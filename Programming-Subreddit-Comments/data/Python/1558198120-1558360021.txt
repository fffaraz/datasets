I'm a bit confused. Since you can call an external module if a standard module is insufficient for you, what is the objection to having a standard module if it satisfies the requirements of most people? I mean, if you moved to PyPI, wouldn't new users be confused about what modules to use and what not to use, a problem mitigated by having a standard module as a base level?
bullshit, read the article
To be fair, I do have the option of starting over with a new group. Unfortunately, my group were the only ones doing what we do, so starting over would truly be starting over, a la another four years. Honestly, I just don’t have the mental fortitude to go through with that. I brought up the prospects of working remotely, but my PI refused on the grounds that they would be unable to “properly mentor” me. Mind you, their entire contribution to my project thus far has been money. I guarantee that they don’t understand the math or physics or code behind what I’m doing, and are inadequately equipped to “mentor” me anyways. They just don’t want to make remote work, and that is entirely their prerogative; but I digress. I appreciate the concern and advice!
This is fantastic advice. Thank you very much!
Sure I'll try n let you know.....
&gt;Rtfa. Her whole talk was just a rant and she offered no solutions. RTFA, she did offer solutions, which were then discussed. &gt;Nick Coghlan interpreted Brown’s proposal as generalizing the “ensurepip” model to ensure some packages are always available but can upgraded separately from the standard library, and he thought this was reasonable. &gt;Van Rossum was less convinced. He asked again, “Amber, what is your point?” Brown said her point was to move asyncio to PyPI, along with most new feature development. “We should embrace PyPI,” she exhorted. Some ecosystems such as Javascript rely too much on packages, she conceded, but there are others like Rust that have small standard libraries and high-quality package repositories. She thinks that Python should move farther in that direction. 
My problem with PiPI is that there doesn't seem to be any quality bar to publishing on it. Lots of crap. Maybe some malware? Hard to know. Download a package with a couple of dependencies, each with a couple more dependencies, who knows what abandoned code you'll get that had changed ownership several times? At least the standard library has some level of quality assurance.
Assert is a statement, it allows to be easily removed at compilation time when you run python with optimizations.
 &gt;I mean, if you moved to PyPI, wouldn't new users be confused about what modules to use and what not to use, a problem mitigated by having a standard module as a base level? I think her point is that the tradeoff you're making there is that new software ends up being built on top of worse libraries just because the worse libraries are in the stdlib.
thanks mate
But in the browser
Her arguments feel kind of hit-and-miss for me. I definitely agree with her that there should probably be some kind of way to get python without certain parts of the standard library like tkinter, and that modules should come with things that make sense, e.g. typing should come with mypy. It’s easy to deprecate support for python 2 for libraries: just add a warning and stop supporting it after some version—see sklearn’s lack of support for python 2. Red Hat won’t keep python 2 alive indefinitely because eventually things will stop working, and refusing to update code yourself just adds to the problem. Rossum is completely correct in his challenging of her point, IMO. Her approach of removing things from the standard library and pushing them to PyPi is a slippery slope and could easily lead to the same kind of version incompatibility from Python 2 to 3. If anything I think Python should do the opposite, i.e. consider python packages that exist in the wild that are beautifully maintained and ubiquitous to add to the standard library. For example, perhaps it would make sense for the most recent version of numpy to be pulled from their github and included with each build of Python.
she could go way further than that, but even her timid criticism received a loud angry offended response. In reality most part of the standard library is poorly designed, inconsistent, badly written, terribly documented junk that even with python 3 did not improve much. asyncio is a horrible, horrible API that is exceptionally difficult to use correctly, and typing is just amateurishly done. She could've ranted about this for hours more, but what she doesn't realize is that its pointless, if the people in charge where able to comprehend and fix anything about it, they would've already done so years ago. But people are just full of themselves, opinionated, unable to take criticism and tribalistic. What you are criticizing our beloved &lt;X&gt;? How dare you! Don't you know that &lt;X&gt; is perfect. please note that i'm not even gonna bother to read the responses to this message either, consider me \*stormed out of the room\*
python.org can be a good starting point since it has an official tutorial
That's what I do when I need a retry.
To vet quality, I often go to the package page to see how many Github stars it has. I'm not sure if this is the right metric, but it would be nice to get something like this on the search page so I can check the metric at a glance.
I like to make classes to interact with REST interfaces in an obvious manner. It hides all the ugliness of the interface. Then I devolve the classes where needed to be functional style so that I can multithread. This is all based off an ABC, so the interface is defined and I can reuse it across projects. So designing a system like that could probably be a good way to show that you know OOP.
&gt; In reality most part of the standard library is poorly designed, &gt;inconsistent, badly written, terribly documented junk that even with &gt;python 3 did not improve much. You don't think that's a bit harsh? How did Python become one of the most popular languages in the world if that were true? So you're going to insult everything, proclaim it'll never be fixed because all the core devs are terrible, and then preemptively declare you're not going to even bother reading any replies? Yet.... &gt;people are just full of themselves, opinionated, unable to take criticism &gt;and tribalistic. Hmm.....
Thanks
Thanks
Which isn't really true - most new software uses Requests even though it isn't in the standard library for instance.
What kind of stuff do you want to do with python?
Which would then counteract the criticism that people wouldn't know what library to use if there isn't one in the stdlib.
Huh, interesting. Do you think that multithreading is a skill set that would be brought up in an interview? Thanks for your time!
I self learned when I was 14 (VB6), I've been programming for past 14 years, but that doesn't stop me from wanting to learn. Don't worry much about impostor syndrome. https://en.wikipedia.org/wiki/Impostor_syndrome
&gt; Maybe some malware? Hard to know. It's happened. There was an ssh lib that uploaded your private key to some unknown collector.
A static site generator sounds like what you want. There are a few different ones. I quite like Hugo, since it doesn't make any assumptions about structure and lets categories me made easily, but Jekyll is popular too. There are several CMSs that target static site generators, such as forestry.io.
&gt;Van Rossum argued instead that if the Twisted team wants the ecosystem to evolve, they should stop supporting older Python versions and force users to upgrade. Brown acknowledged this point, but said half of Twisted users are still on Python 2 and it is difficult to abandon them. The debate at this point became personal for Van Rossum, and he left angrily. &gt;Nathaniel Smith commented, “I'm noticing some tension here.” He guessed that Brown and the core team were talking past each other because the core team had different concerns from other Python programmers. Brown went further adding that because few Python core developers are also major library maintainers, library authors’ complaints are devalued or ignored. Ok, this has got to be considered pure silliness. You can install old versions of pypi packages with little issue. If someone needs their bugs, they need to stay on 3.4 or 2.7, they can. But there's no reason the language can't progress and has to handcuff itself to bugs. When keywords are snatched (like `true`) it might cause temporary headaches, but such is life. Spring cleaning means you need to throw out some stuff that initially tugs at you, but you're better for it at the end. I mean, she's bitching on one hand, but then says "I like *this* bug. Let's keep it!".
If you present a tightly coupled class that can't be multithreaded easily I would hope the interviewer brings up the question.
Make a github account and start some projects in your public repo. As a hiring manager, I don’t hire programmers anymore at any skill level if they don’t have publicly available code to showcase, or a track record of open source contributions.
Wow, I can’t believe that never occurred to me. Thanks again for the suggestions!
Thank you for your advice! I’ve been working on one large piece of code (a simulation) for quite a while now. Do you think that it would be better to get that extremely polished and post it, or would it be better to have smaller snippets of code that demonstrate individual skills in isolation? Or, to reword, my simulations isn’t currently written in an OOP fashion. I am considering rewriting it to showcase my OOP knowledge, but am not sure if that is the best course of action, or demonstrating individual skills in isolation.
I want to just learn it. I want to be an software developer.
&gt; You don't think that's a bit harsh? How did Python become one of the most popular languages in the world if that were true? I don't agree with the parent, but there are many factors which contribute to the popularity of a language. PHP &lt; 7 was an absolute mess ("poorly designed, inconsistent, badly written, terribly documented") but that didn't stop it from becoming the most used server-side language on the web at the time.
The main choice for font sizes on websites is `px` pixels, or `em`. Pixels are absolute values, while em's are relative (aka dynamic size) Basically `em`s are is based on the browser's default font size. They end up scaling better for mobile clients. https://developer.mozilla.org/en-US/docs/Learn/CSS/Introduction_to_CSS/Values_and_units#Numeric_values If you set the top level font-size to 16px, any child elements would have the equivalent of 1em. If the first one uses 0.5em, it'd be 8px. If that child had another child set to `0.5em` it would be `4px` root = 16px child depth 1 at 0.5em = 8px child depth 2 at 0.5em = 4px There's also `rem`. It will always be relative the top level size. so the same settings would be: root = 16px child depth 1 at 0.5em = 8px child depth 2 at 0.5em = 8px
Valid point. Although I started using requests because I was looking to do something, read a tutorial, and that person used Requests. I mean, if that person had used urllib or something else, maybe I'd not have known about Requests until much later. Anecdotal, I know, but just trying to think of how you'd know when something is \_de facto\_ the standard.
The ELK stack is almost the canonical solution to this problem.
Yeah. PEP 8.132. It was too good to be true.
What kinds of software?
Batteries-included is what brought Python where it is today. She mentions XML - minidom helped me tremendously in the early '00s. Could it be moved to PyPI instead? Maybe, but XML handling is still so common that people clamoured to have ElementTree added not-that-many-years-ago. Python should enable users to parse XML out of the box, in my opinion, in the same way it parses JSON, MIME and so on. If this makes a small number of scenarios hard to deliver, well, tough. You just can't please all the people all the time. The stdlib solves 80% of the problems for most users; the remaining 20% is different for each one - and that's where PyPI comes in. In fact, what is holding back the ecosystem is this insistence that everything should be solved via more and more complex packaging, rather than by improving stdlib governance so that more modules can be added in an easier way (and old ones sensibly pruned). Requests should have been cloned a long time ago, for example, and the same goes for arrow or some other high-level datetime-handling library. This really reads like a rant by a member of a project (Twisted) that is effectively being obsoleted by stdlib and core improvements, while the project is busy caring for a slowly-eroding audience of python2 hardcore users who hang around only because they are forced to. Maybe it would be better to brutally re-evaluate their competitive position and focus on the future of the ecosystem, rather than the past.
I’ve had good experiences with Perch CMS for that type of work.
And assert not print statement as opposed to assert (not(isinstance(print, statement)))
One of the interesting things about Rust is that they have the "Rust Nursery", where many of the extremely widespread and important libraries live. It is not the standard library, and libraries living there can have breaking changes, but it grants them a semi official status.
I wouldn’t necessarily rework an existing project to fit an OOP paradigm if your app doesn’t naturally fit that. Python allows you to showcase functional programming, procedural programming, and object oriented programming concepts. Showing a diverse range of skills is better than having an app that is obviously shoehorned into the wrong paradigm. The other folks that have suggested putting together a quick Flask or Django app might help there as web technologies pretty extensively use OOP concepts, but maybe you don’t want to do web development. Painting with a bit of a broad brush - DevOps tools and infrastructure roles focus less on OOP and more on procedural scripting. Data Science roles have more functional concepts. What do you want to do career-wise?
One could assert that print statements serve a similar purpose, to be yanked later and replaced by logger.log
Website is not mobile friendly. It automatically redirects to a scam ad that you can't get out of easily.
Strange, am on mobile and that wasn't my experience. The article appeared fine
Why not just have an app that fetches some uniquely identifiable info for each student's phone to register and then when they open the app it connects to a server that's only hosted on the schools LAN so they have to be connected to school WiFi, and transmit said info to say the student is in. You could produce a fingerprint using the phone number, and possibly either device or user specific information, simpler, more reliable and less resource intensive implementation.
Thank you again for your time and the quick response. Yeah, that makes a lot of sense. As it stands right now, the simulation would actually lend itself to being written in an OOP fashion. There are several classes that immediately come to mind that are direct parallels of their physics counterparts. Career-wise, I would love to continue doing science. I’ve been looking into several jobs at various startups and universities that focus more on modeling interesting physical phenomena (polymer aging, plasmas, etc.), which is where my experience and knowledge lie. Unfortunately, I’m getting married soon and moving, so beggars can’t be choosers when it comes to jobs! I have developed a strong base in numerical modeling, sparse linear algebra, big data, coupled differential equations, etc. (insert other math and physics keywords here lol), and would love to be able to continue using that knowledge in a scientific/engineering-oriented way; but I am not against learning web development if that’s what it takes to get a job ASAP. Luckily, my fiancée’s PhD project is going fantastically, and I want to do everything that I can to support her seeing that through to the end.
Outside dependencies are not the only problem, versioning is another one. If a bug is fixed in say asyncio, there is just no way to depend properly on it. Her argument is that you should be able to upgrade libraries without upgrading python.
[Codecademy](https://www.codecademy.com/catalog/language/python)... you don't get a certificate or anything, but if you're just interested in learning it, then check it out. That's how I learned python, by first understanding the structure from a basic course and then experimenting on my own
Mostly image processing and AI.
Thanks a lot. That is what exactly i'm looking for.
&gt; IMHO, rip off the band-aid. Don't allocate the efforts of Python developers to other people's technical debt. Agreed. Otherwise it's a chicken and egg situation. The developers that haven't updated by now won't do it unless they're forced to, so that's what needs to be done. It's not like anyone can legitimately say that they haven't been given enough time to transition. IMO it's comparable to how Microsoft recently released a patch for a critical exploit to Windows XP/Server 2003. Those OSes have been officially unsupported for five years now, anyone who hasn't updated by now isn't going to unless they're forced to. Leave them vulnerable and give them a good reason to get off their lazy asses.
Does your university have career counselors? I know it can feel more geared toward undergrad studies, but never underestimate to value of a good people-network in finding a job. Make an appointment before spring term ends and everyone dissipates.
They sure do. I actually have an appointment set up next week! Great suggestion.
&gt;You don't think that's a bit harsh? How did Python become one of the most popular languages in the world if that were true? Not OP, but I would say because the language itself is great. The stdlib just leaves a \*lot\* to be desired. And to python's advantage, it's easy to get around because importing packages is simple
But the two approaches are not exclusive. Typically one uses stdlib to start with, and then moves to alternatives when that's not enough. By then, one knows enough to be able to deal with the additional complexities of package management, and can focus on obtaining the specific additional functionality s/he needs. By forcing people to hit Pip right away, instead, you end up in the npm mess -- where everything one needs is in some random module that may or may not have decent documentation and may or may not conflict with other stuff. To me, Python hits the sweet spot by having solid stdlib for the most common cases, coupled with decent package repositories for the rest. When a module is found to be particularly useful, it should be cloned into stdlib. When a module is clearly obsolete, it should be deprecated and eventually moved to PyPI. That's the model that got Python where it is today, why fix what is not broken ?
Yeah thats a good idea, can u suggest some resources for it.
Don't get me wrong, I think Rust is doing a lot of things right (still trying to learn it properly) but aren't the principles of Rust and Python quite different? (Also, quite a few of the repos in the Nursery seem to be docs and archives?) Might be off-base here, but a small std lib would be quite important for Rust's goal to be a systems language as performant as C, right? Python isn't going for the same goal so having more features available on hand might be more suitable? Although crates.io and cargo do seem to make the point of availability moot, having it in the std lib seems a friendlier decision, in my opinion.
I feel like there has to be a balance though. PyPI is great, but there's no oversight at all. Anyone can upload anything to PyPI. If a developer or organization is paranoid about using open source tools, the core libraries of any language can be assumed to have passed through a fair amount of oversight to be included. I've worked on projects where every single 3rd party package had to go through a separate internal vetting process, which meant that we stuck to core libraries as much as possible. The strategy proposed here would basically turn python development into a non-option for paranoid businesses like this, and I don't think it's fair for the dev community to just say "well, you're being too careful and should just trust that popular packages are safe because enough people are combing through their codebases."
Google's cross platform app dev? An SQL database (sqlite?). And a language of your choice to write a server in that can communicate with your schools existing infrastructure for taking the register (if it's anything like mine that's a no go)
I can't speak for anyone else, but for me personally this is the only portrayal of the interaction I've read. I think it's important to recognize that the author clearly sides with Brown here and consequently Guido's portrayal might be unfair or at least biased by the author's perspective.
As a newish Python dev trying to fully embrace the latest and greatest, I definitely get this taste of batteries included that I haven't in other ecosystems, but I also definitely feel the pain of the leaks. And every time I dig into that pain I realize either 1) this is a relatively new thing I'm working with or 2) this is stuck in limbo with Python 2. I do represent the large conservative enterprise side of the house as well. It is very unfortunate that for sane handling of certain basic concepts I have to turn to PyPy where I can't be sure to trust what I'm getting. Yeah Rust might be doing it well but I do not at all feel that PyPy is anywhere close to that and I think the better option is to forget about Python2 and incorporate some popular projects e.g. Requests into the standard. Finally, I hear the issue of stdlib is too big or whatever but what is the % of users that actually need it to be slim vs the % of users that actually need all the batteries available without fuss? Make some way to trim things down for those who need it but fix the leaks for the rest of us. I have several packages that I _always_ install even if I don't necessarily need it immediately because I just think the chances are too high that I'll need it eventually and the pain is too high of doing it later.
&gt; The stdlib just leaves a *lot* to be desired. But the point then should be to improve the stdlib, not killing it. IMHO there is just no argument to kill the stdlib, it's one of the best elements of python-the-language: one install, and you can send emails, parse csv, etc etc etc. Her problem seems to be that the stdlib now effectively competes with her project, and her project refuses to move where Python is going (i.e. dropping py2). That's her problem more than a Python problem, imho.
Because of its regularity, our project chose to use OOP to run a large scale EMR ETL application. The application has many sections and having a consistent class structure makes them more managable. Also, using OOP plus packaging makes for a consistent style with a front-end centric Flask apps that use SQL Alchemy. We also use unittest TestCase which is an OOP style so all this fits together naturally. And its easier to read the code. I think that last attribute: "easy to read the code" makes it more maintainable by a team and so is worth developing a consistent style. Cheers, Rich
&gt; hilarious I don't think that means what you think that it means
In theory, but I haven’t tried it. That would make the simulations a lot more interesting/flexible, though.
Yes, but only on gentoo
\&gt; But the point then should be to improve the stdlib, not killing it. I totally agree and don't think this is about competition with twisted, I think it is more that new, interesting features are being added to the language, but bad and increasingly unidiomatic ones (e.g. socket programming is still basically a bunch of methods with C style flags) are not having bugs fixed or being improved for fear of breaking backwards compatibility
this. I fucking hate the nodejs/npm environment.
r/learnpython
You da man!
Backward-compatibility is the curse of popularity. I think we saw the worst of it with py3: some people will never be happy with change, but at some point a project has to draw a line “and be damned”.
get back to streaming AL!!!
&gt; By then, one knows enough to be able to deal with the additional complexities of package management [...] By forcing people to hit Pip right away, instead, you end up in the npm mess Well-put. It's a kind of unenumerated language feature: "Good-enough standard libraries that newbies aren't forced to pick up dangerous foot-guns."
 \[Hiring\] Python Developer for FPGA SmartNIC Developement Framework - Paris, France **Who we are :** Enyx is looking for a Python developer to join its Paris, France devops team working on our FPGA development frameworks that provides all building blocks, development flow to all our engineers working on products. Enyx is an innovative company specialized in FPGA accelerated applications and designs products providing high performance and low latency data processing for the Financial Services Industry and the smart datacenter. The company is based in Paris, New York, Hong Kong and Chicago. &amp;#x200B; **Requirements :** At least 2 years of professional experience using Python will be required. An interest for FPGA technologies, Low level software( Libs / drivers) , Performance optimization techniques or embedded electronics is preferable to really understand what's going on. This framework is the cornerstone for all our internal product engineering by providing the flow to develop, simulate, validate and synthesize FPGA firmwares for SmartNIC products and is also commercialized as a product itself to enable third parties to engage in FPGA acceleration development. The job offer (in French) : [http://www.enyx.com/careers-offer/?id=ENYX-INT-2019-FRAMEWORK-DEVOPS](http://www.enyx.com/careers-offer/?id=ENYX-INT-2019-FRAMEWORK-DEVOPS) It is not required to speak French. English is our working langage. Please send applications to [careers@enyx.com](mailto:careers@enyx.com) or contact me directly via PM for any question about the job.
Only when prompted and again her talk was mostly "this is shit". Instead of "wouldn't it be best if"
I'm automating my twitch stream setup! As in totally automating the stream where i dont need to stream anymore. Playing iron iv games continually (the lowest end of the league ranks) by pulling spectator data from the league api. interacting with the league client via directinput. And then displaying the endgame stats for each game. &amp;#x200B; This is also tied into a twitchbot which viewers can make bets within the first x minutes of which team they think will win. The hardest part was getting the league script communicating with the bot script. &amp;#x200B; Of course, nobody likes silent streams so the bot has a basic spotify api integration and plays requested tracks with a rudimentary queueing system. &amp;#x200B; Its been a bloody great week!
What are you trying to do?
Find the length
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
What are you trying to accomplish with this?
Because: you posted this in /r/Python instead of /r/learnpython you didn't read the sidebar you posted a picture of code you didn't explain what you are trying to do etc.
len(x) is korrekt for finding the length. The problem is you have written x in front of the function.
Feel free assume I don’t know what I’m doing if that makes you happy.
&gt; consider python packages that exist in the wild that are beautifully maintained and ubiquitous to add to the standard library The problem with this is that you can *never* update them. In the real world, most people don't get to pick the version of the python interpreter, but they usually can pick any version of third-party libraries.
`x len(x)` is in fact invalid syntax. The additional `x` in front of `len(x)` is the problem. To get the length just type: len(x)
and read the sidebar/wiki when you get there.
It's years after Perl6 came out, and the majority of stuff is still Perl5. Go figure that language-breaking changes will be slowly adopted.
That's a *fantastic* point. Probably a better approach would be not to add them to the standard library, but to bundle them with the python installer, sort of like the Anaconda installer
It's years after Perl6 came out, and the majority of stuff is still Perl5. Go figure that language-breaking changes will be slowly adopted.
I used to believe that the standard library was one of Python's strongest assets, and I guess I still kinda do, but she raises some very strong points. For me, though, dataclasses and the like are still very important, because it allows me to easily write one-off scripts with zero dependencies (except Python itself of course) that I can easily deploy in different places should it be necessary without a setup.py or a requirements.txt or a virtualenv or anything. If Python package management from the side of application code was a lot smoother\*, especially out of the box, I would definitely be more in favor of having most packages in the 3.7 standard library on PyPI in the future. Right now, I don't know. \*This is clearly a pipe-dream of mine and has a ton of practical downsides (including potential security risks due to typosquatters), but imagine if the `python` binary came with a `--auto-deploy` option that automatically set up all the right dependencies. I would immediately `alias py="python4.0 --autodeploy"` on all my boxes and whenever I plonk a script in there I can run it with `py somerandomsimulationorwhatever.py` and not care about installing it locally or running pip or whatever.
&gt; typing should come with mypy. Wouldn't that require almost any library that wants to supply type hints in case its users use mypy to depend on mypy, even if the user doesn't actually want to use it?
&gt; My problem with PiPI is that there doesn't seem to be any quality bar to publishing on it. Isn't that utterly obvious? All you need to publish on pypi is to create a user account.
I don't believe so, because it's an optional type checker. As far as I'm aware, you have to manually run the type checking separately from the program itself.
&gt; I'm not sure if this is the right metric Very few people vet code in details, so all it tells you is how many people have starred the code, not why they did, and whether the package is good or the maintainer reliable.
Python 2 is not dead. It is sad, but I have not been able to find the budget for the two or three weeks of development that it would cost to move our projects to Python 3. All new projects are written in Python 3 and use lib3to6 for backward compat if required, but it will be a while before it can be dropped for the older projects, regardless of how many warnings \`pip install\` is blaring at us.
Seems it's not obvious to the author of this rant as she says python should just move more stuff from the standard library to pypi.
I mean if you want to provide type hints as a library, for example this silly example: from typing import Iterable def is_palindrome(v: str) -&gt; bool: return v == v[::-1] def contains_palindrome(it: Iterable[str]) -&gt; bool: return any(is_palindrome(v) for v in it) Now this library depends on `typing`, which, if it is part of mypy, now means it depends on `mypy`.
Tell me about it https://www.theregister.co.uk/2018/11/26/npm_repo_bitcoin_stealer/
&gt;e.g. typing should come with mypy. Absolutely not. There are multiple ways to check types (I know at least 3 projects) as well as typie checking that is included with IDEs such as PyCharm. Any library (including stdlib) to include typing information would now have to include typing as a dependency? From my understanding, she is mostly pissed about asyncio being built in, because raises questions why would you want twisted, and makes it less relevant. Asyncio is just low level library to standardize async programming, because it wasn't present before we now have twisted, tornado, gevent and many different frameworks and for each of them once had to implement async versions of I/O operations like TCP services, http services, database clients etc. Having asyncio being in PyPI it no longer becomes standard, it becomes yet another async framework and only contributes to the problem. The argument she has about Python 2. I don't know under which rock she lives, but Python 2.7 was deprecated 4 years ago, there is no work on it, in few months it will lose support for security fixes. There are already investors that dropped it and ones that promise to drop before 2020. https://python3statement.org/ I know we essentially agree, but wanted to also insert my rant. Python is not ideal, nothing is, but her suggestions would make things worse.
I believe you misunderstood what I was saying. I was basically saying that `mypy` should come bundled with python, not that `typing` should depend on `mypy`. Otherwise I am confused as to what you mean.
Maybe a qualifier for versioning in PyPI or something. Think of it as a "STABLE" tag, except not something that can be applied by the project. So `pip install asyncio` gets the latest stable version, but `pip install requests --psf-stable` gets the PSF approved version for your version of python`. Lets you formally accept a project as "std lib qualified" and certifying a specific iteration of it's code as interoperable with the rest of the standard library (following the set pace of python releases) without having to actually ship it as well as allowing for more frequent (and less rigorously scrutinized) updates between major releases.
The reason I suggest mypy is because (unless I'm wrong) it is made by the python software foundation. My opinion is basically just that *something* should be in the standard library for type checking. As for Python 2 support: I absolutely agree. It's now been 11 years since Python 3 first came out and everyone has had plenty of time to switch over, I just wish people would stop being so hesitant about it.
That's a different problem than the curation issue. Even contributors of Python itself often have this tack, because pypi means more flexible &amp; simpler release management and lifecycles, it also provides for a different kind of support e.g. you can add new features to a library which supports Python 3.2, you can't add a feature to Python 3.2… save by providing a "backports" package through pypi.
Oh, from the context I thought you meant that `typing` should no longer come with Python and be a sub-package of `mypy` instead. In that case, interesting idea, I would like mypy to come preinstalled but I imagine there would be a lot of opposition to including yet another big package into the standard library.
The problems go hand in hand. The curation is a prerequisite.
&gt; The problems go hand in hand. They really do not. &gt; The curation is a prerequisite. The vast majority of users don't care about general curation, they barely care about the curation of what they themselves use.
Well the first step in solving a problem is making it clear it exists. The core developers seem adamant that [the scenario they have is fine, but the building is burning](https://fsmedia.imgix.net/6f/fd/68/f5/211b/43dd/bc62/ce9278275c82/this-is-fine.png?auto=format%2Ccompress&amp;dpr=2&amp;w=600).
who cares, the guy stepped down as bdfl. I also lost respect for his opinions when he came on a podcast where he said he's a fan of women (nothing wrong with that) and would _vote for a woman everytime_. This is a problem obviously because this means he would vote for Marie LePen in the french election or for Angela Merkel in the german one (who said a few years ago that the Internet is new territory (lol)) or for Hillary Clinton just because are female. It's baffling to me the doesnt' understand that this is no better than someone saying he would only let men drive cars or vote only for men. It's sexicsm, just in a now-accepted form. guy should just keep his mouth shut and move on
I fully agree with you the a working example application is the best way to do so and Python is just so goddamn perfect for making a back-end!
I think it's perfectly reasonable to say that these businesses are being too paranoid. You know what's REALLY secure? Typewriters. Can't hack a typewriter. If they want to abandon most modern technological development because they don't trust anyone but themselves, they're free to do so. But that shouldn't hold back everyone else.
Sounds like a pretty big reach for that small statement he made, but hey, each to his own.
Why do you need this? Homework? Ask your teacher.
How can they possibly not use classes for anything more than the simplest of projects?
yeah, the problem is you think it's a small statement but it shows his mindset. he's being illogical which is a problem if you start arguing logical thinkers.
Yeah I can see the ambiguity there. I'll edit my original comment to clarify.
Indeed. Only downside is it would bring down python ecosystem to npm hell level.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Yeah the issues with it seem like an implementation detail rather than a greater design flaw imho
Read the rules, /r/learnpython. Also read the learnpython rules, you should at least have some code to ask questions about.
You are in r/python?
&gt;If anything I think Python should do the opposite, i.e. consider python packages that exist in the wild that are beautifully maintained and ubiquitous to add to the standard library Do not agree. Anything that is in the standard library means that there's almost an official stamp of approval on it. If the library is too complex (like asyncio) or lot of bugs are later discovered then it would require a version update that requires everybody using python (even those who don't use those functionality) to upgrade. Not to mention if a much better alternative is found it becomes obsolete and still remains part of the library for ever. Standard library should only contain those utilities that have the broadest use cases. Anything else should be on PyPI.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Why was U chosen for voltage instead of E?
Like I mentioned in another comment, likely it would make more sense not to add things like `numpy`/`mypy` to the standard library, but to bundle them with the Python installer (or for those who build source, maybe make flags?), akin to the Anaconda installer. A nice bonus to this is that they could also move things that are outdated or have smaller use cases out of the standard library without much disruption.
For the past few years, I've been interacting some with Rust and its community. As Amber noted, Rust has taken the opposite approach of a relatively small standard library and excellent packaging support. There have been some problems with this approach of course, but the community faced them head on by necessity. I can't help but wonder if the batteries included approach allowed the Python community to let problems like the historically poor state of package management, packages of indeterminate quality, and poor package discoverability languish. Rust has been tackling these all straight on, and it's been all the better for it. It doesn't hurt that core contributors often maintain a crate or two, so there isn't the disconnect that is described in the article.
IIRC all attempts had been fruitless to the point of giving up, unfortunately.
“Your mother was a hamster and your father smelt of elderberries” no doubt
This has already been done for `pip` with [ensurepip](https://docs.python.org/3/library/ensurepip.html) which bootstraps pip into an existing python installation. As mentioned in the original article Nick Coghlan thought that a similar approach for other packages (for example numpy) would be reasonable. I agree with that.
better start googling
&gt; He guessed that Brown and the core team were talking past each other because the core team had different concerns from other Python programmers. Brown went further adding that because few Python core developers are also major library maintainers, library authors’ complaints are devalued or ignored. The problem with python3 in a nutshell.
&gt; the project is busy caring for a slowly-eroding audience of python2 hardcore users It's 50% of their userbase. Python3 really only just became a stable production language rather than a lab - I'd say 3.6 was the first really stable release, with compelling features and an end to breaking changes.
Sorry, it's for a project, I have to create and implement a class called student and i need to have 4 things in the class; 1. Name, 2. Student ID, 3. List of classs (4), 4. grades for those 4 classes. It should be able to output All 4 of the items listed and the calculated GPA for the grades.
It's been ten years though. Surely there was time to port over the last decade?
&gt; The stdlib just leaves a *lot* to be desired. Compared to? One of the major selling points of Python was "batteries included".
It’s still the part of their userbase that is not going to grow.
That's the perfect succinct summary of her problem!
Well, we threw Guido into the dungeon after Pascal-style equal sign thing. Still, no one will get behind my push to make Raymond Hettinger the new BDFL despite his having the courage to say publicly that too many things are being added to Python too quickly lately without thinking them through.
There’s a few thing I consider to be etiquette among developers, and there’s a pretty short list of things to avoid if you want to have a good working relationship with your peers. 1. Don’t confuse a bug with a design compromise. Bug has a specific meaning. It’s a defect. It means you done fucked up. It means you meant for A to happen in this case, but B is happening instead. I’m not saying the standard lib is bug-free. It’s not. And I’m not saying the standard lib hits the sweet spot of excellent design compromises. But these are not the same thing. But walking into a conversation and saying, “I don’t like how this works, therefore it’s defective and broken” is rude, arrogant, and completely non-productive. 2. Don’t confuse *your* use-case for the *only* use-case. It is extremely difficult to write tools for even a small group of developers and balance out the different things they all need to do. I haven’t worked on anything that gets used by even a fraction of a percent of how much Python gets used, and even in very small teams, I have to make un-fun compromises to make everything about evenly easy/annoying for my team to work with and accomplish their tasks. Coming into a situation and saying, “This is hit garbage for me; therefore it’s hot garbage for everyone” is, rude, arrogant, and non-productive. 3. Don’t mistake convenience for good design. Or inconvenience for bad. This is sort of like overfitting a predictive model to a dataset. If you design an aspect of a language to fit a specific need too closely, you can have a lot of bad consequences in the future. In this case I’m referring to blowing up the standard library and pushing large chunks of it out to PyPi. If you make it easy to do bad things, people will do bad things. This is t a theoretical slippery slope. We’ve seen where this goes, and I’d like to steer clear of a future that looks like NPM. It *should* be very hard to change the core of your language. There is totally a place for ranting about the challenges in your work. In the hallways, at happy hour, at home, whatever. But if you walk into a meeting and take these kinds of attitudes, I assume you are either too junior to have any grasp of the complexity of the problem at hand or that you are being an intentionally rude, arrogant, asshat. Either way, you are wasting everyone’s time, and I’ve written you off, and I’m probably pissed. 4. Don’t assume you are the first person to think about a problem or that other people are not working on that same problem. Someone told me very early in my career to always assume there was a reason that things are the way they are. It may have been a good reason at the time. Maybe not. Maybe it’s a bad reason now. But it is always 100% worth your time to charitably assume there was a reason, and to find out what it was. You will gain a deeper understanding of the problem you are trying to solve now, what was tried in the past, and—god forbid—maybe even learn something new about how to approach this kind of problem. It sounds like this has never really occurred to her. There’s a lot going in the core dev group. I could maybe see an approach like this being appropriate if the vast majority of the discussion around these issues either a) wasn’t happening at all or b) was being talked about like they are not really problems. But that’s not the situation here. The core devs actively, deliberately, and sometimes passionately talk about the pros and cons of different solutions to these problems. Okay, not the bullshit problem of anti-competition. Otherwise, they do acknowledge they are real, legitimate problems. So I think this rant is a particularly misplaced approach and extremely unproductive. If you want to do this at a meeting—go all in with the ranty, combative style—and go throw a bag of problems on the meeting table and tell everyone that the whole thing is fucked, you damn well better bring an even bigger bag of solutions to the meeting with you too. Not a tiny little picnic basket of half-baked snacks that’s good for you personally and terribly broken for everyone else. I mean, we’re all adults, and we can do whatever we want, but that’s a bold strategy that’s not going to go well for you. Final note about her most “controversial” point. The one about the standard library crowding out innovation. It’s not controversial at all. It’s logically incoherent in the context of the rest of her comments. You can’t argue that the standard lib is a big bag of hot shit that no one can use for anything and then turn around and argue that everyone is using it so much there’s no room for competition. That makes no sense at all. Ultimately, this is probably a good short-term move for her career. There are obviously some politics in play here. There will be a narrative about a woman standing up to all the white men and Guido being such a sexist pig that he can’t even stand to be in the same room. People who criticize her approach (like me) will probably get a little branded as also being sexist and told that we would never critique a man the same way, etc. In the long run? I don’t know. I wouldn’t give a conference talk like that. I wouldn’t even go to a meeting at my own job and act like that. It’s just rude. I know there’s all the stuff about how I’m privileged and I don’t have to be rude to make a point because people automatically listen to me because I’m a white male, and I have no earthly idea what it’s like to be a woman in a man’s world, and so forth. All of those things are true. I don’t know what it’s like for anyone else in the world. My experiences are my own and not applicable to anyone else. But my experience is this: being polite and humble has never held me back in my career, as far as I know. Maybe other people have taken credit for my work. The joke’s on them if they have. Maybe that’s why Bill got fired a while back. I don’t know. But being rude and arrogant has held me back in the past. I don’t recommend it.
I think [`zhuli.do`](https://zhuli.do)`(the_thing)` makes sense, but I had originally thought do.the\_thing() would be another method of do. You know, for shorter and less complicated things that need doing. I'm sure it would all get cleared up in a pep.
That's just madness though - it doesn't work like that in any other language. Java doesn't work that way, C# doesn't work that way, Ruby doesn't work that way. The lesson is to always be using the latest version. If Twisted wants to support Python versions that are no longer supported, they're creating their own problems. It shouldn't be up to the language to change to help them out.
&gt;The reason I suggest mypy is because (unless I'm wrong) it is made by the python software foundation. My opinion is basically just that *something* should be in the standard library for type checking. Yes, mypy is a python project and I'm fact it looks like that's the primary thing Guido is involved. The other 2 are products by Facebook and Microsoft, they are building on top of the type checking work they did with HHVM and TypeScript respectively, but in any case they are completely separate projects that are even written in different languages. The PyCharm as far as I understand it is also separate implementation. I initially thought that it was using mypy underneath, but looks like it is another implementation, but they work closely with mypy to make PyCharm produce the same results. &gt;As for Python 2 support: I absolutely agree. It's now been 11 years since Python 3 first came out and everyone has had plenty of time to switch over, I just wish people would stop being so hesitant about it. Amen, I'm personally thinking that the whole FUD about python 3 was born only because PSF gave too much time to migrate, and no one bothered to do it. The last real Python 2 was actually python 2.6, Python 2.7 was essentially just backporting all python 3 features back, which made people question why should they move to python 3 when it doesn't offer anything.
I’d agree that you might want to question if a matrix is really what you want. I would think a matrix is probably only really necessary if you are wanting to perform some kind of matrix operations on the data you are storing. Perhaps consider using a list of dictionaries or some other suitable collection class or combination of collection classes like that.
I feel like, at this point, if anyone wants to use or support Python 2, they shouldn't expect to have access to new features of any kind. If the Twisted project wants to support two related, yet distinct languages in the same repository, that's on them.
I agree with lot of her points. I believe that standard library should only contain modules with the broadest use cases and libraries which are most stable and well-tested. In particular it is not a good idea to put something on standard library for which there are a number of excellent alternatives available or in an area where lot of developer effort is expected to take place in near future (like concurrency). This is because it is expected that better alternatives would come up which will have to be rejected by the user in favor of the standard library version. Having said all of that I think she could have done a much better job at how she presented this important issue. I understand her frustration as part of Twisted but if you're looking to resolve an important issue you shouldn't rant and antagonize those people who take the final decisions. She should have presented this more logically and objectively.
Or something like docker hub and have packages that are verified.
Well even within python, some packages leave a lot to be desired compared to others. I would give the example of socket vs functools or itertools. Using the \*tools modules can make idiomatic Python, whereas using the former for any length of time just feels like writing C
&gt; The argument she has about Python 2. I don't know under which rock she lives, but Python 2.7 was deprecated 4 years ago, there is no work on it, in few months it will lose support for security fixes. There are already investors that dropped it and ones that promise to drop before 2020. There are also many that just don't have the time / don't want to put the effort in / can't upgrade because of some other external dependency. Python 2 won't die, unfortunately. We'll be writing Py2 code in 2030, calling it now.
&gt; but then she repeated the kneejerk phrase I see here all the time, "The standard library is where code goes to die" It's not a kneejerk phrase when it has truth to it. It's the reason that requests never was put in, and undoubtedly many other libraries as well.
If I were still using Python 2, two very large things would make me switch to Python 3: [This talk by Raymond Hettinger](https://youtu.be/npw4s1QTmPg) because the new dictionaries are fantastic and f-strings Also there's [this website](https://whypy3.com/) which is pretty cool
Python's release cycles are 18 months apart. Probably the most ubiquitous and well maintained "wild" library is requests, which has been known for sometimes pushing out multiple releases in a single day. Also, realize that anyone that wants to embed python in their application or contribute to the core project has to compile *everything* in the standard library, so adding more and more stuff just increases the impediments. But the most compelling argument is that many of the packages in the standard library have superior external counterparts, especially most of the new packages that have been added. Enum and dataclasses are junk compared to competing libraries. But the fact that they're in the STD library means that they're unfortunately going to make their way into a lot of code.
You can update pip, though. That’s the best model: a default version bundled, and a mechanism for updating it if necessary.
That's pretty cool!
Probably make a csv, store everything in it , and average the GPA and then print it
It is a good idea, but potentially someone can carry their 'class bunking' buddie's phone for a free proxy attendance...
How do you figure? If it's the largest part of the python community, then they have room to expand their userbase within the 2.7 user community. You're assuming that python 2.7 (or later) is going away. That's a big assumption, with the weight of the evidence against it.
Python 3.6 is still supported, but only for security fixes. You won't get bugfixes this way. So the issue is somewhat real. Now, I think it's easier with today's deployment methods to strongly encourage using the most recent version. It's fairly easy to treat the whole Python as a library with this mindset.
Not many people will part ways with their phone for a day just to skip school. My personal workaround would be to drop a raspberry pi at school with a reverse proxy so I can connect to the school network from my house.
`ensurepip` is the only standard library module here. `pip` doesn't exist unless you or your vendor installs it additionally.
You took all the fun out of em...
I don't think I agree with your last paragraph, but your first two are addressed in the edit of my comment.
All the growth graps show 2 flatlining or falling, with 3 growing; and of course after January more and more stuff will inevitably break. I don’t think “the weight of evidence” is what you think it is.
True.. Raspberry pi is even cleverer!
[https://xkcd.com/1172/](https://xkcd.com/1172/)
It would probably be easier just to make a dummy package on pypi that has dependencies on all the "standard" packages, locked to specific versions. So you could do something like `pip install python-stdlib` and it would get all the specific versions of packages that are part of the "standard" library.
As a user, I don’t care; my vendor” being CPython, it’s functionally indistinguishable from being a stdlib module.
She's also right that most of the new packages added to the standard library in python 3 are junk and have far superior alternatives -- like enum and dataclasses. There's no reason they should have been added to the stdlib.
Twisted is not obsoleted by the stdlib. That's one of her points, asyncio is useless by itself.
&gt;but XML handling is still so common that people clamoured to have ElementTree added to stdlib not-that-many-years-ago. Yes, but that was before pip, setuptools, eggs, wheels, and GitHub, when usable python packaging effectively didn't exist. That's no longer true. Today, it's trivial to create an open source python package on github, release it on PyPI, and distribute it all over the world. If ElementTree came out today, no one would be pushing to include it in the STD lib. They'd just use it in PyPI.
That's what we're using in Germany when writing formulas with voltages. To be honest, I didn't think about what's used elsewhere. Where are you from? Where is E used for voltages?
I think she's talking more about just supporting the widest array of users. The more stuff that is in the STD lib, the harder it is to support many versions of the python interpreter. If there's a bug in the py35 version of urllib, you can't just tell them to update it like you could if it was an external library; you have to either include a workaround to continue supporting that python version, or drop support for that python version just because of a bug in one or two libraries. Sure, you could tell people to just upgrade their puthon version, but people are often stuck on specific python versions for other reasons, and don't have the ability to upgrade. Telling those people that they're out of luck just sucks, especially if the only reason is because STD lib packages can't easily release bug fixes.
Article was very mobile friendly and didn't redirect for me either.
gotta keep up with the latest version of python. If you don't want to maintain the library, don't. Someone else will.
I mean, just use popular libraries. There are plenty of external packages on PyPI that have higher quality standards that the STD lib.
But that's only because urllib *was so very, very bad*. Look at a lot of the new libraries that have been added to the STD lib in py3 -- enum, dataclasses. They're not *completely* terrible. They'll get the job done, but there are far better alternatives. But now that these versions are in the STD lib, a lot of code is going to use them because they don't know any better.
I’ll write you one and explain the code for $20
&gt;Brown’s most controversial opinion, in her own estimation, is that adding modules to the standard library stifles innovation, by discouraging programmers from using or contributing to competing PyPI packages. Ever since asyncio was announced she has had to explain why Twisted is still worthwhile, and now that data classes are in the standard library Hynek Schlawack must defend his package. Even as standard library modules crowd out other projects, they lag behind them. This really feels like an ivory-tower research professor lamenting that nobody uses the fancy, new technology he developed, even though it's more expensive and nobody really needs the upgrade. They SHOULD have to justify their own existence! Sure, Twisted might have a load of features that are superior to asyncio, but does the average user actually need them? Maybe asyncio is just fine, and easier to use, for most people. If not, then the Twisted maintainers can make their case, and convince users to switch as necessary.
How do you feel about the software that controls flight control systems? Autonomous vehicles? Life support control systems for astronauts? You think systems like these should blindly trust the open source community because a package was pushed up to pypi?
Not for me either
To be fair, the bar for documentation is much higher in the python community. &gt; When a module is found to be particularly useful, it should be cloned into stdlib. Except that then development effectit has to stop, because python only has 18 month release cycles, which is too slow for any decent package. &gt; When a module is clearly obsolete, it should be deprecated and eventually moved to PyPI. Which will never happen, at least until another major release, like python 4, which may be a decade away. &gt; That's the model that got Python where it is today, why fix what is not broken ? It actually isn't. The STD lib started out about where it is today, and has been that size since about python 2.1. there have been a few additions here and there, but there hasn't been much movement of packages in and out of the STD lib.
Looks like the relative shares of package downloads, although noisy, have been relatively stable this year, reaching approximate parity. https://pypistats.org/packages/__all__
You can add an "interactive shell" kind of thing relatively easily with [PySimpleGUI](http://www.PySimpleGUI.org). Here is a [repl.it](https://repl.it) so that you can see the code running and play with it without installing anything on your machine. [https://repl.it/@PySimpleGUI/ShellCommandRealtimeOutput](https://repl.it/@PySimpleGUI/ShellCommandRealtimeOutput) In this case I'm using the plain PySimpleGUI (tkinter based). You can also run it under Qt by importing PySimpleGUIQt. If you do that, then you'll need to change the Output Element to use pixels instead of characters.
&gt;Van Rossum argued instead that if the Twisted team &gt;wants the ecosystem to evolve, they should stop &gt;supporting older Python versions and force users to &gt;upgrade. Brown acknowledged this point, but said half &gt;of Twisted users are still on Python 2 and it is difficult to &gt;abandon them. The debate at this point became &gt;personal for Van Rossum, and he left angrily. 
&gt;For me, though, dataclasses and the like are still very important, because it allows me to easily write one-off scripts with zero dependencies How important is that now though? These days, it's trivial to include dependencies and install them via pypi. I could see that being a valid argument 8-10 years ago, but not today. Python packaging still has a lot of warts, but it's nowhere near as bad as it used to be.
&gt;It's not a kneejerk phrase when it has truth to it. There's as much evidence for this as there is for Bigfoot. The typing module continues to be improved, after Pathlib was added it got several improvements and **the rest of the standard library refactored to accept Path objects in lieu of strings**, etc. &gt; It's the reason that requests never was put in Reitz' ego is why Requests was never put in. There's no reason not to add Requests or a Requests clone today.
The classic "I don't have a problem with women _but_..."
I'm afraid your phone is infected.
&gt; that was before pip, setuptools, eggs, wheels, and GitHub, when usable python packaging effectively didn't exist. Wat? PyPI was already well-established, ET made it into she stdlib in 2005/2006, PyPI started in 2001/2002. It was a pure-python module to begin with, so wheels weren't even necessary. &gt; If ElementTree came out today, no one would be pushing to include it in the stdlib Like nobody has been pushing to get Requests. Oh wait...
First high severity exploit after January and it's gone. Once a security team dubs it not usable companies will migrate off, same as old versions of windows.
[https://www.reddit.com/r/bashonubuntuonwindows/comments/82qif4/using\_anaconda\_on\_wsl/](https://www.reddit.com/r/bashonubuntuonwindows/comments/82qif4/using_anaconda_on_wsl/) &amp;#x200B; You're welcome :)
Feels like yesterday when 3.x downloads were less than a quarter than 2.x, "proof that 2.x isn't dying"... the gap has closed. A slow death is still death.
Many other libraries, such as Requests, Arrow, BeautifulSoup, etc., exist and thrive despite the standard library because they are either higher level or add useful features.
My goal for today is to finish the Flask GUI for my personal data analysis platform. The whole platform has been about a year in the making. Once I plug in this last component of the Flask app, I will clear my databases and start pulling some real data to run studies on! I'm pretty excited. I've been dreaming of this moment for several years, and it's finally here! The sky's the limit on this. I plan on using this to develop and test out data science models in a variety of different fields. My platform will make this whole process far easier and more reproducible and organized than the current industry practice of sticking every pipeline and model into a giant Jupyter notebook attached to a chron job.
Uh, not useless to me. I've used transports, fairly cool for what I needed. Got the job done pretty quickly and with minimal fuss, whereas Twisted... eh.
Why not try using the tools in vanilla Python? Install Python for Windows, and then use venv for your virtual environments. If things get too messy, you could instead containerize in Docker.
&gt; Except that then development effectit has to stop It doesn't. Typically, you get "package2" efforts for the experimental features, that can then slowly move to stdlib when mature. &gt; 18 month release cycles, which is too slow for any decent package. Weren't you pushing python2 in another thread? And 18 months is "too slow" now? &gt; [deprecation] will never happen, at least until another major release That is a problem of governance. And it's not true anyway, there are plenty of deprecation warnings and things do get purged eventually. It's just that there isn't a formal process to follow, every package is (more or less) left free to set its own deadlines, and there is no "graveyard". Maybe it could be useful to have a formal process where any deprecated package can only last a maximum of 2 dot-releases in "deprecated" state before being forcibly ripped out and moved to PyPI.
It's important in the Language Wars. I know lots of people who brag about being able to statically link all of their dependencies into one big EXE and just distribute that. They freak out at the idea of having to install Python (the right version) and then install a list of dependencies.
&gt; It's 50% of their userbase. Then their user base is a base of fossils and they shouldn't worry about what's in the current standard lib because they're appealing to the crowd who never plan to leave 2.7. &gt;I'd say 3.6 was the first really stable release I started using Python in 2012 and Python 3 was never unstable for me.
I did some preliminary research last year for a project that didn't get funded and I concluded also that pybind was the best choice for simply glueing existing C++ code into Python. However, I never actually did it, so I can't tell if you my conclusion was right.
&gt; If it's the largest part of the python community Python 2 is not the largest part of the python community and hasn't been for several years. Python 3 usage surpassed Python 2 years ago. &gt;You're assuming that python 2.7 (or later) is going away. It dies at the end of the year.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
https://www.webucator.com/blog/2016/05/python-3-surpasses-python-2-on-stack-exchange-april-2016/
Okay, sure, there are some cases where the paranoia is justified. But in that case, they should deal with the overhead of that paranoia internally. Have that bureaucracy to justify and scrutinize any new package. Freeze the versions. That certainly shouldn't hold back everyone else.
There's no reason to push out multiple Requests releases in a single day. Or any new updates; it's done. Same with date and time libraries; we're not getting a new calendar any time soon.
&gt; anyone that wants to embed python in their application or contribute to the core project has to compile everything Uh, no...? I'm pretty sure there are compilation flags to strip out at least some of the stuff, and the build scripts do work even if some libraries are not there for stdlib modules. Micropython seem to manage just fine.
Things that are done and not evolving should be in the standard library. There's no reason not to have Requests-like functionality or a high-level date/time unit.
&gt; She's also right that most of the new packages added to the standard &gt;library in python 3 are junk and have far superior alternatives -- like enum &gt;and dataclasses. If they had superior alternatives their functionality would have been borrowed by the official versions.
&gt; PyPI was already well-established I mean, yes, it existed, but it wasn't trivial to use. Pip didn't exist. setuptools was still very much beta software back in 2005. Easy_install may have been around, but it worked about as often as it didn't back then. &gt; The problem it's that it's less trivial for new users to download it, What? No, it's extremely trivial. Pip and setuptools come standard with python now. It's literally just `pip install package`. It easier than installing python itself. &gt; and there is no quality control whatsoever Spoken like someone who has never worked on a popular python package. Many of the most popular python packages have far better testing and quality control than the standard lubrary., And far more developers actively working on them. &gt; Like nobody has been pushing to get Requests. Oh wait... Nobody who matters. No one who is serious. None of the python core team, none of the requests maintainers, and no one who really depends on requests wants it in the standard library.
As a student who's worked with both Python and JS, I must say that I much prefer the batteries included approach than a 250 MB node_modules folder.
Definitely seems like 3.5 is being forced out
If only I had the time, but alas I can only be grateful for great minds as yourself taking time to illuminate the darkness of my suffocating ignorance. Without such deep and thoughtful responses it would be as if there were no truth to be had.
Did you check the new [shiboken2](https://pypi.org/project/shiboken2/)?
Yeah, I need to downvote this twice, so I’m commenting for emphasis. I work in finance. Most of my work is wiring that moves money around between banks and accounts. Credit card auth/settlement and check processing. My paranoia about what’s in my dependency stack is your ability to remain blissfully unaware of just how fragile and broken our financial infrastructure is. You do not want me to just use any old thing to get the job done because it has a nicer wrapper than the language built-in. You most definitely do not want your rent check to get processed twice because of a bug in a package we didn’t take a close look at. And you absolutely do not want a malicious actor to target the industry in a common utility function and siphon off small amounts out of your bank account for each transaction because it happens so far below the level of normal banking operations that it looks legitimate to everyone involved. People can skim money off everything you buy and it just gets hidden in the transaction processing fee structure. I just realized I sound like Jack Nicholson in a few good men. “You want me on that package manager! You need me on that package manager!” Lol. Downvotes accepted for this little bit of self-important hobgoblinry.
&gt; it's trivial to include dependencies and install them via pypi. Which is why we'd never see people flaming over that sort of tools, like pipenv. Oh wait...
&gt; PyPI was already well-established I mean, it existed, but it wasn't trivial to use. Wheels and pip didn't exist. Eggs weren't well known. Setuptools was still very much beta software,. Easy_install may have been around, but it worked about as often as it didn't, but it didn't matter because most of what was uploaded to pypi at that time was sdist tarballs that used distlib, so dependency resolution didn't work anyway. Installing any library from pypi meant resolving and installing dependencies by hand. And god forbid a library or dependency had a c component, which elementtree did have, and although they weren't necessary, still prevented you from building the library from source. &gt; The problem it's that it's less trivial for new users to download it What? No, it's extremely trivial. Pip and setuptools are installed with python now. It's literally just `pip install package`. It's easier than installing python. &gt; Like nobody has been pushing to get Requests. Nobody that matters. No one who's serious. None of the core developers, none of the requests maintainers, no one who really depends on requests wants it as part of the STD lib.
I'm using pybind11 in a personal project and it's working really well. I haven't come across any problems with it yet. The documentation is really good, too. Something that isn't really talked about (or maybe I missed it) is the directory structure of projects using it. For me, the structure was as such: myProj (root dir) bin {execution files, ie launchers, etc} build {cxx build files} modules libs {pybind shared objects} myProj src test cxx\_dir1 bindings src test include cxx\_dir1 &amp;#x200B; cxx\_dir1 is one of several other directories c++ directories containing header and source files. They also include all the binding code needed to generate the pybind bindings. The build directory is fairly self explanatory. It's the folder where I enter the command 'cmake ..'. The modules directory contains a few sub folders. libs is where I place all the shared objects that are generated from pybind. Using cmake, I just specify the LIBRARY\_OUTPUT\_DIRECTORY for the library generated by each 'bindings' folder under every c++ directory. The myProj sub subfoler and subsequently the src sub folder contains all the python source code. These folders can then import modules that live in the libs sub folder. The bin folder contains all the entry points for actually executing the code. For example, my project uses qt for a gui, so this folder contains the launcher for the gui application.
But then that's on you. Do your homework before using a new package.
I agree that it would be preferable to refactor like /u/sharkiteuthis is saying, but if it comes in handy, you can use Python pickle to serialize figures to a file in many circumstances.
&gt;Typically, you get "package2 That's not typical at all. The number of popular packages that have spawned a popular `package2` I can probably count on one hand, and of those, having changes that made thwir way back into the original package is basically non-existent. &gt;Weren't you pushing python2 in another thread? And 18 months is "too slow" now? Just to be clear, I'm not advocating python increase it's release schedule. I'm just saying the release schedule for a programming language is much slower than nearly every python package. The same is true of the release schedules for OS's. I wouldn't want the version of `requests` that I use be tied to the version of Linux or Ubuntu I'm using. &gt; there are plenty of deprecation warnings and things do get purged eventually. I'm pretty sure nothing that was deprecated in py2 got purged until py3, and even then, they ended up walking back a lot of the deprecations and left them in py3 anyway. Again, the schedule is fine for a programming language, but it's too slow for most python packages.
&gt; god forbid a library or dependency had a c component That has been a problem until wheels, yes. Which is basically why anaconda even exists. But it was not a problem for pure-python libs, which are typically the majority. &gt; still prevented you from building the library from source. I personally don't remember ET ever being a problem to install. LXML, on the other hand... &gt; No, it's extremely trivial. It's trivial to install *a* version that *might* work, *if* your python is installed in a certain way or *if* you are using virtualenvs, *and/or* you have certain rights on the machine. Explain all that to a 10-year-old who just wants to make stuff in minecraft, and then come back. And of course, you then have to care about versions in your build scripts, and you end up with pipenv or poetry, and now you have more problems... Stdlib module? Works out of the box, always. &gt; Nobody that matters. Guess so, if users don't matter.
&gt;Uh, no...? I'm pretty sure there are compilation flags to strip out at least some of the stuff, I mean, only if you want to embed a version of python that doesn't work with anything because it doesn't include any of the standard modules.
I've updated my zsh functions with a python script to populate `pyproject.toml` requirements from the `.*requirements.in` files (alias `pypc`, for "pyproject compile"). This way reqs only have to be hand-specified in the `.*in` files (optionally constrained), which programmatically feed the (precisely locked) `.*requirements.txt` files as well as the `pyproject.toml` file (matching original constraints). The reqs are categorized in groups in pyproject.toml based on the filenames of the `.*requirements.in` files.
Let me get this clear: you want a python without some stdlib modules, but that works with everything that relies on those stdlib modules.
Seems like a tautalogy -- "if something isn't in the stdlib, it isnt better, because otherwise it would be in the stdlib". Requests is clearly better than urllib, and yet, it's API hasn't been adopted by the stdlib. There are no less than half a dozen enum libraries that are superior to the stdlib version. There are plenty of dataclasses-style implementations that weren't implemented with typing that are all superior.
The time I started even considering a port was around Python 3.6 which was about three years ago. Everything before that did not seem worth it and for the very early versions a good approach to porting hadn't even been established yet. If it were up to me I'd have done it some time in the last three years, but organisational dysfunction is what it is.
You may want to scan your phone
If a library depends on something, I want them to have to declare that dependency explicitly, rather than just expecting it to be installed in the stdlib. I realize it will be difficult to reduce some of the stdlib, but at the very least, we can stop adding to it.
&gt; There's as much evidence for this as there is for Bigfoot. That's not true. The `subprocess` module is clunky. So is `threading` and `multiprocessing` to an extent-- it got "updated" with `concurrent.futures`. The XML modules are now unnecessarily slow in comparison to modern 3rd-party parsers which have equivalent APIs. `json` *can't* be updated as fast as `simplejson` (though this one hasn't been as important of an issue as of late). &gt; The typing module continues to be improved, after Pathlib was added it got several improvements and **the rest of the standard library refactored to accept Path objects in lieu of strings,** etc. If that's your evidence to the contrary, it's like saying a racecar driver probably likes his car. He probably doesn't like some of the competitors' cars. `typing` is the literal baby of Guido and Dropbox. Antonie Pitrou is the core dev who generally, in completeness, contributes to pathlib. That's *his* baby. &gt; Reitz' ego is why Requests was never put in. There's no reason not to add Requests or a Requests clone today. Reitz, Brown, I, and even come core developers agree that the standard library is where code goes to die. And if you've been around here you'd know I'm not here to defend Reitz-- some people here even think I have a "vendetta" against the guy. Unfortunately an egotistical opinion doesn't automatically become incorrect.
that's a very good point that I'm ashamed I didn't think of
mypy is extremely opinionated about how you *ought* to use classes. It incorporates strict adherence to Liskov Substitution Principle and throws if you violate it. Engaging in that obviously kills an aspect of Python that tons of people love: duck typing. There’s a huge spectrum for type checkers to exist between nothing and fuck-you-this-is-Java-now,-bitch. Leaving mypy out is absolutely the right choice.
&gt;Batteries-included is what brought Python where it is today. Python was born in an era where the internet was not as ubiquitous and neither were good package managers for programming languages.
The main reason people are mad over pipenv is the same reason they're mad about asyncio -- because *a single library* was blessed and pushed by the core group (either the PSF or PyPA) when there are alternatives.
Really? MS recently sent out patches for XP and Server 2003. Companies still use those! These editions were supposed to reach EOL ages ago, but laziness of companies won out in the end. I unfortunately see the opposite occurring-- Python 2 will survive the security issues, companies who will rather patch it themselves instead.
TLDR; Python does it for you, if you want to handle it better you should just learn a lower level language
&gt; I wouldn't want the version of requests that I use be tied to the version of Linux If requests was mature and stable enough that it made little difference which version you had, you just wouldn't care. That's why tons of people stay with the Python their OS preinstalls, rather than using Pyenv or other hacks: because it's good enough for 90% of the job. I bet if we had a request clone in stdlib that covers 90% of what requests does (and possibly some of what it doesn't, like proper multithreading), the download numbers would crumble very quickly. &gt; I'm pretty sure nothing that was deprecated in py2 got purged until py3 Just looking at the release notes of 2.6, I see gopherlib and rgbimg were removed. Going further back I see mpz, rotor, and xreadlines purged in 2.4. It doesn't happen often but it happens. Some modules kept the namespace but were replaced wholesale, like bsddb. In the end, if a lib is there and works fine for most people with minimal maintenance, there is no reason to remove it.
Hmm, I wonder why he removed the part about all the stdlib packages using typography and testimonials.
Time changes all the time. Timezones are controlled by governments and have frequent (as in few times per 18mo release) changes. A reason stdlib does not include timezone lib. It's handled by pytz which is free to release as needed.
Python 3.7.0 was released on 2018-06-27. Today the latest patch release for it is 3.7.3. Suppose in your hypothetical world, it shipped with a high-level date/time library that included useful timezone support. At the release of 3.7.0, the latest Olson `tz` database was version 2018e. Between then and now, the `tz` database has released: * 2018f * 2018g * 2018h * 2018i * 2019a In many years there are nine or ten updates to the `tz` database. Python currently does not update that quickly, and users cannot and will not roll out patch versions of the entire Python distribution that quickly even if they're provided. And having the Python standard library download the latest `tz` is not a workable solution: * Not all Python installations have a network connection * Not all Python users can afford the startup or import-time hit of a download * Not all Python users can afford the cost of breakage if the network connection is interrupted or the download site for `tz` is temporarily down. * Different versions of the `tz` database are, well, *different*, and can cause tests or code to mysteriously break if the time-zone definitions are silently updated: code that was valid for a specific `tz` database version may well not be for a future version. So how would you make this work in the standard library?
I’m not really sure what you’re trying to say. I do my homework, for reasons described above. I don’t want my homework to include having to check the standard lib of my language for errors and malware. You said above that us special needs folks who do things that require stuff to work are holding the rest of the people back. What are you being held back from? What about the standard library moving slowly is stopping you from doing what you want to do?
Asyncio went through a proper PEP. Pipenv was basically smuggled through the backdoor to do a job that most users actually have to do. It's a big difference.
&gt; out of the box To me, PyPi is the box of Python things. It's easier to install from pypi than it is to install CPython.
&gt; Python 3 usage surpassed Python 2 years ago. Not what I'm seeing here: https://pypistats.org/packages/__all__ &gt; [python 2.7] dies at the end of the year. I've heard this story before. And yet here it is, still being supported. I don't think the reasons why support have been extended have ceased to apply. The biggest change is that Guido is no longer BDFL. Actually stopping security patches for 2.7 runs the risk that someone starts funneling funds to a new organisation that will keep patching a 2.7 compatible version. This would be...not good for the Python Foundation.
&gt; Python 3 was never unstable for me. Then you never used strings? Because a bunch of stuff around that has changed through the versions.
&gt; A slow death is still death. We're all dying a slow death. There's a whole lifetime in the meantime.
Bear in mind that package download numbers are inherently untrustworthy because so many of those downloads are CI systems running on every commit. Actual deployments are absolutely lost in the noise of that. When I deploy my own projects, for example, I do so on Python 3. But I maintain a bunch of libraries and I'm committed to supporting Python versions until EOL, which means currently I do support 2.7 even if I don't use it. So every time I push a commit to one of those repositories, the CI will do a full fetch -- on Python 2 -- of all the dependencies. I'd be interested to see what happens after EOL hits when maintainers drop Python 2 support from their testing matrices.
(The role of the nursery has changed; we’re putting stuff in the rust-lang org instead at this point. That said, the library team, which maintains the standard library, also maintains packages that are distributed via crates.io. They used to live in the nursery but don’t anymore.)
&gt;there is no reason to remove it. Well, sure, other than all the reasons I and the OP just listed. Pfff, jeese. &gt;If requests was mature and stable enough that it made little difference which version you had, you just wouldn't care. I mean, that's true for every library... until it isn't. You don't care until you run into a bug, or a feature that doesn't exist in your version. Should those people just be screwed until the next python release? There's just no comparison. In one scenario, there's the burden of having to run pip commands to install extra libraries. Sure, it's slightly more work, *but at least it's a working solution*. In the other scenario, people are basically screwed for 18 months at a time, *or end up having to resort to using pip and pypi anyway* to install a patched version or an alternative. &gt;because it's good enough for 90% of the job That sounds dubious. It seems unlikely to me that 90% of python users are *only* using stdlib packages.
Pure strings have not changed much since 3.0 - they were always pure unicode representations. What has changed is some of the byte handling underneath and compat shims used to make it a bit more compatible with 2.x.
Please consider taking your own advice.
That's a fair point overall, but it also implies that you don't cache packages locally.
The problem with the datetime module is not just timezone support - it's that the whole timedelta interface is pretty bad, even for naive dates. Going back to timezones - this is a problem every stdlib and OS have. Java releases updates every three months or so, and they find it acceptable. A good solution does not have to be perfect.
&gt; end up having to resort to using pip and pypi anyway but that's the point - they don't *have* to touch pypi unless they hit a specific bug they cannot live with, at which point they *can*. Whereas with the npm model, you're thrown in the deep end right away, and good luck if the dependencies *du jour* don't match - you won't even get to find out if there is a bug you may or may not live with. And let's drop this 18-months nonsense - there is a dot-dot-release every 3 months to address the bad stuff. &gt; It seems unlikely to me that 90% of python users are only using stdlib packages. They are not using *only* stdlib, but they are using *mostly* stdlib plus bits and bobs where they really need something more.
User name checks out
&gt; Rust might be doing it well Rust is doing it orders of magnitude *smaller* than Python. Should it ever get half as popular as Python (which is unlikely, considering how low-level it is), they would hit the same problems with "registry quality" that pypi has.
The entire conversation here is so far above my head that I have to go look up things to even begin to understand it. Damn.
&gt; the various different point versions of 3 all have various volumes substantially lower than 2.7 That's an attempt at using first-past-the-post logic. People using 2.x are now effectively concentrated on one or two dot-releases, whereas the 3.x ecosystem moves faster so it gets more fragmentation. Aggregated 2.x/3.x download numbers are substantially tied at the moment. 3.x has closed the gap and will likely leave 2.x behind after January.
It's important enough to me personally to keep doing zero-dep for small scripts. If I do something bigger, sure, I'll get a `setup.py`, fill in the right dependencies and get something proper. But something that's "I just wanna check something real quick" or "I have something on my mind that I want to try before I get back to Being Productive" I don't have any mental bandwidth to spare. Maybe that's just me. If you do know a real fast-and-easy solution for that, please share, I'm dying to know.
I've started using requests, but only because the latest standard library docs literally say you should use it instead of the standard library. IMHO it's a pretty crazy situation when the standard library is cluttered with stuff everyone agrees is substandard.
Old man yells at cloud time: I hate f strings. Zen of python goes: there should be one and only one obvious way to do things. Right now there are at least four ways to format strings: concatenation, c-style substitution, .format(), and f-strings. Concatenation is the most obvious, but is slow as balls (due to immutability). C-style is what everyone has used for decades, so is obvious from programmers coming from c-like languages. .format() will likely vanish caught in the middle. And f strings, while most terse, are perl like and not pythonic at all. So now what do you use?
I am a monkey though.
&gt; but that's the point - they don't have to touch pypi unless they hit a specific bug they cannot live with, at which point they can Well, not really. You can't *really* update a stdlib module using pypi. You might be able to find a patched version with a different namespace that you could use in your own packages, but it won't help any other 3rd party packages you're using. &gt; Whereas with the npm model, you're thrown in the deep end right away, I literally don't understand why `pip` is being treated like some difficult mysterious tool. It's easier to install packages with pip than installing python itself. If someone is capable of installing and running python, I'm fully confident they can figure out how to install a package with pip. &gt; there is a dot-dot-release every 3 months to address the bad stuff. The dot releases will generally fix bugs, but not introduce new features, and may even forego certain bug fixes if it breaks any backwards compatibility (e.g. openssl). Also, from a production standpoint, 3 months isn't really any better than 18, especially when pypi updates are on-demand. &gt; They are not using only stdlib, but they are using mostly stdlib plus bits and bobs where they really need something more. Ok, so then what is the problem with using just a few more "bits and bobs". Obviously, using pip isn't difficult for them.
Just because something is perl-like doesn't mean they can't also be Pythonic. I wouldn't say that it's mutually exclusive. In my opinion, f strings are the best of all the ways to format strings as they are simple, straightforward, and beautiful.
I usually just use virtualenvs and manually install with pip. Most of the common 3rd party stuff is already installed to my system python, so I don't even have to do dependencies or anything for one-off scripts I need to write. If I'm giving a script to anyone else though, or distributing it, I'll make a setup.py, though I use a scaffolder that does most of the boilerplate for me.
Isn't E usually the symbol of electric field . . . While, U and V are for voltage.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
If you aren't doing some dilligence on the libraries you choose to *depend on*, then you aren't doing your job. Is the project active? Does it have sane project governance? Well documented? Can a single person decide to take their ball and go home and break your build process (this would be like the absurd padding library thing in npm a while back). No one is saying ignore "modern" development technology. They are saying "blindly trusting 1000s of dependencies because everything is a 3rd party project" is completely insane.
That’s what happens to any language with a large library included. Then the ones that don’t (include it, like C++) get criticized for that.
Once upon a time, when PyPI was under quite different management, there was an attempt to add comments and ratings. And it was a disaster. The comment system didn't allow package maintainers to reply to comments on their packages. So if someone reported a bug you couldn't link them to your bug tracker, and once you'd fixed it you weren't allowed to tell them it was fixed. The rating system was a basic 0-5, and as all such systems do the ratings clustered on the extremes (and mostly on the negative end). But the ratings didn't come with explanations, so you had no way of knowing *why* someone thought this package deserved a 5 and that one a 0. It might have been as simple as "I tried to use this package without checking the prerequisites, so it didn't work and now I'm mad at that". But you didn't get to know and couldn't do anything about it. PyPI came very close to an all-out rebellion from package maintainers over this. The modern PyPI is run by a different team, and its scraping of star/issue/etc. counts, is much more useful since at least it sends you to a place where there's *some* context available. But any metric PyPI could directly measure probably would not be as useful as you're thinking it would be.
Out of curiosity, and because I'm one of the people, historically, whose PGP signature has been on the releases, do you trust Django? It's not in the standard library, but a lot of "paranoid" organizations have still chosen to use it.
I wonder what the 3.6-specific change is that would cause these libraries to draw the line between 3.5 and 3.6?
My complaint with sqlalchemy is more there is little consistency, more than one way to do the same basic things, etc . Filter vs filter_by. If sessions worked so well why does SQLALchemy expose so much of SessionManager and make it routine you need to do things like merge() db objects?
Not sure how that would help me to produce an app that runs natively on Windows and natively on Mac.
I am not familiar with using virtual environments. Not sure how they would help with me getting all of the packages that I need to install and run on the same environment.
All visualizations made with Python Imaging Library (PIL). Practical examples solved using sympy.
There were *improvements* like using UTF-8 internally if possible which saved memory, adding f-strings, etc. But I've never found Python 3 strings to be "unstable" since I began using it at Python 3.3.
So, I maintain a few Python packages, and have a history of helping to maintain a few more. Some you might even have heard of! &gt; Her problem seems to be that the stdlib now effectively competes with her project, and her project refuses to move where Python is going (i.e. dropping py2). I've got an open issue right now on one of my projects where what I really really need is an RFC-compliant email address parser that can take an addr-spec and return me back the local-part and the domain, as separate values (I need to process them individually to do a check against Unicode homograph attacks). Python 3 can sort-of parse an email address -- `email.headderregistry.Address` will take an addr-spec and give you back local-part and domain. Except, remember, I'm checking here for homograph attacks, and the `Address` class only supports ASCII local-part. I know there won't be a fix for this in Python 3.8. So the soonest anyone could get it into the Python standard library is 3.9. And then I have to wait until I can set that as the minimum supported version. For reference, if a patch were committed *today* to the tree that will become Python 3.9, I might be able to rely on it sometime in the year 2024. On the other hand, if it were in a third-party module with the usual policy of supporting every upstream-supported version of Python, and they added support today, then it'd just be a version increment in my own `install_requires` to get it as soon as they release.
&gt; I literally don't understand why pip is being treated like some difficult mysterious tool. In a lot of scenarios, to use pip you have to know about `--user`, or `venv`, or how to hack your `PATH`, and of course it's different for Windows and Linux. It's trivial once you understand how all pieces fit together, but if you don't, it can be a challenge. Of course, if you are a pro developer, it's not difficult; but a huge number of python users are kids, teachers, hobbyists, students, and even accountants. For them, this stuff is *not* trivial. &gt; If someone is capable of installing and running python A lot of these first-time users just receive python preinstalled. &gt; You can't really update a stdlib module using pypi. You can do it for pip now, and I think that's a good model: bundled default, with option to upgrade. &gt; from a production standpoint, 3 months isn't really any better than 18 It's good enough for Java, come on. &gt; so then what is the problem with using just a few more "bits and bobs" The fact that different people get to them at different times, typically after building some experience of the platform first. Which is why the Python model is so much more user-friendly than npm, and the language keeps growing in popularity despite being completely shut out of the most popular UI platform (browsers) and not having the sort of marketing muscle that C# or Java have. If it went full-npm, it would lose a lot of appeal.
Your phone has a virus. Good job.
This seems like the most promising approach to me: https://www.reddit.com/r/Python/comments/bpp9hg/has_the_python_gil_been_slain_subinterpreters_in/
Rather than force Anaconda to install correctly on windows... Just make WSL a dependency and install your package there. You could additionally reference a package installed on WSL from outside the WSL environment, but that's generally frowned upon and could lead to other runtime issues.
LoK is so good.
As much as I respect your work as a maintainer, you are not the only python user on the planet. For you, setting up a virtual environment or non-privileged-user scenario, fetching a package from a remote registry, and managing dependencies, it's all pretty easy. And it's similarly easy to go find a better email module that covers your very-specific use-case, or writing one yourself. Then you have the kid who gets his python fix on a locked-down school computer. He just wants to send an email, and has enough problems figuring out what an email server is, how to connect, and so on. (Yes, I know `email` is for parsing and `smtplib` for sending, but the principle is basically the same and they would likely be treated in the same way). If you force him to also figure out how to make pip work, you might well lose him for good; instead, it's just `import antigravity`. This is the point that I think is getting lost. Yes, there *are* complex need that the stdlib does not address; but it also solves *a lot* of common cases that would otherwise get hairy. This is why people love python and hate npm: because you don't *have* to deal with the complexity in most cases, whereas node/npm *forces* you to do it. (besides, in your scenario: what if the new release of your email package breaks something else? Which is what happens in Node, and so often...) IMHO Pip currently has the best approach: a bundled version, with the option to upgrade. Should we move all the stdlib to that model? Maybe. But it certainly should remain a "batteries included" experience that does not require big and complex setups right away.
Just stopping by to mention this; I had the same problem and went through thousands of hoops to finish the damn thing. It might not feel good now but it will later that you are pulling the plug. I have similar people around me and we all should have done the same. So in a way you are already better off than us, silver lining and whatnot. &amp;#x200B; Regarding OOP; you don't really \*\*need\*\* it but nice to have enough dose of it.
You seem to be arguing with someone who wants to completely eliminate the standard library. I don't know who that person is, but it isn't me, so I think you may have replied to the wrong comment.
I thought you were commenting in the context of the debate that was set up by the TFA: to have a stdlib completely reliant on PyPI, which basically implies nothing is installed by default. In that context, you saying that `email` should be a third-party module can be read as supporting that view. If that's not the case, you might want to add more detail to your proposal.
There are a few things I disagree with here. For example, you should always use the same database in prod and dev. Use docker if you have to (docker-compose makes this very easy). Second, your “default” settings file should be production. Use environment variables to do specific configuration per environment, like the secret key, debug setting, and others. By all means have a separate dev settings file that imports from production and makes necessary changes. In particular, configuring separate installed apps and middleware (like debug toolbar) is hard to do with env cars, so a Separate file makes that easier. Follow the guidance from https://12factor.net as much as you can.
It's also a much, much smaller community, mostly targeting system developers. The Python community is orders of magnitude larger and more mainstream. This matters, in terms of expectations.
Agreed on the frequency, but no idea how their bugchecking goes. That said, with requests v3, would you want to wait until the next python 3.x bump, or when it's ready? Once they release v3, we'll probably see a flurry of updates, as it's a pretty big rewrite aiui, would those bugs need to wait until the 3.x.1? But Ms Brown *likes* those bugs. She NEEDS those bugs.
I think there's utility in starting a conversation about whether and how at least some parts of the standard library could get release cycles decoupled from the release cycles of the CPython interpreter, and also about whether everything that's currently in the standard library *should* be. In light of which, I'm grateful to Amber for trying to get that conversation going despite the hostile reaction received for doing so.
I swear some people don’t even try to find anything out for themselves
The principles of Rust are different, but \*right now\* for whatever reason, when it comes to libraries and stdlib size and the community and information around these things they seem to a lot of people to be upholding the Python principles better than Python. They don't have the legacy issues that Python has, they got to start from scratch more recently, it isn't a fair comparison obviously. But that model is working better, for Python's definition of better, than Python's has ever worked. We should pay attention to that.
The SQL-in-dev-Postgres-in-prod recommendation here makes me completely discount the whole article. These things aren't drop-in replacements for each other, and recommending one in dev and another in prod is just terrible advice.
&gt; despite the hostile reaction received for doing so. It would probably have been less hostile if she had been less inflammatory. From TFA: &gt; “So I know a lot of this is essentially a rant,” she concluded, “but it's fully intended to be.”
Based how things quickly changed after PSF stopped developement of python 2.7 I'm more optimistic. Several large projects migrated and seems like every time they say that it wasn't as bad as they thought it would be. I think all that's required is prioritizing that tech debt. Since many packages already dropped support and others are promising to do it in coming months: https://python3statement.org/ it will actually be more expensive to stay on Python 2.
This is beyond parody at this point. To paraphrase yourself: "you should just keep your mouth shut and move on".
But some people die earlier than others. I'd rather buy a car I know I'll find parts for in 5-years' time, than a Fiat Ritmo.
Downloads of Python 3 surpassed Python 2 downloads back in 2013: https://ianozsvald.com/2013/04/15/more-python-3-3-downloads-than-python-2-7-for-past-3-months/ &gt;I've heard this story before. And yet here it is, still being supported. Until the end of the year. Then it's dead. &gt; I don't think the reasons why support have been extended have ceased &gt;to apply. We crossed the Rubicon regarding extending support a long time ago. It's not going to happen and there's no need for it to happen. Everything of importance works in Python 3 today and has Guido learned, extending deadlines just lets people do nothing until the new deadline, at which point they complain again. &gt;Actually stopping security patches for 2.7 runs the risk that someone &gt;starts funneling funds to a new organisation that will keep patching a 2.7 &gt;compatible version. Despite al the calls to continue Python 2, not a single fork of Python was made for a 2.8, much less devs coming forward willing to do the work to create it. I don't see Python 2 users sitting on a vast nest egg either, or they would have used it to get their code ported to Python 3. To quote Drew Crawford, &gt;One way is to offer to hire the top 10 Python core developers to work on &gt;Python 2. Another way is to grab 10 developers around you and &gt;contribute to Python 2 yourselves; a group of 10 intelligent, well-funded &gt;full-time developers could probably blow past whatever rate of innovation &gt;an all-volunteer army can sustain. A third way is to set up an organization &gt;that competes with the PSF–that organizes conferences, grants, and &gt;hackathons focused around Python 2. &gt; &gt;....It’s not even that hard to backport major Python 3 features to Python &gt;2. The work is already done in some cases, like Trollius and six. The fact &gt;that nobody has even bothered to take ten minutes to merge Trollius into &gt;their Python 2.8 fork is “case closed” level evidence that the demand for &gt;Python 2.8 is zero. &gt; &gt;Blog posts aren’t demand. Demand is people willing to develop. Demand &gt;is people willing to fund development. I’d even settle for a $15 &gt;themeforest splash page that lists one corporate sponsor and one &gt;developer’s bio. How is it that Python is somehow in grave danger of &gt;forking and nobody will even buy a domain name for the fork? People &gt;literally do that for a weekend hack project. This is a tempest in a teacup &gt;if I’ve ever seen one. There was zero work done on Python 2.8; no one's going to pick up support for Python 2.7. Companies like Red Hat and other software support firms may offer paid support for a time; that'll have no effect on the Python Foundation. No new users are going to bypass Python 3 for Python 2 because Red Hat will support it (for a time) on their OS.
I'm saying that if you run python with optimization (-O flag) enabled, it will ignore all assertions. You theoretically can invoke heavy compression to check for program correctness and after incoming Python with -O it will behave like it was never there. https://stackoverflow.com/questions/1693088/what-is-the-use-of-pythons-basic-optimizations-mode-python-o
Installing stuff from PyPI is not super compatible with using your system python interpreter though. What if pip pulls in some packages that is also in your distro's repositories, but at a different version? Even with the /usr/ /usr/local distinction, this has the potential to confuse or break system software. Packages installed at the system level using pip need to be carefully curated for this reason. Of course you can make a virtualenv and do whatever you like in it, but an extensive stdlib, and a preference for using it, means you can make scripts that will run with system python, and you don't have to think about activating an environment or anything. You can just have a script, and run it.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
This is an amusing question because this exact subject was discussed in a PEP years ago and everyone seems to have forgotten about it. The proposed solution (back when they wanted to bring Arrow-like functionality to Python) was this: Linux (and I believe OS X) have timezone files that are updated by the OS. If Python is running on those operating systems and the files are available, use them. If not, look for Java. Java routinely updates its timezone files. If neither of the above (which generally meant just Windows machines), use the tz that was bundled with Python as a last resort and may God have mercy on your soul. See? Already solved. Here we go, found it - good old Pep 431. Lennart Regebro had the keys to the kingdom but was somehow talked out of it. :-( https://www.python.org/dev/peps/pep-0431/
I have used it extensively for a fairly complex C++ project. There are a couple of gotcha you need to watch out for around memory management but it's pretty well documented. It can be a bit cumbersome when exposing class you want to inherit in python but on the whole it worked really well.
I'm not aware of the enum alternative, I only seen people use enum34 on python 2 and that's backport of the python 3 enum. As for the dataclasses here is the reasoning: https://github.com/ericvsmith/dataclasses/issues/19 I tried to use attrs, but eventually dataclasses fit me better, especially because they integrate seamlessly with type annotations.
A PEP had a workable solution a long time ago.... https://www.python.org/dev/peps/pep-0431/
I see.
This was very encouraging. Thank you for your time, and I truly hope that things worked out for you in the end.
Mypy supports structural typing a.k.a. duck typing as well (see Protocol)! It actually goes pretty far in it’s type system, supporting literals (to some extent, dependent types), `NewType`, etc.
&gt;That's not true. The subprocess module is clunky. I don't know what "clunky" means, but if you skim the module's documentation, you'll see notes about changes and additions in Python 3.5, Python 3.6 and Python 3.7. Whoops - I guess it didn't die after all. Subprocess updated to to gain a single "run" command instead of multiple functions. I felt that the "universal_newlines=True" necessary to get output returned was unintuitive; guess what they did in Python 3.7? They added a "text" keyword for clarity. Again, the code looks very much alive to me. &gt; So is threading and multiprocessing to an extent Again, I think you're moving the goalposts from "code goes to die" to "I just don't like this module". &gt;The XML modules are now unnecessarily slow in comparison to modern &gt;3rd-party parsers which have equivalent APIs. They're there as a basic fall-back. Now, if I said move the third-party parser into the standard library, the response would be "No! That's where code goes to die!" See the problem? &gt; json can't be updated as fast as simplejson (though this one hasn't been &gt;as important of an issue as of late). JSON's JSON. What needs to be updated? &gt;If that's your evidence to the contrary, it's like saying a racecar driver &gt;probably likes his car. He probably doesn't like some of the competitors' &gt;cars. Yet again, "Code goes to die" means "it no longer gets updated". You're arguing something else here. &gt;Reitz, Brown, I, and even come core developers agree that the standard &gt;library is where code goes to die. No matter how much it is said, it doesn't make it true. Raymond Hettinger's out there saying the standard library is changing too frequently. &gt;some people here even think I have a "vendetta" against the guy Ah yes, I remember reading all your posts on the subject. :-)
The best way to get python on mac is homebrew, imho; it makes it similar to the Linux approach. This said, I don't think a clean profile will help - any python you've installed system-wide will still be available in the new profile. Are you familiar with virtualenv? That's the best approach you can try, I think. Packaging python desktop apps with big dependencies on C libraries like yours, is not a walk in the park. Good luck.
&gt;Requests is clearly better than urllib, and yet, it's API hasn't been &gt;adopted by the stdlib. Apparently that's Reitz's position now and official sources *do* recommend using it. Now as for enum, I've never heard of another library out there, so I'm not sure there are any popular alternatives, but I could be wrong. I've certainly not seen one mentioned here, in the Python Weekly newsletter, etc. &gt;There are plenty of dataclasses-style implementations that weren't &gt;implemented with typing that are all superior. The dataclasses library proves my point now that I think about it- there were libraries out there, they were good, achieved reasonably widespread use, and then the standard library borrowed the ideas to make a basic version itself.
&gt;Seems like a tautalogy -- "if something isn't in the stdlib, it isnt better, because otherwise it would be in the stdlib". &gt; &gt;Requests is clearly better than urllib, and yet, it's API hasn't been adopted by the stdlib. Requests had the luxury of being developed later and based when http protocol stabilized (remember that Python is older than http, and the urllib was already version 2 in Python 2). Reitz also did not want his library to be included in stdlib, you can see that influenced other projects such as aiohttp and even languages, to me golang http seems quite similar. &gt;There are no less than half a dozen enum libraries that are superior to the stdlib version. &gt; &gt;There are plenty of dataclasses-style implementations that weren't implemented with typing that are all superior. What's wrong with typing? I actually prefer dataclasses over attrs because of typing. Typing annotations is IMO a killer feature if you are writing a nontrivial application. Suddenly you have auto completion, easy refactoring and you can find many bugs without running the code.
That seems to be the approach Paul Ganssle is trying to resurrect: http://pyfound.blogspot.com/2019/05/paul-ganssle-time-zones-in-standard.html
From what I've read here, I'm not sure there ever will be a Requests 3. And if there were, you'd obviously wait until its API stabilized.
They also don't have full compatibility. IIRC for starters they don't support C extensions. Basically CPython might need to do something similar the problem is that it might break existing applications that worked before in CPython, unlike Jython and IronPython it will upset people (I mean authors of those projects can tell people to use CPython if something doesn't work, CPython currently doesn't have that luxury). What I'm trying to say is if CPython had an option to either have backward compatibility or broken compatibility but no GIL, people would accept it with open hands and eventually they would rewrite their code to work with the later. The only problem is that maintaining two versions might be a lot of overhead.
Awesome! I wasn't aware of this. Thanks!
I agree on the overall sentiment, but I would just add for completeness that a "2.8" fork happened, it was named [Tauthon](https://github.com/naftaliharris/tauthon) because the PSF won't grant naming rights to the guy (and rightly so). It took him three years to release, it's still incomplete and I personally wouldn't touch it with a barge pole, but I guess it will keep the maintainer employed in some place where management would rather give someone three years to fork the interpreter half-assed, than 6 months to port their codebase to a superior, officially-maintained option.
Interesting; I'd never heard of this. Thanks!
I'm going to reply a bit out of order here. &gt; I don't know what "clunky" means, but if you skim the module's documentation, you'll see notes about changes and additions in Python 3.5, Python 3.6 and Python 3.7. Whoops - I guess it didn't die after all. &gt; ... &gt; Again, I think you're moving the goalposts from "code goes to die" to "I just don't like this module". Okay yeah can we have a clarification on what you think that statement means and what I think it means? I think it means significant contributions are stunted and take entire minor version cycles (one year) to get updated if at all. You're claim about subprocess doesn't go against what I said-- those are minor changes. If you honestly think they are significant, you're either deluding yourself or have never seen a code base that actually gets improvements at a decent pace. &gt; They're there as a basic fall-back. Now, if I said move the third-party parser into the standard library, the response would be "No! That's where code goes to die!" See the problem? The API of these third party libraries are 100% the same as the standard library (or have extra keyword argument based options, which are compatible). There shouldn't be any qualms about moving basic code like XML into the standard library. Something like a decent HTTP library, fundamentally has to change at a greater pace, given strides in the general technology. Have you bothered looking at the [changelist](https://github.com/simplejson/simplejson/blob/master/CHANGES.txt)? *Now* things have stabilized, but it doesn't mean that from 2008 to 2015 it wasn't a problem. &gt; Subprocess updated to to gain a single "run" command instead of multiple functions. I felt that the "universal_newlines=True" necessary to get output returned was unintuitive; guess what they did in Python 3.7? They added a "text" keyword for clarity. Again, the code looks very much alive to me. &gt; ... &gt; Yet again, "Code goes to die" means "it no longer gets updated". You're arguing something else here. Well again I'd like to think it's more so that it seems different people think it means different things, apparently. Not having *significant* updates in technology that moves significantly is important and should be discussed. Or if the original API was designed in a sub-par fashion, like many think subprocess was, or the now deprecated asyn* family, it should be updated or replaced with something that is both better but also compatible. &gt; No matter how much it is said, it doesn't make it true. Raymond Hettinger's out there saying the standard library is changing too frequently. Are people now switching from calling Reitz the Python God to giving Hettinger the same? Don't put him on a pedestal. He has his opinion. You seem to share it. So do many others as well, probably. Coghlan, Reitz, Brown, a seemingly significant portion of core and non core devs alike, and I, share the opposite opinion. Didn't know we suddenly had to go to war.
Two comments. One, a three-ring binder would be a better metaphor than a book. Then garbage collection is like removing some old scribbled pages from the binder and adding some clean ones. Two, it is absolutely not necessary to know this much about the specific methods of one Python implementation, and nobody should ever write code that expects or depends on the behavior of one implementation.
[removed]
Ummm...I did, and I quoted the article...
I'm way less paranoid than my former clients' bureaucracies.
Would Rust be a good choice? Whats the jump from Python to Rust like?
I can see it going either way. It does, with or without KR (I haven't dug, I'm not interested in the meatspace stuff, hard for me to point fingers when I'm not involved and don't know the players), and we get a beautiful asyncio-enabled Requests. Or it doesn't, someone or some group forks it, does the intended asyncio version, and that's the new standard for that use case. In the end though, how much can we demand that stuff gets tossed into the stdlib? That is, pretty much everyone's projects need something from pypi or a github download. Not the hack it together script to scratch an itch, but actual projects. I'd never expect things like Pillow or pyproj to get included into the stdlib. IMHO it's a bit much to put tk in there, but I suppose they really want some gui framework (though those who do such work seem to use one of the pypi projects involving Qt, and I'm sure other toolkits). I mean, the premise of OPs submission (not that they echo the sentiment necessarily) is that there is too much broken stuff in the stdlib, but we can't fix it. It just shouldn't have been broken. And now we're talking about putting *more* in? I mean, if you need http stuff, urllib is there. It's not fun, but if you're on a desert island with a LAN and no internet, it'll do it. And if you're not on that desert island, you do what we all do, steal someone else's labor and use a library that does the heavy lifting for you. Maybe we need to just really look at the question of "how big is the subsection of people using python that is at risk of running the latest python, being hampered by bugfixes, *and* can't download corrected pypi packages?" I'm going to go out on a limb and say those 3 people need to bring a thumbdrive home and bring some help to work the next day. Or print it on paper and OCR/type it in when they get back to the office. At some point the pendulum will have to be in the side of the needs of the massive outweighing the needs of the miniscule.
&gt;and then the standard library borrowed the ideas to make a basic version itself. Except it didn't. I don't know of any popular dataclasses style library that decided to implement it via type hints. To me, it seemed more like they were trying to come up with a use case for type hints in the stdlib.
Not format. I hate it with a passion. It's slower than C-style strings and way more verbose for no real benefit. Also, you missed option 5 if you consider concatenation an option. Just don't format the string and dump it directly to a file. Joining the string is slow, so don't join it. Option 6, you left off join.
It's not just a numbers game though it's also how it's curated and what kinds of automation can go into quality assurance right? Like node is famously bad in this respect because people can randomly switch ownership of a project, or drop a project that's depended on by others causing cascading failures etc. What can a modern 3rd party package repo do to ensure quality? Likely any real useful answers come with prereq of $$$ in one way or another
What changed was various functions that interfaced with them. I used to look at my builds and wonder why my Python 2.7, 3.3, 3.5, but not my 3.4 build worked. There was some oddity in that specific version. Then when I started supporting 3.4, 3.5, and 3.6, 3.4 or 3.5 would be the one that is the last one to get fixed.
The code is confusing because it's not formatted correctly and it has those funny "!&lt;" things in it. You should ask questions like this in /r/learnpython. Read the FAQ there to see how to format code.
The `finally` is executed due to GC on `f1()` of the `for-in` construct in function `f2` ```python def f1(): try: yield from range(10) finally: print("Finally") def f2(): for i in f1(): if i == 5: break print("Exit f2") def f3(): f = f1() for i in f: if i == 5: break print("Exit f3") &gt;&gt;&gt; f2() Finally Exit f2 &gt;&gt;&gt; f3() Exit f3 Finally ```
Thank you for pointing me in the right direction.
I always used the metaphor of a desk. You put the things you’re working on or looking at on the desk in front of you, but you have limited space. Your storage is a filing cabinet, which has a lot more space to store things but it takes a lot longer to swap in and out. If you want to work on more things, you can use free space on your desk if you have any. If you don’t, you can take the things you’re not using and file them away to make room for the new thing. Garbage collection is like having someone come by your desk regularly and put away the things that it looks like you aren’t using according to a predefined set of rules, instead of requiring you to manually specify each time you’re done with something. You doing it by hand would be more memory efficient because you can free up desk space faster, but it’s way easier to have someone do it for you.
&gt;Requests had the luxury of being developed later and based when http protocol stabilized (remember that Python is older than http, and the urllib was already version 2 in Python 2). I'm not trying to make this a stdlib vs requests thing. I was just challenging the idea that great 3rd party packages emerge and then make their way into the stdlib and that's how the stdlib grows. Also to be fair, http had long been standardized by the time python 2 came out, and the API didn't really get any better. &gt;What's wrong with typing? It was basically unusable by any library that wanted to support anything more but the absolute latest versions of python. They used a feature that couldn't be backported, even though plenty of other libraries had done it without type hints. I will concede that in 3-4 years it might turn out that dataclasses was the best design, but it's basically useless for any real world production libraries right now.
Thanks, I'll check out the virtualenv option. Currently the Mac is running Python 3.6.8. I was considering setting up Python 3.7 to be the new environment, assuming all of the needed packages will work on 3.7. Dealing with getting Gtk3 to work has certainly been a pain, but I like developing with it.
A python script that runs every night a 3:00 AM that produces a funny video and posts it to Youtube. [Here is the link to the automated channel.](https://www.youtube.com/channel/UCQPCWqI94BfdV26Qamp2JGA) Here's the basic workflow: &amp;#x200B; 1. Begin the script by using PRAW api to scrape the top posts of r/Showerthoughts for the day. 2. Use pillow package to assemble images based on these posts 3. Create audio clips based on the images (tts.sapi package) 4. Compile audio clips and images together and add "buffer images" using moviepy 5. Compile everything, add background music 6. Take video and post on youtube using the youtube API &amp;#x200B; I used the windows task scheduler to have the python script run at 3:00 AM everyday. The whole project only took me a few hours to make, but was really fun! Considering automating the video uploading of more complex subreddits like r/AskReddit. Also, currently all the videos are very similar, so I'm considering changing the "buffer images" which are currently just randomly colored rectangles to something more interesting, and also changing up the background music.
Pyvideo has many for this years PyCon, but not this particular talk. Is it available anywhere?
Personally I would kinda take it with a grain of salt, unless there's video or more points of view. Stuff like this is very easy to misinterpreted.it may seem like he "angrily left", but maybe he just had to be somewhere else or didn't think the talk was worth his time.
For 90% of the stuff I do, I love being able to import things without having to worry about having the right dependencies and where my code runs.
Brownie points: use Quart. The async friendly unstable version of Flask. My company wanted to move to Quart but it's still very new.
If you were going to distribute a package with python itself, that’s developed independently, why wouldn’t you give it a new namespace? Java in 99 or so included Apache’s Xerces for XML processing and it caused no end of problems by not changing the package name. People wanting. You could depend on bleeding edge - the dev team’s namespace, or the python teams different namespace a releases less often.
Nice program, I couldn't get [repl.it](https://repl.it) to work but ran it on my machine and it does exactly what is advertised. I've found plenty of information about running shell commands from a python script, but the real need that I have (that I still haven't found a solution to) is to be able to interact with that exact instance of python. I need to be able to call other functions and view the values of variables defined within the same script as the one running the GUI.
he is unhappy python 2 libraries
The jump to any lower level language is going to be a decent jump if you haven't done it before since there's a lot Python hides from you. Memory management is it's own skill especially if you go to a language where it's possible to metaphorically blow your foot off with pointers. The problem currently with Rust or some of the other languages is that they haven't quite caught on in popularity just yet. Which can be a problem both because community support may not be as strong and fewer people are going to know it.
cool.
&gt; for no real benefit. There is one benefit: on Python 3, `str` implements both `.format()` and `.__mod__()`, while `bytes` implements only `.__mod__()` and guarantees it will never implement `.format()`. This means that attempting to do `%` formatting on a non-decoded `bytes` object can succeed by accident, but attempting to use `.format()` on it is guaranteed to fail with an immediate exception at the site of the call.
&gt; There were improvements like using UTF-8 internally if possible which saved memory Not quite. Python 3 assumes a source code file is UTF-8 unless you explicitly indicate otherwise. But the encoding used to store strings is chosen on a per-string basis, and chooses between latin-1, UCS-2, or UCS-4, selecting the narrowest encoding that can handle every code point in the string as a single fixed-width code unit. This actually *beats* UTF-8 for storage, since UTF-8 has to go to variable-width encoding for any code point &gt; U+007F, while latin-1 can handle up to U+00FF in one byte.
&gt; we're not getting a new calendar any time soon [Actually...](https://www.nytimes.com/2019/04/23/business/japan-reiwa-calendar.html)
Instead of print try: answer = input("Are you still enjoying it")
The difference between 3.5 and 3.6 is 0.1.
How old are the students, if they are in college why bother, if they are hs or less they have small classes and teachers
For sake of an actual data point, here's the stats for Django: https://pypistats.org/packages/django We dropped Python 2 support for new releases as of Django 2.0, in December 2017. Though we still provide security and bugfix support for the final Python-2-supporting LTS release, which was Django 1.11 (and we'll cut that off next year). The daily download/Python major version graph only goes back to November of last year, but by then Python 2 was already only about 1/3 of our daily downloads, and is now down to between 1/5 and 1/4 on most days and still trending down. Looking at other big projects that have dropped Python 2 for new development, I see similar trends, and I think those graphs are really going to nosedive next year when all those projects also stop supporting older versions that ran on Python 2.
I usually use VSCode for personal projects. But for the official company work, vim.
PyCharm, Sublime Text 3 or Vim.
\&gt;Someone told me very early in my career to always assume there was a reason that things are the way they are. It may have been a good reason at the time. Maybe not. Maybe it’s a bad reason now. Thank you for this \&gt;Ultimately, this is probably a good short-term move for her career. There are obviously some politics in play here. There will be a narrative about a woman standing up to all the white men and Guido being such a sexist pig that he can’t even stand to be in the same room. People who criticize her approach (like me) will probably get a little branded as also being sexist and told that we would never critique a man the same way, etc. wat
Go to edx.org and search for python, classes are free
This question is posted very, very often in this subreddit. A quick search will yield many recent discussions.
A sticky of this would be good then.
&gt;There are many modules that few applications use, but there is no method to install a subset of the standard library. Installing just a subset of the standard library seem like a... mmm... bad idea to me. That would be like opening the Pandora's box. &gt;Brown’s most controversial opinion, in her own estimation, is that adding modules to the standard library stifles innovation Is this controversial? I would say this is counterintuitive at best. Honest question: is Twisted being obsoleted by a built-in solution? In any case, adding modules that lag behing unofficial alternatives would be better for innovation and explaining why Twisted is still worthwhile is nobody's job but Twisted devs.
this might work also https://composingprograms.com/ , it has programming projects to illustrate the points
Indeed. The search feature could be used more, as well.
PyCharm
Vscode, atom and sublime though I'm getting more and more sold on pycharm
Text Editor: Atom Can be pretty powerful
PyCharm, VSCode, and Vim, depending on what I'm working on. Usually VSCode though, unless I'm working on a remote server and then I just use Vim.
Having made that jump, it's not that bad. Despite being statically typed, you need about as many explicit type annotations as you do with mypy, just function parameters/return types and a few ambiguous cases. First-class generics, actual closures, and iterator/future/stream combinators are just a few of the features I now miss when writing Python. The big thing about Rust is that you must handle memory management correctly for the compiler to accept your code. This is good in that can't cause memory corruption/segfaults on accident, but it does mean that it will take more work to get the compiler to agree with you in the first place. Also note that the language is still young; there is no PyCharm equivalent, the language server crashes occasionally, and the library ecosystem is fairly small compared to PyPI. That said, I write better Python now than I did before I learned Rust. Being explicit about whether the caller is responsible for closing this file after my function returns or whether I close it and the caller shouldn't touch it afterward - the same thing the borrow checker does in Rust - has caught a handful of bugs before they happened. If you're looking to make the jump to a lower-level language and can take the steeper learning curve, I would definitely recommend picking up Rust.
vscode = G.O.A.T.
Pretty sure the search box is there with or without a sticky
I do `cat&gt;`[`file.py`](https://file.py) and then Ctrl+D when I'm done typing. If I'm appending, I use `cat&gt;&gt;` instead. What's an IDE?
Vim with tmux!
Pycharm and VScode. Leaning more and more towards Pycharm recently
Notepad
&gt;according to Brown, and for users, Red Hat and other distributors will keep Python 2 alive “until the goddam end of time.” Haha
PyCharm debugger is amazing!!!
Let’s have a good package manager first, then
He asked for an advice and I gave my personal concerns about using python for this kind project. Every language has own use case. Python is works fine, but as I said most hosting providers does not support python. So I'll not use python for this simple task. Conclusion: being on python subreddit does not matters in this case.
Pycharm most of the time for any serious development, but for whiteboard demos to students I use MU (https://codewith.mu/)
Also as Amber pointed out, when a module is added to the standard library it becomes much harder to update and the flow of meaningful changes slows badly.
I used to work in Forex at one of the largest banks in the country, and by just briefly going through your code, for one thing, your currency conversion looks off. In Forex, we have major currencies and non-major currencies, and the conversion differs based on different pairs. Also, I don't see wholesale rates and market rates into consideration. Just personal opinion and observation.
Geany
I had 1 year Pycharm pro license from humble bundle. I liked it, but it were heavy on resources. I've used that because of SSH development. Now using VSCODE, which also supports SSH development for a while.
your whole title sounds bad they are basically interchangeable to a good programmer or analytics person learn the basics not buzzword bullshit.
Same, though it's not an IDE.
True
Notepad ++ but after seeing all the pycharm replies, that might change. What does pycharm do for python users?
Just checking if you realize: https://pythonclock.org/ ?
I3wm, gnome-terminal, vim
&gt; six is non-optional for writing code for Python 2 and 3 Well that's a lie.. six should be used when you can't solve the problem another way not as a first port of call.
Quick setup of a virtual env, built-in terminal and python repl, run configurations, plugins for other languages, requirements installation, git integration, Docker plugin, etc. For me, PyCharm makes things easier. I use the Community Edition; the full one supports frameworks like flask and Django too. Note that PyCharm still has some quirks (UI acting up sometimes, on Mac). Btw, I’m also using Atom for quick scripts.
I use ed
PyCharm or vim or ipdb for remote debugging
Pycharm, mostly because it's what I use and was introduced to at school. It does have a nice debugger and being able to remove some code inspections is great when you're just making something for fun and don't want the entire thing to be underlined because you didn't follow pep-8
Leaving academia was easily the best thing happened to me (us) :) Good luck with the job hunting!!
I use EditPad and Idle but after looking at the other posts, I’m going to look at PyCharm now.
VS Code. Occasionally Atom.
‘Tis broken
depends on how much fun you want to have coding...Rust is a very pedantic language, that enforces strict rules and you'll be yelled at by the compiler if you don't follow the rules. The transition from Rust to Python is really huge (especially because Python does tons of things for you). Best starting point: (and no you don't have to read everything!) https://doc.rust-lang.org/book/
Without getting into a religious war about the definition of an IDE, with a bit of setup VIM can autocomplete, highlight errors and run projects. I'd call it an IDE.
This is my relevant piece of code btw: #plot vector X = 0 Y= 0 U = I[1,0] / np.tan(I[0,0]) V = I[1,0] Q = U Z = V L = d H = rayout[1,0] - V O = d + U P = rayout[1,0] B = 10 G = 10*(np.tan(rayout[0,0])) fig, ax = plt.subplots() q = ax.quiver(X, Y, U, V,units='xy' ,scale=1) t = ax.quiver(Q, Z, L, H, units='xy',scale=1) r = ax.quiver(O, P, B, G, units='xy' , scale=1) plt.grid() ax.set_aspect('equal') plt.xlim(U-10,40+U-10) plt.ylim(-10,20) plt.title('Outcoming ray',fontsize=10)
How does that work, im pretty new to python and know only some basics?
VS Code for everything :-)
There are a lot of FAQ, do you want them all stickied?
The Python ecosystem has become so polluted, that even Van Rossum fails to recognize the extent.
There sure is a lot of talk about the logotypes for a short video that is supposed to be about the history of the language... This video is maybe a bit too unclear on what story it tries to tell.
Problem is that it would be pretty messy (im not that good at coding) since I would get a ton of input values since every arrow vector needs a starting point and x-y dimentions. And I honestly don't know how to be able to create so many seperate variables of the run before the plot can be made.
From Googling "pickle matplotlib figure": [Maybe the most useful, pickling figure instead of axes](https://stackoverflow.com/questions/51264460/save-python-matplotlib-figure-as-pickle) [Pickling subplot axes array](https://stackoverflow.com/questions/7290370/store-and-reload-matplotlib-pyplot-object) &amp;#x200B; I have only done this with matplotlib's QT5 backend, as part of a GUI, so some of the specifics of what I know probably don't apply to your case.
I use Repl.it
In Physics, voltage is E normally. Electrical engineering is normally U. So if you are describing magnetic fields in a motor, E is normally used. If you’re dealing with electrical installations and so on, U is used. This is, by the way, in my own experience.
The most powerful feature IMO is the language-aware refactoring support. Lifting sections into new functions and modules with a single click, and automatically updating all references in the project, is close to magic.
If your program is any good then you can easily switch to python. It should feel like learning how to type again. Start re-doing basic things that you did in R but with Python and work up from there. Some people adjust faster than others but I'd be surprised if it took more than 2-3 weeks of full immersion.
This looks great. May I had a request for complex calculations with power factors or perhaps vectors and so on? Great work.
PyCharm and Vim. Coz PyCharm has a powerful refactoring feature that I cannot find on other IDEs. And Vim is lightweight and fast.
Ah, ill look into it thanks!
I disagree with pushing features to PyPI. Mostly for security reasons, I trust the Python core developers more than I trust third party developers. If you were familiar with the namesquatting incident before where environment variables were stolen. Core features shouldn't be moved to PyPI. The talk is too unprofessional IMHO.
emacs
We hereby formally grant you access. Welcome kind stranger!
She's just pissed that her twisted project has been obsoleted by asyncio.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Vscode + type hintinf kills it all Pycharm the best at suggestion but the performance sucks
Spyder
Neovim
When I joined this community I was surprised by the number of non-pycharm developers, Guys Pycharm is amazing! Try it!
The ATOM ide
I agree although atom is pretty complicated to setup it's kinda fun just seeing all the cool stuff it can do
I don’t do much serious work, but I like atom
&gt; “So I know a lot of this is essentially a rant,” she concluded, “but it's fully intended to be.”
Vim can be configured to be a DE but the I in IDE it certainly doesn't have.
vscode because so a e s t h e t i c
Can you explain to an idiot like me why it doesn't have the 'I'?
Almost all students would be between 17-22
I wrote a python program for hangman game today!
I mean... We're arguing about semantics here, so don't expect any absolute truths. But as far as I'm concerned, a development setup based on vim wouldn't count as an *integrated* development environment. Rather vim provides one aspect of an IDE (a text editor) with a convenient, universal interface that also allows other aspects of an IDE to be bolted onto it. I guess the point I'm trying to make becomes a bit clearer if we look at my Emacs setup. It has all aspects I would want to have in an IDE (I'm never leaving Emacs when working on a project). But calling it an IDE seems misleading to me. In the same spirit (but to a lesser degree) as calling a desktop environment an IDE would be misleading.
Started with IDLE, then started loving Jupyter (Notebook/Lab) for its easy prototyping, and now settled with PyCharm for bigger projects (great debugger and tons of other features).
So they are adults, why treat them like children?
Pfft... try using edlin instead.
For projects with several python files - PyCharm. For simple python one-file-scripts: Notepad++
Spyder or Ipython for quick scripting. Sublime for everything else.
IntelliJ Idea for work; I touch too much typescript or go too. PyCharm for personal stuff. Or for non-IDE text editor, Textmate or vim.
https://www.reddit.com/r/Python/comments/bq4v99/amber_brown_batteries_included_but_theyre_leaking
I'm not treating them like children, just had an idea which could save a lot of teachers time for marking attendance. In college for attendance purpose, attendance registers are use which takes up a lot of time
I'm not treating them like children, just had an idea which could save a lot of teachers time for marking attendance. In college for attendance purpose attendance registers are use which takes up a lot of time
Thank you!
PyCharm is an awesome IDE, yes. But a full-fledged IDE for a two-/three-file project is so totally overboard...
PyCharm.
F-strings, new dicts, class attribute definitions ar eordered, type annotation for variables are maybe/probably the big reasons. 3.6 was a quite a big change compared to 3.5.
Spyder. The variable explorer is just great.
But Emacs is an operating system so it's not a fair comparison.
That's a very narrow attack surface :)
Intresting... What are the advantages of using VS code for smaller scale projects? From what I see Pycharm just has more features for python programming
That moment when I start ansible-vault view and try all the key combination I'm aware of... Priceless.
I'm not a serious developer, but I used Emacs with a few plugins before returning to Vim. I agree with some commenters that the "I" is a bit thin. Still you can have autocomplete, Vim can run your code, you have syntax colouring and more. Moreover, the typing and editing are a breeze after 20 years of Vimming.
Startup times for one
Eclipse with PyDev
vim, tmux and bash. I have tried other graphical IDE's like Atom and VScode but I'm too set in my ways to change. One easily explained example of why I stopped using vscode was because everytime I wanted to search&amp;replace I ended up going into vim to do it. I just couldn't figure out how to do a simple s/foo/bar in vscode.
;-)
Imagine making programs today in Python 0.9.0
Netbeans
Try Liclipse, it's by the guy(s) that made pydev
Emacs...
Can you post your code somewhere? I could try to give feedback, if you'd like.
I agree - I've worked on ruby projects where it was a breeze to upgrade the ruby interpreter, and then I come back to python and everyone's still stuck using python 2 and half of the community are just like "this is fine". The thing that really stood out to me from the blog post was the comment that core devs aren't concerned with the same things as other programmers. That's a huge problem. That people can hold the opinion "the standard library is where code goes to die" is not ok! If the core dev team cannot support the "batteries" that the python community actually rely on, the core team should change so they can. Contributing a package to the standard library should mean it is *more* supported, not less. And it should be acceptable to move stuff out of the standard library and into a standalone package if it's only there for legacy reasons. As it stands it's fairly arbitrary which batteries are actually included and which aren't. It's the job of the standard library to be easy to consume and relevant to the python community. If it's not doing that, it's right to question what's in it, what's not in it, and the whole "batteries included" philosophy. It's great there is some discussion of slimming out the standard library but I wish there was more momentum behind this.
Imagine having to support a legacy application originally written in python 0.x that includes a few KLOC of Python C code and slowly having to port it all to python3 oh wait that's me.
The point on itertools is good. But I it *really* smells of butthurt over asyncio and unwillingness to upgrade to non-ancient versions of Python (Python 2 LOL!).
Gets all the C++ and JS ladies.
 [https://stackoverflow.com/questions/56198515/anyone-knows-how-to-let-different-runs-of-a-script-appear-in-the-same-plot-using](https://stackoverflow.com/questions/56198515/anyone-knows-how-to-let-different-runs-of-a-script-appear-in-the-same-plot-using) This is the code of the plotter, do you need to see the rest of the code too? (that is only vector calculation)
Hey! Even I am looking for some resources and projects to work on. Check out this link tho, I found it a couple of days back. https://github.com/tuvtran/project-based-learning#python Let me know if you find anything useful too!
I used NotePad++ for long time, but after I switched to VS code, I won't look back.
There is a *huge* demographic of Python users who cannot use PyPI. They might be school kids where they don't have permission (either legal, or software) to install software on their school-provided laptop; or casual users (say, sys admins) who don't want to research third-party libraries, they just want something that works "well enough". Or people working for enterprises with strict rules about what software you can install and run, where installing something unapproved is grounds for instant dismissal. In places like that, it may take *months* to get approval for third-party software (especially if it is Open Source!), but once approved, upgrades are permitted. So once you have "Python, from &lt;insert name of vendor&gt;" approved, you're fine with upgrades. But if you want to add anything from PyPI, you're shit out of luck. And then there's those of us who would rather deal with *cough* "inferior" standard library modules than the hassle of move-fast-and-break-things third party libraries, Or even just the hassles of packaging. Those of us who are lucky enough to be able to install anything we want with `pip install spam`, and who also know *what* we want, should remember that we're not the entire Python community base.
I have update the repl. Hopefully it will run on the repl site. If not, you already know it runs locally. This version adds "watch variables". You can put variable names into the fields and it'll show you the values as the program is running. I left it an exercise for you to add the code to modify those values if that's what you're wanting to also do. Try entering the variable \`var\` to watch. I've intentionally created it so that it increments every time. Interestingly, if you add a timeout value to your read call, Read(timeout=1000), then the loop will run once a second and the variables you are "watching" will automatically be updated. If this along the lines of what you were looking for or do you need additional functionality? You can enter **expressions** as well as variable names in the input fields. For example this will work just as well as a variable name: (var+10)\*i\*100
&gt; Probably a better approach would be not to add them to the standard library, but to bundle them with the python installer, sort of like the Anaconda installer. Oh, you mean like Anaconda does? If only there were third parties out there who would add value to the Python ecosystem by selling bundled software!!!
Please search before posting. _At least_, take a look at the front page...
PyCharm may be richer with features but takes longer to load, if I boot it up, I spend longer then just a few quick edits on a project. VSCode is pretty fast on loading, and I mostly use it for quick edits or a quick function to write. So it always depends on what I want to do.
Calling all python 🐍 devs! My team at Capital One in Richmond, VA is fighting credit card fraud and we need help! Our app is using Spark to ingest crazy amounts of data from data lakes and streams in the cloud, and we need an experienced Python fanatic to help us refactor and extend. Bonus points for ML and Kubernetes chops, but we really just need a solid, purple-belt Pythonista. Is this you? Know of anyone? Hit me up and let’s catch some bad guys.🤠👏🌈🚀 P.S. relocation assistance!
Idle
If only I could have Pycharm with VS Code's Jupyter integration.
&gt; Rust has taken the opposite approach of a relatively small standard library and excellent packaging support. There have been some problems with this approach of course, but the community faced them head on by necessity. I can't help but wonder if the batteries included approach allowed the Python community to let problems like the historically poor state of package management, packages of indeterminate quality, and poor package discoverability languish. And you think that pushing packages out to PyPI will solve "poor package discoverability"? The batteries included approach has put Python in the top five most popular languages in the world, and one of the few to be entirely community driven. Most other major languages have got major corporations behind them, e.g.: - C, C++: there's a whole ecosystem of companies pushing C/C++, including Microsoft; - C# and VB.Net: also Microsoft - Javascript: Mozilla - Go: Google - Java: Sun, and now Oracle; &gt; Rust has been tackling these all straight on, and it's been all the better for it. Come back and tell us that again when Rust is a mainstream language used by more than a tiny number of corporations and individuals.
While the idea of having an option to install NumPy et. al a la Anaconda is good, why not just push Anaconda instead? Also, IIRC, the Ubuntu package of Python doesn't include Tkinter by default (and presumably other Linux packages too), just the Windows installer
&gt; realize that anyone that wants to embed python in their application or contribute to the core project has to compile everything in the standard library Oh, well if you move those packages onto PyPI, the dependency will go away, right?
Pandas and Spyder's variable explorer is a tough combo to beat.
&gt; Maybe we need to just really look at the question of "how big is the subsection of people using python that is at risk of running the latest python, being hampered by bugfixes, and can't download corrected pypi packages?" I'm going to go out on a limb and say those 3 people That's an amazingly ignorant thing to say. &gt; need to bring a thumbdrive home and bring some help to work the next day. In many tens of thousands of enterprises, that's grounds for instant dismissal.
I don't know man. As I was writing this, I was thinking Django ORM will act the same among databases. That's the logic of having and using ORM, to remove the difference between SQL dialects. I didn't forget the mention PostgreSQL there since it has a bit more on Django's side. However, now that I think, if it is inevitable to use raw SQL queries, then yes, you have the right.
I use VS Code for all languages. I haven't tried many IDE's but I don't think any have as many or as good shortcuts as vs code
As someone whose clients are from the public sector I really support your point! Up until now I did not realize how hard it is to get permissions for packages / technologies in general. I think a solid and official Python Core would be beneficial to all those use cases but without neglecting most of other users.
emacs
I don't remember I suggested a way to configure dev-oriented dependencies with environment variable. I actually even recommended to set the default settings to `development` in the article. I just didn't mention how you set the secret key in production because it would be extra long and any experienced developer would know a couple of ways to inject `SECRET_KEY`. Thanks anyway. I actually like these opposing comments because it shows me how developers differ on solving problems, it is good to get the critical feedback. By the way, I saved this comment, 12factor seems to be a good guide. :)
&gt; I was thinking Django ORM will act the same among databases Except it doesn't work that way in practice. SQLite, PostgreSQL, MySQL (and even MariaDB, as the distance between it and MySQL grows) have their own ways of handling things. I've seen migrations "work fine" in development with SQLite and fail in production with Postgres. That's not when you want to find out you've made a mistake. Setting Postgres (or MySQL, or MariaDB) up in development has always been straightforward, at least on Linux machines. With tools like Docker it's now trivial. Don't introduce a significant difference in your development stack by using SQLite in development. There are literally no benefits, and many hidden pitfalls.
Sorry, this topic has already been posted about. Please continue the discussion there.
Thanks for quick reply ccharles. I get the point to be extra careful on dependency differences among development and production. :)
&gt; The reason I suggest mypy is because (unless I'm wrong) it is made by the python software foundation. [You're wrong.](http://mypy-lang.org/about.html) mypy is still alpha software, even the API isn't stable yet. &gt; It's now been 11 years since Python 3 first came out and everyone has had plenty of time to switch over, I just wish people would stop being so hesitant about it. If code isn't broken, why should people break it just yo validate your choice to upgrade to Python 3? I love Python 3, but I don't insist that everyone else move to it if they have no reason to. I know of at least one company still running Python **1**.5 because it works, they don't need security upgrades (it isn't connected to the internet and it is purely in-house used by trusted users) and there is no business justification to spend even 30 seconds to upgrade to Python 3.
Atom. VS is aesthetically pleasing and a good alternative, but I just like Atom for some reason, really clean UI.
And with wildly different users. You have someone writing only stuff on headless linux that gets deployed to hundreds of servers using vast deployment machinery, and someone else distributing an executable to end users of a GUI. And then a data scientist just wanting to get some libraries and glue enough stuff together to get a correct graph to show of their data. "Just make packaging better" while keeping all these users happy... well, that job has been open and available for literally anyone for the last decade. All you tend to see about it is a lot of talk.
Hopefully you'll be able to run the newest on repl. I changed the code to have a timeout=1000. This way the variables that you are "watching" will be constantly updating. Here is an example for you that shows a few variables changing as the program ran. This is the screen capture: [https://user-images.githubusercontent.com/13696193/57982053-b9b01900-7a0d-11e9-9e6b-b11d5e9919da.gif](https://user-images.githubusercontent.com/13696193/57982053-b9b01900-7a0d-11e9-9e6b-b11d5e9919da.gif)
VS Code has a variable explorer now!
And yet you can't combine vanilla requests with any async code, including all the asyncio standard library stuff. Which would be nice... but despite that, it's done, right?
I think of VS Code as a better Atom. What's the reason for sticking with Atom?
emacs for smaller things, pycharm for bigger projects
Thanks, friendly moderator! This would probably be more useful stickied and with a link to the earlier post.
&gt; I just wish people would stop being so hesitant about it. That hasn't been the problem for ages. It's existing code.
Havent tried VS code yet
Vim
I have been using wingide for almost a decade now and never changed. I have tried PyCharm and Eric4 but always went back to wingide.
based on domain you can segregate your queries. further you can look into CQRS pattern
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
&gt; Yes, mypy is a python project There are millions of "Python programs", that doesn't mean that the PSF has anything to do with them. And the PSF has nothing to do with mypy: http://mypy-lang.org/about.html Guido is a private individual who can contribute to any project he likes, including mypy. And his employer, Dropbox, pays him to do so. &gt; Python 2.7 was essentially just backporting all python 3 features back, That's right up there with "tofu is a plot to emasculate American men" level ignorance right there. Python 2.7 reached feature freeze prior to the first stable release on July 3, 2010. That dates it to Python 3.1, so **not one single new feature** from 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 or (upcoming) 3.8 has made it into 2.7.
Same! If only pycharm had Spyder level variable explorer though, I'd never come back to Spyder.
&gt; elif years &gt; 5 and years &lt;= 20: Python supports maths-like chained syntax for comparisons: elif 5 &lt; years &lt;= 20:
Vscode at home with some great plugins, and neocon at work.
Visual studio 2019 it's just convinient to have all my programming languages in on IDE
The VSCode Vim extension is awesome. Also, why not use VSCode at work as well?
Vim is all you need.
Vim.
&gt; In the real world, most people don't get to pick the version of the python interpreter, but they usually can pick any version of third-party libraries. Not sure what kind of real-world you are referring to here. The last four years, every real-world environment I've touched has been containerized, so you do actually get to pick whichever version of the interpreter that you want. So I'm not sure what you are referring to when you say "real world". Is it embedded systems? Is it pre-Docker support Windows servers? Is it inseparable monolith code bases deployed in byzantine computing environments?
Ignorant because I made a bit of an exaggeration with three people? I mean, we're talking a group that can get pypi stuff, is running the latest python, but can't get pypi updates, or can't install specific versions of pypi packages. The instant dismissal thing was followed by bringing in paper (which could be reviewed prior to use). But again, can get latest pypi but can't get older packages from the same site. Let's paint the scenarios of systematic breakage that is a large enough section to worry about that doesn't have a solution. Can run latest python, and needs certain bugs to stay buggy.
There's also going to be changes to the DST across the EU.
It does, but I just don't think it's as good as Spyder's.
Well I mean, Ed is the standard text editor.
You seem to have a pretty rigid definition of what an IDE is, but it looks like you cannot explain it. I do not really care of what name one would give to my setup as far as it suits my needs for coding but you seems kind of quibbling on the semantics.
Thanks for all this work, but it still is interacting with bash and not with python
Not directly related but `conda-forge` has dropped Python 3.5 and it's caused me headaches recently. I get that it's been out for a couple years but moving this quick puts a lot of pressure on things upstream of me.
Nope, the language summit is not recorded, so this blog post is it.
You're missing the place where you enter stuff. The very top line is interacting with BASH. All of the other lines are interacting with the Python interpreter. Did you see the GIF that was included. I show not just variable names but expressions. Maybe you can sketch out a window that you want and a set of behaviors you want if this still isn't it. There's some disconnect happening in what you mean by interacting with Python.
I use vim/neovim with deoplete + deoplete-jedi for completion and ALE + flake8 for linting and it is a pretty good setup for serious work. Of course I have a few other plugins not limited to python: fugitive for git work is just awesome and I even open vim just for fugitive interface sometime. Particularly the integrated diff feature is super useful. I also started to use fzf+fzf.vim for code navigation also I was totally fine with just grep and ctags until now.
VSCode + Python extension
Geany. Free, open source, well-maintained, and full-featured.
I love Emacs but I always fall back to writing python in pycharm because of its refactoring. Any tips for this in emacs?
What is a variable explorer?
PyCharm for projects, Sublime for quick edits.
Let's cut it short please, that joke happen far too often https://xkcd.com/378/
We have to connect to a server without Xorg. So no GUI. Also I am not allowed to customize VIMRC so I am basically fucking around with vanilla vim. It's horrible
\&gt;&gt;&gt; from math import floor \&gt;&gt;&gt; sum(floor(j\*n/3) for n in range(10) for j in (1, 2))
Not for dictionaries :/ Only thing keeping me from switching from PyCharm.
I downloaded PyCharm yesterday, and I have two questions: a) when i create a project, it takes a long time to index things and so on.. this is normal? b) and every new project I have to download the libraries I want for that specific project?
at the beginning i used the basic IDE which came with python, but now i use Visual Studio Code.
Vscode recently added a remote coding extension
It sounds like a and b are related - you can choose a global interpreter in the settings where your globally installed packages are, but if you work on a handful of different projects you should consider using virtual environments anyway. You can configure them to be based on your global config so you have a “core” set of packages and then your environments will be incremental. Freezing your versions will help you in a few years when you have behaviors dependent on deprecated features and libraries. Also, when it’s time to deploy your code remotely you already have a versioned lightweight summary of dependencies to install from on the new machine. The indexing is mapping out all the classes and functions in each package to help you with code completion and linting, which will be faster if you’re not reinstalling packages every time you start a project.
Support for old Pythons is strictly time-based: https://matplotlib.org/devel/min_dep_policy.html.
Can you define the I? I sort of agree on your delineation but I want to know what that piece means to you
B is only true because you're creating a virtual environment for each new project, which is a good thing. You can check a box to include packages from the base install IIRC.
Emacs user here,I wouldn't write python code without black, yapf, Jedi, autopep8, and rope installed in my virtual environment. Within emacs, install elpy, there's nothing better than that.
Material Theme
Oof
PyCharm is great. Visual Studio is another option though and it supports python very well.
It's an interface where you can see your variables and see what's stored in them in a quick and easy manner. Let's say you have a couple of pandas dataframes, you can open them each on a window, put them side by side, and check the data inside them. This is great for exploring data structures or making sure some data processing algorithm you've implemented is working fine.
You have my thots and prayers buddy
This isn't really an issue with faster machines, Pycharm fully loads in about 5 seconds for me.
At work I am using a raspberry pi with some sensors connected to it to tell if people are in the room or not. I doubted the pi's ability to run any gui based editor, so I've been using vim for it. I'm not amazing at using it, but on a small-scale python project I manage fine with vim + an ipython terminal for testing things as I code
I've been using Thonny, I started learning in it and have just never switched. Is there any reason to switch to pycharm at this point?
As a newbie trying to learn SciPy, this really helped me!
You can edit remote files and use a remote interpreter from PyCharm, I'm pretty sure. I would be so unproductive using raw vim.
I thought you were wanting to interact with the *currently running* Python interpreter, to have access to variables that are running in your program. Are you wanting a completely different copy of Python to also be running in parallel with your existing Python interpreter? If so, why not type "python" at your command line? I'm clearly confused as to the requirements and the goals. Maybe you can salvage some of the code I've written and you can go from there.
The only true IDE.
IDLE, but I also like my coffee maker with one button (On/Off) My friends who use coffee machines with multiple buttons use IDE's with many features. I'm not suggesting that coffee machines determine IDE used, or vice versa; Rather, I'm suggesting that personality type determines the types of tools you use. Are you the type that needs a tool for everything even when you only need a hammer, or are you the type to bring just the hammer? In either event, the tools within the toolbox only help the carpenter. They don't do the job for him.
How vim help in this situation? Directly on remote? I think it always faster to code locally first, before staging and prod.
that is part of what they get paid to do, instead you want to install tracking software on peoples phones. I would refuse to install it on my phone. A better question is why do you need to treat adults like children?
Well that's a bummer. Looking at Amber Brown's twitter (which in my defense seems to be something she uses, and I just went looking for her feed, be it blog or whatever), she doesn't object to how her statements were conveyed, so I have to take OP's post/article at face value. That said, why wouldn't a language summit, which presumably would have core devs and the steering committee present, be recorded? That's some useful or at least entertaining video.
Here is what I mean by interacting with python: Lets say I have this python script: def hello(name): print("Hello {}".format(name)) x = 5 I can run this script with python -i [script.py](https://script.py) and then interact with it's variables. I see "&gt;&gt;&gt; " and can enter x\*5 and get 25, or enter hello('mike') and get "Hello mike". &amp;#x200B; What I need is to not run the script with python -i but have the same interactivity available to me. I need some method in my script to integrate the command line and run commands like: cmd = input("&gt;&gt;&gt; ") python_run(cmd) This case needs to be able to run commands the same way the interactive python interpreter was able to, but from within the GUI. If your GUI program can do that, I haven't figured out how to do it.
Very generous of you to share your thots
Well, If you are willing to pay for the professional version of PyCharm, you could use the remote interpreter. Would make development much easier
Dude if that's true I'll get promoted, do I need Pycharm pro?
I removed the BASH stuff to make it more obvious where you enter ***variables and expressions***. What I can't do in my program is create new variables. Again, maybe with more changes it will be possible. I'm simply using the eval call to evaluate expressions that you entered. So, I have taken care of the variable watching you wanted to do and the expression and computation stuff. I can do expressions and variables, just like in a print statement. What I can't do is define functions and variables.
Wing IDE
Rip
There is no "standard" repo. This is the minimal standard repo layout for a package that has multiple files (which is most packages). repo_name package_name\ __init__.py package_files_here.py ... setup.py For graphql or rest, I might do this: repo_name package_name\ __init__.py __main__.py app.py schema.py setup.py __main__.py is the main entry point for your package and that should basically startup your graphql endpoint on a port. This should call something in the app.py file to run. See: https://docs.python.org/3/library/__main__.html app.py is the standard main entry for a wsgi app. You would likely want this so you can serve from something like gunicorn. See: https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-gunicorn-and-nginx-on-ubuntu-18-04 schema.py is the bulk of what you might find the "graphql" portion of the code. You should have a line in this file somewhere that looks a bit like this: `schema = graphene.Schema(query=Query)` Check this out: https://www.howtographql.com/graphql-python/0-introduction/
Why not using local vim? See `:h netrw` if you're not aware of that option.
Visual Studio Code, that's it :-)
Pipenv does the job just fine.
Yeah realistically got should be pushing your code to some kind of version control (git) then has you RasPies pull the code. Throw in Jenkins or gitlab and you have yourself a nice little cicd pipeline.
Except where nobody agrees on what to commit to version control and thre are architecture and installation specific stuff in those files
Visual studio cus the features, I don’t really care about the size.
I always hear this argument that PyCharm is overkill for most small projects, but my counter to that would be - so what if it is. Ive used emacs, vscode, and pycharm for all my python needs and I always tend to migrate over to Pycharm simply because its simple. So what if its overjill, its not like we live in a world where space is limited and processing power is hard to come by. Its a great ide and takes zero effort to begin programming in it.
VSCode all the time
I'm in the same boat. My work computer is almost six years old and and it loads pycharm in a few seconds.
Actual benchmarks for my current computer: Ubuntu 19.04 i7 3GHz Gtx1060 16gb ram Vscode: ~1.5sec Pycharm: ~3.2sec Based on my iPhone stopwatch app lol Its not that much longer for a great set of tools - even if you dont use it to its potential
So, I heard a comment just like this and I went to try VS Code's jupyter stuff. What am I missing? Because the implementation seems AWFUL. It turns my ipynb into an untitled python file, turns all the markdown sections into # comment blocks, and doesn't handle starting the jupyter server for you. I'm truly looking for a good pycharm alternative, because the 2019.1 revamp doesn't support things like denoting raw cells or rst cells, but VS seemed like a downgrade.
Doesn’t that depend on the version? It’s also a pain in the butt creating byte strings for struct in a way that’s compatible with all versions.
&gt;Except where nobody agrees on what to commit to version control You commit your required list of package and your lock file. Like in any such software for any language. It's not rocket science. &gt;and thre are architecture and installation specific stuff in those files I'm not sure what you mean.
Why black, yapf, and autopep8 at the same time?
What variables would you even watch if you can't assign or create them? &amp;#x200B; I have seen eval() and know it can do very basic stuff, but its functionality isn't comparable to python interactive mode. Thanks for your efforts, but the search continues
This misleads people into thinking Vim is something basic that requires some extra things to get to level of IDE. Let me be clear here. Vim is a programmable text editor with its own programming language. Even without going into scripting the number of features a vanilla version of Vim offers alone makes it **much much more powerful than any IDE**. People who think Vim is basic is not even aware of what Vim can do. Tags, autocompletion, folding, terminal, buffers/windows, sophisticated regex support, diffing between files, grepping files, remote and local file/directory management with netrw and that's still just 10% of Vim capabilities. Add scripting to it and it becomes almost infinitely more powerful than any puny IDE.
I never knew Django was the only Python package worth mentioning at that critical 2005 time when ROR was about to ruin the world. Yelp, Reddit and others "used Python too". How'd they do that? "nothing much happened" in 2000-2005. OK, "history", got it.
It's like they both have valid concerns that by their very nature are difficult to reconcile... Who know software development was so hard?
The Jupyter experience in VS Code does these things for me: 1) allow you to play with code while you develop a normal module. 2) go round trip from an ipynb to code and back, allowing you to maintain source control on the code backing an ipynb. It will start a Jupyter kernel whenever you run a cell, if you haven't started one already. It helps my work tremendously, but it may not be this helpful for everyone. What kinds of work are you doing? Someone here may have some good ideas for you.
Oh shut the fuck up
New version of my open source FEA package today. I get to drop support for python 2 :)
I’d use numpy and just do np.zeros((nrows,ncols))
\&gt; What variables would you even watch if you can't assign or create them? I was going off of your original message: \&gt; The one real disadvantage of my program is the lack of a variable explorer. So, I built you a variable explorer, and a way to display expressions based on the variables in your program. \------------------------------------------------------------------------------------------------------------------------ With the target seemingly either ill defined or is a moving target, I'll spend the *remainder* of my Sunday morning building something that is more useful. Sorry to have disappointed at every step.
Atom and vim
Pyomo, PuLp
That’s the main reason I prefer Spyder.
Larry Hastings the guy who has been working on it had several pycon talks with the progress. But last one Ive watched goes back to 2015 I think.
But the boot code only works on the PDP-9.
Thanks for the reply! I must have had the environment misconfigured if it wasn't starting the server for me- noted! My goal with this investigation is to find a good way for a large group of python devs to write notebooks, saved with no output cells, checked into git as ipynb, so that they run and render as sphinx generated HTML on read the docs. Right now we've got an ok writing experience in pycharm pro 2019.1... it's just very light on the features. The other editor we use is VSCode, so I was really hoping I was completely missing something here. We require people to run nbstripout before merging their pull requests (which allows us to check it into git cleanly) The sphinx HTML on read the docs part is running great with nbsphinx. Features that are unideal in pycharm pro: * No way to restart server * No support for cell types other than md and python * Poor preview of markdown formatting (it's much worse than the normal md file preview, but I think that's a plugin) * No option to wipe output cells (beyond configuring an "external tool"- but then I need to get that external tool config out to 70+ devs) * Tab completion, argument checking etc seem more limited in 2019 than they were in 2018 * Notebooks are pro only feature Things that make me concerned about VSCode (for now) * Md cells as # comments makes it really annoying to write md cells * Converting to py makes the workflow a lot more complicated for me to communicate- and will lead to people saving py files into their docs folder and wondering why it's not rendering. * Was there even output preview for the MD text? Sorry this was 2 weeks ago and I'm on mobile right now. We're using the notebooks as a way to write cookbooks for things like microservice apis. We already have most of our docs on RTD. So, non-interactive rendered HTML works really well for us, especially when it QAs our documentation code examples.
I have a fleet of IDEs installed on my PC, but as far as python goes, I use 3 main ones : For my personal projects, sublime text 3. For my work (which uses RenPy), I use both Notepad++ and Renpy Text Editor (which is a RenPy IDE that I'm creating, to add in features I would need to be more efficient)
&gt; Vim extension I don't get this. If you like vim, use vim. If you like vscode, use that. Vim is awesome at being a small editor, but there seems less sense to make a fullfat editor constrained by the things that make vim great. Back a decade or more ago you could use vim within Visual Studio, but MS felt that external editors were not great so stopped doing that. I sort of saw sense in that, so I used vim standalone from them on, and it suits me well.
I don't know why you were downvoted for that.
i use OS, emacs
I am sorry you have had some struggles. It shouldn't be hard to get the Python up and running on Windows. Maybe some difficulties with $PATH and what not. &amp;#x200B; Keep with it. As you gin more experience, this language is very rewarding and pleasant to work with. Feel free to DM me if your absolutely stuck. &amp;#x200B; The top link has some great Matplotlib stuff within it. &amp;#x200B; Some resources: [Python Programming.net](https://pythonprogramming.net/) some great, easy to follow tutorials [The built-in functions](https://docs.python.org/3/library/functions.html) \- from the standard documentation [Official Python Documentation](https://docs.python.org/3/) \- the Bible [Printing Formatting Cheat Sheet](https://pyformat.info/)
A local vim can edit remote files too (`netrw`), pretty sure VSCode has a similar feature to edit files over ssh.
I've used [ortools](https://developers.google.com/optimization/introduction/python) before, which is useful. Requires 64 bit Python
Thank you, great short tutorials! Would you be kind to recommend some resources for this kind of (scientific) programming please! Between all the machine learning, data science, web dev and all else, I fell that numerical simulations and scientific computing as a whole should gain some traction in this sub.
I use a mix of Spyder, Visual Studio Community 2019, Notepad++. I have heard good things about PyCharm but haven't tried it yet. Note that I am not a professional developer, I just fart around on Python for work and self-education.
I'm working on a project I started a while ago. It's a news aggregator that only shows news from paywall-free sources. [nofeenews.com](https://nofeenews.com) if you want to check it out. You can also go to /r/nofeenews if you want to follow it on reddit instead :)
I’ve been dealing with this for almost a decade and a half mostly with Perl (CPAN) but also python. It’s super fucking annoying when asking about doing something in a core module to be told “just download &lt;insert some bleeding edge module from CPAN/PyPI here&gt;” and then when stating I can’t I get dragged into a dumbass philosophical argument about how stupid my company is. So many people in forums and IRC channels have no idea how a large portion of the world (or enterprise) works at all.
I wanted to learn some modern python features such as dataclasses and enum so I started working on a project that analyzes my firefox browsing history. The code is live on GitHub: [https://github.com/AndrewRPorter/my-analytics](https://github.com/AndrewRPorter/my-analytics) &amp;#x200B; My motivation for this project was me finding out about the places.sqlite database that firefox creates for browsing history. I figured this was a great place for me to start getting into data analytics with python.
I wish I could say the same. When starting and loading into the most recent project by default it took me 45 seconds. On a i7 4790k@4.6GHz, Vega 64, Sata SSDs and 16GB of ram. Though I'm running Windows, but I have my doubts if either I missed something crucial, or if you maybe aren't loading a project. VSCode time matches
What is it called?
Takes about 30 seconds to load PyCharm for me, but that's loading a big project
I am loading a pycharm project.
Crazy, did you make any special settings for optimization?
It would just get added to a packages dependencies and get installed and updated with pip along with all their other dependencies.
Is this in stable already. Thought it was only insiders
Same but I tend to use Geany if it's justva few files
https://code.visualstudio.com/docs/remote/remote-overview
used sublime for a couple years but just switched to VScode
Since you can use it to run *any* command, and play with the output of that, I'd say it's quite well integrated. I'd regularly run 'make' or 'gcc' from within vim or invoke the debugger and step through code. I've used some IDEs in the past that crash when debugging (visual studio .net), the whole project gets lost up to the last save (thankfully most IDEs autosave on program run/debug these days). ctags may be what you're missing, I dunno.
Very cool. Also be aware of FEniCS for heavy PDE work!
I mentioned that I need the interactive python console as a widget in my original message. Thank you for the effort you put into adapting your GUI for me, it has been very helpful to view your code. I don't mean to waste your time, I wish you would have asked before putting in so much work. To me, it seems like common sense that an interactive python calculator would allow you to assign variables. The need for a variable explorer makes this requirement even more obvious to me, because why would I need a variable explorer if I can't use variables. &amp;#x200B; At this point, basically all I need is an eval() equivalent that allows me to assign variables. In terms of viewing variables, I need a way to see all variables in use by the script, but I think I already know a way to do that.
My advisor is a huge fan of FEniCS' interface, but HYPRE and PETSc all have Python interfaces as well!
Oh yeah, sorry. I use autopep8 as formatter, but keeps all of them installed anyway. Now that I think of it, don't even know why.
I was looking for this. It is not bad at all. If you want something lighter weight, there's `nedit`.
I found what I needed, exec() can do what I need. while True: cmd = input("&gt;&gt;&gt; ") if "=" in cmd: _ = exec(cmd) else: _ = eval(cmd) print(" {}".format(_))
I learned most of the stuff from numerical analysis books. They have pseudocodes and get quite theoretical often. Honestly, I am not aware of good resources that avoid heavy maths and programming-focused. Even the [official Scipy tutorials](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html) went too deep in theories sometimes. Actually, this is one of the reasons I write these tutorials.
Are you sure? I don't remember seeing E used for voltage even in Physics, as E is usually used for electric field. Here is two sources, who don't mention E being a common symbol for Voltage: [https://physics.info/symbols/](https://physics.info/symbols/) [https://en.wikipedia.org/wiki/Voltage](https://en.wikipedia.org/wiki/Voltage) From my experience, usually it is V in physics, and U in electrical engineering. Maybe it is the electromotive force you are referring to? ;)
**Voltage** Voltage, electric potential difference, electric pressure or electric tension is the difference in electric potential between two points. The difference in electric potential between two points (i.e., voltage) in a static electric field is defined as the work needed per unit of charge to move a test charge between the two points. In the International System of Units, the derived unit for voltage is named volt. In SI units, work per unit charge is expressed as joules per coulomb, where 1 volt = 1 joule (of work) per 1 coulomb (of charge). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt;There are millions of "python projects", that doesn't mean that the PSF has anything to do with them. And the PSF has nothing to do with mypy: &gt; &gt;http://mypy-lang.org/about.html Mypy is under python organization in GitHub https://github.com/python/mypy I don't think I mentioned PSF &gt;&gt; Python 2.7 was essentially just backporting all python 3 features back, &gt; &gt;That's right up there with "tofu is a plot to emasculate American men" level ignorance right there. &gt; &gt;Python 2.7 reached feature freeze prior to the first stable release on July 3, 2010. That dates it to Python 3.1, so **not one single new feature** from 3.2, 3.3, 3.4, 3.5, 3.6, 3.7 or (upcoming) 3.8 has made it into 2.7. That's how their releases work at least in theory the major and minor versions are frozen and they only offer bugfixes in patch levels. That's a theory, because they broke the rule in 2.7 Take look at this: https://docs.python.org/dev/whatsnew/2.7.html It has the Python 3.1 features you mentioned but also bunch of others backported from up to python 3.4 (3.5 was released after the real feature freeze). This also doesn't mention bunch of 3.x libraries that were backported to work with 2.7 and added to PyPI.
As much as I love Anaconda (which is a lot), Anaconda’s probably a bit too heavyweight for the average user or to act as a solution to Amber’s issues. Somewhere in between the default python setup and Anaconda would probably be my personal ideal, but maybe there’s a way to accomplish that with miniconda?
Since everyone else giving bad advice or dismissing you for no reason: Automate the boring stuff (free python book) Python documentation is pretty good And the best in my opinion are courses on edx. Happy learning friend
How do you solve this? Are there any good examples? I'd rather have no bar for publishing than limit people in some way, since there is no manpower to actually set the bar. It's not like pypi is apple store that can review every framework that is uploaded. This is not just python, I have a react-redux boilerplate + testing framework, `npm install` installs 18k packages. Imagine how many broken or unmaintained packages are in that pile. I'm not saying "others have the same problem so it's ok for python to have it", just saying it is a difficult issue to solve.
Thanks. Will definitely try it out!
Good point. Could have been, it’s been a while since I had to do anything with it.
I think the largest downside of vim is that none of that stuff is easily discoverable :/
Touche. I normally don't get involved in religious debates, but I still think its funny
Next time you open PyCharm check if the anti malware service runs at the same time. If it is, it locks up whatever program is attempting to run until Windows Defender finishes scanning the program. This will occur every time you open pycharm. To fix, find the directory you have pycharm installed. Open Windows defender, navigate to anti-virus definitions, find where you can add exclusions, then add the directory pycharm opens from. If you create VENVs, you may need to do the same for those. Google “add program exclusion windows defender” and there should be better directions available.
I have just the database in mind to give this a try! Thanks for the article.
Thank you!
You uh... do realise that in at least the Netherlands (where van Rossum lives), we have about 20 parties and we vote on individuals in said parties that form the house of representatives and the resulting coalition between parties has the biggest party of the coalition pick the president (while house seats are based on individual votes for each person on the list along with a complex system for surplus votes on individuals)? Van Rossum saying he "always votes for a woman" more than likely just means, "go down the parties member list and vote for the first woman in said list". Almost all parties here have at least one woman in it, barring the SGP which is a Christian fundie party (and I _doubt_ Van Rossum votes SGP), so him saying this means very little on his political views nor does it say anything about "sexism". Source: guess where the fuck I live.
When dealing with modules from github, don't clone them and manually run setup.py. That installs it system-wide, and leaves redundant files. Instead, make a virtualenv: ``` python -m virtualenv .venv ``` Activate it ``` source .venv/bin/activate ``` ideally you should have setuptools and pip in the venv, so then: ``` pip install git+https://github.com/foo/bar ``` Or if you want it system-wide, just skip the virtualenv part. You also likely don't need Kali for that.
I have been using VS-Code with a custom CMD as an integrated command line for a really long time and have absolutely loved it so far. But a while ago VS-Code suggested to use the interactive-console for python and have kind of liked it. It is really easy to debug and test stuff really fast. But since I have joined an internship and the people there suggest me to use Jupyter-Lab, I have shifted for the same. I have found the interactive-console and Jupyter-Lab are kind of similar. But as I have been using VS for so long(2 years approx) I am really comfortable with it. At the early stage I tried using PyCharm and Spyder etc. But they really didn't click. I still really like the VS Code for everything. It has the got tracking and extention and stuff....
Ah, that's great. Now my GUI should have all the components your'll need I modified my code so that the bottom portion of the input area is for doing item assignment. All of the other places to watch variables and do computations do not involve setting a variable to a value.
I am glad to hear this. In a way, it was easier than expected. My main obstacles came from being not well versed in Django. I made few mistakes in design of database. Curiously enough, Django admin provides enough functionality for my users to fill and view basic data. The next step would be custom report views I am about to implement in future.
Grab a good book/tutorial for OOP fundamentals. Having an OOP mindset takes time to develop through learning and practice. I had seen c++ software developers that abused the use of inheritance, creating giant God class, and "very-hard-to unit test"/rigid designs that could be achieved by using composition and dependency injection. Also, you will further appreciate OOP once you dive into design patterns.
I have an old machine, like, 2008-spec old. Running Pycharm in a *VMWare VM* takes 4 seconds to startup. It takes longer to *index* larger projects, but this thread seems to be about small ones. No optimizations on my part. It could theoretically be mix of your system's prefetcher and a slow disk?
I’m not a fan of scapy for a few reasons, but most of all is the fact that typical use cases require you to clobber your global namespace by importing * from it. That’s just a terrible way to write a library.
Also, [Dilbert](https://dilbert.com/search_results?terms=We+Didn%27t+Have+Zeros)
VS Code. As someone who's hated Microsoft most of their life, I'm not gonna lie, I like it and I've had less issues with it than I did with Atom.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
The NEW REPL [https://repl.it/@PySimpleGUI/PyVariableWatchesAssignmentsExpressions](https://repl.it/@PySimpleGUI/PyVariableWatchesAssignmentsExpressions) &amp;#x200B; The old one stopped working for some weird internal-to-repl problem. &amp;#x200B; So, I created it again. Maybe I got it right this time?
2 for me, but I don't want to load every project I work on into a fully fledged IDE, if all I am going to do is proofreading, and small adjustments. Especially when said project consists of runme.py and README.md. I dunno how I should word what I mean so it may become clearer.... The first thing that comes to mind besides habitual usage is separation of concerns. I launch VSCode whenever I don't have need of more advanced features like debugging, remote interpreters, integration into issue tracking and stuff like that. When I want to look something up. When I don't want to rip out the heart of a project and replace it with a different one or jot down some pseudocode or stuff like that. If I don't want feature overload, so to speak.
Great advice. Thank you very much!
That's not true. Terminal vim was designed to provide a minimal interface so that it can run using minimum resources on most machines. But the online `:help` system is one of the best features in Vim and one of the primary mistakes beginners make is not learning how to use this help system. You have a tutorials and detailed references as well as a powerful search and completion that enables you to jump to any part using keywords. For those who want all the buttons and menus like IDE, there's also a graphical version of vim (gVim) that provides access to these features as well the help system make it more "easily discoverable".
You are quoting parent poster and make it look like I said it, I don't disagree with him, but it is confusing. People are hesitant about migrating existing codebase and many won't do unless it is absolutely necessary. Migrating existing code actually is not so bad and only looks scary. If your code is small the migration is trivial, if your codebase is large you will have unit tests which help with testing. Most of changes are mechanical and can be done by automated tooling, the biggest issue is bytes vs text. That's where type checking can help, although it is a bit of work, but it offers additional benefits over porting to Python 3 (with IDE that understands it you also get autocomplete, better refactoring and of course catching typing bugs). For people that do not want to waste their time with typing chances are that in most code str in Python 2 supposed to be text so it translates directly to Python 3 str(). Bytes are generally used for I/O (other than accessing files, since Python 3 abstracts that away) which most people aren't doing in their code instead rely on libraries (Python's open(), requests, frameworks like flask, database packages etc) that do that for them.
I'd advise you to make the switch to another database sooner rather than later. PostgreSQL is free, scalable and easy to install. Migrating data from one RDBMS to another is always a pain and the longer you put it off, the more of a pain it will be.
Thanks!
Now that you put it that way, I think I understand what you mean. I have MS Word on my PC, but I often use Notepad++ because I don't need a full GUI of features when I'm just taking "ugly" notes on something.
I mean... I agree that what you mentioned are great and helpful features, but doesn’t mean it’s easy to use. When the answer to “How do I exit the Vim editor?” has 4400+ points on StackOverflow you have to admit that features, even a most basic feature as exiting the editor, are not easily discoverable.
Please sir, repent your sins and look upon our Lord, Pycharm.
Maybe I should add that my first contact with computers was where resources were scarce and space always an issue. So it just might be a habit from 'ye olden times'
Can't write a .vimrc? What special hell is this?
Pro tips are always in the comments
&gt; Until the end of the year. Then it's dead. Right, but we've heard that before. &gt; Downloads of Python 3 surpassed Python 2 downloads back in 2013: This is really irrelevant. There are far more ways to obtain python than downloading it from python.org. &gt; To quote Drew Crawford, Who says absolutely nothing about security patches. Seriously, instead of arguing with me, you could just wait 7 months. We'll see if the Python Software Foundation cracks again.
Right, the aggregates are tied. But in terms of CI affecting the numbers, I'd expect all point versions to have the same uplift. Which is what leads me to think that the uplift is not significant.
Allow me to tell you a neat little story about my company. We have a server where multiple devs are logged in at once, with ONE FUCKING ACCOUNT. One account that everyone shares. Name of the account is "indev". Before me people tried to modify the system according to them. It was a total chaos as you can guess. So no one is allowed to write to any files which aren't related to the project you're working on.
Oh... wow. I suppose that does explain it...
With academic license there is gurobi and Cplex
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
I can’t tell if you’re serious or this is a parody of something
Yeah, I can see where the .py to .ipynb would be complicated in a team environment. We all suffer from the fact that Jupyter notebooks with output included are piles of JSON. it's the one area where R markdown notebooks are the superior experience. Right now I don't know of something that scratches your itches.
They are probably referring to that bs a few months ago to balance out the decision makers of the future of python. basically morons that want to put social justice in front of actual engineering.
Not very inclusive of you to assume they are all cis.
[No one ever hear of gender diversity in Nursing or number of other fields.](https://onlinenursingms.com/resources/general/men-in-nursing/) Why couldn't this field just like any other fields?!
How could diversity in gender not be a serious issue in IT? This field is fully dominated by males and doesn't allow woman to get familiar with it. Or do you really think it doesn't matter? I am open for a conversation.
Take a look at the Node.js embarrassment over identity politics. Do you really think repeating that mistake is going to advance gender equality?
Why are you so racist against cisgenders?
And why would you stop someone doing what they're good at for any other reason than their capability to do it?
Looking at the posting history, I'm considering this a troll account.
Speaking of gender restriction, WE NEED MORE FEMALE PLUMBER and FEMALE MINER or even FEMALE MINER PLUMBER!
Social justice is required everywhere. Particularly in engineering. In this field, people define themselves by their skill and understanding. What if someone who lacks the talent wants to be an engineer? These people -and among them are many women- get bullied for their lack of understanding. But people should be appreciated for what they are. Cold an inhuman behavior are not seldom in this field. Diversity in gender would fix that.
Social justice is required everywhere. Particularly in engineering. In this field, people define themselves by their skill and understanding. What if someone who lacks the talent wants to be an engineer? These people -and among them are many women- get bullied for their lack of understanding. But people should be appreciated for what they are. Cold an inhuman behavior are not seldom in this field. Diversity in gender would fix that.
If your machine has decent specs, Pycharm is the IDE you'll ever need. Never looked back. I use it at work. To write small scripts i use vs code.
It sounds like there's an unfilled role for third-party trusted code vetters to maintain versioned + hashed lists of "safe" PyPI project releases.
Also need them sweet sweet in number of other field. like, WE NEED MORE FEMALE PLUMBER and FEMALE MINER or even FEMALE MINER PLUMBER!
Am not gonna respond to that one because that is disrespectful.
Nobody cares who makes the software. While I am all for woman in stem careers, the solution isn’t to block out males from participating. That’s not giving women a fair chance, that’s just artificially altering numbers so it LOOKS like there are more amount of women coding. When I took computer science classes at UH, it was the most inclusive experience I had ever had. Women were encouraged to get involved with it. There wasn’t a single thing stopping average women from getting familiar with the practice. While it may be true that not EVERY place is like that, I for one, believe and have seen proof that the world of computers is very welcoming and open to women. Not once in my life have I ever seen someone involved in any realm of computers ever try to tell a women she couldn’t participate due to their gender. I think it would be a better use of everyone’s time to, instead of trying to manipulate numbers by blocking out one demographic, try to teach young girls that it’s okay to like stem and that they are valuable candidates for future endeavors. If you try to block males you will be no better than those in the past who told females that they can’t be scientists, astronauts, programmers, artists, musicians, you will be no better than the same evil you are trying to defeat.
shit
There is so much wrong with that statement. First, it us not about what you are good at, but who you are. If you are an engineer , it doesn't matter whether you are good or not as good. Why do you define people by their skills?
I took the bait, damnit. I don’t know what subreddit this would fit into but at least include me in the screenshot.
Why does it require that import style. Could one just use dot notation to dig down into the library the normal way?
Gedit
You are a moron or a shitty troll. How about you put your money where your mouth is and go get on a plane where the pilot is a SJW hire that’s untrained i’ll get on a plane with a 20 year vet. You won’t because you are literally insane.
No. The fact that there are more males is what excludes females. They are intimidated. So the only solution is to "block out" males such that woman feel more comfortable to investigate that field.
I took the bait. Gg troll, include me in the screenshot.
That is another problem: So many people get emotional about that topic because it threatens their comfortable position. I didn't say they don't have to undergo basic training. That is important too!
Do you need to interact with your graphs after creating them? For example, Matplotlib can be used to create a graph and then also has an interactive mode. It's not possible, that I know of, to enable both the interactive mode and using a GUI. Take a look at the [Demo programs](https://github.com/PySimpleGUI/PySimpleGUI/tree/master/DemoPrograms) made by PySimpleGUI. There are a number of them that are directed at plotting. I see at least 9 of them in [that Demo folder](https://github.com/PySimpleGUI/PySimpleGUI/tree/master/DemoPrograms). I like the Browser Paned the best as it's a clever use of a Widget, the Pane, that I rarely get to use.
That is another problem: So many people get emotional about that topic because it threatens their comfortable position. I didn't say they don't have to undergo basic training. That is important too!
That is another problem: So many people get emotional about that topic because it threatens their comfortable position. I didn't say they don't have to undergo basic training. That is important too! Btw: most plane crashes were caused by males Look at the statistics ;)
I don't. I define people's skills by their skills.
Nobody cares about your feelings, if you want to code, then code. A program has no gender.
But the skills are secondary. We need to create a safe working environment at all costs. Minorities are many times bullied. I can't imagine what some woman go through in this field.
Are you sure you are not a female miner?! You can plumb my pipe anytime! ;)
Thank you so much! I am currently writing a class at my university for scientific programming with python -and this is an inspiration. Any idea how I can "cite" you in my material?
But you could make a pink interface for example. Only woman would use that or people who are completely gay!
Thank you for your contribution friend
I'll try to ignore that sexual harassment and tell you this: Nobody wants to be a plumber. It is disgusting. So there is no diversity required there.
VS Code
Using the intimated excuse is stupid. If you are too intimidated to do something, get over yourself and do it. There are plenty of things I’ve been intimidated about and almost didn’t do, but I did it anyway. Most of the time it was fun and I succeeded. Sometimes I didn’t. Also if someone doesn’t have talent and wants to be an engineer, that’s what other jobs/fields are for. There is no way someone should get a job they can’t do just because they are x thing. I’d love to be a race car driver. I don’t have the talent so guess what...I have an office job instead. :)
I am sorry to hear that you were not able to pursuit your dream! But not everyone can overcome their fears like you. Particularly woman. They are weaker because of their nature. We need to support them instead of coldly saying: "get over it"
the 'years &gt; 5' isn't strictly necessary, either if years aren't less than or equal to 5 and it falls through to the next case, years are already &gt; 5
&gt;... It is disgusting. So there is no diversity required there. The job is not disgusting, you are disgusting for mischaracterize the jobs!!!! I know a lot of smart and intelligent plumber and miner! You need to stop being so damn closed mined and give both professions a try. You might love it!
Plumbers probably make more than you do, and it's a job that doesn't require much in the way of physical attributes, and it's really only gross like 5% of the time.
Seriously, I considered it but honestly it was much pain. I made all the deployment myself with no support of our it department. They have no knowledge of linux. Just backup by copying one file is way too much for them. Furthermore, it is just intranet application that will never be used by more than 20 users max. From what I have read Sqlite should be more than enough for my purposes.
You *can* do that, it’s just been my experience that it breaks when you do that. Without looking into it too much I would guess it’s generally using global dependencies that it expects you to import this way from its own package. Bad design. Also it’s pretty terrible for packet analysis. You’re better off using tshark via subprocess.POpen for that tbh. If you need to craft packets, scapy is *ok* but that’s about it.
Preferably the charts would be interactive as it would be a lot nicer. I'll look into PySimpleGUI, thanks!
OK, this time for SURE, right? [https://repl.it/@PySimpleGUI/PyVariableWatchesAssignmentsExpressions](https://repl.it/@PySimpleGUI/PyVariableWatchesAssignmentsExpressions) &amp;#x200B; I THINK I've finally conversed enough finally get enough of an understanding to make improvements. &amp;#x200B; Now you interact only through the top line, unless you want to monitor some variable or expression. You can monitor a formula based on variables and when those variables change so does the output. Here's a screenshot to demonstrate what goes where: [https://user-images.githubusercontent.com/13696193/57986611-0bc06100-7a45-11e9-8d99-1141aac0f81f.jpg](https://user-images.githubusercontent.com/13696193/57986611-0bc06100-7a45-11e9-8d99-1141aac0f81f.jpg) &amp;#x200B; By the way, this works with other versions of PySimpleGUI, including the Web port for example.
Yea, the problem is that you've got 2 GUIs fighting. I've never tried to spin off the Matplotlib .show() command as a thread, but maybe that'll work. To date, it's been one or the other.
I think people are not emotional! They are just too closed mined and not willing to try new opinions!
Ah, I see. Thanks.
So you want to create a separate interface to segregate women and gay men from everyone else?
Many ignore the intellij Editor like PyCharm, PHPStorm, Goland because of performance. All of then written in Java, it means they are all ram consuming. Besides, the Pycharm UI is super ugly compared to VSCode, lack of extensions. &amp;#x200B; I know PyCharm has the best suggestion, but on the large scale project, i use type annotation for Python, and it works well on VScode day by day, so i don't see any reason to come back to PyCharm again.
Interesting project, I look forward to reading about the results when they are available. I love data gathering and this is right up my alley
Aka, you hate this person and are determined to replace them with a small shell script.
I am planning to do some preliminary analysis in the next few days. I can already say that Google clearly dominate the web, so whenever you go, Google know! Also, in the last line of the blog I mentioned the GitHub repo, with data and code to reproduce the data. Feel free to hack or analyze the data as well!
Um, no. I'm literally wearing pink socks as I write this. Neons happen to be my favorite colors. Traceback (most recent call last): File "reddit:/OP/is/an/idiot.py", line 23
Python is so easy without IDE. I only use python + documentation. By time you start remembering the commands, Python becomes your second nature. But this is hard in the beginning. In Linux you can try KDevelop, it has become good enough. In Windows you can maybe use Eclipse with PyDev plugin.
Can't you just specify your custom `.vimrc` via `vim -u /path/to/vimrc` and put it into a place that nobody cares about?
That seems like a good solution but like I said you're only allowed to edit/create files in your directory and that directory is of the project you're working on which is pretty much under GIT always. So don't wanna create a file unrelated to the project nor do I want to change the gitignore file. Mind you I've only been working there for 3 days...
Woman are meant to operate in positions where you need decision-making, management and character. For example, Angela Merkel who is leading Germany has optimized the country very well. Man are optimal for doing physical work and following orders. What I mean by diversity is that there should be as many woman in leading positions as men in 'plumber' positions. That is the original meaning of diversity.
I wasn't in the room for this one, and I wasn't at the language summit itself, but I was at PyCon this year, so I have a little context. First some indisputable facts: - These talks are not recorded. - They're meant primarily for those who are implementers of Python (CPython, Jython, Pypy, etc.), and so the talks are meant to be about the language proper: problems different implementers are having, etc. - They're meant to be discussion oriented formats, not just a person speaking. - Amber's was a 30 min and right before lunch - the summary is an official PSF summary created by Jesse Jiryu Davis, who as far I know has no affiliation with any of Amber's projects Some speculation: - Maybe Gudio just went to lunch rather than continuing a discussion that he felt was unproductive - Maybe Gudio didn't feel like the rant was too much of rant (since he asked "what was the point?") and lacked anything actionable other than moving async to an external library: which at this point is a really, really tall ask IMO. - Maybe Guido read into the discussion a desire to "hold back" Python or "empower" Twisted on Amber's part, since Twisted is one of the main libraries people used to reach for when handling async like things (even though it does much more than that.) and it seems like it's going to past the Python 2 EOL. - Maybe there's prior conversation we're missing from here, and we're only seeing the tail end of what has been potentially a very long conversation.
No I just want an interface that is also appealing for woman. All the interface available on programs like python were created by men for men. And that is a problem.
You mentioned of using excel over a shared filesystem. I would be a bit concerned storing sqlite3 on a network filesystem and be used that way. It can work, but there are many bugs that can corrupt the data. Here is a page which says where it is good to use sqlite3 and when it's not: https://www.sqlite.org/whentouse.html
Yeah but people don't like this done to them, reminds them of China surveillance, you should stop while you can, this is not the way.
That activity is NOT for woman. I already explained in another comment that woman are ideal in leading or management positions.
I'd not make it worse by moving parts of the stdlib to PyPI. The more is in PyPI, the more used we get to grabbing half a dozen packages from it in one go just to get a package to work, the less diligent we will become. I don't have a solution. Maybe some sort of review process like the Debian project?
How often do I have to tell you that such activities are NOT for woman?
We always have to go one step at a time.
Maybe you should rethink the reason why you like pink. Do you like it because you actually do? Or is it because you're reinforcing gender stereotypes by liking only "girl" colors?
I wrote a command line utility for [reserveamerica.com](https://reserveamerica.com) to check my favorite campgrounds for specific site types and send me email alerts if any come available. It runs on my raspberrypi using selenium and argparse.
I think you misunderstood. I used access file from shared location before. Sqlite file serves as database for Django app on virtual linux server. Which is small web application from your list. I do not access sqlite directly if you think so.
You're saying women can't be good plumbers? Come on guy. It's $CURRENTYEAR. Women can plumb just as well as gays, trans-sexuals, and my cousin Bubba once he gets out of county.
Ah I see, I thought people were running the django app locally directly from a share. If sqlite3 database doesn't live on a networked file system and it's just accessed by a single app, then my concerns don't apply.
 defaultdict(lambda: (sys.getrecursionlimit() - 1000, sys.setrecursionlimit(sys.getrecursionlimit() + 1))[0])
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/datascience] [UPDATE: A review of 6 Python Deep Learning Computer Vision Courses (WARNING LONG).](https://www.reddit.com/r/datascience/comments/bqli8q/update_a_review_of_6_python_deep_learning/) - [/r/u_screamingsmile96] [UPDATE: A review of 6 Python Deep Learning Computer Vision Courses (WARNING LONG).](https://www.reddit.com/r/u_screamingsmile96/comments/bohl0b/update_a_review_of_6_python_deep_learning/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Congratulations on your first project, keep up at it! * in [flash\_messages.py](https://github.com/redasalmi/Python-Package-Manager/blob/master/flash_messages.py) I feel like it could be simplified to just &amp;#8203; def flash_messages(package, operation, response): """Print flash messages once on the web app depending on the operation""" option = { "up_package": " has been upgraded successfully" if not response else " hasn't been upgraded, something went wrong.", "del_package": " has been uninstalled successfully." if not response else " hasn't been uninstalled, something went wrong.", "up_all_packages": ", ".join( [pack["name"] for pack in package] ) + " have been upgraded successfully." if not response else " haven't been upgraded, something went wrong.", "install_package": " has been installed successfully." if not response else " hasn't been installed, something went wrong." } if not response: flash(package + option[operation]) else: flash("Sorry, but "*response + package + option[operation]) instead of repeating the checks over and over which would violate the DRY principle( Don't Repeat Yourself). If you ever find yourself repeating a line over and over, sit back for a minute and try to think of a way to avoid it. * in [proxy.py](https://github.com/redasalmi/Python-Package-Manager/blob/master/proxy.py) instead of concatenating all those numbers by hand, you could have done it like this &amp;#8203; def proxy_str(proxy_lst): """Returns the proxy as a string""" proxy = [str(p) for p in proxy_lst] return ".".join(proxy[:4]) + ":"+proxy[4] If you aren't already familiar with list comprehensions, I recommend you to check them out. They are really great to use. And if you are working with strings, before trying to implement something, try to check out first if there isn't already a method in the standard library that already does what you are trying to do. It would save you a lot of time + being more rigorously tested. Which brings us to the third point, tests. If I am going to use something that is going to manage my packages, I would want it quite tested. After all, you don't want it to some unforeseen error to upgrade the wrong package. &amp;#x200B; Overall this is a good start! I am quite a beginner myself so don't take this to heart :)
I just tried imagine setup like this. It would be crazy. :)
HOW CAN YOU DISCRETE AGAINST WOMEN LIKE THIS!!!! THIS NEEDS TO STOP!!!
Thanks again for the help! Yeah the hardest part of such a large team is that any time spent learning X is multiplied by the entire team, and they need to see how X benefits them doing their job. Despite jupyter's complexity, and even with Pycharm Pro being suboptimal in this area, I think we've finally got a good enough workflow to make this easy.
There should be equally amount of female plumper as in any other position. The skills are equally valuable no matter how it's applied! THE DISCRETION against female plumper has to stop!
This is fascinating. I am a high school teacher and my main Markbook is in Excel. I could have so much more control over the data and analytics (trends for each student, etc) if I was storing it in my own custom database. Your post (and the suggestion someone else made to use a version of SQL) may be a game-changer !!
*Patiently awaiting emoji integration into the compiler
¯\_(ツ)_/¯
My first thought too
I searched for the link and it didn't come up
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
It's true, all of JetBrains product are memory hogs. I consider it to be small price to pay for the features though. PyCharm has simply the best features of any Python IDE I tried, and don't get me started on how good CLion is.
I just want to say that you don't HAVE to create a venv for every new PyCharm project. You can also use any venv manager that you like. Personally, I always use Anaconda, and tell PyCharm to use my Anaconda env in the project.
It is typical that male suppressors blame people people like me for being sexist. Look in the mirror. I am a feminist and protect woman. You want them to have unpleasant jobs!
Of course they are just as good. But they are even better as leaders and decision makers.
No one has to discrete them. Woman are smart enough to understand that this job is for the lower part of society :)
Those sound much more fair. To say that he "left in rage" is a really bold interpretation that would take much more evidence. It's far more likely that he just left because he didn't find it useful as you say
I have a co-worker who uses reportlab and loves it. I don't have first-hand experience, unfortunately, but there at least something.
If you want to help you brother, create him a Shopify site ;)
I want them have equal access to all the job opportunities!
Most major packages have already ended support for Python 2: https://python3statement.org/ There's no reason to extend support for Python 2, nor is there any will to do (nor volunteers). That Python 2 won't do you much good when Requests, NumPy, SciPy, Pandas, SciKit-Learn, TensorFlow, Jupyter, Cython, Django, etc. are no longer supporting it.
I've had quite a few issues with Python 3.5 on my open source project that supports Python 2.7, 3.5, 3.6, and 3.7. If there was one build failure, Python 3.5 was usually the broken one. I'm killing both 2.7 and 3.5 today.
the click bait title is a bit annoying, especially since it's one of the most obvious steps one will take when you realize excel is a database for people who dont know about databases
But the compiler gives very helpful error messages and prevents you from shooting your feet.
WingIDE. It's got a great debugger and it's not slow like PyCharm. I have a core i7. I can't figure out for the life of me how to make it usable.
Hi , sorry but I have two ask , are you incrementing outside of the else statement ?
Are your indents correct?
That's because Reddit's search sucks. It won't find exact URL matches. But you can still search for the _title_ and, again, _look at the front page_. This was still right at the top when you posted.
Hey, student here just learning python in the past couple months. &amp;#x200B; I'm trying to learn how to use GUIs and wanted to follow along with a Sentdex tutorial on youtube. I use Visual Studio 2017 and I can't seem to figure out how to import PYQt4. I cant locate it in the packages section. Do they only support the new version? I downloaded a version of PyQt4 from their site directly. Is there any way to import it directly from there? &amp;#x200B; Any help would be awesome. Thank you
because you posted in /r/Python instead of /r/learnpython Start by getting rid of the continue. Then format your code for reddit (see "formatting help" below the text submission box).
/r/learnpython and read the sidebar.
Sorry i am kinda new to reddit too, what exactly is the sidebar lmao. (I am currently on a phone).
No need to use continue. Just use if (number % 2 != 0$
We have [a pretty long list of learning resources in the wiki](https://www.reddit.com/r/learnpython/wiki/index#wiki_new_to_programming.3F). Try a few and see what resonates. For a brand new programmer I'd recommend automate the boring stuff with python. Also, if you don't have one already make sure you look for a project that interests you and start on it as soon as you can. Programming is a lot more fun if you have a goal. Come visit us in /r/learnpython if you get stuck.
google the name of the reddit app you're using + sidebar. Ultimately, https://www.reddit.com/r/learnpython/wiki/index is what you're looking for.
Thank you so much for your help!! I’ll definitely check that out!!
When you have to get stuff done quickly and you have lots of projects that you're dealing with, this is IMHO the best combination. IDEs are way too slow. Plus vim and tmux is just too cool.
and considering I do this, it takes some time to load all the things before I can do anything?
Google "learn python"
But you do nothing to implement that! That is called hypocrisy.
Because you have built an infinite loop. The continue-statement jumps right to the next iteration of the loop when called, ignoring all following lines of code inside the loop, including the increment of your counter-variable, leaving the value of “number“ at 0. Since the condition of your if-clause is true for number = 0, you'll always step inside and call continue right after. You definitely should review loops and when to use which kind of loop.
i've got a brand new i7 at work with 16gb of ram, and all of the jetbrains IDEs take longer than that to load. what kind of machine are you running? or do you have some VM performance tweaks? load time has never been a detractor for me because...well, it is a negligible annoyance at worst. im just curious
What are you talking about!!! I'm shouting and screaming in ALL CAPS on Reddit AND Making people feel bad about themselves! What more can you ask of me?!
hell, i even do creative writing in it
not really. there are a finite list of options. each thread will mention just about all of them
I always recommend Corey Schafer's channel on YouTube. He explains things very well and he has a lot of interesting projects.
Done: [https://github.com/prodmodel/prodmodel/blob/master/example/build.py#L1](https://github.com/prodmodel/prodmodel/blob/master/example/build.py#L1)
Vscode with black for auto formatting on save.
They are most certainly wrong.
Or you could do number = 1 and remove the if statement completely and do number += 2 :)
True!
I'm running on a machine I built in 2015. 4.4GHz i5-4690k, SSD drive, 16GB RAM. You don't mention an SSD in your post; if you don't have one, I'd assume that's the main constraint. Read times from good solid state drives are substantially faster than hard drives.
I'm working on a little script which uses Gmail API to find specific emails and parse the data of each and then import them into a google sheet.
The only tutor you need is google. Please dont pay for a tutor...
best place to start imao [https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html)
Try these: - [Learn python the hard way](https://learnpythonthehardway.org) - [Automatic the boring stuff with python](https://automatetheboringstuff.com/)
[Atom](https://atom.io/)
Another great (mis)use of excel is as a user interface for scripts. In a corporate environment everyone has a license and are used to working with it. You can easily put instructions together with the actual configuration info. There's basic input checks and you can easily create drop downs and color code cells to indicate completeness etc. There are many libraries that can then read the files to make everything available in Python. My preferred one is probably Pandas as its often at the core of my scripts any way. The actual scripts run on a server with mapped drives for file transfer and remote access for executing the scripts, sometimes with a minimal gui to select input and output files and folders.
&gt; Ignorant because I made a bit of an exaggeration with three people? No, ignorant because you don't know that most people in schools, corporations, big enterprise developments or government don't have the luxury of saying "Fuckit, I'll just download and install some random package from PyPI". These are people who *can't* "get pypi stuff". Ignorant because you seriously suggested *printing out third party libraries and retyping them in the office*. &gt; The instant dismissal thing was followed by bringing in paper (which could be reviewed prior to use). Jeez, this shows your serious levels of naivety. Perhaps that was a better word than ignorant, although really they mean the same thing. Do you think that software review takes two minutes? In many government and big enterprises where there is a requirement to do due-diligence, software review can take three to six months of elapsed time and require dozens or even hundreds of person-hours, including having lawyers check the IP and licensing,
Hi, just cite the webpage with my Reddit account name is fine. I would rather not to reveal my real identity here.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
why would you ever even consider a private tutor? that's insane.
i had the code indented. reddit just moved my post right aligned.
I'm a programmer as a career and hobby. One of the most important skills a programmer has is being able to find information on their own. Asking a question is often a last resort and means I'm really, really stuck. So yes, follow the top comment and Google "learn python". Evaluating the search results and finding something that's right for you is the first and most important skill you'll pick up.
This is so fun. Thank you for making this. I'm learning Python right now, and I'm having a blast not only playing the game but picking apart the code and learning!
VS Code's overhead is just so much less, making for quick startup times and less system resources. I've started using VS code primarily though because there are plugins for almost anything, and I regularly use 3-4 other languages daily. PyCharm is definitely what I started off with, not being really fluent in the language, but after a few projects and being able to whip something up pretty quick, it's just easier to use VS code. But I just use python for small tooling and parsing projects, so I'm not making anything that's needs a lot of structure and maintenance.
I am afraid there is no free Python resourced out there, sorry dude.
I'm hesitant to say no as I haven't worked on Windows in ages so I'm not sure how the new Linux subsystem might change things, but I am pretty certain it won't work. Best bet might be to build a Docker image that has everything set up and execute the conversion commands in a container.
As a multilingual developer, I find pycharm too limiting. Eclipse works for me because I can easily shift between python C++ Go etc
`pathlib` is your friend. No need to know what slash you need to use, other than the first. Windows kind of requires `C:/`, but everything else is `/`. import os from pathlib import Path desired_path = Path('/','users','USERNAME','developer') os.chdir(desired_path) Or just `os.chdir('..')` until you are in the right place.
I really liked your write-up and I also browsed through your sample code - the only part I didn’t fully understand (and sort-of disagreed with) is how you handled registering your routes. It seemed a little bit round-about in registering the various routes in the way you’ve proposed. Aside from the routes, I think this is a really great pattern and most importantly TESTABLE! I hope to read more of your write ups in the future!
Yes, that's basically what pyautogui is for.
Not enough details. I would try it on your regular PC first and report back on bottlenecks.
interesting OP - i will check out your post in more detail later. be sure to check out [Flask API Spec](https://github.com/jmcarp/flask-apispec) - it mashes together swagger and marshmallow support with Flask.
Though learning 2.7 for a job provides a decent incentive, Python 2 has been on death row (so to say) for years and is nearing its (hopefully) final death blow (see this website: [https://pythonclock.org/](https://pythonclock.org/)) I would recommend finishing lessons on 3, and learning 2 if necessary for the job, but don't get comfortable around it. Ideally, in the coming years, more migration to 3 or trans-compilation to other languages (such as Golang) will be commonplace. Good luck with the job regardless.
You can add plugins for other languages.
Python 2 is end of life as of next year. If they don't upgrade, they are accepting an ever increasing security risk by running on an unsupported version. I don't understand what the 2.5 years has to do with anything. I've converted much older (and likely larger) codebases. It takes some effort, but it's not some impossible thing.
https://pythonclock.org/ At time of this post, you have a little over 7 months before Python 2 won't receive any more updates. Maybe keep learning Python 3 and read up on [porting](https://docs.python.org/3/howto/pyporting.html)? It tries to show all the differences between 2 and 3. There are converters out there to aid in this effort. So what I would do is learn 3 and learn the differences between 2 and 3. I would also grab an IDE that can help you write v2 code. PyCharm is a good on for this, as you can install 2 and 3 on the same system and use venv to run under 2. Or just use something like this to write 2 and 3 compatible code: https://python-future.org/compatible_idioms.html
I'd continue learning Python 3. Python 2 is EOL January 1, 2020. People will still use it for years to come, but for your future career, you're more likely to benefit from knowing Python 3 than Python 2. I don't think they're so different that you won't be able to understand and contribute to a Python 2 codebase in the short term, and knowing Python 3 will give you a leg up applying for future jobs. That said, I wouldn't assume there's no hope of converting. In fact, there could be an opportunity for you to help them convert their existing code from Python 2 to Python 3. That's what one of our interns did last summer. Lastly, you didn't ask, but it's a little suspect that a startup made the decision to use Python 2 in 2017. I'm sure they had their reasons, but it's a bit shortsighted, and suggests a bit of pain in their immediate future. This doesn't mean it's a bad choice for an internship, but definitely something to keep in the back of your mind.
If you are already using Excel, I highly recommend keeping it. Over the past couple of years, they've built out a strong Data Model (https://support.office.com/en-ie/article/create-a-relationship-between-tables-in-excel-fe1b6be7-1d85-4add-a629-8a3848820be3) that functions as a relational database, plus the analytics are solid too. The Django setup is pretty heavyweight if you're looking at a single user of your final product.
Nice! Out of curiosity, do you have a list with the next commands that will be added?
Why not a Pi?
What a comprehensive post. Thanks a lot.
The only true python ide.
I really want flask-apispec to continue development. It holds a ton of promise and does things the right way. However, the documentation is severely lacking, and it needs a ton more example code. Honestly reatplus is kinda awful, but at least it's well documented
I will have to check thos out on Monday. Working on a rest plus api, and I whipped up a similar marshmallow helper called plushmallow. Not publicly available, and if flask-accepts is up to snuff, it won't need to be!
&gt; since python is working with very few threads it makes sense to go for high frequency cpus rather than high core counts. One way to get around not writing your code for multi-threads/processes is to run several instances of the program. If you have a list of websites you'll be scraping, split it into several lists and give one to each instance... `myprogram.py listA`, `myprogram.py listB`, etc.
[https://github.com/LimaBean2091/JackAssembly](https://github.com/LimaBean2091/JackAssembly)
Is it running currently?
Yeah, pro-only it looks like: [https://www.jetbrains.com/help/pycharm/configuring-remote-interpreters-via-ssh.html](https://www.jetbrains.com/help/pycharm/configuring-remote-interpreters-via-ssh.html) &amp;#x200B; Editing remote files is as simple as using SSHFS or similar to mount them locally.
Welcome! Really glad you enjoy it. If you have and questions about the code feel free to message me. I tried to keep it straightforward enough that if my daughter ever got curious how it worked she might be able to change it around into a different story.
r/learnpython
Hi, I messaged you on here regarding your handling of the "math" command, please take a look!
Nano.
As a wild guess, 2.7 is super popular with machine learning companies and academics because that's the version scikit-learn got really big on.
I agree. there’s a promising development from tiangolo for a new, similar framework called fastapi. However I am also looking towards Django or other, more batteries included frameworks for any new big projects. It’s tough trying to get all the pieces right for flask!
scraping will almost certainly be network limited rather than cpu limited. Even on the fastest network, you're still bound by how fast the remote sites respond which will probably the majority of time spent. It's possible a slow drive could cause problems, but it really depends on how much data you're looking at.
I5 2500k here with an ancient SSD. PyCharm seems to load about as quiet as VSCode for me. I use vim, in any case.
PyCQA
Congrat's. If you're interested in genealogy you could always [support](http://sourceforge.net/p/gramps/donate/?source=navbar) /r/gramps/ genealogy software, although I believe they are more interested in regular developers joining the project :) FYI I'm just a user of the program
He may just be talking about the keymapping extension, which I can't imagine living without. But I also have the vim navigation extension on Firefox and would prefer it systemwide...
Check out PyInstaller, specifically the [\--add-binary](https://pyinstaller.readthedocs.io/en/stable/usage.html#options) option.
I took a class on edx.org to get started. I would definitely recommend it.
https://pypi.org/project/emoji-encoding/
Not really, i recently added a cat command but its really in its experimental stage, can be invoked by \[cat:\]
Now, yes
That's some diabolical shit.
&gt;2.5+ years work, so no hope of converting Are you sure? Depending on what the code base does and what libraries it uses, this may be fairly easy. Most maintained libraries are now Python 3 compatible if not specifically targeting it, and there's auto conversion tools that go py2 -&gt; py3 pretty easily. Not saying it would be zero effort but it might be a worthwhile investment of a little time to move to latest supported python and libraries -- otherwise you leave it open to security issues and will have to maintain those old libraries yourselves. Of course I understand as developer that's probably not your call to make on your own but might want to ask the job what their plans are for py 2 end of life -- they need to have a plan to either port or prepare to maintain their own fork, a security issue could be the end of a fragile startup. In general you'll probably want to stick with py3 as it will be the standard going forward. Py 2 is not so horribly different so you can learn the differences when needed later. In my experience most of the practical difference is in how strings are handled.
Nope
You also have NumPy, matplotlib and other critical packages back then...
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
I scrape stock prices every minute during extended trading hours. I just run this on an HP Compaq Elite 8200 with a second gen core i5. The OS sits on a SSD and I've got 12GB ram. It's more than enough for me. It's about a $250 rig give or take. Using Ethernet, not wifi.
Thank you for the suggestion! I'll take a look and see if I can use it. If anything, it looks like a great resource.
100% focus on learning python for the environment that pays you. So python 2. Once you're feeling comfortable, start future proofing yourself by learning 3. But an employer will look more favorably on a candidate who was able to successfully complete the task at hand than someone who is studying two similar languages.
That looks great! I'll give it a shot.
So if pypi isn't an option, if these third party libraries aren't involves, why should we keep the bugs? Let's define who *needs* these bugs and is going to be hampered by running current python and non-current pypi packages. You're calling me ignorant while objecting to my scenarios (albeit farcical) that back Brown up. Clearly I've failed to steelman her argument, so I'll leave it to you to do so. So, the floor is yours. Please lay out the scenario(s) where her objections to bug fixes hold water.
Thank you for your links and help. &amp;#x200B; Long story: I am trying to reproduce a machine learning project that was published and the code posted. This is a learning experience for me. I am just going to use the neural net not teach it. &amp;#x200B; The author used python 2.7 and pycu. After a lot of time investment, I found some notes that pycu and 2.7 on windows is basically impossible nowadays on Windows (from the devs). It IS possible on Linux, which is how the author was able to do it. &amp;#x200B; I only have one machine which is my working machine, so taking it down for dual booting would be disruptive. I'm a student and a hobbiest :) Also learning how to translate his 2.7 into 3.8 is kinda out of my scope. &amp;#x200B; In case you are interested, here is the github page (note it is a sub-project that depends on a base project, both of which I need to get running): [https://github.com/hiroharu-kato/mesh\_reconstruction](https://github.com/hiroharu-kato/mesh_reconstruction)
It can be worth it to switch for certain kinds of users. Are you more comfortable writing python code or Excel formulas? Then the reduction of future overhead might be worth it. I'm also a teacher, we use PowerSchool for our grades. It's awful, but I can get enough tracking data out of it that I don't feel the need to roll something on the side to track grades between entry into the system. But there are a couple of charts that, were they missing, I'd consider it worth the time to spin up a flask app.
Did a bit of (lazy) poking around the repos. One of the upstream dependencies is `neural_renderer` which does not support Python2. However, it has a link to [https://github.com/daniilidis-group/neural\_renderer](https://github.com/daniilidis-group/neural_renderer) \- a PyTorch port that supports Python3 and uses PyTorch instead of pycu. &amp;#x200B; As both are imported the same, e.g. `import neural_renderer` it may be possible to install the port instead of the original, and then run the mesh\_reconstruction code using **that** version instead, using Python3. (Also requires PyTorch. &amp;#x200B; The code in mesh\_reconstruction looked pretty straightforward, leaning on the upstream dependency, and with a very brief glance, nothing obvious jumped out indicating it wouldn't run in Python3. Worth a try.
Thank you that is very generous of you to help like that! I'm just learning so all of these options aren't obvious to me. I did spend a lot of time trying to understand the package managers and how to poke around dependency trees *before* installing them... didn't get very far with pip.
Even if you want it "globally" it's still way better to `pip install --user` No sudo required and less risk of fubar-ing an OS package manager by screwing up its dependencies (looking at you, yum)
I thought I had a fast computer but pycharm takes about a minute to load on mine.
&gt; PyCQA Python Code Quality Authority Organization for code quality tools (and plugins) for the Python programming language http://meta.pycqa.org/en/latest/
I like pycharm for its nice features such as refactoring, testing, and ability to easily commit changes to github.
I'd finish learning python 3. You just can't use certain features. I've been using Python 3 since 2013. I've been coding it into my company's Python 2.7 only code for years. My code generally doesn't fully support Python 3, but it's not ignoring it either. I can get things working in a few hours. As long as it works in Python 2.7, nobody cares. We're slowly starting to switch and my stuff doesn't need work. It's pretty bad in other places. Quite a few people are stressed out about it. I just roll my eyes. It's not hard and it just takes not sticking your head in the sand for years.
sometimes...
Even if he was angry, because he thought all her points were naive /self-interested, leaving the room before you say anything you regret and likely nothing productive will come out is of better character than staying around and causing more drama.
It depends of your use case. I had a lot of relational data that are better to put in Access. Django admin enables me with minimal overhead make simple data driven application. When I need to do some analytics in Excel over the data I just write export into csv file that is easy to import in Excel. I just keep things as simple as possible.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. Show /r/learnpython the code you have tried and describe where you are stuck. **[Be sure to format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F)** and include which version of python and what OS you are using. You can also ask this question in the [Python discord](https://discord.gg/3Abzge7), a large, friendly community focused around the Python programming language, open to those who wish to learn the language or improve their skills, as well as those looking to help others. *** [^(README)](https://github.com/CrakeNotSnowman/redditPythonHelper) ^(|) [^(FAQ)](https://github.com/CrakeNotSnowman/redditPythonHelper/blob/master/FAQ.md) ^(|) ^(this bot is written and managed by /u/IAmKindOfCreative) ^(This bot is currently under development and experiencing changes to improve its usefulness)
Interesting, but I can see a potential issue of this kind of implementations. How do you handle the fact that the python scripts are basically black box computations for your users?
It seems like you're using the first as an Ide and the second just as a text editor? Or how exactly do you mix those two?
I guess the vim extension is for the key mapping and the reason why I personally use this setup over pure vim myself is that in my current profession I need to interact with the console quite a bit, which awkwardly so doesn't work that well with vim :/ The console in pycharm is a beast
I'd look forward to that! Hopefully I'll be able to start my own renderer right after my finals.
Is your decompression algorithm working ? If so, you're rich
&gt; I also have the vim navigation extension on Firefox and would prefer it systemwide... This. If only. If you've not done so already, `set -o vi` in bash.
Django
I think that example is half attributed to the learning curve and the amount of users that end in it but didn't want to and half to it being a recurring joke. I would still agree with your quote though. The tool is so powerful that even with one of the best :help systems I've seen, knowing about the capabilities (with our without plug-ins) still feels like a jungle that requires endless exploration. But maybe that's a good thing?
PyCharm as the default IDE. I use Vim when developing remotely.
There must be some sort of bug in your process. Either in how you are determining the file size (maybe they aren't 29 bytes) or how you are verifying your compression/decompression. It's just not possible to reversibly compress a file with lots of information (like a typical image) into 29 bytes.
If it were 43, we might believe it. ;)
I don't have a regular PC, currently I only own a laptop
Too little ram
You appear to only be pickling the EncodedObject class definition itself, not an EncodedObject instance containing data. This means that your EncodedObject class basically is being used as a global variable. It, not the 29 byte file, is actually what is storing your compressed data. The offending line is #113, which should be `obj = EncodedObject()`
i assumed ssd was a given
Great tip, thank you
It must be that middle-out compression I've been hearing so much about
I'm just learning regexes c:
Thank you that was it! When I was testing I'd always decompress the file I'd just compressed so I didn't realize it. My compressed file is bigger than my actual file so evidently there's still some issues
Not yet, HDD's are still quite common.
Head over to r/pygame, you're more likely to get help with pygame there. And please never post pictures of code. The error text is almost unreadable.
Seriously. I didn't use venv before but now watching someone use python without this makes me flinch. Lol. Virtual environments FTW
&gt; I don't think I mentioned PSF u/Timmitei mentioned PSF: "The reason I suggest mypy is because (unless I'm wrong) it is made by the python software foundation." and you answered: "Yes, mypy is a python project" but the correct answer should have been "No, mypy is an independent project with little or nothing to do with the PSF". (It's also still only alpha, so not ready to be provided as a standard feature even if that was desirable.) &gt; they broke the rule in 2.7 &gt; Take look at this: https://docs.python.org/dev/whatsnew/2.7.html I did, and I have no idea what you are talking about. Security features, deprecation changes and bug fixes can be always be backported to older versions (at least until they reach end of life); same with fixes to problems with the build process. 2.7 gets more backported fixes because it has a longer maintenance period. I will grant you a handful of minor changes to the usual process, such as: - new -3 warnings can be added to any Python 2.7 maintenance release; - the IDLE application can have changes backported to present a more similar user experience across 2.x to 3.x; - adding `ensurepip` to a maintenance release of Python 2.7 but none of these are language features. (There is, of course, a bit of a grey area between language features and security fixes when it comes to modules like the `ssh`.) For example, we can look at the [What's New of 3.2](https://docs.python.org/dev/whatsnew/3.2.html) to see some significant features not backported to 2.7: - PEP 384 (a Stable ABI), which is a big deal if you are a C extension writer - `concurrent.futures` - PEP 3147 (PYC repositories) - a whole bunch of other major and minor enhancements to email, datetime, math etc. and the same with [3.3](https://docs.python.org/dev/whatsnew/3.3.html) which had even more significant additions, including - `yield from` - the `ipaddress` module - `unittest.mock` - `venv` - implicit namespace packages - the ability to suppress exception context - key-sharing dicts - more compact strings, and the end of the "narrow build versus wide build" dichotomy - new importlib APIs - open with exclusive creation, failing if the file already exists and a bunch more minor enhancements. It is ludicrous to argue that Python 2.7 has all the features of Python 3.3 let alone 3.7 and 3.8.
Will look it up thanks 😊
Thanks :)
Will do, thanks
The value of *licenses* is a list. &gt; for license in result["data"]["licenseses"]: &gt; print("{}").format(license["name"])
Ok, I'm gonna check it out later on and see if I can give you a hand.
maybe among the general population but do you really know any professional decipherable using hdd?
Hi All, Novice when it comes to working with Python but in an effort to expand my knowledge and work on a project that I can see real world usage from I've been working on something to help a colleague of mine, who at the start of each month spends a full day pulling data from several spreadsheets manually and pastes it into one main spreadsheet. I'm using xlwings to read the .xlsx workbooks and sheets, with a Tkinter interface for my colleague to interact with. It's probably not the tidiest way to do it, but I am using multiple function calls to go into the workbook's various sheets and collect the data from the correct columns based on the previous month, which then gets pasted into the main workbook next to the specific entity it relates to. Once I've finished the project I'll clean it up and remove any sensitive information to share it on github, so I can get some feedback on things I could have done better.
Good stuff. Thanks!
That's not an error, that is a warning from the code analysis in your IDE. It is sometimes frowned upon to from x import \*. If you only import the names that are actually used, the warning will go away
Yes but for these people narrow is not zero. It's their job.
inb4 `AttributeError: 'NoneType' object has no attribute 'format'`
Got any PDF example/s ?
Sweet vid
Thanks, mate!
Cheers!
I guess Trump's not a bad example given its limited vocabulary but I wonder how it would fair with more complex statements.
I think the last line has a minor syntax error. Try this: print("{}".format(license["name"]))
The last line could just be: print(licence ['name'])
I'll be creating a simple service that scraps a utility company's website daily and retrieves an individual's utility bill and sends this information via email
I actually remember that post you mentioned from a few weeks ago, was looking for it back then but didn't find it. Was it deleted or removed by mods? From what I recall it seemed more like an advertisement / spam. &amp;#x200B; In regards to your post, I think you got some things wrong. I don't know about Rajeev's course, but I've taken the Super Data Science and Lazy Programmer's courses. &amp;#x200B; In the course "[Deep Learning and Computer Vision A-Z™](https://www.udemy.com/computer-vision-a-z/)", you mentioned it talking about VGG and ResNet, but I don't remember this at all. Were you thinking of Lazy Programmer's course which does cover those? &amp;#x200B; In [Deep Learning: Advanced Computer Vision](https://www.udemy.com/advanced-computer-vision/), there aren't any code-alongs like you talked about. That actually is more along the lines of what you'd find in the Super Data Science course. So I think you got some of the details switched around? &amp;#x200B; As you mentioned Lazy Programmer covers the basics in another course but that's because his courses are way more detailed than the others. I think he has about 10-12 Deep Learning courses in total, which covers more material than all the others combined. There's a clear step-by-step progression that takes you from basic to advanced. In my opinion $10 for each of these is a steal.
Indeed it is. As I'm not one of them, I haven't got the imagination to envision a stack where a unprivileged user have the ability to input a destination for a privileged service to contact a trusted backend, that in turn replies in a way that lead to privilege escalation, based on extraneous headers in a HTTP request. Can you concoct a scenario where stupidity, willful ignorance, or possible both, actually provides that?
I can't, but a lot of stuff is behind revproxies today, so it's not as far fetched as one might think, and if you shotgun your way around the net, you might find a handful of servers where this scenario may apply, together with something that behind the revproxy has a flaw.
It would take something like a front-end knowing about load-balancing between different back-end services. Even with the present micro service fad, who would actually design a proxy that does nothing but copy a front-end request verbatim to a backend?
Licenses is an array of dictionaries (&gt; gotta use integers or enumerate the array)
replace the subprocess call with this library. https://github.com/pmaupin/pdfrw then use pyinstaller to build an EXE
Not sure how this is any simpler than than the standard: import datetime x = datetime.datetime.now() x.strftime('%d %B %Y | Current time: %I:%M %p')
I use [Supervisord](http://supervisord.org/) as a simple interface to run and track my scripts.
What was the algorithm used for prediction ?
TL;DW He's using no fancy API wrapping library, just Requests. And then it's just a (maybe customized) OAuth flow. OP, why didn't you link your blog post? Video is a good format for teaching concepts but a terrible one for step by step tutorials.
TL;DW He's using no fancy API wrapping library, just Requests. And then it's just a (maybe customized) OAuth flow. OP, why didn't you link your [blog post](https://edgecate.com/articles/sfdc/)? Video is a good format for teaching concepts but a terrible one for step by step tutorials.
You'e trying to format a print() return, but should do it with string, e.g. put it inside parentheses `print("{}".format(str))`
If you want the historical offsets, [pytz](http://pytz.sourceforge.net/#introduction) is probably what you're looking for.
If you want the historical offsets, [pytz](http://pytz.sourceforge.net/#introduction) is probably what you're looking for.
That's a very clever way to go about it. Thanks for the advice!
Just wear 3D glasses to speed up the process
Nice one!
It’s a great project, my two reasons for branching off on my own are personal preference: 1) I wanted the control of attaching arguments in the flask request object. For example, Flask_accepts deserializes the input payload and attaches it to request.parsed_obj, where it is available for the rest of the request pipeline. Webargs provides the schema arguments as parameters to the function, but there are times when I want clear separation of the definition of the object in the payload and other parameters, such as when there are parameters from the URL. Otherwise they are all jumbled together. That’s not me saying webargs is bad — there’s loads of use cases where use_kwargs is preferable. It’s just for my use case I want URL params as the only thing in my def get(self, ...) and then I let flask_accepts “magically” deserialize the payload and make it available. 2) in apispec, you have the extra step of having to explicitly register each Resource with the docs. One of the features I love about RESTplus is that the docs _just work_ and feel like they come for free, so I made sure to preserve that behavior in flask_accepts
A laptop is a type of PC...
So unfortunately this is not really useful :/ You can clearly see that the resulting prediction by the LSTM is the smoothed *true* price from the previous time-step, i.e. the prediction is just trailing the ground truth. I haven't seen the entire video (only skipped to the plots), but I'm guessing you're using MSE or something as your loss function. By trailing the ground truth by a single time-step, the LSTM is actually doing quite a good job of minimizing the MSE between the true and predicted price, which is the result you get. One way to deal with this is to instead predict *changes* between time-steps rather than the absolute price. Then you just obtain the predicted price by accumulating the changes. *Buuuut* in this case I think you'll find that the LSTM will fail quite drastically. At least that's my experience. &amp;#x200B; We made the same mistake initially, and took a while to realize. We only realized because we got really suspicious of the performance; it just seemed *too good*. And even worse, *there are even published papers using this to demonstrate new recurrent architectures!!!!!* (e.g. [https://www.ijcai.org/proceedings/2017/0366.pdf](https://www.ijcai.org/proceedings/2017/0366.pdf) ) So it's an easy mistake to make :)
one thing I noticed is you wrote \`target=codedeploy()\`
You shouldn’t predict stock price levels because they are nonstationary. If you try to predict returns you will find much weaker results.
I also made a custom event listener for Slack. If the script misbehaves It will send a message to my company's Slack.
That's exactly the expert advice I came here for, thank you. Now I just need to buy a long enough Ethernet cable so that I can continously run my program on my laptop while I am out and about.
If you are dealing with small amounts of data, like under a few thousand rows, Excel works great, and is easy for others to understand. It can be hard to debug, but is still a solid choice.
Sass people you ask for advice, you're going places!
Or just difference the price series until it is stationary.
Neural Network . BackProp
/r/learnpython
Can you explain more deeply. I dont understand you
Yep, or that.
Your idea is very interesting. When you want to use this type of programs, you want to know if you want to buy or sell stocks and if you know the change is really useful. I have done the project with the past 50 data of the true price as input but I am sure that if I use also data of the new predicted already values it will increase the error a lot. That is really predicting the future. I will need to reasearch and use your paper that appears to be very interesting. Thanks you for the support!
Why would stationary results lead to weaker results?
There are multiple 3rd party modules. I've used Maya and Pendulum. Found an article with 6 different ones w/examples here: https://opensource.com/article/18/4/python-datetime-libraries Pendulum here: https://pendulum.eustace.io/
The strength of your model is equivalent to the amount of money you bet on your model.
No problem! :) Regarding the paper I linked to, that was more an example of what **not** to do; i.e. predict price rather than change.
Because stock prices are effectively random walks, so your best predictor of next period’s price is the current price. This is what you are finding based on your plots.
Hey mate! Thanks for the feedback! It's in the video description, but I guess I should have added it in the comments. Thanks for linking it, though!
I’m new to programming, so this was very insightful! But I do work in finance so I wanted to give you this warning: the stock market is quite fragmented, and using any public data feed for technical intraday trading is almost certainly a losing game. Banks and large investors have “private” and more privileged intraday price volume data because many orders are not executed on public exchanges but rather on their own proprietary systems. I can point you towards research that suggests consistently “beating” the stock market can only come from an information asymmetry. Which can be illegal, like insider trading or front running.
If you want things to happen "at the same time", you have to use [multiprocessing](https://docs.python.org/3/library/multiprocessing.html). `asyncio` is single threaded. It just a way to allow one bit of code to release control to another bit of code in a more predictable way. `threading` is single process, multi-threaded/multi-core, **but** the GIL prevents two threads executing at the same time on two different CPU cores. So `threading` only can achieve parallelism when your tasks are IO bound and the thread gives up the GIL. `threading` is a bit like a less predictable `asyncio`.
So serious question, with all of the recent new features that have been crammed into VS Code, why does anyone choose it over PyCharm? What features really make dealing with PyCharm's massive resource usage and menu hell and standard over-complicated and mostly useless Java docs worth using?
Made additional changes this morning that make my &gt;&gt;&gt; prompt more like the Python interpreter. For example, the function call eval returns None. So I needed to create a "borrowed", new version of eval that returned results instead of None. The results are really close to a Python &gt;&gt;&gt; prompt, PLUS you still get all of those watches in the middle section of the window. Best I can tell, this is more like what you were seeking. It just took me forever to understand.
Then you will love VS Code 1.35 and its [remote development feature](https://code.visualstudio.com/blogs/2019/05/02/remote-development) when it comes out.
&gt; your model is equivalent to the amount of money you bet on your model And your humor is also the same. I know its not a good model but I am trying to improve it. Wait and see
&gt; research that suggests consistently “beating” the stock market can only come from an information asymmetry. Which can be illegal, like insider trading or front running. Thanks for your informations. I think is legal because I am using yahoo finance
Thanks for your info. Did you try to make the model with changes? Do you have the source code or a demo?
Recently, I've moved my new webapps+db to [starlette](https://www.starlette.io/) and [databases](https://github.com/encode/databases) and I've been quite happy. Leaner than flask. I only wish the project maintainer was a little gentler when dealing with questions. Not that he is harsh but there is little room for chattyness since the only places to talk is GH or Discourse (which seems dead for that project). But very good code quality. I'm also a big fan of [authlib]'https://authlib.org/) and [pydantic](https://pydantic-docs.helpmanual.io/) I'm also trying to get into [alembic](https://alembic.sqlalchemy.org/en/latest/index.html) but I find it quite heavy and cumbersome to use :/ I should keep learning.
I like it. I have used speedtest.py which you import but never bothered to take it to the next level with graphing. If I can make one suggestion it would be to forego the setup.sh and use a setup.py file instead with a proper structure for bin and packages. Something like the following; speedtest-graphing/ bin/ docs/ packages/ tests/ LICENSE README.md setup.py With a setup.py you can put your required packages like speedtest and matplotlib in there. They would get installed automatically when installing your package with pip which you could upload to pypi. The graph is visually appealing but I would change the x values with another string formatting for the time and possibly rotate the times at an angle **plt.xticks(rotation=30)** if they look a little tight over a 24 hr period or even dates over an extended period. I like it though, something useful that you can check on a regular basis.
It makes sense. But that would happend if the input data is very small but within 50 days I think it would give little variations not the current price. If you watch in the next tutorial I published you can see that the variations are significantly but they change. I also know that to predict the stocks is much more complex and I will need complex arhcitecture of models this is only my first indeep
Put your decompression into its own program and compress and then decompress. I bet the decompress won't work properly.
&gt; No matter what original file I use be it a 10KB word file or a 1000KB image, I get a final compressed file size of 29 bytes, and an object size of 1056 bytes. This pretty much automatically means you know it's not working
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Do you have an example?
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
See my comment to OP above. Prices are (close to) random walks, so price changes/returns are almost white noise, and are extremely difficult to predict.
I hope you are paid quite well... because not many people have the skills and strength to do this
u/Thieving_Kea is not suggesting that what you are doing is illegal. They are saying that you are, over the long term, fighting a losing battle due to *market efficiency*. The Efficient-Market hypothesis *is* somewhat controversial however, and it is likely that improperly priced assets do exist and can be exploited. Having said that, you are still likely to lose out over the long term. That is, if the HFTs don't pick your portfolio to bits first.
I'm completely agree. It's impossible to long term predict stock prices but you can predict in small times. The rnn is making short term prediction altough it don't appear to be that
Each thread is just getting the same function? So each thread is just processing the same database, but you want each thread to process a different database? I would write the the codedeploy function to just do one database (which it is given as an argument), then put the thread appending into a loop of the databases. And I always use ThreadPoolExecutor. Something like: from concurrent.futures import ThreadPoolExecutor databases = cs.fetchall() database_obj = [] def codedeploy(d): global database_obj databaseName = d[0] cs.execute("USE DATABASE {};".format(databaseName)) for s in statements: cs.execute(s) database_obj.append(cs.fetchone()[0]) with ThreadPoolExecutor(max_workers=5) as executor: executor.map(codedeploy, databases) Is appending to a global list with threads a good idea? I would probably just return the object to be appended from codedeploy, and append it outside the function.
How is the standard deviation and variance calculated?
I have not calculated.Its innecessary
Sure. You can use a log transformation to stabilize variance, and differencing to stabilize the mean. This chapter from [Forecasting: Principles and Practice](https://otexts.com/fpp2/stationarity.html) by Hyndman walks through it, though the code examples are in R. Here's [another example](https://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python/) applying differencing before implementing a LSTM model. That one is in Python as well. Hope those links help.
How big of an organization do you work in? You mention no support from your IT dept and that 20 people use your app on a continuous basis. I think it is cool that they give you the leeway to innovate a solution like this. Where I work it would be impossible to get a web server to do something similar. They would sniff out any under the table server faster then I could boot it up. I understand it though, as once an application becomes mission critical they could be in for some hurt when/if you leave. Is there any process in your organization for formalizing your app as a standard? This would also give you credit for the work you are doing. I have always thought there should be a balance that allows employees to innovate like you did without crushing them into hacking excel solutions together, which seems to be the norm in larger organizations. But would also meet the organizational needs of continuity should you leave the company. Good work
Oh thanks! I will have a look at them. Really intereseting
How is it not necessary? There is a massive deviance when it comes to stocks. If it's not calculated your algorithm isn't taking into account a particular margin of error.
Hi, I'm planning to get into python to improve our audit process. Is there a way to use python to select sample sizes for audit? !Thanks
We were going to use you're accounts, but [everybody knows you never go full retard.](https://www.youtube.com/watch?v=oAKG-kbKeIo)
I know but that its more complex
Yeah...
Thanks this does look promising. I've started looking into the documentation for ThreadPoolExecutor. &amp;#x200B; I've tried running the query you've written above but looking through the logs I can see it successfully calling the databases but not creating the objects. This is what is in the that's being written to the database. create or replace TABLE TABLE_A ( ID NUMBER(38,0) ); create or replace TABLE TABLE_B ( ID NUMBER(38,0) ); create or replace TABLE TABLE_C ( ID NUMBER(38,0) );
Nobody gives a fuck.
I work for fairly big company but my applications involves one production sector. It should manage and structuralize data from production, business and technology department. To get server was second step. I demonstrate my app running on my local computer. The app was available from my IP address on given port. There are few people who understand advantages of my app, but frankly speaking, they have no experience from programming world, so they fail to comprehend how bad the situation really is :) We continued with server to have application ready all the time. Not just when my computer is on :)
If you have a RAM requirement, maybe you should have included that in the original post, rather than making people guess?
 Is that just due to the indentation error in my code? from concurrent.futures import ThreadPoolExecutor databases = cs.fetchall() def codedeploy(d): databaseName = d[0] cs.execute("USE DATABASE {};".format(databaseName)) for s in statements: cs.execute(s) fetched = cs.fetchone()[0]) with ThreadPoolExecutor(max_workers=5) as executor: results = executor.map(codedeploy, databases) database_obj = [] for res in results: database_obj.append(res) lll
Failing to comprehend how bad a situation is seems to be the norm. Organizations just make it so difficult to allow anyone to fix it. I can't even open a port on my laptop to demonstrate a solution to someone. lol
This is amazing stuff - I have one further (hopefully final question) in regards to this - is it possible that a thread/query can go missing because I can see it's executing fine but when I look in the database all the objects aren't being created in all the databases. I'm testing this over 7 databases and I'd expect 21 objects to be created (3 in each db) but I can only see a total of 17 objects created.
Agreed, It took unions to steer the country away from this in the first place but now here we go again.
I've been working from home for the last 11 years, I have no idea what is being used by professionals in an office setting.
Your submission has been automatically removed. Your reddit account must be older than 2 weeks before you can post. No exceptions. You can repost this when your account is old enough. This helps prevent spam. **If you need help with Python** see r/learnpython or r/learnprogramming. **WARNING** Reposting this under a different account before 2 weeks risks getting both accounts banned as well as domains in the post. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/Python) if you have any questions or concerns.*
Very clear and concise. Thank you!
I'm sorry, I don't understand what point you are intending to make. In am willing to engage you in a serious discussion, but I don't understand your question. What do you mean "why should we keep the bugs?" -- which bugs, who is "we", and how are we keeping them? You say: &gt; Please lay out the scenario(s) where her objections to bug fixes hold water. I don't think Amber is objecting to bug fixes. She seems to be arguing that the problem with the stdlib is that it is "buggy" and there aren't enough bug fixes. [Quoting from the article](http://pyfound.blogspot.com/2019/05/amber-brown-batteries-included-but.html): "She thinks that some bugs in the standard library will never be fixed. And even when bugs are fixed, PyPI libraries like Twisted cannot assume they run on the latest Python, so they must preserve their bug workarounds forever." If that quote is an accurate paraphrase of Amber's position, I would respond: 1. Without know *which* bugs she is talking about, it is impossible to take a sensible position on her assertion that some bugs will never be fixed. Many things that people call bugs aren't bugs at all. 2. *Actual* bugs, as in code that does something other than what it is documented as doing, normally get fixed. Those that don't usually have a good reason to not be fixed. Unless we talk about *concrete cases* (which bug hasn't been fixed?) then I cannot possibly guess whether she's right to be concerned or not. 3. Her point about libraries having to preserve their workarounds "forever" sounds like my dad complaining that when the wind blows, leaves blow onto his lawn. Um, yeah? That's life. Library authors have to make a choice. If you want to maximize the number of users you get, you have to support many versions of Python -- but there's no law that says you have to do that, or how many versions is "many". [Twisted doesn't even support Python 2.6 or 3.3](https://pypi.org/project/Twisted/) let alone Python 1.5, so I think "forever" is a gross exaggeration.
I tried it today, and pretty much got glared down for doing so. The guy incharge is paranoid about the code being stolen so I have to keep doing vanilla vim from now. Though overall it was a great experience using VSCode.