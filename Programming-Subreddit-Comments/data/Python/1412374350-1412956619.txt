The idea of leaning towards functional programming habits over imperative programming is something that's pretty Pythonic, as it allows both styles to work together really well.
It works surprisingly well in C++, too. 
Thanks for the feedback. Still a little confused since some say to do Cython while others say to use PyPy+cffi instead. It's true that one can do assembly or C, but the learning curve for Python is lower and code is prettier. I'm not talking Battlefield level of graphics, but something more indie like a Fez. Also, Python may be easier in cross platform porting to Linux and Mac in addition to Windows.
&gt;I will focus on four primary topics: Functional programming Yeah, no.
This looks great. I know python but I haven't had much experience with APIs. Could anyone get me started on simply getting the nearby yaks?
Type the line where you define proceed into an interpreter and see what it says.
This feels like a homework question... 
Definitely put the docs stuff in it's own dir. 
".link p.title" needs to lose it's height and overflow rules. ".thing .title" needs to lose it's overflow rule.
Thanks very much, I will. It will probably end up being organized like this, if I can figure out Sphinx without too much pain: pybot | --&gt; src --&gt; docs Sound good? 
I'm the CTO of a well-funded startup in Austin, TX called ROIKOI (http://roikoi.com). We would love to have a python oriented data science intern. If interested, PM me.
CFFI is available for CPython. https://pypi.python.org/pypi/cffi
FTFY: from time import sleep as s d = { 'y': lambda c: print('{1}'.format(s(5.0), c(''))), 'yes': lambda c: print('{1}'.format(s(5.0), c(''))) }.get( input('Hello {}.\nKnock knock..\nWanna know who\'s there?: '.format( input('What\'s your name?: '))).lower().strip(), lambda c: c(print('Too bad.')))(lambda x: 'Java...') **** Seriously though, `input()` is a `str` already on Python 3+, and If you're on Python 2.7 then use `raw_input` instead. Also, `proceed = 'y' or 'Y'` doesn't actually hold that '`or`' in it. It chooses between `'y'` or `'Y'` and sets `proceed`, so `proceed` actually only holds `'y'`. What you wanted was `if answer.lower().startswith('y'): do_whatever()` anyway. Hope that helps to make it clearer, and nevermind the code above. 
You don't say much about your clients or apps however expecting a little intelligence on the part of the user isn't a bad thing. If they can't manage pip installs of your apps then maybe you need new users. At least at the facility I work at IT expects a little capability on the part of the users when it comes to working with their half assed apps. There are other options if you have a bunch of idiots using your apps. Here are a few possibilities: Get remote management rights to your users machines and manage the installs your self. Often the majority of this management can be done with a pip update script. Don't use PythOn if you don't have to. Seems obvious but sometimes machine specific apps make sense. Reduce your use of libraries not included with the Python libraries shipped with the Python distribution. If you do use third party library's use only stable libraries that don't update often. This simply to reduce your maintenance overhead. Consider iPython and iPython notebooks. Again this depends upon your clients and the type of work you are doing as a team but iPython can be very dynamic in some situations. I can't help but to believe that some of those features you want are more app related than installer related. For example the phone home feature. It is the security implementations that bother me here. I imagine what you are looking for is a Sparkle "http://sparkle-project.org" type solution for Python. Might be nice but I know of nothing like that for the Python world. Sparkle is for Cocoa apps so I'm not sure if they can even wrap Python components of an app. However for what Sparkle does it is very nice. Consider a Python to executable compiler. Build a wrapper app for your Python solutions. You might as well build a native app in many cases. However if you can embed everything you need in an app then you solve a large number of your problems. 
http://www.sagemath.org/library-publications.html sagemath books: * http://linear.ups.edu/ * http://sage.math.washington.edu/home/wdj/teaching/calc1-sage/ * https://code.google.com/p/graphbook/ * http://buzzard.pugetsound.edu/sage-practice/ * http://www.gregorybard.com/SAGE.html
Not sure if you missed the others, but there is indeed four topics discussed. Are you miscounting, or merely stating your disapproval for a completely valid school of design in an ambiguous way? If you're picking apart the article, I wonder why you didn't go for the obvious: &gt; When those four aspects merge in one programmer, he or she will gain greatness no matter what. if {A, B, C, D}.issubset(some_programmer.skillset): some_programmer.capability = 'great' That's some crazy shit to assert. The skills possessed by a programmer aren't the entirety of his ability to code well.
I think for the complex task you've challenged yourself with here, it's less about finding the right library than it is learning computational linguistics.
PyPy has had an incremental GC for at least a couple of releases, which significantly reduces the lengths of the pauses and spreads them out over time. It's actually a good match for game development. Most of the pauses are significantly less than 1 ms and the max tend to be less than 1.1 ms.
&gt; That’s because more intelligent men than me have already written great articles on the topic of how to become a great Python programmer. Second sentence in and the author is already excluding women.
Most NL interfaces I've seen parse really basic structures and barf on anything even remotely complicated. (By teaching enough structures things become idiomatic ish) So you use your NL interface to parse to something like SVO (subject verb object), then see if that matches anything. (A verb you know). I created some code like that using TextBlob (which is an interface on top of nltk), but I just closed my VM to be lazy and look at Reddit. Learning what a grammar is in the context of programming languages may help (I like parsley, but there's also pyparsing and several others) SVO is actually a kind of simple grammar, let's break it down SVO = noun-phrase:subject verb-phrase noun-phrase:object full-stop noun-phrase = [list of adjectives] noun verb-phrase = [list of adverbs] verb [list of adverbs] that won't parse all of English by a long shot (and there are words that can be both multiple parts of speech depending on context), it ignore compound sentences, and noun and action modifiers that aren't adverbs or adjectives like prepositional phrases. full disclosure I have no idea what I'm talking about, but I've been "coding" a lot in Inform 7 lately so I've been doing some research on how to re-implement it in Python. And I think I got like a B- in Intro to Comp. Linguistics in college (before I dropped out)
Spend some time playing with something like Toy Parser Generator. Play around with building up simple grammars.
We installed this and played around with it a bit today. Very interesting, going to swap out the db stuff for mysql and see if we can actually install a production instance and realy use it next week maybe.
Yes, I am aware. However CFFI+CPython performance is... not so good from my experience. About the same speed as ctypes if not a bit faster, but if you are trying to do fast code between python and C, pypy+CFFI is the only way to go IMO. (Although I have never gotten very far with Cython, that might also be decent for C speed)
Probably a couple of different sorts. 
If you're serious about this stuff, please do some more research. Python is not cross platform friendly for porting, and is basically *not suitable* for game development as it currently stands. Its perfectly fine for making a prototype or something in, but really look into the complexities of distribution before going down the path of writing a game in it. Python has a truly terrible distribution story; making cross platform installers will be an utter nightmare if you plan to ever release your game to the general public. There's lots of information out there about py2exe, pyinstaller, etc. and how complex they are to use. On the other hand, if you only plan on releasing to a mobile platform it's probably more viable using kivy's tools, and there are (relatively) better tools to work with. If you plan to go down *that* road, use cython; kivy doesn't support pypy. 
Why not try importing the symbols directly in addition to using *? Also, consider doing away with * and using qualified namespace variables/methods instead. Importing * from a module should be done very carefully when namespaces are large because of the risk of collisions, especially if you're importing from multiple modules. 
Beware of the promise of declarative programming. You can end up spending a lot of time choosing between, and parameterizing different solution engines. There are a lot of SQL questions of the form "how do I make this more efficient"? It is easy to declare what one wants doing, but arguably harder to optimize the result.
cython has a ['with nogill'](http://docs.cython.org/src/userguide/external_C_code.html#acquiring-and-releasing-the-gil) statement so you can run cython code without being blocked the gill. It is up to you to make sure the code is thread-safe though. 
I think homercles337 probably means python isn't a functional programming language - it's multiparadigm - and the 'functional' features aren't considered 'pythonic'. 
I wonder about the naming of it. I think `address.us` would allow for more package-based extension for other locales....
Actually there is theoretical distinction of natural language processing. I don't have any idea of Chomskian side, I know only more empirical side which is heavily based on statistics, probability and mathematics. Once I wanted to try out NLTK library, yet I learned it is based on developing Wordnet. Then I learned how to use corpus linguistics in a computational manner and currently writing a module named [corpse](http://github.com/erayerdin/corpse-python3) based on corpus linguistics and corpus databases. It has a good tokenizer, preeditor. I think you can look at Manning and Schütze's "Foundations of Statistical Natural Language Processing" which is a really good resource for this. I also think "Markov Model" will be helpful to you.
I'd probably agree with that. But I think that we're attributing too much to a fractional response. I was more trying to poke fun than provide any validity to that type of criticism.
Q: How to become a proficient Python programmer A: Find practical uses for your python scripts and code daily.
gists are pretty good for sharing code. I think something like a weekly "look at this cool code" could be pretty neat though.
[GitHub](https://github.com/), [BitBucket](https://bitbucket.org/), /r/coding, /r/onlycode, /r/codeprojects [*collection of programming related subreddits*](http://www.reddit.com/r/programming/comments/a6qgz/proggit_im_trying_to_compile_all_the_known/)
How about something like "Share your code Saturday"?
That would be good :) what's a gist?
Thanks! I have a look at that.
Thanks for this, really helpful!
https://gist.github.com/anonymous/d08c96e8901e332d1955
I'll make a post, we'll see how it goes. The mods can bless it later (or curse it with the ban hammer).
Thanks again- think I get it.
Here is a quick solver a wrote a while ago to solve the mobile game FourPicsOneWord. It uses a dictionary of the most commons words in the english language that I found online. [Solver](https://github.com/jamesmunns/fourpicsonewordsolver/blob/master/wordsolver.py) Use: for example with this [image](https://pbs.twimg.com/media/BtALMVXCUAAzcsp.jpg), you would enter "ilptxcsekizu, 5". It prints the most likely solutions at the bottom. I'm pretty sure the word is "upset"
I wrote a traveling salesman solver that uses a heuristic algorithm: [Pants](https://github.com/rhgrant10/Pants).
http://runnable.com/ Is cool too
Please don't use *pastebin.com*! It looks ugly, it uses captchas for creating **and** viewing pastes and it is blocked in some countries. There are so many better paste services.
Honestly it depends on what they value. If they're looking for someone who knows X then they'll test your knowledge of X. On the other hand, if they want someone who could know X (because you're intelligent enough) then they'll likely test your knowledge of basic computer science. For that, think data structures, algorithms and efficiency, problem solving, and unit testing.
I've been metaclass crazy this week. [Here's an excerpt](https://gist.github.com/RemyPorter/a68dbbdc3a519997e229) from a metaclass library I'm building. The goal is to use this to generate a wide variety of possible cards for a board game.
this week I wrote modal AJAX form [concept](https://github.com/FZambia/django-fm) to create, update and delete Django objects with ease.
Minecraft seems to run fine
https://gist.github.com
Namely hastebin, which has VERY nice automatic syntax detection and highlighting (although it tends to mistake pasted IRC quotes for Haskell...).
I posted this already as a separate link, but I wrote a 4D tic tac toe game using Kivy. https://github.com/sirpercival/fourdtictactoe
Thanks!
I was working on an API-requesting library and, tired of creating multiple layers of mocks for my unit tests, created a [test server implementation](https://gist.github.com/pellagic-puffbomb/e371921e5ff3b7758c40) so that I could spin up a test-server in a separate process and request JSON fixtures. This meant that I didn't have to use a bunch of mocks: I could just point my API-requester at the test server and it would make real HTTP requests and receive real results.
You can use setattr on module object rather than the ugly exec there.
Yup. And I Iove that I'm being downboated.
I started learning Python yesterday as I wrote a [simple tool](https://github.com/reduxd/faucet-py) to download music from [drip.fm](https://drip.fm). Open to any improvements or suggestions!
A week or two ago, I decided I wanted to learn how Bezier Curves work, so I wrote this: [pybez.py](https://dpaste.de/cyOP) Written using python3, but probably works in python2 as well. Uses Pillow for rendering, but only utilizes `Image.new()` and `im.putpixel()`. There are five classes: * `Pt`, to represent the control points * `Linear`, to represent linear bezier curves (lines) * `Quadratic`, to represent bezier curves of order 2. * `Cubic`, to represent bezier curves of order 3. * `Bezier`. After implementing `Linear`, `Quadratic`, and `Cubic`, I felt I had a pretty good handle on how the different orders interact with one another, so I wrote this generic Bezier class, which can represent any order of Bezier curve, from 1 (linear), up to `RuntimeError: maximum recursion depth exceeded`. Plus a plotting function. This animations of [quadratic](http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_2_big.gif) and [cubic](http://en.wikipedia.org/wiki/B%C3%A9zier_curve#mediaviewer/File:B%C3%A9zier_3_big.gif) bezier curves on the wikipedia article explained it well enough for me to get an implementation going. More complex math might help eliminate the recursion issue, but who really needs Bezier curves of order 1000 anyway.
aah sorry for not reading exactly, thanks!
Ah- good call. I was trying to recall the "right" way to do that.
Gee, thanks. We need more obtuse assholes like you. I wanted to know how much i could accomplish w/o having to dedicate months or years of my life to learning a new academic expertise. I already have a day job. That's why people make toolkits and libraries, so that others can innovate without expending unnecessary time and resources.
http://paste.ubuntu.com/
Great! Now do NURBS.
Thanks for this post, I like this idea. I have a lot of different projects I have published over the years, but I'm terrible about documenting them and promoting them. In recent months, I've tried to change this and let more folks know about what I have to offer. Lately, I'm absolutely obsessed with 3D printing and rapid prototyping, and many of my recent python projects touch on this theme. I really enjoy writing code that can, in turn, make something physical and I think Python is a perfect language for this kind of tinkering. With that in mind, I would like to highlight three recent projects. For starters, I've written an OpenSCAD generator that tries to make it easy to express 3D geometry using Python. OpenSCAD has its own language for expressing geometry, and my library mimics that vocabulary while enhancing its expression. I've finished with most of the low-layer parts of the library, and have started to write more high-level concepts like screws, gears, fonts, etc. It is sorely lacking in documentation, partly because I wrote it to drive my own projects, but I want to change this and build it for a larger audience. I hope I can attract other developers and achieve bigger goals, like embedding it into OpenSCAD itself. You can find my current work here: https://github.com/vishnubob/pyscad The second project I wanted to highlight is Rockit, a python program that generates OpenSCAD generated models of printable, working model rockets. This project has some more documentation, and I've published instructions over at instructables, github, and thingiverse on how to use it to make your own. I would love to see this project find its way into the classroom, where students use it to design and print different rockets, and measure their performance. I think it's a perfect mashup of science and engineering that could be thrilling for young kids. More info here: https://github.com/vishnubob/rockit https://github.com/vishnubob/rockit/wiki/Rockit http://www.instructables.com/id/Rockit-Model-Rocket-Construction-Kit/ The final project I wanted to highlight is my partial python driver I wrote for the Silhouette vinyl cutter. If you are not familiar with vinyl cutters, they are a plotter that sport a sharp blade instead of a pen (although the Silhouette can do both). They are extremely popular in the scrapbooking community, but I like to think of them as a poor man's laser cutter. The bundled software is not very sophisticated. For a recent project, I needed to cut accurate gaskets from thick rubber, and I was terribly frustrated with how the sanctioned software got in my way. The company was tight lipped about technical specs, so I fired up my USB analyzer and reversed engineered enough of the protocol to write my own driver. Here is some information: https://github.com/vishnubob/silhouette https://www.youtube.com/watch?v=OxYCJ1hTM2I
Thanks, I'll look into that. Luckily I'm not trying to parse every English sentence successfully -- the domain is fairly limited. I guess what I'd hoped is that there would be some technique or toolset that would allow me to define that domain in some way. But that's probably an oversimplification, based on what I'm hearing.
I've been using pygame to create a 4-player Jeopardy game. It's still a bit rough right now, but eventually I'm going to incorporate a buzzer attachment I've made for the raspberry pi, to make it as close to the real thing as possible. To run this, you need the pygame package and BeautifulSoup: https://github.com/jesmith0/jeopardy/
You should try [virtualenvwrapper](http://virtualenvwrapper.readthedocs.org/en/latest/), it makes handling virtualenvs way easier.
Blocked in my country
Hey, You have to post code showing that you tried something, otherwise you're going to get downvoted to 0. If you don't know where to start, you need to read some tutorials, e.g. https://docs.python.org/2/tutorial/ Tell us if you're on Windows or Mac, and what version of Python you are running (2.x or 3.x?) and post some code, and you'll get all the help you need. However, you need to post this in /r/learnpython, NOT /r/python. Good luck.
Hey, You have to post code showing that you tried something, otherwise you're going to get downvoted to 0. If you don't know where to start, you need to read some tutorials, e.g. https://docs.python.org/2/tutorial/[1] Tell us if you're on Windows or Mac, and what version of Python you are running (2.x or 3.x?) and post some code, and you'll get all the help you need. However, you need to post this in /r/learnpython[2] , NOT /r/python[3] . Good luck.
Looks like /r/onlycode died about 6 years ago unfortunately. Thanks for the links though!
You're probably going to be a lot better off rewriting in a language that compiles to machine code, like C++. People may just as well make derivative projects in other languages and you won't be able to prove it. The way I see Python make money is through web apps. If you're able to provide this service through a web app or API, you can sell it that way and never open-source the code. Otherwise, your best bet is to rewrite it into C++ or something and use some basic copy protection. You can always just keep it closed source and distribute it knowing it can be decompiled. People will always find a way to reverse engineer your product if they try, DRM schemes or not, machine code or not.
Not very complex, but I wrote a script that turns multiburst pictures (example: http://www.multiburst.nl/multiburst_testimage.jpg), into animated gifs using imagemagick. Basically my grandma traveled for a week or so abroad with our old camera on burst mode the entire time, so a solution had to be found:) I like the output though, it's nice having animated gifs from a trip. Here's the code: https://github.com/eyalzek/imagick-multiburst-to-gif And here's the output for the example image above, btw: http://i.imgur.com/qhXjtPP.gif
try vim ; )
Lots of these constants are created dynamically but as far as I know PyCharm does analyses modules only statically. In other words: PyCharm cannot know the contents of these modules without actually running the code (and it is a good thing that it does not do that). Import them directly (``from OpenGL.GL import GL_POINTS, ...``)
Ya dual licensing works pretty well. I believe qt is GPL for oss and you can buy a BSD license. Another option would be to compile it with cython or maybe pypy(idk very much about compiling python to byte code but it may be worth looking into). 
https://bitbucket.org/Earlo/sotc-turn-counter This weekend I worked on a turn counter for my Spirit of the Century Group, since we decided to edit the rules a bit, and the turn system turned out to be bit troublesome to be calculating in head. Using Pygame for GUI.
I wrote a correct solver that can do TSP for n nodes with 4\*(n-1)\*2^(n-1) bytes of memory, and it runs in about the time it takes to read over that memory n times. It's a correct and useful solver...as long as you have at most 26 nodes. 27 if you have 8 GB of RAM.
Haha correct vs useful... excellent point! 
Thanks /u/jahmez for doing this :) Here are my submissions: * A binomial distribution calculator: https://gist.github.com/anonymous/d20f05db0446e6c2a0c0 * A program to work out if a given number is divisible by three, without using multiplication, division or modulo:https://gist.github.com/anonymous/3a179769145ac7d229f6 
Buy a BSD license? You do realize that in that case, all it takes is one buyer, and the whole thing can be had under BSD by anyone who wants it, right? The only ways dual licensing makes sense is when the two licenses to pick from are both restrictive, but in different ways, e.g. GPL (disallows non-free redistribution and modification) and a proprietary license (unsuitable for open-source distribution), or two proprietary licenses with different constraints, or two free licenses with different implications (e.g. releasing into the public domain where possible, or a very permissive license otherwise).
A game I'm working on about Python: Source (requires pygame): https://github.com/iminurnamez/codewords Windows Executable: https://github.com/iminurnamez/CodeWordsExecutable Feedback much appreciated!
Oh, don't quote me on this but I believe its more complex that that BTW, you really should just talk to a laywer.
That pains my soul.
I need access to min/max values for C (not Python) data types in a python program. Just scanned my source code and found this. &gt;&gt;&gt; import _testcapi &gt;&gt;&gt; dir(_testcapi) ['CHAR_MAX', 'CHAR_MIN', 'DBL_MAX', 'DBL_MIN', 'FLT_MAX', 'FLT_MIN', 'INT_MAX', 'INT_MIN', 'LLONG_MAX', 'LLONG_MIN', 'LONG_MAX', 'LONG_MIN', 'PY_SSIZE_T_MAX', 'PY_SSIZE_T_MIN', 'SHRT_MAX', 'SHRT_MIN', 'SIZEOF_PYGC_HEAD', 'UCHAR_MAX', 'UINT_MAX', 'ULLONG_MAX', 'ULONG_MAX', 'USHRT_MAX', '__doc__', ... &gt;&gt;&gt; _testcapi.FLT_MAX 3.4028234663852886e+38 &gt;&gt;&gt; Woohoo, just what I needed. But in a hidden module? I think these constants should be available in the standard [ctypes](https://docs.python.org/2/library/ctypes.html) module.
Generally, if you can describe the project without divulging specifics that you're not permitted to, you'll be fine. Reputable interviewers will understand that you can't say too much (indeed, you'll be respected for holding your tongue), and technically inclined interviewers will be able to partially gauge your competence by how you describe your work on the project. Also, many interviews contain some sort of coding exercise, which is really what they use to determine your competence. Having said that, I recently landed an interview *because* they asked if I could point to an open-source project I did that solves a real problem (and I had one on GitHub). **TL;DR** Having programmed (and thus having programming competence) and being capable of describing your work without divulging trade secrets, etc., is far more valuable than having code to point to on GitHub during an interview. 
We understand you, it wasn't an easy decision for us, but the develpment overhead of multi database support and the limitations of use only the common features turn the balance.
I have to work with non-git-savvy people who use DropBox for collaboration on code, so I'm making a tool to two-way sync a folder with a Git repo. It's [gitobox on github](https://github.com/remram44/gitobox) (still work in progress) and it's gonna be awesome.
I can never remember all those darn `os.path` commands, so I made a class that wraps them with an easier and more pythonic syntax. from filepath import FilePath path = FilePath('/home/ingineer/text.txt') print path.extension print path.directory print path.filename I have been extending it and you can find lots of the common things you would need to do with file paths. Such as: path.make_executable() You get it... https://gist.github.com/xapple/913cf34953d572b07e1f
probably neither if you want to develop real games. Python is my favorite language but frankly not very well suited to indie game dev as it stands - tricky to package for different platforms, shortage of top quality tools and support. On the other hand if its just for experiments and prototype then you can do either, i would lean towards pypy with pysdl-cffi
No idea how I did that without noticing:) fixed now, thanks for the heads up
I made (still working on) an API for a powerglove I modded. It lets you use the powerglove to execute arbitrary code based on gestures you define. Right now I can do things like fly a drone, interact with x10, and control a mouse. You can use it for what every you want, that's just what I have to show it off. The glove uses an arduino to talk to a kivy app on my phone via bluetooth. The main project is here: https://github.com/LISTERINE/gauntlet The gesture definitions are pretty cool, I think. They're here: https://github.com/LISTERINE/gauntlet/blob/master/kivy/service/Gestures/my_patterns.py I've been working on this project for a while and I'm actually getting to present it at the wearables and things conference in DC if any one in the DC area wants to check it out. http://wnt2014.gomodev.com/
I wrote what I'm calling [an unravel function](https://gist.github.com/blakev/3609eb6d5e2364ed83d0) that takes iterables as arguments and pulls from them evenly until the limit is reached or all iterators are exhausted. I used this with the multiprocessing library to stream results from groups of log files.
Thanks so much for this, I was just trying to learn about Bezier curves, and you did it so much better than I could have thought of. Really awesome!
that's pretty meta
I don't know what you mean by 'ineffective' - it didn't compile your program? I use [cx_freeze](http://cx-freeze.sourceforge.net/) more than py2exe, and it works reasonably well for what I've needed it to do, though there's a few quirks and bugs that pop up with it, too. Most of those have had to do with referencing non .py files without their full paths, which isn't too hard to take care of through judicious use of `os.path`. If you're writing a game with pygame though, I'd suggest taking a look at [kivy](http://kivy.org/), which provides support for compiling python (including pygame) into executables for just about any platform you'd like.
Blah, I am afraid of those bugs, seems like it may be a poor choice to use python. Though I will check out Kivy, thanks.
As far as creating an exe from a python program I would look at pyinstaller. http://www.pyinstaller.org/ I used it successfully earlier this year.
Even though I use Debian/Ubuntu packages myself, I'd probably recommend people new to scientific Python install Anaconda, even on Linux, because Linux distro packages are often pretty old.
I've used py2exe. The only downside I've seen is that you have to deploy a lot of separate files. (Is there a way to package it all into a double-clickable executable? Maybe I'm missing something.) Other than that, it's worked terrifically for me.
If you want to distribute a game on Windows, allow me to shamelessly plug my tool for building installers, [Pynsist](http://pynsist.readthedocs.org/en/latest/). You can see what it takes to make an installer for one of the pygame sample applications here: https://github.com/takluyver/pynsist/tree/master/examples/pygame
**source**: http://www.reddit.com/r/Python/comments/2b4ytx/python_interview_questions/ Copying/pasting something I wrote a while back: &gt; I'm doing a technical interview in python, and though I know it pretty well, are there any gotchas I should be aware of? What kinds of questions should I expect? Almost every company will ask different questions. The questions being asked will likely depend on the level of experience expected for the position and some may not be directly related to the language at all. So if it were me in your position I'd ask myself a series of different questions: * What were the last ten things I learned in the language? Do I know then well enough to teach them to someone else and use them to solve problems? * What were some things I've read about the language but never understood or researched? * Are there any parts of the language I avoid using because I don't understand them or have not found a good use case yet? * For the most common things I do in my code, do I know of or tried different ways of accomplishing the same thing? * Do I understand how the language works internally with relation to attributes, objects, threads, memory, system interaction, etc? I know the above does not directly answer your question but it should help in discovering what you don't know. The key to most interviews is usually not wrote memorization and regurgitation of facts but to prove you can apply your knowledge, both technical and non-technical, to a problem. I interview several Python/C++ engineers a month and the best candidates have good, but not perfect, technical knowledge. Instead the best candidates can solve real world problems with their existing knowledge base. When they can't solve the problem however they often ask themselves questions like those above to try and develop a new solution. **TL;DR** Do not try and ace a technical interview with knowledge alone. That's impossible. Instead try use your technical knowledge to prove your problem solving skills. In the long run, your problem solving skills will improve with time which will also improve your technical knowledge.
https://github.com/jalavosus/Gann-mechitza-minyan-torah-emailer It's an auto emailer for my school's Minyan (we're a Jewish school). We've had problems with not assigning people to read Torah, sooooo this is that fix. 
This is possible in the latest versions with the appropriate `--bundle-files` option. The documentation mentions that some libraries might break and the single exe may not work but give it a go. It has worked for me :)
Started this project a while ago that will eventually be some mobile phone apps to more effectively catch the bus, plan trips, see where bus stops are, etc. Currently its a barebones windows phone app, and a python server written in py3 and cherrypy Currently its code to download the gtds data from the site, put it into a database, logic to handle updated data, and to generate bsdff patches between different versions of the database so the user doesn't have to download a 11mb database everytime it updates. Currently it is waiting on politics on the bus companies side
[My attempt at a basic DB API wrapper](https://github.com/panchr/wire). It has some issues, but haven't been able to figure out what they are, or what causes them :(.
Few mini python projects to share. [Pysite Monitor](https://github.com/briwilcox/pysite_monitor) PySite Monitor is a python up time monitor and alert tool. Receive email and sms / text alerts when your website is down. [Concurrent Pandas](https://github.com/briwilcox/Concurrent-Pandas) Concurrent Pandas is a Python Library that allows you to use Pandas and / or Quandl to concurrently download bulk data using threads or processes. What does concurrency do for you? Download your data simultaneously instead of one key at a time, Concurrent Pandas automatically spawns an optimal number of processes or threads based on the number of processes available on your machine. [Stock Ticker Soup](https://github.com/briwilcox/stock-ticker-soup) Scrapes the stock tickers belonging to the S&amp;P500 and generates a csv file of the results 
This is what I did this weekend so far. It's a sort of content addressable storage backend that I plan to use in a tiered deployment repository (devel, staging, production). The data written is stored in a file that is named as the digest of the data. Data is written with a key, could be a file name, could be something completely arbitrary. A mapping of keys and digests are kept in a sqlite db at the root of the repository. Data can be looked up by key or digest and read back from the repository. When data is deleted it is only released from disk when the last key that references the data's digest is removed. It's content addressable storage... kind of and I call it [cask](https://bitbucket.org/epicDistortion/cask) As I said I threw it together this weekend between family visits and playing with the kids, so it's still rough, but it is functional.
You can still decompile machine code and get a pretty good idea of what's going on under the hood. How this is done is beyond my skills. But it's possible. 
I have deployed several scripts to windows servers with py2exe single exe file. 
I'm using pika professionally in a product but have been kind of hamstrung with old versions and less than stellar code quality, documentation, and support. If I was starting a new project from scratch I'd probably investigate kombu first, support for transports other than RMQ looks attractive just in case you decide to change messaging.
There are tons and tons of tools to RE binaries for all formats and platforms. As long as you are familiar with the asm and the executable format it's really not too crazy, just tedious. It's easier to run something in a debugger and inspect where it is in memory at interesting points for doing something like cracking software. For nagware, you can just break when it pops up the "You have 29 days left" window, and you'll see a backtrace of it calling the gui's api , and above that you should see it within range of the virtual memory of the actual process, not loaded libraries. From there, you can look at the call graph and have a good idea of where to start. Not sure about more sophisticated DRM, but sometimes you have to patch out the check to see if you're in a debugger context. Either way, you can always just disasm it without running a debugger. But as for getting an idea of what's going on under the hood, for machine code generally I think viewing the call graph and seeing what address you're executing at the point of interest is the best way to see. Though, my main point is that machine code is much more of a hassle to break copy protection than something like Java or Python which will decompile easily. Java keeps names of functions... Machine code is very tedious and requires a lot of time. For making money off of Python projects, I think serving it in the form of a web app really makes the most sense, if possible.
I use pika. I have it deployed on a few systems and found it to be rock solid. 
I've been writing a blog series titled ["Saturday morning hacks"](http://charlesleifer.com/blog/tags/saturday-morning-hacks/) that covers small Python projects that I hack on during the weekend mornings: * [Analytics app with Flask](http://charlesleifer.com/blog/saturday-morning-hacks-building-an-analytics-app-with-flask/) * [Note-taking app](http://charlesleifer.com/blog/saturday-morning-hack-a-little-note-taking-app-with-flask/) and [follow-up](http://charlesleifer.com/blog/saturday-morning-hacks-revisiting-the-notes-app/) * [Personalized news feed with a boolean search query parser](http://charlesleifer.com/blog/saturday-morning-hack-personalized-news-digest-with-boolean-query-parser/) * [Auto import your app's models when starting iPython](http://charlesleifer.com/blog/saturday-morning-hack-automatically-import-your-app-s-models-when-starting-ipython/)
Wow. Dropbox as source share? With all the free repo providers, one should be able to use at least one of the mainstream source control tools. Any way, your tool works for you.
It depends what you need to use it for, of course. But I would recommend taking a look at celery. I've been using it for a few projects this past year, and it is easy to start with. http://www.celeryproject.org
 import pyak as pk # replace 00's with your location location = pk.Location(00.000000, 00.000000) testyakker = pk.Yakker(None, location, False) yaklist = testyakker.get_yaks() for yak in yaklist: yak.print_yak() 
Dang! I wish I'd known earlier that there was a PyTexas :/
celery is not a rabbitmq client. It uses pika internally for rabbitmq.
No, it uses kombu, which uses librabbitmq underneath
Why not [`platform`][1] in the standard library? [1]: http://docs.python.org/library/platform.html
 import sys sys.version_info[0:3] == (3,4,0) &gt; True sys.version_info.major &gt; 2 &gt; True import platform platform.system() &gt; 'Linux' platform.architecture() &gt; ('64bit', 'ELF') *** Just putting this here for people looking for a 'batteries included' method of determining python, os, and system versions.
You should look into this presentation from Pycon 2014: http://youtu.be/wsczq6j3_bA
You need to create a daemon for the child process so it doesn't terminate when the parent does. http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/ No idea what Appium is. If you can't make a daemon out of that directly, you can fork your server and have the parent continue serving while the child runs Appium. 
I wrote one, [nucleon-amqp](https://pypi.python.org/pypi/nucleon.amqp), specifically to work well with gevent and take advantage of gevent paradigms, eg. it doesn't rely on passing callbacks around. 
In my opinion I feel that you could save yourself some money by checking out and exploring the [Python](https://www.python.org/) website. The documentation contains absolutely everything you would want to know about [Python](https://docs.python.org/3.3/). 
Pika seems to do the work for us on amazon linux!
This is admittedly a repost of something I've shared in this sub before, but here's a snippet for randomizing layer rotations in GIMP using its Python console: https://gist.github.com/BHSPitMonkey/7097279 Should give you some good ideas for doing some fun image manipulation stuff.
Thanks for the info! I'll definitely look into that. If you're curious, Appium is an open source test automation framework that works with iOS, Android and Browser. More info could be found [here](http://appium.io)
Very nice work.
Been using pika for an extremely simple produce/consume model and it does the trick. I'm trying to use it as little as possible and it works in that regard. I don't know enough about rabbitmq to know what it might be missing. I have heard kombu is preferable, but I just tried pika first and it worked fine for me.
We are using pika and puka here at works. I started by using pika but encountered some problems with rabbitmq 3 at the time. My colleague started using puka due to as mis-communication in another project. But it the end I like it more. It's less suported and less documented but I find the architecture more clear and the API simpler so I'm gradually moving my own projects to use it
Looks like a simple homework question to me, so instead of giving you an exact answer - here is fairly strong push toward the [range built-in](https://docs.python.org/2/library/functions.html#range)
It's not homework, I ended up using numpy. numpy.linspace(1, 180, num=10, endpoint=True, retstep=False).tolist()
What about this: def evenly_spaced_range(stop, steps=10): if stop &lt; steps: raise ValueError("range is too small for steps!") step = stop // steps for i in range(0, stop, step): yield i 
Nice, I didn't know `range` took a step!
 x = (y for y in range(0,n,n/10))
Yes, it can be quite complex... but the main point stands, dual licensing doesn't make sense if the cheaper one of the licenses grants everything the other does and then some, and offering a BSD-style license for a fee pretty much just means that as soon as one buyer takes it, they can redistribute under BSD as they please, which effectively means this one buyer is all you'll ever have (unless they don't realize what they have there).
Just use a nice shell like iPython (attention to the leading question mark!): In [26]: ?range Type: type String form: &lt;class 'range'&gt; Namespace: Python builtin Init definition: range(self, *args, **kwargs) Docstring: range(stop) -&gt; range object range(start, stop[, step]) -&gt; range object Return a virtual sequence of numbers from start to stop by step. Of course you can also just use python's built-in function ``help``: help(range) 
I did some expiriments with it. It works really well after fixing a small bug which was Windows specific. (Check the Github repo of Nuitika for my pull request to see what kind of bug it is). Nuitika gives a similair result as CX_freeze and py2exe. The advantage for me was that Nuitika does not append the compiled Python code to the executable, but it integrates it in the exectuable. This makes it harder for people to decompile your sources and it enables you to code sign the files without breaking it. Beside this I want to mention that Py2exe and PyInstaller are almost dead projects. It are quite stable packages to freeze Python code with, but there are nearly no new innovations and you can't freeze Python 3 projects with it. Since Pygame now also supports Python 3 I would advice to have a look at Nuitika or CX_freeze. Both can give good results once you know how to use them. 
My brain isn't working too well yet this morning, but take a look at modulus arithmetic. This type of math is a perfect use case.
Range if Python 3, xrange if Python 2. Also, in the future questions like this should be posted to /r/learnpython.
Assuming Python 3.3+, you can drop that loop and use `yield from range(…)`
OpenERP/Odoo requires it's modules to be made on Python, even using a compiled library from it would need to expose the function calls making reuse of the library possible without knowing it's implementation
Could you give me a brief example?
Could this help? http://it-ebooks.info/book/2342/
What os are you running? I don't have python2 on Arch Linux anymore: [ikosa@eee ~]$ python --version Python 3.4.1 
On a lark, I decided to resurrect the old Luminotes code, which I uploaded to github [here](https://github.com/osborne6/luminotes). I've been trying to update it for more recent pythons (2.7), as well as the version of cherrypy used. It sorta works. My next milestone would be to use SQLAlchemy, and possibly switch from cherrypy to flask. After that, it's make it ready for Python 3. 
Thanks! It was actually years ago that I last used it. I'll take a look.
I'm still waiting on python 2 for a python replacement. Rust is looking good actually.
OK, my bad
*moved to /r/learnpython* /r/learnpython/comments/2icwg7/is_it_okay_to_do_optional_imports/
 &gt;&gt;&gt; 1523 % 10 3 &gt;&gt;&gt; 1523 % 100 23 &gt;&gt;&gt; 1523 % 1000 523 Basically, it divides the number on the left side with the number on the right side, and returns you the remainder. I think you could also do something like: digits = reversed(str(x)) To get a string of all digits in the number, in the reverse order. Then you could iterate over it with for, writing out the digits. I can help you more, but I think it would be better if you work on it yourself. Feel free to PM me if you have any questions, I'm not really good myself but I think I can help :)
Modulus operator works by giving you the remainder of a division calculation, for example 10 % 4 equals 2 (4 goes into 10 twice with 2 remainder).
The only thing holding me back right now is Fabric, I've built a workflow around using it to deploy and manage a fairly large Django app and it does not support Python 3 yet.
[Python Cookbook](http://shop.oreilly.com/product/9780596001674.do) Full of small pieces of code (with good explanations) on precise and specific uses. I learned a lot with this book (especially on the parrallel programming and small patterns simplifying my code).
0/10 troll harder
Thank you for sharing. I'm sure this keen insight will be well valued by the community of Python fans and users that frequent this sub. 
Here's a version of your code using modulus arithmetic. units = ['', 'one ', 'two ', 'three ', 'four ', 'five ', 'six ', 'seven ', 'eight ', 'nine '] tens = ['', 'ten ', 'twenty ', 'thirty ', 'forty ', 'fifty ', 'sixty ', 'seventy ', 'eighty ', 'ninety '] teens = ['eleven ', 'twelve ', 'thirteen ', 'fourteen ', 'fifteen ', 'sixteen ', 'seventeen ', 'eighteen ', 'nineteen '] order = ['', 'thousand', 'million', 'billion', 'trillion'] def words(x): if x &gt;= 10**(3*len(order)): return 'That\'s too big!' if x == 0: return 'zero' word = '' i = 0 while x&gt;0: if x%1000 != 0: word = small(x%1000) + order[i] + '\n' + word x /= 1000 i += 1 return word def small(x): ret = '' if x/100 &gt; 0: ret += units[x/100] + 'hundred ' if x%100&gt;10 and x%100&lt;20: ret += teens[x%100-11] else: ret += tens[x/10%10] + units[x%10] return ret print words(100999011222) **Output:** one hundred billion nine hundred ninety nine million eleven thousand two hundred twenty two 
At the risk of doing somebody else's homework, here is my solution: def numberToWords(n): # takes number as integer, prints as string placeValues = [ ("billion", 10**9), ("million", 10**6), ("thousand", 10**3), ("hundred", 100) ] # arbitrary max value if n &gt; placeValues[0][1]*(1000): return "Number too big!" # arbitrary min value elif n &lt; placeValues[-1][1]: return n words = "" # handle all explicit place values for (place, value) in placeValues: if n &gt; value: # build addendum using formatting string words += "%d %s, "%(n/value, place) # modulo arithmetic n = n % value # cleanup final string, add single digits if n: words += "and %d."%(n,) else: words = words.rstrip(", ") + "." return words From the original post I had trouble telling exactly what it is you wanted. However I was bored, so this is my attempt. I also meant it to show off what I consider some better ways of doing things. If you want "dozens" etc, you should be able to modify "placeValues", modulo arithmetic still applies. 4501 = 4 thousand, 5 hundred, and 1. 384900 = 384 thousand, 9 hundred. 800082000 = 800 million, 82 thousand. 12345678910 = 12 billion, 345 million, 678 thousand, 9 hundred, and 10. 1234567891001 = Number too big! 88 = 88 
I like these books: &gt; * [Expert Python Programming practices](http://www.amazon.com/Expert-Python-Programming-practices-distributing/dp/184719494X) &gt; * [Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns](http://www.amazon.com/Python-Practice-Concurrency-Libraries-Developers/dp/0321905636)
You may want to look at [num2words](https://pypi.python.org/pypi/num2words/0.5.1) and see how they do it.
Every few days I'm on pypi looking for some new package. I don't always know in advance what I'll want to use. So I'm hesitant to make the choice to use 3.x yet and limit what I can use.
If you are looking at Rust as a Python replacement you are either using Python wrong, using Rust wrong or using both of them wrong. 
Default Python is Python 2.7 but Python 3 is available in their Software Collections repository. This makes sense because Fedora 20 is still using Python 2.7 as the default Python like most Linux distros. Correct me if I am wrong but I think Debian still ships Python 2.7 as the default Python. There's nothing stopping apps from declaring a dependency on Python 3 though I can see how this might not be feasible for small scripts.
Because it is from 2.3, and pycompat works with 1.5 too.
To be honest, the reason is mostly that I hate setuptools, and avoid using it wherever possible. Also, part of my aim with Pynsist is to build Windows installers on Linux, and I mostly test on Linux, where you don't need setuptools for that. I've [made an issue](https://github.com/takluyver/pynsist/issues/32) so I remember to do something about this.
Can you give me resources how I learn to code like this? 
Not the same. He should at least replace "Python" with the particular language ;)
not sure why you were down-voted but you are completely right. Just make couple of virtual envs and put link of "activate" to your path and switching takes less than a second.
Python 3 has its own pip. If you use that at the command line (I think it's pip3 or pip-python3 or something) it will install packages for the appropriate one. At least, this is how it works for me on Fedora. 
 pip3 install amqpy
&gt;I can see how this might not be feasible for small scripts. What's wrong with just using #!/usr/bin/env python3 ?
This test in `_SystemVersion` for the architecture fails on my 64bit linux machine: if major &gt;= 2: self.is_linux = _plat.startswith(LINUX) self.is_64bits = 'PROCESSOR_ARCHITEW6432' in os.environ else: self.is_linux = string.find(_plat, LINUX) == 0 self.is_64bits = string.find(str(os.environ), 'PROCESSOR_ARCHITEW6432') &gt;= 0 self.is_32bit = not self.is_64bit I don't have an environment variable by that name because it is Windows-specific.
 sudo pacman -S python2 python2 --version
In some repositories it's `python` = Python 3 and `python2` = Python 2. Which actually makes more sense. The newest stable version should carry the project name. At least IMO.
Twisted, I need it for asynchronous http requests in a gobject mainloop.
I see your point and in general I have to agree. However if one is to hold the name `python` it should either be the first, or most stable. 
You should be able to replace the `pynsist` command with `py -m nsist` or `python -m nsist` to get the same result. That launches it using the package instead of the script, but I've written it so that they work the same.
What about this thing? http://nuitka.net/ 
Check out Ansible. We moved over to it from Fabric as our needs grew, and have been super happy with it.
You sound like if someone I work with at NASA MSFC was moonlighting as a pythonista... this is some awesome stuff! 
It looks like you need to print x.text. attrib and tag aren't the actual value. What is being printed looks correct in that its printing the tag and attributes (none) associated with device
At least for CentOS 7, 3.4 is not available through repos, only 3.3.
vtk and wx are the big ones for me
It's open source right? Make it python 3 compatible and submit a pull request. 
You can make it recursive too to allow numbers bigger than 999 trillion. This code is a little cleaner too. units = ['', 'one ', 'two ', 'three ', 'four ', 'five ', 'six ', 'seven ', 'eight ', 'nine '] tens = ['', 'ten ', 'twenty ', 'thirty ', 'forty ', 'fifty ', 'sixty ', 'seventy ', 'eighty ', 'ninety '] teens = ['', 'eleven ', 'twelve ', 'thirteen ', 'fourteen ', 'fifteen ', 'sixteen ', 'seventeen ', 'eighteen ', 'nineteen '] illions = ['', 'thousand', 'million', 'billion', 'trillion'] def words(x): word = 'zero\n' if x==0 else '' for i in xrange(len(illions)-1): if x == 0: break if x % 1000 != 0: word = small(x % 1000) + illions[i] + '\n' + word x /= 1000 if x &gt; 1000: word = '(' + words(x).strip() + ') ' + illions[i+1] + '\n' + word elif x % 1000 &gt; 0: word = small(x % 1000) + illions[i+1] + '\n' + word return word def small(x): ret = '' if x/100 &gt; 0: ret += units[x/100] + 'hundred ' if x%100&gt;10 and x%100&lt;20: ret += teens[x%100-10] else: ret += tens[x/10%10] + units[x%10] return ret print words(10**20) **Output:** (one hundred million) trillion
It doesn't list how important they are or what they block, but did you know of the python wall of shame, listing packages that aren't yet updated?https://python3wos.appspot.com
Take a look here: https://python3wos.appspot.com/ Personally, a few out of this list I'm using that still don't support py3k: Thrift, Paste, MySQL-python, Fabric, mrjob
[Python 3 Wall of Superpowers](http://python3wos.appspot.com/) is what you're looking for. It shows Python 3 compatibility for 200 popular packages.
Thank you
Thank you
Everything is possible. Look at `re` and `urllib2`.
`python3` should still be aliased to `python` if that is the case, any distro that does not do that is insane.
http://code.activestate.com/lists/python-checkins/32587/
Also Scrapy is a great framework for scraping and spidering. Probably way overkill for what you want though.
If the modules you need are [listed here](https://twistedmatrix.com/trac/browser/trunk/twisted/python/dist3.py), then you should be able to use Twisted right now. I've heard Python3 support is now a priority for the project, but they need manpower.
You could use some sort of license key model, or even always online DRM (and alienate your users a bit). That would still work. All in the library of course.
Plenty of good - also advanced - python books : http://pythonbooks.revolunet.com/
Hehe, actually, he did post in /r/java. Then proceeded to remove all his comments after the [mods clowned him](http://www.reddit.com/r/java/comments/2hgb6t/for_what_reasons_should_i_choose_java_over_c_in_a/cksygge). Though I found his vacuous post pretty funny ... it looks like satire.
It's real, but people often install the same version of the same package multiple times, which artificially inflates numbers.
New Continuum dev here. Which libraries do you wish had Py3K support?
Well said, fagmaster_9000.
not sure if you just have a copy paste error or if your data is malformed but it looks to me like the opening appuser tag is missing its closing angle bracket. &lt;appUser uuid="{15324E26-B769-962E-D811-043D315679AB}" should have a "&gt;" on the end. if it doesn't your data might not parse correctly. edit: also going to bandwagon on use lxml for this kind of thing. its a great library.
Well, things like twisted.web.client.getPage and twisted.internet.task.deferLater worked out of the box. I'm using GObject.io_add_watch for some other things like reading evdev and other stuff. 
Well that's good to know. Hopefully redhat 7 will be swiftly adopted and it won't be much of a problem anymore. Thanks for the info, I haven't looked into this too much as we haven't really started looking at rolling out 7.
That only works 3 is installed. The point here was that redhat 6.5 doesn't provide a python 3 through their own repositories so it can't be reliably called. Edit: so apparently it is available in the software collections repository. I can admit that I was wrong that it isn't available at all, but it being in a non-standard repository that not everyone has access to (or it seems like it) still means that it's adoption is slowed.
[Requests](http://docs.python-requests.org/en/latest/) is my favorite library for doing http stuff in Python scripts. combine that with some [lxml](http://lxml.de/) for parsing html and xml data and you're good to go. 
It's not a huge thing, but Flask-WhooshAlchemy (Flask plugin for Whoosh search indexing of SQLAlchemy data models) breaks in python 3. They are working on it though.
Thanks dude!
Google's protobuf python library - code is mostly python 2 only. There are some python3 3rd party libraries... still trying to use them now.
Python 3 has [pathlib](https://docs.python.org/3/library/pathlib.html) for this purpose.
No he hasn't. He has said that 4.0 will just be the release after 3.9, but he has explicitly said that he is not promising that there will never again be a compatability-breaking release like 3.0 was. Example reference: http://comments.gmane.org/gmane.comp.python.devel/148985 (I think there was a more clear thread on python-dev, but this one generally says it anyway)
Which distro uses python = python3 ?
I've been using Python3 for science the last few months and been (mostly) fine, even with the smaller packages. There are a few that aren't updated, but usually just the smaller ones, so they are easy to update for 3.
We're already planning for next year! Watch pytexas.org, follow @pytexas on Twitter, and participate in your local Python groups. PM me if you want to know more. :)
They're real in the sense that someone really downloaded the package, but there are tons of reasons a package could be downloaded, lots of people run mirrors which update regularly, CI systems can perform tons of downloads of the same packages, etc.
It's not a problem for me, I'm just saying that some people might. Especially with the possibility of being stuck in old HPC environments, I see scientists preferring to stay with python2 for now. Continuum's products go a long way to alleviate that though. I make use of them myself quite a bit, so thanks!
The problem is when you make backward breaking changes. If customers upgrade RHEL and then all their scripts break because now python = python3, they will be very unhappy, and for good reason. In the world of enterprise software, you do not break customer workflow.
RHEL *5* is also cited as a reason for why [ansible](http://docs.ansible.com/faq.html#how-do-i-handle-python-pathing-not-having-a-python-2-x-in-usr-bin-python-on-a-remote-machine) still runs on python2.
Hmm... I read that reference as "*I* don't want a breaking release, but I cannot guarantee someone somewhere will create an incompatible Python". Either that, or he really communicated quite badly two days before: [This message](https://mail.python.org/pipermail/python-ideas/2014-August/028827.html) seemed quite clear to me. Maybe it depends on his mood ;)
https://python3wos.appspot.com
Yeah, what you're saying is exactly what I was getting at. Small specialized packages that it doesn't make sense to devote developer resources to updating. Especially when those developers are really scientists for whom writing code is a secondary pursuit. Continuum makes [Anaconda](https://store.continuum.io/cshop/anaconda/), which is a python distribution that emphasizes scientific applications. It helps with getting up-to-date installs of python itself and lots of packages installed in a user prefix on HPC systems. They also sell performance-tuned versions of stuff like NumPy and also some fancy numerics packages that perform pretty well in my experience. (I'm not affiliated with Continuum, but I like and use their products.)
u/amfarrell of Continuum in this thread is asking for names of packages -- who knows, maybe they'll get some attention that way.
Supporting all is not a trivial change. We heavily using python3 features. Currently we are using python 3.4 and in next version python 3.4+ will be the unique supported version.
https://gist.github.com/ post a link with your code and I'll take a look
It would be nice to have a comprehensive list of all the "y"s to persuade and assist the python community in resolving as many of them as possible. It could also point people in the direction of distros and libs that are the most proactive.
You don't check for (row-1) or (col-1) to be negative, and since python accepts negative index it's when it bites you back. foundNeighbours += grid[row-1][col-1] #TL foundNeighbours += grid[row-1][col] #TM foundNeighbours += grid[row][col-1] #ML I solved similars problems over and over again, this is my solution: def count_neighbours(grid, row, col): m, n = len(grid), len(grid[0]) dt = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)] counter = 0 for di, dj in dt: nrow, ncol = di + row, dj + col if (0 &lt;= nrow &lt; m) and (0 &lt;= ncol &lt; n) and (grid[nrow][ncol] == 1): counter += 1 return counter I hope you find it helpful to improve your code fu ;)
Here is the bit that brings up an error: https://gist.github.com/radogene/6b824eebca7bd09fee68 on cmd this runs fine however on the apps i'm trying to use it brings up the error: Traceback (most recent call last): File "/home/radogene/textgame.py", line 1, in &lt;module&gt; charactername = input("What is your name?\n") File "&lt;string&gt;", line 1, in &lt;module&gt; NameError: name 'George' is not defined (George is what i'm inputting) edit:also the import time is used later in the script
pep 394 recommends `python` shebang only for scripts that support both Python 2 and 3 from a single source otherwise python2 or python3 should be set explicitly. From the pep: *for the time being, all distributions should ensure that python refers to the same target as python2.* Arch is a notable exception. 
You're using `input()`, which doesn't take the input as a string but rather an expression. Change it to `raw_input(promptText)` instead and it'll be taken as a string no matter what. 
Ah thankyou! why does just 'input' work in notepad++ and not the other ones? 
pybedtools, please. Its a great package for bioinformatics.
Anaconda is great!
Pro Python - Marty Alchin
This is why open-source software is amazing. See something fishy, checkout the commit/source.
ah ok, thank you for the response. That is really annoying because all the chromebook ones seem to use the raw_input and notepad++ doesn't understand it... Is there an easy way to change the python I have installed on my actual PC to 2.7? edit: I assume i would just find the file online, what i really want to ask is... should I downgrade if it means everything works together? or should i just put up with not being able to test run the file on my chromebook?
I know Arch does — however that means anything using Pacman. 
Okay, first of all, something you need to know: Notepad++ has nothing to do with running your Python scripts. At all. It has a hotkey for running them, sure, but then it runs them in the Python interpreter installed on your computer with Python, not with Notepad++. With that out of the way - the way you do this is to quite simply uninstall Python 3 and download Python 2.7 from python.org. No easier way, really, but it shouldn't take too long. Learning the differences between Python 2 and 3 isn't really all that important in the beginning - what matters is you make things and things run okay for you!
I doth think this is what is being asked for. The method is called asynchronously, but the buttons are still iterated through synchronously.
Hey, no shame in learning! You can holler anytime you need help! Once you get a grip on language basics, you'll probably find yourself on a healthy diet of StackOverflow with the rest of us.
I agree. Requests works really well with beautifulsoup too
I know about these models, but they're easily crackeable on python because of the way the library must be exposed to OpenERP/Odoo i've been doing extensive tests and some "black hat" tests on my own protection schemes and they protect very very little.
Have they dropped their SDL dependencies yet?
I don't get it. I wrote an application in Python 3 using twisted only a month ago.
SICP. I'm not kidding. Python made so much more sense to me after I learned Functional Programming and my code has improved greatly.
~~Yeah, I appreciate the answer, but I think I'm just going to have to inject javascript and click the links asynchronously that way.~~ nevermind, this totally worked. It clicked all the buttons considerably faster. Thank you /u/rhgrant10
I wish NLTK had a non-alpha 3.0 release. That said, I work in a "scientific" shop and have gotten along just fine with 3.3. My most recent project was a Tornado webserver using 3.4. So it's not all bad.
Yeah that's what it does. The `click_all` method is performed in a separate process, but initiated from this one.
And we know it was him because of the username?
The only one that I used to know of was Django. I see they support Python 3 now too. I will admit that bytes and strings still piss me off, but I am far happier with Python 3 than I was with Python 2. Then there are other things like py2exe, which isn't avail for py3, but you can use another module like cx_Freeze. How about PyCrypto? Pretty sure that's 2 only and I don't know of a Py 3 comparable module.
Why are you suggesting he uninstall python 3 in favor of python 2?
Yeah, "tim_one".
&gt;SICP http://www.composingprograms.com/
&gt; I've heard that mirrors of PyPI cause a lot of 'downloads'. I wish someone would implement some kind of filtering so the numbers were more realistic. It would be easy to do periodic sampling in order to establish a baseline. ... [EDIT] https://github.com/pypa/warehouse/blob/master/warehouse/urls.py https://github.com/pypa/warehouse/blob/master/warehouse/packaging/views.py#L127 https://github.com/pypa/warehouse/blob/master/warehouse/packaging/db.py#L40 
Yup. Plus, if you want to install a Python3 library using yum, you're out of luck. Trying to install any packages which do not use the default system version of python are riddled with problems, to the point where you are better off building your own packages, which can be more painful (that is, cost you more in terms of time and money) than just sticking with the default version.
As long as that's the word of advice, the community will never be on-board with Py3. If he's new, and already using Py3, why not keep on with Py3? Just because the entire community is not yet up to speed with the current version of Python, it doesn't mean this guy should start behind as well. 
This. And if you can, use lxml. It's easier to use when you start playing with namespaces.
It's not like you can't just read the code.
I'm not a frequent user of mercurial (VCS used for Python), but it looks like it uses SSL. While it's not *impossible*, it is so unlikely as to make to difference.
Tim is already a bot.
It's actually really great. ...but it doesn't support dl calls or file system calls fully, which means if you use __path__ in you code, or ctypes (or any extension module really) its really up in the air as to if it works (sometimes it does, sometimes not). If you're using pure python, it's probably a great choice. ...but for games I guarantee you'll be using a tonne of c libraries, and they don't play nicely. Still, it's worth keeping an eye on. It's certainly the most promising effort I've seen in a long time. 
Maybe, but that just can't possibly be a good idea. Let's not do that.
To make that show up correctly, you need to put a backslash in front of the #, like so: \\\#rekt
Python is one of the only languages where it's okay to use exceptions for control flow. Check out how generators work. But the example you show above should not use exceptions, it's a simple value check. Comprehensions are often a good way to avoid nested ifs. In the end, readability is more important than terseness though. 
Thanks for the correction! Any stories of the conversion process? I'm sure there were some hitches along the transition.
Dropped? They are in the process of moving from a pygame backend to SDL2.
I'm an extremely new guy, learning when I have free time. I'm treating Python 2.7 as deprecated, instead of LTS. Working great for me so far. 
Well... There's always giving back to the open-source community then... Good luck
I just started with kivy, how does one make sure they are writing with 2.7 instead of 3?
&gt;In the end, readability is more important than terseness though. They often go hand in hand, however. If you are writing less code, or at least meaningful operations, to perform the same task, it is likely the shorter version will be much more comprehensible.
well you could also use ands and ors in your if statements
Stupid pet peeve not related to the question but instead of code like buttons = b.find_elements_by_id('lt-button') for button in buttons: I'd really rather see for button in b.find_elements_by_id('lt-button'): See also: `return` statements. 
Yeah I have decided to choose this book. It is really good so far.
https://www.youtube.com/watch?v=pWdd6_ZxX8c
I know right! Anybody who uses a computer everyday for his job should really invest a couple of hours to master Git. But since they don't... some of them actually consider DropBox to be a reasonable collaboration option.
https://access.redhat.com/solutions/472793 
The Fabric devs had to wait for paramiko to port, and in the process decided to build Fabric 2.0 from scratch. You can get the "local" part of this, pip install invoke if you want to get a feel for it, because it will be different. 
You can use a namespace qualified string as your parameter to findall(). Let me confirm tomorrow at work for syntax. _edit_ found it. You prepend the element name with the namespace wrapped in curly braces. For example: plugins = element.findAll('{http://maven.apache.org/POM/4.0.0}plugin')
I'm not sure if this makes a difference, but clicking each individual button in an ordinary for loop took so long because each button made a request and I think Selenium was waiting for the request to finish before moving on to the next button. I could be totally wrong, but this is what I observed.
Well, if you are running on command line on *nix, by using the python file.py command instead of the python3 file.py command.
I thought the point was OP wanted to get rid of python2?
Oh, good to hear. Didnt even know python3 was a command, thanks.
how does lame/stupid comedy get downvoted in a sub dedicated to a language named after monty python?
They are real, rational and natural.
Define `__iter__`. Read up on the iter protocol. 
I think it should background properly without the p.join()
OK, but doesn't that define an iterator instead of a generator? I know the functionality is equivalent, but is there a way to make use of the nice properties of generators (yield, automatically raising StopIteration)? Edit: wait, I'm a fool. Can you just define __iter__ to return self and use yield in __next__?
You would implement the __iter__() method and place yield statements in there. class Filter: def init(self, file_handle, filter_for): self._file_handle = file_handle self._filter_for = filter_for def __iter__(self): for line in self._file_handle.readline().rstrip('\n'): if self._filter_for in line: yield line Be careful what you wish for; in many cases what you really want is a collection of objects, not an object that is a collection. A list that contains many of the same type of object is often the easier solution. Iterator classes have come in handy for abstracting filtering i/o for me, but it's easy to be tempted into going abstraction mad.
Fedora is considering it too - they posed some questions on the pydev mailing list last month.
A quick glance reminds me of [CodePad](http://codepad.org/)
Just return a generator from `__iter__`. Or make `__iter__` a generator. For example: class IterInt(int): __iter__(self): yield self Nevermind that's not something polite to do to int (I couldn't monkey patch it). That returns an iterator. Implementing `__next__` is messy 99% of the time. Edit: for the record, I was trying to use `yield from chain(num, countdown(num-1))` for a recursive countdown because I was bored... But it worked. And mad science levels you to evil geniusry at some point.
https://twistedmatrix.com/trac/wiki/Plan/Python3 A lot of things are working now with python3 but some modules are still missing.
Some *nixes have Python3 by default--My Arch Linux install does. To run Python 2.7, I have to use python2 file.py and pip2 install package. If I want to use Python 3, I just use python file.py for Python 3. The easiest way to check is just to run Python and see what version it is. Here's what I get: ~ $ python Python 3.4.1 (default, May 19 2014, 17:23:49) [GCC 4.9.0 20140507 (prerelease)] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; ~ $ python2 Python 2.7.8 (default, Sep 24 2014, 18:26:21) [GCC 4.9.1 20140903 (prerelease)] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; 
Fedora maintains significantly more up to date packages than redhat as redhats intention is tried and true stable packages. What version of centos? 
You have to background a function like you did but this function can't be the running function itself. def worker(): do_something def main(): p = multiprocessing.Process(target=worker) p.daemon = True p.start() while True: do_something() if __name__=="__main__": main() The join statement is waiting on the background process while stopping the current process! 
\#rekt
I started using python3 at work. Some people say there is no momentum to switch to python3 but Just looking at this post and all the pypi modules that I have pulled in lately have py3 support. You can almost feel it
does asyncio not do what you want?
&gt; MySQL-python This keeps coming up, but there is [a drop-in replacement developed by Oracle](http://dev.mysql.com/downloads/connector/python/2.0.html) which is pure-python and works fine with Python 3.
It'd be nice if maybe the pypi folks offered a way for mirrors to download files without incrementing the download counter. Maybe an alternate URL (i.e. mirrors.pypi.python.org) or a query string, (i.e. ?increment=false)
You could do the same thing in one line: [button.click() for button in b.find_elements_by_id('lt-button')] But in your situation you probably may want to use multithreading.
Thanks. I'm using it through a third party library that imports it, so unless I fork this library, I'm stuck with this version. 
Upvotes for the both of you! **HI**larious
 haste $(which haste) http://hastebin.com/hisegetasa.py That's how it works :)
OK cool, I didn't know about that library. But yeah, Python 3 is interesting . I just don't know if the day where we actually switch to it will ever come.
This is wrong on so many levels.
The problem with this is that /u/radogene is apparently having problems since some of their different testing environments only run Python 2. Learning Python 2 first is no big deal, once you know your way around it you can make the switch to 3 if you want to.
In my experience, it works much better if you just do things in the foreground and leave daemonization to any of: * your init system (if you're using upstart or systemd), * something like runit or DJB's daemontools (both of which can run under the init system of your choice), * inetd (if you're fine with launching an instance per connection), * the Windows "Service" control panel There are so many complicated things with trying to daemonize yourself in the Unix world — e.g. calling `setsid`, cleaning up your environment (\*cough\* bash \*cough\*), handling lockfiles correctly and keeping track of your pid with them ... it's just way easier for you and cleaner for your users just to delegate that to a daemon system that does all that really really well.
Eli5? Or if I needed to know would I grok the code (I've read the linked commit on the other comment)
*Wall of Superpowers
No reason other than that was chosen sometime back. It simple enough and does our job.
Fair enough. Hopefully that library will be updated at some point, the project behind Python Connector is much more active than mysql-python these days.
wrong. Redhat's intention is to ensure Microsoft stay relevant, which is why it has ex-Microsoft staffers like Miguel de Icaza ensuring GNOME is crap compared to Windows. Forget the recent shellshock bash bug, RHEL 6 ships with a bash package that corrupts the display of $PWD. It was existent in at least 6.2. Although there were errata packages to correct this flaw, subsequent RHEL releases never included the fixed packages, because Redhat don't do any proper package or release management. It does not ship "tried and true" stable packages, it ships horrible old bug-ridden filth that no right-thinking sysadmin would ever let near their hardware. The thing with the free software movement is it forced an industry change away from the kind of thinking that something horribly old was more stable, into the more logical conclusion that old, bug-ridden filth cannot possibly be more stable than the current version with those bugs fixed. This is why e.g. Google Chrome has a new stable release every 6 weeks or so, to get away from the problems caused by e.g. enterprises sticking with IE6 for many years after its derided as a massive security hole &amp; even Microsoft are saying "please don't run this horrible old software of ours", for the first time ever. RHEL caters to the old clunkers who haven't caught up with the industry change of ~20 years ago. If you're such a person, by all means run that horrible distribution &amp; have fun with Python 2.4 or whatever it has from 1998 or whenever it was last updated. The rest of us will have already gotten real work done with software better suited to the hardware its running on. 
Wow! I don't really know how to respond to that. Ignoring the part about redhats intention being to keep Microsoft relevant and the personal attacks (which I don't really understand). I never stated a preference for redhat, just that their large install base and preference for older packages (in this case Python) is a roadblock to Python 3 adoption. Do you disagree with that?
Yeah, that's what I'm saying. Invoking Python 3 doesn't help solve the problem of Python 3 not being available on the system.
Better to read the full code at: http://svn.python.org/projects/python/trunk/Lib/hmac.py Basically: `HMAC.new` initializes a new HMAC object with all sorts of instance variables. Calling `copy` on an existing HMAC object calls `HMAC.new`, then overwrites all its instance variable with copies of the existing object's instance variables. But if copy immediately overwrites all the instance variables, there is little point in initializing them. So they built in a back door: `copy` calls `HMAC.new` with the argument `_secret_backdoor_key` and HMAC's `__init__` method recognizes that and skips all the initialization and returns immediately. Purely a performance optimization.
Regular expressions (the `re` module) are not an acceptable method of parsing XML.
This is outdated: download counts were reinstated due to popular demand, and made to work with the CDN. The bits about mirrors and caches obscuring real usage numbers still apply.
Looks like a good use-case for the new `enum` module, to make things less confusing?
This is the wrong channel. /r/python is not for jobs, but for technical stuff. You have other way to contact pythonneers, like the python job board. Beside, no offense but there is not enough info on the site to pique my interest. At minimum, you need to be more transparent about how much money there is in the company. As a senior python dev, you won't get me if I don't have a sense of solidity. And last, please get a designer. with a few modifications, your site would look much more professsional. Silly but that's part of the first impression, and *that* is part of business. My 0.02c. 
No, this is not related to enums at all, they just needed a class variable so they could use the object id. Python 3.2 and up do away with the secret backdoor key by using `self.__class__.__new__(self.__class__)` in the copy method.
The forked process is working until **do_something** ends while the main process is running infinite. That's a typical template, nothing more. Of course, when you want to end the program, you have to insert a condition and take care for your forked process. The point is, C programming is a little bit different here. The python modules for threads and processes have a similar approach which makes Python awesome. 
Don't use the system Python for development. Its there for dependencies only, for boot scripts and system config tools that need a python interpreter. Rather, create your own development environment on that system. My preference is to use miniconda to bootstrap core Python, then use conda environments for each project. If you do web stuff, one thing that's worked out beautifully for me is to build uwsgi in modular form and use emperor mode to run each web app independently. I can "source activate" the python environment and build uwsgi's python module against each version required. Note you only need to do it per python version and not per project as uwsgi's venv feature will load in the right per-app environment anyway so long as you specify to use the right python version module in the vassal config. It works pretty much the same way with Ruby using RVM too - "rvm use" the ruby version/gemset with each rails version and rebuild uwsgi's rails module against them, then the rvm and gemset options in uwsgi's vassal config sort it out nicely. Tools like Fabric and ansible make it trivial to bootstrap new environments and deploy to production systems. Another technique is to use vagrant for all your fun stuff. Once again, tools like puppet or ansible can bootstrap new environments with the needed tools and config. This way its totally segregated for the raw system itself and can cause even less problems. This is especially useful if you have a different system, e.g. your laptop runs OSX or Windows but you want to dev on Ubuntu. 
Awesome! Thanks, strange that they chose an empty list as the default, I presume because it will never equal any other object (using "is"). Python idioms I still have a share to learn.
Thing is `__iter__` has to return an iterator (a generator is a kind of iterator), `__next__` has to return the next item. So making `__next__` a generator only makes sense if you want to loop over generators, which isn't what you want to do here.
There's stupid then there's *stupid*
ahhh, thanks! good to know
Python 3 support is getting better each passing day. Have a look at Python 3 Readiness (http://py3readiness.org) :)
I think that `sentinel = object()` is a better idiom. Then you know for sure that it's going to be unique and that it isn't useful for anything else except being unique.
Or http://py3readiness.org ;)
Oh I know it was just for the id; that's why I suggested enums. While the list was a serviceable solution, and `self.__class__` is better, using a class-defined enum would make it clear that, in this case, all that's needed is a unique _thing_. That's what enums are for, so someone reading the code wouldn't be surprised to see an enum, whereas seeing `self.__class__.__new__(self.__class__)` is surprising and confusing.
Sure they are real, but that number includes replication in other backup services or other package managers.
Are you psychic?
Though certainly possible, in my opinion, Django is a strange thing to use in a Kivy app. Kivy is your GUI, so what is a web framework being used for? Are you using the Kivy app as a GUI control to start/stop a web server? Maybe you just want the ORM? In that case most people would recommend SQLAlchemy instead. The one legitimate use I've seen for this kind of thing is using Kivy in a kiosk-like application, and using Django to access the kiosk remotely.
There's very little point to using a 1-element enum for that. The usual idiom is `sentinel = object()` though, I wonder why they used an empty list.
I learn Python GOOGLE-ey - I google for what i need to do, paste it in, and voila!
Not if you've already made a handful of programs, modules, and maybe even began to build a business on it. It's a tedious switch, and for no reason.
Great to hear! Thanks for sharing. I am somewhat surprised it works in 3. Did you not need to change anything within it? I've had to port over a few basic encryption scripts from 2 to 3. 
What packages are you using as a beginner that are not available in Python 3, but they are in Python 2?
Care to explain how did WSGI solve all the problems you mentioned?
&gt; I understand what request is supposed to be but what exactly is it? Let's assume it's about the same as Django's &gt; So response is the socket? Let's also assume it's the same as Django's It's just my rough idea. It could function the same as WSGI, but provide extra (Like close response first then do some processing)
What do you mean by "putting link of 'activate' to your path? Can I add an entire virtualenv to my python path by adding the activation script?
Nice effort. Something doesn't add up though. How can it be already funded with about 50 backers if the highest pledge is $50? Something to do with kickstarter?
You can give as much as you want. If you give more or equal to one of the rewards, you can choose to get it.
Except that, again, you begin your foundations almost immediately. I regret having started with Python 2 when I did, and there really were many modules not yet converted. I still fail to see a single reason why to not start with 3. What module isn't supported or what part of Python 3 for a newbie is inferior to starting in Python 2?
not positivitely sure, but it seems to be (or looks like) he's recorded macros in vim and is playing them back. 
I wish there was a tool that'd do such kind of automation. 
/u/radogene was having trouble with the tools they had available and were using. It really isn't a big deal which version you start learning in. Sure, you might regret starting with Python 2, but I sure as heck don't.
Not exactly the same but i have seen people use git when presenting live. If you don't mind Ruby look at [git-presenter.](https://github.com/pythonandchips/git-presenter)
python2.7, and I'm not doing IO, really.
/r/cscareerquestions is more appropriate.
http://stackoverflow.com/questions/18625085/how-to-plot-a-wav-file First google hit. 
this doesnt fully answer ops question as it doesnt use pyqt.. but its a giant step forward. OP, what is your end goal ?
Well, it's not gpg-signed.
I guess his computer could never be hacked...
No, /u/askype is kind of right. Probably a typo. You have *target=main*, which will try to create another child and crash. AssertionError: daemonic processes are not allowed to have children
relevant: http://slash7.com/2006/12/22/vampires/ 
turtle.pu() # for pen up. then pd() for down.
https://docs.python.org/3/ We're not going to do your homework for you. 
I'm not asking you do do my homework for me, I'm asking for some help on a programming task, if you program yourself you should know how hard it is to learn a new programming language.
Show us some code and we'll help.
You're going to want to go through the different data structure types, and see which ones would fit your problem: https://docs.python.org/3/tutorial/datastructures.html The *random* module will prove useful in picking random questions: https://docs.python.org/3.0/library/random.html And you'll definitely need statements related to control flow: https://docs.python.org/3/tutorial/controlflow.html You might want to make it nice and clean by making your own functions, which is covered on the control flow page.
Brilliant, thank you
here's some hints: 1. to ask the student's name you'll want some input entered on the keyboard right? look in the Python docs for a function called raw_input. 2. to generate the quiz questions you'll need to make some random selections right? look in the Python docs for a utility library called random. 3. You have two different types of random choices to make. The first kind chooses a random number. You'll need two random numbers to make a quiz question. What else does it take to make a quiz question? You'll need to randomly choose an operator from a list of ['addition', 'multiplication', 'subtraction']. That's also a random choice but its a different kind of random choice than getting a random number. 4. You'll need to make 10 questions to make a full quiz. What is the best way to repeat the same instructions 10 times in a row? I'd use a for loop. Read about it in the Python docs. 5. What are the steps you need to do at each step of the loop? Generate a question, ask the student for their answer, check the answer, and then print the result. That's a good way to organize your code. Define a function for each of those steps. Read in the Python docs about defining functions. 
the condition evaluated in an if clause can be a compound condition joined with "and" or "or". you don't have to nest ifs to get compound conditionals. example: if x &gt; 3 and x &lt;= 6: print "x is between 4 and 6" 
This is going to be really nitpicky, but oh well: * In `DispatchOnValue.add`: * Why do you have `self_of_parent`, which is nothing but an alias for `self`? * Why return `wrapped_f` from `wrap`, instead of `f`? * In `DispatchOnValue.dispatch` and `DispatchOnValue.dispatch_strict`: * (matched, matched_stream) = self._match( stream, t[1], {}, {} ) -&gt; matched, matched_stream = self._match(stream, t[1], {}, {}) * Also, `for t in ...` -&gt; `for f, pat in ...` as well as `t[0]` -&gt; `f` and `t[1]` -&gt; `pat`. (And then you can remove the line `f = f`.) * In `DispatchOnValue._match`: * What's up with that `context` dictionary? :/ * I find the internals of this function rather confusing, so maybe I'm off, but I really don't think you need to create so many copies of `context` as you do. * In ... * if not len(stream) == len(pattern): why not if len(stream) != len(pattern): ? Some more high level things: * The "trying to find a match by throwing things at it" might be a bit iffy in terms of corner cases (also: functions with side effects). * How useful are `any_*` really? * More generally, how many people are going to need dispatch based on actual values? Like, "I need to call this function if it has a list that is equal to [1, 2, 3]" instead of "I need to call this function if it has a list of numbers", which you don't support. * No support for `**kwargs` :( * Nothing happens if dispatch fails, instead of raising an exception, as I would expect, and dispatched functions can't return anything. I would let `_match` raise an exception instead of returning `False`, and just straight call `f` and return what it returns.
I'd be willing to contribute via Kickstarter to have this project mature. I've tried linting my Django code, but there are just so many false-positive
Wow, thanks for looking so closely! I need a bit of time to digest your comment...
You are right, it's a typo
I did what I did with `self_of_parent` because of cloudy thinking - that's what you need to do in Javascript. That is, make your own reference to `this` to use it in a closure. Clearly this isn't needed in Python - I'll change it.
&gt; how many people are going to need dispatch based on actual values? &gt; Like, "I need to call this function if it has a list that is equal to [1, 2, 3]" instead of "I need to call this function if it has a list of numbers", which you don't support. This is true, but a list of numbers would be closer to dispatching on type, which seems to be a problem regularly tackled according to google. Already committed some changes you suggested, continuing to read through the rest of your points... Thanks again, code is steadily improving!
NLTK is a good library, however in order to effectively use it towards your goal, you'd need a lot of training in Computational Linguistics. If you are a beginner, the best starting point is this: http://www.nltk.org/book/ You've gotta realize that your project is a lot more challenging than simply importing the right module and calling a function. NLP in general is one of the more advanced and difficult area of computer science, due to the variety and ambiguity of real human language and the way grammar evolves over time. That's why things like Siri or Cortana are so valuable and seem so magical. For this specific project, I guess the best way to do it would be to build a specific set of grammar to parse your input. Think of grammar like a template/abstraction: instead of "remind me to call joe at 3pm tomorrow", your grammar could contain something in the form of "remind &lt;noun phrase&gt; to &lt;verb phrase&gt;", which is a generalized form of your queries.
My life would be much more difficult if it weren't for Gohlke's page of binaries. If I ever have the opportunity to meet him, I'd buy him a case of his favorite beer without hesitation.
Compiling anything in windows is such a pain in the ass. I can't wait for clang to get a windows version so python can switch to that and we can stop using VS for compiling python and all these libraries 
OK, I've committed fixes to all your points to the develop branch, apart from: &gt; * What's up with that `context` dictionary? &gt; * I find the internals of this function rather confusing, so maybe I'm off, but I really don't think you need to create so many copies of `context` as you do. Yes. I'm using it to pass parameters but it's rather clumsy. I think I need to use an iterative method rather than recursive and get rid of `context`. &gt; * The "trying to find a match by throwing things at it" might be a bit iffy in terms of corner cases (also: functions with side effects). Side effects - that's a good point. There are a couple and I need to think about how to get rid of them. OK, thanks again! The code is improved and my knowledge of Python has grown a bit.
I meant adding activate.sh to your linux path and you can execute it via the terminal. Personally I've written few bash scripts for my virtual environments that go something like: cd $1 #project location source ~/virtual_environments/scrapy/bin/activate put the script location to your path and: . script project_location it will launch virtual environment and jump to project location. I'm in no way an expert when it comes to Linux but so far this has saved me a lot of time.
It looks like others have addressed your issue - but might I suggest posting in /r/learnpython in the future? There are a lot of us that hang out in there as well. We're happy to help, and it helps keep this subreddit on-topic.
&gt; exceptions are not for control flow, even in Python [citation please] My coding style says that an exception should be raised any time the function called is unable to fulfill the developer's expectation.
That's terrible. No, your way of doing it is wrong.
While this is a great resource that I have used many times, [Anaconda](https://store.continuum.io/cshop/anaconda/) has become a much better way to get scientific and numeric packages working on Windows. 
I certainly understand it's more than just a function. But, the answers I've been getting here seem to imply I need a masters degree in computational linguistics to even get started. I recently found this: https://wit.ai/ This is pretty much the functionality I was looking for, but they're a SAS company. I've been fooling around w/ their free account plan and it works surprisingly well. I might just end up using them, but I'm wondering if anyone's attempted to do what they're doing in an open-source model (or if that's even feasible).
&gt; "make sure" that everything is in order. If you're trying to sanity-check your own code, use assert: &gt;&gt;&gt; x = 1 &gt;&gt;&gt; assert x &gt; 3 Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AssertionError
Don't think so. My usecase is fairly simple though, something like that: from Crypto.Cipher import AES aes = AES.new(b'somethingsomething') aes.encrypt(someStuffOfCertainLength)
Yep, was a combo of these 2. lxml was much easier to work with, and I didn't realize that .attrib wasn't the real value, .text was. Thanks!
If anybody else gets an error trying to install scipy here's a fix: https://stackoverflow.com/questions/22878109/error-installing-scipy-library-through-pip-on-python-3-compile-failed-with-err It will take fucking aeons to fully install though.
Sure! Thanks, i will :)
I don't get it... why not just? &gt; C:\pip install numpy
Because VS. Settung up compilers in windows is a hassle.
Certain packages return a vcvarsall.bat not found error. Much easier to use windows install if you don't have the correct version of visual studio. At least, in my experience. 
You should probably ask for advice on /r/learnpython instead, which is geared more for helping new programmers and answering questions like this.
The else clause shouldn't have a condition attached to it, else means if all of the above conditions failed. You could either get rid of the condition or change else to elif. Also, something you could do to make the whole thing more readable is to move the first condition into an else clause at the end, that way it will be clear that you intend the program to print "You must enter a valid choice." if operation is not equal to one of the above choices.
I am on this boat as well. There seems to be an aweful lot of false-positives that you have to acquire enough general comfortability in order to sift through the false-positives.
There are already plenty of free alternatives to this. CodeAcademy and the likes if you find this way of learning useful. I personally still prefer a classic textbook that explains everything with a few exercises at the end to verify you understood what you learned.
If you learned it using a decent course, you would have saved so much time that you now waste googleing. Python can be learned in such a short time already!
OMFG, start with aDict = { 'adc': ['Draven', 'Lucian', 'Twitch', 'Caitlyn'], ............., 'smurf account': ['etc', 'etc'], } The if statement becomes: if operation in aDict: print ', '.join(aDict[operation]) else: print ', '.join(aDict['smurf account'] You can easily add account groups. 
Yes , that one! Also i found a few more : http://liftoffsoftware.com/Products/GateOne http://liftoff.github.io/GateOne/Developer/terminal.html Also we have graphterm but it is webased.
Welp, I'm underpaid then :(
Seriously...[/r/learnpython](http://www.reddit.com/r/learnpython) Having said that. I will do your homework for a nominal fee...
The counting problem is actually NP hard and there are no known linear solutions. The current state of computer science theory says that the best known exact solutions will have runtime O(2^n). To avoid this combinatoric explosion you should go with a Monte-Carlo approximation. The basic outline is: You start with a random field of frequencies check if the estimated frequency for 'a' is too low and increment it until you reach the true value, then continue with 'b'. There was this guy from CodeAcademy who made a good video with an explanation and a code example: https://www.youtube.com/watch?v=dQw4w9WgXcQ
Really? Honestly I'm surprised this was controversial. There's no reason to avoid a simple operation on a `for ... in` statement, or a `return` statement. I see this the same as the difference between def squared(x): ans = x*x return ans and def square(x): return x*x Of course at some point you would break it into two lines. It's just that putting one operation on the `for .. in` or `return` line, ass opposed to zero, is the most logical place to divide the operations into lines.
Where were you like 3 months ago lol?
Is it just me or has the frequency of homework questions actually _increased_ since the existence of this sticky thread?
Now if only I could get a silent install for pywin32 without having to build the MSI myself.
[Vim](http://www.vim.org)
Your last ELSE shouldnt have a condition. The phrase ELSE is a catch all. If the above IF conditions havent been met, then it will default to do whatever is in the ELSE
You can convert it to a wheel with: pip install wheel wheel convert &lt;filename&gt; and then install with pip. Or just use `easy_install &lt;filename&gt;` Or do you specifically need MSIs for some reason?
&gt; Or do you specifically need MSIs for some reason? Not particularly; as far as Windows installers go MSI tends to be better at handling silent installs because you can customize it with Orca. There are also a few DLL files that need to be copied during the installation, I'm not sure if pip can handle that. If it can, then using command line tools is always preferable.
Does anyone know if there is an archive or way at getting at older versions of these builds?
This seems a bit different from what I thought you were talking about. Do you know about virtualenv wrapper?
So it's easier to suggest a non-acceptable method than a complete method like `lxml` or `BeautifulSoup`? Wow, mentioning two - more acceptable - Python modules is so hard. /sarcasm
The problem with sites like this is they're routinely out of date &amp; also do not take into consideration changes in the ecosystem, for example mysql-python was deprecated years ago and is not actively developed since Oracle started shipping their own Python 3 compatible API; so this site gives the impression people can't move to Python 3 or they won't be able to connect to their MySQL database anymore, which is damned lies. 
A tuple is the most appropriate data type to represent a database row. If a row happens to have one column that's not a good reason to special case it and return a scalar value. It would be inconsistent behavior.
Can you explain a little bit more about what this is and why I should care? I'm not trying to be rude, I just don't know what it is.
 con.row_factory = sqlite3.Row Now you get Row objects instead of tuples, and you can use row[0] like always or row['column_name'] (case insensitive)
haha, this is just an updated list of github language color coding. The simple reason why i'm posting this is that i've seen a lot of outdated list around. This is an updated one, and the *short* parser is written in Python so i thought I'd share!
My attempts to install a new library follow the pattern: try conda, otherwise try pip, otherwise try Chris gohlke's page, otherwise look for the project's website or repo.
Try an ORM, for example http://www.sqlalchemy.org
Raymond Hettinger's answer here sums up my position and has informed how I use exceptions in Python (as well as his talks on other topics). http://stackoverflow.com/a/16138864 He's a core contributor to Python. Check out his examples linked to in the answer. Lots of cases for using exceptions for flow control. 
It's fixed for linux. ;)
I heard [PyInstaller](http://www.pyinstaller.org/) was a pretty solid option, given that your code is Python 2.x and not Python 3. It provides installers for Windows, Linux and Mac OS X.
You're a beautiful human being. Idk why when I searched for it a while ago it seemed really complicated and convoluted.
I seriously wish Windows would get a damn package manager already. Cygwin and MSYS are mediocre at best. I can't fathom using Windows for serious dev work. Last time I tried, I spent 5 times longer getting dependencies up and running than anything else, and I never was able to get boost to compile. In Arch, it's sudo pacman -S boost, wait a minute or two, and done.
&gt;pyHook: Python wrapper for out-of-context input hooks in Windows &gt;The pyHook package provides callbacks for global mouse and keyboard events in Windows. Python applications register event handlers for user input events such as left mouse down, left mouse up, key down, etc. and set the keyboard and/or mouse hook. The underlying C library reports information like the time of the event, the name of the window in which the event occurred, the value of the event, any keyboard modifiers, etc. &gt;https://pypi.python.org/pypi/pyHook
It's also the data type that is consistent with database theory with regards to relational databases. Conceptually, the result from a relational database query is a set of tuples.
what?
Thank you, now I don't feel so dumb.
I'm also interested in a solution for this for Python and Java programs. So far, I haven't found anything better than one of these three: * cxfreeze or similar for compiling to native code (can be big or introduce errors) * some other wrapper which bundles python or the JRE (licensing issues here for redistributing) * having the end user install Python/Java themselves (installing Python and Java bring their own problems) So much time, effort, and documentation goes into programming solutions, and not enough is spent on packaging and distributing solutions.
[xlib](http://python-xlib.sourceforge.net/) and [example](http://pastebin.com/kVunB5h9)
There is [Chocolatey](https://chocolatey.org/)...
you need a specific version of visual studio that compiled the version of python you are running (vs2010 ithink), then you need to get all the deps for whatever you are compiling which is a pita, etc
The sad reality is that you shouldn't waste your time on Windows.
AFAIK py3wos is quite up-to-date, but I agree that it should have a third column listing alternative packages that work fine.
The sad reality is that we often have to, given the large number of users on Windows.
Dude, chill; the tinfoil is overheating your head. Last I checked, De Icaza didn't even work at RedHat (he's CTO at Xamarin), and anyway debates on RH's business model don't really belong to /r/python.
[metraon](http://www.reddit.com/user/metraon) is describing a scientific program. Already POSIX systems are dominant in science. This'll only grow. Why waste time on Windows when it is so hostile, particularly in science?
You probably read [the docs for row_factory](https://docs.python.org/2/library/sqlite3.html#sqlite3.Connection.row_factory) which explain how to do something like this manually, before having a near-footnote about how you shouldn't do it, and just use sqlite3.Row instead. [Way later in the docs for sqlite, it suggests using Row.](https://docs.python.org/2/library/sqlite3.html#accessing-columns-by-name-instead-of-by-index)
Yes, but there's a util in psycopg2 for postgres as well.
Well, that's not "falling back", that is basic custom-configuration. setuptools et al really should try to identify an existing valid compiler automatically.
Just like in Java, Python isn't going to reach into that string and inject the value of "i.somevariable" for you. Nor is SQLite able to reach back into Python and ask for it. That execute() call literally tells sqlite to insert "i.somevariable" and neither 'i' or 'somevariable' mean anything to the database. Look at the docs (https://docs.python.org/2/library/sqlite3.html) and specifically search for 'parameter substitution'. You can put the question mark in the string where you want the value to go, then put a tuple of values (eg. i.somevariable) after it. NB. A tuple with 1 value needs a comma at the end, like so: (i.somevariable,)
At a glance this appears to be what I want to do. Do you have a quick example of its usage somewhere?
I'm hating such a feature. The people providing the binaries are awesome, but it's shows clearly a lack in the Python infrastructure for windows, because we have to trust unknown sources. 
This is actually one of the few times in python where threads make more sense than separate processes. It sounds like these buttons are being clicked and then blocking while some external request happens, which is actually the perfect case for python threads.
Sometimes you have no choice, when you want to deliver a product based on python but the customer has Windows PC's only. 
Please point me towards the advanced python user, he seems to have been replaced with an amateur. 
The problem is numpy and matplotlib are huge libraries.
The funny thing is that the distribution on linux is a fucking nightmare that never ends. *Oh, here, let me just maintain some 12 packages for various distros, and various versions of each distro that come with xy library version*
Which are probably available in the repositories of their respective distributions. You could create a package that makes sure all dependencies are satisfied.
Thanks guys. 
Thanks for the tip, I'll check them out.
You've got several options. For Linux: (1) Use setuptools, setup.py and upload to pypi. (2) Create packages (deb, rpm, PKGBUILD) that describe dependencies and automates building and installation. (3) Put the source code somewhere and explain how to build from source. For OSX: Same way really. For packaging, make a brew formula.
For those looking for it, psycopg2 uses a `cursor_factory` argument to the connection or cursor function, you can give it [psycopg2.extras.DictCursor](http://initd.org/psycopg/docs/extras.html#dictionary-like-cursor) for a mapping-ish row, [psycopg2.extras.RealDictCursor](http://initd.org/psycopg/docs/extras.html#real-dictionary-cursor) for an actual dict row (no numeric index) or [psycopg2.extras.NamedTupleCursor](http://initd.org/psycopg/docs/extras.html#namedtuple-cursor) for named tuple rows. 
Don't worry about how you can get Python and JRE into the hands of your users. It's pointless because packages and installers for those already exist. Just tell people it's a dependency and that they should have it installed. 
Those are both popular packages that are in official repos for all the major distributions (this means they are well maintained). Just takes a simple $ pacman -S python-matplotlib, or equivalent command to install both.
This is why everyone is switching to web browser based apps, especially since html5 can almost support the same experience as a desktop application. 
Check out a video on YouTube from PyCon 2014 called [The Day of the EXE is Upon Us](https://www.youtube.com/watch?v=wsczq6j3_bA).
I've used py2exe and pyinstaller, the latter is much nicer to work with. For py2exe at least, there are a lot of ways to save space. Check out the wiki. Excluding modules you don't need, removing translations, compressing the binary, etc. It's trial and error to find what will work for you, but it makes a huge difference. I've gone from 20-25mb down to about 5-9. Still way bigger than I like, but that's the joys of working in python. I'll take ease of programming over compact binary any day. 100mb seems too big. Time to start debugging, figure out what's taking all that space. Could be extra python modules, could be tk. My first guess is that tk is including a lot of resource and language files. Good luck. 
I simply compared advantages and disadvantages of each approach and found that no use case of mine would be more practical using virtualenvs. And as said: I had two incompatibilities total with this approach, and both projects' authors responded to a bug report in days. I fixed one myself and got the fix pulled, the other was fixed by the author. Until the new version was in most repositories, I switched the package from a global install to a git submodule: `sys.path.insert(0, str(Path(__file__).parent / 'local_site')); import that_module` So don't be that smug and believe you know everything better.
So it just loops over all the backends until one is successful? What if some of those aren't trusted?
http://www.reddit.com/r/Python/comments/2hjcxz/xlwings_replace_excel_vba_with_python/ Is this what you're looking for?
nice link thanks
I will give it a shot ! Thanks!
How is this relevant to python, don't add spam to this section.
If you look at the actual files included, you'll probably see things like numpy and scipy are being included in the distribution. Get rid of them if you didn't use them. If you did use them, see if you can re-write the code you used. cx_Freeze has bdist_msi for example, which will compress the files slightly, but you'll have better luck looking into the included files and getting rid of what you didn't actually use. 
Thanks! I will read a little and give it a shot. The numpy library alone is 65 MB something must be off. I love python too, considering the time it took to make the program it still worth to make a few tries to compact it. 
I will try to export what I have to to flask. Perhaps it will save me time on the long run.
If I follow your code correctly it is due to your if statement using in: if 'import' in item: #do highlighting stuff The '''in''' tests whether the string "import" is contained within the item so these will all be true: "import" in "import...blahblahblah" "import" in "lalala...import" "import" in "lalala...import...blahblahblah" You probably want to check whether item equals "import", i.e. if 'import' == item: #do highlighting stuff Also, instead of hardcoding each keyword e.g. import, you would probably want to define a list of all keywords somewhere and do: keywords = ['import', 'if', 'else', 'end', 'del', ...] #defined somewhere and imported where needed if item in keywords: startIndex = totalIndex - len(item) #do higlighting stuff 
I'm looking for Python programmers...it's relevant to Python since we are Python shop that is doing big data analytics, definitely not spam. I remember when Reddit was friendly. :)
I use the heck outta his site and I share it almost on a daily basis. Never thought to post it up here. Always thought he should have a donation link for himself or his lab on this page. 
Wow... Honestly, I have googled this question many times in the past, never saw this solution. Google is still, sometimes, all about the wording. Thanks so much for posting the result and not just saying "google it." This helps me a lot on a project that has been on standby for a very long time +1 to u.
1. Check for the existence of a `g++.exe` on the system path. 2. There is no step 2.
There is also [PyMySQL](https://pypi.python.org/pypi/PyMySQL) which I used for a small utility application.
don't worry about some small errors. It's still a draft. It's the idea that counts.
backend is in settings , what do you mean by not trusted ?
&gt; is basically not suitable for game development as it currently stands. worldoftanks.com (Bigworld game engine is in Python, whole Clientside code of world of tanks is python, so both server and client side) www.eveonline.com (Most concurrent MMORPG Of all time, written in Stackless Python )
You could go about it by only importing the specific components from the libraries you're using (unless you are using the entire library). This should reduce the overall file size a fair bit.
World of Tanks , World of Warplanes , They are Very FPS intensive game with very good graphics , they are developed in Python. 
`3.` Because we don't need no linker! `4.` Oh, and headers don't actually matter, you don't need to know what headers you need for Windows, you can just pretend. `5.` Don't worry whether its 64 bit or not, just fudge it! `6.` Everyone knows you call the C++ compiler to get full C compatibility! `7. ` etc...
A kickstarted project for this would be cool! I'm curious though - as this is currently being written as part of a larger project which I'm hoping to turn into a business (https://landscape.io), would you still feel like the contribution is okay? Obviously pylint-django is and would be open source but I don't know how people would feel contributing to something which would end up improving a commercial product? On the other hand, that's probably true of all open source!
You are representing indexes as floating point numbers when they are really strings of the form: `"{0}.{1}".format( int(line), int(col) )` see: `http://effbot.org/tkinterbook/text.htm` I modified the callback to be called from importing the space key, and Instead of using a global count of the number of backspaces and the number of characters to compute the indexes, I created a callback that is called periodically that repaint the tagged colors. ... display = Text(root, height=30, width=50, wrap=WORD) display.pack(fill=BOTH, expand=True) display.focus() sh.display_tags(display) ... root = ... root.after(1000,sh.syntax_loop,display) def syntax_loop(display): display.tag_remove('orange','1.0',Tkinter.END) display.tag_remove('yellow','1.0',Tkinter.END) callback(display) # colorizes the syntax highlights display.after(1000,syntax_loop,display) def callback(display): line_no = 1 line_col = 0 START = '{0}.{1}'.format(line_no,line_col) END = Tkinter.END while True: idx = display.search('import',START,END) if idx == '': break found_line_no = int(idx.rsplit('.')[0]) found_line_col = int(idx.rsplit('.')[1]) mark_line_col = found_line_col + len('import') mark_index = "{0}.{1}".format(found_line_no, mark_line_col) display.tag_add('orange', idx, mark_index) START = mark_index END = Tkinter.END http://pastebin.com/yexCPMWV http://pastebin.com/pMjVVsKd I'm sure this is not an ideal approach for finding and marking the indexes, as there is a loop that will clear previously marked text, as well as having a short delay before the text is colored, but I feel this approach is better than having global variables storing the character counts and backspace counts. I suggest you modify this loop to iterate for text per line, and then keep track of 'dirty lines' and only clear those during the beginning of the loop. 
&gt; that's something python can only dream of currently. I think you've never even done a research on this , just blaming python all the way. Or living inside the cave? This is world of tanks, written in Python: And it is decompiled here! https://github.com/Omegaice/WOTDecompiled It have almost Battle Field level Graphics with Much more superior In-Game logic.
I suggest [pygoogle](https://code.google.com/p/pygoogle/) It is rather straightforward to use.
pygoogle would be great to get the results but then you need some sort of scraper. i have used [this](http://blog.miguelgrinberg.com/post/easy-web-scraping-with-python) article along with [this](http://www.gregreda.com/2013/03/03/web-scraping-101-with-python/) one. admittedly i don't have very much experience with scraping but i think this will work. EDIT:i made a VERY simple program that gets a search query from the user then scrapes the title of the first link on google, as well as giving the link. the download is [here](http://www.datafilehost.com/d/ceca5480) EDIT 2: i swear that code worked last night
Minecraft is in Python?? In PyPy??
Third Party Libraries aside, if you know the websites, get the data with urllib2.urlopen(URL).read() and then find the required data with a bit of splitting. The plus for this is if you distribute it there will never be any dependencies you can't package with it.
Do some research , Eve online and World Of Tanks are Really Graphic intensive games , and they run totally fine . They are python on both client and serverside. And they are not Indie Hobbie games , they are Award Winning , Multi-Million making games.
They both use python as a scripting language and are written in C++ Thats like saying chrome and firefox are written in javascript because they have a javascript runtime (ie. categorically untrue) (the decompiler decompiles game *content* not the game engine; but yes, Ill admit, python is a pretty good scripting language. its not suitable for building game *engines*)
This. I've done it, and scraping very frequently will get your IP blocked quickly. Pygoogle is the way.
I have had good experiences with PyInstaller.
we use a decorator at work for this
Sadly this GTK component causes a segfault if you are using Qt.
I mean, what if some of your backends are external OAuth providers. I'm not a Python person, so there might be something I'm not understanding here.
At a high level, I would suggest [requests](http://docs.python-requests.org/en/latest/) to fetch a page and then [beautifulsoup](http://www.crummy.com/software/BeautifulSoup/bs4/doc/) to parse it.
Hm, this sounds interesting, particularly the return - do you still have the code?
If you want people to use your program, telling them to go and install something they don't care about, making sure to get the right version, before installing your software, is not going to really entice them. On Linux, it's easy* to tell the computer about your dependencies, so that installing your package makes sure they're installed for the user. On Windows, that approach hasn't taken off. So you do need to worry about how your users get the runtime. (* Easy in principle. In practice, packaging for Linux is another kind of faff)
So what you want to say is , Facebook is written in C++ because of Chrome and Firefox is written In C++ and PHP is wirtten in C++ ? And Reddit is Written in C because , Python is Written in C? Think again. When you write python , do you care about a couple dozen of Standard Libraries written in C? When you use cPickle or cStringIO , in your Python Code , Will you Claim your app is written in C? Nobody claimed Python is good for Game Engines , But as long as we can use 3rdparty libraries that is written in C and Developer can just Use Python in his development life , without Touching C and Make a game that earns hundreds of Millions , its all good, and We can safely say Written in Python , using etc,etc,etc Libraries. There was a Developer talk on WoT Livestream , 1-2 years ago, Dev named Overlord explains that Entire In-Game, Client Side is written in Python , using BigWorld engine and Server Side is in BigWorld + Python , Numpy ,etc. Launcher is in Awesomium (Javascript + HTML) , In-Game UI (Maps , Buttons , etc) Written in Flash , Not even a single Line of C is touch , until 0.8.4 version , where they become successful enough and Bought out BigWorld engine for 45Millions . Then they start to modified Bigworld engine's C code. So ,starting as a no-name company from Russia to a Multi-Million gaming company , Using Python .
Yup, but Ⓘ did it for work so I can't share it without permission. Its not too hard to write yourself, just have the iterator yield a closure that shares a mutable data structure that can be used to flag completion. 
Do you mean that you won't get blocked with pygoogle? what would be the limit?
PyPy does with Pypy-STM , already working , just need a few more phase of development to faster than Python in single core.
 I support this, it's what we were taught in my web basics for geography class. You gotta figure out which CSS elements are what, but you can download browser plugins that will give you the CSS code for whatever you highlight.
Hey post author here! If you're looking for a quick TLDR for making HTTP requests in Production: * Account for DNS lookup failures * Set a connection and read timeout * Handle HTTP errors * Check that the response has the content type you expect * Limit the maximum response size * That callers can't abuse your system to make requests to private resources * Use SSL 
Boo, I didn't know about that =\. I wanted to call it, but unfortunately that name was taken by a similar, but less featureful module (https://pypi.python.org/pypi/retry/0.4.2).
Here ya go: import webbrowser for i in range(1, 100): print "READ THE GODDAMN SIDEBAR" webbrowser.open("http://www.reddit.com/r/learnpython")
Name one program that bundles JRE or Python with an executable on any operating system.
How many websites are you searching? I think all the big job search websites have APIs you could use with python. You could also make your own APIs for job websites with kimonolabs.com
by backend I mean the authentication backend concept in Django, which can be anything from LDAP to file flat file authentication. it is the developer who decides which backends should be enabled in system.
 import re help(re.findall)
Yeah, there's only so many short and relevant names. See also [go's bug #9](https://code.google.com/p/go/issues/detail?id=9).
 &gt;&gt;&gt; s = 'This is a sentence with a bunch of words. How can we count the number of words? How can we count the number of times the letter a appears? How can we count the number of times the word a appears?' &gt;&gt;&gt; words = s.split() &gt;&gt;&gt; len(words) 41 &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; Counter(s)['a'] 11 &gt;&gt;&gt; Counter(words)['a'] 4 
You should not use it then. Keep in mind that this is just authentication, not authorization. It just gives you an identity of some form. Restricting access to your data is a separate issue.
Friendly friendly. 
I want to search LinkedIn and then maybe a few other job sites. I didn't want to use the API approach because then I would have to spend a lot of time learning several different APIs right?
The data I'm talking about is a user's credentials. They should be parametrized by the backend type and only submitted to that one, not given up to each one until one works.
I saw that article this morning and bookmarked it. Seems like a good approach to combine pygoogle and beautiful soup as you are suggesting. 
How frequently? I would think that doing it once an hour wouldn't be too bad right? 
I'm a beginner at this too, but I think learning how to scrape several different websites would take longer than learning the APIs. Each of the websites probably formats their job postings differently, so you would have to write different python code for scraping the relevant information from the HTML for each website. Edit: here is a python interface for linkedin api. http://ozgur.github.io/python-linkedin/
If you need to scrape a lot of sites before parsing them, consider [scrapy](http://scrapy.org/). Gives you a nice framework, plus features to at least attempt not getting you blocked.
3 words, two links, one of which is example and it is even named "example". No idea how you managed to miss it :)
(Disclaimer; I am a core developer on Kivy) &gt; but I feel like there would be trade offs On this side, I think the two things people most often raise as issues are: - The APK size - Kivy packs the python interpreter and much of the stdlib, so the package size is about 6-7MB for a minimal application (double that on the device). If this is a problem, Kivy is not for you. - The non-native widgets - Kivy works by being a graphical framework of its own, with its own opengl widgets that work the same on every platform. There's some facility to use native (java or objc) widgets in limited ways, but it's not something you can really rely on, or something that kivy directly targets. Of course there are lots of other dislikes that I'm sure will come up if the thread gets popular, and these may be important to you, and you can find many of them in the numerous previous threads about kivy, but I think these are mostly more minor, more subjective, or more flexible/possible to work around. Personally, I like lots of things about kivy, but if I had to pick one it would be simply that I can use normal python libraries. This is particularly important to me because part of my interest is the belief that mobile development should be easier and more accessible than the java apis would make it - for instance, if I make a simple scientific demo, it's *cool* to throw up a quick mobile app with exactly the same code, in a way that would be totally impossible if I had to rewrite the backend in java. This is a domain not really addressed by the normal app model, and to which the ideal vision of a perfect app is tempered a great deal by the convenience of working with existing code from a very different domain. (This is just a direction of my own interest, people do make commercial apps etc. A nice example game that was just released recently is [Reduce](https://play.google.com/store/apps/details?id=org.knapps_apps.reduce) by another of the kivy core developers)
Can someone explain what a Markov chain is? I've seen them from time to time, but never really understood the what or why.. thanks in advance
You make a very good point. Developing a seperate parser for each site, even using Reg Expressons (which i am just learning) might end up being more difficult than simply learning a few APIs! 
a pytz for language codes... cool...
Didn't miss it, there is alot going on in that link. Need to sit down and digest it.
GNS3 :) ?
I don't want to be lazy, but typing out long paragraphs on my phone isn't my favorite pastime. Instead here is a link to a comment where I talk about my experience with kivy http://reddit.com/r/Python/comments/2czwff/what_gui_do_you_guys_use/cjlaz2h
This needs more work to strip out punctuation and different cases. For example, it will consider "words" as two separate words, since they will be represented in the list as "words." and "words?"
[Here's](http://erack.de/bookmarks/D.html#Language_Tags) a great collection with more info on language codes. It's from LibreOffice' Eike Rathke [article on BCP 47 support in LibreOffice](http://erack.org/blog/archives/30-LibreOffice-goes-BCP-47.html).
[ImageJ](http://imagej.nih.gov/ij/download.html) offers downloads with bundled Java. So does [CMapTools](http://cmap.ihmc.us/). [Sweet Home 3D](http://www.sweethome3d.com/download.jsp) is another example I just found. On the Python side, anything that uses cx_Freeze, PyInstaller, py2app or py2exe is bundling a copy of the Python interpreter, albeit not as an exe. Dropbox is probably the most prominent example. My own project, [Pynsist](http://pynsist.readthedocs.org/en/latest/), makes Windows installers that bundle a complete Python installer. And I'm not even counting projects that use Python as a scripting interface, like LibreOffice or Blender.
No, Minecraft with a Garbage Collector
hopefully they aren't doing any serious calculations with Pi = 3.145 either :) 
That's a non-trivial problem and it requires defining precisely what you mean by a word, which OP did not do. For example, if you just strip all punctuation then "its" and "it's" are considered the same word, even though they're semantically different. But if you ignore punctuation in the interior of a word and only remove it at the beginning and end, then you mishandle hyphenated phrases like "north-south border". Even really simple rules like "remove trailing commas" lead to problems, because sometimes you have an interior comma, like in the end of a quote: "Like this," he said. So, okay, remove all trailing punctuation. But that doesn't always do the right thing either (i.e., there are examples where it breaks, like the "i.e.," here that would be turned into "i.e".) Such a rule would also cause problems if I were to talk about Michael Jackson's pre-"Thriller" career, as it would strip the trailing double quote and cause 'pre-"Thriller' to be considered one word. You can go on and on. The rules are far from straightforward. I'd expect that you'd have to use a specialized library like NLTK if you wanted to do this properly. 
This is a pattern for Java only because in Java methods are not first class. Javascript uses callbacks. Qt implemented signals and slots.
This is fantastic. I started work a while back on a related goal, and gave up as it was vastly more complicated than I anticipated and I didn't have the time for the project. The world of languages and language codes is so complicated I have tremendous respect for anyone who can turn it into something programmable!
Looks like I was wrong. But I will say that the way packaging on Windows is handled is not ideal.
See here: http://matthew-brett.github.io/pydagogue/python_msvc.html
This is good stuff.
Nice article. There is a lot of things involved with HTTP and requests that aren't documented. This is a nice beginning.
Can you point to an example of how to do what you propose? Not being critical, just curious.
Not even close to too quick. You'll need yo be around 100 searches a second to get a ban. Don't forget that in computer time, a second is pretty slow.
Disclaimer: I am oversimplifying this. Basically, they're a way of modeling state machines when you don't actually know anything about the machine you're modeling (or even if it *is* a state machine). You make them by observing a large corpus of data. As an example: Let's say I want to construct a markov chain to create reddit usernames, and I'm doing so from the names in this thread. The 'states' are individual letters in the name, and the 'machine' is one that creates the entire name. You build up the chain from observation, so if you feed it my username, you end up with something like: [ -&gt; r with probability 1 r -&gt; e with probability 0.5 r -&gt; a with probability 0.5 a -&gt; ] with probability 1 e -&gt; o with probability 1 o -&gt; s with probability 1 t -&gt; r with probability 1 (I'm using `[` and `]` to denote the beginning and end states, respectively) Feeding it your name in addition to my name gives me: [ -&gt; r with probability 0.5 [ -&gt; l with probability 0.5 r -&gt; e with probability 0.5 r -&gt; a with probability 0.5 a -&gt; ] with probability 0.5 a -&gt; d with probability 0.5 e -&gt; o with probability 1 o -&gt; s with probability 1 s -&gt; t with probability 0.5 s -&gt; h with probability 0.5 t -&gt; r with probability 0.5 t -&gt; s with probability 0.5 l -&gt; i with probability 1 i -&gt; g with probability 1 g -&gt; h with probability 1 h-&gt; t with probability 0.5 h -&gt; a with probability 0.5 d -&gt; o with probability 1 o -&gt; w with probability 1 w -&gt; ] with probability 1 (I've lowercased your name to make the transition table easier) What can you use such a thing for? **Generation** As in [ginc's comment](https://www.reddit.com/r/Python/comments/2ife6d/pykov_a_tiny_python_module_on_finite_regular/cl2uq4t) above, you can walk through a chain like this and randomly generate something like what the model has seen. I'll manually walk through such generation: * We start at `[`, the 'begin' state, and chances are 50/50 where we transition next (either `r` or `l`). I'm flipping virtual coins to decide, so our next state is: `l` * `l` always transitions to `i` * `i` always transitions to `g` * `g` always transitions to `h` * We're at another point: 50/50 `h` transitions to `t` or `a`: coin says `t` * 50/50 that `t` transitions to `r` or `s`: coin says `r` * `r` can be `e` or `a`: we're going with `e` * `e` -&gt; `o` * `o` -&gt; `w` or `s`: `s` * `s` -&gt; `t` or `h`: `t` * `t` -&gt; `r` or `s`: `r` * `r` -&gt; `a` or `s`: `a` * `a` -&gt; `d` or `]`: `]` If you emit a letter every time you change state, you end up with `lightreostra`. Other valid things this particular machine can emit are `reostreostreostra`, `reow`, and `lightra`. /u/gindc's example had a transition table much larger than mine, with words as the states instead of letters, and you can see that it gets the gist of things but doesn't necessarily fully represent it. There are other applications, though: **Comparison** Suppose we had two different markov chains: One generated from reddit usernames, and one generated from github usernames. If you're given a new username, you can run it through both chains and see how likely it is that that particular chain generated the username. So it's not just silly text generation, you can also build classifiers using chains. Hope this helps! 
That looks really useful. But I can only assume the handling of Swiss German in the examples is intended as a joke? tag_match_score('de', 'gsw') should at elast return 50, maybe up to 90.
plot twist: gohlke has now installed a backdoor into all of your computers.
I made an app that takes your linked in data and searches craigslist for relevant jobs based on your info. It only took me about an hour or two to learn the linkedin API and it was pretty easy. (this is from my django/views.py code) Here is how i authenticated def linkedin_auth(request): code = request.GET.get('code') authentication = get_auth(linked_in=True) authentication.authorization_code = code token = authentication.get_access_token() application = linkedin.LinkedInApplication(token=token) if not LinkedinToken.objects.filter(user=request.user).exists(): l = LinkedinToken(user = request.user, token = token.access_token) l.save() else: return redirect('home') return redirect('home') And here is how i got data for example (keep in mind that i am parsing this against craigslist data so ignore those parts, cragslist data was just scraped normally, no API for that): def add_linkedin_data(request): l = LinkedinToken.objects.get(user=request.user) application = linkedin.LinkedInApplication(token=l.token) profile = application.get_profile() locations = [] professions = [] connections = application.get_connections()['values'] for x in connections: try: locations.append(x['location']['name']) except: pass c = Counter(locations) for x in connections: try: professions.append(x['industry']) except: pass p = Counter(professions) locations = dict(c) professions = dict(p) locations = {k:v for k, v in locations.items() if not str(v) == "1"} professions = {k:v for k, v in professions.items() if not str(v) == "1"} profile.update({'locations':locations}) profile.update({'professions':professions}) prof = application.get_profile(selectors=['skills', 'picture-url','educations','location']) skills = prof['skills']['values'] profile.update({'skills':skills}) profpic = prof['pictureUrl'] local = prof['location']['name'] profile.update({'connections':connections}) profile.update({'profilepic':profpic}) profile.update({'linked':'Linkedin Profile successfully connected!'}) if not request.session.has_key('craig'): craig_bucket = [x['skill']['name'] for x in skills] + [profile['headline']] cb = [] craig_job_search = [] for x in craig_bucket: a = x.split(" ") for i in a: if len(i) &gt; 1: cb.append(i.lower()) for x in job_categories.keys(): a = x.split(" ") for i in a: if len(i) &gt; 1: if i.lower() in cb: craig_job_search.append(job_categories[x]) region =california['san francisco bay area'] master = [] craig_job_search = craig_job_search[:4] for search in craig_job_search: posts = get_posts(region, search, limit=10) for x in posts: a = {'title':x.title,'location':x.location,"email":x.email,"link":x.link,"local":x.local,"location":x.location,"body_text":x.body_text} master.append(a) request.session['craig'] = master profile.update({'craig_jobs':request.session['craig']}) return profile #profile is a dict If you want the whole repo, just PM me
If it's a joke, it's not one that I'm intending to make. That data comes straight from the Unicode Consortium, and I found the asymmetry surprising enough to include it as an example. Here's one copy of the [original data](https://github.com/papandreou/node-cldr/blob/master/3rdparty/cldr/common/supplemental/languageInfo.xml), in the odd XML format that seems to be designed to be understood by the ICU library. According to this file, the matching value when `gsw` is desired and `de` is supported is 96, but there's no matching in the other direction except the final fallback rule of "yep these are both languages", which has a value of 1 in CLDR (and I made it 0 in langcodes). Now, this might be the kind of thing I'm trying to mitigate by checking if two languages have a common macrolanguage... but they don't list a macrolanguage for Swiss German. Based on my (limited) personal knowledge of the subject, I think the match value should be less than 90; mostly it's that I've seen a comic here on Reddit about how German speakers think they understand Swiss German when what they really understand is standard German in a Swiss accent, so I'd take that to mean they're not *mutually* intelligible. (The other language pairs with a match of 90 generally are. Maybe I should document that.) I agree it should be more like 50 than 0, but I can't find a data source that backs that up.
Are you able to post or vote on yaks? I think the base URL changed and I can't do anything other than read yaks in areas of my choice
Python 3.4.2 was scheduled to be released on October 6. See PEP 429, Python 3.4 Release Schedule, http://legacy.python.org/dev/peps/pep-0429/. Its release has been delayed a day or two due to the Windows build. See http://www.gossamer-threads.com/lists/python/dev/1162587.
&gt; https://www.youtube.com/watch?v=8SkdfdXWYaI This is indeed cool! 
Definitely try beautifulsoup4. Sentdex does a great series (Parsing/Scraping Websites: Python w/ Big Data,…: http://youtu.be/2fLAbqAHk-Q) but there are plenty on YouTube. Nathan Yau also uses beautifulsoup in his book "Visualize This" (but it's a few years old, so use bs4.) 
Trust that, if you are making requests in production, these issues will affect you. Nothing like cascading failures because you didn't set a reasonable timeout...
I never new attrgetter would do multi level sorting. Something new every day. 
The video is pretty funny and you may learn a lot of stuff, but for people who don't have time, the two solutions the speaker (Brandon Rhodes) mentions are: - compiling your code using [Nuitka](http://nuitka.net/) - compiling your code using [Cython](http://cython.org/) He did [some experiments available on his GitHub account.](https://github.com/brandon-rhodes/exe-from-python)
I'd like to also suggest Pyinstaller -- this has never failed me on Windows standalone applications...I create Windows executables within Win7 and Win8; no issues to report so far. 
Same here, I'd like to throw my support to Pyinstaller -- this has been the only solution that works we for me when compiling across different platforms. Something to consider...If your application uses different libraries/modules (which it likely will), be mindful that some modules are platform specific and should be imported/used with detecting the running platform (I used if statements according to the running platform). I hope this tip save you a bunch of time.
Are markov chains used as numeric classifiers by chance? Is this how language detection can be done?
Which python packages do these two imports come from: from pb.native.global_hotkey_manager import GlobalHotkeyManagerBase from pb.utils import Signal Google is failing me.
I'd rather use lxml and xpath or pyquery instead of beautifulsoup
I'm a fan of thin type faces, but I realized this site had gone a little far when I couldn't see the punctuation.
Ignore them, its plumbing.
Well, if you love python gamedev so much, be my guest, go and write a little game in python using 3rd-party libraries like SDL and pygame and report back how much fun it was and how easy it was when you had to create multiplatform distributions for it. ...because I've done that, and speaking from my own personal experience doing so, it was a fucking pain in the ass. So if you've had a different experience, by all means, I'd love to see a series of blog posts on how you did it. 
This is awesome. I've got a project where I have to deal with some normalization, but I've only really implemented a user-managed configuration, since I don't really need anything more extensive (but I'm going to in the near future). You save me the trouble of having to write a non-hacky feature, and for that I thank you! When I get around to implementing `langcodes` I'll be sure to drop some feedback. :)
There is a subreddit for it : https://www.reddit.com/r/vindinium/
Thanks for the feedback. I actually ended up re-titling the article to "A Python guide to handling HTTP request failures" after some suggestions on Twitter. Let me think if there is anyway to make things more scannable!
Tim Fowler's article on the Circuit Breaker Pattern is a good follow up to this: http://martinfowler.com/bliki/CircuitBreaker.html
Hi, from what you report I'd say that the class member you are calling (player.damage) is a method and not a plain attribute. You should call it with the player.damage() syntax. I'd suggest however to check why you have a method there and what is its effect. If you post some code perhaps I can help you understanding the matter.
 player.damage() instead of player.damage
I'd move SSL from the section "For Further Consideration" to "Errors Connecting to the Server". SSL verification should not be a "further consideration" but a fundamental part of the connection management procedure. Too many clients are busted and vulnerable because they do not take SSL validation seriously. We have to train people out of this and that requires putting SSL front and centre.
It has been released! See announcement here: http://code.activestate.com/lists/python-dev/132868/
Release announcement, with incorrect download link: http://code.activestate.com/lists/python-dev/132868/
[Issues fixed](https://docs.python.org/3.4/whatsnew/changelog.html#python-3-4-2)
Any suggestions how to improve the content ? Thanks
It probably won't get blocked. Raw queries definitely will as it looks spammy. The limit is 64 queries.
That will still probably get you blocked. They really don't like scripted access to search results.
http://bugs.python.org/issue21642 which is fixed in 3.4.2 is surprising, didn't know 0x1if 1 else 0 is a valid syntax in Python. Not sure I like it.
Good information! Thanks!
That's very cool!
The choice depends on the application you're going to write. For e.g. simple games like Angry Birds, Flappy Bird etc., Kivy is a very good option: - fast hardware-accelerated graphics, - very easy to get started (unlike raw OpenGL ES), - can write your own shaders when needed. For something more Office-ish, like a spreadsheet app or something with many forms to fill (e.g. CRM) Kivy more or less blows, because you will be implementing many things from scratch. Qt is much better option for these.
Take a look at Joblib https://pythonhosted.org/joblib/
I think I prefer the bug. I can just see someone using this to try to demonstrate how they understand the subtleties of Python syntax. But it would confuse anyone who looked at it.
Ipython parallel is another option. In my experience the multiprocessing module is easier, but ipython parallel allows you to distribute over multiple computers
Awesome, now we can be even further behind! /stuck on 2.7 for the foreseeable future
is it any where in the road map to unify python 2, 3 into a single one....or is it even possible 
Nope, 2 is only receiving security patches now.
They can't be unified. They behave fundamentally different in some very specific cases. E.g. strings.
If i may ask, is there any easy to install way to use kivy in Ubuntu? I have tried the vagrant image on Kivy's site and it runs very slow, and have been unable to run Kivy in Ubuntu 14.04 without issues. I was very excited about Kivy (dont wanna spend time learning Android development for a specific app I want to build), but i feel like its not a realistic option for Ubuntu users :(
What? But why would you do that? Edit: Downvotes but no responses? FFffff....
Why not improve [Babel's locale parsing](http://babel.pocoo.org/docs/api/core/#babel.core.Locale.parse) instead?
&gt; Downvotes but no responses? FFffff.... Well, your comment itself was criticizing without any reasons...
Yes. It's called Python 3.
As opposed to os.path.join("/etc", "init.d", "reboot"). It's just a little more readable and it's part of a larger module that treats paths like objects, and while I am not a fan the over-use of objects, this application honestly makes a lot of sense.
For people unhappy with the growing divide between 2 and 3: Nick Coghlan is working on hypothetical parenthesis-free function calling, which would make `print "Thing"` valid syntax again. It's minor, but it's something. http://bugs.python.org/issue18788
The link is to a ticket rejected a year ago. Is there any other information about this?
I don't know Django enough to know that this isn't prohibited by the framework, but I think an auth attempt request should carry information about the backend to attempt to auth against and only send the creds to that particular one.
Assuming you have the 'requests' module already installed (if not see https://pypi.python.org/pypi/requests/2.4.3 ): import requests ...&lt;code as given&gt;... getTime()
He mentions it in his Python 3 notes, which he's continuously updating (most recently, August 4th of this year). Ctrl-f for "Created a Patch" http://python-notes.curiousefficiency.org/en/latest/python3/questions_and_answers.html#is-python-3-more-convenient-than-python-2-in-every-respect
I'd much rather see the old print statement specifically brought back than Python getting infected with no-parenthesis calls.
I'm down with using objects to represent paths, but overloading division to join paths is just ugly, especially as it coerces strings to do its bidding. 
A more Pythonic solution might be: import requests def get_time(): r = requests.get('http://countdown.tfl.gov.uk/stopBoard/58984') json_result = r.json() all_stops = json_result['arrivals'] my_stops = [ ' '.join([x['routeName'], x['destination'], x['estimatedWait']]) for x in all_stops if x['isRealTime'] and x['destination'] == 'White City' ] print(my_stops) get_time() 
&gt; Nick Coghlan is working on hypothetical parenthesis-free function calling Like in Coffeescript? That would be so cool! If that ever becomes part of Python 3 it would probably be the thing that gets me to switch.
It seems to me that would still leave quite a lot of possibilities. If the number length is n digits, then a naive estimate would be 10*(n-1) possibilities assuming no other typos. Did you have any success narrowing down which package is yours?
I'm sorry I thought it was obvious. Overloading division to join paths is just ugly, especially as it coerces strings to do its bidding. 
Did this break for anyone else this morning? Doesn't work anymore.
It's a horrific abuse of operator overloading, but it's pretty convenient to use. I'd prefer if they used `+` for it, since that has the existing meaning of "join these together".
Blech. No way. Good riddance to the print statement, I say. There's not a single compelling reason for it to be a statement. It always comes down to "It's always been that way." It's a language wart, like old-style classes.
Hm, you thought what was wrong was obvious, despite the fact that clearly enough smart, knowledgeable people thought it was a good idea that they made it happen? Personally, I like it; I don't think its any different than adding strings or lists to concatenate or multiplying strings or lists to extend or using negative indices to mean "from the end"; they are all overloading specific operators to give them a new meaning in certain contexts. To me, that's very Pythonic, and seems esthetically similar to duck typing. Also, I didn't downvote you personally, I was simply pointing out why some people may have thought your comment was "not adding to the discussion".
This feels more like code cleanup to me; it's not an actual problem people run into on a daily basis.
IMHO a better cleanup would be to get rid of this "feature", but it seems the opportunity was missed in 3.x transition.
Yep. The "no whitespace needed anywhere unless it's ambiguous" rule is useless for alphanumeric tokens. Better to require spaces than to be unclear.
Well. Don't do this, ever: basedir + '/' + 'temp' + '/' + 'new + '/' + 'project1' [That will be horribly inefficient.](https://wiki.python.org/moin/PythonSpeed/PerformanceTips#String_Concatenation) Do this. '/'.join([basedir, 'temp', ...]) Or better yet os.path.join(...) And I'm really sorry, but in my mind, `'/'.join(mylist)` very clearly means "join this mylist of strings using / as a separator" whereas `var / "foo"` means divide var by the string "foo" which just fucks with me.
Your code is really bad and unpythonic, why would you write it like that? The complete hack with the .format and sleep alone is terrible.
Agreed. It's good to see things like PEP 476 making headway: http://legacy.python.org/dev/peps/pep-0476/ It makes changes which enable certificate verification by default on the standard lib HTTP clients.
Thank you!
Good catch ill update it now.
You clearly didn't read what boxzonk said. He basically said that parenthesis-free calling is worse than print statements.
Yeah, I said 90 because Norwegian and Danish (the examples given) aren't really mutually intelligible when spoken either, only when written. But I agree that 50 would probably be more accurate. Anyway I guess there's not much you can do about it if your data source doesn't agree if you want any consistency.. 
/ is a well-known path separator. many method/function names aren’t self-explanatory. “÷” means division, and “/” is already overloading for it. i think your argument is as flawed as “keyword arguments are confusing”, “arity overloading is confusing”, “multiple inheritance is confusing” the java school of “we don’t trust anyone with any tool because someone will abuse it”
 &gt;Understanding Dutch is easier than understanding Swiss German for High German speakers and readers, I reckon. Like anything in Germany that really depends on where you're from. For me as a Southern German it's much easier to understand (written and spoken) Swiss German than Dutch. But as I said above, if the sources don't agree there's not much to be done anyway.
You are needlessly renaming sleep to s which worsens readability, you are needlessly passing a float instead of an integer to it. You are needlessly using the sleep function in the string's format method just to avoid its return value with "{1}" later. You are using nested input calls which make them hard to read and figure out which line is executed first and where which value of the format gets inserted. Your last lambda, which is a function that just returns a constant string and seems really useless, takes a completely useless argument x which you just fill with an empty value so you are able to abuse lambdas later on. The in line 8 you abuse format again to create an anonymous function, which takes a function as a parameter which you later pass an anonymous function... or something. The code is just really confusing and unpythonic and it's really hard to figure out what's going on. Why you would think this is appropriate for a beginner I don't really know, and the "greats" use the dict's get method to specify a default value in case a key isn't found, not to do... whatever this is, sorry. This seems more like a result of a contest where the goal was to write the most confusing or obfuscated Python code.
no. `var ÷ "foo"` would mean that. `var / "foo"` means “apply the slash operator to `var` and `"foo"`.” too bad ASCII didn’t contain “÷”, but it seems we’re stuck with “*” and “/” for “×” and “÷”, since americans and microsoft can’t be bothered to include a third keyboard level.
overloading the slash to mean “division” is ugly. there is a division sign: “÷”
&gt; i think your argument is as flawed as “keyword arguments are confusing”, “arity overloading is confusing”, “multiple inheritance is confusing” Wow, nice strawman there, buddy. Sure, `/` is a well-known path separator (at least on Unix), but it's also a well-known mathematical operator, i.e. division. I could well make the argument that `/` is the moral equivalent of "split", i.e. components = "fields|separated|by|bars" / "|" # components = ["fields", "separated", "by", "bars"] To me, these two cases are equally "clear". I can also make the argument that `|` should split an array into equally-sized fragments, i.e. pieces = "foobar" / 2 # pieces = ["foo", "bar"] Or even into equally sized components of the given length: pieces = "foobar" / 2 # pieces = ["fo", "ob", "ar"] Or maybe that's a function better performed by the `%` operator? pieces = "foobar" % 2 # pieces = ["fo", "ob", "ar"] Like I said: operator overloading invariably relies on *convention* rather than *clarity*, because they are not readily understood by reading a local piece code (i.e. you have to look up what they do by reading *some other* piece of code). They represent an additional barrier to understanding. Sure, they have benefits of brevity and (sometimes, not often) correctness, but as the Zen of Python says: "Explicit is better than implicit". &gt; the java school of “we don’t trust anyone with any tool because someone will abuse it” Versus the C++ school of "Here's a trunk of half-assembled tools of varying quality and usefulness. Don't hurt yourself!"
What do '÷' and '×' have to do with any of this? I can see the advantages of this change, but let's play devil's advocate for a second: &gt; `var / "foo"` means “apply the slash operator to `var` and `"foo"`.” The operator represents a particular concept, e.g. `/` for division. Overloading it with the functionality of `os.path.join` isn't intuitive from the usage of the operator in other contexts. It's just more special cases, you need to remember, because it can't be deducted from the other contexts.
Thanks for the tip!
What do you mean by this? They are used in the example functions I am trying to understand.
virtualenv -h --system-site-packages Give the virtual environment access to the global site-packages. 
i know this is article has marketing for stuff airpair offers and reddit generally hates that. However, i really like that their example code is for a same site w/ the same functionality so you can do an A|B|C comparison and judge for yourself... (many of these articles are peppered with the users preferences , which generally makes for a blah read.)
This code conforms to all the guidelines set forth by Daniel Greenfeld in the 'that' module.
Yeah, mine broke sometime between 1010 am and 115 pm eastern time, not sure what's up, looking into it.
I've installed pyzmo and its deps, but I can't seem to make the sample script work. I've run it in terminal as root (normal user doesn't have enough permissions) and added some print statements to the different keys, but none of them are displaying. Is there something more I need other than python and evdev to make pyzmo work?
I think the base URL changed I found hack yak on github, I was going to see if that worked.
Does it fix some big secret security hole? Because I can't find release notes anywhere, and python.org is silent about it.
All your examples are made up. Except the “divide into equally sized chunks”, since this is the “divide” meaning of “/”. The meaning of operators is as much or little convention as the meaning of words in a language, so unless every function name of yours is a lengthy, self-documenting sentence, you're also relying on convention. What's `var.join(arg)`? Join var with arg, returning a new object? Modify var? Modify arg? Use which separator, if any? Maybe don't join those things, but treat var as a sequence to join with the separator arg? Or treat arg as a sequence to join with the separator var? Python's handling of this is uncommon and confuses quite some newcomers! You'll only understand it when you understand python's focus on protocols, I.e. that everything looking like a sequence should behave like one with minimal hassle.
I don't see anything wrong with your way of doing it. If it works, it works. fiedzia's information is good, but I assume that exposes all of the system's site-packages which may not be what you want.
on the time budget you have, i guess the best/most cost-effective way to go forward would be to leverage an existing API, similar to the startup you mentioned, Microsoft's Cortana or IBM Watson (remember the supercomputer that wiped the floor with Jeopardy champions? there's an API for it now!). In case you are not satisfied with that, or want to tinker yourself to gain better understanding/expertise, start with the NLTK book. It's not that scary; since you are an experienced dev and have a rough understanding of key concepts, you probably could get thru it in a month or two. To answer your specific question, there are 2 ways people go about building something like this: 1) top-down: build a grammar for your domain, which is doable since it's pretty limited in this case. It involves a bit of drudgery, but you have total control over your parser: if it misses an expression that you want to support, you can easily abstract that expression and add that to your grammar. The downside is that your resultant system is brittle, i.e. it can only support what you explicitly programmed it to support. required knowledge: context-free grammar and regular expression 2) bottom-up: this is where your typical NLP pipeline comes in. Given a text input, you'd tokenize it, then do POS-tagging on the tokens, then chunk the tagged-tokens into verb and noun phrases. You'd then have to parse these phrases into structured input for you calendar (again, you are probably going to have to create some regex rules to do this). You can do all this using off-the-shelf components; NLTK itself contains multiple POS-taggers and chunkers that you can invoke with simple function calls. This system will be a lot less brittle than the first approach, since it doesn't have the same dependence on pre-defined rules. However the downside of this is that your system will essentially become a black-box for you, unless you have at least a college-level understanding of machine learning and are willing/able to read research papers. required knowledge: basic NLP concepts, NLTK or equivalent libraries like Stanford CoreNLP. For your use case, I recommend the first approach. The second one is cooler by a mile, but it's a recipe for disappointment if you expect to build something on par with Siri/Cortana.
me too :(
Here's the ugly truth: the web development "community" and python's community have never been all that close. Python has some solid tools, but it will never represent the forefront of what is available in terms of frameworks. I use flask and django, and regularly feel like I'm working in a corner, or a ghetto.
There are just few xlib calls that do exactly hotkey binding. If you can't figure code out maybe programming is wrong trade for you.
&gt; All your examples are made up. Great observation! Spoiler alert: *everything* in language design is made up! It's incredible! Design by nature is a set of tradeoffs. In language design, one common tradeoff is between concision (difficulty in understanding) and verbosity (tedious boilerplate). Language designers differ in their opinions, of course, but in general, great languages arise when you only adopt concision and its inherent obfuscation if there is a great *payoff* in the end, i.e. the developer gains productivity. A good example of an obfuscated convention that pays off big time is the Python decorator pattern, e.g. `@contextmanager`. This is an obtuse, abstract, and difficult-to-understand convention that pays off big time, because you gain expressiveness and separation of concerns in your code. In the case of the `/` operator, the payoff is...what? I don't know. Did you suddenly become much more productive now that you have this feature? 
Let me know what you think! Also, if you have any complicated tox.ini please fire this at it and see what breaks, that'd be groovy.
I'm not asking you to explain ANYTHING to me. I just simply asked for a reference to where you are getting those imports from. I'd love to RTFM, I just need you to point me to the FM.
* Thanks for your input! What I'm trying to work on is a Tinder equivalent app. So as long as I can use an OAuth library, and there is a way to build a chat system, I'll be good. Why is the APK double on the device? 
&gt; Why is the APK double on the device? The APK is a zip file, that further contains a tar~~.gz~~ containing kivy's stuff. As I remember, the python interpreter can't (easily) dynamically load stuff from within that tar.gz, so we have to decompress it for a rough doubling of the size. There are some nuances about exactly what is possible or plausible, but that's basically the reason. Edit: tito has told me the internal bundle is not a tar.gz, but just a .tar.
That is why I prefer ruby for this types of things, just one framework (ofcourse there is always other options) and a community with the web as first class citizen.
Take a look for folks who work with Django, flask, webpy, pyramid or web2py. Those are python 'front-end' frameworks/libraries.
`print` changing from a statement to a function is one of the most trivial changes to Python 3. I doubt people aren't upgrading because of that in particular.
&gt; I'd rather see it as a general parenthesis-free function call mechanism than let print be a special snowflake. Why?
We would have to do a capture on a fucntioning app to see where the app is talking/what is being said. basically, reverse engineer their API
One must strike a balance. Here we have something that is a wide convention, which is to say "/" is the path separator, and we are surfacing it in a library. It's not really that problematic, nor do I think it will raise many issues. What I am more concerned with was that it was just added to the standard library without much vetting by the community. I would rather this be a sort of "sanctioned package" that could be used before we consider it canon.
I have. I'm also into manipulating data and bit of machine learning/NLP myself. Those things are still python (or Java depending on the situation). For initial data exploration, though, I've switched to bash. I view Bash as fundamentally a text-stream processing tool. Lot of my initial data exploration can be reduced to the stream model. In my experience, processing of columnar data (e.g., log files) renders itself naturally to analysis using bash tools. Simple pipelines of tools like 'cut', 'tr', 'sort', 'uniq' and of course 'sed' and 'awk' gets me through 70% of my exploration. For these initial tasks, Python feels like an extra layer between me and the data. Doing it in bash is just more 'natural'. Once I get past the initial level, Pythons in. 
It's a bit hard to figure out what you're asking just from that snippet - showing a bit more of your source code, or just giving more details of what you're intending with the code helps a lot for things like this. Calling a method of class A happens the same regardless of where you call it from - so long as you have an instance of class A, just do a.whateverMethod(). There's nothing special about being within a method of class B. From the message, my first guess would be that the wepDamage attribute on weapon is a method, in which case the problem is that you aren't actually calling it (you need to add the brackets). If this is the case, changing that line to: return weapon.wepDamage() + listAttrMod[self.Str - 1] should resolve it.
Hmm, I don't want to access everything. I have a whitelist and all the others should be inaccessible.
you have to pass the one of the classes instances into the other. for example: import random Class Weapons: def __init__(self, damage): self.damage = damage def attack_roll: return random.randrange(50,self.damage) Class Enemy: def __init__(self, name, type, attack, health): self.name = name self.type = type self.attack = attack self.health = health def damage(self, other): self.health -= other.attack_roll roger = Enemy("chuck", "ogre", 150, 300) battle_ax = Weapon(150) roger.damage(battle_ax) Now I wouldn't use this direct code for one because it's not really a good implementation of the classes and ~~for two the way I have the random number generator is bad (it will create a new instance of the random number generator every time you call attack_roll)~~ but it does illustrate the point of how to use methods inside other class instances. Edit: Correcting a few things Forgot some quotes random range gen is actually randrange() and was corrected about the multiple instances issue with the random number generator may have been thinking of a different language though can't remember which atm.
Ruby is in many ways crazy to me, but if someone wants a framework suggestion and they're open to working outside Python, I'm likely to point them to Rails, Sinatra or Jekyll rather than Django, Flask or Pelican.
Cool, I'm glad that it worked out reasonably easily for you. :)
This is a good point. It's a fairly similar project. The purpose of langcodes is to cover all of BCP 47, which I don't think babel does; and to not try to cover all the weird crap that locales can do, which I think babel does. (What language would "C.UTF-8" be?) Locales and languages aren't quite the same thing. The standards people have put a lot of effort into making them use the same symbols, though, so ideally there would be a codebase with complete support for both. Maybe some time later I'll see if babel is something I can contribute to. 
I know you think you are funny, but this isn't helping anyone and especially not a beginner asking a question.
Why should `print` be parenthesis-free? What's special about `print`? I mean, `open`'s kinda useful. Why can't we do `f = open "file.txt"`? Because there's no reason for print to be special. What does it do that makes it deserve no parenthesis?
&gt; The purpose of langcodes is to cover all of BCP 47, which I don't think babel does I'm not aware that it does, but I wouldn't find it outside of its purview. &gt; Locales and languages aren't quite the same thing. The standards people have put a lot of effort into making them use the same symbols It does a bit further than that, the LDML specifically builds on and extends BCP 47: http://cldr.unicode.org/index/bcp47-extension (with actual IETF-registered extension RFCs too). The Unicode language and locale identifiers are [directly lifted from BCP 47](http://www.unicode.org/reports/tr35/#BCP_47_Conformance) with a few restrictions (which can probably be ignored) and extensions. Incompatible tags are a subset of the grandfathered BCP47 tags.
We're talking about parenthesis-free function calls vs. statements (both of which imply no parenthesis). I'd rather see `print` in the form of a statement instead of allowing arbitrary functions to be called without parenthesis (like in Ruby or CoffeeScript) That said, I prefer `print` in the form of a function rather than either of those options.
What's interesting to me is that even though it's the most trivial, it's also the most immediately-breaking. For the most part, people doing only very basic string manipulation are unaffected by the Unicode changes, and many of the other changes (range-xrange, old-style classes, etc) are more subtle, and therefore more likely to still work (or break silently) on code being ported to Python 3. print is just a straight-up syntax incompatibility.
But again, why just print? Assuming we're talking about a very limited syntax (like, only the explicit name or dotted-name of a function can be called implicitly), why should print get special treatment? I wouldn't mind doing `number = input "Enter a number:"`, or `unrolled = list map(function, my_list)`.
The / for division is analogous with a fractional: 2/4 = 1/2 = 0.5
Using \b in a regexp to separate on word boundaries I get the following &gt;&gt;&gt; import re &gt;&gt;&gt; s = 'This is a sentence with a bunch of words. How can we count the number of words? How can we count the number of times the letter a appears? How can we count the number of times the word a appears?' &gt;&gt;&gt; all_words = re.findall(r'\b\w+\b', s) &gt;&gt;&gt; num_a = s.count('a') &gt;&gt;&gt; num_all_a_words = len(re.findall(r'\ba\b', s)) &gt;&gt;&gt; len(all_words) 41 &gt;&gt;&gt; num_a 11 &gt;&gt;&gt; num_all_a_words 4 &gt;&gt;&gt; 
So unpythonic next they'll want to overload % for string formatting.
Python 3 *is* gaining traction. 
I let the package manager worry about it. 
To see the reason why they didn't go for +, consider what happens if you accidentally use it with a string instead of a path: q = p / 'init.d' / 'reboot' # TypeError: unsupported operand type(s)... q = p + 'init.d' + 'reboot' # Now q is '/etcinit.dreboot' If it's the same operator, you get an incorrect result, and you don't find that until some time later when something tries to open the file. Then you have to work back through your code to work out where it went wrong. With an operator that doesn't work with strings, it's immediately an error if you try to use a string instead of a Path object. 
Kudos for admitting it. ;-) Yes, the state of packaging on Windows is far from ideal, but application developers have to live with that. There is [chocolatey](https://chocolatey.org/), a package manager for Windows, but it's aimed at developers, not end users.
Python is pretty good with parallel installations, especially if you use virtual environments. I usually compile mine because is use Centos based distros, which tend towards older versions of python that yum (the RH package manager) depends on.
Crazy in a good sense or a bad one?
You could use [pythonanywhere.com](http://www.pythonanywhere.com) to host the app for free. Then you could check it on your phone when out of the house.
I totally agree. This kind of thing is part of the reason I sort of hate Scala. Python does not to move in that direction (in my opinion).
Yeah I was thinking about deploying it on pythonanywhere or heroku but I want to add some functionality before I do that.
It really doesn't make sense to compare these frameworks like that. Each of them has a different purpose and/or mindset behind it. It's really not about small or large projects, all of them can handle any size. If at all I'd say that Django is more for CRUD sites while Flask is more for uncommon/non-trivial applications or APIs (yeah yeah DRF ... whatever). I can't say anything about Pyramid because I never used it.
[pyenv](https://github.com/yyuu/pyenv) if you are on OS X or Linux. And there is also [homebrew](http://brew.sh) just for OS X. I personally use homebrew because I don't need to test older Python versions. So I have Python 2.7.8 and Python 3.x. Updating them is as simple as brew upgrade. On Windows, Python 3 installs it into a separate folder. Then just modify your path to point to the new one.
Not silent exactly, no. https://docs.python.org/3.4/whatsnew/changelog.html#python-3-4-2
The thread seem fairly old, but I'd love if this was implemented. The lessened parenthesis usage in Haskell and CoffeeScript is wonderful. Easier to type and less wrist pain. The [dollar](http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign) ('$', roughly parenthesis-to-end-of-statement) syntax seem very helpful in making code cleaner.
Precedent is the only reason `print` should be special. It was like that for the first 15 years and people like and expect it. If they're going to threaten to do parenthesis-less function calling if we don't give them their `print` back, then they can have their `print` back. Like others, I don't have a problem with `print()`, I just really don't want Python to degrade into the mess that is CoffeeScript or, to a lesser extent, Ruby. Rules are important. Python is built on the philosophy that explicit is better than implicit. It's much easier to read code that is clearly delineated rather than rely on trying to guess whether what feels like a full-fledged heurestics engine will decide if you meant to call that as a function or not. Would it be great if Python could always tell exactly what I meant? Sure, that'd be great. It'd be great if I could make any program I wanted just by typing "make a program that does what I want". It'd be great if it would extract the idea from my mind so I didn't have to type it. But that's not the world we live in. We should let Python continue to be explicit and clear and allow CoffeeScript et al to continue in their experiment in clairvoyance.
Did you mean to reply to me? I'm arguing against parenthesis-free function calling and you're assuming I favor it. Either way, I don't think removing parenthesis improves readability. From my experiences with Ruby/CoffeeScript, it's easy to get confused when you have multiple arguments with multiple functions. 
I've been Python 3 almost exclusively for the last 3 years. Py3 had a rocky start, but it's time to give up on the 2.x branch. Most libraries are available for Py3 now.
This is my code import random #http://pythontutor.com/visualize.html#mode=edit class weapon: 'legendary weapon generator' def __init__(self,playerClass,lgd): # bug fixer self.StrBuff = 0 self.DexBuff = 0 self.WillBuff = 0 self.DamageBuff = 0 self.enemyAttr = 'blank' self.enemyDmgBuff = 0 # getting the type of weapon wep = ['spear','long sword','short sword','dagger','axe'] wepType = wep[random.randint(0,4)] wepType = str(wepType) self.wepType = wepType self.name = self.wepType # weapon attribute lists if lgd == 1: adjList = 'bane brave brutal courageous determined diligent discrete energetic faithful forceful gentle gruesome intellectual intelligent patient powerful practical quick-witted self-disciplined terrifying tough warmhearted weakness willing'.split() listAttrAdj = 'brave courageous determined diligent discrete energetic faithful forceful gentle intellectual intelligent patient powerful practical quick-witted self-disciplined tough warmhearted willing'.split() listStr = 'determined forceful powerful practical tough'.split() listDex = 'diligent discrete energetic gentle patient'.split() listWill = 'brave couragous faithful intellectual intelligent quick-witted self-disciplined warmheated willing'.split() listWeaponAdj = ['brutal','forceful','guesome','powerful','practical'] listEnemyAdj = ['bane','weakness'] listEnemyClass = ['theives','knights','hunters','brutes'] listEnemyAttr = ['stelth','armor','dexterity','strength'] # attribute generator variables adjSelector = random.randint(0,23) adj = adjList[adjSelector] enemySelector = random.randint (0,3) enemyClass = listEnemyClass[enemySelector] enemyAttr = listEnemyAttr[enemySelector] #weapon attribute generator if adj in listAttrAdj: if adj in listStr: self.StrBuff = 1 if adj in listDex: self.DexBuff = 1 if adj in listWill: self.WillBuff = 1 if adj in listWeaponAdj: self.DamageBuff = .15 if adj in listEnemyAdj: self.enemyAttr = enemyAttr self.enemyDmgBuff = .3 #middle selector if adj in listEnemyAdj: middle = " of " else: middle = " " first = '' #end selector if adj in listAttrAdj: end = playerClass if adj in listAttrAdj and adj in listWeaponAdj: end = wepType if adj in listEnemyAdj: end = enemyClass if adj in listAttrAdj and adj not in listWeaponAdj: first = wepType + ' of ' #name generator name = first + 'the ' + adj + middle + end name = str(name) self.name = name def wepDamage(self): if self.wepType == 'spear': damage = random.randint(4,6) if self.wepType == 'long sword': damage = random.randint(8,9) if self.wepType == 'short sword': damage = random.randint(5,7) if self.wepType == 'dagger': damage = random.randint(3,4) if self.wepType == 'axe': damage = random.randint(6,12) self.wepDamage = round(damage + damage * self.DamageBuff,0) class player: 'player information' def __init__(self,weapon,armor): #setting variables to 0 and adding data lists listAttrMod = [1,2,3,5,8,13,21] classStrBuff = 0 classWillBuff = 0 classDexBuff = 0 classHpBuff = 0 classArmorBuff = 0 #modifying palyer attribute points depending on class if playerClass == 'brute': classStrBuff = 2 if playerClass == 'battle mage': classWillBuff = 2 if playerClass == 'theif': classDexBuff = 2 if playerClass == 'knight': classHpBuff = 2 classArmorBuff = 1 self.Str = 3 + classStrBuff + weapon.StrBuff self.Dex = 3 + classDexBuff + weapon.DexBuff self.Will = 3 + classWillBuff + weapon.WillBuff self.Hpbuff = 3 + classHpBuff self.ArmorBuff = classArmorBuff def damage(self): listAttrMod = [1,2,3,5,8,13,21] return weapon.wepDamage() + listAttrMod[self.Str - 1] lgdTest = 1 playerClass = 'knight' wep1 = weapon(playerClass,0) playerWeapon = wep1 armor = 'leather' bob = player(playerWeapon,armor) test = weapon(playerClass,lgdTest) print(test.name) print (test.wepType) print ('str buff: ' + str(test.StrBuff)) print ('dex buff: ' + str(test.DexBuff)) print('will buff: ' + str(test.WillBuff)) print('enemyattr buff: ' + str(test.enemyAttr)) print('weapon damge buff: ' + str(test.DamageBuff)) print('weapon damage: ' + str(test.wepDamage())) print('Player STR :' + str(bob.Str)) print('Player DEX :' + str(bob.Dex)) print('Player Wil :' + str(bob.Will)) print('Player Damage :' + str(bob.damage())) 
I'm working on a CoffeeScript codebase right now and I hate it so much.
What happens when i have numbers in my path, like with directory trees made out of file hashes? Edit: ah should not be a problem... it evaluates l to r, so always a Path on the l and the operator uses repr on the r i guess.
Yeah, it came out of the blue really. I think it was agreed that existing mechanisms to do cross-platform path manipulation (os.sep etc) were a bit clunky and low-level, which they are; but the result is very underwhelming to me, it feels a bit too alien. And, it's now *another* way to do path manipulation, which makes it more confusing (especially when you go and work with bindings that might have their own conventions and mechanisms, like PyQt).
Aaron Swartz' own http://webpy.org/ http://www.aaronsw.com/weblog/rewritingreddit
You could use a game library, like PyGame or Pyglet. both support loading audio files, although the formats vary. 
Probably all implications of the word crazy. For example, it's *good crazy* how useful and elegant blocks are in comparison to similar constructs in every language I've used. It's crazy how much I want :symbols and implicit return values in Python. It's also *neutral crazy* that because everything is a method call, there wasn't really any obvious way to access instance variables with that dot-or-space syntax, so Ruby classes have all those accessors. IMO it's *bad crazy* that monkey patching is kind of the norm for Ruby. It's not really considered monkey patching when you open up the String class and add magic to it. This is great for writing magic frameworks, and really confusing when you're trying to figure out why the inclusion of some library has completely borked your code. I like Ruby a lot—it has great builtins for things that Python relegates to far off corners of its standard library, Ruby's C source is very readable and easy to understand, and Ruby's own syntax is pretty clean. OTOH, sorting through gems purported to accomplish some system task can feel like amateur hour. I don't like that there are synonymous aliases for methods like collect is to map, inject is to reduce and select is to detect. I find that confusing, but then I regularly use a language with crap like range and xrange and zip_longest and izip_longest.
Read "Cracking the Coding Interview." Practice doing the problems on a whiteboard. Don't do the problems on your computer, don't write them out on paper. Do them on a whiteboard and talk through them as if you're with an interviewer. It really helps.
I really like that syntax; I often use something like label = "A" if is_a_true() else "not A" The example given is a bit ridiculous, because `A if 1 else B` will always evaluate to `A`. 
Any input on what would make these frameworks more forefront?
Bash is definitely useful, but I would never write a bash program larger than 20 lines. If you're just doing simple text processing then it's often quicker to just use grep &amp; friends.
It is not about ternary operator (ternary operator is fine), this is about non-obligatory whitespaces. This was valid before the fix: num = 5 if 1 else 6 Surprisingly, this was also valid: num = 5if 1 else 6 The ticket was about making valid the following: num = 5 if 1else 6 num = 5if 1else 6 
Hey, stupid interview questions are coming: num0o0 = 0o1if 6else 0o0 num0x0 = 0o0if 0o0else 0o0if 0o0else 0o0if 0o0else 0o0if 0o0else 0o0 OOOOO = 0x0if num0o0 6else num0x0 
I've been using Python 3 for a bit at work and for a bunch of hobby projects. The unicode everywhere is what coaxed me to get off my butt and move. It's smoothed over some things that used to annoy the crap out of me.
Your Python3 flair suggests that you no longer have to deal with things like range vs xrange :-P 
Oh, sure, I guess I misinterpreted your comment; I thought when you said "didn't know 0x1if 1 else 0 is a valid syntax" meant you didn't know the general case `X if Y else Z` was valid syntax. My mistake!
Is there some reason we can't have print statements via From __past__ import print ?
Integration. It's so easy to make *anything* work with Rails that that's just hard to compete with. Also, for the web, the Ruby communties willingness to try new things has led to compelling advances in things like templates and asset generation. Sure there are sort-of Haml work-alikes for Python, but none of them are as consistent or easy to work with. Thirdly, much of the "Zen of Python" stuff gets in the way of pragmatic web programming. It offends me on an aesthetic level that many of my python web files contain more lines of basic imports than actual code. I know that sounds trite and derisive but it's *friction*. A lot of it feels like exactly the sort of ceremony I use Python to avoid. It feels like an impedence mis-match or something.
Umm, no? Virtualenvs make this a solved problem.
Sorry for the late. this example relies on [ThreadPoolExecutor](https://docs.python.org/3.4/library/concurrent.futures.html#threadpoolexecutor) import concurrent.futures class Button: def __init__ (self, id): self.id = id def click(self): print(self.id, "Click!") # List of buttons buttons = [Button(i) for i in range(100)] # The threads pool executor = concurrent.futures.ThreadPoolExecutor(max_workers=2) # Map the click method with the button list, thanks to explicit self argument :) executor.map(Button.click, buttons) # Automatically shutdown when done. executor.shutdown(False) # just for testing for i in range(100): print("main thread loop:",i) 
Basically just the number of web developers who work on the cutting edge who use the framework. It's like, when I look into Ruby frameworks I find people using the latest frontend frameworks, HTML5 APIs and CSS3. And when I look at the Python stuff, I find more modest and dated approaches. So it's not actually the frameworks themselves so much as the community of users.
I don't have any programming experience besides stuff I've written myself, but it seems like Coffeescript's biggest flaw is that it lets idiots write unreadable code. If everyone involved knows what they're doing and values readability, Coffeescript is just a really nice clean way to write Javascript without all the yucky syntax vomit.
My concern with `/` is not that it's *that* confusing, but that it's *not needed*. `os.path.join()` isn't that confusing.
Overloading `*` to repeat strings and arrays are on the *hairy edge* of acceptability to me—I can live with or without it—probably because it retains the sense of "multiplication" in math. The `repeat` function in `itertools` does something similar already, but doesn't concatenate arrays. Maybe something like a = "abc".repeat(3) # a = "abcabcabc" 
I sort of have an issue with list multiplication because I use numpy arrays. Numpy arrays have a concatenation method and multiplication actually multiplies the array. Array + an integer adds the value to the array. My biggest issue though is it doesn't follow linear algebra. However, both approaches are useful and as such I use both.
You've hit on another problem with operator overloading: operator overloading *overloading*, or, when the same operator gets overloaded twice, with two different meanings, but both meanings make complete sense in their own ways. I tend to steer well clear of operator overloading when possible, maybe with the exception of purely mathematical expressions, such as your example of matrix multiplication.
&gt; For these initial tasks, Python feels like an extra layer between me and the data. It shouldn't. If you do it in Python, you're doing it in a program written with Python. If you do it with cut, tr, sort, etc., you're doing it in (multiple) programs written in C and then stitching them all together with another scripting language (bash scripting language).
Strictly Python. Bash hates stuff like spaces in filenames and in other text input, while Python does not have that problem. Plus, it takes me longer to remember how to do something in Bash than to just do it in Python.
You should put it in a pastebin and provide the URL here for something that complicated.
&gt; Here's the ugly truth: the web development "community" and python's community have never been all that close. Says who?
Me, that's who. You're welcome to prove me wrong—I'd love to find all the Pythonista web developers working on the cutting edge.
Most cross platform systems will be using a GStreamer, VLC, MPlayer, FFMPEG, or similar for the low level stuff. If you want something a bit higher level you can use [PyQT](http://pyqt.sourceforge.net/Docs/PyQt4/phonon-videoplayer.html), [wxPython](http://www.blog.pythonlibrary.org/2010/07/24/wxpython-creating-a-simple-media-player/), or similar.
Wikipedia ?
The main problem is it wouldn't help. `__future__` imports are great because the actual "future" versions that have the feature on by default can just ignore them. But you can't go back and make old versions of Python deal with `__past__` imports.
Two good links: http://en.wikipedia.org/wiki/Big_O_notation and http://web.mit.edu/16.070/www/lecture/big_o.pdf I haven't "personally used" either (I learned the material from books), but I recommend both.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Big O notation**](https://en.wikipedia.org/wiki/Big%20O%20notation): [](#sfw) --- &gt;In [mathematics](https://en.wikipedia.org/wiki/Mathematics), __big O notation__ describes the [limiting behavior](https://en.wikipedia.org/wiki/Asymptotic_analysis) of a [function](https://en.wikipedia.org/wiki/Function_(mathematics\)) when the argument tends towards a particular value or infinity, usually in terms of simpler functions. It is a member of a larger family of notations that is called __Landau notation__, __Bachmann–Landau notation__ (after [Edmund Landau](https://en.wikipedia.org/wiki/Edmund_Landau) and [Paul Bachmann](https://en.wikipedia.org/wiki/Paul_Gustav_Heinrich_Bachmann)), or __asymptotic notation__. In [computer science](https://en.wikipedia.org/wiki/Computer_science), big O notation is used to [classify algorithms](https://en.wikipedia.org/wiki/Computational_complexity_theory) by how they respond (*e.g.,* in their processing time or working space requirements) to changes in input size. In [analytic number theory](https://en.wikipedia.org/wiki/Analytic_number_theory), it is used to estimate the "error committed" while replacing the asymptotic size, or asymptotic mean size, of an [arithmetical function](https://en.wikipedia.org/wiki/Arithmetic_function), by the value, or mean value, it takes at a large finite argument. A famous example is the problem of estimating the remainder term in the [prime number theorem](https://en.wikipedia.org/wiki/Prime_number_theorem). &gt;==== &gt;[**Image**](https://i.imgur.com/LjjENES.png) [^(i)](https://commons.wikimedia.org/wiki/File:Big-O-notation.png) - *Example of Big O notation: f\(x\) ∈ O\(g\(x\)\) as there exists c &gt; 0 \(e.g., c = 1\) and x0 \(e.g., x0 = 5\) such that f\(x\) &lt; cg\(x\) whenever x &gt; x0.* --- ^Interesting: [^Big ^O ^in ^probability ^notation](https://en.wikipedia.org/wiki/Big_O_in_probability_notation) ^| [^Computational ^complexity ^theory](https://en.wikipedia.org/wiki/Computational_complexity_theory) ^| [^Analysis ^of ^algorithms](https://en.wikipedia.org/wiki/Analysis_of_algorithms) ^| [^Algorithm](https://en.wikipedia.org/wiki/Algorithm) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl4jgef) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl4jgef)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I compile my own python with prefix=$HOME/local and have multiple python versions installed. 'python' always points to the latest 3x. I use pyvenv/virtialenv for all my projects and libraries, so nothing needs upgrading or reinstalling.
I always enjoy these sorts of things in a "losing is fun" sort of way. I usually get one or two of the quirks while missing one. Like I got the quirks of puzzler 3 right, but I though the answer should be [4]*5, not [13]*5 because "should" be x=3, and "should" be y=4, but `points` isn't reversed in the definition of `rev_points` is never actually reversed.
Is it time to switch to 3? Have all the popular modules caught up? 
You just didn't add 4 spaces in front of every line. No need to blame Reddit, buddy.
Note: you can fix your formatting by indenting the whole thing 4 spaces. Reddit will then treat it as code, and stop applying its formatting. (You can do the same thing inline by enclosing it with backticks ("\`"). Eg. \`\_\_init\_\_\` will print `__init__`, while without them, you'd end up with reddit treating the `_` as bolding and get __init__.) Anyway, on to the code: Part of the problem is the one I mentioned, of missing brackets then (your wepDamage function), though I see you've corrected this. However, presumably you're now getting a different error, about "unbound method wepDamage()" being called. The reason for this is that you need an instance of the weapon object to actually call it on. In your damage() function you are calling "return weapon.wepDamage() + ..." but there's no "weapon" object passed in, so what it is actually finding is the *class* itself (incidentally, as a convention, classes are usually named with an upper case first letter to distinguish them from instances etc - it can be a bit confusing when the class is called "weapon", but you're also using an instance of it also called "weapon", and you'll get confusing errors like the one you saw). Presumably the weapon object you want to use is the same object you pass in to the `__init__` of your player class. However, you're not actually storing this off. What you'll need to do is add the line: self.weapon = weapon to this `__init__` method, and then in your damage function, change the last line to: return self.weapon.wepDamage() + listAttrMod[self.Str - 1] However, you'll then run into another problem, in that your wepDamage function isn't actually returning the damage. Instead, it's doing: self.wepDamage = round(damage + damage * self.DamageBuff,0) This probably isn't what you want to do - instead, it's overwriting the method with the integer object the first time you call it, and then returning nothing. You should probably change this line to: return round(damage + damage * self.DamageBuff,0) Hopefully this should get you further. PS: in future, you'd be better to post questions like these to the /r/learnpython subreddit, which is geared more towards such things, rather than /r/python.
I just think CoffeeScript is way too extreme and tries to be all things to all people. It doesn't just choose one or two not-that-harmful ways to simplify the syntax, it tries to throw in everything. In the codebase I'm on, nothing is obvious or consistent. Sometimes things are controlled by indentation (and there's no sanity checks on this like there is for Python; we often end up with accidentally-nested functions because a line has a stray extra space in it) and sometimes just by parenthesis to evaluate as an individual statement (but only rarely braces), almost never uses parenthesis for function calls and also extensively utilizes argument splats followed by fixed-position arguments, doesn't use any braces around dictionary/hash-type objects and the only way to differentiate a hash being passed to a function is whether or not commas are between parameters, which is confusing because it's so spastic (often see something like `func a, b: hi, c: bye d: why e: guy, f, etc` which in practice will usually be written on several indentation-sensitive lines), alternates between fat and skinny arrows without much regard for the actual purpose, and so forth. The project is very fragile due to all of this and it's hard to tell what you're supposed to do where; you just end up learning what works by habit. All of that ambiguity just to save a few keystrokes is unnecessary and results in a great deal more mental effort and concern over whether something is going to work. I dislike Ruby's syntax for similar reasons but even it is much more sane than CoffeeScript. There's probably room for a DecafScript which tries to implement some basic improvements and syntactical conveniences without going overboard and laughing maniacally on the way down like CoffeeScript does.
You can do (effectively) this with anaconda. If you make a conda environment and then install something (using conda) that exists in the root environment conda will link to the root installation instead of duplicating it.
Any imports from pb.* are from my custom application, its just a frontend not containing any functionality.
Well, a recursive function doesn't seems to be such a great idea: &gt;&gt;&gt; qs(range(1000)) File "&lt;stdin&gt;", line 4, in qs […] (skiping tons of lines) File "&lt;stdin&gt;", line 4, in qs RuntimeError: maximum recursion depth exceeded Same goes for copying lists over and over. By adding a few 0s I can see my memory being exhausted very quickly before crashing hard. I would definitely recommend this code for education purposes, maybe as an example of "never do that" in a program optimization lesson.
&gt; I would rather this be a sort of "sanctioned package" that could be used before we consider it canon. Well, at least it's not an entirely original research, plumbum [does that as well](http://plumbum.readthedocs.org/en/latest/local_machine.html#local-paths).
You can do TimSort in one line.........
There is a C library [portaudio](http://www.portaudio.com/) which allows you to do crossplatform audio. [PyAudio](http://people.csail.mit.edu/hubert/pyaudio/) is a Python wrapper on top of it. Unfortunately the last time I checked it it only supported blocked playback. Depends on your application if you need to do something while playing back. But there is [pyo](http://ajaxsoundstudio.com/software/pyo/) which is an audio signal processing package but can also just playback or record cross-platform. It also uses the portaudio but has the non blocking feature. You only have to decide which audio server you need to use depending on the platform ASIO, Jack, Coreaudio etc. **tl;dr** Use [pyo](http://ajaxsoundstudio.com/software/pyo/) its easy.
Nothing against building it yourself, but if you're already using pandas you could just use its power to group by hour and the nicer looking .hist() That what pandas was made for. 
What about Google App Engine?
Mechanize did not appear to be maintained too actively when i was using it. Nevertheless its great lib. I bet maintainer would appreciate any help he can get so **thumbs-up** for your dedication if you decide to go for it.
Quicksort's O(n-squared) worst-case behaviour is well known. You can generally get round this by selecting an element at random to be the pivot: def qs(a): if not a: return a pivot = a.pop(random.randint(0,len(a)-1)) return qs([i for i in a if i &lt; pivot]) + [pivot] + qs([i for i in a if i &gt;= pivot]) I guess that's really five lines as you need to import random. Your example takes about 8ms or less on my machine.
The functionality seems very limited. It does not actually have any protocol handlers at all. There is a 3rd party aiohttp program for http but I found it was harder to use than twisted, did not behave as expected, and had minimal documentation. I also find "yield from" makes the code hard to understand and difficult to debug. That said I tried porting a twisted app to python3 using the parts of twisted that have been tested for python3. However this was not straightforward due to the unicode issue. It seems to work in strings so you have to put a b in front of every string.....
Have you seen httpie?: * https://github.com/jakubroztocil/httpie
Definitely with you there, grep/sort/etc, are hard to match for speed - IPython seems to bridge the two fairly well with it's magic commands though.
I'd already started when I posted this. I should get it up and running in the next 12-14 hours :-D 
+1 for bash to python. I do most stuff in python now, but if what I'm doing is solely a series of commands, I'd rather use bash than have a bunch of subprocess calls.
True that :-) and it's a great package, to be fair. But since we're all for progress here and Python 3 iis the foreseeable future, I feel it's only logical that all the good projects associated with it should be updated parallely atleast in terms of compatibility if not in terms of improved features :-) 
My idea is to create services that follow command-line paradigm (pass command with arguments and get human-friendly response or explaination for an error), rather then deal directly with http. This gives much friendlier and - what's more important - unified interface. Also you'll get service discovery (ie. ws --search "image conversion"), help (ws service help, ws service help some_command). 
Thank you for the reply. I am going to delete this post and follow your advice.
rekt edit: I feel like I missed a big opportunity here. Let's pretend like this is what I posted- def isRekt(): return True
I have tried this example class X: x = 7 class Y: def __init__(self): self.y = 7 y = Y() In [4]: %timeit X.x 1000000 loops, best of 3: 205 ns per loop In [5]: %timeit y.y 1000000 loops, best of 3: 201 ns per loop So there are 4 nano seconds difference between the two approaches. I would say those 4 nano seconds are the least of my concern when deciding a design strategy EDIT: Corrected a mistake self.y = 7 instead of y = 7
Owned!
 from httplib import HTTPResponse def X(HTTPResponse): x = 7 def Y(HTTPResponse): def __init__(self): y = 7 y = Y() In [4]: %timeit X.x 1000000 loops, best of 3: 205 ns per loop In [5]: %timeit y.y 10000000 loops, best of 3: 198 ns per loop But when trying it with multiple inheritance class X(HTTPResponse, list): x = 7 class Y(HTTPResponse, list): def __init__(self): self.y = 7 y = Y() In [16]: %timeit X.x 1000000 loops, best of 3: 275 ns per loop In [17]: %timeit y.y 1000000 loops, best of 3: 434 ns per loop EDIT: All Tests were done on python 2.7
Stack overflow link: http://stackoverflow.com/a/2714590/382749
That's one of the reasons I love programming. I remember when my friends and I were still learning the basics, everytime we needed to learn an algorithm, we would just google it and you could find a lecture about it by the guy that came up with it, while in maths, it's a rare occasion if you can find a photo of the guy. In most cases cameras weren't a thing back then.
How often are your singleton classes performance-sensitive? In my experience that's really, really rare. That just doesn't seem like good advice to me.
"google" is not a verb. Otherwise you're right, with these new, still developing languages connecting with the author is quite common.
Never do something for the sake of speed, to the detriment of readability and maintainability, unless you have a damn good reason for doing it.
Assistance is futile.
You're about 16 years too late for that one, mate.
i've been thinking about this for a while actually since going from pyramid to rails. something similar to asset pipeline would be handy database migrations generators for models/controllers/etc.... a cli to bring it all together like rake for generators the problem is, in order to do that, you have to have opinions on how controllers/views/models are . don't know if I want pyramid to be more opinionated. I like my opinions. :) for the asset pipeline I'm happy with the workflow I ended up with for pyramid_angularjs using grunt and then supervisord to run both. I know someone else has been doing something similar. db migrations again are a challenge without having opinions about how things should be named etc..... alembic works but you have to mess with it more then what I typically have had to do in the rails apps I've had to work on. Things like mode named User corresponds to table users primary key is called id etc..... i just can't imagine this being a thing pyramid would want to do. Turbogears however, I would expect that to be the case. I'll jump on irc and we can toss ideas around if you like. 
Poor Davin.
http://www.merriam-webster.com/dictionary/google
Extremely relevant scene from Woody Allen's *Annie Hall*: http://youtu.be/OpIYz8tfGjY?t=1m57s I love that in niche forums, you never know who's watching.
Not to insult well-versed folks like Alex, but I kind of wonder about people with such high reps. Like...do they have lives? If you look at his history, he's basically on SO 24/7. I think I'd be a few steps away from suicide if that's all my life was.
Too good! Just got owned ^^
&gt;"google" is not a verb. Yes it is. &gt;Definition of GOOGLE transitive verb : to use the Google search engine to obtain information about (as a person) on the World Wide Web Source: [Merriam Webster](http://www.merriam-webster.com/dictionary/google)
In my days, it was rebuked
For Johnny Foreigner here that doesn't get it: "rekt" ≈ "wrecked". Took me a while.
i remember those days.
As far as I'm concerned, anyone with 100k+ rep on stack overflow is a wizard. 
Alex stopped posting on SO 4 years ago. He has definitely contributed to teaching many thousands of python programmers via his posts.
What does `self._dict_` do?
 self_is_rekt()
How about '{routeName} {destination} {estimatedWait}'.format(**x)
I don't know if it always works, but you can try. Example: &gt;&gt;&gt; import PySide &gt;&gt;&gt; PySide.__file__ '/usr/lib/python2.7/dist-packages/PySide/__init__.pyc' So here the directory to symlink is `/usr/lib/python2.7/dist-packages/PySide`. Thanks for your project, I will check it out.
I don't think I've ever encountered a scenario where I needed a pipe and couldn't do it a Pythonic way. Of course something like ps -ax | grep smbd I'd do in Bash. But I never have occasion to chain commands together otherwise except in complex situations where Python can do all the same stuff anyway. I actually made the effort to do something in Bash (run some Oracle scripts and process the output), but found it way easier in the end to write a Pythonic way instead. It's just that anything Bash can do, Python can usually do, and I'm already way faster in Python.
In my days, it was castigated.
Except, in this case, there is no downside to readability or maintainability. In fact, from a maintainability point of view, using per-instance variables is almost always preferable to using per-class variables.
He had it comming.
rekt e k t
Reminds me of Whitfield Diffie being questioned about PKI during the [Newegg Trial](http://arstechnica.com/tech-policy/2013/11/newegg-trial-crypto-legend-diffie-takes-the-stand-to-knock-out-patent/). &gt; "We've heard a good bit in this courtroom about public key encryption," said Albright. "Are you familiar with that?" &gt; &gt; "Yes, I am," said Diffie, in what surely qualified as the biggest understatement of the trial. &gt; &gt; "And how is it that you're familiar with public key encryption?" &gt; &gt; "I invented it." Edit: Should spell his name right, eh? Edit2: I get it now. The lawyer was doing his job and establishing Diffie's credentials, not asking idiotic questions. Thanks for setting me straight, gang.
Depends of the context. For example let say that a Java developer wants to give python a try, and they start with a simple hello world: print "hello world" compared to: public class HelloWolrd { public static void main (String[] args) { Syntem.out.println("hello world") } } Is there something more impressive for the developer? 
&gt; I would say those 4 nano seconds are the least of my concern Not when you're google! 
Really? You didn't get any results on Google when you [searched](https://www.google.com/search?q=python+string+length) for "Python string length"?
The difference is not in the lookup of `X.x` vs `Y().y` but `X().x` vs `Y().y` because `Y().y` is resolved on the first lookup (as it is an instance variable) but `X().x` takes two lookups (as it has to fail to find `x` on the instance before looking at the class)
Ouch.
 It reminds me of when the [SR-71 pilot radioed or a ground speed check](http://www.strategypage.com/humor/articles/funny_flight_stories.asp) to one-up the fighter jet pilot.
How did the appeal go, or when is it scheduled? I still find it ridiculous that Newegg lost.
And if you go to Wikipedia you can usually read about an algorithm in plain English, you will often see an animated example of it, and you leave with a good understanding. If you go to a Wikipedia entry on a math subject and you have anything less than a PhD and years of postdoc experience in that exact subject, you are lucky if you leave with anything less than a migraine.
Install Anaconda or Miniconda, and updating your python becomes trivial.
What's doubly funny is that Alex Martelli is the author of *Python in a Nutshell.*
Ah thanx!, sorry that may have been a really stupid question but i am not that familiar with all the terms yet, so i didn't think of string as the value for the amount of letters in the word haha thax though ;P
I honestly had no knowledge of the case before that article, and haven't kept up with it since then. I mostly remember it because of the ridiculousness of the line of questioning posed to Dr. Diffie, and for the hilarious looks when I shared it with my friends who work at a security company providing PKI services to their clients.
When you are sure you will only ever need one instance of something, we call that a module.
Although it doesn't seem to find the length of the text the person has typed in... it only reads a line that has already been printed..
And his books!
And one of the authors of the Python Cookbook!
Well, Newegg lost and was ordered to pay $2.3 million (around half of what the patent troll wanted); as of 26 Nov 2013 they were appealing the decision. East Texas jurors are silly people.
The post was talking about single instance member vs static class member. 
If 4 nano seconds are such a big deal to a project you make I would strongly recommend against python. C or C++ would be better in that particular use case. But if you are also concerned about maintainability and development time I would still recommend a static class member and sacrifice the 4 nano seconds
&gt; Whitfield Diffie 
&gt; **Most** That's the keyword here.
 containing the elements of a that occur exactly once. For full marks, elements should appear in the same order as their first occurrence in a
So lets see if I understand correctly: `self._dict_`holds `self.variable1 self.variable2`, and whenever you call a `self.variable` it looks it up in `self._dict_`. And the borg pattern they talk about binds that dict to a class variable, so all instances are referencing the same attributes. Whats the point of having multiple instances if they are sharing all the same attributes?
or more importantly, read this: https://docs.python.org/2/library/functions.html#len
/r/learnpython
That Alex Martelli guy is always stealing my sweet sweet Stack Overflow rep. How many times I've been 90% done answering a question and I see "A new answer has been posted"
Yeah fair point
That's the point of the Borg pattern. There's only going to be one instance.
I think this is more impressive: print("hello world") (py2/py3 joke) 
just did thanks.
well i am using Kali Linux to do my writing in because i wasn't able to attach python to my cmd... it is weird because i copied the code exactly exept i can't type " on the linux box... only '(space)'
 #2 is what I'd like to go for, if anything just to satisfy my own curiosity (at least until I hit a steeper learning curve than I'm willing to tackle). I've jumped around different topics the NLTK book a bit but it sounds like I need to read each chapter consecutively. So far I've been successfully able to write code that tags a sentence and chunks it into a grammar tree (S -&gt; NP VP). I'm currently working through Chapter 6 (Learning to classify text), which I believe is where you get into the machine learning portion. I think the machine learning part is the one I have the least experience with. I'm ok with the idea of a "black box". As long as I have a set of phrases that I can continuously test, and further train the system to improve it, I think I should be OK. 
The Python 3 way is backwards compatible to at least 2.7 (I don't know about older versions, don't care). It's not a joke, it's a good tip. 
So we're doing your homework for you?
You need to read the [Python Unicode HOWTO](https://docs.python.org/2/howto/unicode.html) right now before you hurt something. Even for your Python 2 code. *Especially* for your Python 2 code. You're getting errors in Python 3 because your Python 2 code was corrupting all the non-ASCII text it encounters. Sweeping the error under the rug by turning your string literals into byte literals is not going to fix your problem.
Thanks- fixed
I'll have to check out the native UI features before I dive into it. Thanks for the heads up.
Thanks! But I couldn't help but poke a little fun at our community's hand-wringing over the py2/py3 migration.
GFY
It needs to be `name=` not `name:` For the future, these questions are more appreciated with us over at /r/learnpython
Or just: for result, in conn.execute('select field from table'):
You can't just install them into different conda environments?
Great to hear, and nice example of random text! Did you use single words or couple of words as states?
I hope nobody uses that thing until it [works on Python 2](https://bitbucket.org/pitrou/pathlib/issue/25)...
From a theoretical point of view, a markov chain (or markov process) is a model of dynamical system, i.e. it defines how a system moves on time. The system is usually defined by a set, continuous or discrete, of states (like "A", "B", "C", ...) and the time parameter could also be continuous or discrete (t1, t2, t3, ...). In any case, a dynamical system is markovian when it satisfies at the markov property, which states that the probability of the future state depends only on the present state, not on the past states. In this sense a markov process is said to be a memoryless stochastic process. Thanks to the markov property such systems are quite easy to study and of broad applicability.
That's interesting ... what I'd like to be able to do is go from pypi package name &gt; which things should I symlink. Note - The project is a horrible hack, however it pretty much works.
good luck! I'm not exactly a NLP expert, but let me know if you need anymore help.
I'm not sure Google Maps lets you get a dump of street geometry that would let you do this. I'd be looking at OpenStreetMap.
I think you mean def is_rekt(): return True 
EVE Online's server is in Python.
But aren't these questions asked by Albright, the lawyer from Newegg? In that case, he asked that on purpose. In the pic shared by OP, it's not intentional...
*System
No, the post said _if you have a single instance anyway_, it's better to have the variable be an instance variable than a class variable. So it's X().x vs Y().y.
init function of class X will never be called because no instance of X is created. You are right about __init__ function of Y doesn't call its super init functions but this is irrelevant because it will only affect the time required to create instance y from class Y which I am not measuring nor concerned about in that example
Like... Integrals?
bad link
BitTorrent's pretty cool, don't think its Python these days though
http://en.wikipedia.org/wiki/Functional_derivative That would be an example of something that is complicated for a novice but a reasonably well written for someone with a foundation in advanced calculus. If you can't understand that article it is not the fault of the author for the same reason that being unable to read Einstein's [original German] (http://users.physik.fu-berlin.de/~kleinert/files/1905_17_891-921.pdf) paper "On the Electrodynamics of Moving Bodies," is not the fault of Einstein. You perhaps just need to learn German before approaching original physics papers written in German.
I haven't looked over the code yet, but anyone know how sh does its `from sh import XXX` magic? Is it done dynamically or does it define objects for each command in `$PATH` beforehand?
Ah, yes, I misread the timeit invocation. No code formatting on mobile :(
It's very cute and a sick burn of course, but suddenly as hackers do we care more about *who* is speaking rather than *what* .. ?
The Instagram backend uses a modified version of Django.
Wizard or without a dayjob ;)
Isn't Texas that state from the USA that has a lot of creationism schools and discourages teenagers to use protection claiming it's not safe?
HMM... Title got cut off even though it's within the character limit. It should read: &gt; Made a little script to change the ready message on HP LaserJet Printers. (Should work on any model with a 1 - 4 line LCD) This bit of fun was inspired by a picture posted elsewhere on Reddit a few weeks ago. The original version of this script was written in Perl, I felt like it needed some sprucing up!
Hello, Hm, could you try running the [evtest](https://raw.githubusercontent.com/gvalkov/python-evdev/master/bin/evtest.py) program from python-evdev (it needs r/w access to /dev/input/event*)? Let me know if the device is listed and events are being read from it. If not, it might be that the X server has grabbed the input devices or that there is a bug in pyzmo. Cheers, G.
Thanks, that makes sense. Did you write this module?
&gt;That's one of the reasons I love programming. I remember when my friends and I &gt;were still learning the basics, everytime we needed to learn an algorithm, we would &gt;just google it I remember when I was learning the basics - it was literally called BASIC. And there was no Google. &gt;and you could find a lecture about it by the guy that came up with it The only algorithms you use post-date Google?
&gt;That would be an example of something that is complicated for a novice but a &gt;reasonably well written for someone with a foundation in advanced calculus. Someone with a foundation in advanced calculus isn't going to be looking up integrals on Wikipedia. &gt; is not the fault of Einstein There are a whole lot of things that are the fault of Einstein.
I wonder too. Delphi users don't even bother to answer questions anymore because [David Heffernan](http://stackoverflow.com/users/505088/david-heffernan) answers all of them within five minutes.Heh heh, looking at the page now it says, like clockwork, "Last Seen: 5 minutes ago". :-) 
Then just declare one instance? 
I keep seeing things that I understand in programming written down as math people would (which I can't read, never mind understand) and realise that I understand more of that shit than I think I do. Why can't it be in English dammit?!
Write for your audience.
Some package authors neglect to include Python 3 classifiers, even on packages that have become Python 3 compatible. And some package authors just don't use Trove classifiers at all. I don't think there's a reliable way to tell whether a package will install on Py3 besides trying it. I mean, you could check for the "Programming Language :: Python :: 2 :: Only" classifier, but hardly anyone uses it.
Yep. Texas does all of those things and much, much worse. 
In my days, it was "ook".
Is camel case bad? I've been using whatever_this_is for the past year or two but after starting uni they are telling use to use camelCase.
Yeah I've never fully understood why pip doesn't work this way. I guess it was just easier to program pip to simply reinstall everything each time (and I can't complain too much since I personally have never felt like rewriting pip :p ). That way you don't have to deal with getting the coherency problems right. I have at times had a "base" environment whose packages I've symlinked (or simply copied) into new environments which has been nice when I wanted to avoid the reinstallation of some packages whose compile times are kind of long. So it's not like one can't do this by hand, but it would be nice to have a consistent solution within pip.
You know, there's a common theme among folks going to the gym. Whenever you see someone especially big, you can't help thinking - "is he on steroids?". Well no, 99% of the time he isn't. He just worked hard enough, long enough, to reach this state. The 1% exists too, though.
When they are the ones with the most intimate knowledge of the subject matter at hand, yes.
Thank you for the thoughtful response. I was unaware of PEP-411 until just now. I hadn't realized the provisional state was a new standard procedure. In the way you have described it, having an escape valve clause is definitely a good idea. There will inevitably be some unexpected issues that beta testing will not pick up and can only be found in the wild. It is good to know that backwards compatibility breaking changes will likely only be implemented in the context of a fix. It makes me feel better about the choice for starting my project. Unless there is a really compelling reason for using an external library as opposed to an equivalent module in the stdlib (cf. lxml's performance), I usually defer to the core devs' judgment and stick with core library modules. If it had Python 3 functionality, Twisted's feature richness may have been another major selling point. This makes me feel much better about sticking with asyncio. Thank you!
CamelCase is not bad per se, but the style guide most python programmers adhere to is PEP8 and that guide says that you should use lower_case_with_underscores so you don't end up with this: def ThisIsMyMethod(): return True def other_method_of_someone(): return True which can be a pain if you are working with more than 2 people. 
I should elaborate that I do a lot of math-intensive crypto programming. I have seen Wikipedia entries on the math that I know inside and out, but the page is written so esoterically and obtusely that it make me want to cry. It's like they intentionally leave out steps and details because they are too pedestrian. Other times I will read about some development in the news and go to the wiki on it and leave knowing less than when I started.
Chimera from USCF is a really powerful chemistry tool written in Python. I've always been impressed with its functionality.
&gt;Don't know where to go from here. Go to /r/learnpython.
fair point. it is a framework too though right? anyway, cheers for repying 
There's no reason why he can't be both on steroids and working hard to get big.
Wikipedia isn't a teacher. You are missing something here. 
Edit them to make them better if you find them of such poor quality. That's like... The point of Wikipedia. 
&gt; I mostly remember it because of the ridiculousness of the line of questioning posed to Dr. Diffie, and for the hilarious looks when I shared it with my friends who work at a security company providing PKI services to their clients. It's not actually all that ridiculous for a trial. In a trial, you need to establish that an expert witness has the proper credentials to evaluate the evidence; otherwise, one side could just hire some bum off the street and pay them to say what you want. Also, you can't just introduce someone as "the inventor of public key encryption"; the lawyers are not allowed to just make an assertion like that, every fact that they establish has to be based on testimony from a witness, and be based on asking that witness a question. And for direct examination, that is examination by the lawyer representing the side that called that particular witness to the stand, the lawyer must not ask any leading questions (question which presuppose some piece of information, prompting the witness to answer in a particular way). Combine all of these things, and the way that you need to establish someone's credentials for the record is by asking if they are familiar with a topic, and asking how they became familiar with a topic, and let them list their credentials. While for those of us who know something about cryptography might think it's absolutely ridiculous to be asking Whitfield Diffie if he's familiar with public key crypto, you can't assume any such knowledge on the part of the jurors. Even more sad, however, is that Whitfield Diffie is a very easy target to question the credentials of by the plaintiff. He doesn't have anything beyond a bachelors degree, he's not a professor. He's a very countercultural looking guy; long hair, shaggy beard. And there's some room for debate as to whether he invented public key crypto; there are some other cryptographers at GCHQ who could be claimed to have come up with the ideas that led to it, though they kept it secret and never published it until much later. Couple this with the East Texas District Court being very favorable to plaintiffs in patent cases, and plaintiffs being good at massaging juries to be sympathetic to them, while it's incredibly frustrating to those of us with any knowledge of the field, the jury found in favor of the plaintiff's completely bogus patent.
This is an example of a micro optimization. Variable lookup is O(1). CS101 says avoid optimizing these things and focus on the slowest bits first.
It's a general purpose encyclopaedia. It should be written for a general audience. Computer Science seems to do this really well (mostly). Maths seems to do it really poorly. If you want a reference written for someone with advanced knowledge, you need a different venue than Wikipedia. 
This for me is Set/Graph theory. So many papers I've seen seem to need to pump up their technical knowledge with densely packed notation because otherwise their algorithm might make *too much sense*. 
Yeah it's pretty common. Hell they'll probably even want to know your wage history before they start salary negotiations. It seems that many companies' HR strategy is immediate disrespect of your time and privacy. That said you don't necessarily need to do it. You might still get the interview, though that probably depends on how replaceable you are as a worker and the internal culture of the company. In any case, it doesn't sound like you're that desperate for the job so you could simply respond with your terms and move on if they don't want you.
What have you got so far?
That's a bad assumption you're making. Just because it works with encoded strings doesn't mean it will also work with Py3. The web is full of strings of undefined encoding, which might cause Py3 to die in flames/corrupt the data. There are also many situations where passing encoded strings through your code entirely unmolested (which Py3 makes hard) is exactly the right thing to do. That's not to say that OP's code shouldn't be more encoding aware, but it's wrong of you to assert that the strings *must* be decoded.
Sadly this is the case at many corporations but not all. The best way to deal with it is to politely tell them you have no interest in a company that isn't up front with job descriptions. Salary is a slightly different thing, many see it as a sales task where the first one to offer up a number looses. Keep that in mind because they may try to pull a number from you. All in all it sounds like a sleazy bunch to me. Honesty seems to be out the window as far as job descriptions go these days. 
what the fuck is happening to this subreddit? 
On the one hand, sure. On the other hand, "putting a b in front of every string" doesn't sound the approach taken by someone who has thought about the encoding issues and determined that everything will be fine as it passes through their code.
Are you Karma Whoring now?
Wikipedia was an invaluable resource in my undergrad math major. You don't need a PhD in the subject, you just have to actually have some familiarity with the notation, jargon, and concepts. 
YES! Someone does! Over at /r/learnpython.
McEdit is written in python. I find this pretty impressive as its not just the back end to a server (like reddit ~~or EVE online's server~~). But its the full blow 3D client written in python. Source code here https://github.com/mcedit/mcedit edit: I said something without looking it up first... :(
Dropbox, Mercurial 
I always err on the side of using the prevailing style of the language or framework. In Python, that's snake_case.
Yay, I'm a wizard, Harry!
I guess I have high rep (140k). Honestly, I barely answer questions these days. I was an early user, though, and answered questions on niche subjects that later became popular, like Git and Objective-C. Now I typically get over 100 rep per day just from old answers that are at or near the top of Google search results.
That's my strategy. Invest early and ride that karma interest all the way to retirement! I'm gonna to be rich! Rich I tells you!
It takes years to learn these topics. You're dense if you think it can be simplified so as to be understood in one reading by a layman. If you think it would be to the benefit of all to have such articles simply removed take it up with Jimmy Wales. I can't believe the audacity of your comment. "I can't parse graduate level maths from a cursory reading! It's the article that's bad!"
Can't generalize based on state too much; there are good people. Just that the jurors of East Texas are known to favor the patent holder a vast majority of the time, no matter how ridiculous the patent is.
Could it be that I don't understand what I'm doing well enough to explain to the layman? ... No. It's the children who are wrong. Listen, in all seriousness I get it. Some of this stuff is really bloody abstract and can't be explained that easily. However, lots of it can be simplified to at least convey some of the meaning. Perhaps not as much meaning as it would to a professional, but they should leave the article with an idea of what is going on. It just seems like some fields make more of an effort to do that than others. 
http://biblehub.com/interlinear/john/16-8.htm
You sound well adjusted. Good on ya.
Yes, and I'm explaining why your measured results differ from what the post says. Perhaps modifying your example to illustrate what I'm talking about will eliminate the ambiguity: class X: x = 7 class Y: def __init__(self): self.y = 7 x = X() y = Y() In [5]: %timeit x.x 10000000 loops, best of 3: 142 ns per loop In [6]: %timeit y.y 10000000 loops, best of 3: 116 ns per loop In [7]: %timeit X.x 10000000 loops, best of 3: 117 ns per loop Now it should be more apparent what the SO comment is saying. `y.y` may only be 1 nanosecond faster than `X.x` but it is a full 22% faster than `x.x`. I should point out, though, that using new-style classes, or Python 3.4, yielded opposite results - `x.x` was the fastest in both of those cases, and `y.y` was the slowest, by roughly the same margin. 
Yeah, it's also where the integrated circuit was invented, NASA controls its space missions, and the first heart transplant was performed. What of it?
You can't expect to tell me to abandon camel case just 'cause some watery tart wrote you a PEP!
What the flying fuck is In [4]: %timeit Am I high or is that actually Python
I feel no impetus to move.
It's iPython. Inside the interpreter you have a few metacommands or magic-commands. Type "%lsmagic" and you get a complete list.
You're contradicting Wikipedia itself. They state: &gt; A Wikipedia article should not be presented on the assumption that the reader is well versed in the topic's field. Introductory language in the lead (and also maybe the initial sections) of the article should be written in plain terms and concepts that can be understood by any literate reader of Wikipedia without any knowledge in the given field before advancing to more detailed explanations of the topic. While wikilinks should be provided for advanced terms and concepts in that field, articles should be written on the assumption that the reader will not or cannot follow these links, instead attempting to infer their meaning from the text. &gt; Texts should be written for everyday readers, not just for academics. Article titles should reflect common usage, not academic terminology, whenever possible.
If by 'discourages teenagers to use protection,' you mean 'doesn't want to tell teenagers that condoms exist because they think that'll convince teenagers not to have sex,' then yes. 
&gt;Can we stop this "in x lines" shit, no sane person It's not about being sane; it's about making other languages feel insecure. The purpose of cold cathode tubes and case windows on gaming PCs isn't to make them go faster. :-)
Ok then, "=" means "equals", so x = 7 should be a boolean expression, "x equals 7". == or the more popular := should have been the assignment statement, as in x := 7, or x is assigned the value of 7.
That's like not using something until it runs on a VAX mainframe. 
Sometime you just have to let go. "Most" Windows 98 software ran on XP; some didn't. There aren't people today (I hope) still using WIndows 98 waiting in vain for certain software to start working on more modern versions of Windows. Most of what doesn't run on Python 3 today simply isn't being maintained anymore and it's time to move on anyway.
Appropriate user name!
I create scientific tools for my workplace with numpy, pyside (a python binding for qt gui framework), and pyqtgraph. I build exe's with cxfreeze through esky (for automatic updates), then I package it in an installer with Inno Setup. Inno provides another layer of compression for all the files going into the installer making the application smaller to distribute. Learning Inno has also helped me package and distribute other non-python tools professionally.
Can confirm -- I've only really posted like 5 to 10 times on SO several years ago, and my point count still keeps increasing every time I log on.
"Only" a BS in *physics*... Dude. It's like a footballer who's "only" played in second-tier pro clubs -- still a pro.
I switched to 3.4 and had to give up mayavi. Mayavi depends on vtk bindings and enthought Traits. I also miss guiqwt which depends on pyqwt. On python 3.4 I'm enjoying pyqtgraph and waiting for vispy to have more features. There's also lots of other 3d cad-like python bindings that seem like they'll never be upgraded like PythonOCC. SolidPython? Bindings for Coin? Going off fuzzy memory...
he no longer posts. last post is 2010 last time i checked. was too SO addicted? :) still amazing answers. also he works at google as 'uber engineer'.
Bookmarked this awesome site. 
Bah, I was thinking .egg-info files might hold an answer, but it looks like python-xlib shows they often do not. [EDIT] I guess pkg_resources might have the info I need, I'm not familar with the library though [/EDIT]
Another hint: you can also import a module by its name as a string. Example: &gt;&gt;&gt; import importlib &gt;&gt;&gt; m = importlib.import_module("PySide") &gt;&gt;&gt; m.__file__ '/usr/lib/python2.7/dist-packages/PySide/__init__.pyc'
http://en.wikipedia.org/wiki/Heart_transplantation ... actually, it was South Africa
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Heart transplantation**](https://en.wikipedia.org/wiki/Heart%20transplantation): [](#sfw) --- &gt;A __heart transplant__, or a __cardiac transplant__, is a surgical [transplant](https://en.wikipedia.org/wiki/Organ_transplant) procedure performed on patients with end-stage [heart failure](https://en.wikipedia.org/wiki/Heart_failure) or severe [coronary artery disease](https://en.wikipedia.org/wiki/Coronary_artery_disease). As of 2008 the most common procedure is to take a working [heart](https://en.wikipedia.org/wiki/Heart) from a recently deceased [organ donor](https://en.wikipedia.org/wiki/Organ_donor) (cadaveric [allograft](https://en.wikipedia.org/wiki/Allograft)) and implant it into the patient. The patient's own heart is either removed ([orthotopic procedure](https://en.wikipedia.org/wiki/Heart_transplantation#Orthotopic_procedure)) or, less commonly, left in place to support the donor heart ([heterotopic procedure](https://en.wikipedia.org/wiki/Heart_transplantation#Heterotopic_procedure)). Post-operation survival periods average 15 years. Heart transplantation is not considered to be a cure for heart disease, but a life-saving treatment intended to improve the quality of life for recipients. &gt;==== &gt;[**Image**](https://i.imgur.com/GofEzgZ.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Heart_transplant.jpg) --- ^Interesting: [^Organ ^transplantation](https://en.wikipedia.org/wiki/Organ_transplantation) ^| [^Transplant ^rejection](https://en.wikipedia.org/wiki/Transplant_rejection) ^| [^Christiaan ^Barnard](https://en.wikipedia.org/wiki/Christiaan_Barnard) ^| [^Heart](https://en.wikipedia.org/wiki/Heart) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl5jcbf) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl5jcbf)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Its surprising the amount of times my username is appropriate.
Years ago I was reading comp.lang.c on USENET. Some guy was complaining about the syntax of the switch statement with a rant about he just had a bug cause he missed putting in a break. He ask why the hell was C written this way and why does switch require breaks anyway. The first response was from a Dennis Richie, apologising for the bug and say he can't quite recall why he did it that way.
Read that. But it does not change the fact that twisted code that has supposedly been ported to python3 still has strings in many of their variables. It is not MY python2 code but twisted "python3" code that is the problem. If twisted returns "some string" as a byte string then all I can do is compare it with b"some string". What I am saying is that I find this makes my code look a mess; and it is very easy to forget to add the b. Of course I could decode all these strings but that would be even messier.
Well I did but if twisted returns me a byte string then I can either compare it with b"string" or I can decode it. Either way it is a mess. It is the twisted "python3" modules that do not use unicode.
That really should be a property... (and boooo camelCase!!!) Please accept my pull-request, below: @property def is_rekt(self): return True
It's funny you should mention that, but I've actually taken a liking to mixed cameCase/underscore naming in certain contexts. Take Twisted for example, which is often derided for having the camel case convention. It's actually quite nice to know when your method is overriding a superclass method or when it's an entirely new thing. It won't change the world, but I find it convenient enough to rustle people's jimmies by playing the mixed-convention apologist...
Haha you must be new around these parts ;)
/r/learnpython is that way ----&gt; Also /r/blind is further along that way ---&gt; (you seem to have missed the **huge red block-letters** telling you that these questions belong in /r/learnpython...)
I agree with /u/mackstann's comment. I don't think Google is going to be very helpful with regards to munging through their map data. If you absolutely *must* use Google Maps, then I think your problem is best treated as one of computer vision. Segmenting streets should be fairly trivial since they share a common color and are well-delimited. My first try would be something along the lines of: 1. Filter out anything that's not street-colored 2. Perform Canny edge detection, reducing your lines to single-pixel widths. 3. Find dead-ends Part three is a bit trickier. Speculatively, you might be able to adapt an A* search to label dead ends. I would start use `scikit-image` for the image processing.
You're dropping a lot of domain-specific jargon on us so it's rather difficult to understand what you're trying to do. Can you provide us with a clearer description of what your problem is? In terms of how your data are enoded, what are you defining as a "genome"? What are you defining as "a sequence"? What is a "sequence read"? What are your criteria for alignment? Could you please guide us in how we're meant to interpret the figure you posted? I'll go out on a limb to suggest that if you're having trouble getting started, it's because you haven't clearly defined the problem, much less broken it down into sub-problems. Start with that. Tell us what you need to do first, second, third, etc... If that exercise hasn't led you to a solution, we'll be glad to help :) Also, /r/learnpython *may* be a better place for this kind of question in the future.
You are not high but you probably never used IPython shell before
Yeah, and since you should always use new-style classes, **the SO answer is actually wrong** and demonstrates a lack of understanding of how new-style attribute lookup works. The circlejerking there and here is retarded. The catch is the existence of [descriptors](https://docs.python.org/2/howto/descriptor.html) (properties, @staticmethod etc), in particular the fact that _data descriptors_ (those that implement '.set') override instance variables. Therefore Python has to _always_ make a lookup in class dictionary first, and all ancestors' dictionaries, in case there is a data descriptor with that name there. If there is, it would just call it, otherwise it checks the instance dictionary and returns a value from there if it exists. So in both cases here it checks both dictionaries (or, more precisely, all three dictionaries, including `object`'s). Why is the second case faster? Because class dictionary always contains some stuff (`__module__`, `__dict__` descriptor, `__weakref__`), while instance dictionary in the second case is empty, and apparently lookup in an empty dictionary is that much faster. The case where there's a value in both class and instance dictionaries is a bit slower again, apparently because trying to get a value from a dictionary is a bit faster when it's not present there (you don't have to actually compare the keys, access the value, etc). In case of deeper inheritance hierarchy (or multiple inheritance) having the value in the class dictionary is much faster again, because it immediately terminates the search in parent dictionaries. Even if as a result the instance variable is returned.
I agree with this. If you're simply chaining a bunch of POSIX programs togeather, then bash is almost certainly the right tool for the job. Bash really was designed as "glue code" for chaining programs on a POSIX system. When it comes to implementing your own logic beyond associating output from one program to another's input, then Python wins hands down. Usually I have a mix of the two. I'll write a bash script to chain a few commands together and return some taylored output, then I'll call that script from within Python and perform some more in-depth processing there.
Yeah, but by the time XP was out (remember, there was Windows Me, Windows 2000, and Windows NT 4.0 that came out after 98 and before XP), Windows 98 was deprecated. Python 2.7 will be supported until 2020 I believe, if not longer. I work primarily with Python 3, but when there is a library that works only on Python 2, I switch back. 
I'd say its debatable whether its fit for a single line. The algo pseudocode (http://en.wikipedia.org/wiki/Quicksort#Algorithm) says: 'Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way)' qs([i for i in a if i &lt; pivot]) + [pivot] + qs([i for i in a if i &gt;= pivot]) Which makes the above a pretty literal translation. It's also 76 characters, which makes it pep 8 compliant
Just pick something that can run Pycharm. That IDE changed my life.
Ubuntu + Ninja IDE
most* Linuz systems come with python preinstalled ( so getting started is easier in theory ) however just go with whatever OS you are comdortable working in ( and PyCharm is a package from god** ) * not all ( I'm looking at you Arch ** especialy on windows 'couse it has no other usable IDE (that I know of ) and working through windows cmd is a pain in the neck
Arch comes with almost nothing preinstalled...
It's not difficult, it's just horribly limited compared to a typical Unix shell like zsh or good old bash.
&gt; Is there any particular flavor of linux that is better suited for python development than another? No, not really. Python is Python, the tools run on all of them, so it really comes down to personal preference wrt the distro itself. If you like "user friendly" distros with lots of eye candy and "normal people convenience", go for something like Ubuntu or Mint or idk; if you want something vanilla, try Debian or Arch or maybe Fedora. If you do lots of web programming and want something that feels like a server, pick one of the popular server OSes - Debian, Ubuntu Server, CentOS, FreeBSD (not technically Linux, but the userland is mostly equivalent). Of course, if you have a favorite IDE, then it's nice to have a distro that has it in their repos.
with the arrival of Anaconda Python, I am largely agnostic. However I will take OS X or Linux over Windows just on the basis of ease of shell usage. Anaconda makes Python fun on any OS!
/r/bioinformatics
I'm really sorry. I misunderstood what you were saying from the start. Now that I'm reading what you're saying correctly, it isn't that surprising that Twisted would run into the rough edge of protocols that mix ASCII text with bytes. I definitely should not give you crap about that fact that's out of your control. It's great that Twisted is porting, and great that you're using it and describing your experience with the ported API.
I use Raspbian... because it's the only Linux machine I can afford. Lol.
Camelcase is love
I don't know man, I am yet to see an IDE that comes within a shot of Visual Studio
Bua ha ha, whoops.
ConEmu is pretty nice too.
You can download pretty much any distro and run it along side your current OS or use a virtual machine. I also love my Pi though haha.
Slackware. No systemd or Unity or other bloated crap :)
Windows 8.1 + PyCharm
I've been coding on Arch Linux + KDE in KDevelop, which was pretty cool. Now I'm on Windows + Visual Studio + PTVS, and I can't be happier.
* The copy and paste functionality is so bad it might as well not be there. * You can't resize the window at will. * An imitation of MS-DOS is not an environment that is conducive to getting actual programming done. * It doesn't support Unicode. In fact, the only character set supported is IBM codepage 437. That's not even the character set the rest of Windows assumes. So if you think you've dodged the Unicode issue by using Latin-1 bytestrings, it'll switch all the characters around on you. íQue extra±o!
Oo, ouch haha. It's great but way too sluggish for general use for me. 
Windows 8.1
mac osx and linux. I use linux mint at home.
Ubuntu + Emacs
Have a look to Harry's work http://www.obeythetestinggoat.com. 
There is a criterion relevant to Python development: Will the release cycle of the distribution allow you to quickly access new Python versions? E.g. elementary OS is pretty great, but stuck with Python 3.2! CentOS, RHEL, and Debian also have slow release cycles that keep you from using the newest version. If you can handle its installation and maintenance, Arch Linux is usually the quickest to adopt new versions of things, but Ubuntu also has the [deadsnakes PPA](https://launchpad.net/~fkrull/+archive/ubuntu/deadsnakes), which despite its name is also a way to get new pythons with an old Ubuntu.
I prefer Linux. Python is pretty Unix-focused and its windows experience isn't ideal.
Linux, FreeBSD, OSX - i supose Cygwin wouldn't be too bad either. Really you just need something with a solid command line and GCC (for building modules with native code).
True, I developed a Python tool on Windows, ran it on Solaris just fine.
[Windows + Python Tools for Visual Studio](http://pytools.codeplex.com/)
It's not too terribly difficult to build python from source on most distributions. I've done it on CentOS and Debian based distributions with little hassle. Things can get tricky with having python from the package system installed along side ones built from source depending on the distro. On Linux Mint I haven't had any problems. Install all the packages you need to build, ./configure, make , make install.
Of all the Python IDEs I've tried Pycharm comes the closest while being easy to setup, use and it performs fairly well on the older hardware I'm running it on.
Sorry, you're right, I meant in the US since we were shitting on Texas, but phrased it poorly.
The biggest pain is installing stuff with pip or easy_install that needs a C compiler. Other than that I started to hit some of the windows/linux difference when working with signal handling, socket programming, some file system stuff. I've used python on windows to move data in and out of microsoft sql, MySQL, mongo, parsing text files, etc. I didn't hit any of the platform differences between Linux and Windows in Python and it's libraries. The third part stuff though was a little tricky, tracking down windows installers for some things instead of using pip / easy_install. 
system python != the python you use for development build from source, highly recommend with pyenv
and --prefix=/home/me/local 
&gt; system python != the python you use for development this is completely counter intuitive and needlessly complicated. it is a workaround of the case when you don’t have the newest python as system python, nothing more. newest python = python you develop in = system python older versions are for testing only.