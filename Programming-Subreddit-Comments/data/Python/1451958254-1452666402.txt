This looks legit! 
Thanks for suggesting this! I'll use it in the next commit. 
&gt;if you're going to make an interesting web app you will need to use JavaScript Or something that compiles to it! I'm currently learning [Purescript](http://www.purescript.org/) so I can work in a Haskell-like language, but still kick out nice javascript. You can find pathways [from Python to JS](http://pyjs.org/), too!
&gt;No matter where you go in your career you'll have to use or learn multiple languages. It's rare, but you can stick to one for a very long time. I've been an animation/rigging tools guy in games for almost 15 years, and I worked for the first decade in just MEL (Maya Embedded Language), and for most of the rest of the time just in Python, which I had plenty of time to slowly transition to. I know many programmers in the field who've just done C++ for their whole careers. Web dev blots out the sun with its omnipresence, and it brings with it constant language churn, but all around it is a far more stable fringe.
what does ASGI mean? Why isn't it stated at least once on that page? I mean, the initialism is used 22 times on that page without being defined once. Edit: It's been added to the page - it stands for Asynchronous Server Gateway Interface.
I think WSGI has issues, but it's succeeded in making the process of picking a Python webserver _very boring and simple_ - I think being very boring and predictable is something a spec should aspire to. ASGI will be a spec in so much as it's how Django will operate; it's just a bit more formal than, say, the Django documentation on writing a custom database backend (which has suffered from not being concretely specified in some ways). Whether it becomes a Python thing or not we'll have to see, but it's helped me enormously just with writing Channels stuff as even working from my own spec helps keep things in line and lets me remember exactly what each bit should do.
Asynchronous Server Gateway Interface. It's shown in the TOC and sidebar if you browse to another section.
I am going through the udemy course for automtetheboring stuff it is great. I also like the pocket ref guide
It's a bit simpler and more automatic than pyenv. I've now added functionality to build and use non-system versions of python with the virtual environments, so it sort of does the same thing now.
Then you're in trouble. I could make this configurable/overrideable but I'm not sure yet what the best way to do that is. Probably some kind of config file.
You should alias that to "shit" and have both:
You should watch Dave Beazley's Python Metaprogramming Tutorial and it's spin-off/sequel Modules and Packages: Live and Let Die (and not, how he notes, packag*ing* because who wants a three hour tutorial on pip). 
What is the expected real-world setup for this? Nginx + | v Protocol Server &lt;---------+ Supervisord + | v Redis + | v Django Code &lt;-------------+ Supervisord
Wow that is super cheap. Awesome! 
Definitely a 'depends' for me. Working with PySide GUIs I'm often creating classes to format data for display on the UI, and often that involves passing lists or dictionaries of values, and most times I don’t really care what happens to those lists after creating an instance of a class – depending on the data or source of the data they are probably getting garbage collected once my UI class’ method has finished, and the original values that I actually care about are stored in a database or csv file etc.
bang followed by another bang is last command, bang followed by a number is history number. :) And [more](http://craig-russell.co.uk/2011/09/28/bang-bang-command-recall-in-linux.html#.VotbYnqvBhE)
This would be handy for heading off the inevitable fragmentation in 2-way servers especially for mobile and IOT applications. Waiting for the (justifiable) cries of "But Twisted already does this" in, 3, 2, ... :-) 
Aw hellz yeah! Finally! But... I should probably start reading the Python 2 MotW... since I've had it bookmarked for years... without a glance :( 
No to anything by PACKT. They literally make you email them for the source code and then ask why you need it.
&gt; You should usually prefer functions to classes. Functions and modules are the basic units of code re-use in Python, and they are the most flexible form. Classes are an "upgrade path" for certain Python facilities, such as implementing containers, proxies, descriptors, type systems, and more. But usually, functions are a better option. &gt; … &gt; It's always better to have a lib.time module for time-related functions than to have a TimeHelper class with a bunch of methods you are forced to subclass in order to use! Classes proliferate other classes, which proliferates complexity and decreases readability. ([Functions vs classes](https://github.com/amontalenti/elements-of-python-style#functions-vs-classes)) Amen to that!
Does OS X ship a c compiler? Does Ubuntu ?
On Ubuntu it can be trivially installed with apt. On OSX I have no idea.
Use the proper tool for the projet job. For IoT, it's better to usually go MQTT (mosquito) or WAMP (crossbar.io). I prefer the later. But in any case, don't try to stich together some tools you know to create a half baked home made solution. It will never be as good.
You can, and it worked pretty OK last time I tried. You will have access to more features with the picamera module though.
Not in this case - the author gives the link to the bitbucket repo: https://bitbucket.org/wswp/code
Oh god, scientists that program. It's highly unlikely that they have processes worth learning, and instead will drive you crazy by writing horrible code to do beautiful things. Modularity, documentation, unit testing, version control... I've seen all of these treated like bad words as PhDs churn out unmaintainable spaghetti code. If that's your new job, learn how to say "is this prototype ready for reimplementation?"
Universal remote edition: git push -u origin head
I want a link to the talk
X-Post referenced from /r/programming by /u/reubano [I wanted an easy way to follow the semver Specification, so I created ongeza: your (language agnostic) project versioning personal assistant](https://www.reddit.com/r/programming/comments/3yxaqf/i_wanted_an_easy_way_to_follow_the_semver/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
ehhh no thanks, i dont want this language to start picking up habits from R studio
Just want to mention that even though it's written in Python, `ongeza` supports versioning for PHP and JavaScript files too!
I loved the 2.7 examples and went through them religiously. Can't wait for these.
I've compiled one against 12c, which can connect to 11g as long as instantclient is 12c. https://www.dropbox.com/s/onxlqev0phgv05a/cx_Oracle-5.2%2B12c-cp35-none-win_amd64.whl?dl=0 Hope that helps
Unofficial compiled cx_Oracle can be obtained at http://www.lfd.uci.edu/~gohlke/pythonlibs/#cx_oracle Hope that helps... edit: also, if you wish to downgrade, the command might be conda install python=3.4 conda install anaconda 
The author (I'm guessing you) is not a dick. Seriously though, I bought an RX Java book from them, and it was the worst thing ever. How could you learn something as hard as RX Java without source code? Freaking jerks.
If you check the sidebar, it recommends heading over to /r/learnpython. I would post over there. &gt;If you are about to ask a question, please consider r/learnpython. Homework-style questions will be removed, and you'll be encouraged to post there instead.
I started to dig into curses this morning. Let's see how that works out :)
As other have stated, this isn't the best place for it. Anyway, I am still relatively new to Python so there may be a better way, but why not first check if it is a string: `if type(input) is type('')` Then, you can convert it to a float or an int. Then, to check if it is an integer or not, you can do something like `round(input) == input` (or use some absolute value statement and allow for 1e-10 or so equality). Then, you can just check if it is in the bounds with `1 &lt;= input &lt;= 52`. BTW, it's pretty crazy (in a good way) that Python allows statements like that!
I believe that's literally what virtualenvwrapper is, except that it works with bash, zsh and ksh.
I think the point of project Euler is what you want it to be. You can solve it with math focus, you can solve it with low-level implementation focus, you can solve it trying to get every solution to be extremely fast, etc. I do not disagree with these approaches. My focus here is to solve them with a declarative focus, using itertools and yield, simple functions and packages. I found that this type of solution was not always easy to find in the solution forums, and therefore I put this out there if others are interested in this type of approach too.
 !! (On the door, baby)
Hate the new icons. For the same reasons various people have mentioned here on reddit and on their websites. The logos don't have character that the original one did. At least with the "nosplash" command-line option I can skip that horrendous splash-screen.
It all depends on how the keypad gives you informations about the key pressed. If it has a little bit of electronics that sends some kind of code every time a button is pressed through a serial line like the classic RS-232, it would be quite easy. But looking at the photos of your keypad, it seems to be one of the 'dumbest' kind: it has 7 pins on the back, likely 3 are for the 3 columns and the other 4 are for the rows (I'm guessing). You have to cyclically power one (at a time) column, and check if you get a signal on one of the row lines. When this happens, you have the key in that column/row pressed. The good news is that the GPIO pins of the RPi are well suited for this, most likely you just need to wire 7 of them to the keypad (just a reminder: electronics is not my field). The bad news is that you have to code all the above logic. Definetly not trivial you have no experience in programming, but very easy for an experienced programmer.
I'm new to python and I was looking for create something that helps me to learn more about python. I used PyQt and PySide but in my opinion they don't have pretty and flexible widgets. In other hand, I'm a web developer and like inputs,div,ajax , etc. These reasons motivate me to make a new way to create GUI apps by web technologies.
This is awesome to see as I'm an aspiring programmer myself! 
Questions 1-50 are fairly easy. The fun part comes after them.
Sure https://github.com/jaapz/virtualenv-tools
I don't think you have to calculate all the routes. There are some things that are sure, like doubling gets you to n faster than adding 1. So, I would try to do it smth. like this: while k &lt; n: if k + any number in route == n, print route and exit if doubling k makes it &lt; n, do it else add max(route) to k add new k to route print route Where k starts as = 1. With this algorithm: 25 == 1, 2, 4, 8, 16, 24, 25
&gt; inb4 everyone starts to pretend that we are all sysadmins managing hundreds of linux machines and its better to stick to vanilla bash Hundreds? Try over a thousand workstations before we start thinking about servers and our HPC cluster... and we use tcsh ;) But I am a pretty edgy teenager, at least that's what I'm going to tell myself when I turn 40 in a few months.
Nope, just ^foo^bar works. For example if your last command was "echo foo" and you entered "^foo^bar", then the resulting command would be " echo bar". Edit: crap. Reddit formatting ... You are correct.
so why isn't the whole argument/operator/attribute thing just a lambda?
https://gist.github.com/ please use this for your code samples and post the link here. it will greatly assist with readability and you won't have to worry about getting the markdown formatting correct. as for your actual problem, I have a suggestion. consider that the optimal route will always be the one that uses as many doublings as possible and minimizes the number of additions you need to make, and since 1 is always a "previous number" in the route you can always just keep adding 1 to finish the last leg. so the optimal route will always have a complexity on the order of log n + C, where C is bounded by n/2 - 1. try to write a function that computes the optimal route. you don't have to compute every route, then find the optimal one, then count its complexity. just compute the optimal route only. count the complexity of your function that finds the optimal route. that should basically be the same as the complexity as the route itself. this seems like its designed as an exercise to introduce you to big O notation and the idea of asymptotic analysis of function complexity. there's a lot of literature on that already. google it if you're interested. 
Sweet man! Thanks
I'm also kind of confused on the usefulness of this, could someone post some more examples? Seems a bit overboard.
Could you provide a patch of the changes?
Off topic, but your website doesn't respect the size of my screen. I have to scroll back and forth to read it.
Yeah, we're implementing feature flagging on a globally-homed, multi-component, multi-language system. And said flags are just flags, they're not thresholds, they're not conditionals, they're True or False and no more. Dunno why one would blur the line between a threshold and a feature flag. What's the utility in that?
&gt; how does such an expression become more than 100 (or even more than 72) characters? Because you're indented too far and lost 4 characters for each tab or you have to print a string like: msg = ( ' S T R E S S E S I N T R I A N G U L A R E L E M E N T S ( T R I A 3 )\n' ' ELEMENT FIBER STRESSES IN ELEMENT COORD SYSTEM PRINCIPAL STRESSES (ZERO SHEAR) \n' ' ID. DISTANCE NORMAL-X NORMAL-Y SHEAR-XY ANGLE MAJOR MINOR VON MISES\n' ) and it's easier to read at 145 characters deep than 72 (that's also with only losing 12 spaces to indentation). It looks just fine in my IDE. PEP-8 is a suggestion, not a rule as evidenced by: &gt; A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important. &gt; But most importantly: know when to be inconsistent -- sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask! &gt; Some other good reasons to ignore a particular guideline: &gt; When applying the guideline would make the code less readable, even for someone who is used to reading code that follows this PEP. https://www.python.org/dev/peps/pep-0008/
that's a cool idea. good job
looks good, I like the idea but it needs some polish. 1. two buttons say 'I haven't seen it', the third says 'I haven't seen either' - but I have seen both, which button do I click? (now I get you are meant to click on the picture - could be clearer) 2. Couldn't see where to register (now I see the menu option, but it disappears when I click on login and there is no way back) 3. Got "Internal Server Error" after a while 4. After I put in some time choosing films, only when I clicked on 'suggestions' does the site tell me that I need to be logged in (and so I have been wasting time) - could you not enable this for those who do not want to create an account? 5. maybe label this as 'beta' status or something to set the right expectation with visitors Hope this helps
Yeah, but let's say this was a Django app. Why not just add in the view `if user.id not in settings.MAGIC_TEST_USERS: raise Http404`? It's simple and requires no new dependencies.
Jesus, I thought it was a joke and clicked at work 
I like /u/earthboundkid's solution, and you can more clearly (imo) decide which users you want to test on. And even provide a range, like all users that signed up this month: `MAGIC_TEST_USERS = [u.pk for u in Users.objects.filter(date__year='2015', date__month='01'))]` You don't have to fiddle with any new classes this way :)
lot of spam hitting /r/python these days.
That sounds really cool, I wish I knew what any of it meant.
Erica, I am afraid, I can't do that
Maybe tell people to make an account before they start rating movies?
What if you want to start rolling this out to more users? For instance, we might say: first, turn on this feature for just internal users. After we validate that the feature works correctly for us, let's ramp up to 1% of traffic. If things keep going well, we can continue to ramp up the feature a higher percentage of users. If we start to see issues, we can turn off the feature switch, all without having to deploy a code change each time.
That's pretty cool. I haven't been keeping up with python-for-android recently, but it's nice to hear that Py3 support is near. I'll have to take a look at adding support for touch events, if it's already that close to building for Android anyway. 
About SDLmixer, I'm not sure how python-for-android handles libraries, but we're just including the default Linux/Windows libraries for SDL_*. It does seem like SDL_ttf was picked up fine though, since it's showing text in your screen shot. I'd be happy to help with debugging in any way for your build tools, because they look awesome!
This contributes nothing. I think we've all seen this list, or 95% of this list, many times over. It's 2016; which of these libraries support Python 3? The article doesn't say. Why would one prefer one to another? The article is mute. Regurgitated drivel.
It's only for downloads actually, uploads don't count. We also offer a free plan with more bandwidth for open source or non profit projects upon request.
The last company I worked for would love this. We spent so much time on our own insecure solution. I'll let them know.
One of the changes I did have to make was patching ctypes to load libraries from the android libs directory (which contained the arm libSDL .so files), so it will have been loading everything from there - actually I wasn't sure if something would turn out to be missing, like freetype, but that didn't seem to be important at least to get to the title screen. The mixer thing was apparently due to missing symbols in the .so. I don't know what would cause it, but two possibilities are that they weren't included due to build options (I know I tweaked these, but I'm not sure what the implications were) or possibly that they're from a newer SDL version as I built with 2.0.3 rather than the new 2.0.4. I'll probably come back to this when the py3 stuff is completed to try and make it build with no issues (that's the target), as your game is a nice example.
I use packagecloud for hosting deb packages for pgcli and mycli. It is awesome. Their UI is simple and intuitive. Thanks for your service. :)
Thanks! Means a lot to us :) Btw, we have a user slack channel here: https://bit.ly/packagecloud-users 
Hey there. I wrote this to save myself the trouble of manually erasing 88k+ lines of excess data from a list of surnames provided online by the US Census bureau. I would be interested in making the tool more useful than just for this one case, any suggestions as to how the tool might be improved? 
Use pip's wheel cache so that you're not continually downloading from remote and you'll be fine. You're not, like, hitting PyPI directly harder than that, are you?
Stick with Python, it sounds like we had similar experiences. We replaced a lot of VBA at my old company with Python, but still had Excel dependencies. I was one of just two Python guys at the office when we started using it (non-dev role, sounds pretty similar to yours) and it took a bit of time to get buy-in from management, but once we had some clear displays of value, a lot of colleagues were very eager to learn, and it's not a huge leap for open-minded people who can write complex Excel formulas or VBA. We used Python Tools for Visual Studio and ran everything locally with git to make sure everyone had access to all of the scripts. The git integration in VS isn't great, but is good enough, especially for beginners. Once we got really serious traction, we put together a basic django site that allowed people to run frequently used scripts off a local server so those who weren't interested in code could get results without finding someone with an installation to run it for them.
It depends on what you need to do and for whom. If you need to make complex GUIs for others that doesn't need to interact with other systems, then maybe you are better off using VBA. Making desktop applications that can be distributed to multiple users is a PITA in Python. So you're left with having to learn to make full fledge web applications, which means you'll have to learn all the client side web technologies that goes along with this. However, if you just need to make simple web dashboards then perhaps [Spyre](https://github.com/adamhajari/spyre) could be an option which handles most of the client side boilerplate for you. It is a clone of R's [Shiny](http://shiny.rstudio.com/gallery/). [Pyxley](https://github.com/stitchfix/pyxley) is also similar. If you're doing all the analysis, then stick with Python for sure. I am a lone Python guy at work and no way I can convince others to use Python. In my experience, there are way more GUI users than there are coders/programmers. So our users use Excel VBA GUI applications. In my area, it just seems people are not interested in writing scripts, even simple R scripts, but would rather point and click. We don't have the budget, so for these folks, they have to stick with Excel instead of Tableau or QlikView. At work, I use Jupyter notebooks and make web applications using [bottle](http://bottlepy.org/docs/dev/index.html) framework since my web application is used by a small set of users. I've tinkered with interactive notebook widgets, but to make apps for others, it is better go with the aforementioned options.
This is the whole point of gutter (mentioned in the original post). It is hooked up to a storage backend (e.g. Redis, ZooKeeper) to persist the state of the feature flags.
The freetype stuff seems OK since the text is showing normally on the title screen. There aren't any special things going on really. It's all fairly normal use of the libraries. On the Desktop at least, it works fine with older SDL versions as well. None of the new functions are used. 2.0.3 would be just fine. 
How does it compare to SciKitFlow https://github.com/google/skflow ?
Ah right - yep, that may work even better 
With a quick overview, they seem pretty similar, with etf allowing for more customization. EasyTensorflow also has the evolution factor, which can be helpful if one doesn't know the architecture they want. SciKitFlow has the convolutional part though, which etf is missing.
I'm taking Andrew Ng's course now. If you're a student, some universities offer free access to MATLAB, which I like more than Octave. Either way, it's a great course and I wouldn't let the distinction between Octave/MATLAB and Python stop you from taking it :)
If you got 10 users that use TravisCI your hit the traffic limit within a week. As I understood the limit is per month.
Already ?! Oh, man :) I tested it yesterday, it worked fine until I hit an unicode error. I was searching "matrix". I'm sure you encountered some of them earlier though. I was a bit overwhelmed by all the output. I don't like to scroll in the terminal much. I also tested pirate-get I liked the fact that it recaps everything in a table, and that it can feed a torrent to Transmission ! (I couldn't get it work because I can't access an url it needs but I saw the demo)
Throw in a key value store dependency and you've got yourself a trending library
It don't really make sense to use the free tier for anything then. Definitely not for opensource stuff. I'm not sure why it even exists to be honest.
It does : for testing. Which you will want to do before paying. And as the author said, they have special deals for open source. I feel like you are being a bit hard on them. They are trying to do a business, which need to be profitable. Finding a sweet spot between ease of trying and the commercial offer is not easy, but they can't give you a free meal or they'd die like so many start up with no business model and big free plans.
Of course :)
If by "custom descriptors", you meant descriptors defined with a class with `__get__` and `__set__`, and not a with the `@property` decorator, then yes you are right. I had to change the implementation for this to work with descriptors, and now it does.
Thanks for this info, I wasn't aware of the UW courses. And they use python! Awesome! I've immediately started them. edit: Oh I guess the ones you're talking about are all $79 each. I had started the one by Pedro Domingos edit2: signed up anyway!
[removed]
If you're taking Andrew Ng's course, you can get MATLAB through the course itself. Its a limited license and it expires after the online course, but it makes doing the course in MATLAB hassle free.
Yeah we are the same but are just having our GENERIC VENDOR BI solution replaced with Power BI which might make things easier for people.
fiddlesticks
I believe it's a problem with Anaconda. You need to open the image in a new tab (left click on the image, open in a new tab) Using ipython notebook you can just double click and it will appear in the right size. 
&gt; My take is that Markdown is better for fairly simple bits of text, like this comment, but rst provides much more power for complex documents, like cross referencing and extensions. Also extensibility, you can relatively easily build your own rST directives and roles, not so for Markdown &gt; Markdown lets you include arbitrary HTML, which is both a blessing and a curse. It makes it very easy to add custom content so long as you only care about HTML output, but it's hard to convert that to other formats like PDF. rst's extensible roles and directives are a technically better way to customise your documents, but require much more work. rST [also lets you include arbitrary HTML (or Latex)](http://docutils.sourceforge.net/docs/ref/rst/directives.html#raw-data-pass-through), inline or from external files. &gt; I don't even know if there are rst parsers in other languages. [Pandoc](http://pandoc.org) is written in Haskell
TL:DR I'm working as a data associate, in a ad hoc team @ at ecommerce MNC, which is pretty much the lower hierarchy in the system. I use python to leave behind the VBA macros, but they resisted as VBAs are part of excel so they can belive n them. But only a few could code them which Created A void/unusual dependency. Still, i adamantly do my works n python which will be automating the boring stuffs. Even data entry operations assigned to me were automated as browser automations, Even with salesforce. Designed a django for my teams productivity tracker so that each workers work will be documented but my TL resisted me to deploy it and avoided it as its unreliable than the excel columns &amp; rows. Still pretty much to go. But Simple truth : I'm now having more coffee breaks. 
good lord that's awesome! where has that been for the past ten years? HOW COULD I LIVE WITHOUT THAT!
Sweet thanks, I'll check them out
Oh wow, this is neat. I'll definitely check this out!
That is fucking cool.
Sounds very similar to what a lot of people in similar roles face. It's a shame not more people know VBA/programming
&gt; {’category’:[’word’,’word’,...]} I don't think this is sample input. It's more like and example of how the `dictionary that contains categories as keys, and the corresponding lists of words as values` in which you load the data from file will look like.
So you're learning node?
I'll just leave this bit of handcrafted code for you :-) _URL_PATTERN = ( ur'\b' ur'((?:https?|ftps?)://)' # scheme ur'([^\s@:#/"\'&amp;()?{\[\]}\+,;|&lt;&gt;]+(?::[^\s@:#/"\'&amp;()?{\[\]}\\+,;|&lt;&gt;]*)?@)?' # cred ur'((?:\.?[^\s!"$%&amp;/()=?`^{\[\]}\+*#\',;:_|&lt;&gt;.]+)+)' # domain ur'(:[1-9]+[0-9]*)?' # port ur'(/(?:\.*[^\s!"&amp;()?`#\',;.|&lt;&gt;]+)*)?' # path ur'(\?(?:[.&amp;]*[^\s!"&amp;()?`#\',;.|&lt;&gt;]+)*)?' # query ur'(#(?:[.&amp;]*[^\s!"&amp;()?`#\',;.|&lt;&gt;]*)*)?' # frag ur'\b' ) Known to find links in text and cause cancer.
Ah, I think you're right- although the "hint" does say that you need to use `split` twice, so the general neighborhood of the solution is correct.
Thanks a bunch you guys!
Hint - attempt the question and post the code which shows you at least pretended to try to solve it.
I'd wager this pattern would be even worse as a VerbalExpression.
This was really neat to watch but how was Python involved exactly?
Very interesting! Just wondering if a long expression would be just as cryptic as some re's I've seen. Would anyone be willing to show a complex re next to it's equivalent verbalexpression? Maybe the URL_PATTERN re above for starters.
Because closures are more harmful to code readability than GOTO.
Nah, if people knew VBA it would be easier for them to understand python
Posted here because I'd love to hear other thoughts on `nonlocal` and rebinding closures in Python.
Very cool project! 
Sounds good, thanks. I have a pretty easy time going between 2.7 and 3.x on my linux and windows boxes. In windows, "py -2.7" or "py -3" works just fine. In linux there are symlinks to python2.7 and python3.4
Pandas builds on numpy, as all numpy functions are available in Pandas. I rarely use numpy directly. In most cases, the helper functions provided by Pandas are better. Reading / writing files (not just xls, but csv and plain told txt) is a million times easier in Pandas. I can never understand Numpys *genfrom_something()* functions. Once you start using Pandas regularly, you won't go back. That said, the abstraction with Pandas is a bit leaky. It works in most cases, but sometimes you have to jump thru hoops. Like drawing anything but the most basic of graphs. To summarise: You'd use both Pandas and numpy together. Pandas is great for high level abstraction. Like you can read a csv(or xls) file, remove all empty fields and sort it in 3-4 lines of code. If you want low level power, like running some stats function on one row or running operations on one column, then you'd jump down to numpy/scipy. Like numpy did not make scipy obsolete, Pandas does not make numpy obsolete, but allows another level of abstraction.
Sorry pal, but if it isn't written in BrainFuck, us cool kids won't even touch it.
Anyone have a package name for this in Debian? 
This is kind of neat, reminds me of simplified PyParsing or even Parsec. Looking at it, I can't tell if it handles things like [named] capture groups. Is that true?
thanks for your reply. even the fact that you said "running operations on one column" implies that a lot of your use cases are table/matrix like. I guess I was looking for more general non-exploratory software engineering use cases. RE CSV, i've always used the CSV module to parse CSVs. might have to check out pandas for this. 
I fully agree here.
But what if you want to try out Python 3.5? With conda I just do conda create --name py35 python=3.5 source activate py35 # If on windows drop the "source" And now `python` is pointing at Python 3.5 in an isolated environment into which I can `conda install` and `pip install` whatever I want. `conda install` has fewer packages available, but they're pre-compiled if they contain extension modules. `pip` will point at that environment as well, `conda` applies the same environment variable and path manipulation tricks that `virtualenv` does, but it keeps your environments in a centralized location. You can also set it up without admin rights so that you can install and delete environments however you want without ever affecting your system install of Python. It's quite handy, I've found.
In my experience, one advantage is portability. When you build your project around a virtualenv and pip for example, it becomes an easier thing to deploy/manage from my point of view. Also, it keeps your app's working env clean by keeping it's dependencies in it's own environment. I don't mean to say other tools cannot accomplish the same thing, but I love it when I can essentially (assumes virtualenvwrapper) ... cd into_project_dir/ mkvirtualenv my_new_thing workon my_new_thing pip install -r requirements.txt Being able to quickly spin up a project in it's own isolated env has been pretty useful for me in my career. So, even if you don't need to use it for multiple versions or pinning libraries, it's still a good idea in my opinion as it makes your project easier to extend, test, deploy, etc.
Pandas was built specifically for data science, and even more specifically, financial analysis. So it's not a general purpose software engineering library- you can spend years doing Python development, and not once have to use it. If you are not doing data manipulation, it's nice to be just aware of Pandas, in case you need it sometime in the future. Pandas is quite easy to use; anytime I get stuck "How do I X in Pandas" usually gives me an answer in the top 2-3 results. That means there is no need to specifically spend time learning Pandas (other than having a rough knowledge of how it works). Because when you do decide to use it, a simple Google search will be enough to get you going.
I regularly use "py -3.4" vs. "py -3.5" b/c I have some modules installed for 3.4 and haven't updated them for 3.5 yet. nbd.
1. First, read the second thing /u/mailnoff [linked](https://caremad.io/2013/07/setup-vs-requirement/), which is a great summary of abstract vs concrete dependencies with python. 2. He also shared a link showing over 20,000 commits of people having to change their code when another popular code repo site went down. PYPI is meant to outlast any type of version control repo, it's better to link too. 3. Security. I have worked at places (government) where code like this would be considered dangerous to operations, and someone could easily be fired for code like this. 4. Python work environments will be expected to A. have access to PYPI, their own internal mirror of it, or it's contents, and/or B. have a practice in place to bring in external packages. This code is great for working on your own or other random people using it for pure convenience, but it puts a burden on established environments to modify the code before they can use it. I am sure there are other reason / better ways to phrase what I am trying to say, but it mostly comes down to established practice and already solved dilemmas vs potentially temporary and problemsome new age convenience. No knock against the author, he clearly stated this was just a tech demo and I also think it's cool to have code for it. Just wanted to answer your question as best I could at the moment :) 
You probably don't need virtualenv if you're just doing the occasional project for your own use with simple dependencies. If you're doing more than that, virtualenv (or something like it) becomes totally indispensable, and it's actually not very hard to use, so I would encourage you to check it out the moment you run into any sort of version conflict, or want to create code you can share with other people. But for now, you're probably fine just ignoring virtualenv.
Markdown is just more popular- you will find more parsers, more tools that support it. If you are planning to write in the wider world, Markdown is recommended, just because everyone is using it (though be prepared for the *My Markdown is different from yours, just.... because!*). Also, it irritates me that when people link to [John Gruber's blog](https://daringfireball.net/projects/markdown/) when pointing to a reference for Markdown. That blog, written in 2004, is freakin' 12 years old, yet everyone keeps pointing to it, like it's the Bible. With Markdown, if you get stuck, you'll have to search for the specific MD implementation (like Github, Reddit etc). And be prepared for MD that works for one tool not to work for another. Even with these issues, I'd still recommend Markdown, as it has a large number of tools (and increasing), and the problems with implementation are being fixed slowly.
pip?
It's not mandatory at all.. There's a little bit of overhead at first, but it's well worth it. The first thing you'd want to do is take the time to go through your existing site packages, and at the same time install the requirements for your apps into their own virtualenvs using pip. In other words, create and enable the virtualenv for your app, gather what libaries/versions you need, and pip install them. Once you're good, use the following command to create your project's "requirements.txt" from your project's directory. This is Linux specific, adjust accordingly. :) pip freeze &gt; requirements.txt At this point, you have a working virtualenv and all of your app's dependencies declared in requirements.txt. You're now repeatable and good to go. Installing on another system, assuming you have virtualenv there, becomes a quick process of creating the virtualenv, and then using pip's -r switch to install the dependencies from the text file. Also, after you get comfortable with this workflow, I'd recommend checking out tox, here: https://testrun.org/tox/latest/ -- Check that out, I think you'll dig it.
Thanks! Great resource.
Neat.
Why slower? It's just some method calls. Can be done at import time. 
Agreed. You can even go a lot further with re.VERBOSE, and use whitespace to make it a little more readable. pattern = ur''' \b (?P&lt;scheme&gt; (?: https? | ftps? ) :// ) (?P&lt;cred&gt; [^\s@:#/"'&amp;()?{\[\]}\+,;|&lt;&gt;]+ # cred username (?: : [^\s@:#/"'&amp;()?{\[\]}\\+,;|&lt;&gt;]* )? # cred password @ )? (?P&lt;domain&gt; (?: \.? # separating dot [^\s!"$%&amp;/()=?`^{\[\]}\+*#',;:_|&lt;&gt;.]+ # subdomain )+ ) (?P&lt;port&gt; : [1-9]+ [0-9]* )? # etc (?P&lt;path&gt; / (?: \.* [^\s!"&amp;()?`#',;.|&lt;&gt;]+ )* )? # etc. etc. (?P&lt;query&gt; \? (?: [.&amp;]* [^\s!"&amp;()?`#',;.|&lt;&gt;]+ )* )? (?P&lt;frag&gt; # (?: [.&amp;]* [^\s!"&amp;()?`#',;.|&lt;&gt;]* )* )? \b ''' _URL_REGEX = re.compile(pattern, re.VERBOSE) After stretching it out and making the pieces more visible, I'd probably restructure some of that. Those character sets (square brackets) bring in a lot of noise. Maybe break them up into multi-line blocks... maybe split them off into Python variables, then concat it all into one string before calling `re.compile()` . A regexp is a program, there's no reason to make it look like gibberish. 
Why do you care how easy it is to write? Surely you should be worried about how easy it is to read, and this is a fuck-load easier to read than a regex. 
OK you're halfway or more there. Can categories be repeated? or can you assume that they're unique? If they can be repeated then you can use a `defaultdict(list)` as the dict `d`, and extend the value of `d[parts[0]]` with `items`.
I don't have any difficulty reading the regex I wrote. Maybe I've been writing and using them for longer. The stuff in hard to read regexes don't seem to be supported by this library. Positive and negative lookbehind and lookahead, for example (though admittedly I didn't look beyond a quick glance of the source file). 
Don't care for it. 
I am using OSX El Capitan. I don't remember at this point how I installed python, but I have IDLE installed and I run it by going to the terminal and typing "IDLE." This runs IDLE through python. I did mention at the very end how I installed matplotlib. Thank you for your questions, I hope you can help me from here.
 from x import * Please stop.
That's great, probably much more readable than PythonVerbalExpressions could ever be. I'll make sure to use VERBOSE the next time I have to use a regex. In my original comment I just wanted to show that productive regular expression can be veeery ugly, but you and /u/kalgynirae showed me that it was actually my fault, not re's. Thanks!
Google the error mate: [here](http://stackoverflow.com/questions/19961239/pelican-3-3-pelican-quickstart-error-valueerror-unknown-locale-utf-8)
pfft (?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t] )+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?: \r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:( ?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\0 31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\ ](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+ (?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?: (?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z |(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n) ?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\ r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n) ?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t] )*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])* )(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t] )+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*) *:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+ |\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r \n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?: \r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t ]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031 ]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\]( ?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(? :(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(? :\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(? :(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)? [ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]| \\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt; @,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|" (?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t] )*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(? :[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[ \]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000- \031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|( ?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,; :\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([ ^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\" .\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\ ]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\ [\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\ r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\] |\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \0 00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\ .|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@, ;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(? :[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])* (?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\". \[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[ ^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\] ]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*( ?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:( ?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[ \["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t ])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t ])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(? :\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+| \Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?: [^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\ ]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n) ?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[" ()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n) ?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt; @,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@, ;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t] )*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)? (?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\". \[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?: \r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[ "()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t]) *))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]) +|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\ .(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z |(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:( ?:\r\n)?[ \t])*))*)?;\s*) now you can verify the syntax of an email address.
Looks interesting. Have you thought about porting some of the algorithms that have been implemented in Matlab - such as the [LRSLibrary](https://github.com/andrewssobral/lrslibrary)? Obviously forget the GUI but it would be good to have some 'Robust PCA' methods too!
I did. I dedicated most every day to learning
I just wanted to alert you as to why you were getting down votes and no helpful responses. This is the sort of question that /r/learnpython loves so be sure to repost there!
You're right.
I think there is a typo between `(?:(?:(?:\r\n)?` and `(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+`. Could you debug the expression to make sure that it is correct. :P 
The library is simple enough that adding caching would be trivial. It's also not hard for the user to retain the regex object either. 
It's obviously more verbose, but the first one is also quite beautiful.
I think that unless you want to be stuck using this library (and the JS library it's apparently ported from) and never add any other languages to your repertoire, then it would be better to learn regex outright anyway - even if you're using only python in a job, you may not be allowed to use the library, and regex on its own will likely be more useful anyway. As I said in reply to another comment, this is really better as a teaching tool. Besides, there are parts of Python that don't strictly adhere to the Zen simply because doing so would lead to a castration of the feature.
Why not? I see this sentiment sometimes, but people don't seem to explain; I'm genuinely curious
I don't think it would be as useful overall as simply learning regex - Sure, the library may be a good starting point for learners, but if all you know is the library, then you don't have any portability - You need to learn regex before you can do similar things in other languages, or environments that the library is unavailable in. You could argue that people using this library probably don't program enough to need to know any advanced topics, though. It depends how you look at it. 
It could be as simple as adding a `@memoize` decorator; someone could easily send a pull request for that :) I think it could be very useful once you recognize its limitations and accept that it couldn't possibly cover all the same use cases as regex. 
Yes, although they are called modules in Python. You may want take this kind of questions to /r/learnpython.
`@memoize`, you mean? That could work - although I don't think one of those exists in the standard library, it'd be pretty simple to write yourself. &gt; I think it could be very useful once you recognize its limitations and accept that it couldn't possibly cover all the same use cases as regex. That's pretty much what I'm arguing, that it isn't a replacement for regex. As I say, I would personally use it as a stepping stone or learning tool, and it would be great at that. I just don't see it being more useful in production.
I've written a lot of regex over the years, but its always a last resort because of how unreadable it can get when you take your eyes off it. I'd consider using something like this for a lot of simple cases. I sort of understand your skepticism, but even experienced users can benefit from something that's easier to use, even if it means sacrificing flexibility.
Sorry, (autocorrect) typo. &gt; I would personally use it as a stepping stone or learning tool I guess this is where we disagree. I'd use it for the simple to intermediate cases when it's practical, and regex for anything more complicated. There's room for something in-between ad-hoc string manipulation and regex. 
Cheers man will do 
Awesome congrats. Mind if I PM you and pick your brain a bit?
I use pygame for application development and have created my own eventdispatching library that has helped significantly reduce the size and complexity of my code while also increasing drawing efficiency. It is called [EventDispatcher](https://github.com/lobocv/eventdispatcher) and it's essentially a pure-python version of Kivy's eventdispatcher. Unfortunately, I had to drop Kivy due to not having the hardware acceleration drivers on our equipment. So I recreated my own GUI framework around pygame and eventdispatcher. Eventdispatcher has it's own Clock in which you can build your pygame loop around, but it also adds the additional functionality of scheduled events and triggered events. Hopefully it's of use to someone.
You should also look at https://github.com/celery/billiard, which is fork of the multiprocessing package, but with extra features included (https://github.com/celery/billiard/blob/master/billiard/pool.py#L927-L956). Might make your job more efficient
Then why not using the library on your own machine (say in the console) and saving the generated regex for your production code? Sure, it might be slower than actually learning regex on their own, but if you simply dabble with regex from time to time on some projects, it might be worth it to abstract it productivity-wise. 
Yeah but I'd say that for almost anything I've ever used regex for, I haven't really needed the full power of the regex syntax. This kind of a concept creates readable code which means it should be easier to maintain and debug. 
Maybe you work with regexes enough that you can easily read the syntax, but I bet with most programmers it's only something you have to whip out every once in a while, making it hard to maintain fluency. 
I can't disagree, if you have the data in memory and a good idea of what you need then other libraries are fine. Most of my more complex programs using pandas just read in several excel sheets, scrape a few pdf/html/txt files, and output an excel, csv, or json file for future use. Pretty straightforward stuff but some of these programs do four hours of manual work in seconds. Without pandas that kind of thing would be extremely painful.
Pygame is old, but it's great. Like I wrote [this](https://youtu.be/XGxxpNlTlTQ) with pygame (WARNING: Pony stuff).
Thanks for your efforts. I am working on flask now. I will follow your tutorial for Django. :)
Il try this, however could i possibly do the reload(module) command? What would i put as the module parameter?
If you want HTML long descriptions on PyPI you must use restructuredText
The thing is, I can regex. Pretty ok even. It's just not very economical to debug your code and "context switch" to a different language. Every time I have to make sure a regex does what it does, I need to take a minute. That shouldn't be the case, *especially* with "easy" regexes, which i still need to "translate" in my head. That's much less the case with expressive python code, and that's what this enables me to do: not having to "drop out" of understanding the flow of the rest of my program just to understand a string matching pattern. edit: it's also visually more structured and distinct. In nested groups with multiple character classes, it's easy to lose track of what starts/ends where, not because regex is intrinsically hard, but because one character makes such a significant difference which often does not compare to the complexity of the whole regex.
I think he made a pretty fair point.
Call a function and set your variables back to baseline. You can't "reset" python (I don't know why there's some artificial no for/while loop constraint; that's just silly). You could crash your code, dump a variable to a file, and have the parent process decide what to do based on that. I used that approach when I had a Python code that wrapped a Fortran library that I didn't write that bled 50 MB memory each call. Huge problem when you need to call it 5000 times and it wasn't a GUI. That would just look sloppy. You shouldn't be doing that for your code. Solve it the right way. Don't use global variables and reinit the objects. Set everything to baseline. Deal with the edge cases.
I write closures all the time. I love them. But nonlocal? Meh, I think I only needed it once. I just find it rather unnecessary 99.9% of the time.
Should I have a good grasp on Python already to watch this?
Second this. If you didn't kill your shell, try scrolling through your shell history (hopefully there's a windows equivalent). You can normally do this in linux by pressing up arrow.
thanks, now I have cancer
I can *follow* the regex you wrote, but after the initial `^https?` section I have to start parsing the regex to know what it's doing and where it's at in terms of capture groups etc. With this library I'm not parsing anything, I'm just reading literally what's in front of me in the code. That to me says there's a readability advantage with this library. It's maybe less powerful, but we're still writing Python either way you cut it. Readability is a core language feature.
Heh. Welcome to UNIX. Want something really scary? touch "-r" touch "\/" rm * This will now run "rm -r /". Fun times! I recommend reading The UNIX Haters Manual :P
Let me add to the roster of thanks, I bought the book in the fall but didn't get around to diving into it. Appreciate the free course!
What is up with these threads? For real, will any interviewer even ask: "Define python" ??? Or do they make posts like this to increase search engine hits to other parts of the website?
Invalid video id for me...
err ... nopes. Its a home grown framework[1]. [1] github.com/kashifrazzaqui/vyked update: saw it was you after replying rajat404 :P 
Perhaps this is what you are looking for: https://pythonhosted.org/sphinxcontrib-httpdomain/ It has support for Flask, Bottle, and Tornado. EDIT: I guess not if you are using something custom.
Neat.
But the joystick class in pygame only allows you to manage joysticks that are plugged into the computer. To clarify what I want, I'm going to be sending data from an arduino through a wireless serial module, then I want a program on my computer to read that data and do joystick things. So basically I want it to think there's a joystick in it when there's really not but I want to control that joystick with python 
Panda3d and Ogre are commerical-quality 3d engines with Python bindings. Pygame and Kivy will do 2d graphics and GUIs. For something applicable outside of Python, you may want to look at [design patterns for games](http://gameprogrammingpatterns.com/). Games have some almost unique design challenges like how to implement replays (managing the entire game state makes it more complex than undo/redo in an editor). I would also recommend some realtime stuff but I see you have microcontroller experience, so you should be OK for that. Reaction-based games are basically realtime systems. Personally I would just use Unity engine.
Everybody knows Java is trash. 
I don't care for it because it seems to consistently break on my remote VPS. And @DrinkingAndFighting apt-get usually works just fine with python packages. 
2 or 3? I did the python codecademy course, which is 2. The differences between 2 and 3 at that level are basically the print statement vs function, and the division operator. After that I read up on some of the differences between 2 and 3, and used the Dive into Python 3 book to polish my skills further. Other thing that helped me learn is doing a project. Just think of something you want to create: a simple script to gather and organize data, you're first simple GUI app, etc. *edit: just to be clear, I think you should go with 3. It's the future, many import libraries support it, and it has some cool features. 
Check out /r/learnpython and its wiki.
&lt;3 bash.
I mean, isn't this probably because every single person you ever ask (including sidebar here) suggests a material called "learn python the hard way"? 
Grab yourself a book, download an IDE. As for the book, I recommend Practical Programming: An Introduction To Computer Science Using Python 3. Afterwards, check out Data Structures and Algorithms in Python. During which, I recommend utilizing ProjectEuler. Personally, I say stay away from CodeAcademy because it's strictly a syntax teaching platform, so I have a hard time recommending it. Anyways, afterwards you'll be able to figure out where to go to further your development. 
Yes, I finished the course a while ago and was like "now what?!".
I have been looking for tutorials on Python and OpenGL. There's a few that I have found on the subject: [This one uses PyOpenGL and PyGame](https://www.youtube.com/watch?v=R4n4NyDG2hI) [This one uses PyOpenGL and Vispy](http://www.labri.fr/perso/nrougier/teaching/opengl/) For my purpose, I am looking for something that would give me the ability to view and interact with 3D assets, which are modified through python.
I'll check the resources you are suggesting. I did a CS class and was a bit lost of where to go from now on. See you on the riverside.
not suprised. python is required for a ton of entry level IT jobs in the corporate space . 
https://stanford.edu/~mwaskom/software/seaborn/tutorial/regression.html Seaborn will do quite a few types of regressions. Anything more specific requires at least some knowledge of math.
Python 3
&gt; a lot of significant libraries Not really. There are a few, and most have alternatives for Py3. &gt; Follow the community. The community is moving to 3 (slowly, but still moving).
PyThor is like a collection of recipes. All credit goes to RPy2 people. Just standing on their shoulders. 
not really a valid point if you have no clue of what you were talking, he's importing constants made to be used with pygame. just because that import statement is better if not used, doesn't mean it has no uses.
Oh yeah, internet points are so important. /s 
Found some pricing info from one of the python companies http://anvileight.com/prices/ if someone is interested
Not everything will be available in the OS package manager. If you are doing webdev then just about everything will be installable with pip in your virtualenv. If you are doing gui development then things can get more tricky - most of these libraries predate pip+virtualenv. I'd stick to virtualenv, as it is convenient - if you rebuild the virtualenv from time to time, it means you will definitely know how easy it is to install your project from scratch (ie - keep your requirements.txt up to date), and if you accidentally have used other dependencies.
You didn't actually read my comment, did you
http://stackoverflow.com/questions/9582478/how-do-i-read-code-where-from-module-import-is-used It's a post _teaching_ people how to use something. Why immediately use a style that's obfuscating details, and objectively is confusing for new learners?
Check out Elements of Statistical Learning for a good overview of ML theory. It looks at what the algorithms are actually doing, and how best to use them. Then think about how you would like to practice the implementation. R is a good place to start because the libraries are mature but Python has a comprehensive library in Scikit-learn, or you could even try C++ if you really hate yourself.
Some plotting libraries have regression built int. Otherwise scipy/numpy have modules for doing all sorts of regression. If its simply a linear regression you could also probably code up the algorithm yourself with not too much trouble - look up the "Method of Least Squares"
I've read the sidebar and now I'm a master python programmer. Look at my program: def fibonacci(): a, b = 0, 1 while True: yield a a, b = b, a + b
Oh yeah! Isn't this like Unity for python programmers?
But it has garbage collecting, so it evens out.
Because everyone knows java. Right?
Recursion, get! def fibonacci(n): if n &gt; 1: return fibonacci(n-1) + fibonacci(n-2) return n 
 &gt; but now it appears that people are dissing pygame as unsupported, based on an old SDL frame work (Which I didn't like SDL back in c++ in the first place) and according to others doesn't use common framework paradigms common to other non python popular game frameworks. The old SDL "framework" was 1.2 I believe and was quite outdated. SDL 2 got released more than a year ago and is a really stable API where they've cleaned up a lot of stuff. SDL though is not a framework, it is a wrapper around very low level things like keyboard input, window creation and image loading to name a few. You still have to build your own framework on top of that. Pygame is an SDL wrapper much like Love2D from Lua. Naturally, wrappers take time to switch across to the newer versions of whatever they are wrapping. To say it's not transferable is not exactly true, all frameworks have an opinion so at some point they will all have some non-transferable ideas. It will do the common things you expect from a basic game framework, just differently. Have you considered using an established C/C++ game framework/engine and simply writing your game logic in Python? Don't Starve by Klei Entertainment essentially did this by wrapping a SDL engine in Lua.
Taking the Udemy course under the same name. Doing the python complete bootcamp and CodeAcademy lessons first.
The only way I'd've been swayed is if I'd read the article and it'd been an extremely in-depth advanced tutorial on some of the stickier parts of pygame, obviously aimed at proficient coders. But it's "a primer". It's for learners. It's for learners, and it's showing off bad practices, which are especially bad for learners, within the first couple of lines.
But its not pythonic! \s
I like that Python is picking up as a learning language. It's a good language. This is great news! But I think the author of this article should be more careful with his conclusions. He looks at data from 5 (!) arbitrary search terms and makes big conclusions concerning a massive market. First of all individual search terms can be subject to linguistic trends. The fact that an individual search term has had a recent increase in popularity doesn't mean that the thing it stands for is suddenly becoming more popular. It can just mean that it was previously described by different words. “*X* developer” is a fairly standard expression that has been around forever, but “data scientist” is a much younger buzz word. In order to alleviate this the author should *at least* have tried a bunch more related queries, like “java/python tutorial” and “java/python introduction”. Instead of “data scientist” you might look for terms that may have previously described a similar position, maybe in the area of “database engineer” or even “statistics analyst”. The term is actually fairly vague. Secondly, even if we assume that the results are not influenced by the choice of words, the conclusion “Python is getting more and more popular.” is just way too grand. In fact, I'm pretty sure that Python is particularly popular as a **learning language**. When somebody asks me which language to *start with*, I usually respond with Python, because Python is easy to learn. But I also mention that this isn't the only good language and that if you plan on seeking employment as a software developer you should probably learn at least one more “big” language such as Java or C/C++. Python is amazing to get you started and I believe more and more people are starting to realize this. But that doesn't mean it's already overtaking Java in popularity. If, some day, I read “Python overtakes Java in total written lines of code”, I might believe that. And I'm not even going to attempt at judging whether or not that'd be a good thing.
Most of the stuff I make in Java is trash. The fact that many other people found success with it means It's because I am a trash programmer. Not that the language itself is trash. While I do bash on Java from time to time to feel better about myself, I still admit that if I become less trash, my java will also follow suit. It's all about having a positive attitude, you know.
It would help, especially if you start looking into how Classes work, it will help you greatly.
Sure, you can do that, but as I said [in another reponse](https://www.reddit.com/r/Python/comments/3zpgj1/pythonverbalexpressions_regular_expressions_made/cyojoj8): &gt; ...caching the regex object yourself is an extra step, which really should be unnecessary, and isn't given in the example. &gt; &gt;It still has other problems though, if you decide that caching and using the regex object or patching the library yourself is "good enough". It's a totally valid way to use it, naturally. I would just prefer to use `re` directly.
A friend of mine uses Python regularly, but prefers to have all packages managed by the system package manager - including Python packages. I don't agree with him, but it's what he prefers.
Yeah I have a good understanding of lists, arrays, functions, all that stuff and just now getting to classes. Thanks. 
If we implement Java and the JVM within Java, it would hypothetically garbage collect itself and immediately collapse into a single implementation.
The ultimate singleton.
He doesn't sound like a serious dev.
You'd be surprised. I mean, the GNOME team exists!
Now make it not take O(e^(n)) time (roughly). 
http://blog.aurynn.com/86/contempt-culture
Yep. (And honestly, I would put that cache as a global. Shared between calls that way, too)
*use vim
My brother bought me this book for Christmas. It's very good so far. 
Wonderful collection .. thanks
 def fibonacci(n): phi = (1 + 5 ** 0.5) / 2 psi = (1 - 5 ** 0.5) / 2 return int((phi ** n - psi ** n) / (phi - psi))
Luckily, for this script I am just pulling data from an SQL Server, manipulating the results, and then dumping the results into an Excel spreadsheet. Just working with Excel cells, and ranges.
I like win32. Even on windows 10. It works for everything windows. 
had good success with openpyxl. have script to query db and write output in excel spreadsheet. works great
^ this
Shaw has stated that the book shouldn't be used by people who know how to code. Personally, I always recommend it when someone wants to learn how to code.
I would definitely use XlsxWriter for that case, simple and easy.
&gt; “Python overtakes Java in total written lines of code” Even that would be a questionable metric, given I'd put money on python requiring far fewer lines than java to achieve the same thing.
Except not LPTHW, because outdated version of the language.
It depends where you are but I don't think I've ever seen an entry level Python job in the UK.
I'm a language polyglot and laugh at these pissing contests. Language "sucks"? Learn why and don't do the bad things in that language. 
&gt; XlsxWriter Can you read data from an existing xlsx file with XlsxWriter?
You can just export to csv if it's just a table of data that doesn't need any formatting. Panda's works great for this. You don't need anything else
I don't think so =/
No prob. :) I am probably going to use xlwings because the documentation looks really good.
I am talking about automate the boring stuff by Al Sweigart 
That's a good point actually. I may need to just thinking about doing it that way.
I mean, obviously you can do anything on a computer in many ways. You could even manipulate .xlsx files at the byte level with customized C code. I just think the right tool for the job tends to make life easier and Pandas is the best python tool for working with tables of data that I know. However, I'd love to learn about a better solution if one is out there. What do you use and why do you think it's better?
Judging from the error, that library will only work on Linux and osx, it's not written to be compatible with Windows
Just use ADO in vba? Its not hard. Python is great but why do you need to over complicate things by bringing another language into the mix?
How come ive used it before? It worked once but i had to reinstall windows and now i get this
http://shop.oreilly.com/product/9781565926219.do That book has a lot (its more about understanding windows architecture than python) and this link for specifically excel stuff: http://icodeguru.com/webserver/python-programming-on-win32/ch09.htm 
Oh and have fun trying to manage a large VBA code base. Want to use your own text editor? Too bad. Want to improve the syntax highlighting? Not possible. What about version control with Git? Not possible. I am not sure I have met a person that actually likes VBA.
Yeah, I actually have an old copy of that book but just have never looked at it because I thought it was obsolete. I may need to take a look at it though if you think it could be really helpful. Wish there was something more up to date.
It still gives me the same error.
It's almost as if people in Java camp heard about the contest and started a secret flashmob.
Is the "Automate the Boring Stuff in Python" beginners book? or is there a better book that focuses more on the Automation side of things?
pandas has a read_excel function.
It's a pipe. That is how pipes work. Imagine Reader | writer Suppose the writer stops. Is there any reason for the reader to continue reading? It can't write anywhere because it's writer is dead. Why waste cycles reading something that nobody will ever see. So the os kills all processes in the pipe whenever any of them terminate. You don't want a pipe. You want a child process. Either that our you need to catch and handle sigpipe.
Especially because it glosses over SQLites biggest drawback: types. Or rather it's lack of types.
I'm sure it something to do with how os._exit () does or does not tear down the signal handles. You are choosing to use a private method of os, so don't be that surprised when shit breaks. From some other reading python sets a sigpipe handler by default when using popen, and that handler will raise the python signal that the child is gone. So an os signal becomes a python exception. Perhaps _exit avoids this. The resulting parent now thinks the pipe is valid and writes to it getting epipe, and crashes. 
[Take a look at this \(includes zip vs izip\)](https://www.youtube.com/watch?v=OSGv2VnC0go)
Not really, I would be interested in that too. But the term "automation" is kind of broad. A lot of programming projects aim to automate one thing or another or generally make your life easier. So most literature probably focuses on one specific subject rather than "a bit of everything". There are network engineering books that deal with automation, data analysis books that deal with automation, etc.
But wouldn't you still be most likely to do that search if you wanted to learn Python?
PySDL2
did you read the main documentation page? https://openpyxl.readthedocs.org/en/default/
@functools.lru_cache decorator does the trick too.
There appears to be little reason to use PySDL2 for me, It doesn't perform significantly better than Pygame in a lot of instances and I don't like SDL in the first place, I never understood why people used SDL over SFML in C++. I'm probably going with cocos, because it is fairly popular, up to date, and has some longevity support behind it, additionaly there were not headaches with getting it to work with Python 3.x. I'm sick and tired of these devs developing for something that is going to get chopped in the next few years by Rossum any way, 2.7 needs to die hard. 
Thanks for adding to that! :)
The idea that there is no easy way to learn coding is stupid. At the very least there are ways that are *easier*, and LPTHW is not one of them. You don't necessarily learn something better by using a deliberately obtuse resource. I mean if he'd at least update it to Py3 I wouldn't have such a problem with it, but no, apparently Py2 is the eternal best version of Python. Particularly since it is supposedly for complete beginners rather than people who are already programmers who have to get up to speed to work with legacy code. It's just daft insisting on Py2.
The idea is that you probably don't want to just read the csv. You probably want to do something with the data once you read it in, and using something like Pandas makes it easier to subset and manipulate the data. As for whether or not using a compiled package is a bad thing - I guess it depends on your use case. Sure if you are writing a package that you want to distribute to others and it's very important that it's lean as possible and easy to install, then yes, avoid something like Pandas. But if you are just writing a script for data analysis (probably the use case for like 95%+of people online asking questions about parsing CSVs), then who cares?
Sarcasm?
If this is based on [the Node.js module](https://github.com/ferno/base65536) then no, there are no control characters, non-characters, surrogates or other unsafe characters in the encoded text.
For real. The whole point of Fibonacci numbers is that you don't have to calculate them directly. And yet we keep fighting about recursion vs. iteration. 
Whatever SQL DB you end up using, please consider using sqlalchemy.
No. Anyone who seriously does data science probably uses both. I know both very well, and work with some data scientists who only know r. They have a much harder time with obtaining data from the numerous sources a data scientist needs to deal with to be fast and effective. 
[This documentation should be a good start.](https://ipython.org/ipython-doc/3/notebook/public_server.html) As far as allowing other servers on the same machine using nginx, you'll just need to set nginx up as a reverse proxy and point it towards the port you set up your IPython server on. *Edit: A caveat of this though. If you provide credentials to anyone in order to utilize this server that aren't completely trusted, realize you've just opened up a major security hole into your system. 
Seems like a horrible idea. Maybe Haskell's immutability probably ruined how I think about these things though.
That's what they think.
&gt; In fact, I'm pretty sure that Python is particularly popular as a learning language. It is. But it's also incredibly popular as a data analysis language, a system scripting language, a web development language, a scientific array programming language, etc. etc. Python is not as popular as Java, but it's still the 4th or 5th most popular language on the planet. That's not all students. A large number of tech companies run their entire stacks on Python. Youtube was written in Python. Dropbox is written in Python, both server and client. Investment banks trade billions of dollars based on routines and models written in Python. 
That is good to know, Thank you.
Well that would mean that Python have overtaken Java in total amount of functionality used! :)
Take this metric for what it's worth. . . I *finally* found a position at a Python shop and I LOVE IT!!!
These are amazing lectures. Is exactly what I've been looking and waiting for. May your 2016 be a blast and full of Django force! Thanks.
i agree. it's overrated. I say just do video tutorials, build things, and pick up new material as you go on algorithms and more advanced subjects. that's how you learn. by making projects and figuring things out by yourself and progressing. the only real strict learning material should just be an introductory tutorial series on youtube you can follow along with that introduces all the basic concepts up till classes and lists. imo. also, java and python are quite different as far as i can tell. I don't see many real full applications with good guis made in python, maybe i'm wrong. for some reason i'm under the impression that python isn't really good for making bigger, more fully implemented standalone products. am i wrong?
Being able to index by integer and datetime has been extremely useful in a general context and also pandas built in date manipulation in general is very useful. For me pandas shines when your data has a time series component. Did you know pandas will give you business days for a given week/month/year and business hours. http://pandas.pydata.org/pandas-docs/stable/timeseries.html
Realistically, what determines the new programs of the future isn't how well they manage memory (though that is relevant), but how the higher level pieces and ideas are put together to form new discoveries. Such programming requires equal, if not greater intellectual power (and creativity) and it shouldn't be considered somehow "lighter." Though obviously the best coders should have a grasp on everything, generally. In my personal opinion, the idea that memory and "hardware"/"machinelanguage" concerns are somehow of primary importance for every advanced engineer programmer, is kind of faulty. I think what makes a truly advanced engineer (programmer) is not simply the speed of the propeller, but whether her engineering blueprint even will allow the thing to get off the ground.
A Byte of Python is the best book for first time coders IMO
No need for `groupby` there: for el in data: grouped_data[el['animal']].append(el['name'])
I think Python is illegal in the UK, or at least discouraged.
This Is Good For Python.™
Thanks! A friend of mine asked me about a good video series about Django the other day. This might be the perfect start for him.
Her Majesty doesn't find Python amusing?
You lost me at the 'let' keyword. Sorry mate but I rather dealing with ruby python and react in same project. 
Prob python... So damn easy to start!
Too late!
Well, not for fast data access. SQLite is good - until it grows over a certain size.
There's Yhat ggplot. Albeit it has a ways to go to be used seriously.
&gt; What is extremely valuable, however, is the combination of a strong standard library of stats functions, the intuitive plotting, and the ease of Rstudio for rapid visualization. Not just the standard library, the huge amount of available additional stats packages is another strong point for R. I generally agree with the sentiment that Python is much better designed as a general purpose programming language, though.
I don't see any CentOS 7 python 35 packages here: https://dl.iuscommunity.org/pub/ius/stable/CentOS/7/x86_64/repoview/ and if I run yum --enablerepo=ius-testing install python35 I get 'no package available'. Any thoughts? 
Time to get rid of python's `global` and `nonlocal` then var is function-scoped, let is block scoped, no keyword is global scoped
Kudos for working on this, I think it's really valuable to have more people thinking about ways to distribute applications. However, from my experience working on [cx_Freeze](http://cx-freeze.sourceforge.net/), there are quite a lot of packages which don't like being loaded from zip files. That starts with compiled extension modules - does exxo have any way to handle these? - but even among pure Python packages, there are many that don't work from a zip file. We had problems with `requests`, for instance. Because of the large ecosystem of packages like this, I think that the only reliable way to run Python applications is with a real directory structure of multiple packages, even if that's unpacked at runtime into a temporary directory. I agree that Go's single-binary approach is nice, but Go was designed from the start to work like that, and Python definitely wasn't. I maintain a tool called [Pynsist](http://pynsist.readthedocs.org/en/latest/) to build Windows installers for Python applications, and this was one of the key principles I followed when designing it: the installer itself is one file, but what it installs is a directory with many files. I think the primary issue for Linux is the lack of a decent common application packaging format. I [had a go](http://batis-installer.github.io/) at a solution for that too, but I couldn't convince many people it was a problem that needed solving.
In the dim and distant past we used to use the first part of this (no brackets) for job interviews.
And Python will happily accept numbers = [0, 1, "derp"] Same thing.
Is this what you wanted? from decorator import decorator @decorator def self(this, self, *args): rv = this(*([self] + list(args))) if not rv: return self class Cow: @self def test(self, noise): print(noise) my_cow = Cow() my_cow.test("moo").test("Moo") $ python self.py moo Moo I doubt it's robust enough for production, but I bet you could fix this up quicker than you could bugger about fixing Windows (again). I dunno what you'd do if your function actually has a return value that you want to use. You'd need to decide that. EDIT: So I'm told this doesn't work on Python 2. I have no idea how to fix that. Sorry.
I find this behavior completely retarded. The most sensible option should be the simplest and the default one, not the other way around. Everything should be as local as possible by default, and then you can change the scope with keywords. Python has it much more right, in my opinion.
The article is not written very well at all. At all times the author is trying to convey the idea stated in the title but I didn't see a proper reasoning behind it. All he does is reporting someone's quotes that are not backed by any facts except for a couple of assumptions that don't even have a solid basis (namely the top programming languages chart). IMO he just tried to make an impression.
Global and nonlocal are for scope access, let and especially var are for variable declaration with scope management. I should be able to declare variables without keywords. Scope management should be explicit, variable declaration should have default behavior. 
Django does all you need (and more).
I recommend flask flask.pocoo.org
Me too, but it seems that xlwings does more than just read and write Excel.
Why not Django?
Sorry, but I don't see how sqlite is a replacement for Postgres or Mysql. Per the blog &gt; If you haven't heard, SQLite is an amazing database capable of doing real work in real production environments. .... Have you ever managed a Postgres database? .... Per the official sqlite website &gt; SQLite does not compete with client/server databases. SQLite competes with fopen().
Django is well integrated. This means no need to reinvent how to put together all components, so you get time saved and less opportunities for bugs. The app described here really looks like every other "enterprise" app out there and you don't seem like someone who has a lot of experience, so I'd stay away from DYI solutions. Flask is nice, but it will cost you time and effort to pick and integrate all the parts you will need. Also every django project has the same parts in the same place, so any django developer in the world can get in and will know what is where, so you can get help easily. Every flask app is different "because I've decided to use this db and that library and combine them this way" and now you are on your own for all the problems solved in django long time ago.
There isn't currently a version of python35u in the testing repos. Do you have the stable IUS repo enabled?
I don't get why I'm downvoted though, so if someone asks "can you read excel files with the print statement?" The answer is "yes, with panda!"?
I am not actually seeing any evidence supporting the title, only speculation.
I haven't used matplotlib directly in a while. I usually plot through pandas or seaborn (or more often a combination of the two).
Well anecdotally, I started learning R but switched to python when I kept running into python solutions for my problems through google searching. It just seemed more intuitive. R is probably fine for a lot of analysts but python is a much more robust tool. Sometimes though I get the impression python community looks down on R the same way C++ community looks down on python...
Peewee.
Yes, I unpack shared libraries to /tmp, import them and remove. It's the only instance when something has to be moved from the archive at runtime. Unfortunately dlopen() from a memory buffer is next to impossible, at least on Linux/glibc. I hope to bring at least major players to zipapp world (especially Django). Maybe others will follow then. I think the number one reason zipapps has been traditionally neglected is lack of C extensions support. Exxo supports them now, but I'm sure Brett will solve this issue with his zipimport rewrite (at least in Python 3 world). Once C extensions are usable, zipapps will become much more practical and maybe more people will pay attention. &gt; Make sure you test with an https URL, if you didn't already. You're right. This one doesn't work. [This single line of code](https://github.com/kennethreitz/requests/blob/master/requests/certs.py#L22) is guilty and also easy to make zip safe. After quick patch, ssl works ok. Looks like I'll go on a pull request spree soon. :)
It's built on top of PyRun, which is already very portable: https://www.egenix.com/products/python/PyRun/#Download I want to start with Linux version only and make it work reliably. Later it should be possible to pull the same PyRun+zipapp trick on all major platforms. Also, one silly reason for lack of portability is that I simply have no access (or experience) to Mac and Windows. I plan to figure something out, if the whole idea proves to be solid.
Dropbox bundled python for years (not sure if they still do) for each OS. http://stackoverflow.com/questions/2678180/how-does-dropbox-use-python-on-windows-and-os-x
Yes, there are also many different ways, like cx_Freeze. Glyph writes about few in the [linked blog post](https://glyph.twistedmatrix.com/2015/09/software-you-can-use.html). Exxo is just another approach to the problem. The reasons I like it are: * one single binary file. no unpacking, no installation process, etc. * simple, straightforward implementation with fairly few hacks (if any) * the same tool for all platforms: pyrun+zipapp approach should work everywhere, even if exxo is Linux-only at the moment 
Those are good points thanks ! How do you go about specifying permissions of who sees/modifies which column of which table in django? Is it easily done?
Thanks for your reply and for the links ! How do you go about specifying permissions of who sees/modifies which column of which table in Flask? Is it easily done?
Not short, but this is game-y https://github.com/tito/cymunk
The most important reason is really summed up by the first two bullets. It enables different projects to use different, potentially incompatible environments. The third bullet point is missing that different machines can mean different users. Your collaborator ten cities away can run an identical environment as yourself, and neither of you have to compromise the systemwide python env.
thanks
thanks
That would actually be done via other packages. Flask doesn't explicitly include an ORM or even the concept of a database. It's more of a choose your own adventure. The advantage is that you aren't tied to a single implementation. Even the Django developers don't always get it right. The downside is that you have to find the right package as it's not always clear which package will work best. I'd recommend starting with [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org/2.1/) and exploring the permissions packages that work with [SQLAlchemy](http://www.sqlalchemy.org/).
I've never needed this, so its not based on experience, but there is a number of options listed here: https://www.djangopackages.com/grids/g/perms/ I can tell however that every case is different (that's why there are so many options), so without knowing all the details its hard to advise. Perhaps much simpler logic in your app will do.
[Pyramid](https://github.com/Pylons/pyramid) is a great framework. It has a great set of plugins and it's more pythonic than django/flask. The routing in pyramid is also much superior, not to mention the dependency injection is way better than the global state of the request that flask has. Not trying to bad-mouth flask, just trying to show an alternative.
I forgot about working in a team - indeed, it helps a lot in such situations. Thanks.
I fully understand wanting to avoid the build process in C/C++ especially when deploying across multiple platforms. I use framework and engine kind of interchangeably being a mix of a web developer and a game programmer, Ruby on Rails would be a framework with lots of bells and whistles as Unity would be an engine with many of it's own. This is why I refrain from calling SDL a framework as it is quite literally a wrapper and nothing more which makes it less comparable to SFML and Slick2D which are slightly more fleshed out like you mentioned (batch draws etc.). I haven't dived into PyGame yet but if it's closer to SDL as an API than Slick2D then I'd probably recommend just implementing batching yourself. It'd be less time consuming than wrapping your own C/C++ engine. What other common paradigms are you looking for out of curiosity? More high level things like SpriteManagers that handle resource loading and unloading?
Also, when deploying your app.
&gt; it also applies to things like environment variables. Great point! To expand just a bit, use the ``postactivate`` script in the virtualenv's /bin directory like this: $ mkvirtualenv test $ cdvirtualenv $ edit bin/postactivate # in postactivate export SOME_VAR=some_value This is useful for e.g. Django projects where you might want to set something like ``DJANGO_SETTINGS_MODULE``. Another good technique is to use environment variables for sensitive strings like database passwords. Instead of hard-coding them in your settings file, you can set them as environment variables in ``postactivate``, and read them in your settings file using the ``os.environ`` module.
This sounds like a solution in search of a problem. Why Atom in specific? What are you trying to accomplish? Why not Jupyter?
Flask or Django ? Both ! with ImportD (the D is for Django) http://importd.readthedocs.org/en/latest/ it's minimalistic (we can get started with a single file à la Flask) but it's 100% django, with all the built-in tools.
text1.get() is the function call text1.get is the object that is a function
Yep, missing parentheses. :0)
haha it was something that simple? im stupid sometimes :P thanks!
Nice work so far. Is there anywhere I can set headers or proxies? Also, I see you convert css selectors to xpath. Can you give me the option to write my own xpath? I prefer xpath over css selectors.
Ehh, not a bad idea just to learn it, but using SQLite with Python is extremely simple compared to client/server databases. Abstraction isn't quite as important for small apps storing data with SQLite.
For starters, create your own python application (simple is fine, but complex gets bonus points) and create a build script / system that creates a windows installer for your application. The installer should package the python executable and all libraries that your application needs. You might also need to throw in any dll that are being used by your app and might be missing on the user's system. Now, do all that without using stack overflow (that didn't exist when Hammond created the first python installers). Also, your installer(s) should encompass all the different kinds of windows systems (xp, 7, 8, 10, etc, 32 and 64 bit). Now, make the installer build script smart such that it can pick up new dependencies automatically (minimal manual intervention) and package them whenever dependencies change. Also, document the process so that others can use it. Once you have done all that, I think the respect will arrive automatically. People get paid $150k+ per year for doing similar work at my place. Mark Hammond did this for free... I would think his work is worth at least half a million dollars.
&gt; The fact that you can't see "one big thing" that he did means he's done his job incredibly well. Well said.
Your linter may catch this. What tools are you using?
Step 1. Fix your tools. A good programmer knows which tools to use where.
On the frontpage of their site it states """Imba.interoperability Imba compiles down to clean and readable JavaScript. Use any JS library in Imba and vica-versa."""
Yes, "explicit is good" is one line of the zen. &gt; Beautiful is better than ugly. Simple is better than complex. Sparse is better than dense. Readability counts. aka avoid boilerplate
thanks for the links!
[removed]
If you have the chance or the time, please, list the pain points. I'd love to hear them.
JSON is just a simplified syntax for describing a dictionary, for our purposes here, but it's non-executable code and extremely fast to parse using the `json` module.
&gt; I'm just writing it in IDLE... Is that bad? Generally yes. There are free IDEs out there (Spyder, PyCharm, WingIDE, Eclipse+Pydev), with some having paid options as well. IDLE is super simple, but OK for learning on. I like WingIDE, but there isn't an auto-linter like in some others.
Oh, zope is a pain indeed, agreed. The routes is one of my favorite things about pyramid, but yeah, not doing them right can be a bit painful. About the deploy, yeah, there are many ways to do that and depending on your choice it can be little bit weird. Pyramid gives you more freedom than flask in some ways, making the choices have a bigger effect on the code base. You can choose a better routing and not use zope. The good stuff is the predicates, the dependency injection and the renderers. 
Ok thank you for the info. Could you reccomend one for someone who is at a begginer/intermediate level of programming? Thanks!
Ok, well i'll check out Spyder first and WingIDE. Thanks :)
This is one situation where I would recommend Django. Haven't used it in years but it has stuff for mobile backends (basically you'll look for something involving JSON/AJAX)
I'll echo this and recommend Django REST Framework for crafting the API. 
The java example at the start doesn't compile....
Pyramid it's a best choice. http://docs.pylonsproject.org/en/latest/docs/pyramid.html
What's that, actually? @app.route('/ajax') def im_ajaxy(): if not request.is_xhr: return 'Go back to web 1.0, mate.' else: return '&lt;data here&gt;' 
Sounds like you've got the idea. For the most part, for a single small project, you can probably get away with not using `virtualenv`. On the other hand getting `virtualenv` set up and learning to use it is actually a very small investment, so if you plan to do other possibly larger projects in the future, there's not much reason not to start using it now. It might save you some time now, and if it doesn't it will down the line.
Also don't forget he literally wrote the book on Python development for Windows: http://www.amazon.com/Python-Programming-On-Win32-Programmers/dp/1565926218
DJango is probably better for getting that done. I use Flask, but Flask is a micro-framework. Flask is good if you need extensibility and the power to customize it to your needs. It works for simple webapps with fewer pages but higher vertical traffic. Django on the other hand has a lot of stuff done for you and will give you trouble having stuff done other way. The ORM sucks, Jinja is better at templating, etc. But if you need to build an horizontally large application that can make good use django's community already made-and-tested modules, then it's the best choice.
i like cookie idea by hell_onn_wheel (one less site i have to signup for), Give a recommendation after 5 picks, pick more for better recommendations Not really bothered if it forgets my picks for the next session. 
&gt;This is why I refrain from calling SDL a framework Ok, I guess I agree with that sentiment. &gt;I haven't dived into PyGame yet but if it's closer to SDL as an API than Slick2D then I'd probably recommend just implementing batching yourself. It'd be less time consuming than wrapping your own C/C++ engine. I use cocos2d, went through the tutorials, seemed great, albeit with really shitty documentation. The nice thing about it is that it gives you access to all the lower functionality you would need (opengl draw calls) while also implementing quality of life functionality. Additionally a lot of it is heavily reliant on pyglet, and so functionality learned there transfers to even other python wrappers/frameworks for games. Its more like libgdx in a java comparison. 
JS -&gt; CoffeeScript -&gt; Python Easy to translate code between them once you know CoffeeScript.
Either should work fine, Django has more configuration stuff you might need to worry about IMO.
pySFML doesn't seem to be highly supported, and pySDL2 doesn't seem to be as supported as cocos2d, which had its last major update (though github is still being updated for it) in 2015, while SDL2 had its last update in 2014. I found cocos2d to be a fine choice because it didn't try to redo things other frameworks/wrappers did that weren't broken, and thus uses a lot of pyglet and allows direct use and integration of pyglet types and functions through it, as well as other libraries that function in tandem with pyglet. Additionally it handles the "pythonic" part of code decently in my opinion. My big problem with it is documentation, though the tutorial has taught me enough about it so far. 
I also did 3 years of Rails development, before going to the scientific side. ASFAIK, Django/Pyramid is the equivalent of Rails, and Flask is the equivalent of Sinatra in the ruby world. What problems did you face with your Flask project ?
Django has more bells and whistles built into the framework. This makes it easy to get common things done (user management, forms, logging, task queue). Of course you can do all that stuff in flask, but in django it's a well marked path. It's when you want to wander outside of the path that django can be frustrating. If you are only serving a REST API from your backend, I think django's extra features can get in the way. If for example you want a REST API except for an admin interface, django starts to look more attractive. 
Basically, I didn't code it for several months, then I returned to it, and it looked Greek to me. No code left, sorry.
How?
It doesn't. I guess the point is you shouldn't bother to use Postgres or MySQL if you don't need to. For certain tasks, they're overkill.
'echo %PYTHONPATH%' in cmd, the directory opencv is in should be in there. The default directory for python packages is 'python install dir'/libs/site-packages
React uses inline HTML as well. It makes sense when you realize that all this time what we were separating is technologies, not concerns. Since AJAX is a thing both concepts (markup and scripting) have a big overlap.
Yeah, I've been copying cv2.pyd into that directory. The folder I extract from the .exe is just in C:\ though
Here's my thought. Build a simple API + Frontend that consumes it with both Flask (look at Marshmallow + Flask-RESTful for the API) and Django (I'll begrudgingly recommend django-rest-framework). Which implementation was easier, nicer and one you'd like to grow? 
This is interesting because im just learning Python and i only use IDLE. Is it hindering my development and should i be using something else instead? 
So /u/thanks-shakey-snake got it right. It was idle that was the problem. Thank you for your assistance!
Turbogears. Based on ~~Pyramid~~ Pylons. http://turbogears.org/ I use this for larger projects because like Django it has a lot baked in but easily cusomized. Unlike Django not many talk about it. Edit: based on Pylons (thank you mcdonc.)
Pyramid is not a very opinionated framework in the same way Rails will be. You'll find it's more of a glue and less of a workflow. Jump on the freenode #pyramid channel if you have questions and you can learn it pretty well. Django is quite opinionated, comparatively speaking, and may be more comfortable. I avoid it these days, but it's not a bad starting point. Flask is dandy for smaller projects, but then if you want to do bigger things it can be a bit of an up-hill battle, especially for newcomers. I'm not saying it can't be done, as it can and I have done so in the past, you just have to plan ahead for it or things quickly become a practical rewrite. If you don't go with django, you can also look at SQLAlchemy, which is just fantastic in every way I can think of.
Twitch has the creative section and I think it's the perfect fit for. There's plenty of not gaming-related stuff on Twitch and it really is the best streaming platform right now. Go for Twitch and don't think twice about it.
Use a proper IDE like PyCharm that has suggestions and linting, you will learn faster that way.
As someone who is just learning Python, is Flask to Python as Sinatra is to Ruby? And is Django similarly comparable with Rails?
Thank you very much! I'll look at it tomorrow!
Wow, that's quite an extensive library! Is there an algorithm that you're particularly interested in? 
I always recommend Pycharm to newcomers, it's a very capable python IDE. Personally, I use sublime text, but my use case is somewhat unusual and I like the control I have over every part of my editor, while Pycharm is more of a "batteries included" package. Things are already set up, but you have fewer options to customize things. For many (probably most) this is just fine. 
When I got into pyramid, I looked at tutorials and just couldn't get my head around what the heck was going on. Eventually I just started writing code and seeing what happened to poke at the black box. We use Pyramid with Cornice to make a REST app consumed by an angular front end at work, and I use it for some forum software I'm working on in my own time. I'd just dive in and setup an environment to start.
&gt; Haven't used it in years but it has stuff for mobile backends what exactly do you mean? I'm weary of big frameworks when dealing with my apps, which is why I have been going with flask (successfully). I had the worst time trying to get token authentication to work with django
what is a seed app?
Looks like Welsh.
Seconded
Point 1 is possibly legitimate, which is why I suggested talking to an editor/ide vendor to have them package it. The JVM *is* everywhere though. Points 2 and 3 are just someone making something up to avoid having to do any work. If they were in anyway true, we'd be seeing IDLE in programming shops.
Cool, I was aware of the sort of generalized categories, I just wasn't sure if that was really the right place for non-video game related programming though. Thanks for the recommendation!
Nah, there's too many Zs. It's like the unholy offspring of Welsh and Polish.
I guarantee you that a bike that you pedal backwards will be worse than one that's pedalled forwards, unless you happened to have your legs reversed in a rare Star Trek transporter accident.
Django's ORM doesn't support composite keys. 
The answer is always vim... just kidding if I were you I would look into Pycharm.
Thirded-ed? Twitch actually rewrote their Terms of Service to encompass gaming and anything creative (including programming). I'd watch some streams of programming or VODs if people did it in an informative manner. Actually though about it with PHP, but I'm no expert. I say go for it.
It's a philosophy thing, I think. Python likes to claim that it has the batteries included and while, yes IDLE isn't great, it works and provides a functional way to get started. If people get into it more they can evolve to the more powerful editors.
Wow! I had no idea anyone legitimately used IDLE, let alone recommended it! It always just seemed like some unusable little example program, not something you would actually edit much code with..
For one thing, Pycharm is very much for python development. I also write in other languages like C and Haskell, along with other more obscure ones. Having one tool with all the same keyboard shortcuts is really nice for me. Sublime is also much less resource hungry, startup is almost instant. I have a large number of small to medium projects and being able to switch between them quickly is a must. The multiple selection features are awesome, and the large number of plugins is nice. Really, the killer feature is being language agnostic and being so extensible. To be honest, for those reasons I've been considering also becoming proficient with emacs, I've tried vim for quite a while and never got the hang of it, but maybe with emacs it could be different. I just really like language agnostic editors with most of their functionality coming from plugins. It requires that the editor be flexible and abstract, attributes that also go well with programming languages, algorithms, and other CS concepts. 
Developer here. This software is still in alpha, and lacks in both handling some reST features and style extensibility, but is still pretty much functional. I made this for another project of mine where I needed to render some document parts over the terminal, and decided to give reST a go. As always suggestions are welcome.
There's also a section called programming, you could try both and see how it works out.
Have you tried customizing the available themes in either?
Replacing IDLE with Jupyter would be a bald move in the right direction. Not only has the Jupyter notebook been established as an excellent teaching and presentation tool but it is also a bunny trail for Python/Javascript integration which still needs to be fleshed out for other than the notebook projects. 
The newest version on PyPi should support caching and transmission-remote calling. :) I can't find a mac os x version of transmission-remote, so I can't test it on my machine. I wrote this based on pirate-get's transmission code, so in theory it should work fine. Thank you for all your suggestions!
That's actually in the lost tongue of pelagic horrors. I'm pretty sure N'Larl'thyop has just been summoned from the abyssal depths. 
Learned about string.translate() recently and very much expected to find that at bottom after seeing the 13 character offset. "Batteries Included" is a wonderful thing.
There should be one-- and preferably only one --obvious way to do it!
or just use the rot-13 encoding if it's in python 2. print 'Uryyb, Jbeyq!'.decode("rot13")
Just so you know, Django has had built-in support for Jinja2 for nearly a year. ;)
Getting OAuth2 to work with django rest framework took me like an hour
This is a solid idea, but there are a lot of corner cases to consider. Would imports work? What if the python versions don't match? You could preserve STD{IN,OUT,ERR} by running a couple of lines of initialization code on the remote interpreter that redirected them back into the ssh pipe. You should also take a look at [Ansible](http://www.ansible.com). It's modules accomplish roughly the same result, though through a different mechanism (files are copied then executed). EDIT: similar projects include [execnet](http://codespeak.net/execnet/index.html), [pushy](https://github.com/pushyrpc/pushy), and [rpyc](http://rpyc.readthedocs.org/en/latest/index.html). I had a project a while ago that involved remote execution and I did some research :)
On Python 3, that doesn't work (`decode()` only exists on bytes objects, and `rot13` is no longer a valid codec for it anyway on Python 3). So the Python 3 version of `this.py` has to manually decode.
Way too many vowels to even be related to Polish
The best options I saw when I last looked were [Livecoding.tv](https://www.livecoding.tv/) and [Twitch](http://www.twitch.tv/directory/game/Programming)'s 'Programming' or 'Creative' categories. At the time, Livecoding was just getting started (it's still pretty new) and you would find more viewers on Twitch. I'm not sure what kind of audience you are trying to find. The audience on Twitch were mostly beginner level programmers. This is good if you like to educate, but perhaps a bit less so if you'd rather discuss more advanced topics with your viewers. Livecoding seems to be growing. There seems to be pretty active development of the platform as a whole, though the user growth still seems slow. It seems like a good place to establish a presence and audience for yourself. There are some interesting features there, like the option to offer yourself for hire for private sessions at an hourly rate that you set, similar to [CodeMentor](https://www.codementor.io/). I suspect this is where they aim to get revenue eventually, as I haven't seen any ads (Twitch ads can also be eliminated, but I think that requires paid subscribers). Anyway, I hope the evaluation helps.
It's fine for a lot of web apps, but out of the box it caters to the lowest denominator so go track down extra libraries to use all the data types Postgres has in it. It doesn't use the same abstractions as SQL unlike SQLAlchemy so instead of writing normal groupings they have this weird aggregate/annotate thing going on; they have this weird Q construct (when you want to use an *advanced*(?!) feature like an OR clause); their default nullability is reversed; they don't provide a powerful API like SA to model any query you want to do so if you want to do anything like CTE, subqueries of any complexity, etc. you are going to drop to raw SQL; and they presume you want a lot of validation in the web layer so like, when I was using it last if you made a Boolean field in an engine that didn't support it natively they do the usual thing and make a 1 or 0 but they don't like, put a check constraint on there, because presumably some higher layer is validating all that. Those are all just examples off the top of my head because I don't exhaustively catalog these things but in general you will find SA does everything right and Django does many things right, a couple things atrociously, and a good few of things not at all. Django does have nice easy ways of constructing and querying M2M relationships where in SA you have to write out the join tables by hand typically (though of course you can make your own many_to_many whatever to use if you want to, it's not part of SA proper).
Easysnmp is the only one of these I can actually recommend. Pysnmp is slow, and snimpy is based on it, if I remember right. They were also both much harder to use. I wanted Easysnmp to be more function-based instead of class based, but I ended up finding it significantly easier to work with. 
Going with only zip files and hoping the entire rest of the python ecosystem also makes every bit of code they're using zip-safe is a complete and utter dead end, IMHO. The zipapp module was just to make something that unofficially worked (*"psst, check out what you can do with some hashbang magic and a zip file!"*), officially working. *When it already worked*. It has **0**, **null** to do with getting any code that wasn't zip-safe, suddenly zip-safe. &gt; Also, adding zip safety is often almost trivial Famous last words. Before you go: "oh, just change this line here..." `&lt;exception trace&gt;` "Oh, and these two here, yeah..." `&lt;exception trace&gt;` "Oh, yeah I forgot about this module." `&lt;exception trace&gt;` "What, what is possibly stopping it now..." *looks around codebase for an hour* "Oh, this was calling into a third party module here, with a file name... hmmm... I hope the maintainer is active atm..." etc. At this point your tool gets uninstalled again. I'd strongly suggest just making something that extracts files onto the actual file system as either a first-run step, or a simple installation step. Doing so will make everything that much closer to *just working*. Without yet another tool that stops at X arbitrary point along the way, wanting to developers to do Y, but not actually... *just working*.
I found something in the other direction but they can be useful too: * [Javascript for people who know Python](https://www.youtube.com/watch?v=GAoheEUiwwY) * [Javascript for Pythonistas part 1](https://www.youtube.com/watch?v=OyavJFwEZFo) * [Javascript for Pythonistas part 2](https://www.youtube.com/watch?v=4-4hTwlzTMk)
Technically '.project' is the extension so I would expect (' ', '.project'). Or am I looking at this the wrong way?
I wonder if he used Vim to do that? In Vim, you can run text through a rot13 cipher by using the command: g?
I'd say that `.project` is a file name without extension. But that's probably because Linux has quite different semantics here (on Linux a file with a name starting with a dot is hidden by default). How do other Windows programs handle file names like this?
That's part of the joke. Implementing rot13 from scratch instead of just using the built-in functionality is considered unpythonic, hence why it is used in the very module that tells you so.
Cesar is going to be pissed. I would not want to be Guido even if only half of those historical stories are true.
If it were ONLY an API and backend and would stay that way, then I would use Flask. But this sounds like a shopping cart / payment service site, AND an API, AND background tasks. Django helps with all those things (the ORM, Django REST Framework, easy integration with Celery).
Find the source code of some programs you like. Search "python source code games or whatever" http://www.google.com/search?q=python%20source%20code%20games Or this script downloads porn https://evilzone.org/scripting-languages/(python)download-porn-script/ Start changing it to do some things the way you like. Now stop watching porn. Really. Stop. You cant program if you are watching porn. Start collecting scraps of code to reuse for your favorite menus etc. Also download and print out a few good cheat sheets. http://www.google.com/search?q=python%20cheat%20sheet I never should have linked than python porn downloading script should I?
That's correct. There's also Pyramid which is somewhere in between Flask and Django.
Do you have a raspberry pi or something equivalent like a beagle bone? Because with something like that, you can break out into a wide range of projects. One of the best things about python is the vast module system so if you need to blink LED or scrape a website, python has you covered. 
It is perl6
You don't need anything for this that isn't already present on a standard unix-ish system. Just pipe your python script into an ssh command to run the python interpreter on the remote. It's a remote full program run, not a remote function call, but I'd wager that for most real use cases, this is what you want anyway. It also works for any interpreted language, not just python.
An attacker with ssh access can do these things already, this doesn't create a security hole that isn't there already.
I updated my Python code like [this](https://gist.github.com/korpf/1002db3555e577809b9a) but it still doesn't work.
Holy shit rot13 is built-in? That's hilarious.
I would recommend looking at third party db migrations tools like Flyway or Liquibase.
* Find some small thing to automate. * Break it down into steps. If it turns out to be a much bigger problem than you thought, go back to the first step and pick a different problem. * Automate it. (ie. write the code expressing those steps; package it into a script in the standard `#!/usr/bin/env python3` .. `if __name__ == "__main__":` manner; then run that script when needed) * Accept that until you get reliably good at it, this is often going to consume more time than doing the task manually. It's more of a learning investment. * Repeat. Try to do things as cleanly as possible each time, and search for standard ways to do things (eg. writing idiomatic Python; searching for stdlib or pypi modules that solve your problem rather than rolling your own X) * Scaling up to serious programs is fairly natural: just pick a larger task. Be sure to break the problem down fully before you start coding. (I'm hoping you're a Linux user here, because the Unix philosophy primes you for this kind of thing. But if you're on Windows or Mac, there's nothing stopping you either.) Examples from my bin/ directory: * automatically rename a set of files with some bad numeric prefixes/suffixes to have good numeric prefixes/suffixes (for example, foo1.txt foo2.txt ... foo9.txt foo10.txt, should be renamed to foo01.txt foo02.txt ... foo09.txt foo10.txt so that the number of digits in each suffix matches.) * Take several text files with words, convert each into a list, randomly select a word from each; join the random selections together to create a possibly-interesting amalgamation of concepts. (if you're not getting this, think of the identifiers used by gfycat, like 'PettyBetterEel') * Randomly shuffle the modification times of a list of files (I used this to effectively convert my file manager's 'sort by mtime' option into 'sort by last randomized ordering') * convert GPL (gimp palette) files into PNGs. There's no strict need to focus on writing CLI (command line) programs; However, writing CLI programs is definitely less complicated, slow, and fiddly than creating GUI programs, so, good place to start.
This is literally the most zen-of-python-y inplementation of the 'hide text from grep and casual looks' requirement that I could come up with in Python. It's simple, obvious, and as beautiful as it gets. 
Are you looking to improve python or general knowlede that can be applied regardless of language? Maybe study object oriented design patterns ? Advent of code has a number of exercises that may fit for applying your knowledge? Buy a book about algorithnms and or data structures. 
That's great to hear, but I am looking for a complete IDE rather than a text editor alternative (Sublime has got me covered on the text editor part).
This is so cool. Kudos to the developer!
I'm perfectly willing to attribute the poor quality of the code to my lack of experience, especially with micro-frameworks.
 &gt; The JVM *is* everywhere though. Uh, no. Why would you install it before you need it for something? Bigger applications that need one usually ship their own though.
don't see any advantages to move from troposphere. for large templates not much more useful as generic json
That's true. I've been struggling with pkg_resources too, even if in the end the API proved to be relatively simple. For basic stuff, I'd still go with [pkgutil.get_data](https://docs.python.org/3/library/pkgutil.html) from stdlib.
The correct subreddit for these kind of questions is /r/learnpython (If you read the title of the sticky or the sidebar you would have known) What have you tried? What did not work? We're not here for doing your homework, but we gladly help if you're stuck and provide us some context. (P.S. You probably also want to take a look at how reddit formats your text)
That question is quite difficult to understand. I think there may also be some formatting issues, since I can't seem to see the arrows that were mentioned. I'm guessing that you are being tasked with reading many files and outputting a single sorted file. The CSV part may be irrelevant since sorting by first field may be the same as sorting by the whole line. Most importantly; No, I won't do your homework. Work the problem and come back when you have a specific question.
Idle is simple, basic and fast. If you need more just use different tool. I believe the crapiness would be something in your head. Nobody is forcing you to use Idle. My personal note, I use just two main tool: Jupyter notebook and Idle. And I am pretty satisfied. 
Hi Mark, I just wanted to take this opportunity to thank you. It's because of your selfless efforts making Python work on Windows, that I've been able to use my favourite development language at work. Whereas my platform of choice is OS X, I mostly find myself in a Windows environment during my day job. Thank you for all the time you've contributed in porting Python to Windows, as well as for the pyWin32 library. It's very much appreciated!
You know wheels, right? A binary-compiled wheel is literally a zip file of (possibly-compiled) python files designed to be able to be unpacked and then "just run" (similar language is in the PEP!). Pip therefore really doesn't do much magic when installing wheels (as opposed to other formats). You could use this tooling to your great advantage if you wanted. If people make their stuff pip-installable (very common convention in python, obviously), then its "wheelable", which means you can create a wheel of it and then just use the resulting files from the wheel. If it doesn't run, then it should be something wrong with the person making the python package, not something you've missed in your own package/files/compiling process.
*Ash nazg durbatulûk, ash nazg gimbatul, ash nazg thrakatulûk, agh burzum-ishi krimpatul.*
I never wrote a bot with python, but I'm pretty sure you have to call `bot_func()` from somewhere. I would suggest replacing #bot.notifyOnMessage(bot_func) with bot_func()
Don't not speak his name! You'll damn us all!
One Python, to rule them all was a recurring joke on Usenet in the 90s
Don't be silly, everybody knows that N'Larl'thyop's name must be spoken three times to summon it. See, I can even say it a second time, N'Larl'thyop! And nothing will ha
I miss the code analysis that PyCharm has, in particular the ability to find all uses of something, but as soon as I go do edit the text like a boss (multi-select, line shifting, block select, etc.) I miss sublime way more! So I keep both installed and use sublime for everything except some infrequent code analysis in PyCharm.
As far as I am aware, pycharm [has mutli-select and column/block select](https://www.jetbrains.com/pycharm/help/selecting-text-in-the-editor.html) and also [And line shifting](https://www.jetbrains.com/pycharm/help/adding-deleting-and-moving-lines.html). Sublime's is different?
Yeah. With sublime I can ctrl click (or cmd click on Mac) and put my cursor in multiple places before typing, which is unimaginably handy. And in sublime column select is always available whereas in PyCharm you have to toggle between the two modes, which is awkward in comparison. Edit: Line shifting seems identical but I'm not sure if PyCharm supports shifting multiple line selections.
Rot13 is built into lots of stuff. Even vim. 
[It's added automatically by the implementation](https://docs.python.org/3/library/stdtypes.html#class.__name__). It and the other related attributes are referred to as [computed attributes](https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset) and you can see their implementation for the `type` object [in CPython](https://hg.python.org/cpython/file/v3.5.1/Objects/typeobject.c#l847). 
Not sure what you mean by the same edits to the closing tag... maybe an example would help me. Also, you may want to check out [Emmet](http://docs.emmet.io/) if you haven't already :)
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/353#Explanation) **Stats:** This comic has been referenced 203 times, representing 0.2135% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cyrsx1x)
I'm going to assume he used python and ran the text through the exact mapping used to decode the text. Something like: "".join([d.get(c, c) for c in plaintext]) For ROT13 encoding and decoding are identical operations.
In 3.x, you need to grab it from the `codecs` module as `codecs.decode`. But even without it being supported directly, it would be much easier to use `str.translate` (possibly also `str.maketrans`) to do the job.
A detailed explanation of the dissonance between the code and its message, seems to me like a perfectly reasonable topic for a PyCon talk.
good points!
Why does it even need Windows updates? Any other program I ever installed have not asked for Windows updates to be installed. Really weird. 
zinnnggggg
Because sometimes software needs to utilize a newer version of software to run?
What does this offer compared to other turtle tutorials?
Oh I see. Yeah that's a pretty handy feature.
Looks interesting for a very basic site, but it makes a *lot* of assumptions. It assumes that the user will always be using SQLAlchemy. But I know a handful of places that don't use an RDBMS and I work at a place where my project doesn't even use a database at all -- we use LDAP for user auth and we basically aggregate other APIs into a tool for our customer service people. The only state we maintain is a Redis cache for expensive things that don't change often (reports tied to a specific datetime, columns in a Salesforce object, I think we cache some queries from internal services for ~15 minutes). This part is something I'd expect most web dev people *wouldn't* guard against: def login(): username = request.form['username'] password = request.form['password'] user = User.query.filter_by(username=username).first() if not user or not user.check_password(password): return "Authentication error", 401 login_user(user) return "Logged in" Assume I'm targeting this site. I can reliably tell the difference between a user that exists and a user that doesn't exist. It's called [User Account Enumeration through Timing Attacks](https://littlemaninmyhead.wordpress.com/2015/07/26/account-enumeration-via-timing-attacks/). The best way to handle this is to do something like this: class Authenticator(object): def __init__(self, password_checker, user_finder): self._user_finder = user_finder self._password_checker = password_checker self._dummy_password = 'whatever string you want here' def authenticate(self, username, password): user = self._user_finder(username) if user: if self._password_checker(user.password, password): return True else: return False else: # user does not exist! # churn an approximately equal amount of CPU usage self._password_checker(self._dummy_password, password) return False This way, I can't reliably know the difference between a real user account and a fake user account. It's probably not a big deal for your app, but it's something to think about for larger or more desirable applications. In case, you're wondering, you'd set it up like this: from werkzeug.security import check_password_hash from myapp.models import User password_auth = Authenticator( password_checker=check_password_hash, user_finder=lambda un: User.query.filter(User.username == un).first() ) password_auth.authenticate('username', 'password') These sorts of objects are really neat because you can reuse and repurpose them all over the place. But that's off topic. [Serializer](https://github.com/CarlEkerot/flask-orm/blob/698f9b98a20b5944e97020b15d8d7bc887dd4d76/webapp/models/serialize.py#L1) is neat but you might want to look at something that can handle to-and-from Python, something like Marshmallow or Colander (I've never used Colander, so I'm not sure what it's like). This allows you to keep the concepts of ORM model and data serialization completely separate. I think it's a decent example of a really basic user-based, Flask REST API. But scaling this to something more complex would be difficult and testing things would be a nightmare (consider testing your user auth vs my example above). 
An auto increment PK is a surrogate key. It's called surrogate because it takes place of a natural unique identifier for an entity that does not exist. There are plenty of cases the natural unique identifier exists. Say you have an N-M association table for example. Your PK can be a composite key of the left with the right table. I have a project that needs a table with a PK that is a composite of 3 foreign keys. Because it associates three different tables together.
really? what about just XORing the string bytes with a fixed cipher stored in the same source file? basically just implementing a single use of an OTP. even simpler, even faster (computationally speaking), and even more obfuscated to grep. 
thanks man, it worked :) 
Flyway looks pretty neat, I'll check it out. 
QA Automation Engineer here! We use py.test for everything from unit tests of our own library to systems and integration level testing. Having things like fixtures and a well formatted output right out of the box is something I really like about it. Its generally flexible and I've been able to accomplish many different kinds of tests with it!
Have a look on http://oscarcommerce.com this is a very good and well written project.
Yes, I like wheels a lot. They achieve slightly different goal than what I'm aiming for, but they sure make deploying Python packages much easier. I want to make the whole process even simpler (create virtualenv, build and copy one file) without performance impact and resorting to too many hacks. I'm not sure, if exxo tool is bound to succeed, but I want to give it a try. Btw. my biggest gripe with wheels is that there are so few (if any) prebuilt C extensions for Linux on pypi. This forces people to either build their own wheels for dependencies like lxml or install gcc and friends on production machines. Here's an example discussion: https://bugs.launchpad.net/lxml/+bug/1176147. Unfortunately, for me lack of C modules removes much of wheel magic, if you use Linux. If you have some tips here though, please share.
I know this is still just a proof-of-concept, but how would you compare your project with [PyInstaller](http://www.pyinstaller.org/) in terms of goals and strategy? &gt; PyInstaller is a program that freezes (packages) Python programs into stand-alone executables, under Windows, Linux, Mac OS X, FreeBSD, Solaris and AIX. Its main advantages over similar tools are that PyInstaller works with Python 2.7 and 3.3—3.5, it builds smaller executables thanks to transparent compression, it is fully multi-platform, and use the OS support to load the dynamic libraries, thus ensuring full compatibility. &gt; &gt; The main goal of PyInstaller is to be **compatible with 3rd-party packages out-of-the-box**. This means that, with PyInstaller, all the required tricks to make external packages work are already **integrated within PyInstaller itself** so that there is no user intervention required. You'll never be required to look for tricks in wikis and apply custom modification to your files or your setup scripts. As an example, **libraries like PyQt, Django or matplotlib are fully supported**, without having to handle plugins or external data files manually.
How does this compare to flask-restless?
line 22 should be `pass` instead, if you want a no-op. Or in your case you could also use `continue` to jump back to the loop head. Depending on your operating system (don't know much about Windows), it's probably better to create symlinks instead of copying files (I have a directory with more 5200+ images, wouldn't want to copy those 3 Gigs). using randint is probably not sufficient enough. You probably want to avoid name collisions (*edit, didn't notice that you already avoid name collisions with that loop. So never mind that last bit*). The upper limit can be found by the length of your filelist array (`len(filelist)`). As a suggestion: you can create a list of unique numbers (e.g. by using `range()`) and then use `random.shuffle` to mix the order up, after that just pop an item from that random list to get a new name. That's far better than *hoping* for the randint to find a new unused number. `.endswith` also takes a tuple of arguments, if you want to allow mulitple endings, e.g. `x.lower().endswith(('.jpg', '.jpeg', '.png', '.gif'))`. You could make `UsedFilenames` into a `set()`. The `in` lookup works the same, but is usually faster than looking up elements in a normal list. There is other stuff like keeping to [naming conventions of pep-8](https://www.python.org/dev/peps/pep-0008/#naming-conventions) (your function and variable names).
The thing with name collisions was my mistake. I didn't take a close enough look at the actual behaviour. Name collisions shouldn't occur with your script :-). But it can happen, that you end up with an infinite loop, if randints range isn't high enough.
Boredom it the biggest threat to motivation.
Best use of 'literally'... :)
Never ran into any problems in IDLE. Not sure what he is talking about. It is just an editor.
Just start writing a program. That's all anyone can ever do. 
Yep! If there are more files than the current range of randint. I'll look at your suggestion to get around that. EDIT: Fixed this!
In the DRF docs there is a link to the recommended OAuth2 library. It doesn't use cookies
Or if you want to use a RDBM, then django. 
are you referring to this: https://github.com/evonove/django-oauth-toolkit ?
Looks neat, my one suggestion is since it's targeting specifically REST APIs it might be nice to base it around (or at least support) Flask-Restful. I use it in all my projects and I find that it does a much better job at putting "rest" into Flask applications.
Why would there be when you can just use `math.pi * 2`?
&gt; Automate it. (ie. write the code expressing those steps; package it into a script in the standard #!/usr/bin/env python3 .. if __name__ == "__main__": manner; then run that script when needed) This would be a really helpful step to explain further, because I think it's a major part of the 'writing programs' aspect of Python that I haven't seen explained well elsewhere.
Solid advice here. Another classic is to write a "to-do" list application. It is a good example that allows you to improve iteratively on each aspect of the program with proportional difficulty. Example steps with difficulty scale options: - Read input and save it in a data structure. First from command line, then a file, then database. - Store the data structure. At first in memory, then you can serialize it to a plain text file, then structured text like CSV/JSON, then a database. - Features. First just inputting take and listing them. Then priority for tasks, then due dates, then sub-lists, etc. This one is really open-ended, it is really anything you can think of, the idea is just getting used to implementing small incremental features. - User Interface. First the command line, then a simple GUI, then a web GUI, then a local web service. You can mix and match any of the above. E.g. If you don't want, the data storage part never has to move past plain text if you don't want. However, when you start doing features, it will be apparent various things are easier or harder to implement based on your other choices. E.g. If you want to add priority to tasks, and that wasn't a field in your "task" data structure, it becomes apparent this is easiest to add with csv/JSON/DB than with a custom plaintext serialization. And how about the GUI? How much work is it to add a new input option? Going through these things provides an excellent overview of what it is like to develop and extend real applications, with the universal layers (interface, logic, storage). One great light-bulb moments is when you realize why engineers are always saying things like "it would be better to change X to Y for extensibility," even if it isn't entirely necessary. It could e.g. be because while storing your data in a DB isn't necessary, in some cases it drastically reduces your effort for incremental features. It is better to see this for yourself, because next time around you will pick the correct storage data structure the first time! Happy Coding. 
While it is aimed at simple REST APIs, I would strongly encourage you to take look at [Eve](https://github.com/nicolaiarocci/eve) It basically this idea taken a whole lot further, with support of things like [HATEOS](http://python-eve.org/features.html#hateoas) and much much more.
I think so. I implemented it into a large production application and it works great. The tokens get sent through the headers or query string (depends on the client but our web app uses query string to avoid the CORS preflight request) edit: Actually it looks like we are using https://github.com/caffeinehit/django-oauth2-provider
Alt+click in PyCharm does exactly the same thing -- create another cursor at the point where you clicked. Of course it supports shifting multiple lines (vertically, horizontally), in the obvious ways.
Pyramid is a lot closer to Flask than it is to Django or Rails. It doesn't suggest any particular database bindings, for example.
I googled it and found [this issue](https://bugs.python.org/issue12345) where the addition of a tau constant is rejected.
An IDE usually has a full environment including a debugger. Pycharm for example has an editor (similar to sublime) plus a profiler and debugger. Pretend IDLE doesn't exist and get an IDE. Or continue to use their lighter-weight counterparts like Sublime or Atom. The choice is yours.
[This](http://stackoverflow.com/questions/598077/why-does-foo-setter-in-python-not-work-for-me) answers your question. 
IDLE isn't cli. It's a text editor, like sublime.
Yeah, only been using it a few weeks but so far it works great with everything I've thrown at it. On the practical side of things, I really like the integrated terminal emulator (and mode) which ties into Neovim's `:make` and similar external commands. It also has better clipboard support using xsel/xclip which is nice.
TIL. Thank you.
You have been creating programs, from the beginning. Just small ones. If you wrote a function and saved and ran it and tested it, you wrote a small program. Now you have to set a point on the horizon and steer toward it by making a larger program. Either learn web development and make a web app or look at your domain of expertise and see where a program could be helpful. (Just don't make another text adventure.). This is such a common problem, btw. It's like all these people went out and bought miter saws and lumber and don't know what sort of wood structures they have any idea they want to build. Odd scenario. Very 21st century.
Allow me to be greedy and ask another question. Right now I run my scripts in Sublime Text with loops built into it waiting for me to stop it. What's the real way to run scripts? I just got a Raspberry Pi and am not 100% sure the best way to run scripts on it is.. 
No
You should show some examples. It's a little hard to figure out what this is doing.
Well done. If you really want people to start using it, create a sample website that shows off what you have. Create a *Getting started for dummies* type guide, that points to your website (or provide images, so people can see what the final result looks like). Create proper documentation on [readthedocs.org](https://readthedocs.org/), or something similar. Good luck!
Because it requires certain features from that version of Windows. Would you expect to be able to install it on Windows Vista? How about XP? 95? Minimum OS requirements are _everywhere_.
En python e en enorm orm. 
That's a good tip! I like to avoid `if-else` clauses wherever I can so I'd write it more compact as [check_password_hash](http://werkzeug.pocoo.org/docs/0.11/utils/#werkzeug.security.check_password_hash) already returns a boolean: class Authenticator(object): def __init__(self, is_password_valid, user_finder): self._user_finder = user_finder self._is_password_valid = is_password_valid self._dummy_password = 'whatever string you want here' def authenticate(self, username, password): user = self._user_finder(username) if user: return self._is_password_valid(user.password, password): # user does not exist! # churn an approximately equal amount of CPU usage self._password_checker(self._dummy_password, password) return False If you end up having to write nested if-else clauses, that's usually a sign that this logic should be extracted into a separate function. I also changed `password_checker` to a `is_password_valid` so it's immediately known to the reader that it is a function and what type it is expected to return.
"I don't use Idle, so it shouldn't be included!"? Idle isn't a "crap tool". It's lightweight, uncomplicated, and does just what some people want. Want something else? Go elsewhere. But don't start thinking that you speak for the entire community.
I think it would be! Thanks for sharing.
Thank you for watching! Enjoy. Have an awesome 2016 as well
Which one?
Sweet! Enjoy buddy!
what language would you use to speed it up, scala?
I have/had a similar problem because I didn't even know what I was interested in, and I found "Five life jackets to throw the new coder" really helpful, even topics that sound quite boring are really exciting like data visualization. Check it out, it's on the right side.
I'm actually attending a meetup at MailChimp later this month, and if I remember I'll ask if they've run into this sort of issue. The blog claims they decided it was a false risk, but that was also 3+ years ago.
Wish they included aiohttp, another implementation of nonblocking io (like tornado).
I'm freshening up on Python for work, and these are my materials: Mastering Python Design Patterns https://www.amazon.com/dp/1783989327/ref=cm_sw_r_cp_awd_kiCKwbSP5AQ1M Learning Python Design Patterns https://www.amazon.com/dp/1783283378/ref=cm_sw_r_cp_awd_BiCKwbGT2FA1Z Fluent Python https://www.amazon.com/dp/1491946008/ref=cm_sw_r_cp_awd_WiCKwbQ2MK9N Design Patterns: Elements of Reusable Object-Oriented Software https://www.amazon.com/dp/0201633612/ref=cm_sw_r_cp_awd_fjCKwb5JQA3KG I recommend them to OP. 
Design Patterns is more a reference guide, plus all the stuff in it can be found for free and discussed in depth on every blog, forum and tutorial site (well, maybe not *every*). I'd actually recommend Clean Code over Design Patterns. Fair warning to the unknowing, both use Java as the example language so they can be a bit of a heavy read.
must have taken a lot of effort to put this together.
Clean Code was OK, but I returned it because what I skimmed through seemed nothing new to me. OP could run through PEP 8 or PEP 8 YouTube videos/presentations as well. Mileage may vary!
The only PEP8 stuff worth consuming is PEP 8 itself and Raymond Hettinger's Beyond PEP 8. That's just personal opinion, though. Clean Code doesn't seem new because it's common advice at this point. However, while being as familiar as my kitchen, I found it a decent read. Really, anything by Bob Martin is a strong recommendation from me.
What do you have to say about Fluent Python? 
I'll get back to you on that =]
How did you learn how to make a markdown live preview? Is it all handled by python you wrote or have you it being converted to html and reloaded? Really interested as I've tried this earlier last month and struggled 
Hello Rhomboid, In machine learning, data science I hear there are still a lot of libraries that are yet to be ported to py3. However, my main reason is - I have a super useful wxpython gui tool I have developed for my own use. I hear wxpython doesnt work in python. I am just waiting a bit. May be I should transition now. 
The I nothing wrong with Idle! It has a purpose and is ideally suited for that purpose. The fact is no one is forced to use Idle. If you want or need advanced features install the editor of your choice. This isn't a big deal. 
No Idle isn't hindering anything. Idle is perfectly suitable for a beginner. At some point you might want more advanced tools but that is no big deal as there are many out there to choose from. 
So boolean logic is really, really simple. It's not nearly the biggest hurdle when you start out as a programmer. However you still need to learn it, so it's a good thing somebody took the time to write an explanation. Problem is, there is so much wrong with this article that it's really just making things worse. If you consider that the only people who could benefit from an explanation at this level are complete beginners then an article that throws terms around in such a roundabout way is bound to cause confusion. It's trying way too hard to sound cool and forgets to actually explain things clearly. None of the key terms are defined or used properly, some even incorrectly. At no point in the article is a clear explanation of what types are involved. In fact, rather than making a clear distinction between the types `bool` and `int` the article jumps straight into type coercion which should really be kept for last. And it doesn't even explain that this is what's happening, it just says things like “0 evalutes to False”. Rather than explaining the characteristics of these individual data types and how expressions are evaluated, the article instead lists a number of examples of basic operators, half of which consist of type coercion quirks that you shouldn't be relying on in the first place. Next, throwing comparison operators and logic operators together is a bad idea. You should make a very clear distinction which operators make sense for which data types. Logic operators make sense for boolean values, greater than and less than make sense for ordinal types (mostly numbers) and the comparison operators equal and not equal make sense for pretty much all types (though with well known pitfalls when handling references). Using only the values 1, 0, True and False for all these examples is just asking for trouble. Now to be clear, if this article is actually *not* supposed to be an introduction into boolean logic but rather into Python's type coercion than these examples would make a lot more sense. However in that case there should be a different title at the top and the examples would have to be way more exhaustive, covering all possible combinations of types (there is no mention of how strings and arrays are interpreted when used like booleans). To be more constructive, here's what I'd recommend the author should do (in case he reads this): 1. Figure out your target group (Bloody beginners? Don't talk about type coercion without clarifying what it is and why they should be aware of it.) 2. Figure out what you want to explain: boolean logic (basic) XOR type coercion (advanced) 3. Explain terms clearly, don't hand wave precision away in order to sound funny. Making learning resource fun to read is awesome but they should still be correct. 4. Chose examples that explain the general case first, not just the quirky edge cases. Finally, here are a few more particular issues with the article: * “The above examples are called binaries.” The word “binary” in that context is an adjective. Properly explained it describes anything that consists of two parts. However, the word is actually also used as a noun, but only when referring to *executable files*. This may cause confusion. * Leibniz didn't develop a logic system based on 1s and 0s. He did write a book on the binary system (as a representation of numbers, which he found in asian texts) but his work on the binary system was mostly useless. He did however work on set theory, which is also what Boole was mostly concerned with. The modern day applications in computer science only reuse the basic concepts of their results. * The shorthand “Boolean” usually refers to values of the type `bool` (`True` and `False`), not the operators (i.e. `and`, `or`, `not`). And operators are not data types. The way it's stated in the article is plain wrong. Also, should a basic introduction like this even be using shorthands? Why not call them “boolean values” for clarity? * “We can produce Booleans without assigning them to variables, but instead make comparisons and evaluations using operators.” That sentence is just a grammatical train wreck I shouldn't be wasting my time shitting on other people's blog posts but this really needs improving.
Thanks works like a charm.
I also call out rubbish code when I see it e.g. in pull requests but you're just being a dick.
How does this compare to jython?
TIL you were not making a joke, Anaconda and Panda are actual programming-related things.
I'm not even denying the code might be rubbish (how would I know?), but I'm just starting with Python. I'm eager to improve the code. The parent post could be great if it pointed out the problems they had with my code :( I'm also aware that I'm reinventing the wheel, but I don't see any other way to actually *learn* how to Python ...
Thank you very much for your recommendations! I will take a look and get some of these books.
performance is good, it's all based on truffle, so barring absolutely horrible warmup (worse than pypy) the peak performance should be good. They claim in the paper better than pypy3 performance, I haven't been able to verify. PyPy 2.7 is quite a bit faster than pypy3 though, so I don't know how that compares
Thank you for your kind words! The reasoning behind that decision was to split up public and private information about the user accounts. User objects are used frequently all over the place and I didnt want to spill the password hashes by accident (or manipulation) into public. Not sure that thought makes even sense to be honest.
&gt; With sublime I can ctrl click (or cmd click on Mac) and put my cursor in multiple places before typing, which is unimaginably handy. Don't you mean unimaginably confusing?
True. I think I'll be sticking with 2.7 then. :/
Thank you very much for your kind words! I really appreciate them. What do you have in mind regarding the sample website? Just set up a blog using the software (e.g. a blog on my personal page) or create a "try it out" instance with some security meassurements in place?
Could this allow to run some python code inside Android native apps?
Panda**s**
Your sentiments are right, he's just a toolbox. 
Fair enough, I was planning on using those libraries later on for some other project, that's why I wanted to know if Python and Anaconda were interchangeable. 
NICE! Thank you!
Yes, the Python distributed in Anaconda is a standard Python, like the one you would get from python.org
no, you need the interpreter, either installed globally or bundled with your application
Did you ever figure this out? In doing the same thing in python with suds and im getting the same header you were
If keys are fixed (as I understand the question): value, key = min((d[k],k) for d in dicts for k in keys) But that would be too easy. Let me guess: The dicts have more than five keys and the actual question is: Find a set of five keys for which the sum of the associated values in all five dicts is minimal.
Why not make jpython python 3 compliant?
You can bundle the code into an executable with py2exe.
You should ask over on /r/netsec for advice on storing user passwords.
But Android is moving to OpenJDK, so I am not sure for Android N+ this will be true.
Look into PyInstaller, it's what I use, and it works beautifully.
Lol for about 2 seconds, then you've got it no problem.
Singletons are not an anti-pattern in and of itself. Misuse of a Singleton is an antipattern. They actually pop up all over in python: * logging.getLogger uses singletons * `import` creates Singleton modules (I'll cavaet with "by default" but hacking the import system isn't something I see often) Basically, singletons should either be a data getter or a data receiver, but never both and never with mutable state. However, hardly anyone does that, singletons form into God objects in most applications. But honestly, if you only need one instance, create one instance. A better example of an "anti-pattern" would be the Strategy Pattern. With first class functions and callable objects, the strategy pattern just isn't needed except in just a handful of situations.
It's doable, but honestly I can't remember how. This thread looks like a good starting point: http://stackoverflow.com/questions/10098444/py2exe-include-modules-when-should-they-be-managed-manually I'm not at a desktop right now, so I'm afraid I can't work through it myself :(
Yep, NEAT evolves the topology along with the network parameters. This particular implementation tries not to impose any hidden assumptions on what the network topology should look like. Python is indeed the wrong language for training neural nets when they become large and/or when you need to evaluate them over many test data sets. I'm planning on adding PyOpenCL support for the built-in phenotypes, and maybe C extensions if there are users who want to use it on a platform where OpenCL support is troublesome or nonexistent. (When I forked the project, it had some C extensions, but they were fairly inefficient, so I chose to drop them and focus on getting the Python code generalized and cleaned up first.) For what it's worth, sometimes the bottleneck for evolving a solution is in an external sytem, and in those cases pypy's performance is adequate. For example, if you're creating a network to drive a [TORCS car](http://torcs.sourceforge.net/index.php), you're going to spend most of your time waiting for the simulator to do its thing. Hopefully, with transparent support for multiple CPUs and GPUs, the time spent doing the GA updates and phenotype generation in the Python code remains minimal, but if it doesn't, I'll gradually try to move the bottlenecks to a C extension. The XOR example makes progress so quickly because I tuned the NEAT parameters for that example to get a solution in a relatively short time frame. Because that example is kind of the "Hello World" for the library, I wanted it to finish fairly quickly even on a slow machine.
Very cool! I've dreamed of making something similar, but wasn't aware of these high-speed "document scanners". What are they like to use? How much effort does it take to scan in your daily post? I've only taken a brief look at the source code, but one thing that struck me was the fact that there's only one table. I guess the most obvious improvement to make here would be to store everything more hierarchically - with a Sender table (not a field), Document table and Page table, so that multi-page documents are kept together and can be queried by sender. 
I think normally these would end up in a place like (on Windows) C:\Python27\Lib\site-packages. The installer, if there is one, should put them there.
Thanks for this, I've been looking for more resources on videos teaching ML
I don't think it has a GIL, I'm not sure though
&gt; The code is a delight to read. It certainly is a lot easier to grok NEAT reading this than it is reading some of the C++ implementations. Wow, thank you--that's one of the main things I was shooting for, but a lot of the credit for that should go to the original authors [Cesar G. Miguel and Carolina Feher da Silva](http://eplex.cs.ucf.edu/neat_software/#NEAT). When I first got interested in NEAT, I looked at several of the existing implementations, and most of them didn't appear to be terribly easy to hack on (or even to get running in some cases). While that's generally to be expected for academically-generated code, I didn't want to burn up a bunch of my free time untangling other people's code. Because neat-python seemed to be the most straightforward implementation (and it even had comments in the code!), I chose to take that as a starting point. A lot of the support for cognitive science stuff is there just because it was in the original project, and I found it interesting enough to keep and play with. My initial plan was to get the basic NEAT stuff working in a way that made sense to me, get some intuition about applying it to simple problems, get some tests built up, and then start adding stuff like HyperNEAT. I just recently added an assortment of activation functions for use with compositional pattern-producing networks (CPPN), so I should be able to get some minimal HyperNEAT support in there soon. I would eventually like to catch up with the current state of the literature as much as possible. 
So why not a fork?
Yeargh, I wasn't able to find anything concrete either. Also, PyPy is awesome and I appreciate the effort that you and everyone who works on it goes through. It's helped me do all kinds of cool stuff.
Can you provide a step by step of what you're doing, exactly (including operating system and shell)? It sounds like you're partially there and missing an argument or something. The general ways are to do either of: 1. `pip install &lt;package_name&gt;` 2. Download the source and run `python setup.py install` Pip is usually easier but on Windows it often has trouble if it needs to compile native extensions.
Hi, I would suggest that you make a note here saying that the problem has been solved for you on r/learnpython and r/pygame - that way no one will spend time answering it again. edit: wording
The link brought me to a Comcast ad...
It might be even easier to just use [miniconda](http://conda.pydata.org/miniconda.html). Then you can just whip up a very simple `environment.yml` file that records what modules you need, and you can just create a conda environment.
Looks very cool. &gt; Check out this repo to somewhere convenient and install the requirements listed here into your environment. Any particular reason there's no `requirements.txt` file? **Edit:** [Found it](https://github.com/danielquinn/paperless/blob/master/src/paperless/requirements.txt).
Sorry,here is the link http://homepages.math.uic.edu/~jan/mcs260/
Oh, and regarding the `Page` concept, currently the consumer is smart enough to break up a document into multiple png files, OCR them as one document, and then throw out the pngs. The scanner is a one-button thingy, so I put a bunch of papers into the thing, push the Big Green Button and they all come out as a single PDF. You get multiple PDFs only by waiting until a scan is finished and then putting in a new batch. So the idea of a "page" doesn't make any sense here.
Because: https://xkcd.com/927/
Good point. However, if they are moving just to the library, that means they would have to support the part of the runtime that the library needs, no? Or am I miss understanding something?
Installing packages using pip into any Python is prone to breaking things, it has nothing to do with Anaconda. However, with Anaconda you have the ability to create "conda environments", so whenever you want to try something new, you just do it in such an environment. This way, you never mess with your root conda environment.
[Docs say](http://pythonhosted.org/PyInstaller/#what-pyinstaller-does-and-how-it-does-it): &gt; Note: The output of PyInstaller is specific to the active operating system and the active version of Python. This means that to prepare a distribution for: &gt; &gt; * a different OS &gt; * a different version of Python &gt; * a 32-bit or 64-bit OS &gt; &gt; you run PyInstaller on that OS, under that version of Python. The Python interpreter that executes PyInstaller is part of the bundle, and it is specific to the OS and the word size.
In general, to find the key:value pai with the lowest value, you would to: &gt;&gt;&gt; d = {1:2, 4:6, 10:-2} &gt;&gt;&gt; d_min = min(d.items(), key=lambda x: x[1]) &gt;&gt;&gt; print(d_min) (10,-2) Notice that for the key keyword a function is used, whose value is used to order the input iterable. To find the lowest value for 5 dicts, you can build on the above.
Oh yes I should have mentioned that I was using pip within conda environments and the whole root broke and I am still not sure how. This happened a few upgrades ago, though so things may be more stable but I have been very wary of messing with my anaconda install outside of straight up using conda.
Because Truffle+Graal sets the stage for a very different approach to writing the VM, and leads to better performance with comparatively little effort.
Forgot to mention it does have some integration. I'm testing whether the new package name is existing on pypi, if yes then it gets an icon :)
God I love these notebooks. Totally changed the way I work.
Same here!
Cool stuff, thanks for sharing! Just a quick note on document scanners: I used one a few years back, but since I got an iPhone &gt; 5 with a pretty decent camera, I am archiving my documents using a scanner app now -- if you already have a smartphone with a relatively good camera, that's definitely the cheaper option I'd say. The features are actually pretty trivial like edge detection, contrast enhancement, output as PDF, and automatic upload to file sharing services. Anyways, the quality of the scans is really great, [here](http://imgur.com/WIZW3wI) is an example of a document that I just scanned. 
&gt; Is this preferred over cx_freeze? I think the general, unspoken, opinion is to just use what works (this also applies to py2exe, py2app, etc). I love PyInstaller and cx_Freeze. However, sometimes (for one reason or another) one of them is not able to compile one of my applications. So I end up using the other to compile that specific app.
I'd imagine future jython will go in this direction. It's a relatively slow moving project, but seems to speed up when organisations can pay the main dev to move it forward, I'd imagine if some company wanted to sponsor him to make it py3 compatible it would happen more quickly. [EDIT] - These developers built Truffle+Graal - so I guess they are interested in building languages on that tech, there's nothing stopping someone else working on Jython. For them to integrate Jython into Graal wouldn't make as much sense, if you watch the presentations on how Graal itself works.
Multi-cell selections and find and replace are some great features to have. I love the notebook, but I sometimes miss features from more powerful editors; it's great to see they're busy implementing them now that they've got the big split over and done with.
That's a good point, because of the split having gone relatively well from what I can tell this could lead to a lot of new features in the next year. I might start using notebooks a lot more if that's the case. 
If you look at the downloaded page source (ctrl-u in your browser, rather than inspect), you'll see that the comic image isn't actually there. It appears to be fetched with javascript after the page has loaded. The actual image elements seem to come from a JSON feed: * http://peanuts.com/wp-admin/admin-ajax.php?start=0&amp;count=10&amp;action=today_action&amp;page=strip (it's not just a feed of links, but rather contains HTML that gets inserted into the main page's DOM; nevertheless, you should be able to handle it with a JSON parsing step followed by HTML parsing) **Edit**: Updated to include and describe the correct JSON feed link. **Edit^2**: For the record, I found that JSON feed by setting a DOM breakpoint on the `&lt;div id="tabs-1"&gt;` and reloading the page, which led me to http://www.peanuts.com/wp-content/library/peanuts-comics-lib/static/comic-strip-lib-min.js , which does the asynchronous request. **Edit^3**: It also looks like you can add, for example, `&amp;charecter=Snoopy` (sic) to list only the comics that contain Snoopy; but at that point you might be better off using the "[search](http://www.peanuts.com/search/)" link.
&gt; Edit: Doesn't work for me either. Finally narrowed the problem down to the scikit-learn (sklearn) module. It isn't on their supported list either, so I'm guessing this is a dead-end for me. It looks like they do have a hook for [scikit-learn](https://github.com/pyinstaller/pyinstaller/blob/0c7b9021bfa0ce1a0a3d6d9396b095291c72830c/PyInstaller/hooks/hook-sklearn.metrics.cluster.py). Or maybe that's for a related project? I'm not sure. Anyway, if it doesn't work for you and the [troubleshooting docs](http://pythonhosted.org/PyInstaller/#when-things-go-wrong) don't help, I suggest opening an issue. They are pretty responsive.
Yeah apparently either way if you are in Sandbox mode you are pretty much SOL until you can convince them to approve your app so it's out of sandbox mode.
I once knew python fairly well. I knew all the basic stuff but never really had a deep understanding of OOP. Any good sources that I could use as a quick refresher/relearn. I am not familiar with any other languages.
I'm trying it out this weekend. It looks like it works just fine. Great job.
its completely designed ground up for achieving such high performance
Can someone suggest a good, dark, full theme for Jupyter?
Good job on what you did! I like it. First, a heads up. Recently (v 5.1+), LibreOffice's API has become much more pythonic. Check out [this PDF](https://conference.libreoffice.org/assets/Conference/Aarhus/Slides/MatthewFrancisPyUNO.pdf). It even works by name! And you don't need to use `getCellByPosition` or `setString` anymore. So while your package might be redundant for the newer versions, it is still useful for older ones. That being said, a few major things I saw: * Document the attributes of the class, not just the parameters. * Consider using properties when it makes sense. For instance, you set `self._is_null`, and you return it with `self.is_null()`. Why not just allow access to `is_null` directly? You could add this: @property def is_null(self): return self._is_null and access it from `self.is_null`, while making sure that it cannot be set externally. * Try not to return something when you have a side-effect. When you set something, don't return whether or not it set something. * Use exceptions. If you have a problem, raise it. Consider using your own exception classes. When you `insert_rows` ([L151](https://github.com/thepurple/pyoocalc/blob/master/src/pyoocalc.py#L151)), if `num_rows &gt; 0` raise a `ValueError`. If something is missing, raise your custom class. Let the user know what has gone on instead of just reporting failure. Also, you don't want to return anything since it has a side-effect. :P * Use the logging module instead of print. Remember that you can even raise an exception in the `__init__` method. In your example, you have similar problems. * You [try to make a document](https://github.com/thepurple/pyoocalc/blob/master/src/examples/example.py#L30). Ah, a no connection exception has been raised. But you are ignoring its content, which has been set [here](https://github.com/thepurple/pyoocalc/blob/master/src/pyoocalc.py#L665). You should put the error from the print into the exception raise, and just propagate it to the user. (Basically, don't bother with try-except because it's a fatal exception.) * Add a close method to `Document`. Better than delete. * In fact, that's the perfect use case for a context manager. Define your `__enter__` and `__exit__`, so the user can do this: with pyoocalc.Document(autostart=True) as doc: ... * Use `format` instead of string concatenation. There's more, but my computer is almost dead. Let me know if you have any questions. And good luck.
This is correct. Have you tried storing the user in the g global object in an after_login function? 
A more generic question: how can someone who wants to contribute back to the open source community, know when they are capable of being a maintainer for a project? Is it more about committing time and effort, or about knowing the code base backwards and forwards? 
Nothing special, but saves us a bunch of time because our current VOIP provider doesn't have an API we can hit.
It's over the entire run of the program, not just that million plays. So it will only ever go up. 
Ah, now I got it, thanks. It's even more depressing this way.
Ah - like in another terminal? Not a good one that I know of. I've been looking a bit too because I often develop on Windows where I don't have tmux (I know you can get tmux with Cygwin, but then you can't use Anaconda for python and building shit from source without Anaconda on Windows is a major pain...) I know it would be possible to make a solution using AutoHotKey because they have a very complex scripting language. You could find the first window with "IPython" in the title and then switch to it and paste. I just haven't explored writing this yet. Probably also possible to exploit Vim's ability to call Python commands to do it. I imagine by importing IPython there must be a way to connect with an existing kernel and run code.
That's a nice idea, especially if coupled with a dark matplotlib/seaborn theme! 
How 'comittable' are notebooks? The changing blobs of images/output in the saved notebook would screw it up, no? If it was possible to commit just the source that would be awesome.
Not really. For this to work, you need two key features: * Headless scanning (push-to-(FTP|SMB|whatever) * A tray This was the cheapest model I could find. I suppose you could go with a local scanner and upload the files manually, but that defeats the purpose as far as I'm concerned.
Ah OK I see. Thanks
You can't use MPL in a virtualenv?
Thanks for your reply, definitely too advanced for me to try and develop any of those ideas into a working solution.
MPL 1.4.3 would create a "shy window", one that hid behind your Terminal, can't be selected using Cmd+Tab and cannot receive any Keyboard inputs. MPL 1.5.0 detects this "non-framework Python build" and flat out refuses to work. You can [define a function in your `.bashrc`](http://matplotlib.org/1.5.1/faq/virtualenv_faq.html#pythonhome-function) that fixes this issue, but you need to remember calling it instead of plain `python`.
Quick things with %cpaste are nice. It's a good terminal replacement that opens faster than starting the notebook
don't complain about the bug, help on the solution https://github.com/pypa/virtualenv/pull/211 go here, pull the patchset down, probably update it to whatever virtualenv is these days, look into how to remove the dependency mentioned, etc etc etc &gt; I'll have to leave the real review and testing here to someone who has OS X. so test it!
Great analysis, the results were eye opening. I've been wanting to checkout Numba for some time and I'll try to use it in my next project.
Glad you found it interesting. I am becoming a Numba fan.
You should look into something like Solr or Elasticsearch for doing the document indexing and searching.
People get entertainment from the ticket?
I looked into the cloud print options, but most of them want to push my *very private documents* to a 3rd party cloud host like Dropbox or Google. We're talking about my national insurance number, VAT number, business registration records, tax forms. I'm not going to store that sort of thing with anyone by my own trusted machine.
I think it's more than that. When a project is popular but ultimately flawed or broken, it detracts from the ability to create better alternatives. If the majority project doesn't do what you need, and is very large, it can be difficult to achieve anything at all without reinventing the wheel, and suffering from the above problems.
I agree, that point was made as well by neuralyzer. I'll update the post after I've tested it.
It works in Anaconda. The problem is virtualenv on the Mac, and not actually MPL itself.
The circle of software life :).
Hah, I was about to say that a coworker has been urging for this... derp
I'm not sure how to check how many threads were used. Interestingly OpenCl is more than 8 times faster than single threaded Cython. So something beyond parallelization is happening here. Maybe also disable boundschecks in Cython. If you compile Cython with the --annotate option it shows you were costly calls to Python functions are made. This should point you to where to improve the Cython code further.
Let me check my pant's pocket for a spare half billion
From the idea that they could win.
&gt; Lately, I really have been thinking about trying android development, so naturally, I have to do Java programming. You don't *have* to use Java. There's a few Python Android apps done with Kivy. If it's games, you'll be using what the engine provides (Javascript for Unity) or C++ if you need native performance. &gt; Would I get frustrated, having been spoiled by these more powerful languages? I don't want to start a debate on the "power" of languages as they're all turing complete. Perhaps you meant "expressiveness" (the number of choices you can make regarding syntax when it comes to expressing something)? Anyway this is a dangerous topic. :-)
[removed]
The problem is that the problem isn't MPL. It's upstream but their name is getting pulled through shit now.
Yep, but image outputs are encoded as a giant blob of base64 encoded data which is saved with the notebook. Just makes tracking code changes a bit of a mess. Even the updating `execution_count` add noise to commits. As mentioned elsewhere, the trick is to clear outputs before saving and/or committing.
1) This is a trivial program to write 2) Is that an assignement that your son was asked to do? If so, he should really be able to do it on his own. Your question is not really clear as to the context, and if this is about homework, I hope you won't find a canned answer here. Please clarify the context if different.
Looks great, will check it out!
The problem is mac. I'm sure the Mac forums are full of people saying, "why would you want to be able to do that?". Why anyone would use a platform known to backdoor every app compiled on it I do not know.
&gt; Why anyone would use a platform known to backdoor every app compiled on it I do not know. [Citation Needed]
Yes, because of some limits on my NVIDIA chip. Switching to single precision does not speedup the other codes on my machine.
I think it's much more depressing to reset it to 0 after every print. Then you get to see the 6+ million dollar runs of winning no more than $100.
Well, what does he have so far?
Since the PyOpenCI and PyCUDA versions are essentially running C code it'd be interesting to compare the speed of a plain C implementation. The comparison of C to Cython would also be interesting.
Oh, I hadn't noticed it's only on Mac. Good luck.
The i7 has hyper threading, so you potentially have up the 16 threads.
I know, I was just pointing that it's a difference to consider. BTW, some time ago NVIDIA deliberately limited double precision performance on the driver to try to force people to buy Tesla GPUs that had no artificial limits.
Agreed, but there are many C variants we could try, including: - plain C code (would be similar to the sequential code) - mutlithreaded C code - opencl or cuda code Seems I am due to a significant update, or a new post here ;) 
There's a few areas with tmux that require careful configuration to work well. These include scrolling, mouse navigation, and copying highlighted areas. However, all of these are configurable.
It is 4 physical cores, hence 8 threads.
Pyglet has some useful quick-n-dirty audio playback functions, although it depends on a third-party library for playing back anything but .WAV.
The problem I see with simulators like this, is that there's the assumption that you're only buying with one ticket per draw. What if I bought 2 tickets or 20 or 200... is there a point where it makes sense to purchase in bulk to get a higher probable win?
That's very cool actually. I'll check it out when I get home. Thanks a lot!
Thanks for the tip. Having two separate floats shave 25% of the time. I'll update the post, as we use this trick in other codes. Interestingly enough, it does not improve the numba code.
I think it does use SSE/AVX which is why it is fast on cpu.
Great, I'll update the post. How would you like to be credited?
http://daringfireball.net/linked/2015/03/10/cia-xcode Why would they expend the effort otherwise?
&gt; To be clear, there is no indication in this report that this hacked version of Xcode has been used in the wild. To be useful, they’d somehow have to get developers to use their modified Xcode toolset instead of Apple’s, or, to somehow infect Apple’s Xcode code base with their modifications. Unless you want to also claim they've gotten to Clang/llvm too.
For a developer, probably because they want POSIX compatibility without having to install Linux. POSIX on Windows is a pain, and Windows has the same proprietary code problem that Mac does.
I think the point is for you to find the program. A major factor of LPTHW is teaching you to do your own research. It's what people either love, or hate, about the book. If you aren't going to do it, you're definitely wasting your time with the book.
Sorry if that was not clear. Yes, depending on how you ask for the number of cores you get 4 or 8. Many default to the highest number.
They haven't been selected and posted yet....
Yes, it does make sense, but only if you can guarantee that you'd be the ONLY winner, and didn't have to split the pot. 
That question gets kinda complex because this is the real world. You can't just answer it with math. You have to stop off in lotto rules, tax law and game theory. Math: 1 in 269 million chance at a 1.3 billion dollar prize gives an expected value of $4.83. Tickets are only $2, should buy all the tickets you can! Lotto rules: The jackpot is misleading. That money gets paid over time. To be fair, we have to compare the now money of the lump sum to the now money of the ticket price. The lump sum is about 806 million giving an EV of ~$3. Still a good deal. Tax law: lotto winnings are taxable. At a 39% federal tax rate, you're walking with $492 million. That gives an EV of $1.83. Lame. But wait, gambling losses (the losing tickets) are deductible. Game theory: What if you bought every ticket? This would be about $538 million. Win the $806, deduct your $538 and only get taxed on the $268 (plus all the other prizes) winnings. This would be a guarantee *if* you were the only playing. If someone else does this, or even wins by chance, you have to split the pot and you end up in the hole. Now you're in a prisoner's dilemma like situation with the whole country. So do things get better if you buy more tickets? No, not really. 
I'm disappointed with the gap between Numba and PyOpenCl. I'd started to believe that Python with a good JIT might perform close enough to C that I wouldn't ever need to learn C :(
http://haystacksearch.org/ This project makes integrating Elasticsearch with Django fairly easy. Project looks cool btw!
OpenCL is not C. Numba might be getting close to a serial C version (it would be nice to know), but OpenCL should make a good parallelizable algorithm quite a bit faster than a serial C version.
As mentioned in some other comments, PyOpenCl runs parallel code while Python and Numba run in a single thread. That explains most of the difference probably. 
OK. I agree with your last (and only?) blog entry ;)
This is a nice comparison. One thing that is missing, though: a simple C version which can be executed using ctypes or (better yet) CFFI. By the way, your edits indicating updates incorrectly say the updates happened in 2015.
&gt;99% of all of my python starts out in a notebook. I find that interesting. I am still new to Python and newer to Notebooks, but so far, I find I have to write the code and play with the `ipython` terminal, then move it to a notebook. Almost every notebook has a scratch document following along
Can someone clarify why CoreCLR is an interesting part of this? Edit: I Googled it for myself. Hooray me for not being so lazy! &gt; ... the .NET Core runtime, called CoreCLR ...
Any chance you can compare the [intel python variant](https://software.intel.com/en-us/python-distribution) and [numpymkl](https://software.intel.com/en-us/articles/numpyscipy-with-intel-mkl) libraries to the rest of the tests you've run here?
It's finally something close to how I've used Matlab forever. Its a code scratchpad. 
Yeah. I guess I have to work on the content ... ;)
So, I updated it entirely to make a few fixes: https://repl.it/BcbX/22 Now it bases the number generation on the number of files in directory that the script is in - no need to adjust the number anymore. The function that actually does the file randomization accepts filetype as an argument and thusly you can re-use the function for any type of file by adding it to an elif statement at the bottom of the script!
Awesome. The odds of hitting the powerball are 1 in 292,201,338 so I should be good once I hit $584,402,676 spent. I'll report back when mine hits. EDIT: $653,707,076 and I hit it. 
In my experience the pure C/Fortran implementation is usually a tad faster than Python calling C/Fortran just because there is still some overhead associated with Python. But usually not too bad if the bulk of the routine is in the compiled language. Though I would personally still write any hardcore number crunching programs in a purely compiled language. 
i also wrote one a while back: import sys import random def number_picker(): options = [] for i in range(1,70): options.append(i) p_options = [] for u in range(1,27): p_options.append(u) number = {} base = [] powerball = [] while len(base) &lt; 5: num = random.choice(options) base.append(num) options.remove(num) powr = random.choice(p_options) powerball.append(powr) number['base']=base number['powerball']=powerball return number def list_of_numbers(rng): numbers = [] for i in range(1, rng): number = number_picker() numbers.append(number) return numbers def winning_number(): options = [] for i in range(1,70): options.append(i) p_options = [] for u in range(1,27): p_options.append(u) number = {} base = [] powerball = [] while len(base) &lt; 5: num = random.choice(options) base.append(num) options.remove(num) powr = random.choice(p_options) powerball.append(powr) number['base']=base number['powerball']=powerball return number def simulator(tickets, p): cost = 0 win = 0 w = 0 matched_0_1 = 0 matched_1_1 = 0 matched_2_1 = 0 matched_3_0 = 0 matched_3_1 = 0 matched_4_0 = 0 matched_4_1 = 0 matched_5_0 = 0 matched_5_1 = 0 highest_win = 0 highest_match = {} winning_num = winning_number() list_of_num = list_of_numbers(tickets+1) for i in list_of_num: base_matches = len(list(set(i['base']) &amp; set(winning_num['base']))) powr_matches = len(list(set(i['powerball']) &amp; set(winning_num['powerball']))) if base_matches == 0 and powr_matches == 1: win += 4 w = 1 matched_0_1 += 1 if base_matches == 1 and powr_matches == 1: win += 4 w = 2 matched_1_1 += 1 if base_matches == 2 and powr_matches == 1: win += 7 w = 3 matched_2_1 += 1 if base_matches == 3 and powr_matches == 0: win += 7 w = 3 matched_3_0 +=1 if base_matches == 3 and powr_matches == 1: win += 100 w = 4 matched_3_1 +=1 if base_matches == 4 and powr_matches == 0: win += 100 w = 4 matched_4_0 +=1 if base_matches == 4 and powr_matches == 1: win += 50000 w = 5 matched_4_1 +=1 if base_matches == 5 and powr_matches == 0: win += 1000000 w = 5 matched_5_0 +=1 if base_matches == 5 and powr_matches == 1: win += 200000000 w = 6 matched_5_1 +=1 if w &gt; highest_win: highest_win = w highest_match['mynumber'] = {"base":i['base'], "p":i['powerball']} highest_match['winning_number'] = {"base":winning_num['base'], "p":winning_num['powerball']} cost += 2 if p == True and w&gt;0: print winning_num['base'], winning_num['powerball'], w if p == True: print "cost:%s win:%s highest_match:%s" % (cost, win, highest_match) else: results = {"matched_0_1":matched_0_1, "matched_1_1":matched_1_1, "matched_2_1":matched_2_1, "matched_3_0":matched_3_0, "matched_3_1":matched_3_1, "matched_4_0":matched_4_0, "matched_4_1":matched_4_1, "matched_5_0":matched_5_0, "matched_5_1":matched_5_1} return cost, win, highest_match, highest_win, results #print simulator(1000, False) #simulator(1000, True) def runner(runs, tickets, printit): cost = 0 win = 0 highest_match = {} highest_win = 0 results = {} results["matched_0_1"]=0 results["matched_1_1"]=0 results["matched_2_1"]=0 results["matched_3_0"]=0 results["matched_3_1"]=0 results["matched_4_0"]=0 results["matched_4_1"]=0 results["matched_5_0"]=0 results["matched_5_1"]=0 for i in range(1, runs): sim = simulator(tickets, printit) cost += sim[0] win += sim[1] results["matched_0_1"]+=sim[4]["matched_0_1"] results["matched_1_1"]+=sim[4]["matched_1_1"] results["matched_2_1"]+=sim[4]["matched_2_1"] results["matched_3_0"]+=sim[4]["matched_3_0"] results["matched_3_1"]+=sim[4]["matched_3_1"] results["matched_4_0"]+=sim[4]["matched_4_0"] results["matched_4_1"]+=sim[4]["matched_4_1"] results["matched_5_0"]+=sim[4]["matched_5_0"] results["matched_5_1"]+=sim[4]["matched_5_1"] if sim[3] &gt; highest_win: highest_win = sim[3] highest_match = sim[2] if i % 10 == 1: print "%s==" % i if i % 10 == 2: print "%s=====" % i if i % 10 == 3: print "%s========" % i if i % 10 == 4: print "%s============" % i if i % 10 == 5: print "%s=================" % i if i % 10 == 6: print "%s============" % i if i % 10 == 7: print "%s========" % i if i % 10 == 8: print "%s======" % i if i % 10 == 9: print "%s=====" % i if i % 10 == 0: print "%s==" % i rate = float(win)/cost*100 return "Cost:%s Winings:%s ROI:%s \nHighest Numbers:\n %s \n Matched:%s\n Results:\n 0_1:-%s \n 1_1:-%s \n 2_1:-%s \n 3_0:-%s \n 3_1:-%s \n 4_0:-%s \n 4_1:-%s \n 5_0:-%s\n 5_1:-%s" % (cost, win, rate, highest_match, highest_win, results["matched_0_1"],results["matched_1_1"],results["matched_2_1"],results["matched_3_0"],results["matched_3_1"],results["matched_4_0"],results["matched_4_1"], results["matched_5_0"], results["matched_5_1"]) how_many_tickets = raw_input('How many tickets would you like to buy?:') try: how_many_tickets = int(how_many_tickets) except: while not isinstance(how_many_tickets, int): how_many_tickets = raw_input('How many tickets would you like to buy?(a number please):') try: how_many_tickets = int(how_many_tickets) except: pass how_many_simulations = raw_input('How many times would you like to run the simulation?:') try: how_many_simulations = int(how_many_simulations) except: while not isinstance(how_many_simulations, int): how_many_simulations = raw_input('How many times would you like to run the simulation? (a number please):') try: how_many_simulations = int(how_many_simulations) except: pass how_many_simulations += 1 print runner(how_many_simulations, how_many_tickets, False) 
I haven't used this in a while, but maybe give [vim-ipython](https://github.com/ivanov/vim-ipython) a whirl. Doesn't use tmux. You just send code from vim to an ipython session.
Look into the issues that any of the packages you use list on github (or bitbucket, etc.). You may be able to get involved there. Before working on code, however, many maintainers like to see a new contributor work on some documentation and testing before working on the core package.
That's completely unnecessary. &gt;&gt;&gt; def a_generator_function(): ... for x in (1, 2, 3): ... yield x ... &gt;&gt;&gt; for val in a_generator_function(): print(val) 1 2 3 &gt;&gt;&gt; for val in a_generator_function(): print(val) 1 2 3 &gt;&gt;&gt; for val in a_generator_function(): print(val) 1 2 3 And there is no such distinction between an iterator being finite and a generator being infinite. `itertools.count()` for example will return an infinite iterator. 
I just looked for notes re the issues but didn't find any so recollection is hazy and I never figured out the root cause because I reinstalled with a newer version. One thing that happened was conda would no longer work and I scoured google for a fix but everything just made it worse. On a separate occasion the launcher stopped loading, which wasn't a big deal as I wasn't using that but definitely symptom of things gone wrong.
I believe `numba` supports parallelization as well (see: [here](http://numba.pydata.org/numba-doc/0.11/prange.html)). I haven't tried using it as of yet, though, so I'm not sure of its relative merits as compared to Cython.
Is it reliable in production? 
Numba has a nogil option IIRC for writing mulithreaded functions. Also there is a new guvectorize parallel target. 
Best talk on how to loop in Python [Loop like a native(Generator and iterator)](https://www.youtube.com/watch?v=EnSu9hHGq5o) by @Ned Batchelder
Depends what you want to do. There are a lot of huge projects out there and there are a lot of tiny ones. I run one, but unless you're interested in structural analysis, you probably wouldn't care.
"Almost 5 years later and this issue has still not been fixed, making Matplotlib borderline unusable." Funny, seems like a LOT of people use mtplotlib to me.
I tried guvectorize, it does not yield better results. I will try nogil.
I believe what you've produced in `MakeIter` isn't an *iterator* as such, but an *iterable*. See, for example: [collections.abc](https://docs.python.org/3/library/collections.abc.html).
Sure, but I am running this on a Windows laptop.
http://superuser.com/questions/347250/how-can-you-get-thread-count-of-running-process-in-windows-7
Added powerplay option, moved some magic numbers to the top import random #------ #CONFIG #------ stop_on_jackpot = True powerplay = True reset_max = True print_every = 333333 #changed to tickets purchased, rather than spent $$$ jackpot_value = 1300000000 #------ prizes = {(0, False):0, (1, False):0, (2, False):0, (3, False):7, (4, False):100, (5, False):1000000, (0, True):4, (1, True):4, (2, True):7, (3, True):100, (4, True):50000, (5, True):jackpot_value} ticket_numbers = set(range(5)) ticket_powerball = 0 balls = tuple(range(69)) powerballs = tuple(range(26)) winnings = 0 spent = 0 max_prize = 0 jackpot = False powerplay_draw = 0 powerplay_multiplier = 0 iterations = 0 while not jackpot or not stop_on_jackpot: chosen_balls = random.sample(balls, 5) chosen_powerball = random.choice(powerballs) numbers_hit = sum(1 for x in chosen_balls if x in ticket_numbers) powerball_hit = chosen_powerball == ticket_powerball matches = (numbers_hit, powerball_hit) jackpot = matches == (5, True) if powerplay: if jackpot_value &gt; 150000000: powerplay_draw = random.randint(1,42) else: powerplay_draw = random.randint(1,43) if powerplay_draw &lt;= 24: powerplay_multiplier = 2 elif powerplay_draw &lt;= 24+13: powerplay_multiplier = 3 elif powerplay_draw &lt;= 24+13+3: powerplay_multiplier = 4 elif powerplay_draw &lt;= 24+13+3+2: powerplay_multiplier = 5 else: powerplay_multiplier = 10 if jackpot: powerplay_multiplier = 1 elif matches == (5,False): powerplay_multiplier = 2 spent += 3 else: powerplay_multiplier = 1 spent += 2 prize = prizes[matches] * powerplay_multiplier winnings += prize max_prize = max(prize, max_prize) iterations += 1 if iterations % print_every == 0 or jackpot: stats = 'spent:{:,}, winnings:{:,}, net:{:,} max_win:{:,}'.format( spent, winnings, winnings-spent, max_prize ) print(stats) if reset_max: max_prize = 0
Thanks, I will try prange with Cython and Numba ASAP.
So basically, if numba had been parralized it had might run 8x faster? By the way, did you consider using NumbaPro with from numbapro import cuda http://docs.continuum.io/numbapro/index It might be the best way how to compare pyCuda or pyOpenCl with numba. 
Why would it be better than vectorize?
Well, I am not sure if numbapro is not paid. I dont know if you can get free version. But if you can I would like to see results :) Good luck and thank you once again for great article.
I'd certainly be interested in seeing the results. I'll keep an eye out for your next post!
Because its parallel ? Or is vectorize also parallel? 
Fixed. I have also add the side-effect protection. Example: @property def is_null(self): return self._is_null @is_null.setter def is_null(self, value): raise ValueError("Assigning a value to the 'is_null' is not allowed.") Have you any other remarks?
https://www.continuum.io/blog/developer-blog/deprecating-numbapro-new-state-accelerate-anaconda
Great, thanks.
Solid.
Wow - I didn't think I'd get this much flak. I guess the python community is a bit like the kernel community, then.
The reason I went for the scanner I mentioned is that there's no software involved. The scanner is configured through a web interface and then you just push a button on the scanner to scan a document and push it to local server. Using special software means I have to turn on my computer and fiddle with some proprietary interface, then copy the file into my database. That sucks.
&gt; When a project is popular but ultimately flawed or broken, it detracts from the ability to create better alternatives. I immediately thought django, don't know why.
I assume you *don't* want to double `float`. Thus: &gt;&gt;&gt; lst = ['abcd', 8, 3.4] &gt;&gt;&gt; [2*i if isinstance(i,int) else i for i in lst] ['abcd', 16, 3.4] 
Could anyone point me in the direction of more on robust item detection in images with python? I've experimented a bit with the haar cascades in opencv, but I've found tuning it difficult.
Try this one https://mutagen.readthedocs.org/en/latest/ I worked with it and it seems semi popular
Can you share your workflow? I would love to utilize the notebook. Most of the time I use only ipython qt console + vim + terminal + browser, I would like to see if there is better workflow out there. 
Exactly what I was thinking, I was using matplotlib yesterday and it was working fine for me lol. Not a bad deal for the Free price tag.
It really doesn't matter which programming community you pose a question like this to. Programmers are incredibly generous with each other, and sharing is higher in programming than basically anywhere else. The one thing that people require from each other is effort. Any time it appears you are not inputting any effort, but you want effort of others, you will be turned away. 
Probably I would issue some trial queries in the browser, watch the "Network" tab to see what requests are issued to the admin-ajax.php backend, and reverse-engineer from there.
But it still calls the generator twice for the `normalize` function, which is rarely desirable. I personally think it's better to keep things transparent and fix/update things as they change rather than applying patches on top of them...
You could help me out with [git-pandas](https://github.com/wdm0006/git-pandas), if you're into that sort of thing.
Possibly you find a needed library on provided 2 links (take a look to Pydub and PyAudio libs) https://wiki.python.org/moin/Audio https://wiki.python.org/moin/PythonInMusic Another place to check: http://pymedia.org/ 
How else would you normalize except to load the whole thing into a list? You either make two passes or you cache the output until the end. There is no other way to do it.
I'm not allowed to use "import" ):
Yep, using a generator twice is actually quite desirable, as many space-efficient methods take multiple passes through the data. In retrospect, a better problem to solve would be, e.g., counting the number of elements in a sequence which are between the max and max / 2. The example I gave above is sort of unsatisfactory from an efficiency standpoint, as since you're returning the list of normalized numbers anyways it doesn't change the space complexity to just load the whole thing in at once.
The only improvement I could imagine is capturing positional arguments as well
[2 * I if type(I) == int else I for I in in lst]
For me the most important and main part should be your own research, your own program, show it, don't know, attach some screens to show final product, and explain your way of thinking/explain code to someone as simple as you can. After theory about python, make intro to your project. At the end you can write some conclusions about whole paper and coding your own program. 
I don't know about "professional", so I will substitute the word "good"...or even just *goodish*, really. Things that would be a dead, or at least not feeling very well, giveaway that a Python programmer was not goodish by my take with a grain of salt standards might be: - method names are nouns - doesn't use enumerate if needs to track index in a loop - uses for x in range(len(my_list) instead of for x in my_list - doesn't use comprehensions - short non descriptive naming - uses globals. Likewise "makes every object an instance attribute and declares them all in a big pile in the \_\_init__ ("self.whatever") instead of mostly within the local namespaces of functions" ("self.whatever") instead of keeping things mostly local in namespaces. (or generally declaring names of objects in too "liberal" scopes, i.e. global instead of inside a function, global instead of inside a class, etc") - breaks law of Demeter flagrantly - reinvents the wheel when there is an obvious battery included in the standard library to reduce his 20 lines to one clear line. - lots of hard coded values right in the code. - repeats him/herself / copy pasta - uses if x == True instead of if x - zero use of docstrings or comments - uses Python 2.5. 
Proper use of language constructs for the situation, such as knowing when your data model warrants a list, set, or dict. If you understand the language well enough, you will know what constructs are appropriate to solve the problem presented. You did indicate that this was for a 'Junior' developer job. Your expertise will come from reading docs more than from experience. Learning the right usage for the situation comes from a) reading lots of docs and b) coming across lots of situations. You probably haven't encountered many situations, but have read plenty of docs. Your interviewer (hopefully) knows this and will consider that when reading your code. This is why you want to be explicit with comments. For example, let's say I wanted you to index word counts from an article (a common interview question). Given an article, give me a count of all the words in that article. I know that a dictionary is an indexed dataset. The keys, being unique, are the index. I would count each word in the article and increment the value associated with the key for that word. If you didn't know that a dictionary was the right thing to use, you might instantiate individual variables for each word, or set up two parallel lists for words and counts. Both of those solutions can be made to work, but would not demonstrate knowledge of the data model. Now for something as simple as misunderstanding list vs. dict, I would reject even a junior candidate. However, there are many more complex things in python that I wouldn't judge someone for not knowing well, if at all, for a junior position. Suppose I had asked you how you would download 1000 random imgur images in a script. That involves knowledge of the urllib2 library, writing the results to files, and if you want to win points, concurrency models using threads and/or multiprocessing. Unless you held a computer science degree, I would expect a junior programmer to get something wrong in here. I get shit wrong with threading all the time and I've been writing python code for years.
And for debugging, defining your own repr is a must
Homework and School/Online Course related questions like this belong in /r/learnpython What do you specifically not understand about the above solution? It does exactly what you need and requires no external modules (ie. no imports) lst = ['abc', 4, 'def', -1, 'test', 0] # This is any list you are given containing both text and numbers or other objects. mapped_lst = [2*i if isinstance(i, int) else i for i in lst] # This is a list comprehension which creates a new list based on your requirements and stores this new list in the variable mapped_lst # The list comprehension works by iterating over each element in the target list 'for i in lst', checking if its an integer 'if isinstance(i, int) and multiplies it by two if the element is indeed an integer
Copy &amp; paste doesn't work for you?
Thank you. I have some Python knowledge and am an experienced programmer, and thought this book could help me learn how to better write Python,taking advantage of the language. By your post, I can guess it fits my bill. 
This hoses you if you are using GitHub or nbviewer, doesn't it? It's nice to have your notebooks readable by others.
Range isn't actually an iterator - it's an iterable object, and you can loop over it multiple times. In addition, it actually has several other fast special methods: `__getitem__`, `__len__`, and `__contains__` (which just calculate the answer instead of looping over values). Actually, all iterators are not restartable. Restartable objects are iterable, which create an iterator when fed into `iter()`. 
You can actually do both. Multiple cores, and each one using vectorized instructions.
Try [this](https://github.com/snoack/python-goto) or [this](http://entrian.com/goto/). Actually, every `if`, `for`, `while`, `assert` etc statement is actually a goto in the bytecode, since that's the only way to do branches.
What aspects of stability or feature set are still wanting for you and your company? 
That's interesting! I wonder why a shallow copy was chosen over a deep copy.
You don't need to do that. \^\^ Assuming you only have: @property def is_null(self): return self._is_null then trying to set `is_null` will raise an `AttributeError: can't set attribute`.
Is this a troll?
Insert Fry Meme... I'm lazy...
[checkio.org](http://www.checkio.org/) is pretty great. Otherwise I would try to make a [rogue-like game.](http://ondras.github.io/star-wars/)
&gt; just be consistent with your own code, not with someone else's ideal. Unless it's python, in which case PEP8 is your friend and is trying to help you. Use PyCharm and it all becomes a lot easier.
BTW, if this seems absurd question to you, please let me know why. 
Once in awhile people start thinking things like this, and they look back to the [Lisp machines](https://en.wikipedia.org/wiki/Lisp_machine) of the 1980's, where everything really was done in Lisp. One of the key innovations of Unix, on the other hand, was to have a system that you could use many different programming languages on. So for example, back in the 1970's and 1980's, you could use C on Unix, but you could also use Fortran or Lisp too. This model of operating system has stuck around because it's fast (system tools are written in C), and flexible (use any language you like for making applications). One of the big things with Android is that Google switched to using Java at the application level. Java is slower than C, but it's much more platform independent. Python is a good language for applications, but an operating system usually has to run as efficiently as possible. This means writing it in a language like C, or maybe a language like Java if you need more hardware independence. Writing an operating system in Python would be slower and less efficient, and ultimately not accomplish a whole lot. The entire point of an OS, after all, is to provide an environment for running your applications.
Look up dependency injection. Basically, allow ready-made objects to be input into your class from the outside. If someone wants to use something else, all you need to do is make sure your objects act the same.
Fantastic news!
[Cython is aware of numpy](http://docs.cython.org/src/tutorial/numpy.html) and you can use numpy arrays as native cython types. How about re-writing the cython version to use numpy vector operations? This should give you the advantages of both.
The trick is that `is_null` is a read only property. I needn't to set `is_null` attribute directly. I have to forbid the `is_null` changing. That attribute is setted inside the class via `self._is_null`. No other chages are allowed.
I did it, and did not see improvement. Most of the time is spent in Numpy array operation already.
Back in the 80's, my rural Georgia high school finally got some computers and there was a course in Basic Programming. The computers were Apple II's and the teacher was the Typing teacher - an obvious choice, what with all the keys I suppose. I was a self-taught coder/hacker/geek with 4-5 years experience, and the teacher was equipped with a book with exercises and "answers". The first assignment was "to produce some art using text characters", and the lesson consisted of line numbering and PRINT statements. Voila, a butterfly! So, me being an arrogant little shit, I went all out and made a text animation of a tank driving across a landscape, stopping, raising its gun and firing a projectile, which flew across the sky and exploded a building with "Skool" written on it. Today, I suppose I would be on the news as a terrorist, but then...I got a C. Apparently I "used commands which do not exist", and "used multiple statements on a single line", and "did more than requested". The lesson I learned at the time was that it's best not to scare the normals, and this is true. But it's also true that you need to know when it pays to be exceptional. If this is a filter simply to weed out the unwanted coders, there is no reason to do more than satisfy the solution, clearly and understandably. If it's a "small problem", they don't want an animated tank destroying a house. Professionals solve small problems in a straightforward, boring manner. And if they give you a C, you can do what I did, and insert a "BLOAD" command in the startup of the class disks which causes a naked lady to appear. We had to wait outside for a week while the teacher booted all the machines. Of course, someone always had a reason they needed to reboot. Eventually they gave up trying to get me to confess and simply asked me for help removing the images. This also led to several programming jobs for the school and other schools in the county, and ultimately to my first real job.
It should be fast enough for apps, really. But high performance code still has to stay in native extensions, whereas Java can get much closer to native performance because of the JIT.
Caution: This link redirects to **SPAM** (instadatehookups.com). [**mousceukmilj.com**](https://www.reddit.com/domain/mousceukmilj.com) (aka The Idiot Spammer^^TM ) is a known spam website. --- [**^^Basic ^^Automod ^^Instructions ^^to ^^fight ^^spam**](https://www.reddit.com/r/FightSpam/wiki/basicautomodsetup) 
This is an article about using an API.
Interesting, but couldn't find anything about Python 2 vs Python 3 on that page
Looks interesting. The PyPi description is a bit of a mess. It has to be ReST, not Markdown :(
From the OP: &gt; Pyglet and Pygame have a lot of graphics things I'm not looking for.
I love Python and using it for years, and still can't convince myself that super() is a good thing. Due to my personal experience, overloading of regular, non-empty methods is rarely useful. (Sometimes it is even a sign of a bad design). The only case, when accessing super-class is really important is __init__, but because it is common to have different arguments, super can't be used easily too. There are solutions based on kwargs, but they are often awkward and intrusive: every class in hierarchy must be written with this approach in mind. Frankly, super feels meh for me.
Numba compiles things that you mark and write in a specific way and is efficient for only array-oriented and math-heavy code. With CoreCLR you have nothing to do and it works with any code. It could even be included to CPython in the end if it prouves good enough.
Random fact, or thing I remember hearing once: Using Selenium, for men, I mean the supplement - the vitamin you take with water - is linked with an increased risk of prostate cancer. There are many other antioxidant alternatives, so I wouldn't risk it.
Yep, Photoshop also performs image stitching -- it also supports more than 2 image stitching as well. I'm not sure which keypoint detection and local invariant descriptors methods they are using since both SIFT/SURF are patented (maybe they just pay the royalties?), but keypoints + local invariant descriptors are the "standard" for how image stitching is done.
MPL work perfect in Conda Enviroments. The bug is in virtualenv, not MPL, which makes your post borderline unusable.
Well java isn't suited for that purpose too and... you have Android.
check out https://github.com/pmarti/python-messaging
Its suited far more then python, but anyway google was working very hard on making it not-so-much-java anymore, and then use of the remaining java-ish parts is discouraged. Anyway main reason for choosing java was developers familiarity and tooling, less so its suitability for the task.
WWW.codingbat.com
I would suspect that the situation changes often. He might not want to get 100 and end up not using half of them if he changes work after a few months. Or there may be a use-by limit.
Or mechanize. You could also use selenium with phantomjs to not show the browser. 
~~Partial is the best answer. OP is really just reinventing the wheel.~~ &gt; lines = lambda: lines_generator('file.txt') It always makes me a bit sad when I see a anonymous function bound to a name. Why not just use a normal function? Edit: I take my comment about the partial back. See hbweb500's posts.
Lazyness, mainly. 
Actually, it now became an MPL problem. Up to 1.4.3 the behaviour was annoying but workable. Starting with 1.5.0 it deliberately refuses to work in virtualenvs.
Yes. I never stated it is a bug in MPL.
Just because I am annoyed and venting my frustration does not mean I am not helping. In fact, the primary workaround offered in the MPL docs was done by me. The last PR merged to `virtualenv-pythonw-osx` was by me (7 months ago, and the tool has problems with other libraries). I just don't understand virtualenv enough to be able to fix anything in there myself.
&gt; uses globals. Likewise makes every object a class attribute and declares them all in a big pile in the [dunder]init ("self.whatever") instead of keeping things mostly local in namespaces. I don't understand what you mean. What are "things"? And which "namespaces" are we talking about? There are two namespaces (excluding the namespace inside a function) in python: classes and modules. As you just said no! to globals, that would rule out modules but then you now say don't put them in classes. Huh? Are you really saying don't put variables anywhere? And "class attribute"? If you declare things in dunder init they become instance attributes, not class attributes. Again: I don't understand what you're saying.
The FDA site is not loading. I'll check them out later. Thanks though.
[removed]
It is. Try running MPL 1.5.0 on Mac OSX in a virtualenv. You will not succeed.
I agree with that just because google's implementation already exist, but if they were developing a mobile OS now there isn't a big difference between java and python ecosystem for that purpose. Of course, it's unnecesary and it would need a lot of work to optimize python interpreter for mobile development which google already did in their java implementation along the years. That's the big difference they already did it for java, why would you start all over again for python...
Check out [bokeh](http://bokeh.pydata.org/en/latest/). It's a nice library that outputs plots in an HTML file and you don't even need to know JS. I think they also offer some support for sliders, buttons and widgets. I think the creators are aiming to build something pretty close to Shiny for R, if not even better.
I am not saying "it can't be done", I'm saying "it makes no sense to do it". If you would want to replace language, use something that helps you, not something you have to fight with to fit it in.
Check out Spyre or Pyxley. If you're thinking about making GUIs or dashboard for others to use, I would recommend web-based and not local desktop GUI frameworks since distributing and deploying them will be difficult.
I gave it a shot, but gave up very quickly when I discovered that `mypy` doesn't support Python 3.5 and maybe never will https://github.com/JukkaL/mypy/issues/913 Now I just write Sphinx-style docstrings.
Then drop python 2.
A lot of people don't have a choice about what version of Python they use. Heck, a lot of people are still stuck with Python 2.6.
Yes. Pycharm's type hinting support is decent and it's nice to get extra completions and error checking. Hoping that they continue to add features like smart refactorings.
I had 4 separate utilities that we used at work that were written using wxPython. I decided to integrate them all into one program and after fussing around with QtPython for a few hours I decided to do it using Flask. I already new a good amount of HTML and CSS so making a nice looking UI was pretty easy for me. The program has now expanded to 8 utilities because it's very simply to add new pages to Flask.
By the way, when I implied that it's not the same as element Selenium, I meant it's not elemental selenium. 
I know there are solutions on the homepage *because I wrote them*.
I generally code for Python 9.
As a career server-sider this sounds like the blackest of magics to me. Sure seems like it might be the right way to go for this kind of thing.
I once read a thread here about some guy stuck on Python 1.x. Can you even imagine?
Title sounded like a joke but it makes sense. The only place where I disagree is I think it's reasonable to explicitly test for Python 2 or 3. We don't actually know what the future holds. The most air tight would be adding an else at the end and raising an error for an unsupported version. This would be easy to refactor if it turns out the 3 code is forward compatible. 
This argument would only be accurate if the PSF had an adherence to backwards compatibility comparable with Microsoft does with Windows. They don't. Python 3 is backwards incompatible with Python 2 (which is actually the only reason why you should ever want to check the Python version anyway). Because of this, it's reasonable to expect that any version of Python 4 that might ever exist will also be backwards incompatible with Python 3. And when that's out the window, there's no reason to even think about it when you do your version comparisons. The syntax for your `if` statements which actually checks the version could even change. Furthermore, futureproofing your projects in this way (which is not futureproofing at all) is suggesting that you will not need to maintain your projects in the future. Projects need to be maintained. That is especially true if there is ever another major version of Python you want your project to be compatible with. If and when that does happen, *then* and only then is the time to think about restructuring your version checks.
I just installed Anaconda and ran the following in a conda env: python -c "import matplotlib.pyplot as plt; plt.plot(); plt.show()" And it *still gives me a MPL window which I cannot select using Ctr+Tab*. Am I missing something?
Yeah, that's true, as Python 4 is more likely to be back-compatible with Python 3.
I won't say that it encompasses 90% of use cases, but RHEL 6 (supported until 2020) uses Python 2.6 as its system version, and RHEL 7 ships with Python 2.7, with no native 3.x package available. That's a fairly significant user base who may or may not be able to get approval to install an unmanaged version of Python onto a production machine.
Thank you, that was very helpful. I wasn't really sure what to google for it. It looks like I can use something like this: element = WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, "myDynamicElement"))
I'm trying to understand this comment. Are you saying they missed Windows 9 because the number 9 was already used? And I thought it was for marketing reason as 10 is a fresh start and not 8.
Firstly, it's not inevitable. I have personally been in the same room as Guido pointedly saying he does not intend for there to ever be a Python 4. So such an event would be after his tenure as BDFL. Secondly, if it ever *did* happen, every active project would inevitably have a ton of work to keep pace with any updates that would be required. *That* would be the time to think about version checks.
That's a good point actually, that issue is a direct parallel.
six could always change their PY3 implementation to return `True` for python4 if it were to ever exist if you can assume that python4 is backwards compatible in all the places that currently need checks for python3. This is a non-issue.
What we should be able to do and what we are able to do are not necessarily the same. I have a massive software project I absolutely require that does not support Python 3. I use Python 3 for my own stuff, but I have to use Python 2 when working with that project. It would take months to port. The port is underway, but it is nowhere near ready. I am helping as much as I can, but I have work I have to get done, and a baby, and I am moving to a new country in a matter of weeks. So yeah, Python 3 is not going to happen with that software before I am done using it, and there is nothing I can feasibly do to change that.
I have never heard this before. I also think it's really stupid. A backwards-compatible version after Python 3.9 should be Python 3.10
Really cool script. What was the idea behind using PyYAML instead of reading from a txt?
I don't think you should be relying on `six` to ensure your compatibility with Python 3+. I think you should be correctly coding your packages to handle such situations. 
See [this post by a core CPython developer](https://opensource.com/life/14/9/why-python-4-wont-be-python-3). To quote this post, *My current expectation is that Python 4.0 will merely be "the release that comes after Python 3.9"*.
When programmers wanted to check for either Windows 95 or Windows 98, they did `version.startswith("Windows 9")`. So basically Windows 9 would be treated as windows 95 in old programs. Microsoft is pretty good about backwards compatibility. Yeah, the marketing reason may be some bullshit that they made up. But I'm fairly sure the original reason was that it broke a lot of shit.
About Python 4 https://twitter.com/gvanrossum/status/501172370690699265
But what about Python98?!
[**@gvanrossum**](https://twitter.com/gvanrossum/) &gt; [2014-08-18 01:02 UTC](https://twitter.com/gvanrossum/status/501172370690699265) &gt; Why Python 4 won't be like Python 3: http://www.curiousefficiency.org/posts/2014/08/python-4000.html ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Except Python x.x releases are often not completely backwards-compatible. Python 3.5 was not completely backwards compatible with Python 3.4, for example. What you are describing is called "[semantic versioning](http://semver.org/)", and python does not use it. Semantic versioning is a convention used by some projects, but many other projects don't use it.
No one has said there will be no incompatibilities but definitely nothing even approaching the disruption that the unicode and iterator changes caused.
Thanks!
I believe it's the only browser that works out of the box. If you want to use another browser, you have to download the driver for it.
I think we'd have to be using twelve or twentyfour.
Have you tried using [waits](http://selenium-python.readthedocs.org/waits.html?highlight=wait#explicit-waits) for elements that load lazily?
No reason. Just trying to be hip, I guess.
As far as I have seen, there is no plan to have a python 3.10, instead 4.0 will [come after 3.9](http://www.curiousefficiency.org/posts/2014/08/python-4000.html).
Thanks, I had not, but I found it after dalittle mentioned timeout loops and I went on a google trip. I will have to try this when I get home tonight.
I heard him speak back at EuroPython 2012. I find that tweet pretty weird, in context. I also think it's a bad idea to go down this path. But OK. I stand corrected.
Was there ever direct confirmation from MS about this?
I agree with what you say in principle: dropping 2.x is not feasible because people cannot or will not upgrade. However in terms of the example picked, RHEL does have curated and fully supported installs of 2.7 and 3.x in [Redhat Collections](https://access.redhat.com/documentation/en-US/Red_Hat_Software_Collections/2/html/2.0_Release_Notes/chap-RHSCL.html#sect-RHSCL-Features)
Yes, a handful of small applications for aggregating/searching data. Generally used Python and tkinter. One caveat: If a similar system already exists (or a bunch of systems that accomplish the same thing together), it can be difficult to implement new solutions. In my experience, companies build momentum and it can be hard to steer them toward a different system, even if you believe it to be more efficient in one way or another. It's usually easier to keep the old systems in place because they've been around for so long. If you have seniority at your company, they may look upon your ideas more favorably. Otherwise, make sure that you make a good case for your ideas. Good luck!
Maybe he has changed his mind.
That's what they said about python 3 support... 
Not everyone is able to install software on their work computer.
Really cool, I am interested in the Cython version, that can be improved with `prange` with `nogil`, like in http://wiki.ci.uchicago.edu/pub/Beagle/PYTHON/mandelbrot.pyx
Not that I'm aware of, but it would make sense.
I mean yes, but the point of this post was "dont do `if six.PY3: ... else: ...` do `if six.PY2: ... else: ...`, because it won't break when python4 gets released".
Yeah, who knows what else will break when Python 4 comes out? I would want it to break obviously. My only concern though is that I am reminded of a website I had to use recently that complained my browser was too old, and I had to upgrade to Netscape 4. Another famous example is the "if Windows.version.startswith('9')" issue, where old devs were testing for Windows 95/98 or 2000, not foreseeing an actual "Windows 9". If my code was going to be used in some situation where the user couldn't force the code to run anyway this could be troublesome. Other software I've used gets around this by making the version number an int that always goes up. So Python 2.1.7 would be 200100700. Then these comparisons become '&lt;' instead of '=='.
Why should they break a perfectly good constant to lie to the dev just because some developers write bad code? People should just write the code correctly in the first place, instead of making good code worse to accommodate bad code.
I just added such comparison. Numba is as fast as C.
I plan to try it indeed.
Breaking things 5 years ahead is a good way to cull old cruft and make people revisit code. Planning too far ahead, in my opinion, is bad. 
It's really rather impressive that Numba is as good as it is. Thanks for the updates!
I'm also really new to Python and I'm trying to do this as well. The documentation for the discord API is really hard for me to understand as a newbie.
I honestly was unaware of that - I guess I never dug far enough to find it. Thanks! Going to talk with our Satellite admin to see if we can get those added.
Fair enough, I can see where you're coming from, even if you do stand corrected, but I would still say it is a valid point not to do naive checking that is not semantically safe when it would be trivial to implement strict checking. Disregarding whether or not Python 4 becomes a thing, which it might.
Yes, but back then Python 3 was, at least, a thing. Until now no core developer has started talking about Python 4.
What are you trying to do?
Adding an `else: raise NotImplementedError` doesn't make sense unless you do the same thing for *all* your code. Because Python 4 will be by-and-large backwards compatible with Python 3, Python 3 code is a good default. But those times that they're not are *not* more likely to be those fixed in Python 2. If anything those are the things that most recently got fixed and so the *least* likely to break on upgrade.
not caring about "supporting" a hypothetical future programming language does not make someone a bad programmer.
I've recently seen this rant: [Type Annotations: The Kudzu of Python?](http://inre.dundeemt.com/2016-01-06/type-annotations-the-kudzu-of-python/). The author thinks type hints make function definitions less readable, they should be moved to stub files and you should rather write tests. Personally, I think they're kind of ugly and I'd prefer something like Haskell's type declarations, separated from the function definition. 
That's a really good point. I hadn't thought of it that way.
The advantage of the OP's solution (though it wasn't explicitly mentioned) is that it allows generators to be given as input to functions whose interface specifies a list, tuple, or other iterable, without changing the code of the function being called. It's an adapter, and is actually useful every now and again.
When you have many hours experience writing code, some things - like if/then statements - come naturally and you have physically try, in order to do simple ones "wrong". When you look at the code and think how to add support for version 3, it should be pretty obvious that there's one robust way to do it, and it should automatically be selected by your brain without having to *think* about it.
it's important to note that I use the Async branch because the author says it's better since the older one won't be supported for long. https://github.com/Rapptz/discord.py/tree/async right now, 2 things: pull all members/text channels/voice channels/roles into separate lists that I can use for other stuff. Basically, what I'm trying to do is create permissions for certain commands based on role. Need to be at least a mod to execute this command sort of stuff. 
It's not. Problems generated by too loose constraints have existed since the early days of programming. A newer example would be that microsoft couldn't choose Windows 9 and had to resort to Windows 10, because a lot of old (and pre-8) programs that existed since [Windows 95 only checked if the version string began with a 9](https://searchcode.com/?q=if%28version%2Cstartswith%28%22windows+9%22%29).
Your comment can help me make a clearer/"righter" statement. What I want to say is something more like "makes every object an instance attribute and declares them all in a big pile in the [dunder]init ("self.whatever") instead of mostly within the local namespaces of functions". (so, of course, you can put variables somewhere). And If there is a better way to phrase that last part, please let me know. Thanks for the catches. I will edit my comment once you weigh in.
Yea, I just hope that when the official API comes out it will be better for newbs to understand.
C with what compile options? Those choices can make a massive difference in execution time. 
Python 9 will be self-coding, so I'm already *well prepared* by doing absolutely nothing. 
Chrome requires an additional chromedriver.exe on the system to run correctly
Real automation engineers only code for Python Ultron
Hasn't it been established that 3-&gt;4 is not going to the same level of clusterfuck that 2-&gt;3 was that they felt compelled to make 2.7 just to keep people happy? I overall get the impression that Python in general is more willing to break old code than, say, Java is (yet also willing to keep things synced where sanely possible, whence `import future`), but I remember something about Guido et al being very adamant that 2-&gt;3, while necessary, is not a scenario they want to repeat.
... in Domino's service. Jupyter itself has supported Python 3 since long before it was called Jupyter. ;-)
Sure. Same for Cython. I am using: Target: x64, Release Maximum speed /O2 Enable intrinsic functions /Oi Favor fast code /Ot Omit frame pointers /Oy Whole program optimization :GL Another compiler (eg Intel) may yield slightly better results, but we could leverage it as well with Cython. Numba uses a different backend, it uses LLVM, which may explain the difference. Another difference comes from memory management as I explain in the blog. 
Even if it's not 100% backward compatible, from what I remember seeing they're pretty adamant that 2-&gt;3 was a one-time thing where they wanted to get all of the real pain out of the way all at once (talk about a misfire on guessing how things would go...). Stuff may break compatibility but it's much more likely to be specific things and not a wholesale break.
Yeah I really like the idea of `&gt;=`. This communicates that py 2 is the special case that we support for now and that py3 or py3+ is the way of the future. 
That's not quite true. What they've said is that 4 will simply be the next increment from 3.9, without any backwards incompatibility, and we're already nearing 3.6. So at some point in the next couple of years a lot of programs are going to start breaking, as per the article.
Exactly, there's a difference between saying to hell with hypothetical future programming languages, and just writing shitty code. In principle, I think it's fine to do whatever the hell you want with your code as long as you comment it sufficiently. But all of us inevitably drop the ball on that sooner or later, hence why we should also try to write code that's somewhat self-documenting. Here's an example of a middle ground I'm thinking of--I've definitely written if/else blocks where I actually put the special case in the if block. For instance (and I know I'm probably making some other bad coding decisions here, just roll with it for the sake of the example), if len(x) &gt;= 2: do stuff else: x.append(number) do stuff Specifically to avoid doing `x.append(number)` and then executing `do stuff` *twice* due to the flow of block; I'd rather write it that way than nest another if/else block to avoid the double-execution case. Depending on the scale of the project and whether I expect anyone else to ever have to use it, I might even write it as: if len(x) == 2: do stuff if len(x) == 1: x.append(number) do stuff Because *I'll* know that an exception means that something is wrong with the CSV file I'm reading, and not the Python code. However if I do something like this I'll at least put in something like #the CSV file contains lat/longs if len(x) == 2: do stuff #if a long is missing, for what we're doing it's fine to just make one up if len(x) == 1: x.append(rand_long) do stuff Bam, arguably shitty code (two `if`s with no `else` and I'm only handling two very specific cases), but at least I've made it clear what the thought process behind the code is.
If you don't need anything right away, my team is going to open source our dashboard project very soon. It basically comes with everything: sandboxed plugins, authentication (local, ldap, saml), custom errors, caching, periodic tasks (local to server, and global in a server cluster), celery support, extensive logging, CLI manager, User+Groups management levels, notification channels (e-mail, hipchat, in-browser; both via growler and on-page)...etc. The framework for basic HTTP routing is Flask, but the project uses Tornado as its backend server and a lot of its functionality. We use the async access for databases, redis, websockets, periodic tasks and notification channels. The app can be instantiated in tiers so some servers could only serve HTTP content, while others are responsible for tasks only. Additionally, there's a mode where the dashboard will only act as a base for a single page app, providing all the logging and authentication logic for that app. We also support full GUI customization via LESS. Some screenshots, - [Login page](http://i.imgur.com/PYsgtXD.png) - [Anonymous user access](http://i.imgur.com/M9xZP9H.png) - [Page with loaded plugins](http://i.imgur.com/llsQUWF.png) - [Full screen cycling through plugins](http://i.imgur.com/dXxFa3u.png) It's been my baby for about 4 months, but it's almost time to let 'er fly
&gt; If they had introduced the changes more incrementally adoption may have been a bit better. I beg to differ, because my experience has been that both a "sudden breaking change" vs "small breaking changes" are both troublesome, albeit not for the same reasons. Lots of small break changes are certainly easier to accommodate when taken individually, but they are also hard to keep track of due to the sheer number of them. And after a while, the library authors will get fed up of this "treadmill" they have to walk on from month to month just to accommodate another minor change to the language. Haskell does this all the time and it's certainly annoyed a fair number of contributors. Personally, I just find it annoying to look up "which version introduced this incompatible change?" all the time.
Well, [this](https://opensource.com/life/14/9/why-python-4-wont-be-python-3) is linked to in the article. &gt; I overall get the impression that Python in general is more willing to break old code than, say, Java is Java is still on version 1(.8); they haven't had a major version increment yet, so we don't really have anything to compare.
I personally prefer to avoid version checks at all. Instead I just look for the Python 3 module/function/whatever, and if it doesn't exist, I'll try the Python 2 one. This is one of the biggest advantages with scripting languages like Python IMO: the ability to adapt your own behavior at run time depending on what is and isn't provided by the environment. (Well, except for syntactic changes…)
Fair, but I think it also says at least a little bit about their desire to not break old code that they've gone so long without incrementing a major version number.
Thanks, just wanted to make sure I wasn't missing extra functionality.
Please post your code. No way to tell otherwise. Also this belongs in /r/learnpython 
I could write something with Stripe that would take as many dollars as you want in increment of two.
I can forgive the Python 3 breakage and the early mistakes that led to it. However, a Python 4 situation would be a very bitter pill for me to swallow- it just would not inspire me much confidence in the language. 
Great post, thanks for the tip. 
Ah, yes, the [Windows approach](https://msdn.microsoft.com/en-us/library/windows/desktop/dn481241(v=vs.85\).aspx)
Compared to the old way of docstrings?
\*shrug\* No idea. Maybe they thought people wouldn't be able to stick to that? (And it would need translation in any place that reads it, unless you wanted to name the release Windows IX)
I don't see why they couldn't just market it as Windows IX.
"Hey, have you seen the new release of Windows Icks?"
Yeah, I don't see any problem. It IX what it IX.
&gt; I've heard that question enough times now (including the more concerned phrasing "You made a big backwards compatibility break once, how do I know you won't do it again?"), that I figured I'd record my answer here, so I'd be able to refer people back to it in the future. ... &gt;What are the current expectations for Python 4.0? &gt;My current expectation is that Python 4.0 will merely be "the release that comes after Python 3.9". That's it. No profound changes to the language, no major backwards compatibility breaks - going from Python 3.9 to 4.0 should be as uneventful as going from Python 3.3 to 3.4 (or from 2.6 to 2.7). I even expect the stable Application Binary Interface (as first defined in PEP 384) to be preserved across the boundary. 
Looks good! Be sure to post about it!
over 9000
The name implies that it's for Python 3, if it were for python 3 and up, it should be called `PY3_PLUS` or `PY3_AND_UP`. IMO having a variable that is named `PY3` implicitly also be true for versions that are not python 3 is bad. It's better to just be explicit about it.
The reason why `map()` and generator expressions can't be restarted is that they rely on another iterable object - they can't assume it can be restarted, since there's no way to tell. `(x*x for x in range(1000000))` will work fine, as long as you don't try to store all the values. The iterator protocol is deliberately very simple - just `__next__()`, and `StopIteration` to indicate the object is done. That way it can be usable in almost anything. If iterators had to be restartable, it would prevent you from making files iterable (you can't repeatedly read a file, unless you explicitly tell it to move back to the starting point) or make things like network connections iterable (it would be really troublesome if a library re-made a network request without warning you).
deffo over 9000
I don't think we can ballpark a number for you. It also completely depends on how you're going to tackle it. Just reading it into memory using `json.dumps` is probably going to be a bad move. I'd look into a streaming solution like [`json-stream`](https://github.com/kashifrazzaqui/json-streamer). ^^^^That ^^^^was ^^^^like ^^^^the ^^^^first ^^^^hit ^^^^on ^^^^google ^^^^for ^^^^"big ^^^^json ^^^^files ^^^^python"...
or xvfb with chrome after you get tired of phantomjs loading empty pages without special incantations
Or better yet: if py2: python_2_stuff() if py3: python_3_stuff() else: print("This software is fscking ancient, please don't use it anymore")
Considering the cost and stability issues, Python98SE was definitely a better value.
There's no way to answer that, as it completely depends on the nature of the data. For example, the amount of time that an insert to a relational database takes depends on how many indexes have to be updated, which depends on the schema. It also depends on whether you use batched insert statements. And it depends on whether the database lives on a SSD or a magnetic drive. And it depends on how much memory the database has available to use for buffers. And that depends on how it's been tuned and configured, and the amount of available memory on the machine it's running on. And it depends on what you use to parse the JSON. The module in the standard library can easily achieve 40 - 60 MB/s throughput parsing, but there are other modules that are faster, and which offer a streaming interface. 18 GB of JSON could easily wind up taking 36 GB of memory when converted to a Python data structure, although that too depends on the nature of the data — if it consists of lots of long strings for example, the expansion factor will be small — so unless you have a machine with at least 40 GB of memory you'll need to use such a module. 
The partial he creates returns an iterable, it meets the iterable interface, otherwise you couldn't call `for line in partial()`
https://www.reddit.com/r/raspberry_pi Search through the threads and sidebar, or look for the various projects around, including many home automation projects using Raspberry pi, with most of them utilizing python. 
At work, we have to change our passwords every 45 days, so this comes in handy for me. Please, anyone add new methods to it or make it better. $ python3 newPass.py Phrase to base password off of: shake your body down to the ground 5Y8DtT9 
3.10 comes after 3.9 in version numbering. Unless it's a new major version like Python 3.0 was, then it's 4.0 of course (but that doesn't have to come after 3.9).
Because people are always going to write shitty code.
Do you have a source? [This](https://opensource.com/life/14/9/why-python-4-wont-be-python-3) disputes that and was linked to in the OP. &gt; My current expectation is that Python 4.0 will merely be "the release that comes after Python 3.9". That's it.
I found a few slight inefficiencies in the C code with a brief look through it. Mostly to do with this function. int mandelbrot (double creal, double cimag, int maxiter) { double nreal = 0, real = 0, imag = 0; int n; for(n = 0; n &lt; maxiter; ++n) { double real2 = real*real; double imag2 = imag*imag; nreal = real2 - imag2 + creal; imag = 2* real*imag + cimag; real = nreal; if (real2 + imag2 &gt; 4.0) return n; } return 0; } First of all the nreal variable is completely uneeded and only serves as an extra call to memory. These lines nreal = real2 - imag2 + creal; imag = 2* real*imag + cimag; real = nreal; Can be rewritten into this imag = 2* real*imag + cimag; real = real2 - imag2 + creal; And the variable nreal can be omitted entirely which saves a variable transfer. Second the order within the loop is also wasteful. for(n = 0; n &lt; maxiter; ++n) { double real2 = real*real; double imag2 = imag*imag; nreal = real2 - imag2 + creal; imag = 2* real*imag + cimag; real = nreal; if (real2 + imag2 &gt; 4.0) return n; } In this situation the only variables needed to evaluate the exit statement is real2 and imag2. The variables nreal, imag, and real only need to be recalculated in the event that the exit criteria is not met. Therefore a slightly more efficient way to write it would be as follows. for(n = 0; n &lt; maxiter; ++n) { double real2 = real*real; double imag2 = imag*imag; if (real2 + imag2 &gt; 4.0) return n; nreal = real2 - imag2 + creal; imag = 2* real*imag + cimag; real = nreal; } Also one other minor tweak is that the first iteration of the loop will always fail the criteria since the initial value of real and imag are equal to 0. So you could save a little bit of time by unrolling the first iteration of the loop which would be the equivalent of setting the lowest index of the loop to n=1 and setting the initial values of real and imag to creal and cimag respectively. But of course you can probably do this in both Python and C so it doesn't do much for language comparison. So the final version of the loop I got was for(n = 0; n &lt; maxiter; ++n) { double real2 = real*real; double imag2 = imag*imag; if (real2 + imag2 &gt; 4.0){ return n; } imag = 2* real*imag + cimag; real = real2 - imag2 + creal; } On my work computer the original routine averaged about 2.85 seconds per cycle while the new routine was 2.65 which was a 7% increase over the previous version for just shifting a few lines of code around. Based on a rough approximation from your numbers that would put the C code at around 2.53 which puts it slightly below the Numba code. There's a few other spots I think could be optimized as well to yield even further improvements (the thing about C is there are a million ways to optimize it), but just mostly showing how small changes can make a difference for computation heavy parts of the code. Still though, pretty impressive when you think about it that Numba can come that close. 
You know how people complain that there's not enough new stuff in Python 3 to warrant the upgrade effort? Yeah...
code made today will still be used when python 4 is released, let's prepare for it now to the degree we can using the information we have, as long as it doesn't break current uses. We know today that "if not 3 then 2" will cause issues with 4 and having it work for 4 won't break 2 or 3 (in this case). 
but that'd detect 4 as ancient, like many sites that don't recognize newer browsers. 
So, you mean you're part of the problem then? :P
Crazyness. No, big changes are definitely better. You don't want bugs to pop up, and you don't want to have ten years worth of deprecated stuff.
v==4 is a breaking change for code that expects v!=3 to mean v==2
[**@gvanrossum**](https://twitter.com/gvanrossum/) &gt; [2014-08-18 01:02 UTC](https://twitter.com/gvanrossum/status/501172370690699265) &gt; Why Python 4 won't be like Python 3: http://www.curiousefficiency.org/posts/2014/08/python-4000.html ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
How so? 3 &gt;=3 and 4 is going to be backwards compatible.
No, it's detecting *itself* as ancient.
that's what I meant, it's detecting "ancient"
it could be that 4 introduces a better way of doing something, in which case you might want to code: if py2 or py3: old way else: new way
Bokeh is awesome, but if you should also check out dc.js, a great Javascript library, that enables quick development of dashboards with minimal coding. 
I'm starting to worry about Guido lately. :-( Mypy, betraying Mercurial, f-strings and other syntax changes... everything Python used to do was always the right thing. Now... it's questionable. He's apparently even slammed the Zen Of Python. :-(
&gt; That isn't duck typing though. That is (more or less) explicit type introspection. I don't see that. It's accepting *anything* that matches the iterable interface (there's your duck typing), and it's saying that if two iterators are created they should be different objects. No type checking is involved. I'm inclined to side with /u/TeamSpen210 on this issue: I like Python's iterator protocol because it is optimized for the common case. As you point out, the protocol allows for types matching the same interface to have different iteration behaviors (lists are "restartable" while iterators are not), but I see this as a *strength*. It's my job as a developer to take the abstractions offered by the language and to build up my own higher-level abstractions. It seems that what you'd like is for Python to implement a protocol similar to the C++ STL containers, where, for example, `std::forward_list.begin()` returns a `std::ForwardIterator`. For what it's worth, I find Python's containers and iterators to be much nicer to work with, while C++'s approach might be more theoretically pleasing.
That's fair.
Used Selenium a lot last year, liked it a great deal, found the Chrome driver to generally be less hassle than FireFox driver (ymmv, also seemed to run a lot faster out the box).
I don't see it as being "optimized" for the common case at all. Most arrayish things are short and fast. From a developer perspective the "optimum" (easiest to conceptualize and work with) is a list. From a cpu perspective computing the entries may be faster, but that is irrelevant to the question of whether or not the expression should restart. In the common case these expressions can restart with no negative impact. It is in favor of the extreme case that these expressions do not restart, not the common case. So I don't see how this is optimized at all. 
this one doesn't use any of the boilerplate for logging module and more over, it does the job for you, rather than writing a custom logging system every single time.
I love vim for actual coding (as in making edits and changes) but for learning a new code base, I lean toward setting a breakpoint and riding Pycharm's debugger through it line by line.
Dude I want I want I want. 
The problem is, I am not an experienced coder. Do you think you think you could teach me how to do the easiest option? EDIT: My brother (much better programmer than I) helped me write a bash script to do option 2. Thanks for the help!
It's why Java is seen as stale and people want to use Scala. I'm a C# guy by trade and Java devs tell me they prefer C# and say the commitment to backward compatibility is really holding the language back.
/r/django
I find it is easier to put data in elasticsearch and then use Kibana to create dashboards
That's my point, they're not going to go to go to Microsoft (or, you know, Java) levels of trying to be perfectly backward compatible forever; while they tried to get the real pain out of the way all at once, they're not going to taking it to the point of being unwilling to *ever* break *some* small slice of backward compatibility even if there's a good reason to do it.
The common case (in my estimation) is iteration over finite collections of objects. Python optimizes for this case by making it very easy from a programming point of view. I do not need to know how to find the beginning of the collection or how to restart it. Python's language constructs do this for me whenever I call (explicitly or implicitly) `iter(iterable)`. Generators are not collections in the usual sense. A collection is finite. A generator may not have a well-defined size. A collection can be "restarted". It may or may not make sense to restart a generator. Generators satisfy the iterator protocol, but that *does not* mean they are (or should be) substitutable for collections. Let me revisit your example to demonstrate what I mean: def mean(arrayish): tot = sum(arrayish) return (x/tot for x in arrayish) You argue (if I understand correctly) that `mean` should function properly when given *any* iterable by default. But I don't think that's the right level of abstraction. Intuitively, `mean` should function correctly when given a *collection* of numbers. Again, a collection is an iterable with special properties: it is finite. The role of the generator here is to aid in implementing efficient collections. For example, suppose we wanted to compute the mean of a bunch of numbers from a big file on disk. We might settle on a format where the first line of the file denotes the number of entries contained within, and the remaining lines are the data, like: 5 1 2 3 4 5 I could write a simple generator to yield the numbers from the file def generate_numbers_from(path): with path.open() as lines: next(lines) for line in lines: yield int(line.strip()) But this abstraction is weak. It doesn't reflect the fact that we know that there are only finitely many numbers, and that we can restart them. So we wrap it in a collection. import pathlib class NumbersFile(object): def __init__(self, path): self._path = pathlib.Path(path) def __iter__(self): with self._path.open() as lines: next(lines) for line in lines: yield int(line.strip()) def __len__(self): with self._path.open() as lines: return int(next(lines).strip()) I think this is the perfect level of abstraction. It reflects the fact that our file of numbers is really a collection, but it abstracts away the act of actually reading the numbers in a way that makes the whole process very efficient.
&gt; This software is fscking ancient, please don't use it anymore If I ever see a piece a code fail with this error... I'd just kill everyone around me and go fishing, or just be very very angry.
 #Target Python versions 90 through 99 if (version.StartsWith("Python 9")): pass else: pass What could possibly go wrong?
Absolutely. There's a package I use that broke backwards compatibility between 4.9.6.2 and 4.9.6.3. Ridiculous.
It's not that hard.
yeah, I needed to nail down the specifics of the tags I was scraping. I had done it for the table (table =findAll.table attr{things: stuff}) ...or something similar. Then I did it again for the data tags. Thanks for looking.
I have to disagree. In your example there exists a current maintainer to fix problems with the code. As long as a project is maintained, then there is no need to worry about potential bugs because someone is around to fix then as they come to fruition. The concern is abandoned projects. If someone were to follow your suggestion, then the abandoned project is broken regardless if py3 and py4 are compatible or not. With the author's suggestion, there's the possibility that py3 and py4 are compatible so users will be none the wiser. This is precisely the current problem with py2 and py3. There's so many projects that exist that are abandoned or the maintainers will-not, can-not, or for whatever reason do-not upgrade to py3. That cascades down to dependent projects and forced then to stay at py2 as well. When the maintainers disappears, a vacuum is created that forces downstream users to pick from a few unsavory options. Take over the abandoned project, replace it and refactor their own code, live with it, or abandon their own project.
This might help, Shuffle the lists &gt;&gt;&gt; import random &gt;&gt;&gt; a = [['a','c', 'xy'], ['r','a','n'], ['d','o','m']] &gt;&gt;&gt; random.shuffle(a) &gt;&gt;&gt; print(a) [['d', 'o', 'm'], ['a', 'c', 'xy'], ['r', 'a', 'n']] &gt;&gt;&gt; random.shuffle(a) &gt;&gt;&gt; print(a) [['d', 'o', 'm'], ['r', 'a', 'n'], ['a', 'c', 'xy']] Shuffle both the lists and each list's items: &gt;&gt;&gt; random.shuffle([random.shuffle(c) for c in a]) &gt;&gt;&gt; print(a) [['xy', 'c', 'a'], ['r', 'a', 'n'], ['d', 'm', 'o']] &gt;&gt;&gt; random.shuffle([random.shuffle(c) for c in a]) &gt;&gt;&gt; print(a) [['c', 'xy', 'a'], ['a', 'n', 'r'], ['o', 'm', 'd']] **By the way** random.shuffle() returns None. It just shuffle whatever list you passed. so: myNone = random.shuffle(myList) is an empty variable :) 
`print(random.choice(displayfinal))` should choose a random item from the list
Yeah, but if your script is a full major version out of date it's not gonna work anyway.
Depending on what you're doing, the practicality of that changes vastly. I definitely agree with it to a certain extent (and `__future__` certainly helps), but if you can't predict what environment you're going to run in, it gets far harder. I have a project that needs to be able to run in Py2, py3, and pypy (only the python2 version, fortunately) on multiple platforms (including Windows) and deal with sockets. All of that adds up to a lot of tests to make sure it runs in all possible environments, and I've so far avoided having to use six or check for version numbers. (I do use 3to2 on my code to strip out annotations for the 'run this' version.) But if I needed to do something differently on Python 2, I would do it in a heartbeat.
Even if Python 4 were to break things in a major way, it would likely not break the same things. Your code would probably break, but stuff that already changed in Python 3 got a major revamp far more recently than other parts of the language.
Even if it doesn't work, it's a far better assumption that correct implementation for Python 4 (or 5, or 22) will be the way Python 3 does it than the way Python 2 does it. Literally every block of code not wrapped it a version-checking conditional makes the implicit assumption that the way it's written will be correct in the future.
1. It will always be difficult. Always. As soon as you know how to do something, you'll move onto something more complex. You will get better at writing code that works well the first time, and there are certainly some practices you can use that make debugging easier, but the process of programming never becomes easy. 2. Yes, but you won't notice it. As soon as you master something, that will become easier, but there's always something else to learn. I've been programming for 30 years, and it's still hard, but the things that were hard for me in the eighties aren't hard any more. Now I'm doing new hard things. 3. This is an attitude problem. Just because it's in the terminal doesn't mean it isn't cool or useful. You're young enough that all the programs you know seem to run in a GUI, so it's OK that you think it's not a real program until it has a user interface. It is not difficult to build a GUI in Python, but there's really no need to rush it. For one thing, all the GUI engines require some knowledge of Object Oriented Programming, and you don't need to get too involved in OOP until you're comfortable with procedural programming. Patience, my young Padawan. Most of the coolest programs I've written do not have a GUI. (Multiple game engines, a database interface tool, a multiplayer game server) 4. Practice practice practice. This is not a skill you learn by watching. It's a skill you learn by doing, and most of your doing will involve failing. That's fine. It's normal. But you're going to mess up a lot. It's part of the game. Get help from a good teacher, not just a good programmer. There's a world of difference between the two. If you can find a good programming teacher, do everything you can to learn from him or her. Most respond well to food. edit - formatting
Thanks for the great reply. Are you a programmer for a living? Furthermore, I understand what you meant about GUI, but truly, it really isn't interesting at my young age to write terminal applications. 
Breaking things in the way the post describes is pretty bad. It results in code not being executed, or code that targets Python 2 being executed. Both of these are bad errors. In the case of the first it can make debugging harder than it needs to be. Code that doesn't execute doesn't throw errors, maybe doesn't even crash, and is harder to find. There really isn't a reason to break code in this way. Maybe raise an informative exception. Then you just force someone porting the code to review it.
I'm a programming teacher for a living. I do professional coding jobs for fun and money, but my main job is teaching computer science and writing programming books. Success is fun, failure is not. If you are building programs that you understand, you should be enjoying it. Really, GUIs are over-rated, and are not that fun to build. You HAVE to get away from this notion that pretty == cool. I've taught many people much younger than you how to write terminal applications. You can start with GUIs much earlier, but I've learned that one of two things happens. 1. You end up with boilerplate code you don't understand, and you feel like it looks good but you didn't write it. 2. You simply aren't ready for this part and you give up on programming because it's too darn hard. Look at it this way. If you're a basketball player, you probably want to slam dunk, but that's not something that's going to happen in your peewee basketball league, or even in Junior High. Big plays have to be earned. You have to pay your dues, and the GUI is something you'll be able to do well after you understand some fundamentals: * variables * loops and branching * functions, parameters, return values and scope * lists and tuples * basic OOP As soon as you've got those skills, you can use them in a GUI. But it's completely wrong to think that it's not a 'real' or 'fun' program until it has a GUI. Many of my students feel like you do until they do write a GUI, and then they often go back to the command line because most of the most interesting programming is not about the user interface. In fact, that's frankly the most boring part. I wonder if you're letting the perceptions of others get in your way. If you show your command-line program to your friends, it looks like something from the eighties, and they may deride it. Let them. The ugliest thing you've ever built is better than the nothing they have made. Visual Basic is part of the reason for this attitude. It's very attractive to beginners because it makes it very easy to build a GUI. But this process tends to distort people's view of programming, and it leads to some very bad habits. Give me an ugly command line program that does the job over a pretty GUI that doesn't work any day of the week. 
I use it, because it'll make my code easier to read when I stumble upon it again in half a year. Also for writing new code it makes me think more about how I design my functions/APIs to make more sense.
Caution: This link redirects to **SPAM**. [**yfrmazuy.com**](https://www.reddit.com/domain/yfrmazuy.com) is a known spam website. --- [**^^Basic ^^Automod ^^Instructions ^^to ^^fight ^^spam**](https://www.reddit.com/r/FightSpam/wiki/basicautomodsetup) 
Thanks! It worked
I just finished the french MOOC in ocaml, and I don't want to live without Algebraic Data Types. It's just so excellent. But in the real world I use Python a lot, because it has so many excellent libraries and so much excellent documentation and community and tools ... so the typing hints could be great. But I'm not confident that I understand it very well. I don't understand why test3 below is not detected by mypy, but it is not doing my confidence in the tool much good. import typing def test_ordered_dict(od: typing.Dict[str,int]) -&gt; typing.Dict[str,int]: return 1 #type error 1 a = test_ordered_dict(1) #type error 2 def test_me(): a = test_ordered_dict(1) # type error 3 is not reported and if you do know why, earn yourself some SO reputation: http://stackoverflow.com/questions/34757469/mypy-not-detecting-a-basic-type-error
It may. You do not know how things will evolve later, backwards compatibility could be preserved better than between Python 2 and 3. There is no reason to break working code. If the code is written properly and the Python 4 backwards incompatible changes are implemented in a non-confusing manner, the script should fail with an error that will be more useful for debugging than a printed message. This is a thing that Python core developers always keep in mind when writing incompatible changes : how will things fail and whether the change may incorrect results rather than raised exceptions, and again, the gist of the linked post is that we should not expect 3-&gt;4 to happen the same way as 2-&gt;3. Your version of the snippet just no-ops on a non 2/3 major Python version. 
I think author of this post just want to satirize the incompatibility between py2 and py3. 
What I meant is that it's based on the presumption that the version of python is either 2, 3 or ancient. This is of course a dated presumption when python 4 becomes relevant. 
Ancient weapons and hokey religions are no match for a good text editor at your side.
You meant PHP.
https://github.com/davidhalter/jedi-vim
I too have similar concerns...Ultimately what appears to me is that Python has succumbed down to marketing forces rather than stick to core values. 
This may be an ETL situation. Part going to a DB and part being written to CSV. I don't have details of the process, but just curious if this is something I can feasibly do on my computer or do I need to find a better system to run this on? Anything can be done if you have the time.......just something I thought that I would ask. Thanks, then I guess I should ask, What is the most efficient way to consume a file this large......I'm a newb to python, but can google if pointed in the correct direction. Thanks!!
That's a good idea! I'll make another method like hackify or something that does what you're suggesting.
Meh, just a dumb joke. Perl GA versions are always even numbered while the odd numbers are used for development versions. 
Well, PHP literally skipped 6 entirely, and went from 5 to 7. https://philsturgeon.uk/php/2014/07/23/neverending-muppet-debate-of-php-6-v-php-7/
six should remove six.PY3.