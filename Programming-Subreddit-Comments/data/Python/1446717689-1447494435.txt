That's a gigantic requirements list for something like this, I assume that's not needed. Otherwise I think the coding looks great.
The article only covers the test part but there are [many reasons to have a src layout](http://blog.ionelmc.ro/2014/05/25/python-packaging/).
The problem *isn"t* that the tools don't autofind his code, it's that they try to and fail by finding the wrong code, which can lead to hard to detect errors. The entire problem is that everything appears to just work without this approach. There's no error message, if you don't do this, no problem that immediately jumps up at you and needs fixing. Chances are you're never going to look into this until you suddenly find yourself with a broken release and no idea how this could've happened.
It's a nice library, though if I may recommend some things. 1. You might want to clean up some crud.. your requirements.txt should only list items that your app needs, not what your dev machine had installed 2. remove all __pycache__ directories.. and create a .gitignore list that contains all those standard yet useless-for-version-control files ( [for example this is what I use](https://github.com/Xaroth/libzfs-python/blob/master/.gitignore) ) 3. all the get_&lt;var&gt; functions are not really pythonic, I would really, really recommend using properties, or just plain attributes.. you can offload the check for strip 404 in the __init__ function instead of doing that every time you get a prop. 4. instead of creating requirements for 3 different libraries (urllib, requests and wget), it would be much cleaner to stick with just one.. urllib is builtin so won't require external libs, however, requests is easier in use. 5. Seeing you're making a library, you would please API hosts (in this case XKCD) a lot if you give your library a specific user agent.. that way if you unintentionally cause issues on their API, they know where to report it so it can be fixed. Overall, neat little library, keep up the good work.
The ancient, flaky server it was running on got replaced. Stuff was migrated to the new server, but somehow some of the configuration went wrong, and the wiki seems to have disappeared. There's a static dump of the old wiki content at https://scipy.github.io/old-wiki/pages/AllPages.html for now.
Pro tip: Use random.choice(list) to choose randomly from a list instead of randint making an index. It's basically the same internally, but random.choice looks nicer.
I wouldn't call the GIL a "flaw" - it makes the implementation simple, robust, and predictable (how many critical security issue pop up in CPython compared to Java?!). It's a tradeoff. It's also not automatically a barrier to success - note that the hugely hyped NodeJS also has a single threaded design (in fact it probably is MORE annoying to do parallelism in Node than CPython, since we now have concurrent.futures). NodeJS is fast because Google poured vast resources into the V8 JIT vm for javascript. I think using CPython as a baseline interpreter for the runtime is an excellent idea and is proven in Mozilla's SpiderMonkey JS engine (which is one of the fastest out there). For a huge range of workloads (especially in science) a Python JIT is useless if you can't use the vast array of scientific libraries, which means a high level of C API support. 
Yeah...seems every package they have on their system was included in the requirements. Glimpsing over it, it looks like all you need is beautifulsoup, requests and wget.
Nice article 
It's been fixed. I pushed the wrong requirements.txt. I had the right one in the previous version, accidentally dropped in a recent one I made from my Anaconda distribution.
*Nice language you've got there, would be a shame if something....happened to it. You wouldn't want variable declaration now would you, terrible thing to happen to such a nice language*
I've already fixed point #1 (Anaconda overwrote the previous r.txt), and I'm working on implementing 2 through 5.
You can also use Python with Kivy to write all sorts of touch screen games and apps for mobile devices. You can write email clients. Websites. Linux command line tools. Desktop GUI applications of almost any sort. People on this subreddit are writing python scripts that reconfigure their GPU display settings. Heck even non-python projects can make use of extensions written in python. I'm sure Kali Linux, arguably the best OS for penetration testing, uses many python tools. In fact I know it does. Linux is so dependent on python that if you change the PYTHONPATH on a Linux system (to use python3 by default instead of python2), it breaks the OS, because so many tools used by the OS are written in python2 format. Ubuntu is my shit, and Ubuntu doesn't even have a $PYTHONPATH variable, so that people don't fuck with it. You can still view the paths with the sys.path function, it just gets it's parameters from a text file in the Python directory for security reasons. If Linux uses python that much, you can only conclude that virtually every Linux based device and virtually every webserver is powered by python in some way. There is so much that python can do, that I can't even think of many reasons I would want to learn another language.
Essentially, it's an alternative model to asynchronous programming for [the C10k problem](https://en.wikipedia.org/wiki/C10k_problem). Microthreads are generally simpler for most programmers to reason about and work with than asynchronous models. Stackless, like Twisted, was *way* ahead of its time. To an extent, they had their thunder stolen by `golang` and `asyncio` respectively, despite being a decade older…
Requires kernel patches, no?
It's a good article. And it's good to compare this approach to hand-crafting a solution. But it would be better to compare this to an ETL tool, as well as to a custom-written event-driven ETL solution. Also, would love to hear more about: * testing * packaging &amp; deployment * distributed processing * monitoring * auditing of business rules and their changing results over time * performance, scaleability &amp; distributed processing * python 3 * pypy 
I think they genetically evolve an affine transform and used pixel intensity comparisons for error measure. The evolutionary step could be trivially implemented using python+cv2 but I guess it depends on the error metric quite a bit.
What is a "gb"? g-bit?
We need more info. What error are you getting?
It seems to run but it just returns "401" over and over again 
[That means you are unauthorized](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#4xx_Client_Error) Please tell me you set the CONSUMER_KEY, CONSUMER_SECRET, ACCESS_KEY, and ACCESS_SECRET variables with the proper credentials from https://dev.twitter.com/
yes, i entered the correct information for my given app and still received "401".
Check the timestamp on the files using os.path.getmtime() or something like that, store the last time your script ran and assume any file created/modified after that is new. 
&gt; don't want to have to manually figure out which are new by comparing each one to a list Then have Python do it! Keep a list of current files, use os.listdir to get the current list, and compare them.
So does that make stackless more similar to the way that nodejs works? 
But can it download the What Ifs? 
This is good to know I was looking for their Cookbook page about Data Smoothing some months ago and was flabergasted that the old Wiki was somehow no longer around. I wanted to be sure I could reference their data smoothing code if needed as I adapted some of it recently and got a little nervous that that page was no longer available. TY for the link
An alternative, if you want an easy fix, you could turn the folder into a local git repo, and simply perform an add+commit once you're done processing the files. 
Reddit, Youtube, Dropbox to name a few big name ventures. IIRC Bank of America and JPMorgan Chase switched to using Python for some of the software they develop for financial trading (the names escape me at the moment). I learned a little bit about how large companes have invested in python by watching/reading some of the info provided by a video about Enaml (Declarative GUI language extending python) https://vimeo.com/79536617 The entire field of 'Data Science' is seeing python as a novel tool with lots of large companies adopting it for their workflows [source: a few friends who work in financial data science] 
I dont have a full answer, but the most obvious thing from glancing at [the airflow tutorial](http://pythonhosted.org/airflow/tutorial.html) is that it is a top down spec of the DAG with manual creation of connections between nodes. By contrast, connections between Luigi elements is implicit and bottom-up.
Well, glad I ignored that upgrade popup so far then.
Has anyone noticed that the Prolog programming language is an implicit data pipeline?
Oh, see that? Boris here throws exceptions when he's angry.
.. if you do the price goes from $199 to $0..
Okay then, that's going to be the first item in tomorrow's todo list.
Ok this plus the version specifiers /u/billsil brought up is exactly what I was trying to figure out. Thank you!
First of all, posting your CONSUMER_KEY, CONSUMER_SECRET, ACCESS_KEY, and ACCESS_SECRET is basically like posting your username and password. Bad idea. Second, are you getting an error message?
Beyond the areas that people have already covered, Python is also used in: - Technical Art (interface with Maya, Blender, etc) - Build/Deploy Pipelines - Test Pipelines (where I make my living)
Great work /u/makaimc!
There's no API for accessing the What-if posts.
[removed]
Is pip install -r ever used in automated deployment? It seems like it would come in handy there for keeping your deploy scripts dependency independent over the course of development.
This sounds like a fools errand. What is your companies investment in Tableau and why would Bokeh be a better fit for them based on you alone using python?
Note that the seaborn style sheets are separated into those that control size (or context), style, and color palettes, so it may be better to use 3 at a time. For example, `seaborn-notebook`, `seaborn-darkgrid`, and `seaborn-deep` combined would give you the defaults as if you imported seaborn. 
/r/learnpython
Tableau can be taught to analysts who don't need to learn how to use Python to use it. Bokeh can't. Your bandwidth is limited; if you do your job right you should have other people generating reports out of Tableau.
good call. it's been a few years since I used Hyde and didn't realize it was still being actively worked on. added under the implementations list, thanks!
thank you! appreciate it! what other topics would you like to see in the future?
Do you know if the company will be looking for new grads / soon-to-be graduated anytime soon? I even wore my UltiCoder shirt today.
&gt; A Day In The Life: &gt; &gt; * Start your day off right by meeting with your teammates to make sure that yesterday’s challenges are today’s wins! &gt; * Get together with your Business Analysts, User Experience leads and Quality Assurance Engineers at the story kickoff meeting to make sure the code you write is building the software that you want to use &gt; * Want to talk shop? The tech standup is the place to do it where you meet with your fellow engineers and platform leads to make sure your code is using the latest and greatest practices and patterns &gt; * After lunch, head on over to a design meeting where you are working with the analysts and fellow engineers to determine what the code and product will look like just a few months from now &gt; * The team only gets stronger at monthly/quarterly retrospective meetings where your small ideas can have a big impact on how your teams days are going &gt; When the day is over, by using our internal communication portal, Ulti Home, you plan on playing poker, volunteering, or going on a run with other Ulti Peeps! &gt; «500 engineers, no work done whatsoever, despite all the meetings we're having? I guess we'll have to hire more»
I remember emailing files and etc. to myself and others like 10 years ago. Nowadays I have far fewer headaches using dropbox for spreadsheets and private git repos on bitbucket for code. The time spent setting up these systems pays for itself quickly. To answer your question more directly though, if you are emailing these things to yourself, I guess it's worth trying to rename it to myfile.py.txt and see if you see previews that way.
Honestly, when I started digging into their code it was - in my opinion - way over engineered. And as far as helping them get to py3, they seem much more involved in the [Invoke](http://www.pyinvoke.org/) (a python build project that looks quite promising) project than the python3 port. So between those two I decided to write my minimal implementation. I was, and still am, a huge fan of Fabric. I just know that all of the other tools I've been using have been on Python3 for over 3 years and Fabric just hasn't moved towards py3 as fast as I would've liked. Also, when your project lead starts asking why you haven't moved to python3 for all your work, they are not exactly impressed that a single project is holding you to python2.
We can have the full list of (python) static site generators, sorted by github stars / forks / issues: https://www.staticgen.com/
Nice. This is with version 1.5, yea?
Well, I suggest nikola's own website of course. Mate Desktop's site: http://mate-desktop.org/ and an original one, a bit artsy: http://tedyin.com/ 
That's great. I'm super excited to hear it. But from what I've seen the py3 port has been on the planning table for over two years. The mountain ceased its motion in my direction, so I strolled to it.
In the true nature of right tool for right job, i'd suggest just using find (if your on windows, which it looks like, get mobaxterm or some unix tool set installed). Then a find . -newer FILE ; touch FILE will give you the list
The csv module understands multiple dialects, surely one of those should parse it cleanly..
...Sphinx isn't included? It's the classic Python site generator!
When I was using Tableau two years ago, the deployment of a report from dev to test to prod required manual *interactive* report changes. You could go under the covers and modify the XML but it wasn't a supported method. That alone pushed me away from Tableau. On top of that it required a windows box, and I was running linux so I had to buy another box just to run Tableau. Then creating really usable &amp; reliable dashboards was a huge PITA. It seems like the tool is better for making a pretty report, but anything beyond that and you start hitting diminishing returns. If your report-writing staff can write code than python could be much better: you can test, deploy, and transform data much better than you could ever with tableau. If they're not technical, then you don't have many great options.
Glad to hear it!
I'd like to start a static site generator that you can run locally and get a Django-admin style backend site, but then click a button and it uploads static pages to S3 or your net host somewhere. Best of both worlds. The reason I don't love the "use text files" approach is you end up having to write a bunch of YAML for the metadata, when it would be nicer to just use a CMS for it. 
Interesting. So these take some formatted text and write html files to the folder of the server where they are served unchanged again. As opposed to say php creating the html on thefly for each visiter. Do i have that right? 
matplotlib numpy Are those required modules free?
Pftt, MS Word can do that too. /me ducks
[Mynt](http://mynt.uhnomoli.com/) might be worth a look.
Yes. In a pinch i have used it. But it cant create inter page links or can it?
Canada
Ohhhh! Thanks very much! This looks awesome! 
I get `&lt;class 'type'&gt;` Anyway, what's odd about that? That's what type is.
Tableau isn't necessarily geared toward the same crowd as someone proficient in Python. And Tableau is also expensive, relative to open-source software (yes, there's server costs and such, but it's generally much lower than the $500+ a month you'd be dishing out per user to Tableau). That aside, Tableau, via its visual-QL (aka drag and drop shit to make visualization), does allow non-technical users to achieve what would otherwise be quite technical, or make technical users much more efficient in generating complex queries. 
Cool I might use that to redo a big page i have into a multi page. You cna always hand edit some php or something into the resulting pages but it starts you off. Does it do the multiple links at the manually set page breaks in word?
That's actually a relatively small file size though.... I've seen some files easily reach into 3000 LOC
That's awesome! I'm going to implement this as part of the Flask based CMS I'm building. Someone else here mentioned that they wanted a CMS backbend that generated a static site...
They're all okaaaaaaay. I wouldn't really call any of them pretty, though they're certainly far from ugly. Why can't there be a stylesheet that makes plots look like [this](http://www.randalolson.com/2014/06/28/how-to-make-beautiful-data-visualizations-in-python-with-matplotlib/)? Ever since I read and made some plots using ideas taken from that article, I haven't been able to see all of the useless 'chart junk' that has been drummed into us from school days.
It's a fine idea and would work, though seems a little unnecessary. Are you building a version for web too and don't want to duplicate the work for both versions? I'd expect you run into usability issues if they need to run two things just to use your program, however. E.g. So I have to start this one program, then go to http://localhost:3000 to use it?
How is this not farther up?
No need to make copies. If you are relying on the .py extension to associate your script with Python then you should know that this is easily circumvented. Use shebangs if your environment can interpret this. Otherwise, explicitly invoke your script with python. So normally if you'd just write "hello_world.py" to execute your script, do "python hello_world.txt" instead. By explicitly invoking python with your script, the extension doesn't matter.
Look at electron or nwjs 
I'm looking at this approach because electron - or more specifically node.js - is a nightmare of errors. Every single step of the path halts in a concrete wall which must be either scaled, tunnelled under or blown to bits, whilst I feel armed with a pair of chopsticks and a firecracker.
You could go on a quest for the Holy Grail.
Even the FIFA got rid of Blatter.
Yeah, that's a start. Maybe I should look into making my own seaborn stylesheet.
Yes, as I said MATLAB OOP isn't anywhere near as nice as with python, but it is at least usable.
Thank you!
That's a great idea! I'll think about it ;)
&gt; &gt;&gt;&gt; sorted('abcABC', key=str.lower) Wow, that is such an elegant way of expressing what you want done.
Hi acpcalin. Have you tested REMI?
I like how the library is 'for humans'. That is original.
The edition in a web interface will be the most difficult to get. I just read [an article](http://www.smashingmagazine.com/2015/11/modern-static-website-generators-next-big-thing/) referencing [prose.io](http://prose.io/#about) which makes possible to write and publish posts with a nice markdown editor from github. They talk about a couple more solutions (look for prose.io in the page).
I feel this is true for most complex software products where user interaction is not limited to an abstracted surface layer. OS's are another good example, though arguably a order more complex again. It used to be a running joke that you never upgraded Windows until SP1 of the new OS released. Actually it's probably still true, they will have just automated the error catching and worked it into their always-on data upload.
Good to know, thanks for the explanation.
I made exactly the same thing for one of my clients. I built a desktop application using Qt4/PySide; this application stays minimized in the system tray and offers a small menu from its icon: show configuration window, quit. The configuration window is used to set a small number of parameter including the listening port of the web server. Besides this native interface, the whole production interface is accessible through the web server integrated in the application. The web server is the standard library's http.server.HTTPServer, using threads (for my client's usage of estimated 10.000 connections/day, its performance is far beyond what is required). If needed, it is accessible from other machines in the local network. edit: typos
What is this library? The github says "simple things make the world simpler" and doesn't explain what it is until half way down the page.
I guess I don't see why stuffing everything into one line functions such that they become inscrutable is a good thing.
lol
Not in vote count, poor guy....
Can you please give me an example code? Would really appreciate that.
Do you like programming?
Ever since I saw I post about it in this sub, I've been using [toyplot](https://toyplot.readthedocs.org/en/stable/tutorial.html) whenever I can. It's plots look superb and the stand-alone html files are very small.
Oh snap, those are some nice fucking plots. 
Yup, can't seem to figure it out 
I had a problem like this with this combo (Windows / PyQt4 / Python 2.7 and PyInstaller) As far as I can remember, an update to VGA driver had solved the issue. Try to update everything. :-)
Here are some examples: 1. Calculator 2. image application - similar to the one below http://www.cs.cornell.edu/courses/cs1110/2013sp/assignments/assignment6/index.php 3. a special purpose editor - like editing binary data file - for example http://vislab-ccom.unh.edu/~schwehr/rt/python-binary-files.html 4. test data generation - may use faker module 5. board games like tic-tac-toe, sudoku, 2048 etc 6. simple CRUD application - for example a library application using SQLite supporting forms for the following operations - search for a book - borrow a book - return a book - add a book to the collection - remove a book from the collection - borrow 7. a paint application - do you support canvas now? 
Yes otherwise i wouldnt be exploring the options!
Thank you for these ideas. About the canvas, it is simple to integrate an image library and let the gui display the generated image. I will provide an example for this.
In the "Narcissistic numbers" section, why is: &gt; def is_narcissistic (n): d = int_to_list(n) e = sum( map(lambda x : x**len(d), d) ) return e == n better than: &gt; def is_narcissistic (n): d = int_to_list(n) e = 0 for x in d: e = e + x ** len(d) return e == n other than occupying fewer lines?
Haha I feel you on that. I've been using it a lot lately, and while we've gotten a pretty large scale app to be stable and scale well, it wasn't without headaches. 
Too bad there isn't a cleaner way to yield in async functions. 
I think this is a great idea if you already know how to make good Web UIs and don't want to bother with python GUIs. I have done this for multiple projects using Bottle and Flask. Just make sure it only allows connections from localhost, otherwise you'll have some quite unhappy people. 
Ansible is basically a replacement for Fabric. It has the advantage (yes, advantage) of applying declarative configuration instead of applying procedural changes. If you're not happy with Fabric because it's becoming unwieldy to manage, you want Ansible. If you need to do orchestration, configuration management, and reporting at massive scale, use Salt.
Can you get the cursor to snap to a line or a point? Or otherwise show information about a point?
Sorry, can't help you with that. On the other hand, I've done this before with Bokeh, checkout the [Categorical Heatmap](http://bokeh.pydata.org/en/latest/docs/gallery/categorical.html) example or the more in depth [HoverTool](http://bokeh.pydata.org/en/latest/docs/user_guide/tools.html#hover-tool) section.
I hope it can help you. ;-)
[removed]
I will provide some comments to indicate how it works in my case. 
This isn't really a matter of personal preference... At best, it's a matter of habits... So while you can say that you prefer the first one because it is more familiar (which is a **valid** reason), I wouldn't go any further. But let's follow what people **must** do to understand what the programer meant in each case. def is_narcissistic (n): d = int_to_list(n) *This is the easy and common part. You split digits of the integer `n` into a list of digits.* e = sum( map(lambda x : x**len(d), d) ) *Ok, here if I want to understand what's going on, I have to:* - *find matching parentheses;* - *find the most nested part: a lambda function (which is not readable by itself);* - *go inside-out to understand what the lambda function is used in;* - *check for what `map` does... (many persons will wonder why you did not choose list comprehension which is less dense but far more legible);* - *get back inside of map to see lambda is applied to `d`;* - *figure out which new list is gonna be generated;* - *finally, apply sum (which is easy and already well known).* Your mileage may vary, of course, but this kind of functional programming is by no way linear and you **have to** go back and forth into the code to understand what's going on. Now let's compare to the other piece of code: e = 0 for x in d: e = e + x ** len(d) *Obviously, it takes more space but the intension of the developer is easier to grasp (mainly because there is no `lambda`, `sum` or `map` so no need to know them or to go back and forth to understand where the data is going. In the end, the operations are easier to understand too:* - *a new variable is defined equal to 0;* - *loop over each digit;* - *something is calculated from each digit and is summed in `e`.* This is really all there is to say. No back and forth, no "computational units" people have to construct in their mind. The intension could be even easier to grasp using: e = 0 for x in d: e += x ** len(d) --------- In the end, if I had to do this myself without the help of `numpy`: def is_narcissistic (n): """Determines if a number `n` is narcissic. [...Equation...]""" d = int_to_list(n) e = sum(i**len(d) for i in d) return e == n *Here we have:* - *calculate something from the elements of d*; - *calculate the sum of this list*. It can be made even more efficient by avoiding any complete list allocation by estimating `len(d)` separately and by changing `int_to_list` to a generator. But again, this is not as easy as an explicit for loop to read... Finally, also don't forget we have numpy: def is_narcissistic (n): d = array(int_to_list(n)) e = d**len(d) return e.sum() == n OO dot notation might not be trendy anymore, this is definitely a plus in readability in a bunch of cases because it helps to define data processing pipelines in a neat way. This can be considered the easiest to understand or the hardest depending on whether you are familiar with vector notation and numpy. But again, you don't have to go back and forth: this is very legible. ------- NB: I'm certainly not trying to show that I may know better. But when talking about numerate Python, `numpy` is important (even though you lose the automated cast to `long` and even `bigint`) because it is often what's make Python fast enough for number crunching. As well, people are often using some constructs that are definitely valid but somewhat dated and arguably more complicated for people to read and understand.
Not too deep unfortunately, without giving away my anonymity. Basically it's an ETL pipeline that runs dramatically faster than the previous one (minutes instead of hours) due to performing all cleansing in memory rather than writing to disk for every operation the way the previous one did. Additionally, the previous one leveraged the DB excessively for things that dbs aren't good for. I also added full validation of the data (didn't exist before) with reports being emailed to submitters telling them exactly what's bad in their data and how to fix it. Leveraged numpy/scipy/pandas to build it. 
Man, I busted my ass 19 months ago wiring in gensim to sklearn for LDA purposes. This is a huge development that will dramatically reduce development time for a lot of people. 
Maybe exporting plots from matplotlib. Yeah can be done.
Here's to hoping that it meets with your needs. I will be (obviously) trying to be as accommodating as possible with issues/features; and I am a big fan of outside help. 
This is the something I find myself doing quite a lot so made a little library, let me know if it can be improved / seems sane :)
A lot of professional software engineers are not mathematicians or scientists (although they will have taken discrete mathematics as part of a CS degree). They value code clarity over mathematical simplicity. "Code is read more times than it is written". Remember that code has to be maintained, and maintenance programmers are typically juniors (here I am using the commercial definition of maintenance programmer, not FOSS's maintainers). Code that is clear to a mathematician may be a magic one-liner to a software developer. On the other hand, the software developer's reusable frameworks and testing libraries may be unintelligible or useless to the scientist who only has to run his own code and not sell said code to someone else. If you buy source code no-one in your org can read, you might as well have bought a binary.
Sorry. Replied to wrong post. Please ignore.
Why are you making two copies in the first place? Now you edit one. Which one is out of date? Why even email code? Put your code in a VCS like github and the job is done.
Not sure if it makes sense to you, but you don't have to compromise: boto3 is on the boto3 namespace, so you can have both without deciding (yet), both ways. I think boto 2 will receive only bug fixes, but no new features.
Add blender to that list. If he's into VFX, it's also good to note that Autodesk Maya uses Python for scripting.
Read about instances and classes in the context of metaprogramming
I think I installed it through homebrew. Worked immediately, with both Python 2.7 and 3. 
Got a link to the competition information? This would help narrow down your ask for generic advice.
Ehh...in memory SQLite is excellent, but SQLAlchemy almost certainly would be way more overheaded than you actually need in this case.
Thank you! :D I've done few interesting posts which are Python related such as [The incredibly challenging task of sorting colours](http://www.alanzucconi.com/2015/09/30/colour-sorting/) or [How to retrieve all the images from a website](http://www.alanzucconi.com/?p=1611). Some of the posts are not accessible because they are available on preview on my [Patreon](https://www.patreon.com/AlanZucconi). I have few other tutorials which at the moment are not public, and you see them [here](http://www.alanzucconi.com/tutorials/). I should replace the password protected page with something nicer, I know! :-)
I'd recommend going for boto3 now. Do your learning once.
I reckon you could find a decent web scraper. Lots of casual stats analysts publicize their code. There's may even be a subreddit for NBA analytics. Edit: [This looks promising](http://www.danielforsyth.me/exploring_nba_data_in_python/) and was posted this year. Apparently there are reliable APIs for this stuff. TIL
If you want you can use my nba stats client [nba_py](https://github.com/seemethere/nba_py)
Have you looked at [ETE](http://etetoolkit.org/docs/2.3/tutorial/tutorial_trees.html) or [NetworkX](http://networkx.lanl.gov/index.html)? I've never used ETE but I've used NetworkX before and it's a good solid library. Combine networkx with beautifulsoup or lxml and it should get you most of the way there. EDIT: looking through the ETE docs it seems that it does have a visualization element as well: http://etetoolkit.org/docs/2.3/tutorial/tutorial_drawing.html#interactive-visualization-of-trees
Finally something I can answer! My most recent project involved extracting data from websites and presenting them in an easy-to-read format. Specifically, it went to Reddit and fetched and showed you all the titles and links for the submissions on the front page. Basically, I used urllib, urllib2, RegEx and Beautiful Soup 4. My code visited the website, downloaded the data and stored it as a variable, then used BS4 to beautify the HTML to make it easy to read. After that, I used regular expressions (RegEx) to parse the data and return the titles and links. For a project like yours, you will most definitely want to look into these libraries and features of python. Once you are familiar with urllib, you can use requests instead. Requests is basically stupid-proof but it helps to know what is happening in the background, which is what you learn when using urllib and urllib2. If anyone is interested I'll share the code, although it broke recently when Reddit changed something in the way the html is written.
I'd model the standard PyCon talk. - Big speakers - Topical speakers - Social events - Sprints and other work sessions - Networking-type events (invite vendors?) - FUN STUFF!! There's probably lots of people coming who don't normally get to the Caribbean, so show your location well!
No, not really.
Thanks for all the info guys, I feel however the discussion is going off in the wrong direction. I have chosen for python 2.x at the moment because that is what is used in the courses above. My question is also more about what to do after those courses. Ofcourse it is a stretch to think i'll be up to par by summer. The actual goal is to have a new job in python in twelve months. The interviews in the summer i see as training to achieve that. Besides my full time job im spending about 20-25 hours a week on programming, so i should make significant progress... 
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Mice
It's hard to answer without more information (not sure how advanced you are). Make sure you can do things like read files incrementally, use iterators, perform intelligent sorting and searching rather than doing brute force techniques, etc.
Thanks, I'm looking at it, and all I'm getting is this: http://i.imgur.com/17mP4Pj.png The 404 error is something I do have to fix, but what do the other GET errors mean?
Most companies I have worked for for the passed 3 years have either been starting with python 3.4 or migrating their code and dependencies. For instance the company I am working for now is migrating from monkey patched gevent style asynchronous programming to the python 3.5/asyncio. I think what is more important is that one recognizes that 3.4+ and 2.7 are slightly different languages and different companies are working with different versions. You might choose to bang your head against the wall about the differences now or when you are actually in the workforce. But a general rule of thumb is I you know one you can quickly get up to speed on the other. I would recommend python 3.4+ because I'm seeing it all the time these days, especially in startup companies which is where you are most likely to land an entry level python job. 
Those are 404 as well. 
I don't know what they mean, as you have provided no context from any of the other informational panels you get to see if you click on each of the errored out requests individually. But if I were to make a guess, I would guess they are also 404 errors, caused by missing files on the server. From an organization perspective, you probably want to put all of your static assets under /static (should be configurable with the framework), which will simplify your life in the future. Whether you further break it down into css, images, js, fonts, etc. as necessary is up to you.
I've never used wakari.io but unless they give you access to the python installation, I don't think you'll be able to use anything outside the standard library.
Sorry, I just don't know how much information I should be providing off of the panels. So the static assets are in the folder they are supposed to be and I think I see what the problem is. For some reason it's trying to get http://www.arcane.info/%7Bstatic_url( and http://www.arcane.info/static/style.css?v=d41d8cd98f00b204e9800998ecf8427e Why is it adding strings to the end of the file it's requesting? 
Make a program to throw a ball into a fish tank, and if your program makes it you get a goldfish. Still the best thing that happened to little me was getting goldfish from fairs
&gt; You obviously haven't been programming long. One never learns their learning just once. ;) Proper learning is a continual process... That's questionable thing to say. Why would I learn a technology which has been declared as dead, when there is a new version available? Of course programmers continue to learn but you're a fool if you waste your valuable learning time learning the old technology instead of the new - the inevitable outcome is you, at some point, need to spend time learning the new version - why not just learn the new version right now? Learning takes alot of time and effort, you should wisely use your learning time, not throw it away learning dead technology. If there's anyone in this discussion who lacks wisdom about learning....... boto3 is constructed dynamically because it is built from json structures that define the Amazon web services APIs, their inputs and outputs. Mitch Gaarnat, who designed both versions of boto knew the right way to go after designing the first version of boto. It is a strategy that clearly works as the same API definitions are now being used as the basis for other Boto SDKs including the AWS Golang SDK and I believe the AWS C++ SDK.
Yep, I wasn't dealing with enough data to make in-memory SQLite seem worthwhile.
&gt; boto3 is constructed dynamically because it is built from json structures that define the Amazon web services APIs, their inputs and outputs. That doesn't really answer his question. Why doesn't Mitch instead write an application that consumes the JSON structures and then build a proper class with type-hinting to help IDEs like PyCharm? ORMs do this all the time. They crawl the table structures of DBs and build classes and relationships to interface on the DB so the programmer doesn't have to learn the entire DB or that specific DB's particular domain language. EDIT: and one more thing, an old API isn't exactly a "dead technology". It's just an API that's no longer getting new features. Why do people continue to program in Python 2.x? Python 3.x is a superior version of the language, but everyone I know still codes to 2.x despite its inferiority.
You break their arms and I'll go to Costco for some lotion.
I gave it three votes. That's a thing?
Yay for [DIY IoT](https://twitter.com/internetofshit/status/662646466876411905)!
Please. Do this, please.
I gave it three votes. It said I had five more left... ?
Vote once per day is my guess
This would change my life. Doing it properly won't be trivial though. I've noticed that most of the time Java-style APIs tend to be cumbersome when translated directly to Python.
I follow them all, and when I test it out by running import pygame, it gives me an error, so I'm not quite sure :/
Oh man, listen I'm just a high school student in grade 11 Computer Science, so I'm not 100% on what this all means. Is there any way you could walk me through it privately?
BCE: be coding everyday. Learn some basics on version management with git and github. Find some projects and work on them as best as you can. If you like math, try https://projecteuler.net/. Make your github green. It's OK to not finish everything, but don't be quick to give up. Learn how to use APIs in a project. Learn some SQL. Learn how to setup a database and use an orm like sqlalchemy. Try to work on a group project.
It's part of "Built-in name". If you change it, you'll be changing all sorts of things like len, any and OSError.
It really annoys me how people constantly want to use google docs or sheets. Its a vastly inferior tool compared to ms office or open office. Sheets is slow, its really annoying to have a text editor lag while trying to scroll, makes it unusable imo, not to mention all the missing features that have been common place for a decade now in the standard office suite. Just throw a regular doc up on google drive if you need to share, its s much more efficient the using their crapy interface to create content 
Blockspring lets you run Python (and R, Ruby etc for that matter) within both Excel and Google Sheets. you call functions directly like built-ins, after you install the free plugin. Worth a serious look. 
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #------------------------------------------------------------------------------- # Name: CreateSlideExamples.py # Purpose: This is an example file to demonstrate the usage of MSPPTUtil # Module created by Alan G. Isaac # # Author: Shengdong Zhao # # Created: 22/07/2012 # Licence: MIT #------------------------------------------------------------------------------- #import all the modules. MSPPTUtil is a module that allows you to create a # presentation and insert title slide, outline slide, and slide with pictures import sys, win32com.client, MSO, MSPPT, MSPPTUtil g = globals() for c in dir(MSO.constants): g1 = getattr(MSO.constants, c) for c in dir(MSPPT.constants): g1= getattr(MSPPT.constants, c) # Step 1: create a set of slides # initialize a list of slides slides = [] # initialize the different type of slide object # In the text below, it shows how to create a cover slide, an outline slide, a text+picture slide, a picture slide, and a simple table slide slide = MSPPTUtil.PptCover('this is a subtitle', 'title') slide1 = MSPPTUtil.PptOutline('this is main point\n\tbullet point 1\n\tbullet point 2', 'title') slide2 = MSPPTUtil.PptTextPicture('text', 'C:\\Users\\Shengdong Zhao\\PPTExample\\photo.JPG', 'title with photo') slide3 = MSPPTUtil.PptPicture('C:\\Users\\Shengdong Zhao\\PPTExample\\photo.JPG', 'title with photo') slide4 = MSPPTUtil.PptBasicTable([[1,2],[2,3]], ['column1','column2'],['row1','row2'],'slide title') # add slide(s) to the slides list slides.append(slide) slides.append(slide1) slides.append(slide2) slides.append(slide3) slides.append(slide4) # step 2: create a presentation and add the slides to the presentation. Set the slider master's footer to be a string # set the datetime field to be true, and set the gradient of the slide presentation = MSPPTUtil.PptPresentation(slides, footer='shen', date_time=True, preset_gradient=(6, 1, 10)) # step 3: show the slide, save it, close it presentation.create_show() presentation.save_as('C:\\Users\\Shengdong Zhao\\PPTExample\\exampleSlide.ppt') presentation.close() Here's a good example howoto make a presentation from Python.
Java style? In excel?
I re-posted on some G+ groups as well as adding my three votes.
Nobody "knows" python except perhaps Guido, I get paid to use it and I learn new things all the time. Point is, use what you want, Google the rest.
That name would be good on both /r/FoodPorn and /r/gonewild.
This is blowing my mind
Didn't Google and YouTube switch from python to ruby?
Mainly it's a monstrous macro written, and only known by, a single person; that performs magic on large data sets generating various reports for important people. And which causes everyone a headache when said person goes on holiday, or leaves the company.
I've been using python as a hobbyist programmer for a few years, I figured I was fairly comfortable with it. I went to a Google conference yesterday and the casual off hand comments they made about python made me realise I know fucking *nothing* about python.
Google Doc is good to make sure there is only one copy of a document that is always up to date. I seriously hate people sending docs around, editing them and loosing their edits because some other fuckwith edited the wrong version and send that around. Sadly these people are even too distracted to use version numbers or something. So now we use Google Docs, makes it a lot easier to manage documents. (now if only they would stick to the naming convention.. fml :)
I'm intrigued.. What were they saying?
Not necessarily. A lot of things which support scripting in Python will install the necessary bits which can be called by Python, but they won't do anything until you've got Python installed to call them. 
In no particular order: - the deliberately gimped lambdas - some minor non-sensical syntax (why do we need ':' at the end of a def, if the only thing we can do is indent to the next line and begin the function definition anyway?) - the parallelism/multi-core story is still not so good, and likely never will be - ecosystem transition to python 3 is still dragging on. - the type system kinda sucks Eh, overall it's really not that bad.
&gt; make sure it only allows connections from localhost, But please just make this **BY DEFAULT** and changeable with an argument (e.g. --listen="*") or environment variable (e.g. LISTEN=0.0.0.0 python yourapp.py). I run most of my Python stuff on a headless box via SSH and connect to it from my (Windows) desktop, so I get really pissy when stuff refuses to bind to anything but localhost and I have to enable X-forwarding and start an X-server so I can run Firefox remotely. 
It was a fortfive min segment where python was just the analog they used while conducting a "mock interview" but the offhand comments about the language are what intrigued me, one thing in particular that stood out to me was range vs xrange, where range makes a copy of the list and xrange doesn't (very useful if your list was say, a petabyte of data). I personally didn't know that. Also in the example they eschewed using boolean "false" since "it wasn't stored efficiently" which I still don't understand. The use of all() to logical AND a list of true/false values and return a single true or false. It was little bits and pieces like that. They're really big on python users though, they kept talking about how python is a core language for them, they'd pick a python dev over a Java or c++ dev with the same skillset.
AppScript is the scripting language for docs and it's infinitely better to use than VBA. The Sheets API is amazing as well and so well documented. I highly recommend you look into it if you haven't already:
People would be better off convincing companies and coworkers to use [Libreoffice](https://help.libreoffice.org/Common/Scripting) as much as they can, IMO, it's a project everyone can collaborate to make it better It's a shame that people who are locked into Microsoft Office instead of looking for alternatives they try to use features to get more deeply locked.
You have office, I don't. I also want to have a copy of my sheet everywhere on all of my windows and Android devices. It's capable and clean and does all I want without flowers... Like feature outlines. Beyond that, I couldn't give a single shit less about, say, mail merge.
I'm going to be honest here, and for the record, I use Python regularly and although I tend to use JS the most often these days, Python is my language of choice. I think R is probably preferable to Python for integration with Excel. The language is already suited towards the type of work done with Excel, and supports a lot of similar features that Python does not (natively, as in without pandas). Yes, it's less popular, and **ideally Excel could support both** (I want to emphasize this, because choice is awesome). But if I had to choose just one of the two, I'm going to say R. Full disclosure: I don't use R (yet).
In no particular order: * Handling of mutable default arguments. * That you need a line break after a `:` in loops, conditionals, and declarations. * Lambdas are too limited and too verbose. * Lack of an multidimensional array literal. * Lack of a range literal. * No built-in support for views of sequences. * No immutable dict. * No way to define a slice object and assign it to a variable. * Pickle is too limited in the data types it supports.
Actually `range` builds and returns a list while `xrange` returns an `xrange` object which acts like a generator. That means the elements are yielded as needed and they don't have to all be kept in memory.
No it doesn't seem to be. That already has a defined colour as part of the theme I installed and shows up for len etc... as you mentioned. But calling a function that the developer is defined seems to be on a different setting - but I can't find it (or it might not be possible in python?) e.g. If I have def foo() pass foo() How can I make calling foo() a different colour? Also anyone know how to set True and False to different colour? 
Even better explanation! There's so much about python I don't know, and so much I *want* to know.
regarding slice: https://docs.python.org/3/library/functions.html#slice or am I missing your point?
Would much prefer PowerShell integration much closer to dotnet without having to use ironpython imo
One small clarification: My major problem with the type system is in how it treats boolean-ness. `1` is equivalent to `True`, so is `['lol', 'yolo']`, but `2 == True` is `False`, hmm. This can be useful, but it can also be a major pain when testing, as you can think you're getting back a boolean result from a function when actually it's an integer, or a non-empty set, or frankly who the fuck knows? It's bitten me more than once when writing test suites, which end up lying to you about what they're actually testing. It's a personal thing, but I feel that boolean contexts should be strict. When I ask the computer "is this value equal to True", the answer should not be `Dunno, *shrug*, sure, why not?`. EDIT: actually, one more point: I'm not _too_ bothered by `lambda` being a one-expression-only deal, but it would be nice to have a less verbose syntax. So: ``` foo -&gt; foo.bar ``` over: ``` lambda foo: foo.bar ``` But I appreciate the arrow syntax may not 'fit' with the rest of python.
But range in python 3 is xrange and the old range is gone. Python 3 puts iterables front and centre and is a core part of understanding the language. The other comments you mentioned are fairly well know but "false" no stored efficiently - that's news to me and doesn't sound very pythonic not to use it.
I'm guessing it's about data types. R has vectors and matrices built in (and probably optimised for fixed sizes), not like Python where tuples are immutable and lists are made to be heavily manipulated (have entries removed or extended), and there is no built-in multidimensional array (you need either list-of-lists, flattened arrays, or numpy).
If there was one single thing I would recommend, it would be to hang out on IRC on the #python channel. It's ok if you don't know how to answer any question. Seeing the questions will make you think. Seeing other people's answers will teach you a lot.
Wow that looks really interesting! Never heard of it before, great post.
Still totally subpar compared to Python.
google sheets is better than having to buy and load excel, any day.
As I mentioned, these were all things new to me, I haven't used python 3 much, spent most of my time with 2.7. Regarding false, I don't know exactly what they meant, and it was an offhand comment I just happened to remember because it struck me as strange. Perhaps it could be inefficient in Google's terms, they spent a lot of time talking about scale, and how to strive to write code that preforms really well at scale, and the number of problems they encounter when working with petabyte and exabytes of data! Edit: My comment sounds far more snarky than I meant it to. I'm happy to learns all these things about python that I never knew!
I gave 3 votes, got 7 more left. 
In that case you have to manage security criteria. Granting or refusing access depending on the user credentials.
Have you ever heard of the law of the jungle, where the strongest survives? I have not said that the american corporate system is not successful. I have said that it is flawed, when you look at it from certain points of view. Take a psychopath: you will agree that it is a flawed person. Yet, certain traits of certain psychopaths make them insanely successful, having no moral principles to "slow them down", among other things. Incidentally, it is in the modern corporate environment that psychopaths have found a fantastic thriving ground for themselves.
1) Installing packages on windows sucks 2) Date/time/timezones libraries sucks 3) Request not in standard library Threading/Concurrency 1) Several ways to do threading with almost the same performance but GIL still exists 2) Concentrating on concurrency in new Python releases while GIL still exists Other: 1) No compiler in standard, no fast way to make .exe in standard - to build compiled exe You must have Cython + Pyinstaller, installing Cython sucks on Windows. 
&gt; if the only thing we can do is indent to the next line and begin the function definition anyway? That's not true. A newline is not required: def foo(arg): return bar(arg) for i in stuff: print(i) The colon is therefore necessary as a delimiter. Consider a case like: for x in y: +z Without the colon, that's ambiguous. Is this `for x in y + z: ...` (i.e. the iteration is over `x + y` and the next line begins the loop block) or is it `for x in y: +z` (i.e. a one line loop.) Remember, unary plus is a valid operator. 
How does it compare to datanitro?
Better chance of R integration since they bought R company Revolutions and have it interested with MS SQL Server.
Slow? The text editor doesn't lag... What are you talking about? 
Why not just use pyxl or xlrt?
What version of Python? What modules? I'm expecting in 2020 to be using Excel sheets that are restricted to Python 3.4 and its standard library, because nobody on the Excel team had any time to work on this feature since the initial release. I'm not convinced that's going to be more fun than just using Excel's own scripting language, or using actual Python using some module to work with spreadsheets.
And how does that help when you want to write a custom function in excel? Or have to persuade your SA to install python on all the office computers? Or teach half the office how to run a python script which probably had a horrendously shit UI because it just wasn't worth doubling the amount of time required to write the script? 
Thank you. I fixed this problem, but it just ended up not liking the subdirectory I guess. For anyone else who is having this problem please put your code in a folder external to your script as I mentioned in my own comment on this post. This solves the problem, and is actually a better solution considering that as dr-josiah mentioned it will simplify your life in the future. Sorry for any confusion.
Is it wrong for me not to support this because it would make it more likely I'll be asked to use Excel in the future?
Does it work with python? As in, does it have a window that tells you what happens when you run the code?
People always bring up the single line lambdas but I've never seen a decent syntax for what a multiline lambda would like. And I've never heard a decent explanation for why it's better than just defining a function just before the lambda is needed. 
Not that I don't love Python, but wouldn't something like Lua make more sense? It is the fastest scripting language with an easily embedded runtime. Especially with tables already a part of the language seems a natural fit.
https://pythonhosted.org/spyder/ maybe
I'll go one further. I hate spreadsheets. Get your data into arrays, use python pandas or use a database. Spreadsheets can be somewhat useful to prototype but next thing you know and its out of control.
It already kind of supports JavaScript, or at least whatever implementation Microsoft calls JScript. Example: http://ramblings.mcpher.com/Home/excelquirks/snippets/scriptcontrol
If I were a slightly less unethical person I'd fire up scrappy. I'd be pretty happy with pandas and excel.
I want to make a library for dogs someday
I use scripts for simple data analysis. Like, which apps in my customer's environment have multiple entitlements with the same set of permissions?
If your making a multi page spread sheet in google sheets, try inserting a figure from a 200 point data set. It takes 30 seconds + just to open the figure dialog 
Yep and then the scripts get spaghetti, the data gets stale, and the people have no idea what they are doing. Translate you vba in stored procedures, move your data into SQL and let them use an interface as needed. 
Lol
no one can help you if you don't provide any information about what is going wrong. Its clear there's an error - stating that doesn't advance the situation. What is the specific error you see when running 'import pygame'? What version of OS X are you using? Which version of python?
Is this gonna be integrated into Python at some point?
&gt;Steve Huffman will teach you everything he wished he knew when he started building Reddit &gt;Final Project (8 hours) For the final project, you will build a fully functional wiki It's the one, thank you!
This is a SaaS. 
Are you their mother?
How does installing packages on windows suck? I'm on windows, and `pip install ...` works great for me. Plus, there's that unofficial windows binaries for python packages page (or whatever it's called). I don't quite get what you mean with the "request" thing. Do you mean the requests module? That would be nice I guess, but we do have `urllib.request`. 
regardless of what sub you're in, I just don't understand why people get so bent out of shape over what languages other people like. AFAIK, MS isn't going to replace VBA, they're just considering adding an option for python, so what's the big deal?
PyCharm Community Edition should fit all of your requirements: https://www.jetbrains.com/pycharm/download/
Yeah, if you're going to be using Python for excel, you may as well switch over to pandas and matplotlib and the other pydata modules
This must have been a joke. Nobody in their right mind would say this with a straight face.
I haven't used it personally, but I think win32api supports Office apps already and I've seen some indian programmer make ridicoulously complicated, interactive Powerpoint data visualisations using Python only.
Packaging / deployment. So many different package/installation options and no clear straightforward way to have a single artifact to deploy. Something like PEX standardized (and less hacky feeling) would be awesome.
This is where open source is infinitely superior. Just implement it yourself. Don't have to beg. Begging for features sucks no matter what anyone says. If this really is a worthwhile feature, why not go for LibreOffice? Also, OP be careful. I think post titles like that might be against reddit rules.
&gt; one thing in particular that stood out to me was range vs xrange, where range makes a copy of the list and xrange doesn't (very useful if your list was say, a petabyte of data). I personally didn't know that. This is really basic shit. &gt;Also in the example they eschewed using boolean "false" since "it wasn't stored efficiently" which I still don't understand If this is even a thing, it's the most micro of micro optimisations and I couldn't ever see it being an issue.
Might not be trivial with Tk. A tabbed interface would be much better for most people though. Want another window? Launch another instance. 
Yeah thats why I'd like Python. :)
This is amazing. Thanks for the info!
&gt; When you do write comments, remember: "Strunk and White apply." - PEP 8 /r/badlinguistics would love to have you. This nonsense is even preceded by: &gt; You should use two spaces after a sentence-ending period. Absolutely indispensable advice.
 from bark import woof
Time to write a pep?
&gt; not short way to limit a generator in size. "import itertools; itertools.islice()" ? Come on ! In Python 3, you can do zip(range(n), gen)
For me, it's that lambdas are usually one-off functions and giving a name is more cognitive load. Aside that, in-place definition seems more natural.
I think it's less about language power and best fit but more about getting shit done quick and easily without needing to learn another language.
Why the logging module, if I can ask?
You're telling me you don't want to turn Excel into a cloud-based IDE for people who haven't learned how to program?
&gt; pathlib.Path does inherit from str. I think that would violate Liskov substitution. For example, I don't think a path should support the `*` operator.
Batteries included -- off-brand batteries, but batteries nonetheless.
For one thing the syntax isn't PEP8 compliant. It also uses constants instead of strings for setting levels, which is a bit annoying. 
Yes it is true that with Python you have to import libraries. But with R, people are dissatisfied enough with its built-in libraries that they resort to installing Hadley Wickham's libraries like ggplot2, dplyr, tidyr, readxl, etc. So I think this is not a good argument for the question at hand. Also with an IDE or in my case, with jupyter notebooks, you can automatically setup imports of certain libraries at startup. So this is really moot point. Pandas also has built-in wrapper for MATPLOTLIB, so it can plot dataframes directly like so: df.plot.bar() So it doesn't take much effort to plot with pandas. I am still not convinced that supposedly it is better to integrate Excel with R instead or Python. I am not saying that it would be better with Python, but just curious why you think R is better suited. Sorry, but so far, your examples haven't convinced me. EDIT: I use Python and R and honestly could care less if Microsoft does integrate Excel with R or Python or both. The world will still move on.
&gt; how it treats boolean-ness Yep, unfortunately `bool` is a subclass of `int` (and therefore `True` is `1` while `False` is `0` -- thanks C!). However, the rest of it isn't really a problem with the type system. `['lol', 'yolo']` is certainly *not* `True` (try `['lol', 'yolo'] == True`). It's *truthy*, which is short for saying the constructor for `bool` returns true when given that object. If you really don't like it, just go back to comparing things to True/False: `if(some_var == True): do_something()`
Haskell has some [nice uses](http://learnyouahaskell.com/starting-out#texas-ranges), such as infinite ranges (e.g. all multiples of two).
Python 2 vs python 3
&gt; numpy should be part of the stdlib. I'm not even a maths person and I want it. I'm a math/science/engineering guy, and no. A numpy like library should be in the standard library, but not numpy itself. It would limit numpy's frequency of release. I want the latest numpy when it's ready and not a second before or after. Packages go to the standard library to die. Packaging numpy with Python will limit the frequency of releases of numpy and totally go against the rule of don't support old versions of Python. I'd be fine with: from numpy import dot from math.numpy import mathdot Where math.numpy is the version of numpy that was released when the version of the package came out. So if Python 2.7.0 comes with numpy 1.3, the latest Python numpy is 1.3.x, even if 10 years later people are using Python 2.7.10. My 2.7.0 code should still work in 2.7.10 and vice versa and if numpy is upgraded in between, I can't guarantee that.
Lack of free multiprocessing on numpy arrays.
This would be so huge for me. I come from a very excel-heavy background and am learning to code for the first time. I would actually have some knowledge to leverage into learning programming faster/better.
I'm not an expert in Python, but I'd probably recommend IPython/[Notebook](http://ipython.org/notebook.html) + [a plotting lib](https://wiki.python.org/moin/NumericAndScientific/Plotting). Thinking about data objects is a pretty seminal skill in programming. I'm not sure a SaaS crutch is ideal for somebody that is serious about learning to code. You really want to learn to retrieve the datasets "as they were" and programmatically alter/filter/mutate their state (or create "views" of that data thereof). 
I think I see what you're saying. You give yourself a more hands-on learning experience that way. Is that what you're saying?
Yeah the language is so oriented towards side effects that it would seem like a bad fit for operating on data /s People use Python for data analysis all the time, operating on a CSV is not much different than a spreadsheet. Python is more than capable, and is a good fit.
I don't see python changing that much in 10 years. But, [Julia](https://en.wikipedia.org/wiki/Julia_%28programming_language%29) is a good candidate.
Because it's a pointer rather than an actual Boolean value? That statement is true, but the criticism is shit. Googlers making this complaint are probably some quasi technical PM because anybody else understands that for performance critical applications it's gonna be C++, Java, or Go, pretty much in that order.
ELI am pretty good with Excel and wanting a way to use Python a lot: What does this do and how does it work?
Eve online is written, in many ways, in Python. 
&gt; %matplotlib inline Oh you are magic! Thanks!
Still, if you actually need an infinite range and `range(10**10**10**10)` isn't big enough (and, seriously?), you can do that fairly easily: def infiniterange(start, step=1): yield start start += step
Really the whole numpy don't need to by in the lib, but at least numpy arrays and basic math aperation on them. Everything use them now : image lib, neural networks, serializers...
This is a neat trick, but it decorates it to a generator of tuples and you need to undecorate it later. Plus, you need to comment that code every time you use it since it's not obvious what your intent is.
Yeah, but honestly, once you tried request, do you even try to use urllib ?
It's because I was too busy thinking about packaging.
The way you phrased it made it sound like you didn't think anything like that was in the stdlib.
Well its different methods of creating a pptx. Feel free to work with something your more comfortable with. 
Long as we agree on what is defined as basic. I'd say a solve, norm, dot, sets, eigenvalues, eigenvectors, tensordot, fft, sparse matrices, fromstring, etc. are all basic numpy functions. Numpy is largely a basic library, with nothing like `scipy.special`. So maybe you don't include `numpy.distutils`, but the vast majority of it should be there if you're going to do it at all.
does this use python 3 or python 2?
I guess. I just don't see why a far more general purpose language is a better choice than one that's already built for this kind of processing.
Doesn't exist in Python.
all being used to check for logical ands makes a lot of sense. Did you do A and B and C? Did you do **ALL** of these things: A, B, C
Exactly this. One of python's issues is its portability. Thankfully things like conda and docker have helped, but that doesn't help distributing tools to less technical people (unless you want to include a fully compiled python environment just to share a script)
I like that type hints are finally here. I dislike that they aren't required.
Haaaaaaaave you met China?
emacs or vim with a little bit of configuration will be the only "IDE" you'll ever need for Python and any other lang.
Obvious troll. 
The country that still has a GDP per capita of about $7k? That bases its growth on becoming more and more like the US? Yes I have met China, I am writing this message from China.
It does [now](https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-484)
Think about what your problem is, in simple, atomic steps that a computer might understand. 1. Take your string, and split it wherever there is a comma into a number of substrings. 2. Reverse the order of your substrings. 3. Join your substrings with a space. If you have any trouble finding documentation for the functions that do each of these 3 steps (tip: it's one for each step, and they're called `str.split`, `reverse`, and `str.join`), let me know. 
I think [this Gist](https://gist.github.com/sidharthshah/c1398bad23c21f2dced2) should help you. It has a sample code
Can you point me to a guide on building kivy for python3 on OSX? Or a prebuilt package for it? I'm having trouble with this also.
You are also magic! =D Thanks.
Can you be more specific?
Learned how to do it! Now I just have to take it to the next step in the problem. I might ask for help if I get stuck again lol thank you. 
NameError: name 'strip' is not defined
Crap forgot to mention about an import you need to do **from string import strip** Please refresh the Gist I've corrected it. 
I agree with some of your points, except for the following two (closely related): &gt; Prefer "reverse notation". &gt; &gt; Why? It reeks of Hungarian notation, and while emphasizes one aspect of the object (e.g. that it contains "elements"), it also hinders readability by making the name flow awkwardly when pronounced. It helps A LOT with auto-completion, and API searchs in docs. And its not supposed to "contain elements", but "group actions" related to whatever the names begins with. &gt; Use action words ("Return") rather than descriptions ("Returns"). &gt; &gt; Hardly makes any difference. It does. IMO it makes for cleaner/regular APIs. What do you preffer?: `on_mouse_click()` `on_mouse_clicked()` or as you don't like "reverse notation": `on_clicked_mouse()`?
I've just found your site yesterday (by searching for Peewee, some of those things years ago I've said... "mmm, I should learn/use that"). You have so many good articles and projects there! I just wanted to thank you for sharing your knowledge with the rest of us. I'll be using your site as reference/inspiration while learning Flask+Peewee. Your "goal oriented" approach ("I want a personal wiki/bookmark/etc thingie") makes for a much nicer experience than regular tutorials on the subject. Hopefully I'll learn enough to scratch an itch I'd have for a long time. Sorry for the broken English, and THANKS A LOT!
The virtualenv the op sets up is python2, but there isn't much here that shouldn't work in 3 (unless the libraries used don't support it, I know that the main couple do)
It's very useful for comparing two or more main object types such as: `force_old`, `stress_old`, `displacement_old` and `force_new`, `stress_new`, `displacement_new`, where that list can go on for 20 different variable sets. It has it's place and I switch between the two styles depending on what I'm doing.
What is the rank og your matrix?
 &gt;&gt;&gt; print(' '.join(reversed('Doe,John'.split(',')))) John Doe
And Raymond Hettinger, Tim Peters, David Beazley..
&gt; And how does that help when you want to write a custom function in excel? First you need to ask yourself why on earth do you need to write a custom function in excel that can't already be written in VBA. &gt; Or have to persuade your SA to install python on all the office computers? If you need to persuade your SA to install python to do something in your spreadsheet, that obviously means you're using the wrong tool for the wrong job. 
&gt; Exactly this. One of python's issues is its portability. This is simply bullshit. Python as the exact same portability issues as Excel, because in both cases you need to install the software in order to use it. That's the full extent your portability issue amounts to. Furthermore, unlike Excel, Python is actually free software and has multiple alternative implementations.
Monopsony is just as bad as monopoly. Small businesses and anti trust/anti monopoly regulations help end this issue.
No need to go that far, you just need federal laws that recognize certain employee rights as basic human rights and local entities like trade unions that help enforce them without the need to go to court every time. Unfortunately this sounds too much like socialism to Americans and although it would be greatly in their interest, for this single reason they would never vote this.
I don't agree. This adds unneeded restrictions on people, both employees and employers. So long as employee and employer groups are restricted from colluding the most efficient solution is reached.
Well you are certainly free to disagree, my opinion is not gospel. However, I must say that your answer is coherent with what I said: I see the typical american fear of "socialism" in your reply. It is unfounded because those "restrictions" you talk about are not going to destroy the economy, they are simply going to make sure that the workforce is respected. Thinking that you do not need to respect the workforce is a typical capitalist way of thinking. Without the workforce, the capitalist is nothing... until robots replace all the workers at least!
The American system is going a long ways to improving the well being of the people in China. 
That is the whole point though isn't it, applying some American approaches has caused the standard of living to rise rapidly in China. Is it a capitalist wonderland for everybody - no - but it has undeniably improved the conditions for many in China. 
And a more and more developed system will improve china. China isn't a counterpoint to capitalism, but one of the stronger supporting examples
You have misunderstood a few points in my comment, probably because something I said ringed negatively on an emotional level to you. I did say, if you read my comment carefully, that the system where 'one orders and the lower ranks execute without questioning' might work well and make sense in the Army; if you did not notice that and therefore assumed that I was disrespecting the armed forces, read again. However, I also said that this has no place in the modern economy, which might sometimes look like a battlefield but it is not one, literally. What needs to change is that the contributions of "technicians/troopers" must be recognized for what it is and the decisional power of "officers/managers" in a modern company needs to be questioned. Technicians are professionals, too and sometimes of a higher degree than most managers: this can and should be acknowledged because we are not in the army and there is no danger of causing the trouble you would cause in the army when you break the chain of command. On the contrary, acknowledging it would solve a lot of issues in modern companies. The problem is that we take this division of competences for granted and nobody is questioning it, ever: this happens precisely because its origins are that far away in our past; hence my point.
I think that is what I said! &gt;And a more and more developed system will improve china. China isn't a counterpoint to capitalism, but one of the stronger supporting examples China has come a very long way and a bit of American style corporate management has done wonders there. There is plenty of room for improvement, sure, but there already has been plenty of improvement for the average person in China. 
Yeah, wasn't disagreeing at all, just adding my opinion on how it is advantageous
Another typical American answer. Why do you think I am advocating for communism? Communism is a bad thing and nobody in Europe is a fan of it today. Get back to 2015, basic welfare is not communism. Hell, it's not even socialism. Unfortunately you confirmed my point: anything that puts even the slightest form of control over employers sounds like socialism to Americans... because every American has been duped into believing that one day they will become employers and therefore you all vote for mantaining employers privileges... even though you will never become one in your lifetime. The American Dream has been corrupted, take notice.
Not even close to a response to what I said. Don't get caught on labels. My argument is that small labor and small business makes the most efficient outcome. Not because of communism, not because of capitalist overlords, but because of basic microeconomics. Why not focus on the main point?
I really wish they'd've just stuck with the name annotations because there's gonna be all sorts of disagreements on terminology. When I see type hinting, I think of something like Java: public function(Car car) Where as the Python version is similar but unenforced by the language. It's type hinting for your IDE, and maybe useful for a DI library with some jiggery-pokery. 
So again, missing the point. Communism was mentioned because communism and the country I live in was brought up. Why is makin strong unions better than making weaker big business? This is the crux of the issue. This is all supported, at least theoretically which admittedly has a lot of distance from reality. Please have a response that addresses this issue, and less ad hominem arguments.
But how is making businesses buying power more competitive worse than making unions stronger? You made an as hominem by criticizing my use of the term communism the focus of your response, rather than looking at what is more efficient.
I can download WordPress in 20 seconds.
&gt; can't already be written in VBA I have written VBA functions, and python functions, I would take Python over VBA every single day. Hell, I would take a hit to my paycheck to not have to do VBA, I guess its ironic that my days of writing VBA help my job prospects in data science, even though I never use it.
Point still stands. As for ad hominem, I'll admit I used the wrong term. Regardless, the focus was on the term "communism", a superficial focus, rather than the content of the message. As for the subject at hand, I did inappropriately suggest a false dichotomy between increased labor unions and further separated businesses, which is unfair. I was thinking about at equilibrium, and maybe a little too far ahead. If we want the best outcome, the best output from society, we need to use smaller business and smaller labor. This is, as I have said multiple times yet has not been addressed, the optimal outcome for societal good. Why do you think that monopsony is a good outcome for society, in light of having businesses broken up to be more competitive?
You can also see how much it becomes indented and unreadable. Limiting lambda style is precisely to avoid the temptation to write than kind of code and why we got yield and await.
Espacially in 2015 when most problems are fixed, python 3 is the default version is clear winer.
I do dislike True == 1. Feels dirty.
Multidimensional array literals are just nested list litterals ain't they ?
Can sign up in Blogger in 19.9 secs.
I have been programming computers about 5 times longer than you. I did in fact build medicare.com, usa.net, and american-paging.com. Don't get stupid. Do you understand? WTF Have you done? Huh? List your magnificent accomplishments... go on... I'll smoke your ass, literally, figuratively and in every other way possibly imaginable... C'mon... Let's hear what you got to say.... C'Mon bitch... you stupid assed mother fucker. What have you built? NOTHING. And you know so much yea? Really?
Because Python can't replace VBA in Excel or Word or Powerpoint or the Calendar. Microsoft employs proprietary code... it has always been this way. No-one can replace Visual Basic, because they don't have the underlying code. Fast forward to web applications... MS can't figure out how to make Excel or Word, or any Office product work on the web 100%. That doesn't mean python has an advantage... they have nothing over MS. One day, in 20 years, MS will figure out how to make Visual Basic work on the web in Excel/Word/Powerpoint/Outlook and they will become relevant again. But it will take longer than NASA can put us on a foreign habital planet. I mean, MS has had 20 years already... and they've literally done nothing to make their shit web approachable. Nevermind the visual studio shit, none of that makes MS applications functional on the web. Fuck ASP, it's a shit language with a shit outcome.
I spend a lot of time in my job helping people figure out how to stop using Excel for their data workflows. Rather than putting Python in Excel, I'd rather see better support within Python for dealing with Excel files. If you want to program in Excel, VBA is more than enough and is easy to learn and use (and there's tons of support and examples on the web). If you need more than you can get with VBA, you probably should by figuring out how to solve your problem using something better than Excel.
I think it should work or either but I only tested it with python 2.
Thanks for the kind words.
- dicts/sets/lists should have been immutable by default - set and dict literal syntax are too similar - keyword arguments should be the default, you should have to explicitly say you want positional - short form syntax for calling kwargs. Javascript will get foo({foo, bar}) as shorthand for foo({'foo': foo, 'bar': bar}). It's embarrassing to want a feature from JS!
Just use `map(str.strip, …)`
Careful to not killl duck typing.
Thanks :). Sure we'll have a look, I haven't done any HTML scraping yet but it should be possible.
It's not bullshit at all. Installing excel is easy for non-technical people. When was the last time you tried to have someone non-technical set up a python environment? (Especially if they're on Windows &lt; 7)
You are correct. Functions lets you reuse code, and override functions. Without functions you would have to rewrite code over and over for same calculation.
Thanks.
FYI /r/learnpython 
If the author's goal is to find the best nuggets from the Python advice out there, then this is a failure. Recommending S&amp;W is a terrible idea.
Check out the multiprocessing library if you want to dodge the GIL.
The threading lock only affects *Python* code. If your thread is waiting for disk I/O or if it is calling C functions (e.g. via math library) you can ignore the GIL. You may be able to use the async pattern to get around threading limits. Can you supply more information about what your program actually does? I have issues with the technical accuracy of the video linked. David Beazley has done many well respected talks about the GIL at various Pycons. You can find them on pyvideo.org.
super-cool well done
If you want to do parallellized CPU-bound work, then yes, your app is doomed. If you want to do concurrent IO-bound work, you're in luck. Check out the greenlets library for ideas.
Indeed.
Or: `python -m SimpleHTTPServer` Or in python 3: `python3 -m http.server`
Can you provide some sources or examples to back up this claim? Are there alternatives that you would recommend?
I think I've had this error before. I think your qt modules may be out of date. Try to remove them and reinstall them
panderingPenguin has pointed out that i really meant 'parallelism' as opposed to concurrency. 2 or more threads executing at the same time.
Definitely take a look at his talk from the most PyCon 2015. https://www.youtube.com/watch?v=MCs5OvhV9S4
If you'd like to write an application that allows a user to push a button and then receive a response to that button push, while at the same time the program is also downloading content from servers and doing other things without causing the response of that button to block until they are all done, you most commonly use threads. Makes no difference if the GIL is there or not; threads always allow *concurrency*. The GIL just gets in the way of achieving *parallelism*. Two different things. http://stackoverflow.com/a/1050257/34549 The much-hyped solution of doing everything with "async" has its pros and cons, but as far as concurrency, you are merely swapping out having your OS do context switching with a more interpreter-level strategy that context-switches only at the boundaries of waiting on IO. For general purpose programming with limited numbers of concurrent tasks, the OS will do a better job at this (and in cPython the GIL releases on IO anyway), unless you really need to wait on lots and lots of slow IO channels in which case async will scale better. 
First of all -- it isn't a problem until it is. Meaning, what performance numbers do you need to hit, and are you hitting them? If you DO need to be maxing out multiple CPUs -- you generally can do it various ways in python by splitting the load among multiple processes. People here have recommended mutliprocessing -- I can not recommend that, as it has caused me untold hardship. I recommend you setup multiple processes and coordinate them with ZMQ (http://zeromq.org/bindings:python) -- simple, fast, and "just works"(tm). 
You are partly right, because when a project gets larger, more complex and more people contribute you need some kind of structure (you either do it in the form of convention or enforcement). Best practices, documentation etc are fine, but type hints and interfaces enforce this structure, they also help document source code better and prevent some bugs. I have not experienced it in practice, but I think that being able to start fast (without type hints and interfaces) and iterate until you are convinced for your implementation and API, and then be able to formalize selectively (using type hints and interfaces) is a very very powerful, pragmatic and agile way of building software. We must use the ducks not abuse them. I would like someone to prove me wrong though.
I don't agree with the author of that statement, but the 2.x versions of the multiprocessing module have indeed quite a few bugs. There's a forked version at https://pypi.python.org/pypi/billiard which fixes some of those bugs (see the link for a description of what the fork fixes). The 3.x version of multiprocessing is fine.
Check out the multiprocessing library. It works quite well.
Indeed, I've used multiprocessing to great effect. But starting short-lived processes for many small tasks is expensive and honestly solved better by other languages. Although, if you absolutely want to use python, it's possible to go with a solution using the JVM or C extensions... But at that point, you're not really writing python anymore.
Or hang out in the python section of Stack Overflow. I used to read and try to answer a lot of questions on Vaadin (a java web framework) back in 2012. That taught me a lot about the framework. I imagine the same thing applies to, say, python.
Zed Shaw's Lamson code is really nice. Also "Das Inbox" by Kenneth Reitz should be studied.
Even more so now that they've been bought by Red Hat, and they don't seem to want to break compatibility with RH 5.x
I'm not opposed to the current type annotation system -- well, it's ugly, but so are all inline types. And I regularly use the ABC module because it allows some rigidity. But I don't think actual type checking has a place in Python. I try to avoid type checking altogether outside of a few grey areas (`str` being iterable has bitten more than once). But that's me and my own desires and biases.
TIL if you want to do modern things with a program you should use the modern version of the language. 
no, `dict.get` allows you to not throw an error when indexing, that same goal can be done with `len(list)` on a list.
[Codeskulptor](http://www.codeskulptor.org/). There is no tkinter, but other GUI module (simplegui).
Without wanting to be "that guy": For at least a subset of the first case, there is another option, albeit one involving more pain. In the specific case that you need lots of CPU number crunching, you can use the 80-20 rule to determine the time-critical part of your program and then write that in C++. The integration is best done using boost::python (not easy, but doable). Then you parallelize your number crunching in the C++ code, using MPI, OpenMP (or even pthreads if you have the "hard as nails" mentality). This option should only be applied in the case were you're already thinking of moving parts of the code to C or C++ to gain performance, since it is much more time-consuming to write C++ code that writing Python code. Definitely worth it for things like scientific computing, though.
&gt; **Above all it's important to note that this apparent lack of parallelism via threads is not an issue with Python itself, but an issue with the implementation, such as with CPython. Claiming that Python doesn't do parallelism is misleading.** Actually, that is just as misleading, if not more (regardless of font-weight used). Saying it is an implementation-level issue makes it sound more harmless of an issue than it really is, saying it is a language-level issue makes it sound more severe than it really is. The main reason is the design of the C API which has many global variables. Look for instance at functions like `PyTuple_New()`, `Py_BuildValue`, `Py_XDECREF()`, `Py_Initialize()`, `PyRun_SimpleString("python code goes here")` etc etc. As opposed to most other language runtime APIs (lua, spidermonkey, V8, guile, ...), these do not let you specify which VM object to work against. How is that possible? Global variables. Global variables everywhere. (btw, this is the same issue that prevents you from just instantiating two or more python interpreters in the same thread as well, or to instantiate two completely separated python interpreters in two completely separated threads, even if you do not want to share any data between them whatsoever -- with e.g. lua you can just do this, since its API does not make reference to global variables) Now the issue with this (and why this is an issue at a more important level than just the cpython implementation) is that the C API is pretty important. PyPy for instance inherits the GIL issue because it wants to be compatible to the CPython C API. Not being compatible to the CPython C API means that many python libraries will cease functioning, e.g. numpy and any other library that has C/C++/fortran code in it (maybe cython is affected too, I don't know.) So while it's true that JPython and IronPython do not have this issue, they have the even bigger issue of not being compatible with the cpython C API, which is why they are so unpopular, despite having big performance benefits. It's technically true that the GIL is not a requirement by the python language as such, but it is nonetheless deeply ingrained into the python ecosystem. Unless you are willing to forgo a huge percentage of existing python libraries, you cannot get rid of it, even if you write a new implementation. So is "Claiming that Python doesn't do parallelism is misleading." true? Well, if you consider the libraries python has to be an integral part of the "python experience", then it's actually not misleading, because those libraries have the GIL baked into them. If you OTOH think python is still python without the libraries and the cpython interpreter, then the statement is not true.
Don't be pedantic. Yeah, I'm aware that the GIL is part of specific implementations of Python. However, OP specifically mentions the GIL, and either way, it's a safe bet to assume you're talking about CPython until someone says otherwise, as it's the standard implementation.
Then it comes down to a question of how real time does this really have to be. Are we talking a loose, "we'll try our best and hopefully everything works out properly," or an, "ohmygodIneedtodothisnowgetthefuckoutofmywayoreverythingwillcatchfire," type of real time system? Given what you've said, and the fact that you're even using python (which should not be used for the latter, period), I'm guessing the former. In that case, and the fact that you're only doing things every 4-5 seconds, you could probably get away with concurrency and a buffer, with no real parallelism without any issues. Just have an incoming job handler thread or two. That queue things up in the buffer, and worker threads that pull jobs out of the buffer and handle them as necessary. Hell, if it's really consistently 4-5 seconds between jobs and the work required per job is less than that you can probably get away with a single-threaded program and still have it sleeping, waiting for work most of the time. You'll need to experiment a bit and see what happens. But I don't think it sounds like parallelism is truly necessary for this task at all. Good luck!
&gt; what you need to do with the data is less than 4 seconds We'd love to assume that one measurement is enough to give us the insight we need to design a program, but consider that the program is running on a multi-tasking OS, or that it uses a shared resource, or just basic statistics, and you might be concerned that there would be some outliers that could cause one job to run long... and then you've backed up the entire pipeline. Of course, we can't reach any conclusions on OP's design because we don't know what he's doing, but it's not entirely unfounded to make his processing loop asynchronous. IMO, it's smart.
Until they say exactly what they're doing, what is the environment, what are expectations, what things are happening... an async loop handling separate tasks off to different processes could be a great design, or a simple serial for loop might be really all that's warranted until requirements make a big change. It can be just as misleading as possibly useful to speculate.
You can't make any statement to a python newbie without someone coming in and "Um, actually"-ing you with some complicating details.
/u/RDMXGD is seemingly good at that, I remembered the username from this thread a while ago... https://www.reddit.com/r/Python/comments/3rqvio/starting_to_learn_programming_with_python_to/cwqljf6
If a thread is blocked waiting for something external to Python, like file or network I/O, or database connections, then it typically releases the GIL during that time and allows other Python threads to run. The GIL will only impact your performance if you are CPU-bound within your Python process. If that's a problem for you, then consider changing your threads into separate spawned Python processes (see the `multiprocessing` library, which has a similar API to `threading`). You'll just have to worry about how the processes share data since typically multiple processes don't use shared memory the way threads do.
Minecraft code for Python, go on...
Your code is not slower than C because of deficient data structures. It is slower because of function call overhead, typing overhead, and the looping construct. I don't think there is a lot of possibility for improvement over Python's builtin data structures.
[here](https://github.com/fogleman/Minecraft)
My thoughts exactly, Jesus... We don't need to further muddle the issue with alternative implementations to answer something like this.
Wow.
Python is not a great program to write multi-threaded programs in, not only because of the GIL, but because the standard library (and other libraries for that matter) say little about being thread safe. Frankly, I found it to be a minefield. I have written multi-threaded programs in C/C++ for years and have no problem handling locking, synchronizations, etc. so I don't think it is my limitations and much as Pythons.
Yes please! Microsoft is a new company with Satya Nadella at the helm. I think developers are starting to take notice.
Delete this post, repost in /r/learnpython, and indent your code by 4 spaces on reddit.
And you can do "in" on a dict to check if the key is in there. It's not about existing feature, it's about convenience. They decided it's convenient enough for dict to have it - and it is - but we lack the convenience for list.
Because one of the solutions is to run your code in different implementation!!!
That guy must clang when he walks. I've seen people do live demos before, but never with code that they've written while talking.
I can help, PM me the details? I can help you on skype. 
thank you!
Perhaps these may help you - https://docs.python.org/3.5/library/os.html#os.listdir - https://docs.python.org/3.5/library/subprocess.html 
http://courses.cs.purdue.edu/cs17700:fall15:projects:project3#part_4matplotlib heres the project, i am probably like 60% done, i am stuck on one piece of code and if i can get passed it id be all set, see if its something you are capable of and then message me back 
Just a shot in the dark, `os.walk` might come in handy.
Sounds pretty dangerous. Something like this, maybe? import os import fnmatch start = "." for root, _, filenames in os.walk(start): for filename in fnmatch.filter(filenames, "*.exe"): command = os.path.join(root, filename) os.system(command)
at the moment its just a list of the default python float objects. I'll look into Pickle
You're going to want to do an os.walk() because listdir just returns the directory tree. Once you've gathered all the exe files (or as you come to them) you want to do an os.startfile(&lt;path to file&gt;) which is equivalent to double clicking the file. It's actually super simple, but I can't help but think it's a terrible idea to do.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
&gt; It can be just as misleading as possibly useful to speculate. That didn't stop you from telling OP he's done wrong.
You can also do it with a recursive glob. Using `subprocess` avoids the unnecessary overhead of the shell. import subprocess import glob import os.path def run_all_in_tree(start_location): for filename in glob.glob(os.path.join(start_location, '*', '*.exe')): subprocess.call([filename]) run_all_in_tree('c:/foo/bar') 
&gt; it's worth noting that it is hardly ever a problem Well, that really depends on the domain you're working in, I wouldn't make such a blanket statement. My background is largely from scientific computing &amp; games (but I've done a bit of everything), and there python is certainly only used for prototyping and small problems, as personal calculator or interactive shell, etc, the kind of jobs that you would also use matlab for. In another post in this thread I enumerated some of the issues where e.g. `multiprocessing` scales poorly, like tiled sub-domains of a large lattice that have dependencies at the boundaries between the subdomains because they need derivatives/share some quantity across the boundary/etc. I would say that half or more of the algorithms (mostly physics stuff, monte-carlo, metropolis, PDEs, ...) I implement are a bad fit for something like multiprocessing. Remember also that while the existing solutions work OK for pythons current userbase, the userbase is shaped by its limitations. For instance I have absolutely no doubt that the limitations of the cpython API hold back pythons adoption as a scripting language, especially in gamedev (where lua -- in my opinion a significantly harder and uglier language than python) really shines. I think the fact that cpythons C API is so misdesigned in general is really as big as a factor here as the GIL, though -- multithreading in scripts is not really that important, but cpython is also hard and annoying (there are a bunch of other issues as well) to embed, and since it pollutes your process with global variables, there is no way to have more than one python interpreter at a time, which is a total no-go -- you would often want that e.g. several different AI actors can live inside their respective scripting VMs, completely independent of eachother and running in parallel. And don't get me started on how excruciating it is to build CPython for mobile and console platforms... Of course since the userbase is what it is, so there isn't necessarily a huge amount of pushing force to widen the adoption in other areas. But I think it's important to keep these things in mind and to not succumb to the echo-chamber.
Django
holy shit
On mobile so not 100% sure, but `re.findall` takes the pattern as a string not the compiled regex object. Or does `pattern.findall(htmltext)` work?
Nice.
Not sure if it's for a beginner, but SQLAlchemy has some fantastic engineering behind it.
Turns out this had '/usr/bin/python' in the Interpreter option in the RUN-&gt;edit configuration dialog. Removed that and it works fine (as expected now) thanks
&gt; Homework-style questions will be removed, and you'll be encouraged to post there instead. Also, kind of not cool to ask people on the internet to do your homework for you. Paying them to do your homework for you is worse... 
I highly recommend reading Python [flask](https://github.com/mitsuhiko/flask) and [requests](https://github.com/kennethreitz/requests/) source code. Also, if you haven't already, read [PEP8](https://www.python.org/dev/peps/pep-0008/). It's not code, but it's the official Python style guide. The [stdlib source](https://hg.python.org/cpython/file/tip/Lib) is great to look into as well. You could pick something like [csv.py](https://hg.python.org/cpython/file/tip/Lib/csv.py) and just dig into how it was implemented. Let's you know what you're working with!
* python 2 * packaging
It sounds like you've typed some code into the interactive interpreter and then saved the whole session — output and all — into a file. What you have saved isn't a python program, it's a interactive session. If you want to create a python file you need to go to "File" &gt; "New File". This video shows the basic idea: https://www.youtube.com/watch?v=da8YU52iPrE
It doesn't display stats for private users. Other than that, it's a cool tool.
I compare functions to music. Many songs have multiple verses and a repeated chorus. You can describe the song as verse1 chorus verse2 chorus This is helpful because it describes the structure of the song and hides the details. Each verse can be thought of as a function, and the verse is also a function. This demonstrates encapsulation and repetition. here is 'The ants go marching in' as a python program. http://cs.iupui.edu/~aharris/230/python/function3/ants1.py Once that is established, we talk about how similar the verses are, and how it might be better to have a single verse function that's more flexible. We also discuss how powerful it would be if functions made verses and choruses rather than simply printing them. These ideas lead to parameters and return statement, illustrated here: http://cs.iupui.edu/~aharris/230/python/function3/ants2.py This is also a good place to descripe scope. Finally, if you've talked about lookps, lists and tuples, you can make an even more powerful version that combines all these ideas: http://cs.iupui.edu/~aharris/230/python/function3/ants3.py Hope this helps... 
I don't think that's actually true. I don't remember having to stop/start APScheduler when adding new jobs. The last time I messed with this was three years ago, so I could be wrong.
Maybe use some sort of math exercise, like have them calculate e^x using a taylor series, and have them implement functions for factorial and powers.
You should take a look at [Peter Norvig's IPython notebooks](http://norvig.com/ipython/). They're more explorations of computing problems than source code, but you can still learn a lot from them and he goes into detail about the choices he made. If you copy the URL for any of these, you can render with [nbviewer](http://nbviewer.jupyter.org/).
Lamson is no longer developed
Shorter and/or more readible. I feel that it's important not to accidentally teach that it's all to shorten code. "But it ends up being more lines so I didn't do it."
Functions look intimidating because they disrupt the normal beginner thinking of "one line is executed after another". Being completely self taught in Python with no CS or formal education, I have learned to think of functions as packages of code that accomplish a specific goal. Typically, much like math functions, they have an input and an output. Don't even get me stated on classes though...
I think his code is well organised. Also Lamson implements a state machine which he wrote a corresponding blog post about and I enjoyed that and learned from it.
In this case you're probably not cpu bound or really especially I/O bound either. In which case it looks like threads are more of a design decision than to try to wring extra performance out of your code. As such, I suspect you'll be fine. Personally I find threads easier to comprehend than async methods. They don't scale very well, though.
I programmed VB6 and VBA for a living. You are either trolling or a manager.
&gt; Maybe use some sort of math exercise This is the biggest problem I've found with teaching materials. They almost always assume knowledge of math. We're teaching Python to humanities students. Some of them don't understand what `x**2` does. Most of them don't know the Fibonacci series. Yet so much material online uses math examples. I hate it. We need *other* examples. Things that are intuitive for people who think "I'm not a numbers person." For people who are *scared* to learn how to program because it's so *abstract*. /rant
Not a good idea. This sets a bad example where people get what they have not deserved. Let's not make the world worse.
Great advice, although the stdlib isn't really the best place to look for PEP8-compliant code. Depends on the module, though, some are really well written.
`python3 -m notebook` should do it. This is helpful with other commands like `pip` where if you aren't sure whether `pip install` will install to Python 2 or Python 3 you can use `python -m pip install` to force Python 2 or `python3 -m pip` to force Python 3. 
thanks for the suggestion, but we can't change the system on this level :/ 
I have no problem with teaching Classes how to `learn` and `solve_exercises` using a function: class Class: def function(self): learn = True solve_excercises = True Really though, have a student go to the board and write and solve a simple equation (i.e. `2+2`). The student writes out `2+2=4`. Now ask them to do it again. And again. The student and class will realize that it is unnecessary and inefficient and repetitive to write out the equation every time. Make a function with the student's name (I'll use `steph`). What does `steph` do? She solves the given equation `2+2`. This can be modeled as: def steph(): return 2 + 2 Now how does she know what numbers she's supposed to use? You told her. Let's model that: def steph(num1, num2): return num1 + num2 Now we can see she `steph` can solve an addition equation using any two given numbers. Bam! You secretly taught them how to define functions
Let them do something painfully mundane and simple, like printing the number 1, then 2, then 3... and lastly 10 using just print 1; print 2 ... Then ask them to now print the number 1, then 2, then 3, then 4, then 5, and then start over from 1 to 10 again like in the beginning. After this introduce them to the function that takes any number, and prints starting from 1 to that number, and they will maybe appreciate why functions are useful.
Usually, when I give a Python training, functions are introduced at the very beginning. The reason why we program is because we don't like to do things manually. This also means that we don't ever want to code the same things twice. Functions are the most fundamental way of code reuse, and I like to have this mindset from the very beginning. It doesn't mean that everyone will get the idea from the beginning, but all the way through the journey of doing exercises on variables, operators, data structures, classes etc, I come back to the question: "Can we make this piece of code more reusable, by splitting the code is simpler, but still meaningful functions?" and "Is there some kind of repetition inside?" Functions are also important, because they force people to think about naming portions of code. (It's good that Python doesn't have anonymous functions, except for the lambda.) Naming contributes a lot to readability. Further, they isolate a piece of functionality. I think interfaces between pieces of logic (the inputs and the outputs) are much more important than the actual implementation. So, I have a very strong emphasize on thinking about inputs and outputs first. (Similar to test driven development, except that I don't go as far as teaching people to write tests first.) But of course, finding the right abstractions to for making code DRY/reusable (without going too far), is probably one of the hardest things in programming; it takes time to master.
Richard Pattis, in 1981, created Karel the Robot which initially has no variables, and only functions (or their Pascal equivalent). This focus on functions from day 1 can really be helpful (but I understand that this obviously would not be the case for you and your students). In my experience, students that have seen print statements first get really confused between printing a result and returning a result - especially if you do things at the terminal. If you are interested in exploring the Karel-like function-based approach for Python, even if it is only for a day, you might want to have a look at http://reeborg.ca/docs/en/index.html (actual programs are run at http://reeborg.ca/world.html)
You must be on ya period, 'cause ya PMSing, bae.
shieeet you are the author of Peewee. Thank you very much for such an amazing ORM
You might also want to check out [Julia](https://en.wikipedia.org/wiki/Julia_(programming_language\)): it also has high performance, and (in my experience) is very similar to Python. Also, you can directly call (almost) any Python library you wish through the PyCall library.
I'm not using anaconda but I think you should be able to [create a python3 environment](http://conda.pydata.org/docs/py2or3.html) with: conda create --name py3 python=3 then activate it and launch Jupyter Notebook from there: source activate py3 jupyter notebook 
There is a paragraph in **bold** on the right side: &gt; If you are about to ask a question, please consider r/learnpython.
One of my personal favorites is [scikit-learn](https://github.com/scikit-learn/scikit-learn/tree/master/sklearn/). Especially, when it comes to a well-thoughtout objected approach, refactoring, PEP8, code documentation, and augmenting Python with C code here and there if computational efficiency is a concern.
Endorsed by Ned Batchelder in the sense he tweeted about it. But really a useful tool.
I've personally gone with drawing a box(with input lines on the left, outputs on the right) to explain how functions are. It also helps to explain scope and explain that function parameters arnt linked to the outside world Drawings are really good for explaining math and code
Math is popular in programming material, because it's what computers are built on. They are glorified math machines. We could make a function that, say, counts the number of words in a sentence, but it's going to involve looping and string parsing and maybe delimiters, and all that noise gets in the way of understanding the concept of functions that take input and give output based on that input. (although arguably Python makes such a function easy with `str.split()`, but then they must also understand that classes have functions attached to them, and that's one more thing for them to get their heads around)
&gt; flask What is the best way to go about reading a project for learning? Let's say I want to read the flask code.
A function is just giving a name to some computation. My favorite example is popular in Lisp courses, writing your own square root function with different parts: def square_root(x): guess = 1 while not good_enough(guess, x): guess = improve_guess(guess, x) return guess def good_enough(guess, x): return absolute_value((guess ** 2) - x) &lt; .0001 # add more zeroes for accuracy def absolute_value(x): if (x &lt; 0): x = -x # might also use "return -x" here to show multiple return statements return x def improve_guess(guess, x): return average(guess, x / guess) # Newton's method def average(x, y): return (x + y) / 2 After going through all that hell, you can inform them that Python has two built-in ways of doing this: `x ** 0.5` and `sqrt(x)`. It's still a good exercise, and it helps them know that the computer is not magic since all the built-in stuff is ultimately programmed by humans in a similar way (if we don't consider optimizations for the sake of language speed).
I've always had success teaching beginners a variant on [Literate Programming](https://en.wikipedia.org/wiki/Literate_programming). the way I do it I encourage the students to write out pseudo-code or even just english sentences to describe their program. once the pseudo-code scaffold is in place they implement it by writing code. its very easy to teach about functions and other units of code organization using this technique because it flows very naturally from the literate approach. a function is just the group of code instructions that implements a sentence (or maybe short paragraph, depending on complexity) from the literate programming scaffold. 
I disagree with you on this point. Humanities oriented people can learn a little math. However, I don't think anyone can learn a meaningful amount of programming, not even beginner stuff, without knowing at least a little bit of math beyond elementary school arithmetic. There's a cultural problem in that some people take on this identity of "not a numbers person" and really cling to it, somehow convincing themselves that they are constitutionally incapable of doing any math more complex than calculating a restaurant tip. That's what has to change. Everyone can learn some math. Everyone _should_ learn some math. A person determined to never learn any new mathematics is also determined to never learn programming. 
nope, can you further explain this please?
Fair enough. I had already taken several calculus classes before I even started programming, so the math exercises always made sense for me. 
Hello there. I am a long term contributor to Stackless Python. My interest in it started in 2003 when I joined CCP, who had chosen it to run it's ambitious project EVE Online. Here comes my rant, with lots of personal biases and semi-factual conjecture. Christian Tismer, Stackless' creator, had written it originally to demonstrate that a) Python could use a single level frame execution engine, instead of being internally recursive and b) that by doing this, interesting things could be done regarding execution. Unfortunately, changing Python's innards to not do recursion was a major undertaking and not compatible with all kinds of extensions. So, Christian turned to "stack slicing" to create multiple "tasklets". Christian's model was of Tasklets that communicate through Channels in a single thread, allowing for some very interesting cooperative multi-threading models. At CCP, we wrote IO libraries to dovetail to Stackless, so that IO operation would appear blocking to a tasklet, while behind the scenes asynchronous IO was just putting a tasklet to sleep. The advantage of tasklets and stack slicing is that the number of execution contexts you can have is only limited by available memory. With threads (or fibers) each context occupies a fixed slice of virtual memory, a precious resource. In EVE, we could have thousands of tasklets, each one servicing a single socket. Additionally, Stackless contained a number of other important extensions to Python, most notably enhanced pickling support so that a dormant tasklet could be pickled and restored. The concept of tasklets and threads has been useful as a teaching tool and for doing all kinds of experiments with co-operative algorithms. You can write stackless programs without there being any IO involved. Stack slicing has the drawback that special code has to be written in assembly language for each platform. So, Stackless python was no longer pure "C". Also, as a fork of Python, it was sufficiently removed with all its pickling extensions that merging it into the mainline was never really possible for all kinds of reasons. Stackless python was in many ways ahead of its time. It has been used to great effect in EVE Online, and also by frameworks such as Nagare. The Nagare use case is particularly interesting. There, the ability to pickle and unpickle runtime state is used to turn the web interaction model around. Instead of writing the server as a request processor, it can be written as an imperative program, where the user's interaction with a page follows an execution graph. When user input is required, execution on the server halts, and resumes once the user has interacted. Pickling is used not only to halt execution on the server to continue it later, it can be used in conjunction with e.g. memcached so that execution can continue on a different machine altogether. There are probably two main reasons why Stackless never really "caught on". The first is Armin Rigo's "greenlet" project. He basically tore out the stack slicing code from and packaged it in a stand-alone extension. This later became the basis for "gevent" which uses many of the ideas that we pioneered at CCP, but packages them in a convenient extension module to regular C python. Stackless was not ready to run web applications or anything out of the box, it always required the user to write or adapt a framework to do it. Greenlets and gevent provided this functionality in a convenient package, albeit not with tasklet picking. The second is probably that Stackless was simply too big to merge back into c python and therefore was always doomed to suffer neglect. Today, stackless is in maintenance mode. Christian Tismer has suffered some health problems in the last years and not been able to contribute as much as before. I have moved from CCP to other things and cannot devote my time to the project as I could before. As far as I know, CCP is no longer actively contributing. As for the web site, I don't know what is up with that. The last big contribution of the stackless team to Python was to port large parts of the pickling support code into Python 3. Python 3 should now be able to pickle all generators and most run-time structures in the standard library. The exception being stack frames and modules and such things that was probably too controversial to push through. But you can pickle your half-iterated itertools generator. C python really took a long time to catch on to the fact that tasklet style programming was cool. Frameworks such as "twisted" existed to try to make asynchronous programming more palatable, but Stackless' way was always more appealing, and simpler to wrap your head around. The human mind likes to think in imperatives, not reactions, I think. There was an enormous reluctance to adopt any kind of microthreads in python. For some weird reason, Python's inner circle though that python's "generator" concept was the answer. A concept that was originally hacked together to create iterators in a convenient way has now been co-opted into acting like microthreads. The machinery to make this work is horribly complicated, and wrapping your head around it even more so. A whole new framework has been written around it, "asyncio" and recently python has gained some syntactic sugar, the "async" keyword to further twist generator functions into behaving like microthreads. It would have been much simpler just to have proper "execution contexts" in Python, with stack slicing or not. Stack slicing is here to stay, though. Single threaded cooperative multitasking is your friend. 
That's pretty much it, yeah. Essentially any time you read from the disk, the network, or are waiting for something (eg. for a lock to be released, or for a time.sleep call to finish etc), then other threads can be scheduled and do work - these are generally described as IO bound because the actual *bottleneck* is the IO. If you sped up the CPU operation a thousand times, you wouldn't actually see much of a difference because it's already probably doing the actual CPU operations in a fraction of a microsecond, so changing that to a fraction of a nanosecond won't really matter. With most tasks, things tend to be IO bound, because computers are ridiculously fast in comparison to pretty much any kind of IO (for perspective, if you slowed a CPU down to the point where it'd take a second for each instruction to execute, a small disk read would be the equivalent of waiting around for a year or so). The exceptions are things like some games, or number crunching tasks, where you've basically no IO for a decent period so the only thing that mtters is how fast you can crank through the calculations. Here, speeding up the CPU a thousand times really would speed up the time it takes to complete the task, because the CPU is now the bottleneck. (Actually, technically even there, it's often stuff like memory access times that are the real bottleneck, rather than raw clock cycles, so you'd need to speed those up too).
Thanks, I'm glad you're enjoying using it.
&gt; This is causing errors when trying to add data to a database as double quotes are used for strings in the database. This is a huge red flag, and an X-Y question. I'm going to answer Y, not X. Use your database's bind parameter functions. If you ever string-interpolate to construct a SQL query, you are Doing The Wrong Thing. db.query("insert into foo (x, y, z) values (?, ?, ?)", my_list[1], my_list[2], my_list[3])
So here's a reply in two halves. This half is about getting them used to the idea of "I put code in a function" and "I can call that function". These functions don't return anything, yet; instead, they have a printing side effect. Next half-post will make the transition from 'functions that do something' to 'functions that return something'. Assumptions: interactive class, students have their own terminals. If you're teaching from a blackboard only, or teaching form a worksheet, this may need some adaptation. I'm not a teacher, so there are probably some rookie attention-management mistakes in here. Inspiration: * http://stevelosh.com/blog/2013/09/teach-dont-tell/#the-hairball * http://www.garlikov.com/Soc_Meth.html Form of the class: 1. Run a bunch of commands. Now run those same commands again. Tedious, eh? 2. Put those commands in a function with no arguments. Now you can run them all together any time you feel like it. Have the students run their function a few times. See how it saves them time to have the code in a function. 3. Now parametrize one thing in that function. Let them play around with calling the function with different arguments. Use key=value notation to make it obvious that you're giving something to the function. 4. Draw their attention to the similarity with builtin functions like `max()` and `min()` and `round()`. Here we go. So, say we want to count down to something: we print a 3, we print a 2, we print a 1, and then it happens! So write some code that does that; and you can choose yourself what to print at the end of the countdown -- Liftoff!, or Happy birthday!, or Surprise! or I love you, or anything you want. print(3) print(2) print(1) print("Liftoff!") So that's a countdown. Can you make another countdown happen on your screen? (Give them the time to make another countdown.) You have to type everything again, right? (Class gives you the silent 'duh' look here, probably.) It takes some time, doesn't it? Wouldn't it be nice if you could just type `countdown()` to make the countdown happen? Yeah, it would. Luckily, we can do that in Python. We can put some code together inside a function, and then we can run that function any time we feel like it. This is what a function looks like. def countdown(): print(3) print(2) print(1) print("Liftoff!") Now what does this do? countdown() It prints a countdown, very good. And if I do this again, what do I get? countdown() Another countdown. Awesome! I defined a function, and now I can call it any time I want. Now put your own countdown into a countdown function. What does your countdown say? And yours? And yours? Okay, lots of different countdowns. What if you had one countdown function for everybody, and you just tell it what to shout at the end? Well, you can: you add a function argument. def countdown(shout): print(3) print(2) print(1) print("Liftoff") countdown(shout="Liftoff!") countdown(shout="Happy birthday!") Oops. That still prints "Liftoff!". The `shout` variable gets passed into the function, but we still have to use it. I've got a `shout`, what line should use the shout? How do I change it? def countdown(shout): print(3) print(2) print(1) print(shout) Okay, so define the same function at your python prompt. Congratulations, now you have a function. It has one argument: `shout`. And it prints a countdown. Python has a bunch of functions built in. You call them the same way: first the name of the function, then the parentheses, and inside the parentheses any arguments. There's `print()` [Assuming you're not teaching legacy Python]. What does `print(something)` do with its argument? And what does `pow(x, y)` do? And what does `max(a, b)` do?
Multiprocessing is fixed in Python 3. Yet another reason to switch.
 import that
* Self is a choice, but no one likes you more for being original.
Python will for _printing_ to screen print as expected. Let's have some examples: The string: `abc singlequote def` : `abc'def` Will be printed with double quotes, because that way Python doesn't have to quote the quote. The string: `abc doublequote def`: `abc"def` will be printed with single quotes, because that way python won't have to quote the double-quote The string `abc singlequote doublequote def`: `abc'"def` will be printed with either single or double quotes, and will \ encode the content. Why is this? BECAUSE PRINTING IS FOR DISPLAY PURPOUSES. If you wish to represent text in output formats, use `repr` not `str`. 
That is an excellent advise. I am not actually in a position to change their exercises midterm (the coordinator had them made quite some time before I was even hired), but I will try to include some of my own exercices in the next class.
That's a really great example indeed. I'll try to think of a native song that has the same sort of general behaviour.
That is indeed my bet as to why they are misunderstanding the notion altogether. I've actually drawn some diagrams to show the flow of execution and then explained that a function is a way to encapsulate some of that flow. I'm not sure I was successful, though...
Thanks. This goes hand in hand with my idea of a recipe, but it may be even more appropriate, as the complexity of an engine is a bit superior to the complexity of a stove :P and abstracting those details is even more important.
* python3 is better than python2. * python2 is better than not using Python. * Code should never be optimized before it's correct. * Unless it's for a microbenchmark. * Tests are one honking great idea -- let's do more of those!
Yeah the loop is better for this. I wanted to reply fast and didn't come up with a better situation where a function would be better :P
Really helpful comment. I can even explain further that we can parameterize on the initial number, since they already have the notion of loops. This will introduce variable inside the function to keep state (`for i in range(n, 0, -1)` or equivalent with `while`). And having them test the code in their own terminal will help, I think. Unfortunately, half of my classes are in a classroom with no computers, so I can only test this next week. &gt; [Assuming you're not teaching legacy Python] Unfortunately I am, but that's another entirely different topic.
&gt; The number of bugs per operation is a constant. I prefer "Number of bugs is linear with number of code lines." It is the basis behind many other code practices; DRY, simple is better than complex. don't pre-optimize (optimization often is longer code), short single purpose methods/functions. Of course it is not unique to Python.
Can't get behind rabbits not quacking. That is in opposition to Duck Typing and the flexibility it bring. I often have my rabbits done a duck costume. For test mocks and the Adapter Pattern.
Python is fast enough. When Python is not fast enough, there are many solutions.
Almost as easy to write as golang.
Another, semi-related tool I saw recently was [Pigar](https://github.com/Damnever/pigar), which has the potential to be awesome. &gt; "A fantastic tool to generate requirements file for [an existing] Python project, and more than that."
Not sure if it's been mentioned, but the multiprocessing module can basically be sued as a drop in replacement for threading. This will probably get you the performance you need at the expense of a lot of memory
This is getting a little meta, people. https://twitter.com/nedbat/status/663739273632456704
lol
huh, under 1000 lines
I missed that one. 
yes it seems like the multiprocessing module could be used here, and from what Brian was saying, i think the memory expense may not be a problem, or too much of a problem &gt; If this is the case, and you are CPU bound, it may be worth looking at the multiprocessing library, rather than threading. This will spawn a seperate process for each thread, which means there's no shared GIL. This comes at the cost of making communication more expensive (everything must be copied to send to another process), but if you've no communication, this won't matter. 
It's released under Apache 2.0.
The idea is that something that can't do any of the stuff a duck can do shouldn't tell users it is a duck. It was meant along the lines of "don't lie to users." I could certainly see valid reasons for a goose quacking, or a coot, or even a turtle in some situations. But not a rabbit. And most of the rules go right out the window when it comes to testing.
Anyone who uses something other than `self` should be shot. 
Yes - in `@classmethod` and metaclasses `cls` is quite common.
Yes, I saw a project once that used something other than `self`. I forget the exact project, though.
Also this guy's Twitter bio: https://twitter.com/ballingt This is officially a thing haha.
That's literally PEP8.
for example: class ForBlackrat47: def something_different(shot): """see what I did there?""" 
I've done it, but only to piss off the other guy on the project. He claimed that pep8 had no value, so I just started using 'me' instead of 'self' I considered using 'my', but knowing him, he'd have liked it.
I think they are similar, but not exactly the same. I interpet the first as being more about API flexibility. You should let the users use the API the way they want to, rather than keeping things too strict to the use-cases you can envision. The second is more about safety. You shouldn't prevent users from doing something you think is dangerous. There is certainly some overlap there, but I don't think they are exactly the same. To be more specific, duck-typing is an example of the first, while method name mangling is an example of the second.
Except it is already basically in the original: &gt; Simple is better than complex.
I was really worried it was somewhat dependent on Go or a weird language, imagine my surprise when I read: &gt; import tensorflow as tf Kickass.
The idea of the Zen is somewhat-abstract thoughts that sum up good design principles. Ideally they're things that apply to absolutely everybody, regardless of circumstances. "Four spaces is the law" is an example of something that is entirely personal taste. "Object-oriented programming..." is an opinion :P Something like "It is their foot, they should be able to shoot it if they really, really want to." is an excellent Zen of Python line and should be included imo. Props to /u/TheBlackCat13
I write C# for a living, but python for fun. There's been a couple of times when I've used `this` out of habit, but I've never encountered it in the wild.
I'm not a native speaker but 自分 would probably work better
One of the comments below: &gt; rhmoult commented on 6 Feb &gt; Thanks! I've updated this to use SSL: https://github.com/rhmoult/SecurityTools/blob/master/Platform_Independent/Python/httpsWithUpload/src/httpsWithUpload.py Haven't even looked at either so of course handle with care, but if verified this could be useful 
This is a good one. I often make dorky little jokes about using `this` or `my` instead of `self`.
Ah, that's a fair point. I just always mentally grouped both of those concepts under the "We are all consenting adults" ideology because it makes sense, but you make a good point.
I made pretty much the same once, and it got deleted after 20 minutes with exact that reason :| Well, can't help you with that problem, though, sorry
Why not use if statements to say if you are at the end of the row then don't add the pipe?
This is better suited for /r/learnpython. Your post may be removed given the warning on the sidebar.
One for people coming from Java or C# • it is okay to use functions you don't need a class for everything
What's the problem with OOP? I think it's great. Actually, what are the alternatives? Because having everything as functions sucks. balls. a. lot.
I've been using Google's "Neurolab" in python for about a year. This library looks very similar to previous releases of Neurolab.
Being a guy that started programming on Pascal and then Delphi, I really like that it uses "self". It brings some nice memories and feels more elegant.
I can't take credit fur that one, it is a common saying on the python-ideas mailing list.
Sometimes, when writing decorators or other maximally generic wrappers, I'll do something like this: def func(*args, **kwargs): self = args[0] args = args[1:] ... Here's an example from one of my libraries: https://github.com/Lucretiel/Dispatch/blob/master/dispatching.py#L150-L155 The idea is that there is the SLIMMEST chance someone might use `self` as a kwarg, and I don't want that to break.
自己 works for Mandarin tho ;P
What do you need help with? Edit: try r/learnpython, this post might be removed because it's against the rules.
Is it possible to use TensorFlow on windows? EDIT: Come on guys.... Why would you downvote this? Random windows user hate? Its a legitimate question that other people may have and the answer to it is a couple child comments down. And then all the upvotes to the comment asking why you would ever use windows?? This subreddit is worse than r/pcmasterrace as for as elitism goes and that place is meant to be satire. Windows has tons of reasons to use. Huge amounts of support and available software that is easy to use . P.s. The answer is no, unless using a virtual machine
Does any of these have a switch to list also the standard library dependencies? Could that be used to shrink Kivy projects that now take MBs to install on android? 
More literal for sure. Anyways it was just a spontanous idea and the first thing that came to my mind was "ich".
All you need is Python 2.7.
I use 's' cause it's three characters shorter. It really adds up. We all know the terser the language the more readable it is. Cause you can get more concept on one line. Also the more obscure the code the cleverer the programmer. &lt;/end sarcasm and reverse rant&gt;
That seems to not be the case. It requires a virtual machine to run it on windows. Im not exactly sure what kind of performance I would get out of that. Might be better off to just install ubuntu. Why did I get rid of my partition when installing windows :(
excellent explanation, very helpful.
Just looking at the intro, it looks very similar to [`dask`](http://dask.pydata.org/en/latest/) in its architecture. Looking forward to trying it out.
In all honesty the main reason I use Python 2.7 is because I hate having to put parentheses around print statements. Yeah there's the whole thing about being around for longer and being stable and legacy support and all that, but sincerely my main reason for sticking around is print "hello world" Is just a little easier on my tiny hands than print("hello world")
No Python 3 support?
Technically a valid use case! Just... one you should try to avoid.
What editor are you using? You can make it map Alt-P or similar to the word print() with the cursor inside the parentheses. 
Yeah it's kind of unfortunate they removed print as a statement. Something about special cases not special enough to break the rules.
[Image](http://imgs.xkcd.com/comics/workflow.png) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1172#Explanation) **Stats:** This comic has been referenced 530 times, representing 0.6048% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cwul8cn)
Only runs the first .exe it finds... Not a massive flow of programs...
I think Flask supports python 3. Twisted and Fabric come to mind as the main ones still officially python 2 only.
In the spirit of the thread, one might say because *flat is better than nested*. There are typically two orthogonal concerns of an inheritance hierarchy. One is representing a tree of behaviours, the other is representing a tree of structures. Consider perhaps the simplest typical introductory inheritance tree: a cat is an animal. It's true that *behaviourally*, every cat, dog or cow is an animal. But is it true structurally? Does a cat *contain* a core "animal" part with a bunch of cat-like extras stuck on? Of course not. Even the most introductory exercise into OOP falls into this trap, so it's no wonder people get it wrong. Languages which reject OOP typically do offer these techniques, but they do so separably. Such are Haskell's typeclasses or Rust's traits. Java's interfaces are also on a similar vein. In Python, one just uses duck-typing to give rise to implicit interfaces, or ABCs if one so desires. One doesn't have to make everything into functions to do this. Of course, you still need structures to hold data - non OOP languages typically have cleaner ways of doing this, too, probably due to the clarity gained through separation of their concerns. Further, representing disjoint unions of state is normally a first-class tool. Python typically needs type-based dispatch for this, which IMHO is a lot less clean but almost as effective. Languages like Ceylon and Crystal even have arbitrary combinations of types, which makes such a thing more comfortable. Some languages like Nim also have what's called *uniform call syntax*, which gets the syntactic nicety of `foo.bar()` without the special casing - *simple is better than complex*, yet still *readability counts*. Julia doesn't, but uses the consistency to work multiple dispatch deep into the type-system. However its done, once you've stopped inheriting frequently method calls start to look an awful lot like the syntactic sugar they are. Languages like Haskell and Lisps are even syntactically sparse enough normally not to want this sugar at all (and should I quote the Zen about sparsity?). Some functional language users will also criticise OOP because they're unable to separate the coolness of some of the things they have from their overall sentiment that "OOP bad, Functional good". Luckily the truth is not so harsh, and those cool things are almost always equally suitable for an imperative, OOP world or not really that important anyway. So, I'll say to you, you can totally write methods and avoid OOP - and most people that avoid OOP do indeed write methods. Python is great for a non-OOP approach to programming mostly because it's so easy to use flat hierarchies with it. Although practicality beats purity, so don't neglect to use it when it does fit! OOP hatred mostly comes from Java and connected languages, which took it too far. So don't follow the hate, but learn the lessons anyway. At least, that's my opinion - YMMV.
Is not "entirely" personal taste. As long as you stick to whatever you choose, there isn't much difference, but there's one pro of spaces that make me prefer it over tabs: flexibility of line wrapping. Take the following line, for instance: stuff = make_sutff(arg1, arg2, very_long_argument_name=long_variable) Now, let's say I wanna wrap it because it's more than 80 columns, or something. With tabs, there's only one safe solution: stuff = make_sutff( arg1, arg2, very_long_argument_name=long_variable ) If I do this, instead: stuff = make_sutff(arg1, arg2, very_long_argument_name=long_variable) I'll most likely have to mix spaces with tabs to properly align the last argument, and this will break the visual indentation for people with different tab widths, and at this point, you might as well use spaces, if your tab has to be always 4 spaces anyway. It's a small pro, but since it's the only objective reason I see, I'll take it.
I've been learning to program for 5 months-ish. But is this like a form of AI? or something? So can someone ELI5 why I should be excited?
I don't see what your point is.
Ah, check again - a few hours ago I re-ran `conda update pyqt` and it's working now :) 
Not exactly. It's a library that makes certain kinds of matrix algebra computations very easy to do, and it just so happens that many modern AI-ish applications (detecting stuff in images, understanding/generating natural language passages, etc.) are special cases of these kinds of computations - the so-called "deep learning" methods, although TensorFlow would work for any kind of gradient based optimization problems. The general idea of these AI applications is this: Instead of manually writing lines of code that deals with every aspect of some problem domain (say, taking natural images as input and outputting text describing the objects in the images), AI researchers figured out that it was far easier to collect a bunch of input-output examples and use generic algorithms to "learn" the correct mapping between examples. 
If your processor has virtualization extensions (which most do) there's basically no overhead, the virtualized machine is being run on bare metal. Although I'm not completely sure on this and could in fact be 100% incorrect.
is there a quick way to disable line x through line y of code without typing # in front of each line?
Did anyone else think that all the humans in that video were more like robots? 
&gt; not try to get them to understand Fibonacci or Eratosthenes' Sieve Those are more obscure areas, though. Something like square roots or averaging should not be beyond a programming student. &gt; Wasn't Python developed to be able to ignore all the low-level stuff? Math isn't low-level. Math is fundamental. The low-level stuff that Python seeks to abstract is memory allocation, manual string parsing, implementing popular data structures by hand, making low-level system calls, and similar. Anyone learning programming should be fluent in arithmetic and basic algebra. They need not be familiar with Fibonacci, but if they can't solve a basic equation, they are in for a world of trouble. If someone thinks they can program without involving numbers in some way, they have been sorely misinformed. Even a basic operation like centering a window on the screen involves math, even though it's far from a math concept. Plus, before a student can begin working with graphics, they need to understand language mechanics like functions. We can't teach functions with something that requires an existing understanding of functions.
Look up a generic introduction to object-oriented design. You should get the picture that classes are blueprints for "objects" which have properties and abilities just like physical objects.
Oh God. I'm now planning long term for an April Fools prank...
...why not just pass the instance into the class...unless it was being used as some sort of factory? 
The standard library does this in a few places so don't feel bad. And if someone did use `self` as a kwarg they deserve all the hell they get.
I remember seeing some code a JavaScript person wrote that used `this` instead of `self`.
OOP is just binding functions and memory together. It's inherently less efficient and more complex. It introduces a lot of design problems, and doesn't solve any problems in particular. People like it because they feel like they are modeling things in real life, even though normal OOP is pretty rotten for many types of simulation (e.g. space, time, interactions between objects, etc.). The alternative is to use modules, which contain data structures (structs in C, classes in Python), and algorithms (functions). This is the way Unix was built, the way Linux is currently developed, and the way many people have always programmed. The only thing you are doing is removing a restriction (data structures and functions are tightly coupled in OOP).
well if you read the example you can programatically read captcha images. 
I feel like I kind of get what you would use a class for, I've just never come across a need to use them. My understanding is that people use a class to spawn many objects with different attributes. So something like this with a class 'Worker' w = Worker() result = w.do_work() But then I often just find myself using a function directly as I never have the need for spawning multiple workers: result = do_work() I guess they are useful for code organization if you treat them like mini modules, but is that really a good use case for them?
http://www.howtogeek.com/213795/how-to-enable-intel-vt-x-in-your-computers-bios-or-uefi-firmware/ http://www.intel.com/support/processors/sb/cs-030729.htm
The mini-module usage is kind of Java-esque. Classes clicked for me when I got into game development early on. Imagine I have a generic kind of Enemy class. Now, I can make subclasses of that Enemy each with their own abilities. This Enemy would be a subclass of a more generic Entity class. With that kind of structure, in my game loop, I can have a list of all my Entity instances and call something like for entity in entities: entity.draw() to draw them all on the screen. Even though each entity has its own unique properties, they are all drawable. Similarly, all entities might have health and be able to sustain damage, or they might have velocity. I can use the more abstract Entity class for those operations, and get down to the specifics only when I need to. This becomes difficult to pull off with only functions at your disposal. For a business perspective, you might have data you associate with a customer, so a Customer class would be in order. Classes are also useful for "personifying" tables in a database. You can create a function in your Customer class like `get_name()` that queries the database for that customer's name based on an ID, assuming the object is aware of its own ID in the database (likely sent via the constructor). There are many other uses as well. Learning Java forced me to really come to grips with classes and their purpose, and learning C forced me to abandon all of that an understand what can be done with data and procedures alone. Now, Python has both of those, and I know when to use both since I have the ability to choose. That said, anything a class can do CAN be recreated with data structures and functions. When I write C, I often find myself defining "classes" which are just `struct`s with some functions that take a `self` parameter of that structure. Similarly in Python, you could use a named tuple and a function with a parameter for that tuple, and you've made your own simple object system in Python without using classes. However, you should just use classes in languages that provide that to you.
Ok, thanks. At least now I know that there wasn't some obscure Python feature that I wasn't aware of that was the issue.
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
yep, i wanna say the same thing :)
I see that all the time... I think it is one of their conventions???
Well, it's PEP8 compliant, so it must be okay.
By that standard, so is the Python interpreter's implementation of the `dict` type. I guess you need to brush up on your assembler. This is arguably better because, given that we can assume (though apparently you're a counterexample) that Python programmers are familiar with the standard library, it's more immediately apparent what this code does. Being shorter and clearer is a good thing. Moreover, while this is a silly example, generally speaking, using the well QAed standard lib is generally advisable to reinventing the wheel by rolling your own. Also, if you're so bothered about the standard library's being a "black box," look in your Python directory. Almost of all of it is written in Python. `collections.Counter` is implemented in libs/collections/\_\_init\_\_.py. 
If you had valid arguments, you would just state them without the personal attacks. Friendly subreddit you have here.
&gt; I guess you need to brush up on your assembler. &gt;...given that we can assume (though apparently you're a counterexample) that Python programmers are familiar with the standard library, Take a deep breath. Just because someone disagrees with doesn't mean you should insult their competence. 
This is a single quote `"'"` . The is a double quote `'"'`. This is the word can't `"can't"` . This is the phrase, "this is a phrase", `'"this is a phrase"'`. That's all it is.
There's this one time I used "slef" for an assignment to be submitted...
One of these days I'm going to remember that the Counter class exists before writing an initial implementation a different way. One of these days...I just don't write code that needs Counter often enough to remember.
Track your website visitor's actions, real time and more...
Maybe they were programmed with TensorFlow
we will see first and then add this one into our post..thanks for sharing..
It's not a black box when there are extensive docs and source. You can't get much better than Python stdlib docs. 
Link to nbviewer (often down): [http://nbviewer.ipython.org/gist/TomAugspurger/a6877233fbbfb51512a9](http://nbviewer.ipython.org/gist/TomAugspurger/a6877233fbbfb51512a9)
They do have valid arguments. And if you are too sensitive and precious to understand them then that is your problem. 
They don't. They are arguing that ensconcing the action of a program inside another program is good procedure. I argued that the article was crappy because it amounted to saying: "Use X standard library for Y task." Insulting comes more easily than reading on this sub, apparently.
Hi ADC_TDC There is a distinction to be made between stdlib contents and other sources of modules in that the standard library is checked by the Python core developers to be used as stated by the language documentation. If you are a competant Python programmer with problems in a particular area then that would be the time to delve into the sources to see if you can get a particular function or module to work better for you, but for most use cases the standard library solutions are designed to be a good starting place. Use of a standard library solution has the added benefit of making the code _more_ readable as a large percentage of readers are expected to know what Counter does as opposed to any bespoke solution - even though a particular use case may not need all the functionality provided for example. 
It is showing you the history of it for god sake! Don't you understand that? And yes you should use the standard library when doing these kind of tasks. It will no doubt be better and easier to understand. &gt;Insulting comes more easily than reading on this sub, apparently. If you are a hyper sensitive person with a severe lack of comprehension skills then apparently so. Seriously.
&gt; Loose coupling is the root of all well designed code ...but too loosely coupled code is brittle. It's a bit like the "you should have an open mind, but not so open your brain falls out"
good bye pybrain ?
Or use "teh" if porting from LOLCODE
It doesn't even *mention* Python anywhere on the page. Are you lost?
 for line in pg_hba.conf: if line.split() == ['local','my_dbname','my_username','auth-method','trust']: break else: insert at correct line position in file
Could you provide a screen cap? This link is definitely often down. 
Another suggestion: if not any(line.split() == ['local','my_dbname','my_username','auth-method','trust'] for line in pg_hba.conf): insert at correct line position in file 
You shouldn't need to create the `kernel.json` manually. Once you've got IPython installed in the virtualenv, run: .../myvenv/bin/python -m ipykernel.kernelspec --user
Dude, go grab a cold beer and chill out. You asked: &gt;It's still a black box. Why is that black box better than two lines of code? And I answered you: * It's not a black box: what it does is very well documented. * It's shorter * It's clearer * It's standardized * It's QAd I ever agreed that in this case it's not a big difference, but for all of those reasons, using the stdlib is better than not. I really don't see what your problem is here. As far as your claim that I implied you're a bad Python programmer (the horror!). I never implied that, and I don't know how you'd get there from my saying you need to brush up on assembler (implying you actually know it) if you want to use no "black boxes." I said that Your complaint is bizarre, and you don't know the standard library (because, frankly, that seemed both more likely and more to be giving you the benefit of the doubt than assuming you knew it and were objecting). You seem to have missed that the article was advocating nothing. It was a cute history lesson. That's all. In fact, his main point was that, as much as we try to be Pythonic, that standard changes over time with the language, and what is Pythonic today may not be tomorrow.
[Awesome-Python](http://awesome-python.com/) is intended to be a laundry list of good python projects to look through. I find it a bit overwhelming, but I do like exhaustive lists at the same time.
&gt; Anyone learning programming should be fluent in arithmetic and basic algebra. Students should able to count things, add two numbers, or multiply them. *Maybe* they should know division. Beyond that, it's all optional, and we shouldn't expect them to know more. Challenge yourself: how much can you explain without going beyond that limited amount of maths knowledge? &gt; Plus, before a student can begin working with graphics, they need to understand language mechanics like functions. I agree that students need to understand functions, but they don't necessarily need to be taught using numbers. Sadly numbers are the first thing that come to mind when trying to think of examples. My point is: try to find *different ways of explaining Python*. &gt; If someone thinks they can program without involving numbers in some way, they have been sorely misinformed. Maybe they're onto something. For some people, it would be better to introduce them to programming using very high-level concepts, and then gradually introduce the lower-level principles behind them.
Yes that would of course have been cleaner. I don't remember if there were any other reasons for doing it this way.
Thanks I looked into what you suggested. New to this so I appreciate it
I could see if it was some sort of class factory this making sense and closures are really powerful tools in Python, so I can see the use in doing this but I'd probably find a better way to handle it.
That's a metaphor. If you pull your head out of your ass and stop trying to one-up him with some stupid retort, you'll figure out his point pretty quickly.
Hum, you know, there are reasons why scientific notation is used. One of the most important is to **prevent users from shooting themselves in the foot**. And you are most certainly currently shooting **yourself** in the foot. ## Significant figures and IEEE 754 floating point numbers Actually, with double floats (float64 in numpy notation), you can expect at most 14-16 significant figures. This is because of how these numbers are represented in memory ([IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point)). The extra figures are generally just garbage and can't be trusted: &gt;&gt;&gt; "%.16f"%(0.1) '0.1000000000000000' # == 0.1 -&gt; Seems alright &gt;&gt;&gt; "%.17f"%(0.1) '0.10000000000000001' # != 0.1 -&gt; True in-memory representation ## Actual impact in real (i.e. non specially crafted) operations Ok, I guess you are not convinced: that's only theoretical gibberish you say. In the real world, this won't cause real problems. **Wrong.** ### Description Let's just try something using a bunch of random numbers which follow these rules: * You said that you encountered numbers in scientific notation, * therefore the result must have an exponent of at least 1e16 (or 1e-16). * You asked for a decimal precision of 2, * therefore I'll give 2 decimals in each numbers. ### Example operation Here is a simple operation determined **with random numbers** according to the description above: &gt;&gt;&gt; 58222212.23*605554.27*80502.80-15.01 2.838263811376008e+18 Feel free to pick any other numbers: what I will show you will work in the general case (i.e. more often than not). ### Displaying in decimal notation &gt;&gt;&gt; "%.2f"%(58222212.23*605554.27*80502.80-15.01) '2838263811376008192.00' Isn't there something shocking already ? The decimal part of my random numbers exactly cancelled. What a coincidence! If that's right, the decimal part of the product of the first 3 numbers should be `.01`, right? &gt;&gt;&gt; "%.2f"%(58222212.23*605554.27*80502.80) '2838263811376008192.00' Oh, I did not subtract `15.01` and yet the result still ends with `...192.00`! ### Full precision calculation The only what to see what happens is to perform the calculation with integers. (58222212.23*605554.27*80502.80)*1e6 + 15.01*1e6 -&gt; (5822221223*60555427*8050280) + 15010000 And we get: &gt;&gt;&gt; (5822221223*60555427*8050280-15010000) # * 1e-6 2838263811376008337661880 # *1e-6 Therefore: 2838263811376008337.66(1880) to be compared to: 2838263811376008192.00 So the 5 last digits are **not** significant. And oh, big coincidence (hint: it isn't), the scientific notation hides these 5 last digits: 2.838263811376008e+18 ## Conclusion If all the digits in your calculations are important, do them using integers. Floating points numbers are only useful if you want to keep the first 10 or so digits of your calculation (assuming double floats). IEEE 754 floating point numbers were designed for engineering purpose, not for math. They are a trade-off to get sufficient accuracy on a wide range of numbers. When you perform a calculation on large numbers, you can easily decompose the operations into a bunch of integer calculations if you want exact precision (in banking for instance). But in most cases, you don't have exact numbers (uncertainties in science) and/or you don't care about a certain level of details (I don't care if night falls at 7:23:16:15'168", 7:30 might be enough). With float64 (double floats), this level of details around 14-15 figures (if you don't perform to many operations). This is actually sufficient for most of the science, engineering and financial calculations out here. 
Is it just me or do they all look the same? The styler isn't working in Firefox or Chrome.
Your data must never never never be interpreted as part of your command to your database. You could do this by trying to predict all the ways some data might break out of that way of being interpreted as data, and changing it, as you were trying to do with " and ', but that is doomed to failure. Don't do that! A database must be able to take any data and give back any data, *unchanged*. It has ways built in to facilitate it. That way is through adding placeholders in your statements, and giving the database the data separately. Play with it until you understand and the bobby-tables XKCD is funny. http://bobby-tables.com/
In the future, please post this kind of questions in /r/learnpython. -------- 1st year college student should be used to math functions. Something that has always worked for me is to start with what they know: basic math, calculating then drawing f(x) = y (and then more complicated functions). Then, once they are used to it, you can introduce different problems and talk about laziness and automation.
This kind of question is better suited to /r/learnpython.
[Facial recognition](https://www.keylemon.com/), [Movie recommendation engine](http://www.jinni.com/), [Self Driving cars](https://www.google.com/selfdrivingcar/)
This kind of question is better suited to /r/learnpython.
Ok, i will repost there, do you know of a fix though?
&gt; news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python &gt; If you are about to ask a question, please consider r/learnpython. Asking someone to check some code because one cannot see what's wrong (which is fine, don't get me wrong) **is** asking for help. Asking for reviews is also asking for help. You don't need to type HELP to ask for help: the process of getting people do something for you is asking for help. /r/learnpython is not dedicated to students who want some help with their homework. /r/learnpython is for anyone who has any question/problem that they want to ask/expose to other users to get some input/"help". This is to oppose to /r/python which is used to post python-related news and third-party documents/media. 
This kind of question is better suited to /r/learnpython. In the future please consider asking similar question there.
This kind of question is better suited to /r/learnpython. In the future please consider asking similar question there.
This kind of question is better suited to /r/learnpython. In the future please consider asking similar question there.
This kind of question is better suited to /r/learnpython. In the future please consider asking similar question there.
This kind of question is better suited to /r/learnpython. In the future please consider asking similar question there.
There is nothing obviously wrong with the code. It works as intended. Perhaps I should have phrased the title better. I was looking for a code review from a more experienced python programmer.
I hadn't intended to imply gender with it (I have, on occasion, called my wife "dude").
Ignore pep8 at your peril :-P except line lengths of course ;-) 
You're using "a company" here with zero context so I'm afraid all I can offer is a rough estimate. For an entry-level gig, a company is looking for someone who knows how to follow instructions and has a rough idea of how the language works, especially how it works with the product in development. Specifically, be comfortable with the language and be open to instruction. Some of the best juniors-turned-senior I've met have just been curious people who like to write code well. That last part is key though. As a junior, you need to be driven to find out the *right* way to do something. You have a research background though, so you could theoretically get a job as a researcher using Python -- my company employs a few of those. Or use your experience in research to leverage that into a developer role. Lots of companies have an R&amp;D division, and it sounds like your skills would fit right in.
True. :)
&gt;He did not say anything about optimizing the critical parts. In fact he specifically encouraged optimization of these, but only after these parts have been identified. I think that's pretty well covered by the word "premature". I don't think people misreading the phrase and interpreting it in their own way is a good reason to change it.
I've *never* seen loose coupling cause brittle code. Do you have examples?
Twisted supports Python 3 now, too.
Wait, you think classes in Python are an *alternative* to object-oriented programming?
His first comment was fine, and, when I responded, it was at 0. That said, I think a small number of downvotes are justified in that he was wildly off base. There's no need to upvote stupidity just because people's correcting it results in good comment. Right or wrong though, I'm pretty sure the downvotes came later as because of his other comments, which is against reddiquette. That said, his other comments definitely do deserve the thrashing they've received.
Oops... Sorry...
*Standard disclaimer of it depends on type of company and where they are located* This info is based on how I have helped other people that came from other disciplines (one was a music degree) move into Python work. The skills they look for vary, but at entry level they all want someone that knows how to computer, and has an eagerness to learn. Make sure you know how to run a program from the command line on both windows and unix (when they say 'unix' they usually don't mean 'unix' but either RedHat or Debian based linux, like CentOS or Ubuntu), and basic terminal navigation. More than any specific skills, I have seen there are a few big things that can help you out getting these jobs. 1. At your current position, try and get something about 'programming' or 'python' into your job title, or at least include in description. 2. Make sure 'self-taught' is a visible keyword in your resume / cover letter. It shows the companies that you have drive. 3. Have a github (or similar) account with some working samples of your code. One of the people I was helping had them pull it up and run it over a phone interview. (It was a super simple cmd line based game, important thing was it worked.) I would suggest brushing up your resume and linkedin, and putting it on sites like indeed.com. (Even beginner programers are rather in demand depending on area, be prepared to deal with headhunters that want to move you to different areas.) Edit: can't words sometimes 
https://leetcode.com/ Practice coding interview problems and you'll be fine. One of the best devs on my team has a PhD in chemistry and was using python for his research. Our team builds web applications. If you have a solid base and have proof of passion (github!) it shouldn't be too difficult to get an entry level (or higher) python job. 
Well, I did just get tested with Fizzbuzz. Everyone before me had failed. So looks like I got the job...
I did this.
At entry level I assume the person is going to spend a good chunk of their time at the beginning learning so I look for smart and can get things done. This is a good read although the advice appears to be polarizing for some people. http://www.joelonsoftware.com/articles/GuerrillaInterviewing3.html For me unix / windows experience is that you understand the internals of how the operating system works in a way you can use it with code. Might also mean be able to admin unix / windows systems depending on context. 
This isn't a subreddit about asking things. This is a subreddit about news and 3rd-party media about Python. /r/learnpython is the right subreddit for asking things. Your questiin is interesting, this is just not the right place. **To the downvoters:** please read the information at the right of this subreddit and once you downvoted me, please explain how this question can be considered as a **news** or an **announcement**. Thanks.
A single * (splat) indicates varargs, this allows a function to take a variable number of arguments by passing all remaining (non-kwarg) arguments into the function as a list. Two *'s is for handling kwarg (keyword arguments), such as `myfunc(foo='bar',baz='foo')` - the kwargs that don't match parameters already defined in the function are converted into a dictionary and passed into the kwarg parameter.
If you don't want to use SMS, [Pushbullet](https://www.pushbullet.com/) have an [API](https://docs.pushbullet.com/#api-quick-start) that's pretty easy to use, and free. There's several Python libraries to use it too.
Congrats! I'll have to take a look into this.
Hey thanks for sharing! I wrote this post, and it was a lot of fun to work on. I was actually going to use Celery at first. Decided to go with RQ for simplicity and because I couldn't find many resources online for RQ Scheduler.
Click the link click get started and there's a tutorial thing 
To be clear, you should be able to do a lot more than just FizzBuzz. That's a basic algorithm. But evidently a lot of people try to get hired without being able to do even that.
Instead of writing code to handle every case of some type of analysis. You write an algorithm that guesses what the analysis should be based on a set of test data. on the real data, it can "learn" what the mapping be should be from the test data and apply it to the real data. The machine learning part comes in when you encounter each additional test set, you refactor the whole algorithm based on this new information. The more test data you get, the more accurate the algorithm. It involves a lot of probability and linear manipulations. Read the tutorial on the link it will walk you through an example
Is it possible to have syntax highlighting as rich as this. https://github.com/jdiaz5513/NotSoNeon-color-scheme
I almost took the bait there :)
This is what I have so far. I have one script that will list the files in a directory to a text file. Now I'm trying to make a second script that will compare the names of the files in the .txt file to a list from a directory, and return the difference. import os, sys path = "C:\\Users\\INstokes\\Desktop\\CityPts\\" old_files = "C:\\Users\\INstokes\\Desktop\\CityPts\\file.txt" new_files = os.listdir( path ) text_file = open(old_files, "r") old_list = text_file.readlines() s = set(old_list) temp3 = [x for x in new_files if x not in old_list] print temp3 text_file.close() It's just generating a list of what is in the directory rather than the difference. Any suggestions?
I've seen `my` used: def order(my, food): my.desert = my.favorite() my.entree = food It was used by a guy who used Python classes as configuration files. I couldnt find him or his site anymore.
Use `readlines()` instead of `readline()`
Disappointed that `__debug__` isn't mentioned, nor the fact that `getattr` works and `builtins.foo` sometimes works and sometimes doesn't.
And here I am, unempleyed, learning decorators and shit, while I should just start going to interviews... DAMN.
Python seems to be de facto language for different kinds of research. Machine Learning and AI is one where python is huge. The TensorFlow deep learning framework that Google just opensourced has a python api, for example. More info about it [here](http://tensorflow.org/get_started)
Sounds great, and I agree with your responses. The black box effect is real and significant :)
Tried that and it's still returning the whole list rather than the difference. Strange...
Print both lists. Something about the lines isn't matching up properly. Try using `.strip()` like so: temp3 = [x.strip() for x.strip() in new_files if x.strip() not in old_list]
Totally agree! For me it's a great tutorial because it outlines so many important application functions in a way that are accessible for a beginner but at the same time can be translated to so many different use cases. At the end you have everything you need to extend the base application -for example I'm hoping to replace the SMS function with email alerts using responsive HTML templates! Thanks for the tutorial!!!
&gt; Yet so much material online uses math examples. I hate it. We need other examples. How about something like this: [Automate The Boring Stuff](https://automatetheboringstuff.com/) Teaches how to use python to accomplish useful things that a non-math/comp-sci type person might still like to do.
Slightly more up-to-date notebook [here](http://nbviewer.ipython.org/gist/TomAugspurger/376c81cab634edd67aa4) Let me know if you have any questions.
I didn't realize that CSS was disabled until you trusted the notebook as well. I'm assuming that's a security thing as well?
&gt;In the future, please post this kind of questions in /r/learnpython. I considered it, but I ended up posting here as this is not about learning python but teaching it. I'll post there in the future, thanks for the tip. :-)
Well, [not since C99](https://en.wikipedia.org/wiki/Boolean_data_type#C.2C_C.2B.2B.2C_Objective-C.2C_AWK).
&gt; This isn't a subreddit about asking things. This is a subreddit about news and 3rd-party media about Python. If that's the case, then maybe this subreddit should be renamed "PythonNews." Don't squat on the "Python" name - which clearly will attract people who have questions about Python. "LearnPython" sounds like a subreddit about beginning Python programming - nothing wrong with that, but it doesn't describe many of the questions posted here. 
You could do `/usr/bin/python3.5 -m venv venv35` to create the virtual environment. This way, you don't need to change symlinks or install virtualenv (Unless you really need to use virtualenv, instead of the built in venv, of course)
Yeah, pretty much exactly what you described but in large scale. Basically we're gonna have a central server with some queuing algorithms, a simple FIFO at first and then tweak it to use greedy algorithms to determine priorities, but basically it just manages machines (hardware or VM's, irrelevant) that carry out large I/O simulations and there's clients that come to the server and request some number of these machines for jobs they need carried out for testing purposes. ZRPC here buys us the ability to write the server/client logic using RPC's (I wasn't a huge fan of using ZRPC, but that part is out of my control by this point) such that the client can just make an RPC to the server, the server acknowledges, processes the request and eventually returns back with the status of the queue to the requester and then eventually dispatches one (or however many) machines back to the client. From my basic (even ignorant) understanding of RabbitMQ, it's just a message queue system, so that part is abstracted away from us by ZeroRPC which uses ZMQ instead of RMQ.
A lot of "professional" courses i've taken through the years have literally 0 requirement for math. They're more about specific knowledge of libraries and platforms so that you can be immediately relevant for a given position, and the productivity pipeline is "try things until it works". The notion that you might have to recognize the mathematical nuance (even if it is relatively basic) involved with fizzbuzz and spit out an answer that works the first time speaks to a degree of critical thought and design-on-the-fly that just doesn't exist in a lot of courses.
I thought that was where I did ask the question.... whoops.
I wouldn't have seen any of the other comments if I hadn't expanded the hugely downvoted comment though.
&gt; Some of the best juniors-turned-senior I've met have just been curious people who like to write code well. This. It is very likely that your current skill with the alnguage will not fit the legacy code/ team structure etc. But as long as you are driven to craft beautiful code rather than hack out something that kinda works you will be an asset.
Hey thanks! I'm glad you enjoyed the post. That's actually a great question. I personally decided to use Redis for simplicity and ease of implementation, but I think something like RabbitMQ might be better as a persistent job queue. This page written by my buddy Matt Makai might have some helpful insight: http://www.fullstackpython.com/task-queues.html
I didn't know what fizzbuzz was, but if someone asked me to write a program that spits out strings based on mathematical conditions, it'd be done is a jiff.
While it's a moot point to argue strong typing in C, those are still macros for 1 and 0. Your compiled objects will not contain anything related to "booleans" ([bool erasure](https://en.wikipedia.org/wiki/Type_erasure)?)
Thanks for that article! So let me ask a question. What should I understand as a beginner? Do pointers and recursion fall under "things a beginner should understand" ? Funny he mentioned java, that's what I'm currently teaching myself. 
And IFTTT can be used to send the notification to pushbullet when the ISS is overhead (i had this working a couple of weeks ago) 
Using windows and anaconda, I wasn't able to install Redis or twilio. 
If you use anything other than `self`, chances are some code may actually break. One reason is that in Python 2.x, there is no reliable way to tell unbound methods of yet-to-be-defined class apart from global functions. Libraries implementing some OOP features (e.g. final methods) might thus rely on `self` name just for that, and you could break their decorators if you don't follow the convention.
Hi ! thanks for sharing my article :D
Release is scheduled for [November 20th](https://github.com/pydata/pandas/issues/11566). Discussion is [here](https://github.com/pydata/pandas/pull/10250)
can you program? can you learn how to do new types of programming you don't already know? yes? ok thats good enough to score an interview. 
Why the fuck would you do that? Twitter has a fairly easy to use API.
Using [TwitterAPI](https://github.com/geduldig/TwitterAPI). from TwitterAPI import TwitterAPI, TwitterRestPager api = TwitterAPI(your_consumer_key, your_consumer_secret, auth_type='oAuth2') iterator = TwitterRestPager(api, 'statuses/user_timeline', {'screen_name':'POTUS', 'count':200}).get_iterator(wait=3.5) count = 0 for item in iterator: if 'text' in item: count = count + 1 print(count, item['text'])
It depends on your area, but I tend to think of software languages as tools in the toolbox. You want to be competent in the ideas of software an not necessarily one language. Good companies will not ask you gotcha language questions. I would definitely learn pointers and recursion and also [design patterns](https://en.wikipedia.org/wiki/Design_Patterns). I would pick an open source project on github you respect and contribute some code to it. Also what is often overlooked is collecting requirements and project management. For collecting requirements I like domain specific software architectures / [use cases](http://www.amazon.com/Writing-Effective-Cases-Alistair-Cockburn/dp/0201702258). And I would recommend the book [mythical man month](http://www.amazon.com/Mythical-Man-Month-Software-Engineering-Anniversary/dp/0201835959/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1447189719&amp;sr=1-1&amp;keywords=mythical+man+month) for sage advice about software projects. 
 **Writing Effective Use Cases** |||| --:|:--|:-- Current|$38.75|Amazon (New) High|$46.15|Amazon (New) Low|$24.48|Amazon (New) |Average|$38.03|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/uVj9IT1.png) **The Mythical Man-Month: Essays on Software Engineering, Anniversary Ed...** |||| --:|:--|:-- Current|$27.15|Amazon (New) High|$31.92|Amazon (New) Low|$21.99|Amazon (New) |Average|$28.00|30 Day [Price History Chart and Sales Rank](http://i.imgur.com/TquEkgS.png) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index) 
I have only been learning for a few months, but isnt it http://pastebin.com/9TX4Nw0G was using this question: "Write a program that prints the numbers from 1 to 100. But for multiples of three print “Fizz” instead of the number and for the multiples of five print “Buzz”. For numbers which are multiples of both three and five print “FizzBuzz”." http://c2.com/cgi/wiki?FizzBuzzTest
You should be able to handle algorithms, though, because that's one of the problems you need to solve. You also need to handle systems understanding to code well.
Yep. We were concerned that CSS inside a notebook could hide a malicious code cell underneath an innocent looking one, tricking the user into executing something that they wouldn't if they saw it properly. It's an annoying thing to lose, though.
&gt; Learning Java forced me to really come to grips with classes and their purpose, (...) Careful. Java is actually a little special with how you use classes there, because they are the _only_ means of organization. Python, C, C++, and others have modules: if your code starts taking too much space in a single file, you can extract it into separate module. But in Java, you have to make another _class_. People who are decrying the various -er/-or classes in Java programs (Manager, Visitor, etc.) often do not understand this aspect of it. They think those classes were created because the architectural model of the program is just that bloated with distinct concepts. In reality, those classes are there only for structural reasons. Contrast this with Python etc., where you use classes for their semantics: instantiation, inheritance, dynamic dispatch, and so on. You shouldn't create one just to sequester some code that's overflowing its current structural boundaries. You add a class where it makes sense, and provides superior abstraction to loose functions. If anything, it's really Python or C++ -- languages with both classes and global functions -- that help to really understand where and when classes are necessary, not Java.
why would it be hard since you can easily run through Beautiful Soup + Regex to get what ya want...
Until the HTML changes…
&gt; for i in xrange(1, 101): &gt; sum = '' &gt; if i % == 0: &gt; sum += 'fizz' &gt; elif i % 5 == 0: &gt; sum += 'buzz' &gt; print sum or i This is why FizzBuzz is a useful tool. Programmers who are all ego and no rigor do things like this. And now your theoretical interview failure is saved for posterity.
Sites change their HTML all the time. Assuming that the DOM tree is going to be even slightly consistent over time is foolish. And last I checked, Twitter does a lot of client-side rendering, and BeautifulSoup does not implement a JS engine, does it?
&gt; i in xrange(1, 101): &gt; sum = '' &gt; if i % == 0: &gt; sum += 'fizz' &gt; elif i % 5 == 0: &gt; sum += 'buzz' &gt; print sum or i Eh, I was typing out a quick one. Not really a big deal to me that I was thinking faster than i typed but i'm sure no one else does that but me.
Since we are talking about speeding up tests, if you are lucky enough to be on django &gt;= 1.8, you can use manage.py test --keepdb with this, tests will start faster since db won't be recreated from scratch everytime
Python n00b here. I'm interested in more tutorials to begin to learn some cool and introductory Python code. This example is right up my alley/fits my learning style (and is damn interesting). Anybody have other recommendations similar to this one?
Could you post the line where you call read_excel and possibly the excel file in question (or a screenshot so we can get an idea of its structure?). It looks like Pandas is trying to interpret the first row of the excel sheet as column names but not finding enough data. Setting header=None in the call may fix this.
&gt; Pushbullet is a company, it is a they. From your own sentence, you say Pushbullet *is* a company, instead of Pushbullet *are* a company, and then you say "*it is* a they", rather than "*they are* a they," so I would say that either usage is probably acceptable, and, given that you yourself wrote about the company as if *it is* a singular item, one might argue that it's preferable to use "Pushbullet *has* an API"...IMHO, it does feel better, especially since it is easier to maintain consistency. ; )
Oh that's awesome! How are you liking Python so far? It's one of my favorite languages. In general I think [Full Stack Python](http://www.fullstackpython.com/) has a ton of awesome stuff. When it comes to other stuff I've written, you can check [this one](https://www.twilio.com/blog/2015/08/romram-hacking-building-an-sms-powered-game-genie-with-lua-and-python.html) out if you like old video games. It's another post on the Twilio blog about making an SMS powered Game Genie for Nintendo emulators.
We pose fleshed out hypotheticals and ask what the results of various operations are. If they are wrong in those cases, it implies the type of knowledge gaps that lead to hard to detect bugs. An easy example is asking a c++ candidate what happens when a reference to an object with a destructor goes out of scope. If you think the destructor is called, then you don't understand accessor methods or the implications of double deletion. The programmers who bone this question would make our particular codebase more buggy.
This looks like a great resource to help with a project I'm working on-- making a cron job that will check the weather forecast every 6 hours and send me an SMS if it's going to be below 32 degrees. If we don't leave a tap dripping our pipes freeze. I think I know the main chunks I need (download weather forecast from weather underground API, parse the .json file, send the text) but having an example of structure is very helpful.
Seconded for the anaconda recommendation. Any reason in particular you're trying to install that specific version of python? I believe 3.5 is the most up to date
Where would one start if you wanted to learn machine learning?
I actually posted it in both places and i am getting the help that I need over there. Thank you for offering to help, it is greatly appreciated
You know what, there may have been a moment of mental distress after a long day of C++ when I wrote "this" instead of self when writing Python. But I don't think it ever lasted long enough before I fixed it that anybody else ever saw it, so I'll deny it to the grave.
[Someone already made a recipe for it](https://ifttt.com/recipes/194044-if-the-iis-passes-over-a-specific-location-then-send-me-an-if-notification), using IFTTT notifications! Though it should be easy to convert into any other action on IFTTT.
I am a native speaker and I speak and write very well, thank you very much. Well, it's not redneck English, as others have pointed out. It's even in the Economist style guide, though with some flexibility... and it's a style/usage choice http://www.economist.com/style-guide/singular-or-plural But, on English stack exchange many consider your usage chiefly British, as I have said... http://english.stackexchange.com/questions/1338/are-collective-nouns-always-plural-or-are-certain-ones-singular Here's another bit of evidence for differences from a professor of linguistics at U Penn http://languagelog.ldc.upenn.edu/nll/?p=877 Kisses and hugs.
Thanks for the advice I'll be sure to download anaconda 
On a side note, check out /r/forhire for small Python programming gigs. I've picked up four or five in the past couple months, learned a lot, and it's been nice income. Helped motivate me to learn Python better, but it's also made me much more confident in my relative ability
&gt; Bonus question: What does a company mean when they say they want someone with experience in Unix/Windows at a system level? If they didn't add that, anyone who's *used a computer* would have experience with Unix/Windows. This means experience doing some systems programming in one of those environments.
Thanks for the answer. I'll go with smarter classes.
could this be modified to allow def expressions? As in sorted(list, lam(def sort(a, b): # stuff pass)) That's kind of the way Lua does it, and it's beautiful.
Please post an example of "smarter classes". Thanks
I bet that stackoverflow.com already has a dozen of questions like this. Try that site next time. If all you need is sorting a small text file alphabetically, the following code may suffice: with open('names.txt') as input_file: contents = list(input_file) print("".join(contents)) sort(contents) with open('names_sorted.txt', mode='w') as output_file: output_file.write("".join(contents)) 
I've seen it all the time. A trivial example: def foo(a, b, c, d): ...some code here... People call this function like: a = 1 b = 2 c = 3 d = 4 foo(a, b, c, d) then someone goes and changes foo to: def foo(b, c, d, a): # &lt;- 'a' changes place ...some code here... and then you have something between code that crashes very deep where the type/value is checked or you get super subtle bugs that are horrible to find. The fix is to call the function like: foo(a=a, b=b, c=c, d=d) then the change to foo is stable and any problems like removing one param and adding another will be a hard error at the call site and not much much deeper in the call chain. Using kwargs everywhere is what I call "well coupled". It's loosely coupled in all the good ways, but yet coupled enough to be robust.
I hope it may be useful for somebody else too, because my aesthetic preferences aren't that unique. Grammar fixes are welcome, either.
Thanks! We definitely need more extensions for Sphinx. Please note the the repo link in your docs is wrong: https://github.com/firegurafiku/contribsphinx-divparams
Here's an ugly but amusing one liner: print ["Fizz" if not x % 3 and x % 5 else "Buzz" if not x % 5 and x % 3 else "FizzBuzz" if not x % 15 else x for x in range(1,101)]
[PyQT is GPL (or commercial, if you buy the license)](https://riverbankcomputing.com/commercial/license-faq). You can distribute it freely and even sell your work, but you need to provide the source with it, always. If you want to pack your source in a non-source format (pyexe, something like that), you'd still need to provide the source. (The GPL doesn't mean it doesn't have costs, it just mean you can only charge for your work). [Matplotlib is BSD](http://matplotlib.org/users/license.html), which means you can do absolutely what you want with it. Just keep in mind that both licenses require that you mention that you're using their source and their source is copyright by them. BSD explicitly requires that you mention that somewhere. I'm not sure GPL also does, but I guess you should put it in the same place you mention the matplotlib license.
Well it's not intended to be used, of course. It was just an interesting hack especially because it shows one can implement almost a full blown macro system based on decorators and bytecode rewriting 
No. It can use only valid python syntax, because it works similarly to a macro system: def /decorator run time is compile time, the decorator expands bytecode matching an expression to the bytecode we need 
As for an IDE, if you're getting started, I've enjoyed PyCharm. It automatically shows you when you are out of PEP8 coding standards. But like he said, following coding standards does not mean you are writing efficient code. It more of less ensures your code is readable, which is a huge first step in becoming a good programmer. 
I've tried hand gestures but not with pacman see here : https://www.youtube.com/watch?v=QYiypuWZPU0 Tracking object is easier but yes I'll try implementing it with hand. I would be more awesome ! 
Thank you, fixed. Too many of "sphinxcontribs" for tooday.
Would this make sense to be merged into Sphinx (or maybe docutils) itself?
 if i % == 0: What ? 
the issue with this, is that even if you were to return the "same" class, `isinstance(get_me_a_class(), get_me_a_class().__class__)` would be `False`. So in general, with class factories, this is not the way to do it in python. 
Learn list comprehensions and generator expressions. lst = [] for i in range(10): lst.append(i**2) Versus lst = [i**2 for i in range(10)]
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
We are looking to build our team onsite, however we are open to remote opportunities as well. 
Like the Gfycat urls, only funnier
This got reported, I'm assuming by /u/ADC_TDC as harassment. Everything that was said by aj was pretty above board except for this: &gt; graduate highschool, grow up a little, and stop being such a crybaby and hypocrite. And that comment is at -1. Aj, I understand that you were frustrated at that point. This isn't a reprimand or anything, just an acknowledgment that it would have been better to have not said it. to ADC_TDC: Just because someone disagrees with you strongly, that doesn't mean that they are harassing you. In this case AJ is definitely not harassing you; if anything it is the other way around. AJ pointed out that the reason that we use Collections is because it's part of the standard library. To give you an example of what this is like, not using this and saying that it's someone else's code is like not using `print` and implementing your own way to have text show up on the screen, because `print` is someone else's code. This is a basic tool that you can (and should) add to your library of tools when using python.
&gt; list comprehensions I think "writing quality code" should be defined here. I know using list comprehension improve efficiency. On the other hand, using list comprehension is a very controversial topic about readability
1. Write tons of code 2. Work on a team, so you can have an opinion on other people's code. 3. Contribute code, and get your contributions reviewed.
omg this, str should absolutely not be iterable
we can work together. I already followed you in github. Let's see what happens :)
I agree, but only partially. There should be a method that returns an iterable rather than itself being that way. However, this would break so much code no one would ever consider it. Iterating over a mapping has caused issues before, too. But that's basically the only time I type check.
pd.read_excel(fname).plot()
&gt; using list comprehension is a very controversial topic about readability Is it really, in general? Used badly, I agree they could get messy (e.g. if nested), but often I find that they , if anything, actually improve readability since they are shorter.
You want to have a whole layer of GUI above the current OS that looks like Mac? Or do you want to just program a windows ap that looks like a Mac one? 
To create windows app that GUI look like Mac OS GUI. Windows OS UI is ugly. Mac OS UI is so awesome.
Checking the determinant is not ideal here. A better way is to use SVD (numpy.linalg.matrix_rank).
I looked up really quick and I found this: http://doc.qt.io/qt-5/gallery.html I'm not sure if that helps you, but on my previous experiences, windows won't have the widgets for osx and vice-versa, you might be able to use something that works for both and isn't as pretty. 
You're right. I was totally out of line there. I shouldn't have let him get to me like that.
I would argue that creating readable and consistent code is definitely an aspect of learning to write high quality code and not just for improving team productivity. It's way easier for me to source dive a library which uses a coding standard and start using it much more quickly.
I can't believe no one here has said testing. Besides writing a ton of code, being peer reviewed, using PEP-8(since this is a Python post), and using pylint which are all suggestions below, learning to do Test/Behavior Driven Development will make the biggest positive changes in your coding style. I've worked in a lot of places with big engineering firms and it drives me nuts how many people don't write tests and how many bugs come up in their work. If you're unit testing properly you need to code in a style that is simple, avoids side effects, and produces well structure code. Furthermore, you get unit tests that help you iterate much more quickly, and you can code with confidence knowing that you have test coverage to prevent any regressions on change.
Pair programming. I've been trying to find a programming partner for quite a while now...
Having not used any of these tools myself, this blog did not explain what they were to me. Are they pulgins for a text editor? Which one(s)? Are they command line tools? Does anyone really run 6 different command line tools on their code regularly? What sort of workflow is being recommended by this post? I'm not asking for answers here. My workflow works well for me. I'm just saying these are the questions this post left me with.
&gt; This isn't a reprimand or anything The other person was being pretty annoying. When you're trying to explain basic concepts and the other guy is saying "zomg harassment!" it's annoying.
That's also part of code review. Giving constructive feedback, forcing you to think about what is being expressed and how it could be expressed differently. Code review is less about the missing semi-colon, and more about "does this read well? Can someone other than me understand this?"
Check out [500 lines or less](https://github.com/aosabook/500lines)
I love when people ask questions about something in code review. I instantly know that I need to either refactor the code to some degree to make more sense, or at least add a comment that explains wtf is going on.
&gt; And writing a lot of code. and, if you can avoid boredom doing it, refactor your own code as you realize better ways to do things. Remember, code is meant to be read. If it takes a while to understand some code you are reading, ask * why is this hard to understand? * what changes would make it easier to understand? (perhaps all it needs is a good block comment with a paragraph or two)
Raymond Hettinger -- Beyond PEP8 -- Best practices for beautiful intelligible code - PyCon 2015 https://www.youtube.com/watch?v=wf-BqAjZb8M
Don't.
Write a lot of bad code first. Good judgement comes from experience. Experience comes from bad judgement.
Post your code to the [Code Review](http://codereview.stackexchange.com/tour) Stack Exchange site. Get feedback. Better yet, answer [other users' questions](http://codereview.stackexchange.com/questions/tagged/python). That forces you to puzzle out other programmers' bad code, so that you learn what to avoid in your own code, and in writing your answer, you'll need to figure out how to do it better. If you're lucky, you'll even get comments telling you how your answer could be improved. Repeat daily. I guarantee that you'll become a better programmer.
Peer review, polish based on feedback. Rinse, repeat.
I don't know how to code, well, im learning it very slowly (im over 40 so slower to learn), but i doubt you will find many coders doing high quality code simply because its not taught with basic learning books. If a easier way to do a piece of code is around, its not taught at a lower level like im learning. I'm just trying to say i think that if the code takes more space, but YOU understand it better that way, that is high quality code.
First, this is what I think of when I think of high quality code: 1. Code that deals with all possible input and failures; not just the 'ideal' cases. "Deals with" can simply mean that it does something predictable, like throw an exception. The worst code isn't code that crashes; it's code that does something that could fail, and then just presses on with the result without checking it. 2. Code that is written to be understood by other humans. It doesn't contain hidden dependencies, magic numbers, time-bombs, etc. Most of the time, this is WAY more important than efficiency, style or cleverness. Good code isn't difficult or risky to maintain. 3. If you're writing code for others to use, always remember that you're in a service role. It's your job to do the hard stuff once, so that your users can benefit from it many, many times afterward. Your documentation should say what the code does, and the code should do what the documentation says it does. Beyond that, I'd say reading code written by others is one of the best ways to pick up on techniques and coding styles that help in writing clearer, better code. Any programming book is likely to be helpful, but **the books that helped me the most** either focused on why you'd do something a certain way when there were several other alternatives that might seem equally correct (e.g. Scott Meyers "Effective C++"), or they focused on the philosophy and mindset aspect of coding (e.g. Steve Mcconnell "Code Complete" and Steve Maguire "Writing Solid Code"). Finally, write lots of code. The more you do, the more relevant the information above will seem, and the more ingrained the habits will become. If you're in an environment where you can have senior programmers review your code, all the better.
I think you misunderstood my comment. I should have explain my point. Beside I agree with all your points. Like I said, clean code is more a standardisation so everyone can read and understand the code (highly readable, consistent in style and design).
Good try, but unfortunately: &gt; "This page shows some of the widgets available in Qt when configured to use the "macintosh" style. **This style is only available on Mac OSX**, and provides native look'n'feel by integrating to the Mac OSX platform theme. Thus, the final appearance varies depending on the active Mac OSX theme." 
Go back and read your own crappy code, and think about why you don't like it. Then read good quality code
What I've found is that, generally, when you want fixture-type data in your database, what you really want is data in your code. It's not always possible to do this (i.e. ManyToMany fields require another model to play with), which is unfortunate, but I'd always recommend that as the first option to consider. 
Look at the source code for some libraries you use. Not sure how to guarantee you'll be looking at good code, but even analyzing mediocre or bad code still helps. I've been learning to write more idiomatic Clojure code by just looking at the core lib and other libraries I use myself.
any recommended sources available for free reading?
Write a bunch of code how you normally would. Identify the parts that aren't high quality. Rewrite those parts. Gain experience that in the future you can use. Practice makes perfect.
Welcome to the world of SOAP. :) I am guessing that wherever they refer to cventapi for calling a method, you would probably want to use `cventapi.service` the same way you did when calling Login. As for what types the other things are... the best thing I can suggest is that you use the Python console (or an iPython notebook) to explore a bit by manually making calls and inspecting the results with dir(), type(), etc. so you can figure out exactly how it works. At the moment, SUDS is pretty much as good as it gets for Python and SOAP. It's the only reasonably up to date library I know of that supports relatively modern SOAP... other stuff you may find like ZSI and SOAPpy is tremendously out of date and won't work with current APIs. The C# is unfortunately not that helpful in determining how SUDS will translate stuff into Python. At first glance it looks like they must ship a pre-built DLL and that's what it's calling, rather than using a service reference like you would usually use to consume an arbitrary SOAP endpoint from .NET.
I'm sorry I read too much into your comment, but happy that we agree. Thank you for clarifying. :-)
The best applications use native UI. MS Windows user won't be familiar with OS X interface and will find the application hard to use / bad. If you are so fascinated with OS X - stick to OS X ;)
It mostly depends on the complexity you wish. It could be a simple sequence of inputs-ifs-prints or you can go all the way: I've made a library ('Tale', [docs here](https://pythonhosted.org/tale/), [source here](https://github.com/irmen/Tale)) that supports running either single-player text based story games that you've written (Interactive Fiction) in a console window. But it can also be configured to run as a MUD server, a multi-user dungeon of sorts. It hosts a web-based interface for every player in that case, but commands and responses are all still text based. There's a link to an online demo in the docs, so you can see what it can do in a live environment. If you're mostly interested in just writing/programming the *story itself* (in Python), Tale could be of interest to you. If you're interesting in writing the whole thing including the story engine logic, Tale could still be of interest because you can study Tales own source code. If it's not perse about writing this in Python however, I agree with /u/notconstructive about using Inform instead. 
https://confluence.jetbrains.com/display/PYH/PyCharm+vs.+IntelliJ+IDEA+Python+plugin+FAQ
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Code Complete! Read it !
1. Start writing shit code. 1. Have people tell you why it's shit. 1. Write better code. 1. Get told it's better but still shit. 1. Repeat steps 3-4 1. ???? 1. Good code! 
Oh and use Pycharm. If you have a .edu email address you can get the pro version free. If not... just use the free version! (Or pay for it)
pip uninstall &lt;package&gt; Repeat until it fixes.
I've never minded code review, but I'm not and never will be a professional.
Forget the guidelines. Forget the books. Forget what anybody else says. Just think. THINK. What is this code supposed to do? How can you do that? Is there code already that would do that? Then, having come up with a few ways of how it could possibly do that, think of the ways that it's likely to need to change in the future. Will this design make those changes easier, or harder? Will changing the design to make those changes easier make it inefficient? Will the code produced by this design be testable? And all this is before you've written a single line. That's okay. Good, even. (Bad code breeds from a rush to code.) Then, start coding. But put some real thought into names. Forget capitalization conventions, just think about what the names mean, and how best to say it. You'd be surprised how much bad variable, constants and function names can decrease readability of your code. Yeah, I said readability. Good code is readable, and it's functionality can be easily discerned. (Even by management.) Sure, later you'll be producing recursive object-oriented state machines, or whatever. But if you've followed these simple rules, there's a good chance that your stuff won't suck. Remember Alan Shephard's prayer, and repeat it every once in a while: "Dear God, Please don't let me fuck up". That's what good code is, no fuck-ups. 
This is something I think a lot of people have a natural resistance to -- because it feels like you're wasting code. But they forget that anything created is never wasted. You wouldn't have been able to write that second draft without the first. It's very important to know when to delete and when to modify, and that knowledge only comes from doing both a lot and feeling out the problem space.
[Pyflakes](https://pypi.python.org/pypi/pyflakes) is tremendously helpful. I would like to recommend [flake8](https://pypi.python.org/pypi/flake8), which is a combination of [pep8](https://pypi.python.org/pypi/pep8) and pyflakes. The huge improvement over pyflakes is the addition of config files, which allow you to ignore certain errors, and a more streamlined usage (calling flake8 vs. calling pyflakes and pep8) Edit: I would also like to recommend [pep257](https://pypi.python.org/pypi/pep257) if you care about documentation styles.
This was a great talk! Definitely worth watching. 
Yes, Fim is a great tool, but I just wanted something much simpler.
Thanks, I figured out the syntax. But when I try to Retrieve something, i'm getting another error: WebFault: Server Raised Fault: "INVALID_CVENT_HEADER_VALUE" So i'm thinking I have to create a valid header? But I have no idea how to do that.. trying to research now..
Read this like this Increase your code quality using these tools. http://aboumrad.info/essential-python-tools-quality.html
I see. Based on how OP worded it, by guess is he won't like this (to me it looks mostly like Linux), but, yes, good to at least put it out there.
&gt; Anything created is never wasted I like that. Makes all the little projects/ideas/prototypes feel worthwhile. 
One thing you have to be careful with here (and your statement is pretty general, so don't take this as a criticism, but as an addition) -- almost always people go through a number of solutions or ideas before getting to the current one, and all you see when looking at code is the current state. It's really easy to wonder how someone could have made such terrible design decisions, but you don't know what convoluted change process occurred over the lifetime of the software.
Oh, it's interesting to know you knew it. Your tool looks so much simpler I installed it at once and didn't even think of it for Fim (java…). It takes a long time in a large repo with videos though so it isn't usuable in that case.
One thing that really bugs me about the default view is the line break in the "Return Type:" keyword. That alone is enough to try out your extension!
I use Pycharm and it seems to do most of this wrapped into one wonderful IDE. 
Afterwards, could you ask him who he stabbed when he was a kid?
Has anyone had any success using a button to navigate to a different web page with this?
Exactly! Many times I read some awful code, cursed the programmer, only to discover I was the author.
Buy some books my friend! - Fluent Python - High-Performance Python - Parallel Python - Learning Python Design patterns etc.
Unit test!!! First produce code that works, look at design patterns and implement the one best for your function. Make sure the design is reusable. Also don't re-invent the wheel ask around if there are libraries you can use or someone else already wrote what you need. Once you get that done write in all the error handling and take care of exceptions. Next unit test and make sure you cover anything users would throw at it including numbers, unicode, different strings ... etc. Stylize it with PEP8 and have someone look over it and make suggestions to changes. Then Unit test again. Last thing you may want to do is see if you want to speed it up by writing things with loops to cython or taking advantage of distributive/multi processing using dask, celery, or futures. Unit test again. 
You can use the new Link widget, an example is shown in the script 'widgets_overview_app.py . if you have problems, do not hesitate to ask.
How is that used from a button?
&gt; you're wasting code My code is so bad, the bits can't even be recycled. 
Taught me about the with keyword (I'm a rubyist)
I had not even thought of powershell. Good call on that. I know the user does not have admin privileges on the machine, so all read/write permissions should be jailed within their userprofile directory.
Can you show us the code you used to generate this? Because there's no way 4,000 lines in (or maybe just 400?) you didn't realize you were doing something massively wrong :p
Two possible solutions: mybutton = gui.Button(300,30,'stackoverflow') mybutton.attributes[mybutton.EVENT_ONCLICK] = "window.open('http://stackoverflow.com/','_blank');" Or: def on_button_pressed(self): webbrowser.open(base_address)
This is how I thought games were developed when I was a kid.
Okay I laughed.
He has it in the repo. https://github.com/asweigart/my_first_tic_tac_toe/blob/master/codegenerator/generate_ttt.py
when/where will it be published?
&gt; Read good quality code. I've got to disagree here. You can read amazing code, but unless you know why it was done that way you won't be doing anything other than copying a pattern that you saw once without knowing why. Reading other people's code is great, but if you want to do that to get better, you need to know why something was done the way it was done. You won't really grok that until you already know what they are doing and what other, lesser ways there are to do it. If you want to read other code, do it. But write out the algorithm first as you think it should be done at least so you understand what the code you read was trying to do. And knowing enough about coding guidelines to be able to understand when a choice is stylistic vs algorithm vs maintenance vs safety is of great benefit. I can pull up numerous code reviews from sister teams that look like great code, but when I explain the context and the constraints, that beautiful code falls apart like tissue paper.
Most likely Friday on the inventwithpython.com blog. It'll be posted to reddit.
No worries, keep up the good work!
You just stole my source code from my Tic Tac Toe game on the TI83! My lawyers will be in contact with your lawyers shortly. /s
hi /u/AlSweigart it's nice to see that you are learning, but your game ends when you select a move that is already used
well,... there is a better solution :-D 
In case you're not joking, you should know that OP is.
Become not a human.
now move on to chess
Care to elaborate?
Using good libraries is just as important i think. They will give a strong sense about how your code should look to the outside, and then you shoukd write your own code like good libraries with a sharp seperation of functionality. Other than that all good code comes down to the dry principle dont repeat yourself. And consistency in naming.
Entirely made with only one variable and prints. That's memory optimization !
People keep saying you get less lines of code with Python. I guess they were wrong. ;-)
Here you are : Beyond PEP 8 -- Best practices for beautiful intelligible code - Raymond Hettinger - PyCon Montreal 2015 - https://us.pycon.org/2015/schedule/presentation/416/ https://www.youtube.com/watch?v=wf-BqAjZb8M Also anything from Raymond H is worth watching (and his twitter account https://twitter.com/raymondh is worth following). By the way, all videos from https://github.com/s16h/py-must-watch are interesting and might help you write better code.
I like the way it [uses decorators to specify relations](http://orator-orm.com/docs/orm.html)
What are the chances! I made [my first Tic Tac Toe game](https://github.com/vaibhavsagar/tic-tac-toe) in Python too! It's a bit shorter than yours :).
You should post that to /r/shittyprogramming.
holy shit, lol
I use SimplyiFold for python folding in vim. https://github.com/tmhedberg/SimpylFold You may also want to take a look at this: https://realpython.com/blog/python/vim-and-python-a-match-made-in-heaven/
Thanks! After some time I figured out that I probably overwritten one of the modules that are crucial to Spyder to an uncompatible version, but I changed too much things in the process of "making it better" so I reinstalled the whole thing. But I'm learning! (the lesson being, try not to screw things up too bad) Thank you again, sorry for a dumb question.
The question is asking for comments on Cython's PyPy backend. This isn't relevant.
I'm at best moderate in either - as in, I've done toy projects in both but never needed them for a real problem - but my understanding was that they don't play well together at all. PyPy is completely magical, and does magic to make pure-python code run faster. Numpy support is improving, but not great yet. Cython is basically normal Python, except that you can write some parts in C and everything is a bit faster than the CPython interpreter (because it's all compiled!). Less magic, but better at interfacing with other non-magical libraries which is important in science.
Nice flair: http://imgur.com/8gMvtsn
When I was a kid I discovered MS Paint and Age of Empires at around the same time. Naturally I assumed that every possible screen had been hand-made (as a BMP, of course) and that the game just had to figure out which one to show at a given time.
I've flip-flopped on the (explicit) relative imports question, and I'm now back where I started with always using absolute imports. The proponents of using relative imports for package-internal imports tout the ability to easily rename the package or move/rename a subpackage as its main virtue. Sounds nice, and it follows a well-known pattern used in other contexts. However, it turns out you generally don't need to rename packages very often, and with the absolute import approach you can do a global search-and-replace to easily do the same ting. My guess is that OpenStack, like me, likes the ability to easily identify all imports of a certain submodule using any standard file search tool, like `grep -r`. This is useful when you make changes to a submodule, because you need to answer this question: *which other submodules uses this module I just altered?* 
Many things can still be improved in your code. For instance def is_even(value): return value % 2 == 0:
Lessons I learnt in quest of writing beautiful code: 1. Writing good code takes at least 1/3 extra effort, not just time-wise but mental-wise. 2. Not everybody cares about good code. 3. As a result, it's common for teams to have someone that produces huge quantities of liable code. It's easy to hate on these, but think again, they are more productive. 4. Therefore, beautiful code should be on the right balance between zealousness and productivity. My basic rules for good code: 1. Return early, instead of wrapping code around huge if / else blocks. 2. A 80 character limit will make good code and bad code stand out. 3. (Relevant to python): code should look compact, not like a bowl of spaghetti. 4. Bad code wrapped on 80 character lines will look like spaghetti. Good code on 80 character lines looks compact as a block. 
Did you not notice the LOC count at the top?
But that means I have to design a coding style that takes into account all the various corner cases that will inevitably come up. Or I can just slavishly adhere to these linters and get consistency across all my projects without any cognitive load.
TL;DR
I really hope this code was machine generated.
I really don't understand why `pip` should activate virtual environment, that too with `init`, which kinda indicates initiating some things for `pip`. regarding `pip save`, I wrote this small zsh function which does similar: # make `pip freeze` run everytime I do a pip install. pipi() { pip install $@ &amp;&amp; pip freeze &gt; requirements.txt } pipu() { pip uninstall $@ &amp;&amp; pip freeze &gt; requirements.txt } obviously its very basic and I don't use this anymore. `pip freeze` shows everything that was installed along with main dependency. So `requirements.txt` was getting unnecessarily big and I stopped using this method at all and rather started adding requirements manually.
chess.py - 4TB
Someone recommended Think Python: [How to Think like a Computer Scientist](http://www.greenteapress.com/thinkpython/). It was recently updated for Python 3. Completely free and goes over SO MUCH! It has many exercises throughout. You can also check out /r/dailyprogrammer. They have an Easy, Medium, and Hard problem/situation, and you can use whatever language you can to solve the problem or perform the task. You can try it out, and then go into the comments and there is probably someone who has posted their solution in Python.
Fastest way to learn is to break everything then try to fix it. Look into [virtual environments](https://virtualenv.readthedocs.org/en/latest/). They let you make a 'clean slate' to go crazy with withouth breaking your main environment. Not sure how it plays with Spyder though.
&gt; it becomes more important to keep information local - spam.eggs is clearly from the spam module, while eggs could be defined elsewhere in the file or a number of other places. I see where you're coming from, but I wouldn't deal in absolutes on this one. I've always taken the view that when I need the definition, I'll be searching through the local file for that symbol. In the case where `eggs` was imported from `spam` I'll find the import with clear directions to where it's from. Sure it's one extra step to know it's imported, but if that symbol is being used a lot I see it as butter to have the shorthand `eggs` rather than having to read `spam.eggs` a lot (or even `spam_spam_spam_spam.eggs`) Basically it all depends on what reads better. &gt;&gt; "[H304] Do not make relative imports": Are there issues with them? &gt; Not compatible with Python3, I think. Definitely supported on 3, but possible that the semantics have changed slightly. I'll need to investigate.
That's right. You actually have to think. I tried it once, and I didn't like it either. But then it got me: Thinking is kind of like googling, only way cooler! I haven't been able to stop since then! It's become an addiction for me! I have to think about everything! Think in the morning, think in the evening, sometimes I even think at work! It has truly transformed my life! Sorry, got carried away, there. Kidding aside, coding guides are designed with specific goals in mind. The idea is that a certain style of writing code will make you less prone to certain errors. But they act on syntax, not structure, so they can't actually prevent errors or ensure good code. The overall design of your code is still your own responsibility, and while coding guides can help, they are in no way central to the task. The goal is to structure the code so it makes the most sense possible. If this violates a coding guideline here and there, that's much better than sub-optimal code that *does* follow every guideline.
Hi @hoocoodanode you have plenty of use cases but the main case is : you have to tweet on a regular basis and you don't have workforce for it. The project was born from the French job board LinuxJobs.fr, tweeting job offers several time a day. Either I do it myself, which is not scalable and is a boring task, either I let db2twitter manages it :) db2twitter uses a user-defined template of a tweet, so you know what you are tweeting, the "risk" is pretty limited imho.
He writes code live. 10/10.
I understand that pip-init is usually used to generate a base of python package. Since init command is not available in default pip, I made use of it create virtualenv which basically initializes the project itself with isolated env. I don't think there is any issue having dependent packages in `requirements.txt`. Manually doing it might lead to human errors. I still use `pip freeze`. Moreover, JavaScript developers will understand this better, might find bit useful. At least for me this saves lots of my time.
Al Sweigart! Some high school students are monkeying around with your squirrel-katamari-damacy on raspberry pi 2s as we speak. You and the raspberry pi minecraft python guy both saved my Python curriculum-development life. Thank you.
I admire your patience sir. Could you try to reduce the no of lines as it might be difficult for a beginner to go through God knows how many line your code was .
very like 
Also, use a linter like pyflakes. Once a tool chastises you every time you do something wrong, you learn to do it right.
So like "// everything you ever learned was a lie" before a goto statement? I kid; your point is very good.
Why bother having the intermediate step of exporting the data to an excel sheet at all? Are the final resultant report templates you mention also excel sheets?
Output demonstration here. https://twitter.com/the_kindly_1/status/664858916858273792
[**@the\_kindly\_1**](https://twitter.com/the_kindly_1/) &gt; [2015-11-12 17:34 UTC](https://twitter.com/the_kindly_1/status/664858916858273792) &gt; https://github.com/thekindlyone/infinitweet @MikeHerman @Ilian\_Iliev \#python \#PythonSavesTheDay &gt;[[Attached pic]](http://pbs.twimg.com/media/CToNqA-UYAE4Oaa.png) [[Imgur rehost]](http://i.imgur.com/qeZAW7V.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Yes the templates are also excel sheets. We have to export because 1, our database is internet based (Netsuite), 2, we use these reports to create a snapshot of the data. We've tried to do real-time analysis but that became way too complicated. 
Well that would explain why its not working. Do you know of any other ways to do this? The pandas to_excel function erases everything as well, is there something I can put in my code to have it ignore the columns I use for my formulas? 
I'm also working on getting this packaged for Anaconda so that you can install via `conda install py_pushover` but I haven't been able to finish that yet. 
If you are on Windows, you can install the PyWin32 module and then use COM automation to put your data into your templates. 
I just spooged my pants. 
Ok thank you, I will give this a try. 
Maybe more like "// this is my last day so fuck you"
Works great! Needs the ability to sort columns. Also export functionality would be nice (could just feed it into the df.pivot() function and to_csv/excel)
Xlwings is the perfect tool. Edit: typo.
Would be cool to make this into a browser addon for more convenient usage.
why the ugly py_ prefix?
I'm not the library author 
 ➜ ~ which pip pip not found ➜ ~ which pip3 /usr/local/bin/pip3 Oddly enough, I was able to install PySlice without issue. I don't think I was able to when I posted this. A second problem is that I have some programs that give me errors under 3.5.
amazing thanks for this 
`pushover` was already used.
Yes! The book is a little old there, and Py3 is a much more consistent and pleasant language to learn. 
Heheh, it was. https://github.com/asweigart/my_first_tic_tac_toe/blob/master/codegenerator/generate_ttt.py
Well, if you remove all the blank lines, that cuts out 400 lines of code right off the bat...
https://github.com/juanpabloaj/pip-init
Okay thanks!
In my experience, any type of COM work you can do with VBA or VBScript you can also do with Python and PyWin32. I'm sure there are things I haven't encountered, but I'm currently doing some Word document generation this way, and the Python COM code is actually simpler than the VBA macro recorder code. Edit: clarified "anything"
* Yes, absolutely depends on context. I do this all the time, but then again I'm not working on anything quite that large. * Yep. Same functionality is available, but there's a few things that changed to be careful of IIRC (but I'm happily Py3-only, so...)
Well.... I ported my 50,000+ line production production project which was written pure Python 3 to Python 2 in less than one week for the purpose of using it with pypy. All tests passed and didn't encounter any difficulties. The whole process was very smooth and the vast majority of the work involved copy/pasting a file header to the top of every module consisting of `from __future__ import ...` and `__metaclass__ = type`. Other than that, the vast majority of the code stayed *exactly* the same. So overall, I wouldn't say it's *much* more consistent or pleasant. 
No, unless you want some python 3.5-specific feature. You're not losing anything by keeping that project on py2.
I made a slide presentation in VB with bitmaps for 9th grade history. I spent faaar too long typing in coordinates of hotspots.
Here's an example that demonstrates several things: creating and saving a new workbook, inserting data cell by cell, and copying and pasting between workbooks like the VBA code posted by @691175002: # ExcelTest.py import win32com.client import random class ExcelTest(object): TestDataName = "c:\\temp\\ExcelTestData.xlsx" TestSheetName = "Test Data" def __init__(self): "create excel object" self.xl = win32com.client.Dispatch("Excel.Application") self.xl.Visible = 1 self.xl.DisplayAlerts = False # suppress overwrite dialog def CopyTest(self): "create new file, fill with example data, save" print("creating workbook %s" % self.TestDataName) self.test_wb = self.xl.WorkBooks.Add() self.test_ws = self.test_wb.Sheets[0] self.test_ws.Name = self.TestSheetName self.test_ws.Cells(1, 1).Value = "Test Data" # column header row = 2 while row &lt;=11: num = random.random() * random.randint(10,100) self.test_ws.Cells(row, 1).Value = num row += 1 self.test_wb.SaveAs(self.TestDataName) "create new workbook, copy test values in" print("creating copy target workbook") self.copy_wb = self.xl.WorkBooks.Add() self.copy_ws = self.copy_wb.Sheets[0] self.copy_ws.Name = "Copy Target" self.test_ws.Range("A1:A11").Copy() self.copy_ws.Range("B1:B11").PasteSpecial() def main(): print("Excel data copying test") e = ExcelTest() e.CopyTest() main() ###
Honestly? If you're so new to python that you're reading LPTHW, just move to python 3.5. It's unlikely in the extreme that anything you'd do or try in the coming few months would be a problem. If you are developing on python 2, for the love of all that's holy use the __future__ imports, as they'll make the biggest changes for py3 work on py2... http://python-future.org/quickstart.html#if-you-are-writing-code-from-scratch That way you'll not go nuts as the print function will be a function, and the behaviours around integer division and strings will be right. When people are learning, 95% of the problems they come across in the switch from 2 to 3 these days are that print "foo" becomes print("foo") and most of the rest are that xrange() and izip() like iterator names become just range() / zip(), so you don't end up creating lists in memory where they're unnecessary. The old "but module X doesn't work" is also very unlikely to be true for a beginner anymore. See http://py3readiness.org/ Python3 makes a lot of things a lot more pleasant to work with, like super(), but you can have almost all of that back in python2 if you use __future__. For better or for worse, Zed Shaw loves python2 and hates python3. You may be the same, you may not, but if you use the tools given to you, you can write nice, idiomatic python that works on both and save yourself some brain cycles as you go.
I think that's generous.
My interpretation of this: * You write good, clean code. * It's easier to start in Python3 and backport if you need to, than upgrade * Modern Py2 involves a lot of stuff like `__future__` imports that you don't have to think about if you learn Py3.
Handling a million rows? No problem. Displaying a million rows? I believe it depends on your browser &amp; computer.
I'm new to working with APIs - is it common to require the user to register their own app to use the script? I understand that app credentials must be given in order to access the API, but wouldn't it make more sense to just provide users with a single set of credentials so that the script's usage can be monitored?
Try using `python -m pip &lt;search&gt;` or whatever your Python version is named. You can create an alias, function, or shell script to use this command more naturally.
How do I install this via Anaconda?
Here is a [gif](https://i.imgur.com/rJANurN.gif) of the app doing its thing.
That sounds great, I'll xpost it there too!
Not to mention awful for accessibility.
Using future is a good suggestion with the exception of unicode literals. Explicit is better than implicit and simply using u"the string" gets the same result and is python 3 and 2 compatible.
This revision now has no dependencies, as the core implementation is pure Python (it seems to work great with pypy, by the way). If you run the examples which attempt to visualize the results, they will tell you if you which optional dependencies you are missing for visualization. Documentation at [Read The Docs](http://neat-python.readthedocs.org) is slowly being updated and improved. Also, a wheel distribution is available on PyPI for this version in addition to the regular source distribution.
Needs more GOTOs...
I just used pip install without issue. 
Neat but will be unnecessary in the near future: http://recode.net/2015/09/29/twitter-plans-to-go-beyond-its-140-character-limit/
I don't have much experience in 3 but there usually is several ways to do stuff. (in varying levels of "correctness") Another way not already listed; could be do something like `greet= "Hello, " + userInput + "!" ` then something like `print("%s Wow, what a long name!") %greet` I guess you could also have something like `print("Hello, " + userInput + "! Wow, what a long name!")` You could even put the if-else statement in a function then call `print ("Hello, " + userInput + "! " +reply(userInput))` if you felt like it. though zengil's suggestion using end=' ' seems like it might be the better than the ways I listed.
what is your OS ?
Thank... Will update the instructions.
another option, is to check in /bin/pip3 and see what the version of pip the requirements are using. If its 1.x.x, you need to change it to 7.1.2, and it should work. Its what I did recently.
PyCharm uses Git: https://www.jetbrains.com/pycharm/help/using-git-integration.html. Bitbucket supports Git. It seems that all you really needed to do was install Git on Windows. Aside from the Bitbucket plugin, which isn't actually needed, none of what you described is any different from what I do with Github.
Oh really? I was under the assumption that there is always a special way when you're using Anaconda.
I remember thinking about how many millions of possible states Super Mario 64 could be in. Blew my mind that they were storing all those images and somehow linking them based on button presses.
&gt; blog.ytotech.com Thanks, that's really helpful! 
Aww, poor tweetsincommentsbot doesn't understand your fancy images!
just to avoid confusion: Brendan, you could also do print("Hello, " + userInput + "!", end="") the `.format()` mechanism zengil has employed is better form than sticking texts together by `+`, but is technically unrelated to your question.
Cython utilizes CPython's C api, pypy supports that api but it's kind of emulated and low performance compared to cpython. I haven't tried nuitka with pypy, guessing it won't work. But man, the posibility of cython pypy and nuitka together makes me shiver. Cython to have optimised c libraries, pypy to optimize pure python parts with stm and jit and nuitka to convert all of the project to binary. They probably won't work well together for next 10 years, I can only dream... 
Hello, Thanks a lot for this book, Reading it will comment once donne. Best of luck, 
Was initially based on text messages which had that character limit. This text feature was actually used for a while to get siri to tweet by sending it via text message.
Thanks! And yeah that makes sense, it's just the general construction of the program itself that I find difficult. I really thought I would be better at this ha. 
&gt; that Numpy was not included because it was not maintainable. "unmaintainable" does not appear on that page. Care to provide a source?
&gt; Do you believe it should be part of the stdlib? Heavens no. That's the death knell for any library. As soon as you become part of the standard library, everything is frozen forever. You can't innovate, refactor, deprecate, design new interfaces, etc. because once established, things in the standard library can never change due to backwards compatibility issues. No library author would ever want that.
[Levenshtein](https://pypi.python.org/pypi/python-Levenshtein/)
AAAAAAARRRRRRRRRGGGGGGHHHHHHHH /r/learnpython
There's more to Python's grammar than taking away braces and adding colons and indentation. I feel whoever came up with this ugly syntax never actually used Python and just superficially looked at how it's formatted.
You won't be able to update it from the source yourself, whenever you need to? Or it won't be updated because it will be part of the std lib?
How do you make it performant in pure python without using numpy? Or do you drop down to C for the matrix operations? 
The standard library has a slow release schedule, maintains a very high-degree of backwards compatibility, and tries to greatly limit external dependencies. Numpy has a much faster release schedule, has a bunch of large external dependencies, and although it has a high degree of backwards compatibility it is not as backwards-compatible as the standard library and some bigger backwards-compatibility breaks are being discussed. Really, there are few advantages to it being in the standard library, and a lot of major disadvantages. In fact the only major advantage I can see is having an `ndarray` literal, which although nice wouldn't justify limiting the freedom of the numpy developers. Especially considering how open Python core developers have been to implementing the language features numpy developers need (the buffer protocol, `@`, `[...]`, etc.).
If people are just going to do that, why put it in the standard library to begin with? Can you name any standard library module that is maintained both in the standard library tree and outside it (not counting backports from later python versions to earlier python versions)?
Using PyCharm with the already included Git plugin as well, working perfectly for my Bitbucket repo, no need for complicated setup. Edit: But thanks to OP for the tutorial, might be useful for some 
FWIW, `and` and its keyword brethren are *exactly* as expressive as their operator counterparts. That's because they mean the exact same thing, they just use different symbols.
in python you can even exclude the parenthesis like so. myCond = True if myCond: print "true" else: print "false" Which prints true. You can use parenthesis to group statements together, which is a lot like in math.
When did Fedora switch from YUM?
Why can’t you update things after a system release?
MMS? 
Python 3.4 bytecode is not compatible with Python 3.5, so we would have to rebuild every single package that depends on Python 3 (~1000) and then ~3% fail to build with Python 3.5 for various reasons. All in all it's just too much churn, we don't want to expose user to that. We're currently in the process of doing the above in [rawhide](https://fedoraproject.org/wiki/Releases/Rawhide), so if you don't mind being exposed to it, you can have Python 3.5 even as the system Python. :)
Travis Oliphant (original author of Numpy) has also said that the important thing is that a common *interface* is in core Python, so that C extensions and libraries can all agree on how to talk about memory and layout. This has somewhat been achieved with memoryviews and the buffer protocol. There is some new exploratory work going on right now to try to better integrate numpy's type system with the Python type system. That presents an interesting path forward for making Numpy fit with the core language better. Additionally, the "array runtime" part of the Scipy/Pydata stack is currently undergoing some innovation. Not only is Numpy getting some additional love, but also there are efforts underway like DyND and XRay which may be much more important for modern data handling and processing. So, as others in the thread have stated, it's better for it to not be coupled with Python language releases, and be able to innovate on its own.
Great work, Felix! Do you have any thoughts on how we might get an HTML window embedded so I can show interactive Bokeh plots?
You can still use yum on Fedora 23, it's just that dnf is better.
Please consider upgrading! :) Fedora 21 will be at end of life in about 3 weeks, at which point it won't be maintained any more.
cool ! I'll follow along, but come back give some news !
BitBucket is already in the plugin list, just install from there. 
I think you can get pretty far while only teaching people the basics of how a server works from the client side. For example, [R shiny](http://shiny.rstudio.com/gallery/) can create complex dashboards while largely sweeping the server internals under the rug.
I’m actually using 3.4 as an excuse not to upgrade, because it’s a pain on DigitalOcean. So, thanks, I guess? But why does that policy apply to smaller packages, too?
Except it hasn't worked correctly in years. The forked repo linked in OP does work correctly, mostly. Steps 2, 4-6 are therefore very useful. Though I prefer to make a blank repo on bitbucket and check it out to start a new project, instead of trying to start it directly from pycharm. Most of the rest of the walkthrough is decent for learning how to use the basics of git in pycharm.
oh, forgot about that. my institute still has RHEL 6 i think.
I didn't have a twitter account till a few months back because of the 140 chars limit seemed stupid. Then I made an account because of work. Few days back I tried to tweet this joke but couldn't because of the char limit. SMS lingo would have destroyed it. Hence this.
Hi, author here. Ultimately yes, someone will need to learn how to implement a proper server-this might be the eng/dev team rather than the data scientist. The need for this came from my data science coaching and conference speaking, the requirement to "ship a demo but I don't know servers (and don't want to know them)" is prevalent so I figured I'd try to help those folk. In these teams the recipients might have different languages (eg Ruby, Go, .net) so JSON+GETs are a common language
Right now the performance is pretty bad for large networks, and so far network evaluation is the bottleneck on any non-trivial problem. Usually the networks NEAT produces are fairly irregular ([like this](http://imgur.com/ZyxCRN4)) so I don't know how much work would be necessary (or if it's even worth the effort) to try to use a linear algebra package to speed it up. But certainly, dropping out to C for network evaluation is something I'll look at adding later on, once things have become more stable. *Edited to add*: If anybody has any requests for exporting network descriptions that can be used in an existing neural network library, please open an [issue for it](https://github.com/CodeReclaimers/neat-python/issues). In the meantime, JIT-enabled [pypy](http://pypy.org) 4.0.0 gives me about a 10x speedup on some problems that are limited by network evaluation, and it's possible to use [multiprocessing](https://docs.python.org/2/library/multiprocessing.html) to do evaluations in parallel ([one of the XOR examples](https://github.com/CodeReclaimers/neat-python/blob/master/examples/xor/xor2_parallel.py) shows a way to do it).
I'm not sure that's what "expressive" means. I think `and` is more expressive than `&amp;&amp;` because it is immediately clear what `and` means. &gt;Expressive: effectively conveying thought or feeling.
that's not how it's used in programming. https://en.wikipedia.org/wiki/Expressive_power_(computer_science)
One other note on performance: the original NEAT algorithm is often only used to generate functions which implicitly code for the actual neural network--see [HyperNEAT](http://eplex.cs.ucf.edu/hyperNEATpage/HyperNEAT.html) and similar extensions to NEAT. In those cases, the evaluation time of the NEAT networks will probably not be a bottleneck. However, if any neat-python users find that it's just too slow, I will do what I can to make it easy to offload the network evaluation to C.
I definitely think you're right--that in a sense, learning something like R shiny is trading a good chunk of time learning a more narrow domain (R shiny) instead of the general domain (web servers) it is simplifying. That said, I'm a lot more likely to build a one-shot dashboard in Shiny, because it's so simple for small projects!
What policy do you mean?
copy paste copy paste copy paste copy paste ........ so many much printing! print all the things!
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
Sweet! So the tabbed interface demo is cool with Guido? I might actually use IDLE again :P 
Hi there. You have posted a learning question to /r/python. These types of questions are far more suited to /r/learnpython, where users are actively interested in helping people to learn. Please resubmit it over there! Make sure to read their sidebar rules before posting, notably this one: "Posting homework assignments is not prohibited if you show that you tried to solve it yourself." Show them that you've tried to solve your problem and you can get all the help you need. Cheers &amp; best of luck!
So did [Raymond](https://www.youtube.com/watch?v=wf-BqAjZb8M) Absolutely loved the way Raymon delivered that talk. Too bad htey had to shut him down at the end, though. That was a complete privilege and I shall never use unnamed tuples again! 
Any learning question should go in /r/learnpython; the note about homework is just a warning that doesn't apply to you (it gets added to all of these notices, which are automated). Good luck!
&gt; Server don't care much about gnome/wayland sure sure. are people deploying RHEL on company desktops? (i mean apart from red hat :))
It would have made more sense to delay until the distro was ready for Python 3.5. One of the reasons I got away from Fedora was due the rapid release schedule that at times just seems to be belligerent. This is a perfect example, Python itself is a key component of the distro, and as such it pays to keep each Fedora release synced with the newest Python release. In a nut shell Fedora does more harm to itself as a distro with the rapid updates that seem to ignore the fact that Linux isn't the game here so much as it is a platform to deliver key technologies on. In this case Python is one of those key technologies and as such each release of Fedora needs to move forward with Python. In a nut shell better planning is in order as is understanding what your product is. If I wanted a distro that runs old crap I could simply install a Redhat Workstation version. 
There's some more info on how this works and how to contribute in [this blog post](http://synfo.github.io/2015/10/14/Python3-Porting-Database/). If want to ask anything, please let me know. :)
whenever you publish a project turn off the debugging. it could be a HUGE security risk if left turned on. I understand it is a beta site but still you should turn it off also I guess you know it but your site does not handle imputs too well. try to search for an empty string or the letter 'ó' for example. nice work anyways. keep going and finish it! be sure to notify me when it's done and I will check back on it :)
This has nothing to do with learning Python!!!
With a little reworking this worked perfectly! Thank you so much!
Dozens of people have been trying to submit PY3 patches but the repo manager doesn't want to take any of them. The major rub seems to be that 2.5 requires `except Exception, e` in lieu of `as`, so because of that "breaking change" for a branch that stopped getting updates ~4 years ago, no compatibility fixes. Coming out with a 1.99 (or whatever) that requires 2.6+ and tweaks the syntax/type differences would be fantastic, but the project manager squelches all discussion of such things while development of Fabric 2 happens behind closed doors.
Totally unrelated but... as a Spaniard, I can't help but laugh at the domain name!
Great, glad to hear it! Don't forget to go to MSDN to learn about all of the other things he object model can do. Excel https://msdn.microsoft.com/en-us/library/fp179694.aspx This kind of thing can be done for just about all of the other Office products too. Also, you can use the VBA Macro Recorder to capture how Excel does something, then copy (and often simplify) that code into Python.
https://github.com/Keeper-Security/commander
Cool, but aren't there JSON-RPC libraries that do pretty much the same thing with not much more code? The NumPy encoding is a plus though. Some suggestions: * decorator support * a simple web interface so people can call functions with a browser
https://github.com/timothycrosley/hug?
&gt; But why does that policy apply to smaller packages, too? It doesn't, self-contained packages can and do get updated during the life of a Fedora release.
Also because it breaks the plugin API and some commands. Giving it a new name makes the likelihood that people believe it is fully compatible when it's not a bit lower.
&gt; The closest I found was the conditional release of logs but I do not see how this could be adapted to my case. It could be adapted very, very simply for the naive case (exact matching). if msg == prev_msg: ++repeatCount else if repeatCount: emit repeatCount clear buffer repeatCount = 0 else: flush buffer What is there to miss?
http://www.atom.io
It's still a more appropriate place than here.
Maybe I'm just weird then:P
Vim?
Probably still need a bit of work to make it work at the specificity you want. Look at the instance methods of a Synset. from nltk.corpus import wordnet as wn from pprint import pprint as pp parents = lambda s: s.hypernyms() pizza = wn.synsets('pizza')[0] pp(pizza.tree(parents)) [Synset('pizza.n.01'), [Synset('dish.n.02'), [Synset('nutriment.n.01'), [Synset('food.n.01'), [Synset('substance.n.07'), [Synset('matter.n.03'), [Synset('physical_entity.n.01'), [Synset('entity.n.01')]]]]]]]]
No. You ship with what's ready, tested, and stable. If it isn't ready, and ypu can live with the old version, you don't update. If you want the latest and greatest at all times, go to a rolling release distro. 
packages go in the standard lib to die 
Ah sweet - that's probably what i'm looking for.
If you're going to develop a lot, it's worth learning a programmable editor: Emacs.Don't be frightened. It has a lot of menus to find one's way. A good config to start with is [emacs-prelude](https://github.com/bbatsov/prelude), it has a lot built in for python programming.
Yes, very much so. I'm not at liberty to disclose which company I work for, but suffice to say that rhel is very actively used
hmm, I think I've heard of this. Didn't know it was programmable though. I'll try it, thanks
and Kate: http://kate-editor.org/
Is one of my best series
Yes indeed, it's programmable by its own programming language, emacs-lisp (lisp is an old family of language). elisp is again a bit strange, but you don't need to understand it if you don't want. Emacs is also a sort of environment, more than just a text editor. We can use the file manager, open shells, surf the web and even read pdf, listen to music and manage your email. I like the interactive interface and that many things are just text, that I can manipulate with my everyday commands and shortcuts. I forgot my favorite emacs doc: http://wikemacs.org/wiki/Python
Atom is slow on my i7. I'd hate to see how slow it is on OP's machine.
Hi there - Looks like there's quire a bit wrong above, including some syntax that I don't recognize and some indentation which is wrong. Does that code definitely run? I'm not sure it does. Questions like this are usually suggested to be redirected to /r/learnpython. &gt;&gt; See sidebar &gt;&gt; People browsing there are actively looking to help, rather than just read up on the latest Python happenings. I happen to be bored tonight, so if you respond to my comment here, I'll help get you up and running (sorry for encouraging bad behavior /r/python!)
I've been using vim almost exclusively for nearly 20 years, though i've occasionally dabbled in other IDEs (yes i just called vim an IDE). I just started using Atom a couple of weeks ago and I quite like it for the most part. Well worth a look for something lightweight. It's very fast on my macbook.
[Curses](https://docs.python.org/2/howto/curses.html) gives you an ASCII canvas to create menus and anything else you want. A very educational and fun exercise would be to begin making some fun, silly, neat video game. Like Dwarf Fortress or whatnot. The benefit is that there is no clear "feature complete" end and there's plenty of things to learn how to do with core Python and core programming in general. When I did this, I worked on a simple game that let me plant plants and whatnot kind of like Harvest Moon. I eventually pulled out the very simple "things grow x % per minute" and replaced it with a system that incorporated some weather. Then I added seasons. Then I added a mole-stomping challenge as part of the game. As someone who sucks at graphics, it was nice to not have to worry about the graphics. I got to focus on architecture, data structure, separation of concerns, algorithms, etc. And the best part is that I had an application that grew over time without ever feeling like it was useless until it hit a certain threshold of "completeness". Furthermore, it felt really good that I had an application that kept growing and yet didn't become a spaghetti mess of code I didn't understand, because I was able to patiently evolve pieces one by one as I got better at coding. My next goal is to expose it with a REST API so I can keep up to date on how my little world is getting on without me while I'm at work. Maybe I'll learn to set up emailing for notifications.
Vim is only meant to be a text editor. Your development environment is bash (or zsh). I'll grant, to really make good use of vim you need a small handful of plugins, but not really that many. Give me vim with command-t (or ctrl+p), syntastic, and vim-python-pep8-indent and that covers everything I actually use daily. And vim-python-pep8-indent is really just a correction for python specific suboptimal default behavior. You can add another dozen or so plugins if you want; I use seven plugins myself, but that's just the result of compulsive fine-tuning and is totally unnecessary to make vim + bash a very effective development environment.
I can use npp, but I like things like autobackups and history reversing.
That's because you're just concatenating the names into one string. names = ('') I'm guess you're trying to create an empty tuple? However this won't do that. A quirk of the syntax is that you have to have a comma in the parentheses for it to be recognized as a tuple literal. Regardless, I think it's not what you really want. Initialize your names variable as a list, then append each name to it: names = [] And the two lines where you have: names += &amp;lt;whatever&gt; Replace them with: names.append(&amp;lt;whatever&gt;) Then you will return a list where each element is one full name. 
I'm using it on a macbook too. Nice and fast, silky smooth performance. Not sure what that other guy was on about.
Sublime or atom... 
You should probably be using git for backups and history reversing. Its much more complete and de facto standard for version control/distributing source code.
Home automation! Grab a z-stick, some switches, a motion detector, and go crazy.
Two things. 1) Use requests, it'll make your life much easier. 2) That's the shit version of OpenSSL that ships with OSX. brew install a newer one, or try it on a linux box.
[removed]
I believe /u/ucbEntilZha is referring to the local history functionality found in some IDEs. For example, PyCharm keeps track of file changes locally. I don't know the full range, but I can usually see small changes I made up to a day ago. This is all in addition to revision history in version control.
Sorry I'm using alien blue I can't see the side bar
Well it was a countdown from 6 to 1, an actual ordered top 6. I was surprised to, but it mentioned FlexJobs, which is an amazing resource not too many know about, so I trust the rest of the article.
Nice list. Thanks for sharing
As /u/davidj911 said, use `requests`, it's way more human friendly than `urllib2`. For your specific case, though, `Json_obj` is a file object (of sorts) as opposed to the data returned itself. You have to use the `read()` method to get the data. url = 'https://etherchain.org' json_obj = urllib2.urlopen(url) data = json.load(json_obj.read()) print data
I'd consider throwing in YouCompleteMe for slightly smarter completion, otherwise good list to start with.
Does it really matter what it's "meant" to be though ? Clearly many people use it how you described, making it a lightweight IDE. What other features do you really need (if you are just developing python)? 
Did you see the sidebar of this sub? Did you not find anything useful in the prior 30 instances of this question? https://www.reddit.com/r/Python/search?q=Books&amp;restrict_sr=on Also, did you know about /r/learn python?
I have the feeling you didn't follow the link. Here you go: What do I do now after [insert learning resource]? If what you've finished was a basic introductory tutorial then we'd recommend that you take a look at the books and videos located in the New to Programming section of the wiki. If you've finished one of those books then you're at the point where you can start choosing your own direction! There is a list of possible projects to work on available here. You can also take a look at thetrending repositories for Python on Github. The best thing to do if you're a budding programmer though is to find a problem you have, or a service you want to create and start breaking it down into small chunks that you can learn how to build piece by piece until you have a piece of fully working software. Google, StackOverflow and /r/learnpython will become your best friends when you do this. Don't be afraid to search for answers or ask technical questions on /r/learnpython or on the ##learnpython IRC channel. 
So you debug with pdb, separately?
Specifically for first timers. http://www.firsttimersonly.com/
A shell window with pydoc works?
Tried out Ninja the other day, worked well enough to give it a try. 
Not updating things after release. For example, Fedora 22 ships with python3-nikola v7.3.0 (2015-01-13), Fedora 23 has v7.6.4 (2015-08-22), while we are up to v7.7.3 (2015-10-30)…
seems like it's an OS based issue as opposed to a python one then
Yeah. It's a high quality aggregator. You pay for the convenience. 
the code in my edit above is exactly what I had, works fine for me, but I'm on windows so
I just found out tonight that dnf stands for 'dandified yum'. It seems like a BS, after-the-fact name.
2.7.6
&gt; Does anyone build Python (aside from OSX users)? Not that I know of. Why do Ruby people do it? &gt; For Python, it seems nobody builds their own interpreter and prefer distro modules over pip install. Not so sure about preferring dnf over pip though, I know plenty of people who like 'pip install --user' more :)
First of all I would install Linux to improve the performance. And Gnome Builder is a lightweight IDE that supports Python. It is coded in C and very easy on the resources. Newest version uses 224 MB of RAM and idles without even touching the CPU.