Have you made sure that you're accepting the PSExec license terms? http://stackoverflow.com/questions/5151034/psexec-gets-stuck-on-licence-prompt-when-running-non-interactively
1k lines of barely tested code? I'm sorry but this is not an alternative to puppet or chef, this is just some wrapper functions for fabric. It's not about management at all.
/r/circlejerk ?
Eeyup. It looks like a good and interesting presentation, judging from the slides. Unfortunately one property of good slides is that they're largely useless without the talk they support.
You can do all of that with function annotations, I'd think. They'd just be trivial functions if you were running in CPython. Casts can be done as functions (and probably should, I think) and the function annotated to state that this is a cast. Same with variable type declarations... the declaration *is* an annotated function. Apologies for not providing examples, I'm not familiar enough with mypy at the moment. I'm not so much arguing for or against it, but rather I want to understand the trade offs. From what I can tell, you're making the trade of giving up Python compatibility for a (subjectively) better syntax. That might be a worthwhile trade, but I think it's an expensive one. 
Yup. The 5×5 rule* is awesome, but only when seeing the slides while hearing the talk --- *max. 5 lines with max. 5 words each per slide
debugging helpers? As somebody who only recently began using python with the most common resources (LPTHW, Udacity...), how do I get into the more advanced features of the language?
That part about the duck typing is really cool, but is defining a new `__method__` considered acceptable? I could see arguments both ways. 
&gt; Who is actually attacking Python? HN, but the Python community shouldn't take it personally. A vocal minority of HN shits on anything that isn't the flavor of the month.
The eula pop-up is not the issue. I have exhaustively google searched this problem and ran through all of the work-arounds. (accepteula, piping to files, launching in seperate console windows). It is a known problem with PsExec hanging when trying to launch it from scripting environments such as python. This is why I want to remove psexec and replace it with something else.
It keeps noise out of auth.log
&gt; List comprehensions, when used judiciously I would be less conservative here. Yes it's possible for list comprehensions to be overused, but that's almost never done by a beginner. For people still acclimating to python, I would say, if a comprehension makes things shorter, it's probably also clearer. I would also mention dicts. Many programmers have learned to avoid dictionaries because they're expensive in some languages. These programmers will probably be hesitant to use a pythonic amount of dicts.
Which one would be easier to learn? Junior Computer Science major here. Never done MVC programming before... 
why not just let people have some fun?
neat - it would be cool to have something more live through JS
resource description framework. A standard for describing Things on the web. You should read into it and see if there is an open data coordinator at your educational establishment
Project Euler
Project Euler is a set of math problems. It doesn't encourage or benefit from a deeper understanding of Python.
I use Python every day and I have some pretty strong negative feelings about it. I do feel like most other choices are worse, but that doesn't mean I think Python is as good as things _could_ be. :)
it would be cool if I could point it at a public git repo. Eg github
Django, it has the bigger community and clearer documentation.
also, inline commenting on errors and warnings :D
I like enumerate() man... I like it
Better watch you don't fall into this trap: http://ucouldfinish.com/
I see your point. I think my perspective is colored by working with Protocol Buffers, where you can add new fields to messages for newer versions of the protocol and not break old consumers. Typically when I change a tuple return value from function foo, I'm adding a new element, extending the protocol, etc. I want old calling code to continue to work while new/updated calling code should be able to take advantage of the new data in the tuple structure. There's nothing in the semantics of tuples though that prevents me from putting my new item at the head of the structure, which would likely break the "defensive" code snippet I wrote above in subtle ways. *EDIT: But I think doing this would be bad form.* Thanks for encouraging me to think about it a bit more. 
What's the university? Are you in the computer science department?
Notre Dame. Yes, I'm a Computer Science student. Our Computer Science Department has an Open Data Coordinator for their department and labs, but information with classes and all of that is handled by the Office of Information and Technology, and it's pretty locked down.
sorry, misunderstood. You could still talk to your ODC about how to use RDF and the best vocabularies to use.
If you feel bad that Python is being attacked, try being a Java developer! 
I also prefer it without the parenthesis, but I could see a beginner reading a, b = b, a as a, (b = b), a
I'm not preventing anyone from having fun, but if you are actually working in Python and don't already know this then you will be massively more productive not to believe that you have to paste your code into a web service over and over. I find that many people are actually NOT aware of the pep8 command line utility, which is an excellent assist
In that case I would rather show the first way and discuss as an aside the meaning.
It can be tricky if you don't know where to look. I learned mostly by digging around in the [Python Docs](http://docs.python.org/reference/datamodel.html), and reading/watching tutorials on "Advanced Python" or "Python Black Magic". Hopefully that gives you some useful starting points. Googling for these should quickly lead to information on lesser-known language features like descriptors, decorators, generators, metaclasses, and much more.
You may be thinking of [Code Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html).
dictionary comprehensions make me happy
Yeah, they're even better for this use case.
Ah, okay. I'll ask him and see what he has to say about it.
&gt; Do you seriously think...? No, I prefer to use software local to my machine, **but that's not the only way people do things.** And, not that I have used any, I imagine web-based IDE's don't have a lot of support for things like command-line utils, so a web-based interface for it might be useful to them. While having to copy-paste as part of it isn't ideal, at least there is an option. Could someone just as easily perform copy-paste and a few other trivial operations to run pep8 locally? Almost certainly! But the point isn't possibility, it's preference. &gt; A lot of people don't even know these tools... I already told you that I understand your point. I do not disagree with you about the importance of knowing that such a tool is not exclusively web-based. I only disagree with the way you attempted to get your point across; it lacked the context that you provided in your reply, even if it was an honest question (as opposed to a smart remark). I have explained to you twice now "why not," but you haven't seemed to accept the idea that someone works differently than you do? &gt; Your insults are pointless I apologize if you feel insulted by what I have to say; it is not my intention to make any statement about you as a person. I meant to be constructive, rather, in showing how you could have been more clear. There is no subjectivity about the lack of context around your initial statement, and there is certainly no more around the my repeated statements of agreement with you. Finally, it is abundantly plain that there exist a number of web-based IDEs and at least reasonable to think that people preferring to use a web-based IDE might also prefer a web-based pep8 (if only for an aversion to command-line tools). 
If you are looking to do something pretty simple, I would go the flask route. Django is nice in many ways, but flask is much more minimal and nice to use, as well. Just my opinion...
I find many of his "idiomatic" examples to be less easy to read.
:D good one
Yeah. Coroutines are one of the things I have the most negative feelings about. :)
Good thing fall break is soon... I'll have something to do! 
&gt; this is just some wrapper functions for fabric. It's not about management at all. That's why I like it.
I highly recommend you to use and *read* [bottle][]. It’s a single module (which means: one file) web microframework. Why do I recommend it over other web frameworks even though I’m a big fan of Flask and Werkzeug, not bottle? It’s short. The most important thing of code readability is its size. You can *read* it, and so you can completely *understand* it soon. It has no dependencies other than standard libraries. You don’t need to checkout multiple source trees. Follow my suggestion: 1. Read the manual of bottle. [about an hour] 2. Try something following its tutorial. [about an hour] 3. Read bottle’s code using your favorite editor. [about half day, maybe] 4. Read [PEP 333][] to clearly understand it. [about an hour] 5. Dive into a web framework what you want to use e.g. Django, Pyramid, Flask. [bottle]: http://bottlepy.org/ [PEP 333]: http://www.python.org/dev/peps/pep-0333/
Although I would say that choosing between the two versions is hardly clear, another argument for the former would be that it's "purer and therefore" more parallizable. It's harder to tell if you can turn a for loop into a parallel process (by either 'compiler' or human). 
Flask is by hands down much easier to get something up and running sooner with less code. 
I code in Python often enough, but apparently I haven't been keeping up. The "with" and "enumerate" was news to me. Nice stuff!
Too bad they're limited to 2.7+ :(
Thanks for this. I will review Execnet and see how it could fit my needs. I was hoping for a solution that wouldn't involve deploying additional software across all the servers as essentially that is the problem I am trying to solve. 
Probably would have been better to do it in HTML: http://imakewebthings.com/deck.js/ What you did is pretty cool though, if a bit over-the-top ;)
While {i:chr(i) for i in range(20)} is very nice. dict((i,chr(i)) for i in range(20)) is not a bad substitute. 
I cant believe I used to do if name=='tom' or name=='harry'. One good practice I do a lot is to sit down woth code that I know works well and just look at it and figure out ways to male it more readable, efficient, and possible cryptic errors.
&gt; if name in ('Tom', 'Dick', 'Harry'): &gt; is_generic_name = True It should be `{'Tom', 'Dick', 'Harry'}`. Recent Pythons automatically make that into an O(1) frozenset look up. Here's the timing on Python 3.3: &gt;&gt;&gt; setup="""import random ... names = "Tom Dick Harry Smith Jones Peterson".split() ... items = [random.choice(names) for i in range(100)]""" &gt;&gt;&gt; case1="""count = 0 ... for item in items: ... if item in {"Tom", "Dick", "Harry"}: ... count += 1""" &gt;&gt;&gt; &gt;&gt;&gt; case2="""count = 0 ... for item in items: ... if item in ("Tom", "Dick", "Harry"): ... count += 1""" &gt;&gt;&gt; &gt;&gt;&gt; timeit.timeit(case1, setup) 7.745268601000134 &gt;&gt;&gt; timeit.timeit(case2, setup) 14.516629380999802
If you are going to writing a lot of Python you should learn to read this stuff. Some of it, such as list comprehensions seem strange at first if you're coming from C or Java (not so strange if you're coming from LISP) but it is important to be able to read it. Over time if others are going to see or run your code it becomes important for you to be able to write it.
HN is full of hipsters who are desperate to find a way to make money from their no one ever cares startups.
Actually using map was inappropriate anyway because your intention was not to create a new collection but rather to produce a side effect based on an existing collection, so using map is if nothing else wasteful because it actually constructs a new collection of None's that is immediately thrown away. Of course, this assumes that you are using Python 2.X. In Python 3.X the situation is even worse --- the code won't work at *all* because map does not create the new collection right away but instead returns a map object that you have to force in some way to get the desired side effects. That is: &gt;&gt;&gt; map(print,range(3)) &lt;map object at 0x10a3b5a10&gt; &gt;&gt;&gt; list(map(print,range(3))) 0 1 2 [None, None, None] &gt;&gt;&gt; for x in map(print,range(3)): ... print(x) ... 0 None 1 None 2 None
Probably not, I'm just parroting the claims of parallel/concurrent processing improving overall performance where IO-bound resources are consumed. Each `send_mail` call might be fire-and-forget, or the function call may hold until the email finishes entering the mail queue. In the former there is no noticeable difference, however in the latter it will go from O(n) to far less.
That's been there for a long time. I think maybe as long as Python has had unpacking (ie: pretty much forever). *However*, it was actually removed from 3.x. If I remember correctly the argument for removing it was that hardly anyone ever used it, and it added significant complexity to the implementation (cpython).
Well, I think it's an odd example because send_mail has obvious side effects.
I dunno. I prefer to put parentheses around all tuples.
It doesn't really make sense to me either, but that's what timeit is for. My best guess is that tuple making is so slow that hashing looks fast. :-)
Why doesn't this code raise complaints? class test_me(): def __init__(self, test): self.TestMe = test
Python is aging &amp; it's become a mature, established language. There are large, established codebases that new developers are being thrust in to maintain - this, in itself, can create a lot of negative feelings. Perl's past this point. Ruby's getting there. Python 3.x just isn't gaining traction - many key libraries are *still* not ready for production. On top of all that, we've got competition from newer, flashier languages - between the rise of functional languages (Haskell, Clojure, Scala, F#), the increasing dynamism of the big enterprise languages (Java &amp; C#) and the new breed of flexible systems languages (Go, Rust, etc), it's becoming harder for new programmers to get excited about &amp; justify choosing Python (as opposed to 10-15yr ago, when I learned it, in comparison to Perl, VB, C, C++ and Java 1.2, it really stood out). Is it really hate? Not really - it's just controversy hungry bloggers desperate for hits &amp; forum trolls that feel like pushing an old man's buttons for the lulz. The language has finally reached the stage where managers at large companies will allow projects to be written in it. Python is stronger than ever, it's just no longer young and sexy - the cool kids don't want to be evangelizing the same tech that 40yo guys have made their careers on.
The inbuilt `csv` module has a flag that can pull column headings from the first row of a CSV, and then use that to make a dictionary when you read a row. *edit:* Also, isn't 'csv' an acronym that is "in common use"?
If you click to error or warning in table then browser go to the wrong line.
It's not stupidity, its arrogance. But its also an important life lesson - some people do not want to know that their million-dollar investment produced a steaming pile of crap. Its not easy (particularly in IT) to squeeze that kind of money out of the spiteful beancounters, and when your project team is shown up by an undergrad in a few weeks... 
And you get a discussion like this started, where most of us learn something new ... (see earthboundkid on frozensets).
So what is the one -- and preferably only one -- obvious way to do 2-dimensional arrays/matrices in Python? Or 3-d or more? This is trivial in many other languages, even VBA, but I can't find a single consistent straight-forward way of handling this in Python.
Numpy
`''.join(arbitrary_list)` always ends up biting me because it expects everything in the list to be a `str`, but doesn't attempt (afaik?) to convert it. So `python -c "','.join(range(10))"` fails with: TypeError: sequence item 0: expected string, int found Is there a nice solution to this that doesn't require `"".join(map(str, list))`? 
[I made them using Vim :-)](http://www.reddit.com/r/Python/comments/10y7od/pycon_uk_2012_create_beautiful_commandline/c6hzaqq)
I'm too lazy for that
i run into that a lot and do the map(str, list) dance.
Python 3 switches just about everything to be an iterator if practical. `filter`, for example. Most of it gets caught by `2to3` though. 
There ought to be a distinction between "idiomatic python" and "here's a shorter and more efficient way of writing this code in Python". If there's a shorter and more efficient way of writing a piece of code, that way ought to be adopted. It's not a matter of "Pythonic", it's a matter of programming, of problem solving. It is about communication effectively with the computers, and has not much to do with communication with other programmers. On the other hand, an idiom refers to some practice that might not be necessarily more efficient, or more correct, but it is adopted because most people practicing that language are using it conventionally. You use idioms so that what you express is easily understandable by other people. So, idioms are meant to facilitate communications with other programmers. 
Be sure to let you know. This is the first version. I received a lot of feedback and ideas. And now I will do it.
2-D arrays/matrices are used for many many things, so it's not such a big deal that there are different ways to do it, just like there are several ways to store a 1-D array (list, tuple, array...) If all you're going to be doing is lookup, then use a dict indexed off tuples. (This is the equivalent of those trivial methods in other languages.) If you need to do complicated slicing, reshaping, or matrix operations like multiplication, use numpy. (The trivial methods in other languages are generally not capable of this.)
For this kind of project you would be fine with anything really. I suggest pyramid or flask. Here is a tutorial i've wrote for pyramid: http://pyramid-blogr.readthedocs.org/en/latest/index.html Read this and you should have a general impression of how it works.
Having database access included lowers the learning curve IMHO. You got a point about settings tho.
If people want performance they sure as hell aren't going to be using Python!
Another one I just learned from a [link](http://www.jeffknupp.com/blog/2012/10/04/writing-idiomatic-python/) on the /r/python front is obj_from_dict = {}.get('value', default_value) # Returns value or default_value if not in there Really cool stuff! 
Absolute +1 on bottle.py. I've implemented several internal production services with it. Bottle hits the 80/20 sweet spot having almost everything you *need* to be productive. The docs are quite good, and as hongminhee states, the code is readable.
Python is also a major environment for scientific computing. This community, though, has invested heavily in CPython extensions, which PyPy can't or won't support well. So while I'm interested in what PyPy is doing, I don't see myself using it any time soon.
They now mostly have compatibility: https://bitbucket.org/pypy/compatibility/wiki/Home Unfortunately, performance isn't as good as they need to emulate a refcounting GC for compatibility.
Here is a loop that is building some lists from another list: for r in rows: if len(rows[r])==1: essentials.append(rows[r][0]) delete += cols[rows[r][0]] remove.append(rows[r][0]) I'm not sure why I used += with `delete`, but it is also a list. `rows` and `cols` are both dictionaries with lists as values.
They should have done this forever ago. 
Is it an another gospel song of PyPy? PyPy does JIT so is memory hungry. This means it’s not so suitable for mobile app programming. Anyway if PyPy team revives JVM backend soon it might be able to create Android apps. (See recent approaches of Xamarin.)
I know it isn't a popular opinion, but I still dislike how everyone gives so much of a crap if python has good concurrency. It is a dynamic high level highly readable and high productivity language. It isn't meant for high performance computing, and there are half a dozen ways to write faster code before you get to the point where you are using threads and mutexes that are much more elegant and less error prone. Static typing is one. Boxing by itself takes an order of magnitude off language performance and that is why Python is often 5 - 10x slower than static languages. If you need something faster, try rewriting it in Java or Haskell or something static first before taking on the tremendous headache of parallelism. I'd say it is *easier* to convert a program using the same paradigm from dynamic to static than it is to try to parallelize a program in either domain. Especially in something complex. Parallelism is *hard*. Especially load balancing low memory footprint task parallelism to maximize hardware utilization. At least to me, but I'm kind of dumb anyway.
they already rejected path.py once before. 
&gt; A path can be joined with another using the __getitem__ operator: Whaaat. That makes roughly zero sense. It makes it seem like the path you're joining is already a part of original path (which may or may not be true). Yuck. Overloading the + operator would make sense to me here, but alas.
Once you come to terms with it, it's a fairly nice looking syntax: &gt;&gt;&gt; p = Path('/') &gt;&gt;&gt; p['Users', 'Shared', 'Library'] PosixPath('/Users/Shared/Library')
I'm still unclear how you'd change `PosixPath('/Users/Shared/Library')` to `PosixPath('/Users/Shared/Backup_Library')`.
We use Python in games for many things on the backend. It's part of Autodesk Maya now, which is one of the principal bits of software for asset creation. I've been using it all day every day for 6 years now, and I've used it to create a rather extensive and powerful library and pipeline for animation and rigging. We are, I admit, a bit of a niche industry as compared with the massive, international industries of web design. This is why whenever I look up questions about Python, all of the answers are about web frameworks and such. I have nothing to do with any of that world, but I know a lot about it now from years of wading through it while learning about Python and its powers and idiosyncrasies.
You can say `p.join('Users', 'Shared', 'Library')`.
Thanks, I missed that part. I don't see why the other syntax is necessary at all given that. 
I agree. To me, Flask kind of feels like a subset of Python that allows easy web programming, plus a few utility functions and bells and whistles. Django on the other hand is a massive beast that makes things much easier if you need to make a big, standard type site (a forum, a web store, something that requires registration and login and profiles and comments and a full administration interface). They're both really good frameworks, they just have different purposes. I tend to prefer Flask in general, though that's probably because of the type of web apps I make.
Looks pretty cool, but the author needs to rethink his licensing. The freemium business model isn't all that compatible with the GPLv3. On a related tangent, I strongly dislike the recent trend to co-op the rise of the open source movement and warp it into the crippleware business model of days gone by. I sure as shit wouldn't contribute code back to such a project.
Are you not familiar with Chef Solo? I'm more of a Puppet guy and I use it all of the time to set up dev VMs in Vagrant without a Puppet master server. The development manifests are stored in the source tree of the app.
Could you elaborate please? I'm still learning python and don't know what getters and setters are. 
Allot of OO people have this fetish for never accessing member variables of an object directly. That would "break encapsulation". The idea is, you should treat member variables as private to that object, and only manipulate them through methods on the object. This way, you can ensure you know exactly how these variables are manipulated, because all manipulations go through the interface of an object's methods. So, say I've got this guy: class OnlyGets: def __init__(self, a, b): self.a = a self.b = b def get_a(self): return self.a def get_b(self): return self.b Now if I follow the convention of only interacting with `OnlyGets` through methods, I'm assured that I'll never modify `self.a` or `self.b`. What about this guy though: class GetsAndSets(OnlyGets): def set_a(self, a): self.a = a def set_b(self, b): self.b = b Now we're just participating in a lot of ceremony for nothing. We've lost sight of the original intent, which was to impose an [Abstract Data Type](http://en.wikipedia.org/wiki/Abstract_data_type) (not to be confused with [Algerbaic Data Types](http://en.wikipedia.org/wiki/Algebraic_data_type)). 
I agree. And I agree, because when you read the proposal, its basically all about obfuscating the fact the Microsoft Windows is not POSIX compliant and therefore has to have its own unique way of handling filesystem paths that's totally different to how standards specify to do so (and works perfectly fine on EVERY OTHER SYSTEM) Please, no hacks around Microsoft Windows in the stdlib! Anyone still using that crap deserves all the pain they can get. 
Because it's a solution looking for a problem?
What a terrible opinion. Python is all about abstracting the differences out of the various operating systems so you can write clean code which is cross-platform. The API for this is terribad but the reasoning is spot-on.
Where does OSX sit in this? Every OSX install I've seen is defaulted to case insensitive.
I updated all the torrents/information - I missed a talk last night: https://gist.github.com/3848238
There is also the option of designing a dynamic language with the JVM in mind from the beginning, like Clojure. It's a very nice language and it interoperates with the rest of the JVM naturally.
That’s Java standards for you.
Have you read the howto on docs.python.org? That along with the library doc was the only thing i needed when i started with curses. http://docs.python.org/howto/curses.html http://docs.python.org/library/curses.html
&gt; The web is rapidly becoming the only platform. And Javascript right now is the assembly language of that platform. And it is a giant turd of stupid. I know it is insignificant, but how can you call a language where objects are declared at functions anything but a poorly thought out festering wound on the web platform. You're right. Javascript, as a language, is crap. However, the biggest advantage it has over every other language is the simple fact that relatively feature complete implementations of it are available across all of the major browser vendors. You simply cannot ignore that simple fact. This kind of of feature synchronization is simply epic. &gt; Yes, arbitrary scripting languages would be hard to implement in a browser, and it would be bad UX to have users finding pages that said "can't find interpreter for mime type text/rbuy or text/perl or text/python" but as someone who likes the Unix philosophy the overtly tight coupling of a dynamic language interpreter with a markup language parser on top of a plugin, file browsing, image rendering, and networked platform is a ridiculous failure to modularize parts of a complex system into smaller, more manageable, more focused applications that interfaced together cleanly to give a full modular experience. This kind of integration is the stuff that end users crave. Modularity is fantastic for developers, but users don't think like that. When you develop software for the masses, the Unix philosophy flies out the window. The web browser wasn't designed for you. The web browser was designed for the 14 year old girl checking her facebook account. &gt; I use python instead of shell script because it is so much more beautiful. It is a scripting language. It has a target purpose, and trying to ignore the inherent limitations of being a dynamic clean and elegant language means it is doomed to fail anywhere else it tries to go. It is amazing where it works, be it for doing math, scientific computing, scripting, and web backend. It might one day also take a spot on client side web scripting, because it would fill that niche really well too. I also like it as an app language when it uses an api to some lower level graphics library like gtk, Ubuntu apps are a pleasure to read and write, for example. If I want a GUI interface on parted (aka gparted) or libtorrent (aka deluge) Python is the perfect choice to give a fast, clean interface to nicely abstract low level libraries and command line utilities. But it isn't a replacement for an interpreted language for performant applications that need horsepower, or binaries for compute intensive tasks. And it can't be, by the nature of its design. It already made the tradeoffs to make it the best scripting language, in my book, there is. I do not disagree with this.
Here, hear. There's also the fact that well-written C modules can take the hard parts to task in multiple threads, and Python's own threading interface can handle waiting on the results while the rest of your Python program chugs along. I honestly think that writing C modules that release the GIL is the only feasible solution to performance woes in Python. I consider the Python C API a feature of the language, and an important one that is frequently neglected. 
I can get behind this, but not a full concurrency API. If you just have some global function called async that takes a function and its arguments, and if you try to access its return you block until that thread returns, that would be a fine solution to the main use case of python threading anyway. I just don't like how the popular solution is to redesign the language to support error prone gobbledygook like mutual exclusion.
&gt; You're right. Javascript, as a language, is crap. However, the biggest advantage it has over every other language is the simple fact that relatively feature complete implementations of it are available across all of the major browser vendors. You simply cannot ignore that simple fact. This kind of of feature synchronization is simply epic. Every major OS platform has a C compiler. They all support at least ANSI C. This kind of feature synchronization is simply epic! AMD and Intel support the same instruction set. This kind of feature synchronization is simply epic! ARM processor manufacturers adhere to the ARM v7 standard, and often include NEON. This kind of feature synchronization is simply epic! There is very little on the part of browser makers to provide hooks into the DOM for a script interpreter. They don't have to write it, they just need to provide a means to have arbitrary scripting languages that have valid mime specification used in place of JS since JS is not the kitchen sink solution to programming, and it hurts the web in the long run because a lot of problems become extremely hard in the JS model. &gt; This kind of integration is the stuff that end users crave. Modularity is fantastic for developers, but users don't think like that. When you develop software for the masses, the Unix philosophy flies out the window. The web browser wasn't designed for you. The web browser was designed for the 14 year old girl checking her facebook account. Meanwhile Android is outselling iOS now, and has modularity in design and a tremendous breadth of hardware. Microsoft beat Apple and IBM at the home computer by using heterogeneous devices and providing software makers the ability to go wild (interestingly, they seem to have forgotten that recently). Good UX with modular systems is just having good defaults that cover 95% of use cases. That applies to *any* user facing environment. Nothing stops Firefox or Chrome from forcing a dependency on some JS, Perl, and Python interpreter of some sort so that the browser is usable by average Joe, and if you don't have one it can silently install CPython / V8 / whatever to make sure you have it.
Yeah, and I tell my clients what idiots they are for using Windows in their companies.
If we are at the limit of Silicon, explain why Intel Sandy Bridge processors have upwards of 25% more single threaded performance than the Nehalem architecture that came before, or the Core 2 generation before that. We aren't at a limit, but we are getting diminishing returns. We hit a clock ceiling that can only be raised by manufacturing smaller transistors that bleed less heat. And that doesn't go up as *fast*, but it still goes up. And yes, concurrency is important to push more computationally intensive programs. When you are asking that question in the context of a python program, shouldn't you be asking if a dynamic scripting language is the right language domain for the problem you are trying to solve in the first place was the right choice, regardless of if it supports overtly complicated threading primitives? The difficulty and time commitment to doing most tasks is trivial. You can parse massive amounts of text and data in very short time, and we have sufficiently powerful processors now that graphical interfaces, even with superfluous eye candy, are extremely snappy and responsive. While our resolutions will go up, hardware can easily cope with that, and the problem domain python operates in doesn't have endless complexity to solve. Concurrency is the answer to a problem that doesn't face python programs, and trying to use it as a substitute for less convoluted and bug prone concepts like static typing in another language forsakes Pythons primary benefits to the developer anyway, it is supposed to be clean and elegant.
He probably wrote that two years ago about experiences three years ago, and pypy has gotten a vast amount of improvements since then.
Well, an API built around strings would suck anyway (as does the current Python file-system handling). Someone needs to strike a balance between using a dozen classes for handling paths and using simple strings for file handling.
TBH - the best free IDE for Python is emacs but from what i have seen for Eclipse - in every single version it just gets less stable and more bloated. With the newest version its almost impossible to get it to work right under Linux.
TIL there are still people out there who use Eclipse.
[Tuxradar has a good one](http://tuxradar.com/content/code-project-build-ncurses-ui-python). It's the website of the UK Linux magazine Linux Format and they have quite a few really good tutorials. They do actually remark in the article on the fact that there are few Python-specific resources for ncurses, but they suggest that much of the Linux Documentation Project's resources for using C with ncurses may be relevant.
Have used this. Definitely recommend. 
This actually won't help them. Android doesn't use the JVM. They'd need to write a Dalvik backend. 
https://github.com/kennethreitz/clint I have not used this personally, but I have heard good things.
The one thing that's made me use a path library in the past (Twisted's, specifically) is that it can join in a way that prevents escaping some root of the hierarchy, e.g. that HTTP GET /../../../etc/passwd won't resolve in a way that could leave the DocumentRoot. It's not clear from skimming the PEP that such a feature is provided, or that some clever way of using the proposed operations could implement it. Probably not difficult to extend but then what's the purpose?
I also recommend it, the [urwid tutorial](http://excess.org/urwid/tutorial.html) is a fantastic starting point.
...because...?
But most shops have some niche needs - for high-performance, mobile computing, web development, or whatever. So, if python completely gives up competing in these places it'll just lose out to java more often in those shops that don't want to get stuck with too many languages. I'm currently working in a shop that is primarily Java, Python and Ruby, but also has PHP, Perl, Javascript, and Bash shell scripts. Python has worked out great for ETL operations - processing about 200 million complex transformations a day. Ruby has worked out fine for our transactional front-end. But we're facing a lot of questions about why we shouldn't just move everything to java to make resourcing simpler. Nobody is asking why not move everything to python - because it's really not fast enough to.
Python cannot be all things to all people. I understand the desire to see Python pushed into more spaces, but this is just not sensible.
Installing ease is definatly not the big issue. xlrd/xwt attempt to read/write a very complex format. If you are working with simple spreadsheets you'd probably prefer xlrd/xlwt/openpyxl(for xlsx documents) and your own code to transform the data for simplicity/not having to rely on a complex gui app/cross platform support. But if you want to do something more complex, taking advantage of excel power for chart creation/evaluating macros/etc. you want to call into excel.
Good point! I suppose it *could* be linux-only, but cross-platform is ideal. In any case, it must absolutely work under linux.
Hmm this seems promising =)
&gt;They do actually remark in the article on the fact that there are few Python-specific resources for ncurses, but they suggest that much of the Linux Documentation Project's resources for using C with ncurses may be relevant. This was the problem I ran into. I know a bit of C, but ever since I've started using python, I've been very reluctant to touch C/++. I've turned into a bit of a snob =) In any case, this tutorial looks very good. Bookmarked!
Ooooohhhh... pretty...
I have always used geany: http://www.geany.org/ for python coding | have tried sublime but it does not offer me anything extra
IIRC curses is only for ~~linux~~ UNIX. Generally, using terminals between different OS's is a major pain in the ass. The thick layer of poor decisions, breaking standards and self-contradicting habits makes it terribly hard to have a portable, good looking "CLI UI". Edit: Yes, UNIX, not linux. Brainfart.
curses is a UNIX library, so you were remembering wrong.
&gt; You can hardly do the kind of programming that you do in Python in C/C++/C#/Java. In an academic setting when evaluating languages - you can easily categorize these features and distinguish what kind of problems each is appropriate for. But in the real world, you've got a team with mixed, but concentrated skillsets and a variety of problems - that could be solved by many of these languages. For example, I've been writing ETL processes that transform vast amounts of data for years. I've written this in c, perl, and python. I've seen it done in java and plsql. Any of these languages can do a fine job. But I prefer python because I want the readability and maintainability. To get the performance I want I have to split very large files up and manually process the fragments by completely separate processes. That's extra work that wouldn't be required by c, and probably wouldn't be required by java. But that doesn't mean those languages are more appropriate to the task.
I want it. `relative_to`, `parts`-slicing, `owner`, not having to use `os.path_sep`, …
&gt; Although I don't recommend it!!!!!!!!!!!!!!!!!!!!! -------- &gt; I wanted to give the closest answer I could, the commonsense answers having been already provided.
clickable link for the lazy: http://stackoverflow.com/questions/6704151/python-equivalent-of-rubys-method-missing/12770162#12770162
The [docs for the next release](http://urwid.rtfd.org) are even better. If you want to play with the development version I highly recommend getting on the irc channel.
see &lt;http://plumbum.readthedocs.org/en/latest/cli.html&gt;
Was just wondering how it is integrated with Linux. Basically scripts that I write in BASH I want to write them on Python.
There's a lot of Unix functionality in the os module. Check out the documentation: http://docs.python.org/library/os.html
like takluvyer said there are a ton of libs for this kind of thing. Here's one that i find interesting but havent actually used: http://amoffat.github.com/sh/
Depending on what you want to do, check out [sh](https://github.com/amoffat/sh)
Will Fabric fit your needs? http://fabfile.org/
Will do so :) Thank you.
Because posix threading is a bastion of abstract simplicity you silly goose.
Some things you can access through high level python libraries. Some things on linux can be found by reading files in /proc or /sys. Sometimes you're stuck just executing the shell command and parsing their output. It really depends on what you want.
The point of docopt, as far as i understand, is that the only syntax you need to know is posix, which has been the standard for *nix documentation forever. Any time you've read a man page (and, to a certain extent, any python documentation), it's followed this syntax. So this is a standard that you actually already know, most likely, even if you don't realise it. For me, the appeal is in writing your code *based on the documentation*. Wow. I can't imagine anything more brilliantly elegant. No worries about trying to keep your documentation up to date as you develop, or trying to go back and figure out what the hell you did so that you can document it. And there is literally nothing you have to learn or remember in the way of options or syntax to optdoc.
There is such a thing as polyglot code bases. You can write in Python up to the point where you say performance is an issue, and then write a C or C++ binary to handle the rough stuff, and take your pick of sockets, signals, RPCs, or just write out instructions to a file in json or something. I get that a lot of developers don't like using the right tool for the job, but they are also the kind of people who won't be using mutexes and threads in Python without causing tremendous errors and problems. Once you know one imperative / oo language, you can learn almost any other in a week with library reference guides to any frameworks you are using.
That still isn't an answer. As you can see, the results were awful. 
Unfortunately this turns out to not be a very good search. Way to many water bottle rocket references.
The trouble is, Microsoft marketed their system as POSIX compliant because they needed to in order to satisfy FIPS to sell to government. http://www.unityisplural.com/2012/01/windows-posix-compliance-wink-and-nod.html Without this compliance they would have no government contracts, and big business would not be forced to buy into their crap in order to communicate with government on the non-standard platform. So, in short, we have a standard for interaction with an operating system in a portable way - POSIX - and stdlib should be supporting that way only, not any non-standard proprietary systems. 
I prefer more subtle hints; "Windows? Do people still use that? In my experience it was superceeded by more open and standardised systems in the 1990's!" Good luck with calling your clients idiots. 
I've got a couple. I use bottle for most of my python projects, which tend to be small quick apps. Using bottle.py for everything but the blog here [hanging hyena](http://www.hanginghyena.com) Also have a web-based calculator here: [website revenue estimator](http://www.marginhound.com/calculators/website-revenue-calculator) Please pardon laughable front-end design skills. I'm a database guy - if it doesn't have a couple of million rows, I'm at a distinct disadvantage :) It would be nice to get a public list of "powered by bottle.py" for the community... The web2py guys have one. Not sure what would be a fair way to manage the spam factor....
I think it was 2010 when I thought NumPy/SciPy was pretty big already. And in the scientific community it's CPython instead of pypy that's big, as takluyver says. 
Bottle isn't like Wordpress, where they jam a link / text on every page. This search will miss most sites unless the owner blogs about it.
Awesome, it's really refreshing to see websites made with the framework you're using. I remember seeing your hanging hyena site before, I don't remember where. And I agree, a powered by bottle.py list would be a great idea, i'm sure it would bring in a larger community. 
I assembled a list of bottle.py links and tutorials a month or two ago that showed up on reddit. [bottlepy resource page](http://www.marginhound.com/bottle-py-resources/) Hyenas actually started as a polite "load test" for the framework; I wanted to use it at work and figured the online scrabble community would give it a much harder workout than my fairly sedate end users. Mission accomplished. The daily traffic on Hyenas is 10x - 25x greater than the reporting systems I manage in my day job. Dirty little secret of BI: business people ignore over 80% of your stuff, unfortunately they neglect to tell you that in advance of coding it!!! I've actually got another project in the works - much more complicated technically (data management, thus we have to address security, concurrency, more load issues, etc.). Plus it is taxing my lousy front end skills...
but posix is a prorietery standard. The fact that most non-windows os aroung today are in the *nix family and largely posix compliant(I'm not sure that any linux distro has ever been fully posix compliant) is a historical accident(symbian failed, classic mac os did not have premtive miltitasking and was replaced with a *nix, beos was partially unix-like but asked too much to be bought out by apple and died, after Microsoft dumped it OS/2 didn't go too far). Microsoft is doing their own thing. It would be convinient/usefull but I see no moral or legal obligation for them to do so. The posix complience addons date back to when posix complience was mandated which is no longer the case.
Lol...actually it's worse - in BI / Analytics we have to deliver the final product (report, analytical tool, study) THEN we get to see if the business people will take action on it. Unfortunately, if they fail to do anything...our reports / tools just sit there... cruft central... New project is more serious and likely commercial - a real web app.
Python criticisms being "high level" indicates of a distinct lack of hype. There's relatively little drama. No dogma over functional vs. oop forced upon you and yet clean anyways. It does it's job and does it well. In other words, Python is Craig Tucker from South Park. It's good to be Craig.
Yes - for now at least. A lot of it comes down to architecture. Microframeworks do just fine if you're using a clean design and understand how stuff gets done. In some ways, easier to use, since there is less stuff hiding in the bush.
Point. Just sounds like lots of stages to fail.
In C it works okay. You think differently when you have your C programmer's hat on. EDIT: I think I understand what you're getting at, though. No, exposing mutexes and such noise in python has already been done. Import threading. However, what you propose has *also* already been done, but there's a little bootstrapping involved in getting it working. Use multiprocessing. It takes some getting used to, but you can achieve exactly what you describe with it. 
That is very good to hear since I was not sure if Python is used at that scale :)
Are you assuming that `p.parent()` returns a `dict`? It returns a path object: &gt;&gt;&gt; Path('/Users/Shared/Library').parent() PosixPath('/Users/Shared')
&gt; `FilePath` implements essentially this same check, except that it resolves the path using `os.path.abspath`, and so inherits the problems/bugs mentioned in this PEP. Addendum: `FilePath`'s string-based path comparisons can also lead to some surprising edge cases, such as this: &gt;&gt;&gt; p = FilePath('/etc/cron.d/') &gt;&gt;&gt; p.preauthChild('/etc/cron.d/foo') FilePath('/etc/cron.d/foo') &gt;&gt;&gt; p.preauthChild('/etc/cron.weekly/foo') twisted.python.filepath.InsecurePath: /etc/cron.weekly/foo is not a child of /etc/cron.d &gt;&gt;&gt; p.preauthChild('/etc/cron.daily/foo') FilePath('/etc/cron.daily/foo') # whoops? `pathlib`'s object-based approach avoids this kind of thing.
Tldr, business people dont give a shit about programming. Its true. 
One big issue is government contracts. Many do not want to use a company that does not use SAS. Even the FDA mandates SAS for any trial analysis. This needs to change.
&gt; 10 years ago you could get ~3GHz chips and that's still the limit today You can put a good-yield Bulldozer or Sandy Bridge chip (both 32nm) at 5 ghz on air. The highest end chips from both companies retail at 3.8 and 3.7 base, and 4.2 and 4.0 "turbo" each, respectively. So we have "plateaued" in the last generation of chips around 4ghz, with indications that if Intel hadn't used cheap thermal paste in Ivy Bridge instead of a copper sink dropping the manufacturing tech to 22nm (especially if they hadn't dedicated so much die area to useless integrated graphics) they could have had cores at 5.2 - 5.5 ghz on air. I'm not saying we haven't hit a point of diminishing returns on processor frequency or tricks to exploit on die resources more effectively with things like out of order execution or branch prediction, but we *still* are getting single threaded improvements, on many fronts from cache to interconnect speed to resource duplication to frequency improvements to more intelligent instructions. &gt; Parallelisation isn't actually all that difficult - there's three separate implementations in the Python stdlib plus developers are more familiar with design patterns like MapReduce. You seem to want to limit where generic programming languages can be used based on your own personal biases, and I think that's just really unhelpful. If you want to write your own python interpreter to provide a thread module without a GIL, have at it. The language design means sacrificing single threaded performance to remove it without creating obscure silent runtime unpredictability. &gt; The "problem domain python operates in" is global scope. Its a generic programming language which is dynamically typed. There's no limit to where its useful. By making a language that is dynamically typed you inherently limit the problem domain. Go write an OS for a single core CPU in python. You *can not*. Even if you made a hardware python interpreter, it would be excessively and prohibitively slow with autoboxing. The language has inherent tradeoffs that limit its problem domain. &gt; Also, you appear to not consider the fact that many people who write software are not software engineers but graphic designers or traditional scientists - Python gives them a language they can understand and get their jobs done. Forcing them to learn C or some similar line noise because you believe Python should only have an extremely limited scope is unbelievably arrogant and short-sighted. And you want them to learn posix threading, mapreduce, or any other parallel paradigm? I have no problem with Python adding features like async as a C module that can be called from the stl to run python tasks in parallel, but trying to put fine grained paralellism in python ruins the language features that make people use it in the first place by making single threaded performance even worse and making progam complexity unnecessary complex. In the end, *whatever*. I would *never* use python in parallel even if it supported it because as soon as I say "I need speed" the *first* thing I do is switch to a language that is faster by at least an order of magnitude like C++ or Java. I trade the concise and beautiful simplicity of python for more fine grained control to construct a more performant program if I need it. Trying to ignore *why* Python is slow in the first place and trying to unnaturally corral in features of other paradigms is fine, if you want to do that. I don't, I won't, and the only time I would care is if your actions make the language I am using *worse* by making single threaded performance worse when it is already pretty poor. The use case of python parallelism doesn't exist. If my program is slow, it is easier, and less error prone, to implement critical sections in a lower level language where I get 10 - 20x speedup just by changing the language, than to try to do critical sections in parallel in python for a N core speedup as the theoretical limit.
Also think this is more like Baker, which I'm currently used. Last time I try clize, it assume all callables in the module as command which include functions that I import from other module and not meant as command. In Baker, there's a decorator to mark the function as command. @baker.command def hello(): print 'hello' Is there similar functionality ?
Either way my reasoning still applies.
and 'R' is......?
I liked this article quite a bit - but maybe that's because I had already decided to try and learn Python and R this year. Marginhound, if you're the author of Python for Data Analysis (this wasn't clear as the blog post didn't list an author), I just want to let you know I've had it on pre-order for almost 2 months now and I'm very anxious to read it!
&gt; Good luck with calling your clients idiots. ***Woooosh***.
Clint here has the distinct advantage of being truly "cross-platform" (it even runs on Windows, courtesy of colorama). If the OP requires basic coloring and formatting, clint would be the way to go.
Thanks - no, I'm not the author of the book...just ran across the book after i had written most of the article and wanted to link to the guy's blog vs. some online store...
It encourages the manipulation of data so that you get the desired answer. If you were unable to solve a problem yesterday, but can do so today, then you have improved.
Op here - I do blend a couple of critiques in the post but that is because these issues overlap to create larger problems. At the junior level and in small / startup organizations, analysts need to know how to code. In today's world we just don't have the bodies to do anything else. I've spent most of my career in immediate teams of under 5 people... (usually 3 - 5 very senior people, but a limited # of potential do-ers) BTW - agree there is a role for tools that let business guys do stats. Minitab is good for this - Six Sigma, probably the largest effort to teach business guys statistics, used this fairly heavily. But this isn't analytics... it is more like building "analytical literacy" or "analytical comprehension"... Hey - what if we hire a bunch of scientists / engineers / math guys and teach them to become business guys :) 
Generally it is quite simple and there are numerous calls in the subprocess package which you can look up. import subprocess as sp ldenv = {'LD_LIBRARY_PATH': '/some/custom/libs} proc = sp.Popen(["df", "-h"], env=ldenv, shell=False, stdout=sp.PIPE, stderr=sp.PIPE) out, err = proc.communicate() Note the commands and its args are passed as a list. if you set shell=True then you can specify the whole thing as a string. Its a bit less convenient than perl for things like this but I've written a distributed test system based on sp and I'd say if you structure your code and write your own little wrappers for it you can get quite a lot done.
so it's like plac then. or am i missing something? http://plac.googlecode.com/hg/doc/plac.html
reddit. The best thing ever happened on the Internets. Thank you easy tiger !! :) The information in this thread is gold.
Noob here too. I wrote a python script to retrieve the meaning of a word using Google Dict API. Then I integrated this into the terminal by adding a custom "define" command to linux. everytime I enter "define someword" i get the meaning of that word in the terminal. Code is here: https://github.com/ritratt/define PS: it has minimal functionality.
&gt; Last time I try clize, it assume all callables in the module as command You must be mistaken. Clize never did that and if it does, that would be over my dead body. Only functions decorated and passed to run will be taken as commands.
Well, the idea is to control everything in real time. I were tired of "push &gt; wait &gt; see result in browser" workflow. And never understood why should i push a eventually broken commit. I want to test everything before push, not after. And i want to test right here right now, without queues, and have the result returned to me in real time, in my lovely terminal. After i see greenish tests on all versions i'm ready to push updates. I'm i somehow wrong? With CIBox i'm working like i would have installed all versions on my computer. 
improved at solving math puzzles, sure. That is different from improving at anything useful.
docopt doesn't require that the docs are at module level - its just a string - so this works and lets you use setuptools entry_points: import docopt def func(): """Usage: func SOMETHING [OPTION] """ opts = docopt.docopt(func.__doc__) I imagine it would be easy to write a docopt decorator - I might do that.
My lab has been using Python3 in production for 2+ years. The web framework people were the biggest stick-in-the-muds, but they've mostly come along at this point. For example, Django works on Python3 as of last [December](https://groups.google.com/forum/#!topic/django-developers/XjrX3FIPT-U). PyPy has experimental support for Python3, but it's not ready for general use yet. At the rate they've been working, I'd expect something usable (if not 100% stable) by the end of the year. The moral of the story is: people continue to use Python2 mostly because of large, messy, legacy code-bases that they don't have the resources to port yet. As a new user, you don't have this issue. Don't be part of the problem ;)
I always use [opster](http://pypi.python.org/pypi/opster) :D The usage help is auto-generated, and the dispatch method is quite nice.
Also interesting: https://github.com/tomerfiliba/plumbum See author's blog posts about it: http://tomerfiliba.com/blog/Plumbum/ http://tomerfiliba.com/blog/Plumbum-1.0/
It doesn't really matter that much. Most of the new sugar was brought to 2. If someone is at the point when 2 vs 3 matters (that is, they have to use a library that wasn't ported), they should have little problem switching. Python 3 is not driven forward by newcomers, it's driven by people who port important libraries and frameworks.
As far as i am aware, the twisted framework only works with 2.7. This is not researched, we have only recently implemented the twisted framework at work and chose 2.7 over 3.x
That's not true anymore, they just demand that data be in the XPORT format, but such files can be generated with R as well. Merck, for one, uses R for it's clinical trials.
perhaps. the fact remains that it's a DSL for definition where clize uses the function's actual arguments for definition, and only uses a DSL for actual documentation. It'd be really cool if clize supported actual doc languages, like epytext, or whatever-the-crap-it-is that makes RST usable to define function arguments.
IMHO, learn with 2 for a month or so, then go to 3. Lots of stuff still use 2, if you're going to be working with other people's stuff it'd be good to understand the differences.
I'm using python 2.7.x in production and for casual coding. I don't see myself moving to python 3 any time soon.
True! The only reason I'm using 2.7 right now is that I've been working on a thing that depends on Twisted. There's some work being done on [making Twisted work with 2.6, 2.7 and 3.3](http://twistedmatrix.com/trac/wiki/Plan/Python3) but there's no date set and I wouldn't hold my breath for it right now. EDIT: Beyond that project, I try to do everything in Python 3 simply because it's The New Thing and I like a few things about it, such as easier dictionary iteration and the new format strings. 
At my work we are a python only shop with about 70 python programmers. Our product is a distributed enterprisey app that we install into our customers environments and in some cases host i.e SaaS. We are long time PSF sponsors and regularly contribute time, code and money to opensource projects and PyCon. But, 100% of our Python code is 2.7.x and we have not seriously considered Python 3 at this point. Perhaps sometime in the next year we will look at the possibility but, there would need to be a strong finical motivation for us to consider it and to balance the risk.
I've just asked the resident "twisted expert" and he seems the think twisted 3.0 support is coming in the next year. Some things you can get to work in 3.0 but it's messy 
Do you need libraries, modules or packages that are not yet ported to Python 3? If so go with Python 2, if not go with Python 3. That's as simple as it can get.
That's probably a bit too simple, though. Newcomers can't anticipate every library they might want to use. Predicting what you need is hard enough even for experience programmers.
The only bit I'd change is to recommend 2.6+, not 2.5+. 2.6 came out four years ago, and its features make it much easier to move to Python 3 in the future.
Is there any easy way to get pylint or pyflakes support? pep8 is available but it's not the same.
Man, seems like **everyone** is reinventing this (I have something similar locally!). IMHO, this is a sign that the standard library `cmd` module needs a major overhaul.
Thanks! :)
Where does pygame come in all this?
Performance-wise there's not much of a difference. Better performance wasn't a goal of Python 3, and when 3.0 came out, the performance was actually slightly worse than 2.x, but they've since improved it and they're now pretty much the same.
That one looks appealing and I nearly bought it once, but several of the reviews (both on O'Reilley and Amazon) mentioned the book having quite a few errors. Have you used it personally?
You are thinking about this as a string manipulation problem instead of moving around a file hierarchy. You are not "inserting the word backup in front of [something]", you are moving one step up a tree and then to a different child node. We're all used to the subtree identifying API of "strings separated by slashes" but it's not the right tool for every job.
But path.py was an api for building strings to use as an api for accessing files. This *is* different in a non-trivial way in that the objects actually represent files instead of representing strings which represent files. That doesn't mean it's the right solution but it's not the same.
Go with 2.6+, you're likely to encounter a number of production environments that are still working with older versions of Python and learning 2.6+ first will get you comfortable with those conventions. Transitioning over to Python 3 is relatively easy (except for string handling and a couple of conventions about metaclasses). If you *really* want to get in the Python 3 habit, you can also use `__future__` imports to get into Python 3 syntax.
python 3 taught me much about bytestrings and unicode strings. even if i code python 2 now, i don’t ever get those unicodedecodeerrors and asciihatesyoutooerrors, because i simply know when to en- and decode. python3 has the advantage that you don’t have to do mass `__future__` imports and `# -*- coding: utf-8 -*-` directives to get sane default behavior. python 3 apis are built around unicode strings if they handle text and byte strings if they handle binary data, in python 2 you get str or unicode pretty randomly. that’s the difference: less hair-pulling.
Knew you'd go there. Let's also compare that Peewee solves about 2% of the problem space that SQLAlchemy does, and as you slowly experiment more with Peewee and perhaps gain more users, an ever larger percentage of this problem space will become apparent to you, and the kinds of patterns SQLAlchemy uses will become more familiar and hence more navigable. Suffice to say I can give you the rationale for every line of code within SQLAlchemy, and those which I can't are bugs. We're very aggressive about removing redundant APIs once they've been superseded by better approaches.
I was referring to the idea that with path.py you still access a file inside a directory by concatenating strings with a nice overloaded '/' operator. Your mental model still involves "adding" strings together to get a path descriptor like "/home/foo/file.py". It's clearly the same mental model for navigating in a filesystem tree that we use in a shell (and that we use for URLs) This one considers foo.py to be "inside" foo which is inside home which is inside root. It seems to me that this is the proper use of object oriented modeling. The objects model the problem domain of accessing nodes of a tree instead of making it easier to build up string based file accessors.
People ask this all the time, but it's based on a false premise: that you can or should only learn one version. Look, Python 2 and 3 are not very different. If you're a computer, you might get confused by `print "Hello"` when you expected `print("Hello")`, but if you're a human being, you should be able to handle it. The differences between the languages are small and listed in the docs for Python 3. If you plan to be a competent Python programmer, you will learn both. As for which to learn first, learn the version used in whatever book or tutorial you plan to use. If you're done with the learning phase and want to do a project, use the highest version that supports the libraries you'll be using (e.g. Django is still only on 2, but bottle is on 3).
R is a venerable and well-known programming language used for data analysis and visualization, which comes with a nice fully scriptable environment for doing things like graphs, importing data files, etc. It is open source and has probably the world's best ecosystem of statistical libraries available in its repository, called CRAN; lots of really robust and cutting edge stuff. If you need to do serious statistics or other data work you should seriously consider learning R.
&gt; Peewee solves about 2% of the problem space that SQLAlchemy does The guy was saying it is supposed to be lightweight, not solve 100% of the problem space that SQLAlchemy does. (It might help to observe that Django only addresses a small part of SQLAlchemy's problem space as well) I doubt Peewee's user base is even a noticeable fraction of SQLAlchemy's so why does it matter?
2.7 is a lot easier to port than 2.6, like really significantly. It is explicitly meant to be the transitional more forward-compatible version, 2.6 is meant to be the conservative backward-compatible version. If you need to do multi-version, and can pin it down to 2.7 rather than 2.6 or before, you will hate your life less
A chasm has gradually grown between the standard libraries in 2 and 3. You should also be specific about the version: 2.6 really doesn't get backports except security fixes, 2.7 alone has backports from 3.x ideas. So it isn't that version 2 in general has backports. And the pain of migrating a code base from (say) 2.5 to 3.x is crazy while the pain from 2.7 to 3.x is much less.
The experienced person giving the advice has a vague idea of how likely it is that you will NEED a 2.x-only library, and should factor that into the advice. Someone who is brand new can actually get a lot done within 3.x universe because now most of the libraries that are still maintained do support 3. Newcomers are not pre-attached to things which don't support 3, and this rewards projects which went ahead and ported rather than keeping everyone behind. Not the same for someone with a lot of history on 2.x who has imprinted on a certain set of libraries they refuse to do without, or has a lot of existing code that uses one of these libraries. They can't switch nearly so easily. But that doesn't mean that the newcomer has to follow the same path, because they don't have a lot of existing code or preferences. Since now the library support is actually pretty good (especially if you prune out things nobody uses/which haven't been updated in 6+ years) I would not have a problem recommending 3. In the hypothetical case where it is essential to use 2.7, it's not unlearnable
I think I may have caused a misunderstanding. I was speaking to vph's definition of lightweight and wanted to clarify that, to me, it meant a simple API and codebase. vph had compared peewee to SQA and I meant to show, by listing SLOC, that peewee was barely in the same discussion as SQA. I don't think anyone here is trying to talk bad about SQA and, as I said in an earlier comment, SQA is a very well-regarded library.
thanks for that clarification. If you'd like to check out an ORM that gets a lot of featureset within a simple-to-understand approach, I'd check out Storm. Unlike most "simple" ORMs it actually has a rudimentary unit of work, identity map and row-dependency system built into it, as well as a very intelligent system of interacting with the transaction that SQLAlchemy imitated starting with version 0.5. Ever-nicer class configuration and expression construction is nice and all, but if you'd really like to diverge from the shortcomings of the Django ORM, looking into transaction scope, identity maps, and better persistence patterns would be a good place to explore (hint: Class.select() already makes it very difficult to have control over the transactional scope of operations. SQLAlchemy abandoned this pattern as the default mode of operation after version 0.1). 
I'm fine with the goals of building small and simple database tools that are easy to understand. But you're going to have less capability as a result. That is, lightweight *does* mean a dearth of features, for those users who are dealing with real-world problem spaces. I mostly disagree with the implication that you can have all the features you'd ever need and have it all in a tiny codebase anyone can read over breakfast. It vastly understates the problem. It's hard to let it slide. These threads never get into what exactly those capabilities are, and to that degree I think there's a little bit of a rift between those devs who depend daily on complex features like inheritance mapping and unit of work, versus new end-users who are probably not aware of use cases like these, much less recognizing that they can never fit into a 1500-line Python module (note: I am referring to end-users, not to any ORM developers here).
I was at a 'work party' the other night that participants call Codenight. They're all Microsofties in Seattle. One of them was talking with me about Python and encouraged me to learn on 2.6 versus the other versions. That seemed to be a consensus opinion (more or less). None of those guys use it all day long, but they're all deeply involved in programming.
I started learning python about a year ago, so I could hardly be considered an expert, but I did face the same dilemma as you. I started using version 3. But ended up reverting to version 2.7 so it was compatible with the libraries I wanted to use. In addition I found that most tutorials are for the 2.x versions of python, and while the differences are fairly minor, they can trip you up when you are learning.
Great news, I used peewee for a few lightweight query-only tools and as my first ORM. 
Who was pushing for this to be included in the standard library? Someone needs a hug...?
Interesting, I wrote something similar: https://github.com/haukurpallh/def
I think that **flask** is similar to bottle and is pretty popular as well.
I think pylint already supports Python 3, but I don't know of a good pyflakes port yet.
You mean allowing you to use rST or other formats so the same docstring can be used in your code documentation? I think I may be able to do that.
&gt;For example, Django works on Python3 as of last December. That's incredible, but who uses pure Django? The advantage of Django is that aside from great built-in functionality, there's tons of existing code you can take advantage of too (Django CMS, djangosnippets.org, etc.).
Why 2.6 instead of 2.7? That doesn't really make sense.
But isn't clint just for making slightly more attractive stdout? Could you use it to create CLI with a menu, etc?
This is very cool. It feels much more Pythonic IMO, although I'm not a fan of operating overloading, and I agree that the __gt functions are weird... I just think there must be another way. I'm not a fan of &amp; and | either, they feel more like bitwise operators than Python's "and" and "or". Fantastic work though, good work! P.S. Any ideas if Python 3 support will happen?
&gt;On one hand I feel that newcomers should adopt Python3 to help drive Python3 forward, but then perhaps Python2 is the only practical choice in terms of libraries, documentation etc? As a new programmer myself, I can't really imagine learning python without the abundance of resources available for python 2, which is what I'm currently learning. I feel like the responsibility for that lies with experienced programmers pushing forwards through the uncertainty, where new programmers need the 'stability' while overcoming the most basic 'language barriers.'
Practical, relevant, and sure to help your development? No idea. Build an IRC server from scratch, using sockets, just for fun.
You parse json using the json module, not using ast.literal_eval.
You guys are making me realize how much I do not know as a noob lol. Thank you though :D
check out /r/dailyprogrammer You'll find hundreds of ideas.
Take some comp sci courses at Udacity. I took the robot car course, and there was some decently interesting python coding to do.
make a bot to hook partners on a dating site. It did not make me famous, but sex is always great :)
what app do you use the most that you often think "man I wish it would do this instead of that". Ok now rewrite your own copy of it in python.
Screw that, make your own reddit API using [requests](http://docs.python-requests.org/en/latest/)! It's a lot of fun.
directory snapshot inventory system performance test (like how long it takes to execute,load, either your program or remote computer, eg ping) data is saved/loaded from database, xml, json, csv How complex depends on your level, try procedural only, OOP or even with unit test. Is output going to be command line, gui, web? http://www.cse.msu.edu/~cse231/PracticeOfComputingUsingPython/index.php http://www.cs.princeton.edu/courses/archive/spring12/cos126/assignments.php Games, like Tetris
You sound like someone that would love to check out [Coursera's An Introduction to Interactive Programming in Python](https://www.coursera.org/course/interactivepython) which is a free seminar offered by the fantastic Coursera project. I'm having a hard time making sure I don't enroll in tens of dozens of those myself, found this Python one today and it puts me up at 10 courses for this semester. I wish I had been this active when I was at University myself...
This is amazing. Thank you so much for showing me this. I've been looking for something exactly like this to get me into Python.
Write a wrapper for some API, start with something small, like a weather API. You can also make a web crawler, reddit bot or the almighty TODO list :)
You're doing it wrong: http://theoatmeal.com/comics/ie
This is how a major release announcement for a young project should be written. A well thought out blog post that introduces people to the project, with links to more in depth information up front. After that's taken care of, we can get the feature lists &amp; links to Github.
You know how much work that would be (even with requests)?
Wow, that is well put together!
how bout a freemium model where you can buy sleeve tattoos for 99 cents?
might as well learn sqlite while your at it
Write a script that copies all messages, likes etc a person does in Reddit into Evernote. I've been meaning to write one of those but never gotten around to it :). 
numpy, scipy apparently support Python3. Matplotlib does not. No word on PIL.
Salary is highly dependent on the domain, experience, rarity, etc. but I've seen 50-130k
google show 3.6 million results for the query: todo list software It's not need, it's just an advanced "Hello World!"
Try to write a small wiki engine using [bottle](http://bottlepy.org/docs/dev/) and files for storage. Improve it with : - a DB - a git repo to track modifs
3.59 million of those results are probably for a male enhancement product, though.
Is there list of incompatible libraries? Because we might be saying that there are some and in reality everything was already ported (I doubt that :). I remember faintly that there was some kind of page (maybe even on official python server). Edit: LOL, found it (just searched python hall of shame) http://python3wos.appspot.com/
Write a program that tracks which season and episode of your favourite TV shows you're up to, and automatically downloads the most highly seeded episode torrents as they show up on your favourite RSS torrent feed.
That's updated now. The install script gets mongo from the repository. Putting that aside, packaging Python software to .deb or .rpm is a nightmare. ( In theory FPM should do the trick, but in practice ... ) Even if you succeed, there is still tons of bash ( in the post-install, pre-install scripts ), so there is no guarantee it will work better. It's a good idea if you have lots of dependencies, but they have to be part of the repositories already available for the OS. Amon has only one dep - MongoDB, and that's in an external repo, not part of the defaults 
In Paris 35k€-42k€/year (my JS dev friends are closer to 50k€)
When I want a little exercise I write a chess engine and if motivated enough try to write a (half way) decent AI to play against.
What degree did you get in college? 
Context, man. There is no reason whatsoever to start with 2.5 or 2.6.
Cool. Thanks.
Wow... At least we have lots of nature in New Zealand
What city are you in. This makes a big difference
Some people like to live dangerously.
And LIM wipes the hard drive.
try [sh](https://github.com/amoffat/sh) (previously pbs) library. It is a full-fledged subprocess interface for Python 2.6 - 3.2 that allows you to call any program as if it were a function:
Now I love you.
SV?
hmm sounds like CA or around NYC... so basically double the cost for anything else
True, it doesn't have to be perfect. I just imagine the Reddit API to be fairly large. Haven't actually looked.
Silicon Valley? not actually sure
Make a game. All sorts of example code here you could use to get started: http://programarcadegames.com/index.php?chapter=example_code&amp;lang=en
Help me debug and add features to [my shitty app](https://github.com/louist87/tromegle).
That's a good point. If you're looking to get something done, use PRAW. If you're like me and want to experiment with some APIs though, the reddit API is a nice start.
Guys, are you considering taxes?
JS devs make more than a Python dev?
Where I am in the US Python jobs (and dev jobs in general, really) are paying in a fairly wide range from $60k-$100k. Smaller companies that I've been talking to lately seem to be topping out at about $70k.
Most of these problems have more to do with reading skills than with programming skills. 
"*Find sum of the largest number* with an odd number of factors (including 1 and itself) under 1000000". Did sum of the factors. Nope wasn't that.
&gt; The web framework people were the biggest stick-in-the-muds, pep 3333 was not approved until Jan. 2011. without a python 3 compatible version of wsgi, there wasn't much of a choice for those stick's in the mud.
By my calculations, Eclipse 7 won't even run. 
Do you have a day job? Most of my small python projects are things to make my day/life easier. 
grad student here... decided this isn't for me and going to make the jump to software dev
nothing specific, but we've done some python/kinect integration that might be of some use (&amp; will be doing more soon). see: http://pytools.codeplex.com/wikipage?title=PyKinect
How many results for "it was a joke"?
More upvotes for parent please. Most of the suggestions have fixated on the premise that "project" refers to a complete application/tool/script/etc that you write from start to finish yourself. It doesn't need to be. As an example, I have a project I've been meaning to get around to: The Adium IM client for OSX has the option to perform actions (audio, growl, etc) when your name is mentioned. It's hardcoded to only do this in group chats, I'd like to make this an option. **It's a single checkbox in the UI, a single conditional in the code, and a single entry in preferences.** But when I'm done I'll know the Adium codebase, the patch submission process, etc. **Learning how to collaborate with other programmers is often more difficult and far more powerful than making something all your own** and potentially far more satisfying, as results of your efforts may be used by many, *many* people. 
To the top with you. Being a "Python" programmer isn't what gets you jobs or determines how much money you make, it's the problem domain you have experience in. 
I am more surprised that people label themselves as *Javascript* developers, I've heard everything now!
I'm working on a project that uses kinect and opencv. It's nowhere near done and I haven't had time to work on it for a while, but I gisted some code here that might be helpfull: https://gist.github.com/3859347 Note: this uses https://github.com/jmendeth/PyOpenNI , which requires you to also compile/install OpenNI, NITE, etc. Removing the OpenCV should be pretty easy if you dont need it, otherwise, make sure you have openCV with python bindings compiled/installed. *Edit*: sorry I didn't see you said Kinect for Windows SDK. I dont have experience with that directly, but once you get the depth / color image, the code I gisted should help in figuring out how to display it / blit to texture at least. hope this helps :) 
For that salary? Definitely Silicon Valley.
Here is an example of an older app we wrote using kivy + kinect: http://fresklabs.com/projects/computer-vision-interface
Aussie dweller here: 75-120. Aud of course, which is more valuable than US. In addition I look with horror at local design level and coding skills. Seen a lot. 
Second that. 
This! We run a small consulting shop, and end up writing almost everything in python. We charge between $100/h - $200/h based on the kind and length of work. The clients dont care how you do what you do it, as long as it gets done right and is worth more to them than they paid you in the end.
Yeah, that's a great theory, but most organizations are looking for specific skills and people who can hit the ground running. Not to say all are, and not to say that they should be. But they tend to.
silicon valley
As far as I know, we have a "Formulário Ortográfico" (something like a collection of rules for the Brazilian Portuguese - which is different than the Portuguese of Portugal), so, in these rules they do not specify if we should use space or not, but the entire collection is not using space, actually I never stopped to think about this hehe, everyone here seems to use a space by intuition.
Write your own versions of classic arcade games. Missile Command, Space Invaders, Defender, PacMan.
Oh look, GitHub.
What you're talking about is the concept of [persistence](http://en.wikipedia.org/wiki/Persistence_%28computer_science%29). There's a lot of ways to do it; the simplest way is to write the data to a file at the end of the script, and read it in at the beginning. writing example: with open("somefile.txt", 'w') as my_data: my_data.write("checking:1222.36,savings:0.00") reading example: with open("somefile.txt", 'r') as my_data: bank_info_string = my_data.read() checking, unused, savings = bank_info_string.partition(',') # checking is now a string, "checking:1222.36" These methods are examples that are short, and skip a lot of the details that you'll need to be careful of. You can get fancier and more efficient and consistent by using `json`, `csv`, or `pickle` stdlib modules to more consistently and easily convert from a file to python data structures. There's a whole lot of other ways too, most of them involving various kinds of database. Whichever method you use, you'll have to be wary of things like running your script twice at the same time, and so forth, to ensure that your data is consistent and correct. When you get into persistence, you're also going to want to remember to back up your data, just like you should be backing up your taxes, family photos, etc. You don't want to rely on any one copy of your data being on a hard drive that you hope never fails.
oh look useless comment. 
I like it. competitive mercurial hosting is good in my book. Now, if only lauchpad does the same thing for bazaar. It is so damn ugly.
It's certainly better than the folks that wore "VB developer" like a badge of honor well before it got dotnetified. One coworker of mine constantly laments the unfriendliness of Python (of all things) and pines for a day that software shops see the light and return to the "sanity" of VB + COM.
Hello facebook.
Always handy: they can be very sneaky.
Too lazy to Google. Why use Mercurial and BitBucket over Git/hub?
good, looks less like a github clone and more like a separate entity
I like the new design. But why have they removed the "explore"-function for repositories and other open-source projects on Bitbucket? Without this feature Bitbucket is a completly anti-social plattform compared to Github. From functional view Github is way better than Bitbucket, but only Bitbucket allows unlimited private repos. So me Bitbucket is good for private use, but for open-source projects Github is still the best plattform.
The only reason I see is to benefit of free private repos for up to 5 collaborators.
That's precisely why I use it. It also supports Git now, and is not strictly Mercurial.
I wish the wiki had more options than Creole. But I like the option of Git or Mercurial and ~~5 free private repos.~~ free repos with up to 5 users.
your preference for mercurial would be a reason.
The unlimited private repositories for free is also a very good incentive. If I ever need a private repo, bitbucket is my go-to.
All-natural Python enhancement from trusted Canadian pharmacies! Buy now!
In a related vein... Make a modular, plug-in based, IRC bot. Without using a 3rd-party library. Hard mode: Use Python3.
It looks facebook-ish. That additional scrollbar in repositories is still killing me.
+1 on that - but I'm still a github kid. Partly because of the lock in effect - most projects I contribute to are on Github, so forking and doing PRs there all the time makes it natural to put my own stuff there as well. Also, I like the Github team, their talks about Developer Driven Development leads me to think they have a good thing going. Atlassian is cool as hell too tho..
I'm game. I have about 5 years of Python; more than 25 software in general.
You can't just copy an easy_install script around on your system and expect it to work. Have you tried downloading the setuptools windows installer? http://pypi.python.org/pypi/setuptools#downloads Run that, choosing your ArcGIS python when prompted, and it'll put a working easy_install in your ArcGIS environment. After that you ought to be able to "easy_install geopy".
Just copy geopy folder from the geopy distribution into site-packages directory.
That's the first thing I tried. Doesn't work. (I basically just followed the install instructions on Geopy)
The logo is blurry and the 1 and 2 Pixels in the navbar that are not filled in hover state are killing me.
they also support git.
TO DO: * Find people who need a todo list program * ??? * Profit
Wow. I'm instantly sold. Learning Mercurial tomorrow. :)
pretty much how i feel as well. so much stuff is on github… unrelated thought: i really have to finish some of my projects there :D
2.5? that’s harsh. why do you have to do that? :(
Have you been to the roads? Traffic is appalling near any of the major cities. Just wasn't convenient to get anywhere really. NYC you don't need a car and can find literally anything. They have the public transport to let it scale.
Awesome! Just started using bottle for a project at work and I'm loving it!
i've been a github user for a while now and have been practically dancing around my office for the last 5 minutes or so. the ui and free features are slick.
I don't know why I'm getting down voted either, maybe people don't realize that (many) physics grad students like myself use Python extensively. Or they don't like hearing that people who code can make so little. Or they think I'm exaggerating, which I swear, I'm not. I pretty much reached my breaking point with grad school lately. It's not getting me anywhere because I won't be a tenured professor. I'm actively looking for software/quant roles in the financial sector.
I live and work in the NYC area. My rent is $525 a month. I live in a shithole, college town, high crime, ugly ass area, but its possible to be very frugal here.
I'm not sure if its brain drain or what, but there's too many PhDs every year. It's insane what it takes to make it in academia. Instead, they move onto the private sector, hopefully bring their advanced scientific knowledge, and contribute to society that way.
Depends on the wrapper, sometimes it's a lot easier to use the API directly with requests than using the wrappers :)
&gt; I live in a shithole, college town NYC ?????
wow it's hardly comparable to NYC and I think in NY/US you have more ways to live cheaply compared to Paris
Its unlimited repos, 5 free users to share the 6th user to share with is $$
Oops! Thanks for the correction.
Good god what. I'd consider myself pretty good at Python. Where are you finding these contracts?
I posted in that other thread but it seems to have been buried: It's possible you could use a [prefix trie](http://en.wikipedia.org/wiki/Trie) to store the data in-memory. I'm not sure of the number of words you have but I have no problems storing a 4M+ set of strings in my tries (I implemented them [here in C++](https://github.com/AeroNotix/algostructure/tree/master/C++/prefixtrie), [here in Python](https://github.com/AeroNotix/algostructure/blob/master/Python/prefixtrie.py) and [here in Go](https://github.com/AeroNotix/algostructure/blob/master/Go/prefixtrie.go)) what I would change is that you could wrap the C++ one with a Python module and have it so on insertion the Nodes are initialized with a count. If you ever insert that string again, simply increment the counter.
Or have a look at contributing to [SickBeard](http://sickbeard.com/) :)
| See also [Persistent dictionary recipe](http://code.activestate.com/recipes/576642/) with widely supported storage formats and having the speed of native dictionaries. I saw this on the [shelve documentation page](http://docs.python.org/library/shelve.html). It won't work for the guy on the other thread since it loads the file in memory but it looks interesting.
Line comments. Finally. 
So, as an average i've seen that the usual salary is 70k - 80k. That's the final money you get? Or it needs to be cutted off because of the reduction in taxes?
ah, get it. i think it really is. their deprecation policy seems even more conservative than django. since python 2.7 is the last 2.x-version, i personally would target 2.7 &amp; 3.1-3.3 wherever possible (since 3.1 accompanied 2.7, which means that if supporting 2.7, you restrict yourself to ≤3.1 features anyway, and 2.7 has many transitional features.)
* my [markdown editor](https://github.com/flying-sheep/markdowner) is currently being reworked. a working docutils-html5-writer would be awesome, currently i can’t really apply the same css to rendered rst and md documents * my [texture pack customizer](https://github.com/flying-sheep/Texture-Pack-Customizer) is finisched, but never gets any love from others (e.g. new versions of johnsmith’s pack added by anyone but me, or persistence reintroduced or a speedup, or…) other than that i have a few unfinished on my HD which i don’t want to release yet since they could still get major redesigns.
You are not a simpleton, that is not at all the normal way of doing things, it is just a quick workaround
Well, I think it's a neat idea, but I get that feeling in my mouth when people directly ask for my money. 
I think [pickle](http://docs.python.org/library/pickle.html) is what you are looking for. Its file-based and basically used for data persistence. Example: **Pickling** # Save a dictionary into a pickle file. import pickle favorite_color = { "lion": "yellow", "kitty": "red" } pickle.dump( favorite_color, open( "save.p", "wb" ) ) **Unpickling** # Load the dictionary back from the pickle file. import pickle favorite_color = pickle.load( open( "save.p", "rb" ) ) # favorite_color is now { "lion": "yellow", "kitty": "red" }
Not what I'm currently doing, but about a year ago: * 2.5 million daily users (multiply by a few dozen to get # of requests per day) * ~60 app servers * ~4 load balancers * ~10 DB servers (replicated MySQL) * ~3 mongo clusters (each with 3 machines) * ~10 memcached servers * monthly cost: six figures (managed, dedicated hardware)
To be perfectly honest, I don't get it. Where are the images store?
&gt;On the bright side though, Python installations peacefully coexist so you're actually able to install both 2.7 and 3.3 and make the best of both worlds. Not for OSX.
Decentralized is a poor word choice, *federated* (like Usenet is federated with multiple central authorities) would be more appropriate. Or IRC with several different server networks (notably Freenet and Efnet).
so this is an image gallery written in python?
It was built to scale, and it also plays video / sound and has a plug in architect to be extended to other media types(IE 3d models)
yes It already can be used for a stand alone video / music / image site. It also can be extended via the plugin interface to do a whole lot more(for example a planed plugin for 3d-models). But the funding is for federation so you can aggregate your media find new videos and see more media that is on other servers, much like you can get emails from other email servers. Once it is federated it becomes a whole lot more useful as a platform. 
So if it all worked out, you could have a website like youtube or flickr, but all the content is hosted on different servers?
You'll have to consult an accountant in whatever country/territory/city/district you live in to determine what your taxes would be man. Two people earning the same money in the same job in the same city might take home wildly varying amounts of money depending on and their country's tax law. You're asking a question that is so unanswerable it makes me think you must be very inexperienced with a lot of things, so I'll break it down a little farther than I normally might: the people on this thread are from all over the world and have no idea what tax laws are like for their friends, relatives, or even their own taxes if they recently moved somewhere new. All they know is the pre-tax number that they're told by their 1) offer letter or 2) friend who has the job they're talking abut. How much money you pay in taxes is between you and your accountant/tax bureau. No one, ever pre-calculates how much they personally paid in taxes last year when talking about how much they earn. Your question is like asking, "Are these numbers before housing expenses or after housing expenses?"
vim + tmux yes, together they form an awesome ide.
On this topic. I would kill for a tutorial on how to grow out of sqlite, using flaskr as a base, and step by step modify queries and schemas to use something else like mongodb, redis, or another sql like db such as postgres. I found someone who did a fork of flaskr and converted it to redis and it was a nightmare to try to wrap my head around the changes, and they split an elegant single file flask app into 20 different modules. 
&gt; area
I'll come on later on in the project to do frontend. Looks promising. Keep up the good work guys.
Sublime Text 2 + console + pdb.
PyCharm is generally the best all-around IDE, IMHO. Yes, it's bloated. It's even a little slow on old computers, but it does *everything*. It does JavaScript debugging using Firefox plugin, it finds definitions of symbols, it runs unit tests, it copies code to your servers. Having said that, if you just want some really good *core* features, WingIDE is better. Its debugger, in particular, is outstanding (far superior to PyCharm). It's fast. It's written in Python. And it's got a great community.
I just installed mediagoblin yesterday and I actually had a really nice time installing. Everything you listed except the named address thing could be done automatically, and the main issue with that is that you have a bunch of different webservers with different config formats(you could certainly tell the installer its url when you do installation, maybe tell it what server/where to configure?)
SublimeText2 with Vim mode activated.
I get the feeling it'll be shut down by some DMCA BS within a month of going live. :/ 
Sublime Text 2 (with SublimeLinter) + ipython I really should start getting into pdb...
Not to mention the huge, bold-text warning when you submit a question to this subreddit... =/
A readme/usage example would be nice ...
Well, to be honest, I use the wonderful [werkzeug debugger](http://werkzeug.pocoo.org/docs/debug/) and I print my debug information using the print statement most of the time. pdb is used in the rare cases where these 2 tools aren't up to the task.
pdb is really easy to use. It is most likely much more easier than you think. You simply add the following line where you want your program to break: import pdb; pdb.set_trace() When your program reach that point, it will enter the debugger and you'll be able to type python commands just like with the interactive python (mostly).
There is a tutorial with an example available on RTD (http://flask-pushrod.readthedocs.org/en/latest/getting_started/).
The "Vintage" package. It's bundled by default, but you need to enable it (or rather, remove it from the black list). See [this](http://www.sublimetext.com/docs/2/vintage.html) and [this](http://docs.sublimetext.info/en/latest/basic_concepts.html#vi-emulation).
How do keyword-only arguments work with Python 2.x?
Has anyone used Wing?
nobody mentioned Ninja-IDE (http://ninja-ide.org/), it does the work, I thought it might be a good idea to point it out if anyone else knows it...
[Opera Unite](http://www.opera.com/unite/) had basically that... but couldn't gain much interest, and was discontinued. It was all built into the Opera web browser. "Opera Unite is a new technology platform allowing you to share content directly with friends, without having to upload anything to a Web site. You can stream music, show photo galleries, share files and folders, or even host your own Web pages directly from your browser." 
I use wing 3.x EVERY SINGLE DAY. I've tested 4.x under a trial and plan to go to it full time soon. I picked up python about 10 years ago when I wanted to go from dev'ing in vb6 on windows to something more portable to *nix. I'm an electrical engineer at a fortune 300, so now I'm back in windoze. I work on a wide range of apps utilizing many frameworks/libs including SQLalchemy, wxpython, numpy, matplotlib, bottle, siemens load flow, .... Wing is a huge help!
I am sad to say but Diaspora seems to be going no where. It still doesn't support basic features such as Groups and Events it seems to be a glorified twitter relying on hashtags as the main way of organizing user content. IMHO that isn't good for trying to foster a Facebook replacement, also their user profile was lacking relationship status and other information you might want to have. MediaGoblin seems like it very well could be a Flickr / youtube replacement at the very least. 
Just purchased 4.x Pro... 
Oh, interesting. I wonder if this was simply before it's time. Public awareness on owning one's own data and the benefits of decentralization is increasing. Perhaps its going to take multiple stabs at this before a lucky group hits things at the right moment. Unite looked really cool.
use both WingIDE (version 1.x?) and IPython (version 0.5 ?) since year 2005. both are great helpful. recommend pep and pyflake plugin for WingIDE, ipdb for IPython. 
What in particular do you like better about Wing's debugger?
Aaaah. I misunderstood, then. In THAT case...I wish they were using Kickstarter instead of directly asking for money. :)
They are giving prizes like kickstarter and I believe the [Free Software Foundation](http://fsf.org) is handling the fund-raising and financial bits so it isn't being handled by some random guy. I wouldn't be worrying about being screwed over, any more so than any other kickstarter project. So feel free to donate as if it were a kickstarter project. 
Or at least it should be!
Same here.
Damn. As a machinist I make 45k. Need to switch careers.
Real man use butterfly
vim + tmux or vim + Conque here (trying to leave vim as little as I can)
Whatever format the [Pandas library](http://pandas.pydata.org/) saves its data in. I believe they're pickled numpy arrays.
I'm curious: What is the use of tmux in this setup? Why not use, for example, `vim --servername` and a virtualenv hook? Edit: I just noticed, hooks aren't implemented in virtualenv itself but only in virtualenvwrapper. My bad, sorry!
Probably something like Redis or MongoDB if a properly-configured traditional RDBMS can't handle it (which it probably can). Personally, I'd go with plain ol' PostgreSQL. Write to one table all day, partitioning only if your volume becomes a problem. Each night, collect the daily stats and produce reports, writing to "roll-up" summary tables. Drop/trunc the "daily" table and start over the next day. R, Python, and most other languages will have excellent support for this.
i wasn't suggesting that you said otherwise, I was stating that it could be worse. I believe the complexity is related to how a stateless protocol such as http originally conceived for requesting documents from servers has been morphed and bent(raped) to be an application stack. I don't think there's any abstraction that could be made for http that doesn't leak. So given http sucks, but it's what we have, wsgi provides for things comparable to other enterprisey web stacks like middleware etc without getting too ridiculous. I can't imagine how things like authentication and authorization would be handled without some kind of pattern like middleware. 
Same here. Eclipse + Pydev is incredibly feature-rich, and I appreciate the environment it provides--the major project we're on now is just set up in a way that doesn't quite jive with it, though. I did use it to great success on a couple of 1-week quick things though. I mostly just use PyScripter now for the syntax coloring and the interpreter in the tab--the autocomplete is nice, too.
There is no such thing.
just don't try to declare/set variable c, haha (Pdb) c = None # pdb looks at the 'c' and says, 'okay, I will continue'
Csv files are terrible for large data sets and are really prone to user input error. Same for tab delimited files. Much data has commas and spaces naturally or through uswlers, which can cause problems in csv and tabbed files. 
what python version does this apply to?
A lot of people have different ideas of what 'large' is. If you are trying to put your data into R, it better not be much more than a GB unless you are running in on a server with a bunch of ram. For taking a file out of a DB or a python scrape and throwing it into R, flat files are great. For storing data and querying it long term, flat files are terrible.
'Large' is pretty vague. Are you talking about something you're going to have to use a Hadoop cluster to analyze, or something that fits in RAM? There aren't many binary formats that are easily read by both R and Python. Maybe they can both handle connecting to the same database, but the only compatible binary format I found was Matlab's - they both have libraries. I'd pickle numpy arrays to a gzipped file for intermediate steps in python, and convert as needed if R isn't your main environment.
Flask extensions have nothing to do with middlewares. Flask uses WSGI middlewares where appropriate.
This is the first time I've heard of HDF5. Thank you.
Editra. Very light-weight (and written in Python).
MongoDB is slow with large arrays of numeric data BTW.
I've used PyTables, but not h5py. Any idea how they compare?
It was 2.x from what I can tell, due to how it handled print statements in the testing code.
ST2 is a multi-feature text editor, not an IDE.
Eventually in a DB of some sort. CSV as a middle ground for sharing with other tools (the world runs in Excel). Pandas, OOo, Excel and the csv module in Python handle csv just fine.
I've never used PyTables extensively - I considered it along with h5py when I started my current project, but I wasn't sure how easily I'd be able to access data from other programming languages if I went with PyTables. I went with h5py mainly because it wasn't adding anything on top of HDF5 so I was fairly certain I wouldn't have too much trouble if I wanted access from Java, C++, etc.
Uh, yeah, what he said. 
After looking into it (I've used Django and Flask, but never Pylons/Pyramid) it seems pretty similar, yes (although Pyramid renderers seem to let the code choose the renderer while the whole point of Pushrod is to expose it to the user).
Can recommend giving Pandas a look, large chunks of it are optimized in C and it's built from the outset for Numpy. If/when you outgrow CSV, it is trivial to build DataFrames from any dict-yielding iterable (e.g. various DBAPI adaptors with the right row factory configured). One word of warning against PyTables/HDF is that record lengths are fixed, so if you need to store a potentially long string, things start to look ugly quickly (note: I only know this from fixing another design, never invested time really getting to know PyTables). In this case a multi gb file and 10 minute runtime reduced to a 30mb sqlite DB and 15 second runtime. Edit: not many people seem to know, but with autocommit disabled and PRAGMA synchronous = 0 (which is similar to what you get with HDF5) sqlite becomes blazingly fast. As a compound tabular file format it's very hard to beat.
Pyramid does indeed let you choose which renderer to use inside the view code via render_template, request.override_renderer, and a number of other ways.
Which is pretty much what I said. Pyramid lets the client code handle that responsibility, Pushrod tries to figure it out on it's own.
I routinely use space-delimited flat files for data sets up to about 5GB with no problems whatsoever. If you're familiar with command-line tools (grep, awk, cut, etc), this makes it extremely easy to do quick explorations of the data. It's much easier than using a database for this purpose. I know it's not for everyone. (User input error isn't an issue for me, since my data are machine-generated.) But I don't think it should be dismissed outright: it's certainly a possibility if your data are not more than a few GB.
Looks great, but I found a bug already: https://github.com/Julian/Condent/issues/1
Tee hee :). Yup I doubt this will be the only one you find, there's still lots of obvious ones. I replied on the ticket, this mostly is just due to not being able to redent more than one container at once yet, gonna get to that in a few minutes. Thanks again for filing it :).
Ah yes, I was thinking about that, could I use that to be a scoreboard to of some sort? After all, I am using this for an experiment to see how caffeine affects typing
PyTables has more features and another layer of abstraction. I use pytables when i need pytables features and h5py when i just need to move data in and out of numpy. Both pytables and h5py websites answer this question (and link to the other projects answer to this question)
Why don't you take a simple database abstraction layer, like that of web2py, and create a plugin for it. Make it easier for people to use bottle and create non-trivial apps.
I use 4.x everyday at my job. I love it. Probably the best IDE I've ever used. It just works.
I am still looking for a replacement for [WPMTray](http://anappaday.com/downloads/2006/10/day-17-wpm-tray.html), since it crashes every so often. I find that much mroe useful than what you describe, since it measures my wpm when I'm in the flow of actually working on something. Just throwing that out there if you are looking for more projects. 
&gt; Flask uses WSGI middlewares where appropriate. What does this mean?
&gt; On top of that there is a very clearly documented interface to add middlewares in. Which is what I said earlier. &gt; That we're not reinventing the wheel for these things just because. It has little to do with that but with the fact a framework may have been built with an API that doesn't fit WSGI itself in the first place, notably because WSGI isn't always the best interface. I assume you thought from day one that Flask would acclimate well WSGI middlewares, there are older frameworks which thought the opposite (I can think of Django and CherryPy for instance) and as an extension interface, I've found those much easier to read than the start_response signature or the ever so abused environ dictionary.
No idea what that means.
Well thanks regardless. [This](http://imgur.com/tm5KW) is what I've got with geopy, and it's working wonders better than the alternatives.
In pyramid you can do: @view_config(renderer='sometemplatename') def aview(request): return {'a':1} Which is what pushrod lets you do, too, apparently. But in pyramid (like in flask) you can also do: @view_config() def aview(request): return render_to_response('sometemplatename') It's exactly the same as what you allow for in pushrod, AFAICT. Maybe there's some subtle point I'm missing.
Sure. But he also created Java, so I don't think that says much for his taste. ;-)
Can it do tabs? It's useless for me if it indents with spaces only. 
It can't currently. That's not something I'd need ;) but if you do want it I'd certainly accept a patch. Don't think it'd be hard to add it.
I see. But I'll rather complete my half-finished patch of reindent.py
I typically work with datasets which have millions of rows. I've recently switched to using Pandas and couldn't be happier.
I've got Wing at work and pyCharm for my open source development. Wing is sooo much better for debugging. I actually kind of prefer Spyder (free) for some parts of development over pyCharm.
When I did science fairs at school, I did it about molding cheese, now I see lots of people on here doing it with programming. That would have been a lot more fun.
I got a $30 student license, loving it,
I was on a project that was sifting through several terabytes of information. We used makefiles and SQL with PostgreSQL. I was very gung ho about using python as an alternative but it simply lacked parallel processing and the implementation for the python library interface to Postgres was too limiting as datasets hit past 1GB began to slow exponentially. I never dug into what was going on in the underlying c code but python simply couldn't hack it.
[here is the features docment](http://ipython.org/ipython-doc/stable/interactive/tutorial.html). and it's only for IPython console, there is a IPython Qt front and IPython notebook(web front).
sheep love *wink*
NYC
I did something like this once, but used sha512 hashes instead of words. https://github.com/MithrandirAgain/randomname
And then you install the VintageEX package and get command line goodies you are use to in vim as in "%s/hi/bye/g". https://github.com/SublimeText/VintageEx
I looked at it, but it seemed to be pretty much dead.
From what I can tell from the docs of Pyramid, those two are equivalent. In Pushrod you can specify options for the renderers (such as the template name), but you don't actually specify which renderer to use, that's found out by inspecting the request (while Pyramid seems to try to look it up from the template name).
I really enjoy flask and have built a number of sites and services using it. For simpler REST applications I tend to use web.py since I don't need as many bells and whistles.
You might want to give [IdleX](http://idlex.sourceforge.net) a try.
Wow, a sheep joke. How original.
Could someone explain where the linear correlation comes from across all variables? I find this fascinating but I don't quite grasp it.
Take a look at [Twitter's Rainbird](http://www.slideshare.net/kevinweil/rainbird-realtime-analytics-at-twitter-strata-2011). It wasn't released and they don't plan to do it apparently, but the concept along with Cassandra counters looks very good. I've implemented similar system with some adjustments for games statistics system but not planning to release it any time soon, I can share some code if you find it interesting though.
or cherrypy
Flask is a great framework, but this is why it's not so much a "micro" framework due to its dependencies on other large libraries. The good thing is the same person is responsible for both jinja and the network library.
Is that a good thing? http://en.wikipedia.org/wiki/Bus_factor
so you got a python joke then ?
Have you tried Flask-SQLAlchemy? That's what I use for my projects, you can switch databases by changing about one line of code.
I've had some fun using Flask Flatpages together with Frozen Flask.
Thanks for this. Such a perfect example. All of the doc's for Pickle are overly-complicated.
Vim!
turned debugging on and now the error is: UndefinedError: 'url_for_static' is undefined i'm really new to flask, so I apologize for these probably dumb posts.
according to the link it looks like Fall08 http://scripts.mit.edu/~6.006/fall08/wiki/index.php?title=Python_Cost_Model 
This example is very simplistic, just a small amount of combinatorial logic. It would take a lot of support/infrastructure work to use Python as an HDL for a non-trivial clocked synchronous design. The parallelism is not trivial to model in conventional programming languages. That said, I do use Python for system-level behavioral simulation, especially when most of that behavior is controlled by firmware.
Try web2py. You'll love it.
try: url_for('static',filename='&lt;your_filename&gt;')
We still have 15 open spots for the hackathon and $4500 is up for grabs. If you'd like to register a team, please state the team members you plan on joining with in the notes section. Free food, Free Drinks, Free accommodations. Come show us what you've got Los Angeles. 
COOL! Wish I could join, but I'll be gone that whole weekend :( Good luck!
Great post! I think you must've missed it but flask already has a pretty great quickstart *and* tutorial aimed at beginners: http://flask.pocoo.org/docs/quickstart/ http://flask.pocoo.org/docs/tutorial/ And the docs are generally excellent.
"return redirect(url_for('static',filename='&lt;say_hello.py&gt;'))" gives me the same error.
do you have to be in LA
Dude, seriously? from fabric.api import local from fabric.api import get from fabric.api import put from fabric.api import reboot from fabric.api import run from fabric.api import sudo Or... from fabric.api import sudo, local, get, put, reboot, run or... (less pythonic, don't do this) from fabric.api import * Come on. :| One big incentive to avoid '*' in your imports, other than the usual PEP 8 and hygiene reasons, is that it helps your editor infer where a function/object came from. I use Emacs with Rope, so if I use *, it usually breaks it. Whereas, if I leave the explicit imports in, it can tell where something was implemented. This makes it quick-n-easy to see the source of the libraries I use too.
You could use threads. threading.Event and threading.Timer could be useful. A more common use of threading might be this: import time import threading class Counter: def __init__(self): self.count = 0 self.keep_counting = True t = threading.Thread(target=self.run) t.start() def run(self): while self.keep_counting: print "The count is {0}".format(self.count) self.count += 1 time.sleep(1) counter_thread = Counter() raw_input("Press ENTER to stop the counter") # this block the main thread counter_thread.keep_counting = False raw_input("More stuff that blocks the main thread...") 
Every time I read HDF5, I mistake it for [HDFS](http://hadoop.apache.org/)... especially with the words "large data sets" :)
This is useful up until the point that you have so much data, that it starts taking 5+ hours to archive and copy the backup to a storage server... Then you have to drastically change your backup strategy.
Just curious, why do you prefer swooshing them all on one line Mob_Of_One?
I know they're all from fabric.api, you don't have to hammer me in the face with it and in so doing, shove all the relevant code downwards. DRY.
The preference, if there officially is one, is implied by the way dict objects are __repr__'d.
I'm not condoning my approach, but before the lazy version I commented out the following line from virtualenvwrapper.sh: virtualenvwrapper_run_hook "initialize" Which loads python and accounts for most of the startup time, but ultimately performs no operation, unless you've set up custom stuff on the initialize hook. If you have a custom hook, you could replace the line with sourcing your custom stuff instead.
This single post makes my three years of Reddit worthwhile. I salute you.
This is an awesome tip, although the one tiny downside I see so far is that tab-completion doesn't work with the `workon` command until virtualenvwrapper has fully loaded.
What doesn't work? Paste your traceback. Don't be satisfied with your 49-line program that solves a simple problem in a complex way. Don't even be satisfied with my example; it, too could be simpler and better. Strive for perfection, pberko!
Ok.. It was my own fault. No bug in the software. https://bitbucket.org/dhellmann/virtualenvwrapper/issue/161/usr-bin-virtualenvwrappersh-461-parse
I prefer one line too, but it's a little easier to read and scan if they are in separate lines imo
and rsync was good, and we all saw that rsync was good. When rsnapshot was made, it was also good and we saw that it was very good.
What's going on here? 
Rsync is better, but still slow on write heavy systems... And when you can easily load a single server with 32+ TB of data, rsync starts making a lot less sense, and Tape backups start looking a lot more attractive.
Async libs a part of the standard library? Exciting! I wonder if this has to do with the recent PEP 380 being a part of Python 3.3 ...
The printer is connected with a parallel to usb adapter. The printer is less then 2 years old. We have actually contacted manpaz@gmail.com and followed the steps and are still having issues. There is a group of 3 guys working on this who are very proficient with python.
I made an [aggregate self post](http://www.reddit.com/r/Python/comments/11eqtd/from_guido_on_mailpythonorg_the_async_api_of_the/) on this that was spam filtered 8 hours ago &amp;#3232;\_&amp;#3232;
Very excited to see what comes of this. Perhaps it'll be ready by PyCon?
&gt; but it's not as easy as it is in node Easy? Try chaining callbacks and call that easy again. JavaScript is so not the right language for that... I may get some flak for this, but I think that good async APIs require language support like automatic function currying and combinator support like Haskell's `.` operator or F#'s `|&gt;`. And I won't even mention the "M" word!
If you have three people who are proficient in Python working hard on the problem, that is three more people than you're going to have in /r/Python working on it since the chance of them having access to even similar hardware to you is virtually nil. You haven't indicated any attempt to bisect the problem, but for all I know you have already done that, too, and didn't feel the need to mention it in your OP either, which I confess is making me feel less charitable and that perhaps whoever it was that did so, was right to downvote your post right out of the starting gate. 1. Does the Python driver work with the printer on x86? 2. Does the Python driver other alternative architectures' Python implementation? 3. Does the Epson-supplied driver work with your printer on x86? Armed with the answer to these three questions, your team of engineers would easily know whether the problem lies with ... 1. The third-party python module; 2. RapsberryPi's architecture or hardware; 3. Some missing/differing library detail for the RaspberryPi implementation of Python; or 4. The printer device itself, the adapter, or its cable. 
I agree that Readability is good, but it is subjective. Your preference of readability might be different than someone else's. That's why PEP8 exists, so set standards for consistency, not just readability. So to some perspectives, you gain readability by using lines. In fact, PEP8 states: &gt;Imports should usually be on separate lines And only after that does it state that it is 'okay' to do them the way Mob_Of_One suggests. So the more pythonic way of doing it is the way it was done. Also, you posit that having them collected into one line is easier to handle in the case of removing some lib, or adding a new identifier for import from that lib. I suggest that the inverse is true as well. Having them spread out makes it easier to add an identifier for import (adding a line instead of changing one), or removing an identifier (removing a line instead of changing one). If I am filtering through a diff, it is much easier to spot a whole line that changed, versus a few characters in a line.
asyncore has been in the standard lib forever. It's not perfect, but it is quite powerful. I wrote a full featured http proxy (ssl support, http 1.1, persistent connections, pipelining, etc.) with no 3rd party dependencies using asyncore.
asyncore is for socket communication, this new effort isn't just for sockets.
Ah, you're probably right, though I've never seen Twisted, Gevent, and the like used in a non socket context. It's always about network clients/servers from what I've seen. 
It seems more like a reaction to Go, there has been a lot of news recently about how impressive it is.
On a tangent: I'm hoping they follow a lot of Christian Tismer's advice, I really like his ideas on implementing coroutines and continuations and such in pypy, his pycon talk about that and his experience writing stackless python was very enlightening.
Maybe not indefinitely.... :P but if you implement an algorithm for calculating pi, then sure (I've heard of one to do with shooting apples...)
Go through the whole os part of the standard library and you'll have a much better idea of what's possible.
Just because you can write async code with callbacks, doesn't mean you should put up with it. Modern high-level languages should have built-in support for high-level concurrency constructs that are not a pain to refactor and move around.
I agree. I tried learning Twisted, and later gevent. Twisted felt extremely Java-ish to me in a lot of ways. Factories for everything, interfaces, the naming scheme. Plus writing code in that callback style was just a bitch. Switched to gevent, got things done with much less code and the same or better performance, and never looked back. Plus I feel like when you're writing clients vs. servers, it makes even more sense to use code that's still asynchronous but not callback based.
 import sys import select import itertools import time def heard_enter(): inp,out,err = select.select([sys.stdin],[],[],0) for s in inp: if s == sys.stdin: c = sys.stdin.readline() return True return False def gimme(iterable): for it in iterable: return int(it) if __name__ == '__main__': c = itertools.count(0) print("Press &lt;enter&gt; to stop timer...") while not heard_enter(): print(gimme(c)) time.sleep(1) print("Timer has stopped.") 
I thought this was gonna be a bad metaphor, but this guy actually runs his public establishment using Python, Arduino and Ubuntu. Awesome! ::edited for exclaimation after checking out the pics on their website.
Yeah, I guess that was my point. It isn't too complicated, but it's ugly as hell. [Here's](https://github.com/hdeshev/node-postgresql/blob/master/test-connection.js#L42-44) the simplest example of chaining two DB operations and a disconnect command -- that code makes me claw my eyes out.
Even the fastest algorithm currently, the chudnovsky algorithm, does it so. It calculates 12 digits of precision every iteration edit. 12 digits, not 9
&gt; The Earthquake... &gt; For a moment I pause to grasp what has happenned in Japan... And the relief to have felt when I finally got that email from Shigeru Kondo telling me that's he's okay. &gt; Makes us wonder why we were still running this... TIL computing PI will cause hard drive failures and earthquakes.
I've never shared this before, for the lack of docs, but I made myself a lighter alternative to virtualenvwrapper, https://github.com/sharat87/virtualenvman. Created out of frustration with what a beast virtualenvwrapper was becoming. It has the mkvirtualenv, workon, lsvirtualenv and rmvirtualenv commands and autocomplete for zsh. Nothing else. It's a very tiny script, not too hard to read the source. I'll probably write a small readme and share it one day :)
Source: http://docs.python.org/py3k/whatsnew/3.3.html#decimal So make that up to 120x+ :)
But on the positive side it scales perfectly to multiple CPUs.
You can do this in Vim with [this](http://www.vim.org/scripts/script.php?script_id=2711) plugin. To create a new vertical split, call ScreenShellVertical inside Vim. Then you will need to use screen hotkeys, Ctrl-a-c to start a new shell session. To resize the split you can use Ctrl-a and type :resize 100&lt;Enter&gt;. To switch between the Vim split and the screen split you use Ctrl-a-Tab. Edit: you can also just use Ctrl-z and fg to switch between Vim and the shell.
[p-p-p-pyscripter!](http://code.google.com/p/pyscripter/)
I second pyscripter, I have been using it and I really like it. It is free, fast and easy to get setup and use. You may also want to check out ninja ide.
[Ninja ide](http://ninja-ide.org/) may be something worth looking into. I use it and like it quite a lot, it does have a python interpreter tab.
Up-voted because you did what the OP should have done. You described the video content. 
If you use a tiling window manager you can just use a standard text editor and an xterm. You can do this without a tiling window manager too, but it's particularly convenient with one.
&gt;starts to look ugly You are a very tolerant person.
Tmux with vim and ipython. Learn the default key bindings, it's worth it and portable. 
What's wrong with using two windows?
If you're using Win7, Gnome 3 or (AFAIK) KDE4, just open your editor, open a terminal, drag one to the left edge of the screen and the other to the right edge of the screen. They'll fill up their respective sides of the screen. If you're using Mac, you're out of luck, I think. If you're using another WM or DE on Linux, check your docs. Unless it's something deliberately lightweight like Openbox, it'll usually have a way to make a window fill half the screen.
with t-mux you can do vertical splitting and then you have two consoles in one window, one of which can run vim. 
Yeah, emacs would be perfect for this... you can easily put a shell on the right instead of the file (or anywhere).
Usually hotkey that runs the code being edited in the console window.
Use a tiling window manager. Lets you tmux style window management with native apps. Personally I use sublime and a few consoles all tiled. 
To elaborate on this point: * Tmux is a program that runs in the terminal, that lets you have multiple tabs, and split the current terminal into many smaller panes. * Vim is a command line editor that is really powerful, but takes a lot of configuration. I run this configuration around 50% of the time. The other 50% of the time I have two vim panes instead.
kate is awesome. i’d fulltime switch to sublime text, though, if it’d support editing/directory browsing via (s)ftp and a terminal panel.
It's also portable, so it's pretty brilliant to use on my flash drive.
Same for me! This is the best way to work :) Often I have 2 vim panes + 1 console, and a log pane in the bottom (if needed)
I use iterm and vim. So I hope between console and vim super quickly with tabs. Within each iterm tab, I normally have multiple vim tabs open too
Thanks for posting, never heard of it before, just downloaded and tried it and VERY happy with it, like how you can move the python interpreter around. Awesome!
I wrote spigot algorithms for pi, e and the square root of 2 at [my blog](http://programmingpraxis.com/2012/06/19/digits-of-e/).
You can change the Vim shortcuts to act like tmux if you like. 
Eclipse can do that, but I'd rather use vim and tmux.
Young'uns acting like vim is the shiniest latest shnizzle* make me smile. * Obviously unsure of "shnizzle" usage here, but then again, I am an old fart.
Haha, I just wanted to stir up controversy. 
Sublime Text editor is the best you can find around! With http://thecrumb.com/thecrumb/2012/02/10/sublime-text-2-shell-turtlestein-package/ this plugin you'll have a neat editor!
Oh you're right lol, my brain derped for a second there. 
Ooh, quite true. Good call. 
Keep in mind that if you really want to *calculate* it, then you probably don't want to spend half your time *printing* it every iteration.
emacs does this out of the box with a handful of commands. emacs C-x f test.py C-x 3 M-x ansi-term C-x o 
Gedit has embedded terminal plugins, but top/bottom usually. http://ubuntulife.wordpress.com/2011/10/09/gedit-multi-terminal-plugin/
This is more of an intro to Python for folks coming from other languages.
I thought so too, until she got to the `scapy` part :D
use Ctrl+p instead of Up
Shell just runs bash or whatever shell you want, so you could just use ipython.
You might be able to press up faster actually, since your pinky is already right by it.
Along this same line, dtach and dtvm combined provide the same features as tmux (one for window management, one for detaching and reattaching to sessions). I don't remember why I switched, but i like them a lot now. 
It's also possible to configure some non-tiling window managers to make this more convenient. On Linux I use sawfish with key bindings that will snap the current window to half of my screen (top, left, right or bottom) or to any of the four quadrants. On the Mac I use SizeUp, which offers the same thing (though less-configurable/easier-to-set-up than sawfish). I set this up precisely because my default way of working is terminal on the left, vim on the right.
And what do you think of Pytools for Visual Studio? I tried it a few times, I'm a Python beginner, and it looked pretty good.
When I press Alt+tab my pinky is on the ;, right next to the p. I have Caps Lock bound to Ctrl so Ctrl+p is a total distance of 2 compared to (what I perceive as) about 6-7 to `Up`. The arrow keys are fucking evil as far as I'm concerned anyway, if you use them as a normal part of your workflow you're losing out on a ton of working speed. Almost as bad as using the mouse.
I'm surprised no-one's mentioned Editra, which is written in Python. The shelf can hold a Python console, and it's dockable so it can be dragged to whatever gravity/orientation you want. It has all the nice IDE stuff found in Geany and much more besides :) -- that's why I switched from Geany to Editra.
I agree that its very powerful, but I just dislike all the overhead.
Yep. I recently have started running pycharm with the console docked to the right. Or, I'll undock it and float it over to my second monitor, depending on what I'm doing. Currently, I'm building a shell based on cmd that I like having running in a floating window. After an edit, I can hit the re-run (`&gt;&gt;`) button to see my changes.
I find that much harder to read than the standard way. Without static type checking, I don't see what you gain.
No show-stoppers, as far as that goes.
/thread
This doesn't save any characters and doesn't seem to add anything else.
SciTE is exactly what you're looking for: http://www.scintilla.org/SciTE.html
There are other asynchronous systems that may not involve a network at all, and may not involve multiple processes, and certainly don't involve manually handling the result of `recv()` calls. An asynchronous API would address those cases.
this isn't a solution until it is automated so that you are not doing the same minute-long dance every time you need to start working.
Please tell me more about these other applications. I don't know very much.
SCAPY is about passing the parameters to assemble packets, fairly straight forward.
Is there much of a difference between tmux and screen?
I might have to try that out, though I'm already pretty set into geany.
Komodo IDE 7
IIRC, IDLE itself has this mode.
It depends what you are doing. If you are doing sysadmin scripting or small website stuff, I prefer vim. If you are working on a large Python application, Eclipse + Pydev is the best solution in my experience.
I meant after you hit enter. On some laptops at least the arrow keys are two rows directly under the enter button. 
Oh nice. On coursera? Or the actual classroom class? I'm on coursera. 
I don't know about cmd.exe, but that's just a small shell-script away on my terminal.
I use PyCharm as my main IDE right now, I like the fact that it can understand pretty much everything (javascript, HTML, even jinja2 templates), but the console is where I feel it lacks. I use ipython usually, and things kinda blow up with Pycharm and ipython :(. Same thing with any form of a re-loader for cherrypy/web.py, just bugs out and doesn't work right. 
I'm taking the class as well :)
vim + conque http://conque.googlecode.com/svn/wiki/screenshot/unix.jpg
The first half is very informative and shows some really good examples of processing pipelines and such. The second half is Dave being awesome, and actaully really helped with my operating systems course at university
Database access, file access, background threads for long-running tasks, that sort of thing.
Of course, this now make sense. I had not thought of databases as async as I only work with small hobby ones that return the results very fast. Now I also see why file access and other threads can be a problem too. You're amazing.
I tend to use map for simple stuff like this. It looks cleaner, to me. Also, I didn't know you could pass a key for min; that looks handy.
I agree, this seems more suited to /r/learnpython.
I wouldn't mind participating. I don't know how much time I'll have, but I've got 10+ years in Python, and as many in the NLP area. Haven't done anything with QA in a long time, but it'd be interesting to get back into it.
The differences are summarized here nicely: https://www.wikivs.com/wiki/Screen_vs_tmux 
Fantastic! 
I am one of the developers so I am probably biased. The biggest difference is that Django follows "explicit is better than implicit" while web2py follows "everything should have a default", therefore programming web2py feels more like programming Rails although you use Python syntax. Django has a slicker and more customizable database interface (what they call admin and web2py calls appadmin). Django has more third party modules and more users. Web2py has a web based IDE (which we call admin, one can also use the shell as in Django), ships with more stuff (role base access control, login modules, credit card payment apis, wiki, a distributed scheduler, more db adapters than any other python ORM, support for Google App Engine, memcache and redis APIs, etc.). You can find equivalent modules for Django but they ships as different packages (with their own django-*) so you have to be mindful of version issues and conflicts. In web2py we pick the good stuff and ship it with the core. Django and web2py have different definitions for the term app. Both support multiple concurrent apps but, in Django an app is a part of a project, and can have multiple apps but only within one project (they share the settings and must share modules). In web2py an app is a project and multiple concurrent apps do not share anything (db, sessions, cache, python modules, internationalization rules) unless you want to. This means in one web2py instance you can run multiple apps concurrently without any conflict even if they are not designed to work together or use different versions of the same modules. The web2py admin (the web based IDE) allows you to hot install and un-install the apps (locally, remotely, from github, to GAE, to Openshift) without need to restart the web server. Web2py has always been very strong on security. For example, we had default escaping in templates and CRSF protection since 2007. web2py allows pure python in templates {{...}}, while Django uses a custom template language. Django makes a distinction between development (tracebacks are exposed) and production (tracebacks are lost unless you integrate with third party tools). In web2py there is no distinction. On any error the visitor is issued a ticket, the traceback and system status are stored, sorted by error type. The administrator can browse the error tickets. web2py is the only Python framework with a built-in pluralization engine which, for example, supports languages with multiple plurals. web2py is considered by many as "less Pythonic" than Django, whatever it means. Our goal is not to be Pythonic nor to be the fastest framework on "hello world" apps. Our goal is to make the easiest framework to use maintain. We made a promise of backward compatibility to our users which we maintained since web2py 1.0 in 2007. EDIT: Web2py won some awards: 1) http://www.infoworld.com/d/application-development/pillars-python-six-python-web-frameworks-compared-169442 and 2) http://www.infoworld.com/slideshow/24605/infoworlds-2012-technology-of-the-year-award-winners-183313#slide23 EDIT2: forgot to say because we had the features since 2007 but it is important: web2py does automatic migration. This means that when you change the models, it ALTER tables for you (create table, add column, remove column, change column type), without you having to take any action.
Thank you, I have updated the source.
I only ever have 1 panel/tab open for iterm2...any benefit for having more than one when you are running tmux?
Loved this solution! Thank you :)
Hey /r/Python - We’ve built a site where you can learn Python, Ruby, and JavaScript in a fun, engaging and interactive way. How is LearnStreet different from other learn-to-code sites you ask? UI/UX: A key aspect of LearnStreet’s courses is its distinct UI/UX. In order to see this, simply sign up! Multi-modal: Our courses are designed for beginners, and we have multiple ways to help you learn, including live chat, Twitter, Q&amp;A, hints, videos and background material. If you don’t know which language you want to pick up, check out our teaser videos in the Courses page! http://www.learnstreet.com/lessons/languages/javascript Code Garage: If you already know how to code, check out Code Garage where you can try your hand at cool coding projects like building a Mastermind game or a Sudoku Solver. http://www.learnstreet.com/cg/simple/projects/javascript Dev Tool: We’ve culled the web to provide some key resources beyond the core programming language that will help you gain a better understanding of what it takes to become a competent coder. http://www.learnstreet.com/dev_tools/ We just launched about a week ago and would love to get your feedback. We are looking for expert coders to help build out our other courses so check out the Contribute section on our site as well. Coding Starts Here! -The LearnStreet Team
Must have been Candlejack out t
What's the best way to receive update news? I use web2py for work apps and I need a solid way to be notified. Thanks for all your work btw
If you checkout from git at least it works with Python3 today.
If you log into the admin app, you will see a button that notifies you if there is a newer version. Click on that button, your version will get updated.
PyTables is oriented towards table-like data. h5py is a more straightforward (but still very pythonic) wrapper around the C hdf libraries. If you want to store a 3D, 4D, etc array or just want to easily store and quickly access index-based slices of your data, then h5py is probably the way to go. If you want fast queries or optimized offline calculations (without loading everything into memory), then PyTables is a better option. That's all an oversimplification, of course, but it's the basic idea. Also, as has already been mentioned, h5py doesn't add any extra metadata or do anything special to the HDF files. If you're going to access things from another language, it's usually easier to use h5py.
Well you have two options: 1. CTRL + ` (~) will open up a little terminal below, don't worry that it's missing the '&gt;&gt;&gt;' it will still interpret Python. 2. If you are in a *.py file ST2 will automatically know that it is a Python file land if you type CMD + B (or go to the build menu and find the key combo) it will automatically run the Python code in your open file below in the window. Let me know if you still can't get it to work. 
I've been using the Build System within Sublime Text 2 for something similar. Wrote a small little blog post about setting it up with Fabric http://simoncoulton.com/using-fabric-with-the-sublime-text-2-build-sy Nettuts (also linked in the above post) has some great Sublime Text 2 tips with regards to the various plugins that are available.
Or it could be a long-time, low-grade desire to minimize the differences between the Twisted, Stackless, greenlet, concurrent.futures, etc. APIs. Not saying that Go and node.js aren't influences, but I don't think it's specifically a reaction to an existing language. Stackless programming, after all, feels similar to Go; because both have the CSP heritage.
Using it with another ORM doesn't really make sense. The whole framework is quite tightly coupled.
Short answer: you can use SQLALchemy but it does not buy you anything and would break forms. Not worth the trouble. Long answer: Django has an ORM while web2py has a Database Abstraction Layer. The DAL is closer to the SQL than an ORM. It supports inner joins, outer joins, aggregates, nested selects, etc. It is in fact quite similar to SQLAlchemy. Web2py comprises of modules and these modules are, in a sense, less tightly coupled than Django's. For example the DAL, the template language, and the helpers are each implemented in their own single file module and they can be used outside of web2py. They have no dependencies on other web2py modules. On the other side, when put together, they are more tightly integrated than other frameworks. The main issues is form generation and processing. If you need a create form for a model, the helper needs to gather information from the dal. In this respect web2py is not different from Django. If you use SQLAlchemy, you cannot take advantage of all logic built on top of DAL (access control, form processing, etc).
I like web2py, unfortunately PyCharm doesn't work too well with it D:. As far as I've read, they're not planning on working on support either. 
Too bad. web2py is the most requested feature. Anyway, it works with Eclipse and Rad2Py. I think Rad2py is one of the best python IDE.
That will do - Thanks!
Ready to blow your mind? * http://net.tutsplus.com/tutorials/tools-and-tips/sublime-text-2-tips-and-tricks/ * https://gist.github.com/1311735 * https://gist.github.com/1207002
Agreed. As a current Django dev who is free to change as long as it gets the job done, it makes me want to try it out!
You'd be surprised at the number of people that claim to know python that just don't. That said, the interview process should filter out anyone that doesn't match up properly. And while I think there's more python jobs out there than people looking for them, I don't think there's that many more.
I don't understand why you were downvoted... For what it's worth, I agree with this sentiment wholeheartedly. OP should really just get out there and code.
I went through some udacity lessons starting with the intro to see if I missed anything. Turns out I missed a lot of odd things, like indexing an array with a negative number. Magic!
github?
Make something tangible in python and post it publicly.
Can you link to the OpenCourse project? I'm curious to see what it's like.
https://www.edx.org/courses/MITx/6.00x/2012_Fall/info
It's challenging but I enjoy it. I felt a real sense of accomplishment when I figured out some of the problems. 
Why do you keep italicizing python?
I hope you don't think that was obvious.
I'm not entirely sure what this does?
Same here. But, Im now interested to find out if I can adapt this plugin to simulate dice rolls on skype text chat. :D
If I was looking for a good programmer, the *last* thing I'd look for was a PHP cert.
Oh there are... reasons. For example, when computing one's starting salary for certain civil-service positions, certs are entered into the calculation matrix and will bump you up toward the top of the range. I would imagine that the semi-official ones that cost money would be the only ones that would apply, though.
I like this a lot, but I don't like the use of globals within the plugin functions. The plugin loop is a good idea, but I think the plugin interface could be abstracted better (have a better API, basically). Maybe something like "on_message()". This would also be a perfect use for classes (each plugin sub-classing a Plugin class), so one won't have to rewrite the initialize function each time, but can override it if they want to.
I'm currently looking into a job that is more flexible as to what certs they'll take for inclusion in that matrix. Of course, the starting salary range is pretty low, relatively, so I'm investigating anything that will get it as close to the top of the range as I can.
BEST Python hacking course around. Not for amateurs. Assumes you already know networking, programming in another interpreted language. Was the best [Python](http://www.securitytube.net/video/3786) class Ive ever taken.
I'll certify you for $5 if you write me the following code in python using only core libraries: 1. Compute all prime numbers between 0 and 65335 2. Write a random number generator 3. Write a program that will find what digit of PI a given number appears in (such as your birthdate, or your ssn. Whatever number the user inputs) 4. write a function that compares two strings without conditional branches. 5. Write a program that grabs minutely info (stock price, volume, etc) for every stock listed on the NYSE.
Best is "personal". It doesn't run on OSX as far as I can tell. So that is out for me. I really like PyCharm and it runs on all three platforms. I do wish they supported web2py though...but I thought everything was done "in" web2py and an outside IDE isn't really needed?1 
The web based IDE is a convenience. Most people program in web2py very much like you would program in other frameworks, using a shell editor or IDE. I use emacs. The problem is that third party IDEs do not understand that some .py files in web2py are not module and are executed in an environment therefore cannot autocomplete some variable s which are defined in that environment. Eclipse can be tricked into doing it. I believe Rad2py understands the environment.
&gt;Tape backups start looking a lot more attractive. Hahahaahahha Nope.
I got a lot out of the udacity cs101 course.
Ahh, very nice. Thanks!
Ah, decent reference thanks. I also learned a new word - Idiomatic =) 
Nevermind, I just tried this and since it pops open a terminal inside vim it's almost better than the setup I have right now.. I can use the extra screenspace for another file instead of a terminal! Thank you!
Sorry to be that guy but surely you meant "my room-mate and I"?
That's completely awesome!
Totally!
Reading your comment made me think less of /r/python
Nice job! The line intersections are great, however when the said lines meet with axes, there are some glitches (e.g., the right end of the blue line in the duplicated XKCD comic). This is unacceptable.
You wouldn't instantly fail, no.
awesome!! both the blog post and the XKCDify.. and waaaay better implementation than on Mathematica or on Matlab.
http://lmgtfy.com/?q=python+javascript+translator
...aaaaaand this is why I love Python....
Instagram for scientists.
Chris Webber writes about this at http://dustycloud.org/blog/mediagoblin-campaign.
It is wholly up to you, but http://stackoverflow.com/questions/120926/why-does-python-pep-8-strongly-recommend-spaces-over-tabs-for-indentation . From http://www.python.org/dev/peps/pep-0008/#tabs-or-spaces : &gt; Never mix tabs and spaces. &gt; &gt; The most popular way of indenting Python is with spaces only. The second-most popular way is with tabs only. Code indented with a mixture of tabs and spaces should be converted to using spaces exclusively. When invoking the Python command line interpreter with the -t option, it issues warnings about code that illegally mixes tabs and spaces. When using -tt these warnings become errors. These options are highly recommended! &gt; &gt; For new projects, spaces-only are strongly recommended over tabs. Most editors have features that make this easy to do.
i know, and i agree that one should always stick to the style of the code around you, but i strongly believe that encouraging to use spaces for new projects a wrong decision: 1. tabs are logical: one tab per indentation level 2. related: spaces already have a different meaning in python: separating tokens. why don’t we use tabs unambiguously for indentation, then? 2. tabs are customizable: you can set the tab length to whatever you prefer in any useful editor 3. tabs are easier to get right manually: hit tab once to create one, hit backspace once to delete one, never again indent one space too much or too less 4. tab-indented files use a little less disk space ;) but again: if i work on foreign code, i just indent how they do (unless that means “inconsistent indentation”, then i get the hell away from the code) PS: see also [here](http://stackoverflow.com/questions/119562/tabs-versus-spaces-in-python-programming#answer-1777008)… the best the spaces-faction can offer is „because PEP8 says so“, we have arguments!!!!11eleven ;)
From the off Guido is inviting discussion of adopting - as in un-monkey-patching - gevent. Its right in the invite, and its also in the mailing list: http://mail.python.org/pipermail/python-ideas/2012-October/016424.html But yes I to see a swing towards crowning Twisted (presumably with enough PEP8 that its not source-compatible with Twisted) :( My own concern is about completion-based IO. And my hope is that gevent is the way forward. I've just posted my 2 cents to the google+ thread and Guido replies..
Looks like a linking error possibly. 
Skulpt, not skulp. http://www.skulpt.org/
&gt; there are some glitches (e.g., the right end of the blue line in the duplicated XKCD comic). This is unacceptable. Well... fix them! :)
For me that's exactly describing what makes it great !
You are right. Thanks :-)
Oh! I had no idea about that. Hmmm, is there something that explains developing it that way? Just curious.
That's about what they are worth.
regex module looks nice, like it's mostly just incremental improvements, but nice nonetheless. Think I'm looking forward to most would probably be the `subf` function and accessing groups with [].
If you are not too far along with this, you should use Cython (www.cython.org) for this. This generates your C module from your python code. You add type declarations to make it go faster. It's way easier than learning the python C-API. There is even a module pyximport which will automatically (re)build your module as required; no messing with distutils required.
I will admit that until recently I was rather indifferent to py3k but since 3.2 and even more with 3.3, I feel like py3k is getting more and more attractive.
Any reports on how much this actually speeds up code? Haven't had time to play with it yet.
I think that it helps if you replace every instance of the word "compile" in the article with the word "package", as in packaging for distribution to others.
For starters, you can update the site title to something more descriptive, for people who bookmark your site. "lint.io" generally gives off different idea about the site than it actually is. Keep up the good work!
Well, in fact, I'm planning to add more linters for other languages, such as javascript, ruby and so on. Then that name maybe will look more intuitive.
I'm experiencing a little problem with my tool and github api, so for some repositories it can show "0 errors". Sorry for that, I'm fixing it now. *update: seems like working now.*
Great work. A few things that would help me use this tool more would be: 1) Support for [BitBucket](https://bitbucket.org/) hosted repos. 2) Support for private repos with private/hidden reports obviously. Keep up the great work. I'll be sure to check it out again when I have some public repos hosted on github. 
You may want to explain what "lint" itself means.
You are right, I hate that error too :)
pep8.py is dumb. and i don’t mean that i don’t agree with PEP 8, it’s just that pep8.py has W191 (indentation contains tabs) PEP 8 only says that one should be consistent with the space, so a consistently tab-intented file is fully PEP-8-compliant. then it sucks detecting implications from earlier warnings (i.e. if you turn off offending warnings, it will just continue to spawn random ones), e.g. “E121 continuation line indentation is not a multiple of four ” if i indent with tabs that comes all the time, too. hey, pep8.py, python interprets tabs as 8 spaces, so if i indent with tabs, everything is always indented with multiples of 4, you liar. i also prefer to indent blank lines to the same level as surrounding code, which pep8.py doesn’t recognise and instead dumbly says “W293: blank line contains whitespace” as if that would be some random whitespace somewhere.
additionally, any time you install a module, it gets compiled (amongst other reasons, because it resides in a system directory where users have no write permissions)
From [pep8](http://www.python.org/dev/peps/pep-0008/#tabs-or-spaces): &gt;For **new** projects, spaces-only are strongly recommended over tabs. Since a project is already hosted on github you could assume it is not a new project, or at least is not starting from scratch. So I would say that warning enabled would not make sense in this context. 
Jep. Furthermore, the only reason why spaces are recommended is that guido uses spaces, he even said so once. It could be as well tabs if he had, say, a better editor at the time. For using tabs however, there are reasons, the most important one being that they are more logical: 1 tab per indentation level. 
I was defending your point...
This article is a bit dated. In practice, this compilation is done automatically by most packaging tools. If you follow industry best practices (I recommend [pip](http://www.pip-installer.org/) and [virtualenv](http://www.virtualenv.org/), but you OS package manager probably does it too), you pretty much don’t have to think about this at all. That said, I’m a big fan of developers having a good theoretical understanding of how their stuff works under the covers, so if you’re not familiar with Python bytecode compiling and importing, it’s helpful to read up.
Yeah, looks like the error message is wrong.
I get a 404 if my repository name contains a period.
If you don't know what lint means, then you're probably not interested in this tool.
Not gonna lie, I usually get peeved when people do this (I used to, but stopped); but this one had a full page of relevant results right at the top--most of which were mentioned here. I for one support this use of lmgtfy.
Why do you consider rooting the device to be 'unclean'? 
[$ man 1 lint](http://www.rootr.net/man/man/lint/1)
Joined too. I'm taking this class along with computational investing. here's the link if interested https://www.coursera.org/course/compinvesting1 the computational investing class uses python also.
Any real editor can handle spaces just as easily as tabs, and generate the right number of spaces when you hit the tab key, so that's a ridiculous argument. You do disagree with PEP8. PEP8 says to use 4 spaces per indentation level. And it strongly recommends spaces instead of tabs. One of the incidental benefits of using spaces is that you can distinguish hanging indents apart from a level of indentation, i.e. def long_function_name( var_one, var_two, var_three, var_four): if True: stuff: instead of def long_function_name( var_one, var_two, var_three, var_four): if True: stuff: with 4 spaces per tab, and 1 tab per indentation level, you cannot do this. Ultimately you do not have to follow PEP8, but if you release code publicly then you should be conservative to avoid annoying other people.
Ugh. I have been happy with Python for many years now. But Twisted is enormous and baroque (unnecessarily). If Python crowns it then I am going to find a new language to use for new projects.
Personally, I don't think it is reasonable for core Python to acquire a dependency on 0mq.
I would not follow 9 year old advice on this.
Thank for the link. I joined.
These exist? Never heard of them..
I love you
I blogged a bit more http://williamedwardscoder.tumblr.com/post/33847950854/python-stdlib-to-get-async-apis Reading through the mailing list though, I was pleasently surprised how great the grokking is
Didn't even know about this site, but will definitely use it, thanks!
put that in the read me :) maybe do something crazy like provide an example. 
Once enrolled do you have to complete the mini-projects to get access to the next lot of lectures &amp; projects? Or will the whole course content become available to me regardless of my apparent inactivity? 
The latter.
Cool. I signed up.
Thanks, just signed up
3.x *is* 2.8. Features that make sense have already been backported either directly to 2.6 ([3.0 features in 2.6](http://docs.python.org/whatsnew/2.6.html#python-3-0)) and 2.7 ([3.1 features in 2.7](http://docs.python.org/whatsnew/2.7.html#python-3-1-features)), or in the form of `2to3`.
Never heard of it but it looks nice. Quickly did the first quiz because I have no idea when PDT is.
I'm enjoying this class immensely so far. First week's strings, operators, native data types, flow control, and functions, so about as far as I've gotten in any of the python books I've embarked on. Glad to find out that video lectures hold my gnat's attention span. Looking forward to learning enough .py to be dangerous(tm).
fixed!
They're using 2.6 or 2.7 I believe, with very limited library support and their own programming environment (the former caused by the latter). Didn't really do it for me. OTOH, Coursera has three or four other Python courses, so it's worth looking around.
You notice he didn't say he was running it. He just said it was more attractive. 2.8.5 would have been pretty attractive too, and he'd actually be running it.
I've tried taking courses there but the notes for them seem incomplete, rushed and shallow. The lectures are abridged versions of the notes and don't help that much. The whole point of studying in your own time is that you get to explore what you're doing, a pace is good, but given everything that's online I'd expect something more from them. I was doing the numerical computing class there but dropped out fairly early on because of all the really bad short cuts they were taking to "teach" us something. I think the problem is with the fact they are just taking university classes and putting them online. And being honest a university class is mostly just a way to see if someone can jump through hoops without care for their actual ability to do anything. Worse they don't give you a piece of paper with your name on it that's recognized by anyone.
Thanks!
WOW! This is great, signed up, but is this a good site? Are there other sites with free courses?
I took the Coursera's Crypto Class on the first semester and I must say that was the best course I'd ever taken. The lectures' structure makes you really go for it, and don't let you lose the interest. I totally recommend it.
PDT stands for Pacific Daylight Time( -07:00 GMT)
Neither do I. I Just google it hahaha. Sorry!
Well I just clicked that link and out of a sudden a scary old man showed up with a freaking blue shirt full of coloured little fishes. That was really something.
I should say that was not your phone's fault...
2014 for the release date? I hope it's a big update, or something... 
Maybe but it wouldn't be me who'd do it as I don't think it's a particularly interesting project. Skype is going to get rolled into Live Messenger in the near future.
 python -m py_compile &lt;filename&gt;
I have python for android on my X2 and it didn't require rooting the phone.
what did you use then ?
OK but why. I don't understand much of this, so how is it different from twisted and the rest?
doesn't this make it more likely to take forever to be Python 3 compatible?
[something](http://stackoverflow.com/questions/11182765/how-can-i-build-my-c-extensions-with-mingw-w64-in-python) similar?
There are two ports of web2py to python 3 but we do not advertise it because of backward compatibility. From an official standpoint web2py will never be ported to python 3. web3py instead will run on python 3. It will have some differences with web2py.
From what I've seen, the differences should be minimal at best. They suggest the website because programming in a browser is more accessible than telling you where to go install the language AND all the libraries. Not that installing is hard, but the website is still easier to use and lets you "hit the ground running" a bit faster/more reliably.
I do not know because web3py does not yet exist. web2py will continue exist and will continue be backward compatible. web3py will be a different animal. They may share some libraries (probably the database abstraction layer, the helpers, and the template language).
It's very relevant in Python. It wasn't an arbitrary choice to choose tabs over spaces in PEP-8. The author(s) reasoned that having some people use spaces and others use tabs makes the body of source code less usable. For other things, like formatting a document, maybe your use of tabs vs spaces is a trivial choice, but for source code, especially Python code, everyone agreeing on one standard makes a big difference when sharing code. I think people trivialize the tabs vs spaces argument in python too much, because it isn't just a matter of style in Python; it's part of the structure of the code. So, if you choose to use tabs in your code, that's fine, but keep it to yourself ;)
Anyone have a good link for where to learn more about this? The ones I've found are * [PEP 425](http://www.python.org/dev/peps/pep-0425/) * [PEP 426](http://www.python.org/dev/peps/pep-0426/) * [PEP 427](http://www.python.org/dev/peps/pep-0427/) (the latter of which seems to be the most general) but I would like to find a higher level overview.
Huh? first you say it was no arbitrary choice that a specific type of indentation was chosen, then you say the reasoning for that was consistency. But with no word you said why *spaces* where chosen, so you used a strawman: your argument does not make the space choice less arbitrary at all, your whole post could also defend the tab choice. 
I don't know that anyone's written a blog post about it. I'll try to give you what I know. Basically they're saying binary python packages can be distributed as zips. Some meta data is in the filename. Then more information and code-signing is stored inside various files within the zip with standard file-names. The effect is that a package can be installed by unziping the "wheel file" into site-packages, but a pacakge manager, like pip, can verify the code inside the package, download dependencies and automatically know which package to download (based on the filename). Overall it's a pretty simple format, but the python-dev people are giving some valid criticisms.
In practice Description: is the only multi-line value. It receives far too much attention in the document when a simple textwrap.dedent() would do, given that you don't actually need to parse the description out of PKG-INFO. The complicated multi-line treatment is copied from the predecessor, Metadata 1.2. Metadata 1.3 (PEP 426) adds: http://www.python.org/dev/peps/pep-0426/#summary-of-differences-from-pep-345 There is plenty of distutils in there. Wheel just lets you create a package with distutils (actually distribute), and later install it without distutils, but the format is simple enough that you can also create it without using distutils at all. It is designed to be a distutils escape hatch.
What field do you work in? Python can be either a godsend or an afterthought depending on what you want to do, what you need to do, and what you're allowed to do in the workplace.
I updated the OP to clarify. I'm a trainee at the moment, but with no interaction or anything to the software developers team.
In Terminal, type: python --version Does it point to the 2.7 install or the 3.2? Also: &gt;If you don’t choose an installation directory—i.e., if you just run setup.py install—then the install command installs to the standard location for third-party Python modules. This location varies by platform and by how you built/installed Python itself. On Unix (and Mac OS X, which is also Unix-based), it also depends on whether the module distribution being installed is pure Python or contains extensions (“non-pure”) http://docs.python.org/install/index.html
-_- I don't always have an internet connexion %&amp;@*).
You used "where" where you should have used "were". I guess we're even now. My argument isn't that spaces are better than tabs, or that tabs are better than spaces. It's that python code should use spaces. I actually wrote an argument for spaces over tabs in a different post. Assuming fixed-width fonts, I argue that code looks the same across all editors with spaces; whereas they don't look the same when using tabs due to the fact that editors usually allow tabs to be whatever number of characters the user configures them to be. An unintended consequence of this that was mentioned by another poster is that code written to the 79-character PEP-8 specification may actually wrap when the tab stop is 8. Another argument I have for spaces is that I use vim a lot when coding and vim has this annoying but understandable way to deal with tabs: when you're on a tab character, the cursor is on the last position in the tab width, whereas if you go into insert mode, it jumps to the first character. This makes editing a fixed-width document odd, to say the least. It just doesn't make sense to have a non-fixed-width character in a fixed-width document. I'd like you to think my argument is well-reasoned and makes sense, anonymous internet friend, but if you don't, I won't lose any sleep over it.
I work in second-level support, taking escalations from our help desk. We're a software company that develops POS applications for specialty retailers. I use python mainly for its text processing. Every so often we get log files or flat files that we use as databases that have some kind of issue, something that would take hours and hours to tweak or analyze by hand. I'll whip up a little script in maybe 15-20 minutes and make everyone's problems go away. I read on reddit a little while ago someone's post on this subject. He said if you know how to program and you work as a programmer, that's no big deal. If you're not working as a programmer, and none of the co-workers in your department know how to program, it's like having a superpower. I can attest to that. Your mileage may vary.
Once you know how to program, you'll probably find all sorts of things you can do with it. More or less any boring, repetitive task you're doing on a computer can be automated. There are several domains where Python is used: * Scripting &amp; command line tools, especially on Unixy platforms (i.e. everything except Windows - you can also use it on Windows, but it's less common) * Web development - perhaps not quite as popular as Ruby, but there are high-profile sites running on Python. Like reddit, I think. * Scientific computing - numpy, scipy, matplotlib, and the whole ecosystem built on top of them. * GUI applications - Mostly on Linux, but there are examples on other OSes, like Dropbox. Versus Matlab, the biggest advantage is that Python is *free* - you can run your code at home, send it to a friend, run it on 200 Amazon EC2 instances, and never have to worry about licensing. Of course, if you go into computer-related jobs, you'll probably end up learning other programming languages. But Python is a great place to start: it's widely used, easy to learn, and there's lots of libraries to make it do interesting stuff.
Knowing the exact value of PI is the first step in performing block transfer computations.
Reddit does use python. There is a post about them switching to it.
i would love it if pre compiled things became the norm, installing lxml on my mac is such a clusterfuck i almost gave up
Using MATLAB for vanilla MATLAB makes no sense at all (unless you have unlimited money) when you can just use Python with Numpy. Scipy is a good equivalent for many of the toolboxes as well, but definitely not all of them. It pains me when people think they need to buy MATLAB when all they need to do is multiply, transpose, and invert matrices.
Have you checked out [their docs](http://library.linode.com/web-servers/apache/mod-wsgi/debian-6-squeeze)?
I just went through this exact page step by step twice with no luck so far. Maybe my brain is just too fried at this point.
This course does require involvement throughout the week. One could maybe watch all of the videos and do all of the quizzes and mini-projects in one day, but another part of the class is evaluating the projects of five other students, which is not available to do until Sundays, since Saturday nights are the hard deadline for quizzes and projects. I would recommend the beginning Python course from Udacity, which is completely self-paced and does a great job explaining things from the ground up. I'm an experienced programmer and am taking both at the same time (started with Udacity a few weeks ago, and Coursera yesterday). I like both courses a lot so far, but feel Udacity is a better place to start for rank beginners or those who are unsure of their math skills. Going by the comments in the Coursera forums, it has been quite challenging for some folks.
Lighty is pretty dead in the Python community. Apache+mod_wsgi and gunicorn are the workhorse servers, with uWSGI, Tornado, and a few others showing up more rarely. Other than mod_wsgi, pretty much all of them are dedicated app servers that expect to be behind a proxy though.
Oops, didn't see the subreddit name, thought this was programming. Yea, lighty's probably not good for python then.
thank you, i will check this out!
One thing that always seems to trip up new administrators (I used to work in support at a different VPS company, and helped many people who never had root privileges before set up their web service) is you MUST restart apache after changing your virtualhost configuration. Another is file permissions... if the user Apache is running as can't read/execute your scripts, there's no way it will be able to serve them to visitors to your page. Use ps to verify what system user Apache is running as, and verify permissions on your scripts/web document root directory to ensure they are loose enough for that user to read/execute. The command "apachectl configtest" (Might be apache2ctl depending on which package you've installed.) Can help out a lot if you are mucking with VirtualHost directives. And lastly, ensure you have logging enabled for your Apache VirtualHost and check that log! Apache actually provides useful information which might point you to something you've simply overlooked.
How do you know its not working? Are you seeing an error or 400/500 error page? If yes, trying checking the log files.
thank you. i have it working now. for security, what kind of permissions should I have. is there anything wrong with 755 on the entire thing?
Thank you. I just got it working... no way i could sleep with something like that unsolved! I asked another user this already but what is the best practice for file permissions on my files and directories? is 755 ok for everything? Also am doing myself any injustice by using web.py? django seems to be a bit more popular but I dont know enough yet to tell if i am using the wrong thing.
I am just so tired today! fixed it and it was my stupidity not setting up the DNS records. After that i was able to fumble my way to the conclusion i was looking for with ease. Thank you for the response.
I am with you on gevent in that it extends python well. But you need to keep in mind that: A) gevent monkey patches python to the extent that the language has a very different API B) gevent is built off of a c library, and that is not included on every platform available to python C) you still have not done real concurrent processes. You cannot utilize multiple processor cores. D) you are also still technically just single threaded and you are stuck with a single instance of the python interpreter which has a single instance of the GIL. So all of your code is shuttled through that single point. To be fair, gevent is really nice for python and it definitely patches a lot of problems for the developer. But you haven't actually changed the core language or feature set.
we are getting there. If you look at those PEP, they rely on the previous works like the PEP 376, 386 and 345 standards
yeah i saw that.. hehe. i got it working with web.py, im still not sure about it and may switch over to django tomorrow.
That's pretty cool. Thanks for sharing!
If you hit lint w/o anything in the text field it routes to http://lint.io/r/create/?uri= Perhaps you want some validation there, or a prettier 404 page
Do you have Python 3.2 installed? How did you do? Binary install package or with a package manager like MacPorts? In MacPorts you could install Python 3.2 and set it as default: sudo port install python3.2 sudo port select python python32 (Or something very similar, you can certainly google it.) After that, python-3.2 would be used as default, when calling just "python". You also can call "python-2.7" or "python-2.6" if you need this for compatibility. If you installed Python 3.2 from a binary package, you can maybe set an alias in your .bashrc or somewhere, to use this as default one. 
I agree. It also looks like Udacity is more open to working with "vanilla" python (as opposed to containing everything in a web browser, which means not seeing some imports and not playing with any half-decent text editors). I think I'll be pushing on Udacity instead. Web crawlers are cool too!
What's wrong with `rm *.ext` ? EDIT: This is probably the most over-engineered script I have ever seen. if extension[0] == '.': extension = extension.lstrip(extension[0]) # strip off period What? Easier: if extension[0] == '.': extension = extension[1:] This: if cont == 'n' or cont == 'N': run = False # ends loop Should be: if cont.lower() == 'n': run = False And + don't get me + started on + the string + joining.
wouldn't it be better to use "while True" and "break" instead of run=True/False?
Suspected as much - so `rm *.ext` doesn't do as much as this script ;) But yeah, my first thought was similar - it's a oneliner in any useful shell environment. EDIT: Oh, wait. I somehow assumed that this script was doing more than it actually is. Yeah, complete waste of time other than as exercise to figure out glob.
Many thanks! I was working with [this example](http://www.wayforward.net/pycontract/examples/sort.py) which I now think is error'd
FYI, Reddit uses [Markdown](http://daringfireball.net/projects/markdown/syntax#link) syntax for hyperlinks (and other formatting) rather than HTML. For example, to make that link, I typed `[Markdown](http://daringfireball.net/projects/markdown/syntax#link)`. Reddit will also automatically hyperlink things like /r/python or /u/andrea (note the leading slashes).
Thank you so much for that link. I'm new to posting on reddit (long time reader), and the link to markdown really helps. Is this the same markdown that stackoverflow uses?
Glad I could help. Reddit only supports a subset of Markdown, unfortunately, but it's mostly the really fancy stuff that doesn't work. There's a link in the bottom right of the comment box labelled "formatting help" that has a handy (though incomplete) overview of the markdown features that Reddit supports.
Aha! got it, thanks :)
I think my background is similar to yours. I'm a computational chemist by training, and am old enough to come from a time when one only learned FORTRAN coming up. MATLAB was a huge step forward for me, as was Perl. I realized that with Python (esp with Numpy) I could do everything I did in Matlab and Perl in a single, free language. Fell in love with Python. Now I work for a CS department. For physical scientists, Python gives one a pretty solid palette of computer science tools. You can experiment with XML, or with heap storage, or with binary trees, because tools to use these are built into the standard library. I never sorted when I was a FORTRAN programmer, because sorting was hard. I'm sure there were times when a sort would have helped things, but I found other ways around sorting. Now I end up sorting things all the time. This isn't meant to bash FORTRAN, which is a good language, and one I still use occasionally. Just that a more modern language gives you a bigger toolkit most of the time.
I think you pretty much just ignored his reply. In good editors (Vim included) you can set it so that it essentially does a search and replace upon opening files. Setting tabs to the number of spaces you want.
* http://docs.python-guide.org/en/latest/ * http://docs.python-guide.org/en/latest/scenarios/ci/ * https://github.com/kennethreitz/python-guide/blob/master/docs/scenarios/scientific.rst * http://scipy-lectures.github.com/ * http://ipython.org/ipython-doc/dev/interactive/htmlnotebook.html prints to Python, JSON, PDF and HTML * http://pandas.pydata.org/pandas-docs/stable/ * http://pandas.pydata.org/pandas-docs/stable/io.html#excel-files * https://github.com/mikedewar/d3py/blob/master/examples/d3py_scatter.py 
https://github.com/pypa/pip/pull/684/files
Up-fucking-vote just for actually saying "pandering." I don't get why ~~people~~nerds refuse to see this. XKCD is cheap. It's easy. It's recycled tropes and soulless cutesy gags that try to make sad people feel good about liking math or programming or whatever. The most infuriating thing about it is that there have been one or two good ones.
@andrea: Thank you for the clarification. Would I be able to do post conditions with PyContracts like I would be with PyContract? I ask only because I need to check in some cases that the inputs are not changed, etc and I don't see such functionality in your [Quick Tour](http://andreacensi.github.com/contracts/#using-python-annotations). Also, are there any other guides/tutorials that you would recommend?
* http://docs.python.org/using/windows.html#compiling-python-on-windows * http://docs.python-guide.org/en/latest/starting/install/win/ * http://code.google.com/p/pythonxy/ * http://pythonxynews.blogspot.com/ * http://www.portablepython.com/
Depending on what you're doing doing some scripting can really help with workflow.
I was told be a professor that "real engineers" used MATLAB, not Excel. After working in industry (ME, manufacturing) for around 8 years now, I've never seen MATLAB used. I'm sure R&amp;D guys use it, but it seems pretty ridiculous now.
True. But I still don't like tabs in Python code.
there's a python shell you can get for android; also I'm guessing the way Kivy works when packaged is it bundles up the interpreter into the app (similar to how packaging python for windows works, now I think of it)
This is pretty contrasting with what [Guido said recently](https://plus.google.com/u/0/115212051037621986145/posts/HajXHPGN752). [Comments on reddit.](http://www.reddit.com/r/Python/comments/zv8ex/guido_on_how_to_write_faster_python/)
This is how I got away with not bringing my laptop to CS all last semester.
&gt; On the Nokia N900 getting root was one command away This is true of Nexus devices. Sucks that it isn't true generally...
just FYI SQLAlchemy and web2py could not be more dramatically different, at every level, both superficially and fundamentally. (this is not to say SQLAlchemy is for you. just wish massimo would keep the falsehoods out of it when he sells his product).
You do t need to root your device to use kivy, it builds a valid app pkg which includes the python interpreter and any packages compiled for arm on android. So it builds real apps that can go on the market (search the market for kivy to find some examples)
SL4A is really confusing. What is this other shit they keep peddling, "Taskbomber" what is that? Anyways what I wanted to tell is this: -- in SL4A the interactive Python shell is hidden in Menu&gt;View&gt;Interpreters&gt;Python. 
I don't advocate it as a dependency or anything. It just seems that noone tried. I can give you few reasons why not: * dependency as you said * jit warmup times are bad * I don't think pypy speeds up mercurial to start with (some time ago it did not) etc. etc. However, if you talk about performance of a particular operation, especially if rewriting to C is an option, giving pypy a go is not really that hard.
Oh. Ill have to check that out...
On the n900 you also have 'sudo apt-get' and the normal interface is X11 compatible so you can run whatever X programs you use normally. Also loopback mounts are in the default kernel.
My Google-fu failed me when upgrading to Mountain Lion this weekend, so I wrote up some notes. I hope others find them useful.
Oh yes, you're right, for the Python part. I was thinking of the Haskell community attitude (which is contrasting with Guido's).
Thanks, I've been using the python included in the mac OS distribution. Your notes will help me install the latest distribution, which seems to be required (or strongly recommended) for matplotlib. 
I don't recall having to do anything special with my macports python install.
Good point. I neglected to include that I'd already installed the XCode Command Line Tools, since I figured most people would recognize that problem pretty quickly. My main goal was to help w/ the `pkg_config.DistributionNotFound` issue.
Matplotlib will be on Python 3 by the 29. of October. JSYK. Personally, that was the last Py2.7 holdout. I'm all Py3k now.
6 MB seems okay to me. These apps all take up more than 6 MB (application storage only, not including "data"): * Google+: 25.79 MB * Skype: 16.74 MB * Evernote: 10.54 MB The Kivy Showcase and TouchTracer apps were both ~4 MB downloads, but the applications themselves each take up 9.02 MB on my phone. I'd estimate that it took two minutes to download over 3G with my [Sprint service, which is awful](http://www.pcworld.com/article/254888/3g_4g_performance_map_data_speeds_for_atandt_sprint_t_mobile_and_verizon.html). This happened in the background, which I'd imagine is how most people download mobile apps.
Especially when it's so ridiculously cheap.
The mentions of other software, like Cython, were also generally lacking in any sort of depth. "heavyweight and meh" is a poor reason for not using a piece of software. This seems like a common case of dismissing potential solutions on religious or ideological reasons without trying them first. It's a shame this still happens so often, especially when it leads to significantly more work.
True. All except being X11-compatible for the main UI and having all the main events hooked into dbus. I mainly miss being able to use the same scripts on my phone as I use on my laptop (vpn, captive portal logins, backups).
Also check out [SublimeREPL](https://github.com/wuub/SublimeREPL)
Check out qwcode's cleaner and more up-to-date wheel_install branch: https://github.com/qwcode/pip
Curiously, why aren't you Mac/Python guys using Vagrant?
It seems using excel would be much quicker for large scale data manip, no?
Link to the actual post, instead of the whole blog: http://stonly.tumblr.com/post/33830362022/erlang-python-android
This mentions segment_axis.py, which is *really* handy and [might one day be included with NumPy](http://projects.scipy.org/numpy/ticket/901) (if it ever gets approved).
I use excel a lot at work too, so now I'm kind of curious what can be done in Python that can't in excel?
but that's Python3 isn't it?
Any idea if they're gonna start merging those patches though? This one is four years old.
If I'm not mistaken this was deprecated for this very reason, no?
I consider a good programmer one that doesn't modify the style of the code to suit himself, but modifies his own style to suit the code. In other words, everybody's particular style of coding sucks, so we might as well get over it. Suck it up and write in the current style. There's only one thing worse than code in a style that sucks, and that's code in two or more styles that suck. Regarding the whole dry/wet code generation... I'm not really sure what you even mean by it. The Googles tells me dry code is a "machine-readable style" and wet code is a "human-readable style". Or at least that's my interpretation of it. At any rate, writing dry-code that outputs wet code and can also run sounds like an interesting challenge, but I would most definitely *not* actually use it. The WTF-factor is just too high to actually use something like this in production code, especially when they only justification for it is "I don't like the other dude's programming style".
You're right. http://docs.python.org/dev/whatsnew/2.6.html#pep-3110-exception-handling-changes
But that's the thing. His code has no style. He doesn't even pay attention to what he's putting in there - I keep finding bits of code from previous incarnations of the script that don't do anything, function declarations that consist of nothing but a single comment: '# code me,' and line after line of identical statements that need to be constantly watched, lest one change without the others. It's an absolute nightmare to maintain. DRY stands for "Don't Repeat Yourself," and is a fairly well-known and noncontroversial concept. Or maybe not - maybe I'm sticking my neck out here, who knows? WET stands for "Write Everything Twice" - not strictly twice, but you get the idea - the opposite of DRY. WET code is usually much more difficult to maintain, since you have to go through all of it every time you change something, just in case you missed a bit of repeated code somewhere. I don't "dislike his style" so much as I "am no longer twelve" and have learned how to code in a way that is forward-friendly and takes future maintenance (by both myself and others) into consideration. I hope that doesn't make me sound like a snob, or a jerk, because I'm really not. I just value my time at work, and if I have a choice between spending three hours updating the code of someone who who has no such sense, and rewriting it so that I can do the same maintenance in fifteen minutes, well, I have to say that I am strongly inclined to choose the latter.
Has anyone played with Mondodb? There seems to be a pretty stead push from the relational database community to tout it as unstable and benchmark driven.
but there's no `functional` module in Python 2.x and [`functools`](http://docs.python.org/release/2.7.3/library/functools.html) doesn't have any `compose` function
Interesting... I'm not at that level so I'm going to keep learning, but thanks for replying!
`functional` is not a built-in package but you can install it with easy_install or pip (it's a package by Colin Winters). Tremendously useful though; wish it were built-in...
If anyone has any questions feel free to ask and I can describe in greater detail what we were working on.
To show good performance numbers, unsafe writes are enabled by default in Mongo. I personally don't like this mindset hence stay away from Mongo. Fortunately, there are other good NoSQL DB's worth playing with like Riak, Neo4j etc. so all is good.
&gt;continulet-jit-3: enable stackless to interact with the JIT by killing global state while resuming from the JIT into the interpreter. This has multiple benefits. For example it's one of the stones on the path to enable STM for PyPy. It also opens new possibilities for other optimizations including Python-Python calls and generators. Does this mean that stackless behaviour now benefits from jit optimisation? Or is it just a step along the path towards implementing jitted STM?
Not specific about the report, exactly, but is there a plan for a release anytime soon? It seems like if the goal is to wait until a bunch of this stuff (like the rpython-pypy split) is done before releasing, it might be a while, and there's a bunch of stuff in nightlies now (like the CFFI backend) that's super useful...
https://bitbucket.org/pypy/extradoc/src/tip/planning/2.0/todo.txt is our current plans for 2.0, we might drop some of it though, we're definitely planning to do a release before teh end of the year
do not, under any circumstances, use or even look at Piston. It is a steaming pile of crap. I've used tastypie on several projects, and while it does have some issues (like file uploading), there are fixes available, albeit not in upstream, yet.
Killing CExtModuleBuilder was completely orthagonal to our NumPy work, or future SciPy work. CextModuleBuidler was *not* CPyExt, it was a random crappy thing in a corner which was awful.
~~5~~ 3 files for a "Hello World"?
Tethered vs untethered is an interesting difference I hadn't considered Most all of my dev is power attached so running vagrant vms isn't a consideration but, good to hear an opposite view
I'll make sure to have a beta in the next few weeks. There are a few regressions (like slower ctypes), and a few nice-to-haves, that are preventing us from doing 2.0 final just now.
numpypy is progressing. I'll post a report on this once things settle down a bit. Regarding scipy-matplotlib - this is still months away. We need to finish numpy first.
That's totally legit. I'm starting to write code that depends on some of the new stuff (CFFI, mostly, but also some numpy bug fixes), but probably won't deploy any of this new code against a nightly, so I was mostly just asking for my own planning purposes, and not as any criticism of your release scheduling. Thanks for the great work.
Isn't the whole point of a Hello World to have a very simple starting point? Hacking up the standard settings/urls/views layout just to have it all in one file seems extremely counter-productive.
Cool. So they should be feasible with CPyExt?
I've worked with Tastypie to provide both internal APIs (for jquery) and external APIs (for mobile apps) and it's been wonderful. The only annoying part is the lack of documentation by examples; the reference is your best bet if you're looking for something. Piston is quite broken and outdated from what I hear.
I just added this, but wrote a little (gross) javascript demo as well: http://charlesleifer.com/static/colors/
[Neat!](http://i.imgur.com/DYLtN.png)
Agreed, the almost 1-to-1 mapping of my db data with my programmatic data makes it fantastic to use.
Good stuff.
Nice article. I believe Scipy has this implemented: http://docs.scipy.org/doc/scipy/reference/cluster.vq.html
ah I see, didn't knew that one thanks!
What did you think of South Africa/Cape town? Enjoyed your stay? :)
Everything you're forced to do with macros in Excel but faster to code/execute, more friendly and more powerful. Just an example I got yesterday: I got an Excel extract from a database of the structure tree of the product we design (basically the CAD parts, assemblies and more are organized in a kinda big and complex tree). I wrote an Excel macro to clean it from what I didn't want and extract the exact info I wanted (basically some particular elements from the tree and for each some info from their parents). I couldn't do it without code. And with Python it would have been faster to code (but it's not convenient to use Python with Excel data, and I'm not really good at Python yet).
So, just to check I understand, you treated each pixel as a point in 3D RGB space, then ran K-means clustering and returned the centre/mean value of the largest 3 clusters (or always running it just generating 3 clusters)?
that's incorrect. Numpy is implemented in RPython (mostly) and scipy/matplotlib will be pulled in using some sort of trick, but unlikely to be rewritten.
It's interesting how the k-means is the busywork of the algorithm while the a priori distance measure between samples or clusters, is the defining quality which is *understood* about the data. If only there was some way to automagically explore and 'cluster' that measure, too!
Why did you change the way in which default values are specified? It seems a bit counterintuitive to have a such a complicated way to do it.
You are putting the cart before the horse. You don't look for the packages and ask how good they are. You are thinking about your task and figure out problems to solve. Then you go in the internet and do a little research. Or talk to fellow programmers about the problem. And then, when you have a good abstract idea of how to solve the problem, you go and start looking for Python modules. Actually even better: you don't look for Python modules directly but you ask "How do I do this? What would be the best practice?". And eventually someone points at a Python module.
When you develop GUIs with Qt, do you need to distribute PyQt along with your software? (my experience has been that it can be very frustrating to get that installed)
You ought to be aware that REST framework 2.0 is just about to be released. It is a backwards incompatible reworking of REST framework, and has had a *huge* amount of work put into the design and documentation and is looking really, really nice. Planning on pushing it live next week, but you can take a look at the documentation here: http://tomchristie.github.com/django-rest-framework/
Yes I treated the colors as points in a 3d space (r,g,b). Then returned the centers of only 3 clusters as I only calculated 3 for the examples. You can definitely do more if you want.
Awesome! This fit right in with some ideas I was musing over on doing one of those ' image made of hundreds of little images' things. :) 
You could make a 3D rendering of the colors of the image, that would be amazing...
If you gonna do this (not sure it's worth), I go with: import plistlib class plist: dump = plistlib.writePlist load = plistlib.readPlist As its clearer what's happening.
Thank you! Do you know anything about drawing graphics within Qt? I am interested in making a Qt GUI that can draw an image based on an 2D matrix array of scalars to create something of a heat map.
This is the basis of some pretty cool computer vision/image retrieval research. Treating k-means on pixel intensities and selecting the dominant k colors is one of the first steps in creating a color signature codebook in computer vision literature. The next steps would be to concatenate all pixel intensities together in a population of images, run k-means, where k is normally in the range of 2048 to 4096. The centroids generated are called your "codebook". Then, loop over each of the individual images again and assign each pixel to the closest centroid in the codebook (variations exist where you don't have to examine each pixel). This will create a histogram of size k for each image. If you compute the euclidean distance between these histograms, you will be able to find "similar" images based on the distribution of the codebook histogram. EDIT: Updated for clarity.
Ya, what this guy said.
I need interactivity and something more low level for rendering them in the form of animations while responding to parameters obtained from the GUI. The actually calculations will be done by calling out to Fortran binaries.
It's in rpython, you don't have to do this in normal Python code
it's not even RPython. It's RPython-Python interface that's confusing.
It was extremely fun, they have penguins! Also, my first trip outside of the US to an English speaking nation.
If you want to get REALLY picky, then YUV space isn't the best bet either. You would want to use the Lab color space, especially if you are using the euclidean distance when clustering since the euclidean distance between two points in the Lab color space has actual perceptual meaning.
ooh... that's a cool idea.
And I'm not being a dick. I'm trying to turn you on to better ways of doing what you're trying. You really shouldn't have to convert your image to a thumbnail to accomplish this with reasonable speed. The thumbnail algorithm in PIL is doing something very similar to what you're trying to accomplish (you can think of the output of kmeans here as a 3-pixel thumbnail) and the fact that PIL's thumbnailing algorithm is fast relative to your code (albeit I think PIL defaults to KNN, so slightly different) should be a signal to you that there's something in your code that should be faster. I'm just trying to bring this to your attention. I'd like to think when I post code here people aren't afraid to tell me how it could be faster or to direct me to libraries that have out-of-the-box solutions for what I'm trying that are faster than what I built. You shouldn't take it personally when people tell you something you built could be better. Anyway, if you want to keep playing with kmeans, try this out for your next project: http://pragprog.com/magazines/2011-12/revisiting-graphics-hardware
I never had great luck packaging/distributing PyQt apps. I wish the whole install of PyQt was more streamlined as well.
So synchronous PyPy edges out NodeJS in all cases, and is less hassle to write for.
And it's still less mature. Impressive. 
Ya know, I made some....stuff...important stuff....
Question from a newbie learning Python. What is QT? And do you need a particular development environment to develop a GUI?
Very cool that they actually showed some real interest. I guess mentioning games is a real good way of getting their attention! But as someone who isn't familiar with these American-style Career days, in what age range were these kids?
Well...technically, yes. But you do not need to distribute it in a manner that you have to install PyQt on the user's computer, you only need to distribute the DLL file. PyInstaller does this automatically.
I have a few more videos to go over and then my intention is to start a sort of a "project" where we will build an entire app from the grounds up, and this video will include how to package and distribute the app as well. I have never had any luck with py2exe, tried it once and failed miserably, but PyInstaller worked like a charm. For example, for my private project I am right now writing a software that has over 5k lines of code and PyInstaller works without any problems. 
Qt is a GUI framework. Basically it allows you to build a desktop GUI application using Python. Well, it is much more than a GUI framework, but stick to the GUI part for now. It is very simple yet very powerful. [Here](http://en.wikipedia.org/wiki/Qt_(framework\))'s the wiki link. You don't need a particular development environment to develop a GUI, a notepad will do. 
No, I don't honestly. But I will learn and make a tut video :D
Any chance for pyside or pyqt compatibly? 
Yes, I stumbled on this once. Unfortunately I can't install non-portable software at my work, so I can't use DataNitro (nor Python actually although you could manage it I'm sure).
It's 100% time. Money and material aren't issues. I appreciate your offer to donate, but I definitely don't want to start taking donations. The thing about RFP is that it takes me a seriously long time to edit the interviews. Like, 10-15x as long as the interview itself. It's tedious work and I tend to procrastinate like crazy. I had a bunch of travel on September... and October... and I'm gonna have a bunch in November too. And I really only like doing the interview editing at home, with my nice big screen and big comfy headphones. The good news is, I'm gonna try and get an episode out before my next trip. It's an interview with Barry Warsaw. Also, I already have a second interview in the can, and if I can get it done I'll do the edit on that before I leave. Assembling an episode around the interview is no big whoop, I could do that from the road. And I thank you for your continued interest :D
Why was no mention made of the magnificent and resplendent Larry Hastings regally sitting in on your sprint for the first four days? Well, five days if you count the day I did laundry and split for the airport. A SPELLBOUND PUBLIC DEMANDS THE TRUTH
That defeats the whole purpose. Mac has an ancient version of libxml2, and windows probably won't have it installed either, so that means this new proposal won't do anything for those situations?
If you don't take donations, is there anything _we_ could do to help? I don't have a single clue about sound, post-processing and such, but if some part of the _tediousness_ of the editing can be shared/distributed, don't hesitate to ask!
Indeed, these are not useful results if it turns out, for example, that any time spent in a request handler blocks all other requests, or there are only a limited number of 'busy' handlers in flight at once.
OpenStack has proven that you can build robust, scalable cloud services with Python? Really? OpenStack, the immature broken stepchild of AWS where the biggest known cell is less than 10k servers, not, say, Google? Next you'll be telling us how NGINX is better than Apache and Mongo is better than MySQL because a benchmark you wrote that runs on a single machine says so.
[Memory mapped files](http://en.wikipedia.org/wiki/Memory-mapped_file). If you open a 2GB file in your editor you shouldn't load the whole thing into memory. You need to load what the user can see, plus a sensible amount on either side and the load what's needed as they scroll. Regex support including replacement for groups. Basically, combine Ultraedit, Notepad++ and Sublime Text for features.
I agree that OpenStack shouldn't be considered robust or mature, but there are successful businesses running it in production with few issues. It's not as featureful as all of AWS, but I don't know of an open-source competitor that is. You wouldn't consider scaling to 10k servers to be successfully scaling? What is the 'scaling' line?
I'd have to think about that one. Other people have offered similarly. But it's such a grind, I hate to ask someone else to do it. And I'm awfully picky is the other thing--I'd be surprised if other people went to the lengths I do to provide good sound for y'all. Anyway, let's stick with the status quo for now. But thanks!
For writing GUI programs, check out Qt or wxWidgits. Both have c++ and python interfaces, maybe more.
What is wrong with WxPython on Windows? I used it recently for a simple application and it seems to work.
Interesting read, but I'm not a fan of raw benchmarks like that. The biggest difference will be in coding style and libraries, which I would have liked to hear about. Most of my time will be spent developing, not gushing over a few points in a benchmark.
" It is in fact quite similar to SQLAlchemy. "
Now try it when each thread needs to collect responses from three different slow APIs over the network. Synchronous Python leaves you with: Initial request, contact DB1, wait..., DB1 response, contact DB2, wait..., DB2 response, contact DB3, wait..., DB3 response, collate, reply to initial request. This is easily improved with *any* asynchronous model (including, of course, multiple synchronous Python processes communicating via some shared state or messaging system, like a message queue – but this is quite a bit of additional infrastructure, overhead, and programming work). Async isn't useful everywhere, but when you need it, you need it. 
Let me know how your method works, maybe I'll make a tutorial out of it too
Emacs for me, same reason.
Yeah, it is actually something there are surprisingly few resources about in any programming language. Maybe it is so obvious that they don't feel the need to explain it, and I really am just slow. Either that or they just expect you to be using OpenGL at that point. It is too bad. What would be even nicer is if it could read the bitmap from a text stream coming from the binary. 
textmate is open source now!
ncmpcpp
Vim with vim-flake8 plugin for pep8 check is IMHO the best choice.
Emacs.
Indeed, Larry for intentionally omitted from the report for the purpose of insulting the american general public :)
Not sure I've seen "vim" in the same sentence as "simply text editors" before.
Make sure you know who are the users are, design the interface and experience around them. So you need to make an editor that fills the needs of researchers if the audience is academic, if the users are programmers there is a whole lot of other features that matter. And then as a programmer/ux guy, I'm a big fan of things that support plugins.
pypy is still heavily in development: they still modify the architecture, no py3k yet, … CPython is still the reference implementation. v8, on the other hand, is in heavy use since chrome exists.
This was for elementary school, so the age ranges could have been five through eleven. I only talked to third, fourth and fifth graders, so my age range was eight through eleven.
SublimeText2 is a really nice code editor, but it's not the best text editor since it has serious problems handling large text files and stuff like this.
Just stumbled across this. I don't think English is the author's first language, but it's an entertaining way to practice some code.
Thank you :)
Super cool!
Hi Tom, Is this &lt;https://github.com/tomchristie/django-rest-framework/tree/restframework2&gt; the code in progress?
Agree, though it makes reading the storyline somewhat comical...
looks great, I'll use the chance to learn the basics of Py3
Coderunner on the app store!
&gt; I do not sell a product. your behavior for years now strongly suggests otherwise. I've not seen other college professors show up at conferences with illustrated comic books talking about their web framework's great features.
Coderunner is hit or miss for me. I'm brand new to Python, but for example it wouldn't take (1/2) * variable, and required me to use .5 * variable.
It's a good idea. Shame it's so unpolished.
Komodo edit, free and great
I will have to check that out...
Can someone tell me how i convert a float into this Decimal type? (using python3) balance -= Decimal(item*0.1) and balance -= Decimal(str(item*0.1)) and everything i tried game me a TypeError: unsupported operand type(s) for *: 'decimal.Decimal' and 'float' error:/
The language is part of it, yes, but there are so many errors I'd have to rewrite pretty much all of it. The style of the site feels pretty amateurish too.
how about `item * Decimal('0.1')`?
same problem Edit: was my fault. this works. thanks a lot:)
Your problem seems to be that item is Decimal, while 0.1 is ofc float. Just wrap 0.1 in 'Decimal': balance -= item * Decimal(0.1)
It's quite annoying trying to figure out how to get the tasks to pass. I mean, when the tests pass, you'd expect it to be a success, right? WRONG! I had to guess a lot for the ATM task to get it to pass. Apparently you have to raise a ValueError when the balance becomes negative. Sure, it's proper, but how are beginners and such supposed to figure that out from nothing? That said, I haven't looked at the learning material I saw links to, if it even exists.
Try `Decimal(0.1)` in an interpreter. The float gets rounded to a binary fraction, so it's very slightly off 0.1. Instantiate Decimal with a string: `Decimal('0.1')`
I thought that was funny. That happened in 2008. I think it is a shame there are not enough academics in conferences such as a PyCon but there is a reason: talks are not required to be on original work and therefore not acceptable for academic standards and do not result in publications that count for professional advancement. I have proposed changing this and more academics but my proposal was dismissed. Almost everybody at this kind of conferences sells something usually themselves as consultants. I do not, I just share my code which is free, and earn my living teaching. Anyway, not to nitpick, but I am a University professor, not a college professor. The school where I work has a PhD program and we are one of the few NSA certified centers of excellence. I have all the rights to attend a conference and talk about the great features (and defects) of the software I produce. Anyway, back to the topic, you accused me of saying something false. I am still waiting to hear what you are talking about.
And on [Stack Overflow](http://stackoverflow.com/questions/7303313/what-are-the-differences-between-django-tastypie-and-djangorestframework). * [Another](http://stackoverflow.com/questions/2488325/framework-for-implementing-rest-web-service-in-django)
So far the only one baiting is you and I do not know who you are. I am dropping this discussion.
vim with https://github.com/klen/python-mode
It makes the challenges difficult to understand.
Can someone help me with the 2nd task? Im struggling to understand the question. the amount of money that Petr will pay for the ride ''' initial_petr, raise_petr, initial_driver, reduction_driver = offers assert checkio([150, 50, 1000, 100]) == 450 Wha?
GO VIM OR GO HOME
it's basically a negotiation with Petr's initial offer vs driver's initial, and every step you add petr's raise increment and driver's decrement as counter offers, until petr's offer is acceptable by the driver.
It completely depends on what you want to do. If you want to do scientific computing, you should look into Scipy, Numpy, Orange, Sympy, etc.. If you want to make GUIs you should try pygtk, pyqt, PySide, etc.. There are many modules/libraries available in Python and each of them have their own purpose. tweepy is a python module for Twitter API. You can play with that for some time. If you want to make games using Python, learn pygame. If you want to learn web development, you have django, flask, bottle, etc. So, basically, it all depends on your need. Look into some open source projects and their modules and start working on it.
Their signup employs what is probably the most infuriating captcha I've ever encountered. GG, Check iO.
Che k out html5boilerplate and twitter bootstrap. Changed my web app life around. Oh and initializr to put those two together. 
Sometimes it is good to be abused. I'm far from experienced in these matters so this may seem like a silly point but after scanning all of the postings I didn't see one reference to anything Apple is doing with iOS or Mac OS. Since these two OS's are awfully stable with great apps I'm wondering if the technology Apple uses is worth pursuing? I really don't know, my Python programming is limited to using it as a scripting environment one step up from MS batch language. With respect to iOS it amazes me that apps are so responsive there running on these little ARM processors. I take it as an indication that they are doing something right with asynchronous tech. 
And that's my problem solved, thank you! In fact, I'll probably end up using a mixture of those.
You're on a Mac. You get BBEdit and TextMate. Game over. (I love Vim, I really do, but anyone who can't google a text editor on their platform is not going to be happy with Vim) 
Sounds good :-) I'll give it a try
I can totally get behind darthmdh's recommendation to 'learn the stdlib'. After years, I'm still finding areas where a simple module/function in stdlib can replace most of complex functions I spent considerable time writing. With the exception : kick urllib/urllib2 to the curb, just don't bother with that crap. If you need that functionality, use requests instead, it has a sane API worth using.
A friend and I have been developing a networking library for Python for more than a year now, and one of the features I'm excited about is an easy way to read and write binary wire protocols. The problem is... struct felt lacking to me. It's quite good at what it does, but its string handling made it unnecessarily hard to use. This is my attempt to solve that. NetStruct puts logic on top of struct that makes it possible to pack and unpack data with length encoded strings. I won't put any examples here, but the readme on github has several.
If you work with HTTP, avoid urllib(2) whenever you can. [Requests](http://www.google.fr/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CB0QFjAA&amp;url=http%3A%2F%2Fdocs.python-requests.org%2F&amp;ei=TUCKUKS7K8rY0QXX_oHoBw&amp;usg=AFQjCNFyAH9fsxdKUHgs_F_P-ZQ_-_P1nw), thought not part of the standard library, has a much better API. For your daily fix of asynchronicity, [Twisted](http://krondo.com/?page_id=1327) is what you'll need.
While there is much to be said about the love of programming for programming; most programming is to be done as a means rather than an end: project-directed programming reflects this.
Hi. This is really not a question for us. We released cffi that let's you interact with C in a much better manner than before.
Can you give an example of when this would come in handy? I'm pretty new to Python, so I haven't had much time to dig deep into the networking libraries. What is the drawback of sending a block of data over the wire? For example: blob = pickle(myobject) host.send(blob) ... blob = client.recv() myobject = unpickle(blob) Is it more efficient to pack into a struct or something? 
I think the problems with urllib are often overstated. If all you need to do is load something from a URL, it's fine. That's probably &gt;90% of what I've ever needed to use HTTP for. It's only when you need things like authentication, custom headers or more exotic HTTP methods (TRACE, anyone?) that urllib's API gets in the way.
lol I didn't realise the Decimal() function was available, so I multiplied all my results by 10 then divided by 10 at the end so could use 0.5
http://www.doughellmann.com/PyMOTW/
Sometime i have to analyze log files between 500-1000 MB. SublimeText 2 doesn't crash when i try to view them, but it seems to load the complete file into memory instead of displaying only loading part of the file like some other editor do (Notepad++, UltraEdit, Vim, etc..)
Using urllib means you can give someone a snippet that will work without having to install third party modules. This is no problem for us, but try talking a newbie using Windows through installing a module. It does not usually go well. 
The main problem with pickle is that if you connect to an untrusted remote client or server, there's nothing to stop them pickling some malicious code that gets run on your machine when you receive it. (One reference: http://nadiana.com/python-pickle-insecure) It's also not necessarily very efficient in terms of bandwidth, depending on the type of objects you send.
I guess you don't really have any data. I don't have any either, but you have to remember that people using node.js are the ones who cream the loudest. I hear about a lot of people who use PyPy (obviously), but it's also usually not very public. I would be very skeptical - there is simply not enough data. Regarding "production ready" vs "widely used" - common, you can't claim something is not production ready just because everyone and their dog is not using it.
It doesn't actually matter if you read my description literally (which is kind of why it's spoilers; it's the *exact* description of the function).
Maybe i am a little slow, but how does it help me to run a QT gui programm under pypy?
it does not. however it's really not up to the implementors of Python to port all the existing extensions to it. We won't put our efforts into that (we also have a very limited manpower to start with), however we'll make it easier to call C. Library authors can try to take it from there.
* Review an entire worksheet without clicking on every data/code cell to see how numbers are being computed * Work with standard science, engineering, and mathematical analysis software packages * Develop and run tests for process and data consistency
* Python(X,Y) bundles many of these libraries together. [1] * The scipy-lectures describe how these libraries work together. [2] 1. http://code.google.com/p/pythonxy/wiki/StandardPlugins#Plugins 2. http://scipy-lectures.github.com/
Sadly I don't see this as an effective teaching tool except for complete beginners. School children even. However if it was actually used for that purpose it would be pretty great to spread programming to the public.
Oh yea, I wouldn't use it for that, I only use pickle for serializing objects that I need to send from one component to another. I am willing to sacrifice some bandwidth for speed in this case.
You can manage modules from the PyCharm IDE, click on file -&gt; settings -&gt; Project Interpreter -&gt; Python Interpreters and click the install button on the right. A search box will pop up, find the module you want and install right there. Pretty nifty. 
Makes sense. Right now my system only talks to other python systems, but that will probably change in the future. I'm thinking about looking at protocol buffers at some point, they sound pretty nifty but I haven't worked with them before. Thanks for the response. 
...... ***Fun*** D:
it's a really hard attitude to overcome that "what I'm used to is ideal, and you're automatically wrong because your thing is different". I mean, that doesn't excuse the people who think it, but I can at least see how they manage to think that. I'm guilty of it myself quite often (for instance, python is\* objectively better than haskell even though I haven't so much as seen a byte of haskell source code) \* this is a joke about how I feel like python is better even though I know logically that since I have no data my conclusion is completely invalid.
You need += not +1
Also check out the [HTMLParser implementation:](http://stackoverflow.com/questions/753052/strip-html-from-strings-in-python) from HTMLParser import HTMLParser class MLStripper(HTMLParser): def __init__(self): self.reset() self.fed = [] def handle_data(self, d): self.fed.append(d) def get_data(self): return ''.join(self.fed) def strip_tags(html): s = MLStripper() s.feed(html) return s.get_data()
I'm sorry if I wasn't clear! The library falls back to using the parser from beautiful soup with ugly html. It is in the docs if you'd like to learn more! 
Or you could use [readability-lxml](http://pypi.python.org/pypi/readability-lxml) (python port of the readability algorithm)
I don't know what parts of the editing process you find the most tedious, but a lot of podcasts here in Germany have recently begun to use [Auphonic](https://auphonic.com/). They do all kinds of interesting (automated) audio processing like leveling and speech detection (and it's free). Maybe that could free up some of your time for the actual cutting.
You should post your code, verbal descriptions of code are kind of hard to follow.
how about you just use matplotlib
Roughly, I would say that you have to figure out the total width of the bar graph by value and by pixels, and divide as appropriate, but I, like eagleeye1, could be more helpful if I had code to work with. 
I read the docs. By default, lxml uses libxml2 for all HTML, ugly or otherwise, and libxml2 almost always does a good job with even very broken HTML. It also provides a same-API wrapper for BeautifulSoup, but will not automatically fall back on it.
what plotting library are you using?
Learn python. If after learning python if you still don't know what to use python for, then you don't need it.
That is the dumbest excuse for not learning python ever. Seriously, pick up a book and read a few chapters. It will take you an hour or two. If by then you can't see the point of Python, then you don't need Python.
It's used in Web Development together with the Django framework. It's used for command line scripting. But basically you can use it for whatever you want, since there are many libraries. There is a lot of scientific stuff, since it's used in this area a lot. There are gui ibraries, database connections. Blender (3d rendering engine) uses it for scripting. Really, you could ask the other way around: What are you planning to do? What languages are you using right now and for what kind of project? There isn't much you can't do with python.
So why are you thinking of learning python, if you can't think of a use for it? 
Thank you answering my questions instead of just saying learn it. It sounds pretty versatile. I'm fairly strong in PowerShell, Batch, VB Script, and some VB.Net. My plan is to be able to create an all in one tool set for system administration. My plan is to create an all in one program with GUI for computer administration. Be able to get remote computer information, machine name change, and join a computer to a domain. I've already created something like this in [PowerShell/VB.net](http://imgur.com/a/SEBYG). 
I currently use PowerShell, but I don't know if Python would be better or provide more options. 