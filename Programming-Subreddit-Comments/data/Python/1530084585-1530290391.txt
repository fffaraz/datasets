I think the problem is we're too kind as a community. :P Hear me out. Our Polish fb groups have the same issue: people ask more beginner questions in "Python Poland" than in "Python: first steps". (It's just not that many posts overall so we don't care much.) Meanwhile, "SysOps/Devops after hours" is flooded with posts starting with "I'm not asking in the main group because it's such a beginner question". In all seriousness, I'm not saying we should get more rude towards beginners, but I like the fact that people aren't afraid to ask us questions.
&gt;with no unit tests Are you supposed to leave your tests in the files you share? I'm following some online course and learning about tests, but not sure about the do and don't about them when you share files.
I see. If it would depend on me, I wouldn't bother with any support subreddits, and kept just /r/python. The items would look like this: https://www.reddit.com/r/Python+learnpython/. It seems acceptable to me, there aren't that many submissions there anyway. It is easy to see which ones are beginner questions, one can just ignore them.
&gt; Subject to preferences? What are these preferences you are talking about? It seems to me, having a solid solution that anyone can rely on would actually benefit everyone. I didn't have anything specific in mind, that I don't see anything wrong with people creating wrappers that match specific use cases better than other available options. If they don't do that, they won't get used much. You sound like we don't have solid solutions and everyone is just sucking at everything and it's all because people have the freedom to have their own take on how a tool should work. The freedom to choose and shop around for what suits best for you is beautiful. Python as a language is buzzing hard and of course you are going to get many different takes on tools. Don't make it sound like all of the tools are bad just because there are many of them. &gt; How can you have something that rises to the top if everyone starts their own project (to suit their preferences as you say)? Generally options rise to the top if they get used more, and generally they get used more because they offer more value. The way you put it makes it sound like every python programmer has created their own libraries and are using only those. That's the only way nothing would rise to the top. This idea of somehow limiting people to one option for every category of problems or whatever sounds terrible. Smells like some real bad bureaucracy if you think about how to actually pull it off.
Okay, I was hesitant since I'm a developer who would be learning this on my own time before being able to pitch it, but now I'm in. I'll make an account when I get home
If you get CLion it supports C, C++, Rust, Swift, Python, and JavaScript.
idk if you're using a tool you should learn how to use the official documentation. Just because we have instant search now doesn't mean you can get away with not knowing how a glossary works for example. It doesn't take much time to figure out if you have basic comprehension skills and your skills will go up waaaay more from figuring it out than from someone ü•Ñ feeding you the answers
Sure, for the actual volume controll it depends on your OS - you most likely want to use someone else's API so for Linux python + PulseAudio and/or ALSA are nice keywords. Windows is annoying but https://stackoverflow.com/questions/25631123/programmatically-changing-system-wide-speaker-balance-on-windows-7 and https://mail.python.org/pipermail/python-win32/2014-March/013080.html looks like your best bet.
Facebook is different though,you're asking with your own face and identity so beginners feel intimidated in a group filled with more experienced people. Reddit is supposed to be anonymous anyways so sending them somewhere else makes more sense than indulging them
Annoyingly, this isn't a universal thing that can be done easily with one command. You'd need a solution for each different platform (OS X, Linux and Windows). As you mention a Raspberry Pi, I'll assume Linux for the sake of simplicity. You could achieve this by using this module: [https://pypi.org/project/pulsectl/](https://pypi.org/project/pulsectl/) Alternatively, you could directly use pactl from within Python by doing the following: `import os` `# increase volume by 10% using Pulse Audio/Bash` `os.system('pactl -- set-sink-volume 0 +10%')`
&gt;And what does exposed to Python mean? Can mean a few things. 1. You use the CPython API and actually write a library that python can build and `import`. [Something like this](http://book.pythontips.com/en/latest/python_c_extension.html). The reference interpreter that everyone uses is CPython. It has a C API. You can do python stuff from pure C/C++. Other APIs exist to use it as well. There's a Python-Rust API. 2. You compile a shared library (DLL/SO/DYLIB), and then write a python proxy interface that uses something like ctypes to invoke functions in it. That acts an intermediate layer of python code that will offer a clean python interface, but invoke code compiled in any other language. 3. You use any other interface. It could be a rest API that runs locally and you write a Python client API that makes calls to it. It could just be compiled to a binary that you can run from the command line, and then you write a python API that simply invokes it and runs the process with something like `subprocess`. Could be anything, but the idea is you write a python wrapper API. Basically, this other software is written in whatever language they want and someone writes a wrapper that makes it convenient and easy to work with that software through another language like Python. Python is just a popular language so a lot of Python wrappers exist.
When I tried to run your `coroutine_example.py` I got the following error: `RuntimeError: There is no current event loop in thread 'Dummy-1'.` Why?
Since you said control panel, im assuming windows is your os. Go to add remove programs in start menu and uninstall python. 
Thanks for sharing.
&gt; This is what you don't understand. The Anaconda Python interpreter and ArcGis one are completely separate. You'll need to install spyder-kernels in your ArcGis interpreter so you can use Spyder with it. I don't use ArcGis so I don't know how to help you with that, but the easiest thing to do is to run import spyder_kernels and get no error in ArcGis. I am confused by something to be sure... I thought Anaconda Prompt was a modified command terminal, not a Python interpreter. &gt; I don't understand very well what you mean by this. All I know is that you can install 32 bits apps in a 64 bits OS, but not the other way around. What I mean is: if there is a possibility of conflict between the bit rate of the Spyder installation and the installation of ArcGIS, would I need to reinstall a matching bit rate Spyder program or is there some way I can emulate the proper bit rate? 
The problem I have is that Reddit doesn't make it clear that there's a learnX subreddit available ... It's also not an obvious usage of Reddit at the same time This is a problem for all languages actually and if you just have a sidebar widget or whatever that can direct you there, then it would help immensely
I mentioned the amazon\_scrapper project just for example of data that could be gathered. I also wouldn't relay on the API, since the data there is often outdated. Perhaps check how to package your library (so you can just pip install it, instead of downloading the repository in your project) 
It may not be "easy", but it is easier than lower level languages like C to get started with.
I think Python is an easy language to learn if you studied maths because the logics are similar, actually you can often just literally translate mathematical definitions into Python and it works.
Create an API... code that talks to another code ;)
Please try running on the main thread. `python coroutine_example.py`
People are probably downvoting you for the pedanticness, but you are correct.
I don't really see the problem with beginner questions. They are the ones who need help the most, as they might not be familiar with where to look for the solutions on their own yet, or they're just stuck at something that could take hours to find a satisfying answer to by googling, whereas experienced programmers can tell them straight away. I've had this alot in the beginning, where the problem is not always obvious (could be a sneaky syntax error or a deeper logical error). 
Thanks a lot man, i'm kinda moderate linux user so i've not seen most of these
Well, that's really the mojo behind Python: &gt; There should be one -- and preferably only one -- obvious way to do it. The problem we have with python packaging and distribution is not one of bureaucracy but the fact communities prefer working on their own, and bitch at each other, rather than federating their effort. End users suffer from this. I have a couple of applications I need to distribute and right now my users, who aren't Python developers, feel totally lost about the right way to get their system up. It's just messy :(
None of the real programming languages are necessarily easy, but Python is usually the quickest to get started in. And a lot of programming concepts will show up in many languages. Technically HTML and CSS are easier, but they don't translate into other things as well - they're really single-purpose type languages, where Python is very versatile.
I‚Äôm running it in an IDE (Pythonista on iOS). Python 3.6.
Compared to what? Which language do you think is easier to learn than Python?
**YES**
Very interesting. You could try this workaround `loop = asyncio.get_event_loop_policy().new_event_loop()` which I found [here](https://github.com/omz/Pythonista-Issues/issues/43).
IMO this is a silly separation. r/python should be for everything including seeking advice, help and discussion. r/learnpython sounds more like for beginners. 
Python has less mechanics than other languages, so yes technically it's easier to learn. 
From personal experience of teaching some folks can say what I consider as 'pro' ease of python for beginners: * big community, good documentation, literally any question was asked and answered (e.g. on StackOverflow) - *easy to find an answer when you stuck and don't know what the problem is really is* * number of broad and narrow topics covered on YouTube, Udemy, etc - *easy to learn step by step or focus on exact topic* * libraries available for everything: Excel, data wrangling, web site scraping, visualisation, UI etc, etc - *easy to focus on job, not wasting time trying to understand how to solve basic task like data load from file* * Unicode from the box, multi-platform, Jupyter/IPython notebooks, *easy to start coding*
Some feedback Can you remove this claim from the website? &gt; "Backblaze will automatically backup all your files including documents, photos, music and movies. Unlimited files. Unlimited file size. Unlimited speed." It sounds like a scam. Unlimited capacity? Unlimited speed? It sounds like that guy advertising unsinkable boats. 
They just rely on the law of large numbers meaning that most accounts back up comparatively nothing. It's not a scam.
We believe it's easy because beginners can start using it and get results pretty fast. I don't really know what you mean by "proper python code" is supposed to mean, maybe that's the source of your confusion?
Cheeky answer : go to /r/learnpython It depends on the kind of test, and the tool that you are using. Doctests for instance must stay with the actual code. But for a decent sized test suite, and any other tool, i think it's best to have it in its own file(s).
Can anyone train a model on r/python posts that have high ranking comments directing them to r/learnpython, and get it to automatically hide the post and refer them to the correct subreddit? It would make an awesome tutorial too!
Learning to program is never easy. It's a whole new way of thinking, and there is a lot of room for frustration as you convert your fluid ideas into concepts so tightly described that even an idiot computer can understand them. Once you learn a couple of languages, they come more easily, so for an experienced programmer, language choice is mostly about picking the best language for the job at hand. But for a beginner, the choice of language can be a deal-breaker, because some languages require you to have a deeper understanding of how the computer works than others. Consider writing a program that asks the user her name and incorporates it into a greeting. Here's the basic way to write that in C: #include &lt;stdio.h&gt; int main(){ char userName[20]; printf("What is your name? "); scanf("%s", userName); printf("Hi there, %s! \n", userName); return(0); } // end main It's not the most awful thing to read, but it doesn't make a lot of sense unless you understand a lot of underlying concepts. Here's the same program written in Java: //Hello.java import java.util.*; public class Hello { public static void main (String[] args){ Scanner input = new Scanner(System.in); String userName; System.out.println("What is your name?"); userName = input.nextLine(); System.out.println("Hi there, " + userName + "!"); } // end main } Again, reasonably clear, but it raises a lot of questions. First, what's up with that public static void nonsense, what's a scanner, why do you need a new one, and much more. All these things make a lot of sense when you actually understand the way Java wants you to think, but that's a lot of overhead for a simple program. Here's the same program written in Python: name = input("What is your name?") print ("Hi, {}".format(name)); As you can see, Python's syntax is quite a bit cleaner and requires a lot less overhead. If you're learning the basic ideas of programming, it makes a lot of sense to start with a language that has a strong layer of abstraction around what the computer does, (Both Python and Java do this) and doesn't require a thorough understanding of how the language operates to use (Python wins on this one.). That's why most programming teachers (including me) often begin with Python. But I strongly believe you should learn one or more of these other languages after you understand Python, because they can do things that Python does not do as well. 
Ok, let me clear my thoughts: I'm refering mostly to people that are in C.S field, so they will most likely be programmers. If you are comming from a C/java background to python, usually you tend to write C code in python with a result to making it harder than it should be to understand what your code does. If you just start with python, you won't know what's happening under the hood and that's another discussion. So i my point is, yes Python is cleaner to write code in but that doesn't make it easier to write code that uses Python as language and it's tools to achieve your goal.
&gt;Everything that people seem to list as advantages of PyCharm can be included with a few clicks in VS Code \- remote interpreter and debuger \- running env and tests in directly inside docker and interact inside pycharm \- great code completion for django (auto recognize db models and completion for Model.objects. methods) and others \- deep support for pytest fixtures (navigation, completions, find usages etc) \- refactoring tools not only for Extract Variable and Extract Method \- great visual merge tool \- IPython notebook integration Can you do that in VS Code?
I've been using it for 5 years, it's legit. They bank on most customers not needing to retrieve it often, and storing low amounts of data. I'm sure some sort of abuse protection will kick in if you try to upload 100TB, but they've been storing my measly two terabytes with no complaints.
Thank you for the link. I restarted Pythonista as it suggested and the script ran fine.
Yes.
Hey guys, I wrote this code here and I'm having a strange issue where the device I'm connecting to using socket is giving me the correct response when I have a breakpoint on the socket object's .recv() function in debug but if I don't have that breakpoint in or run the program as opposed to debug it doesn't work. I assumed that that would be a timing issue so I tried using a sleep to wait before accessing the data and a function that uses a non blocking socket to check that all the data is returned but neither had any success. Anyone seen anything like this before or know what could be causing it? The code is in the Stack Overflow link, thanks in advance, I'll keep an eye if you have any questions too. 
That was my issue with learning to program. I learned so much through Stack Overflow and W3Schools, but reading official documentation was like reading the wrong section of the Rosetta Stone. Now, after using multiple languages for a while, I can finally start to understand a lot of it. 
More details please. ie, how you got the corrupt file etc
Sticky it for a month or two. 
* How do you handle exceptions? * How do you store and resume execution graphs? * Have you ever used a massively parallel data processing toolkit like Ab Initio or Talend to compare their feature set to what you are doing? * How do you monitor the flow of data? * Have you seen Luigi or Airflow? They both solved batch-style data pipelines a long time ago for Python. 
Try to open them via excel first. If excel prompts for some format issue, try opening via notepad. If the text begins with an HTML tag, then use : pd.read_html("your_file.xls")
If it doesn't work, please paste the error message.
If you do t particlaurlu care about the project and who uses it/what they use it for, then use the MIT license. GitHub and GitLab both offer license explanations during and after creation of your repo.
You want AutoMod to find all /r/python posts with high ranking comments then hide the post and message the OP that they should post to /r/learnpython instead? I feel I'm misinterpreting that in some way. 
It makes waaaay too much sense.
&gt; So i my point is, yes Python is cleaner to write code in but that doesn't make it easier to write code that uses Python as language and it's tools to achieve your goal. But in your original post you asked something else: "which language they should start learning". And for that, I'd say python (or possibly Javascript, if they want to learn with GUI). You can start with C, but it is somewhat harder. Syntax itself is more difficult, and incorporate 3rd party libraries is also more difficult. Let's say you want to do some basic example, like download URL page and then parse some info out of it. In C, beginner will spend several hours to just be able to download that URL, then fighting with how exactly string works, etc. In python, it is just a few lines of code. &gt; If you just start with python, you won't know what's happening under the hood and that's another discussion. Yes, that is true. But this is the case for most languages, nowadays.
I wonder if this code I wrote 10 years ago has inspired dill in any way: http://code.activestate.com/recipes/572213-pickle-the-interactive-interpreter-state/
VSC would be a nice step up for you, then. It's not a full IDE so you don't really get the bloat, but inline linting (not inbuilt, mind) and smarter tab insertion and such are really convenient QoL things. (I was in a similar situation to yours, used to use gedit exclusively)
PyCharm is ugly (forgivable if not for the rest) and bloated and slow and ew. VSCode any day
This is often how it results when you try to check something with types.
Check out the online book ‚Äú[automate the boring stuff with python‚Äù](https://automatetheboringstuff.com/) 
Duck typing: if it weighs the same as a duck then it's a witch. 
I will look at that
Who are you who are so wise in the ways of science?
.
Thank you!
SciPy has a really nice article on the subject, called "Python as Glue" https://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
What do you mods think about having automod reply with a message suggesting the user posts to /r/learnpython instead if the title contains a question or keywords?
&gt;but it can't be so complex that I end up understanding nothing. Actually, I think you *want* complex projects so you can see how larger projects are structured and how they deal with breaking the complexity into smaller pieces. Sure you shouldn't be looking at anything as complex as an operating system or something (which wouldn't be in python anyway), but projects that you might think are too big to learn are probably exactly what you need. I'd recommend cracking open some popular open source libraries. Not only do they have some great code, but they're small enough to wrap your head around. And as an added bonus, you've probably used a bunch of them already so you're already familiar with *how* they work, even if you don't know *why*. I recommend checking out the [Requests library](https://github.com/requests/requests/tree/master/requests) source code as a start, because it's absolutely fantastic, and you've probably already used it. If not, make a small project with it to wrap your head around (which will take no time, believe me), and then crack open the source code. Another thing is to start learning programming patterns. And for that there's no better start than the [famous design patterns book](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8). There's also [Game Programming Patterns](http://gameprogrammingpatterns.com). That one is more catered to video games, but it's applicable to anything. All the examples are in C++, but is easy enough to understand with just python knowledge. 
Sounds like something a macro can sort. https://www.jetbrains.com/help/pycharm/using-macros-in-the-editor.html I've used something like this in the past for other stuff.
Honestly I just do regex replace. (underscores represent spaces) Search: `^(.*)$` Replace: `____$1__` It's nothing that I do often enough to benefit from a plugin. Though folks on subreddits like /r/learnpython might like the convenience.
Awesome. Thanks!
I desperately need help in this area, I'm the author of TimeView: www.github.com/j9ac9k/timeview Bonus points for helping out with some qt related testing. I've been on a bit of a break on developing TimeView until School wraps up, which I'm not entirely my last term. Making TimeView more robust with testing and CI oof one of my school projects for the Summer.
That place is my home :D . 
What movie is this?
Yeah that might be a good plan for now, I will discuss it with the other mods.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Holy Grail
You are in for a treat.
.... Since somehow this made the top of the /r/python I will bandwagon of its success and post this survey: https://survey.cerebralab.com/ It's a survey I've created, which will hopefully allow me to correlate certain popular hypothesis in modern psychology with the way people think about code. It's a single randomized question and the few lines of code are in python, so if any of you kind sirs have 2-3 minutes to help me with this that would be amazing :) (All results are stripped of any identifier such as Ip and browser signature and will be made public, only your answer and the random seed used to generate the survey will be visible)
Excellent advices! I liked the recommendations, it was exactly the kind of thing I was looking for. I'll check out immediately both the requests library and design patterns book. Thank you very much!
Well the first sentence should be easy, it's just high-school physics. Granted the notion of symplectic integrator, or of canonical mappings (a symplectic approximate integration scheme is one where every integration step is a canonical mapping) go well beyond high school physics. Let's just say that being simplectic is a fairly important property of exact solutions to Newton's equations, and an approximation scheme that fails to preserve it is likely to depart a lot from true solutions in the long run even if it's highly precise on short time scales. 
I really neede this comment to understand the post. Thanks 
Does anyone get what the "witch" says at the end? I've never been able to make out that line. 
That wouldn‚Äôt explain why it cannot launch from Anaconda prompt directly, that should be in a user folder and when called directly will only touch its own libs. 
 An American White-Winged Scoter Duck, or a Fulvous Whistling-Duck?
Monty Python and The Holy Grail
I hear it as "That's a fair call", but I might be wrong.
Because when presented with long data(either horizontally or vertically), it does that to show the head and tail of the data. if you merge the dataframes into a new one `df4 = pd.merge(df1,df2, on='HPI')` and type `df4.columns`, all of your expected columns are there and to see the data of the first row, `df4.iloc[0]` will show you the first record in it's entirety.
&gt;It doesn't take much time to figure out if you have basic comprehension skills and your skills will go up waaaay more from figuring it out than from someone ü•Ñ feeding you the answers If python is your first language, as it was mine, it actually takes a ton of time. There is a reason why folks use google and not always the documentation. 
Git is a great place to store data, unless it's large enough that it's going to cause problems with git not being able to handle huge files. Be careful about people who say, "it's not supposed to be used for that (I feel)," rather than, "here are the advantages and disadvantages of using this tool for that thing." There are also sorts of things that are improved by storing them in Git even if they're not code. I store a huge amount of [personal documentation](https://github.com/0cjs/sedoc/) in Git, despite people telling me, "MS Word or similar is what you're supposed to use for documentation." I don't care if it's the "wrong thing" if it works better by giving me easy access and replication everywhere, as well as excellent revision history. And yes, I've even stored "databases" in Git: I wrote an accounting system based on tab-separated value (TSV) files where all the data was also in Git, for the same reasons as above.
"That's a fair cop" https://idioms.thefreedictionary.com/it%27s+a+fair+cop
"It's a fair cop". Which at least in the UK is slang for something like "I reluctantly accept that the accusation is reasonable". Usually in relation to a crime having been committed.
As far as I can see - this have no way to 'partial' compare an object?
Ah, cool. Thanks! Never heard that expression before.
&gt; public static void nonsense Sensible instructors tell their classes to treat that **MAGIC** for now. But the more magic the harder it is to feel comfortable.
https://www.xkcd.com/1053/
That's more like a dependent type system, which is able to prove a type given a set of axioms. We could say those languages are witchly typed. 
Not OP but I've looked into this. Backblaze's command line tool `b2` is written (and distributed) in python and via `pip` but it is **not** a library. They do not provide any public API or access to the internals. If you install it, you cannot import it or call it from python. And, while you can easily view the source and probably pick out what you need, you are taking a major risk that something won't break on update
I have been considering B2 for a personal project so this is very exciting. I also saw some of the other ones on Github but was never blown away by them. And, I do not trust myself to write my own. Honestly, I am kind of surprised that Backblaze doesn't have a "blessed" tool like this. At this point, the biggest thing holding me back is that I really want to be able to move files without having to delete and reupload. The alternative (for me) is to just write the files with some random name (`uuid4`?) and then have a database that is `uuid--&gt;filename` so I can change the filename.
I wish I could watch it again for the first time
I currently have 19 TB stored on BackBlaze and I know others that have more. While there may eventually be a point where the 'unlimited capacity' turns out to not be unlimited, it isn't anywhere that 99.9999% of users are ever going to encounter it.
Maybe the other commenter misinterpreted your question slightly, so I‚Äôll add just in case. You‚Äôre asking, when you post some code on e.g. GitHub to share, should you also post the test files? The answer is yes, absolutely. And tests should generally be in their own files alongside the files they test. Tests are an essential piece of code sharing and collaboration because they serve as the specification for the behavior of the code and a safety net when making changes. If someone wants to contribute to your project, a quality test suite gives them confidence when making changes. They can be sure their changes aren‚Äôt breaking things elsewhere in the codebase and help to understand the purpose and corner cases of a piece of code. Testing and test drive development have a ton of additional benefits but these are some of the most fundamental. Generally, the only time you want to strip tests out is when distributing/deploying an application, after development. Like if you put some code out on a server, where it‚Äôs running but nobody is looking at it or changing it, you might leave out tests. But anytime you‚Äôre sharing wit a human who will be looking at the code, absolutely include your tests. Final note: testing is a weird thing to learn and really doesn‚Äôt make sense until you‚Äôve worked professionally or on a large open source project and seen the benefits of a great test suite (or the consequences of a poor one). So if the value doesn‚Äôt make a ton of sense while learning, don‚Äôt fret. It will eventually become clear. 
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Thanks for this cool answer! I was thinking tests were "personal" (for thoses who work on a project only) and imagining it would only makes the comprehension more complicated, but i didn't considered the case of collaboration. 
Nice usability features for asyncio. We are getting there, steadily. The hard work being done banging it into shape is very much appreciated.
That comic outlines a true, real fun fact about life. I love it when numbers make a solid case for optimism. 
Honestly just having `breakpoint()` is incredible. I absolutely love the changes to classes too. Reducing boilerplate is always great. My favorite though is ordered dictionaries. That is so useful, and it will help prevent a lot of bugs from new developers :) 
`in` tests against the index. You want.. aux = pd.DataFrame({'test': ['1','2','3']}) aux['test'][0] in aux['test'].values
Anaconda often lags by 3+ weeks.
It's actually quite tolerant of experts asking quite specialised questions. The problem is with "do my homework" posts or "how do I for loop"?
Thank you!
Does that mean she admits she's a witch?
 if thing.weight == duck.weight: assert isinstance(thing, Witch) 
It's also a callback reference to one of the Flying Circus sketches. Can't remember off the top of my head but it might be Crunchy Frog 
She cops to it. We have that idiom in the US, too (though less common now)
Certainly plans to add multithreading but it needs to detect support since web app servers may not support it. Top of my list.
The thing that still bugs me about asyncio (coming from JS and C#) are two fold: * coroutines are not Futures/Tasks (js think Promise), thus arguably causing unnecessary extra wrapping * the loop itself seems to block the Thread (maybe even the entire Process, but I hope not) when told to start executing. Which means if you want to run sync code and run some async code in the background (ex in JS delay you can update visuals asynchronously without having to wait for it to complete before your logical restrictions are set). So to get similar functionality a new thread, and a loop for that thread, has to be explicitly made, along with having to explicitly use the threadsafe versions of methods to submit them into the loop A nice benefit of of JS is that since there's only one event loop you don't have to explicitly submit anything either.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
I also wrote one around the time b2 was released: [backblaze-b2](https://github.com/mtingers/backblaze-b2) It started as a test, but then people started contributing (needs cleanup/refactor). Some features that you may want to consider: * Multithread/process upload * Low memory consumption (streams data) * Encryption (pretty sure I did this half right so don't use my example :) I've only glanced at your code, so you may have some of these covered. 
* Ansible is written in and can be extended with Python. Have a look a the docs and the source code. * Search on PyPI for libs related to your stack and to typical admin topics, like parsing log files or reading and writing popular config file formats * Use something like file /bin/* /sbin/* /usr/bin/* /usr/sbin/ | grep -i 'python script' to find other programs written in Python. Have a look at the libs they are using if there's something interesting. 
&gt; Honestly just having breakpoint() is incredible. You are aware of pdb, I hope?
The article points out that `breakpoint()` is just a shortcut for `import pdb; pdb.set_trace()` which is very annoying to use. I honestly have to look it up half the time to remember the syntax.
First a logic error, if thing.weight == duck.weight, there‚Äôs no need for the assertion, we‚Äôve already proven that if it weighs the same as a duck it is a witch (and floats on water and made of wood) Second, it‚Äôs quite common to run python in production with ‚Äú-O‚Äù, which disables assertions, so the above code would run in production, but not for the reasons you think :-)
I plan to add some significant improvements to asyncio in 3.8 and 3.9. Buckle up. :)
To the people stuck on 3.6 LTS, there is a backport on pypi: https://pypi.org/project/dataclasses
I was able to download https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz but it is not listed yet on the CPython website directly (this will most likely change in a few hours). The timestamp of the files in it are from 5 am this morning. I've also create a pull request on pyenv: https://github.com/pyenv/pyenv/pull/1177 
Because mandatory type annotations are such a good idea.
Your second point is very valid: asynicio's event loop is known to be bad when used for anything beyond very simple code. 
Adding a read() to the end of your script will prevent them from closing
Use pythonw.exe to run the script instead of python.exe For more info: [https://stackoverflow.com/questions/9705982/pythonw-exe-or-python-exe](https://stackoverflow.com/questions/9705982/pythonw-exe-or-python-exe)
 Save as .pyw should do the trick ?
Have a look at [Natural Language Processing with Python](http://www.nltk.org/book/ch01.html)
Thank you ! 
Ah, thank you. Exactly what I was looking for.
I assume this would then associate the file with the pythonw.exe interpreter mentioned in the other reply?
Yes
Library was located at /usr/lib/i386-linux-gnu and when I copied that to project folder everything worked. I am under impression that is not correct way to do that and system should find shared libraries from location mentioned before. Or is this suitable way of working? Or can it be that python module did not try to find library from that location?
Yes, its huge.
Being able to relive completely losing my shit at the "Knights of the Round Table" song sounds pretty great
Disclaimer: I work at Backblaze. &gt; It sounds like a scam. Unlimited capacity? &gt; &gt; It sounds like that guy advertising unsinkable boats. Just to be perfectly clear for people new to Backblaze, Backblaze offers two totally separate product lines: 1) Personal Online Backup for Mac and Windows for $5/month. This was the original product line. It has some restrictions, for example it does not backup NAS drives or any network mounts. If you save several versions of one file, it only keeps the multiple versions for 30 days, then it only keeps the very final version as long as you keep it on your laptop. If you delete a file from your laptop, then after 30 days Backblaze deletes it from the "backup copy" in our datacenter. This product include USB attached external drives for no additional charge. This product was targeted at CONSUMERS, like my 85 year old father who does not know much about computers. 2) B2 Storage - this is for programmers. This is an API. This charges half of one penny per GByte per month. Use that storage in any way you want. You want to archive content and keep thousands of versions of the same file? Great! Backblaze charges you for every copy, so we're SUPER happy to store anything you like for as long as you like. If you make a copy of your NAS drive, great! &gt; It sounds like a scam. Unlimited capacity? The Personal Online Backup product is advertised that way to prevent "sales friction". We aren't trying to attract the largest data customers, we realized that 85 year old consumers don't know the difference between a GByte and a MByte and would be "stressed out" that their bill would change every month. They would also contact support when their bill was too high and ask how to decrease the bill. So we made it "easy". Backblaze backs up everything on your laptop, done! Price is $5/month, done! Backblaze loses money on anybody that has more than about 1.5 TBytes, and makes money on those customers with less than 1.5 TBytes. Overall, Backblaze lives on the averages for this product line.
Not too familiar with Twisted, but isn't their entire reactor/event loop based around the concept of the application being some web server? Which is extremely limiting.
Disclaimer: I work at Backblaze. &gt; I'm sure some sort of abuse protection will kick in if you try to upload 100TB Nope! Our largest "Personal Backup" customers have 150 TBytes fully backed up. Backblaze lives on the averages, and it turns out for every 150 TByte customer there are a ton with only a small amount of data (like 50 GBytes) and it brings the average down to where Backblaze can make a small profit. If you think about it, several things work in Backblaze's favor. Remember that you must *HAVE* 150 TBytes before you can back it up. The "Personal Backup" product line isn't an API (the API product is called "B2" and is priced differently), our software is the only thing allowed to make copies of files from your laptop into the Backblaze datacenter. Our software only runs on Macintosh and Windows, so it doesn't run on Linux servers (the "B2" product line is designed for Linux servers). It turns out, for a consumer to purchase 150 TBytes of disk is fairly expensive (like $10,000?) Most customers don't have $10,000 extra dollars, and they don't want to find the space and electric power to keep 150 TBytes running in their homes. Finally, most consumers don't have the bandwidth to push 150 TBytes to the Backblaze datacenter in any "reasonable" amount of time. All these things conspire to make Backblaze perfectly profitable by offering a "$5/month unlimited backup".
Do you want your program to draw the blue or the green lines? Or lots of those blue lines, one per vector? If I'm reading correctly, you want one line per vector, and each line needs to start at (0, 0), and finish at the sum of the current vector and all previous vectors? Say you have the vectors: (1, 1) (2, 2) (4, 4) You want 3 lines, which are (0, 0) -&gt; (1, 1) (0, 0) -&gt; (3, 3) (0, 0) -&gt; (7, 7) In this case, you would still use the cumulative sum, but you would iterate through each pair in the `np.cumsum` result and do a new `ax.plot`, like import numpy as np from matplotlib import pyplot as plt my_vectors = np.array([ [1, 1], [2, 2], [4, 4] ]) my_cumsum = np.cumsum(my_vectors, axis=0) fig, ax = plt.subplots(1, 1) for row in my_cumsum: ax.plot([0, 0], row)
I am conflicted about ordered dicts. Do I like them because it's incredible useful, or do I not like them because it restricts what future optimization can be done?
It also works based on an environment variable and hence you can turn on and off at will unlike pdb. Also a disadvantage is that you have to update your linters if you want to lint for them in your codebase.
cmd+A (select all), tab, cmd+c (copy), click in reddit, cmd+v (paste), click in Pycharm, cmd+z (undo)
This doesn‚Äôt answer any question asked...
The idea is to not do all of that. 
I actually used to be really into Udemy courses when I first found out about it. It‚Äôs a great concept, but I never really learned much from them. I‚Äôm not saying it won‚Äôt work for you but they never really helped me. It might be a good introduction for you since you‚Äôre a beginner and it can make it less intimidating, but if you choose to go a different route books are a great option too. I used to hate reading programming books but if you really just take an hour out of your day to read one you might get a lot more from it than from a Udemy course.
&gt;saying Thank you! Any book suggestions?
Didn't like: The Right Way TM Liked: the article
Oooh!!! *This* is why it's called "duck typing"?
That first scene when the "horses" appear from behind the hill, not knowing anything about the Mounty Python at the time, was one of the best movie experiences I ever had.
Thanks for the feedback, and for reading the article regardless of the title :)
About the Linux thing... Any chance you'll be making a desktop client available for use? I run Linux full-time so my backups are a few tests old by now since they were uploaded back when I had a Windows install. If abuse is the problem I'm sure there's some technical way to prevent it from running on big servers and such. (Actually, does it run in WINE?)
I don't know that! Wait! N^o^o^o^o^o
No, actually it's not, it's because "If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck." I and I assume the OP were joking, using the Monty Python's nonsensical sketch to derive a nonsensical definition of duck typing, in a nonsensical way.
I'm pretty sure duck typing is really a reference to the older [duck test](https://en.wikipedia.org/wiki/Duck_test) (which is often phrased "if it looks like a duck, and swims like a duck, and quacks like a duck, it's probably a duck"). The similarity to Monty Python is probably a coincidence (or the scene from the Holy Grail might be referencing the same idea).
It is the JS and C# implementation that is dumb. The way they are designed forces a specific pattern of usage. The python implementation is much nicer using basic generator function features, that doesn't depend on any particular event loop implementation. The reason futures and tasks feels clunky is because the asyncio event loop is clunky and doesn't provide a nice interface for dealing with raw coroutines. The problem goes away entirely if you switch to one of the alternative event loops like Curio and Trio.
The one I used for an introduction to python was ‚ÄúIntroduction to computing using python: an application development focus‚Äù by Perkovic. It‚Äôs a bit pricy ~$50-60, but it‚Äôs actually pretty good. Reading a programming book can be extremely boring but once you get past ~10 pages you should be good. There‚Äôs probably other great python intro books out there so make sure you look around the internet. 
The title was likely intended to attract your attention. It appears to have worked. Nevethless, I agree, good article.
I'm going to be honest, I didn't know about it. So, with the improvements and everything, this is opening up a whole new world to me.
So long as you are happy to read - then you don't need a course - just follow the official Python tutorial. It is very good (in my opinion), and unless you are going to use Python for something very complex from day 1, I don't think that a course is a good use of your time. 
Sneak peak?
Mind I ask, where are we going?
Data science is just doing science, nothing special there. It is just the catch-all term picked up in industry to explain their need for people who know how to make sense of data. NLP is just one area where you can do this which happens to be relevant in many industrial applications. Doing tutorials won't get you as far as you need to go. They are too sterile and they don't force you to think. Though they can be useful for helping you solve a problem you already have. If you want to learn NLP you need to take-up a moderately challenging problem then adopt whatever skills you need along the way to solve it. For example, sift through the NLP literature and learn what it is about, when you come across something that peaks your interest, try to reproduce it using your own data. Search for some data-set online, go through the hassle of cleaning it and organizing it and then write the algorithms you need to reproduce the paper, or find a Python library that implements it. You can even come up with your own questions along the way. In going through this process you will be forced to become familiar with many of the aspects of practical NLP that you are confronted with in the real-world. And you will become familiar with what tools and techniques are available and how to use them to solve a problem. You want to get to the point where you can come up with your own unique question and then use or search for the tools you need from NLP literature or Python libraries (like Gensim) to solve it. Even better, make it an open-source project that you can put up on github to show off, make it a package that is easily install-able and usable by others. This will force you to write good code. Then if you go applying to places you can put on your resume that you did X, Y, Z projects using A, B, C techniques, which recruiters may see as hot keywords they were asked to look for. Make sure you understand those techniques you use from the bottom up, not just practically. For instance, if you pick a project that ends up using Word2Vec, even if you only use Gensim's implementation, you should be able to explain how it works during an interview from first principles, which means being familiar with the literature surrounding the technique.
The JS / C# implementation is dumb because it forces patterns of usage? In what way do they force usage patterns. *Python* forces the usage patterns the boilerplate of having to set up and handle loops across threads in different ways, and makes the coroutines non extensible. Trio does not accurately solve this problem either. Not sure about Curio, haven't seen it in action. To your edit: I have no idea what you're arguing. It is irrelevant in C#/JS. It is not in Python-- I can't easily add callbacks to awaitables.
The fact that dictionaries became ordered was a side effect of the optimization done in 3.6 taking PyPy's implementation. It wasn't optimized as a side effect of making them ordered. Then in 3.7 people said "well the fact that it's orderered is actually very useful, lets make that not a side effect of an implementation detail but rather a requirement of the spec" to avoid issues with people going from CPython to some other flavor. So long as optimization is wanted by the community more than ordering, when a more optimized structure is thought of, it will be reverted.
Can you elaborate? I don't get your point in reference to the parent comment.
You're right, I could do better: if thing.weight == duck.weight: thing.__class__.__eq__ = sir_vladimir.use('largest_scale').balance_check(stops=False) if thing.weight == duck.weight: witch = thing burn(witch)
Because adding ‚Äúnot trying to discourage‚Äù makes it so that it‚Äôs impossible for it to discourage me.
Thanks for not wanting to crush my hopes at actually being good like some people
3.7 adds data classes, data classes must specify type annotations, being required to use type annotations in Python is a good idea. Now you have to work out if I'm being sarcastic or not.
Yeah, but that's going to be a breaking change if they revert (Albeit a very minor one if everyone just keeps using OrderedDict when they need ordering). Ordering fits with python's main use as the scripting glue language that works with anything, so I'm not complaining too much.
Nice! And thanks for the recommendations. I'm definitely going to add multithreading and I actually just added streaming data. Might eventually add encryption. Appreciate the feedback!
&gt;https://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html Yes, there is really little room for improvement. As an example, with MKL configured etc, pytorch will deliver so much work to 3 \* 1080 ti GPUs and a i9-7200x that the [Power Draw](https://imgur.com/soiRNKJ) pops the over-current protections on a 1200w PSU. (note one unused GPU with no OC) I will have to migrate to volta based GPU units or move before I can improve much on the CUDA/MKL/Python solution because my house can't support more. It would be *premature optimization* to move to another platform in the hope of gaining small efficiencies as the back end libs are some of the most efficient available in the industry.
kind of , i need to creat a link for more then one think 
Not quite. I want one line per vector but I want each successive vector to start from the end of its predecessor. So, it would look like (0,0) -&gt; (1,1) (1,1) -&gt; (5,3) (5,3) -&gt; (8,13) I changed your numbers because those would result in one straight continuous line, which might be okay in some cases, but doesn't accurately represent what I'm attempting. Also, I accidentally got python to do what I wanted it to do without using the code from stack overflow. I really appreciate the attempted input, though!
I figured it would be fine since I wasn't looking for code help, I was looking for something premade. I apologize for the inappropriate post! Thanks for letting me know that I should take these sorts of questions to r/learnpython instead.
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [My new book, "Cracking Codes with Python" is now available and free to read online!](https://np.reddit.com/r/learnpython/comments/7sigre/my_new_book_cracking_codes_with_python_is_now/) \#2: [I'm releasing a free code for the "Automate the Boring Stuff with Python" Udemy course](https://np.reddit.com/r/learnpython/comments/7fxork/im_releasing_a_free_code_for_the_automate_the/) \#3: [I made a python cheat sheet](https://np.reddit.com/r/learnpython/comments/82t191/i_made_a_python_cheat_sheet/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Also check out the discord for fast answers
I can't tell if you're being sarcastic or not but your throught process is just wrong. Let me get this out of the way-- requiring types in Python is not good IMO. But dataclasses by definition of their rationale have no meaning without typing. Not to mention you can simply set the type to `Any` if it really bothers you that much.
\&gt; Python 3.7 is officially released! Whut?
The fact that it's now ordered is technically a breaking change-- what if someone decided to use the disorder of dicts to psuedo randomly get an item from a container? Much more performant than using `random`, assuming they understand that to utilize this method all objects in the container must have been generated immediately before picking and must be objects that are not interned by the VM (small integers, true, false, etc). The fact that OrderedDicts still exist and make no mention of "this class is pointless and a thin wrapper around dicts", makes me think for insurance purposes people still should use it.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
This happens because using `in` on a DataFrame asks about the keys (of the index of rows, in this case -- similar to asking `in` against a dict). So, if you were to ask: &gt;&gt;&gt; 1 in aux["test"] True &gt;&gt;&gt; "1" in aux["test"] False As /u/SupahNoob said, you should be asking against `aux["test"].values`.
Hi there, this post has been removed as it is not directly related to the Python programming language. It might be more topical on /r/programming, /r/coding, or /r/technology. Cheers, /r/Python mods
DataFrames and Series are dict-like, where the index/columns are like dict keys and va. That means that '1' in df checks for member
Why are people on this sub so deathly afraid of being exposed to types?
I don't know what you're talking about. Async in C# is beautiful. All you do is change your method from returning `T` to a `Task&lt;T&gt;` and proceed as normal. I don't do much JS so I don't know about that.
The language was named Python because the creator Guido van Rossum fell asleep while watching the movie and then created the language from a dream he had
I'm still intrigued by what it is you wanted to start with, and it's going to bug me. In your example above, what were your original vectors?
&gt; But dataclasses by definition of their rationale have no meaning without typing. Aren't they just supposed to be a prettier version of `namedtuple`?
It's a running joke through a whole episode 
I like that implementation -- Keeping it simple. The only downside I saw at first is that you couldn't easily create a partial() for it to make the pipeline re-usable... but that's not true, you could just unpack a tuple or list. double_pipeline = (lambda x: x * 2, str) functoolz.pipe(data, *double_pipeline) - seems equiv to: - double_func = functoolz.compose(reverse(double_pipeline)) - or - double_func = functoolz.compose(str, lambda x: x * 2) double_func(data) So I guess this kind of flow has already been put together.
Not OP but GitHub search doesn't return anything open except for a performance improvement PR. Curious about the changes too. https://github.com/python/cpython/pull/6876 https://github.com/python/cpython/pulls?q=is%3Apr+asyncio+is%3Aopen 
OrderedDict is not pointless. You can pop items from either end, move keys to either end, do reverse iteration, and has order sensitive equality checks.
But the disorder was never part of the specification. If you rely on implementation details of a specific interpreter, of course you're going to have portability problems. 
breakpoint is good, but try debugging with PyCharm...it's great!
I'm all aboard using type annotations, but one of the problems people have with them in python is that they're very verbose and not very powerful.
The PEP says it is "expected". [https://www.python.org/dev/peps/pep-0537/#release-schedule](https://www.python.org/dev/peps/pep-0537/#release-schedule)
I use pycharm occasionally and I think it‚Äôs the best IDE, but I‚Äôve super into vim the last 6 months
WOrked like a *charm*: class DressDataScreen(Factory.Screen): def on_pre_enter(self, *largs): parts = self.manager.get_screen('part') datafield = self.ids.datafield datafield.clear_widgets() datafield.add_widget(Factory.GridLayout(rows=2)) for wid in parts.walk(): if isinstance(wid, Factory.ToggleButton) and wid.state == 'down': datafield.add_widget(Factory.Label(text=wid.text)) datafield.add_widget(Dropper())
I thought she said ‚ÄúThat‚Äôs a fat duck‚Äù...
You might get more of a response for this over at /r/learndjango
These are not the pretty version of named tuple, in fact the PEP goes into "why not named tuples".
...I never said it wasn't?
The specification included "items may not be in order due to their hash values", wasn't it? The documentation warned of such in multiple places.
&gt; Any chance you'll be making a desktop client available for Linux use? For Linux, we recommend B2 with a variety of tools available today! Pick from anything in this list: [https://www.backblaze.com/b2/integrations.html](https://www.backblaze.com/b2/integrations.html) (be sure to scroll down). If you don't have any preferences, some of these tools are already built into all Linux distributions and support Backblaze B2 "out of the box" with zero modifications, no software to install. I think Duplicity and/or Duplicati? We have also heard great things about Arq which supports Backblaze B2: [https://www.arqbackup.com/](https://www.arqbackup.com/)
I don't mind type annotations, but I dislike broken promises and having to type extra things.
https://www.python.org/downloads/release/python-370/
Nice
Yes, but it wasn't specified behaviour, it was a warning about *un*specified behaviour that could otherwise have been assumed. The keyword is ‚Äòmay‚Äô here. 
They are often less verbose than docstrings. I'm a big fan of using them in conjunction with [sphinx-autodoc-typehints](https://github.com/agronholm/sphinx-autodoc-typehints).
https://i.imgur.com/M5XLdNd.png
The whole PyData stack could use a lot more testing, but Xarray is particularly dear to me and already has an issue listing some tests they need someone to write: https://github.com/pydata/xarray/issues/1846 Using [Hypothesis](https://hypothesis.readthedocs.io/en/latest/), which is practically magic and makes testing more fun than tedious :-)
I'd appreciate any tricks you'd be willing to share. I used Vim for a long time, then PyCharm, and am probably going to stick with PyCharm, but I drop into Vim now and again and would love to switch totally if I could get a few kinks worked out.
Very small rocks! 
Any word on when a Numpy wheel will be available?
Where do you go for middle of the road? eg I was contemplating asking a fairly broad question on project file structure, where to store things, separation of scripts, sort of high level stuff. But where do I go for this?
I'm aware - however I meant for the home use $5 backup plan :)
Finally, we can get rid of python 2. 
For 3.6 the wheels were released *before* 3.6 was officially released, so I expect in the next few days.
Nice
What about 3.7 means you can finally dump Python 2?
Noice.
&gt; isn't there some deeper problem To me, the deeper problem is that when you search Reddit with the keyword `python`, the results are these, in this order: 1- /r/Python 2- /r/PythonTips 3- /r/LeanPython So, people just go to the first result and (since they didn't read the sub's description in the search results they won't read the sidebar) they'll just post a new thread.
I thought it was a joke lol
thanks, the latest news on the [python.org](https://python.org) front page still talks about the rc 1 which is why I was confused.
Think 2 is still good till 2020. 
&gt; It will become the default in Python 4.0. \*blinks\*
Can anyone explain to me - a relatively new Python programmer - why so many people are against updating to the latest version? This seems to be one of the only languages plagued with this problem. When I first started writing scripts, I noticed some slight differences in the syntax that were made between 2/3, but it seems like those would be simple to address even in large scripts. Do the benefits not outweigh the drawbacks, and what about the potential security concerns of using outdated software?
Here's the problem with Linux (and where Windows still wins)... Ubuntu's repos are still on Python 3.7b3 as of right now. God damnit will the repos hurry up so I can install this.
Libraries
Budget to migrate legacy code would be one reason. Having worked in a small dev team for a large non-tech company, we had plenty to do and updating working code was a luxury we couldn't afford. *(didn't want to spend on) 
Nice
Happy cake day /u/TwinkTuckr! [Here's some cake!](http://gph.is/1WDTNoY)
Because Python is used for a wide range of applications including a lot of code that is never released outside of the company that uses it. The time lost vs the benefits gained from switching to the newest version of Python is not worth the investment. Python 2 can do everything Python 3 can in terms of the results you can get out of it even if the implementation might be better in Python 3.
You can't install it without the repo? (I use Arch Linux which is on 3.6.5-3)
*Think 2 is still dead by 2020
Sounds like the transition between C/C++. It seems eventually, people won't have a choice to either stick with legacy or adopt. Are there not automated methods of at least making a Python 2 script *work* in Python 3, just for the sake of potential improvements in benchmarks/security?
This all makes sense, but imho there is no reason to continue writing python2 code.
Nice
Thanks for the answer. I truly hope Python never stumbles upon a zero-day exploit for 2.x, because then said companies will be scrambling and wishing they'd have updated their code.
You ask retarded questions? Obviously I don't want to compile it from source. It's way easier to install on Windows.
I just downloaded 3.6 last night! Bother...
:( why is that ? 
+1 I've ported several scripts from 2 to 3, but never thought twice about writing something new in 3.
Sooo who‚Äôs already using it in production? 
There are probably a lot different reasons. Some that occur to me are: \- Python is pretty frequently used by non comp-scientists are are generally less inclined to embrace learning new languages \- Moving from Python 2 to Python 3 typically breaks stuff. So unless you start something in Python 3, it's usually a headache to get everything back up and running if you switch. \- Not all libraries get updated. This again goes somewhat back to non CS people contributing lots of code but not necessarily having the interest to update for newer versions. \- The differences between Python 2 and Python 3 aren't drastic enough to convince most people to switch. 
Good catch. 
One day soon...
I don't think that this implies that Python 4.0 is in progress in any meaningful way.
Yep, [it's built-in to Python](https://docs.python.org/3/library/2to3.html). I can't understand for the life of me why anyone would still be using Python 2. 3 has been out for 8 years...To put that in perspective, Python 1 was released **6 years** before the release of Python 2, and Python 2 was released **8 years** before Python 3. Honestly if Python 4 was released next month, it would be in line with the current history of Python. Folks need to get their shit together and stop using technologies that are outdated by nearly a decade.
I know this sound stupid...but what this 3.7 diffrent with 3.6
Interesting. At least the libraries I use, are very frequently updated and insist on using 3. In fact, it's become such a common thing when importing new libraries, that I automatically ignore anything that's only 2.x compliant. I suppose, depending on the complexity, if no such library existed I would write one myself before using an outdated/unsupported version. There's a ton of open-source libraries that are constantly updated, and IMO the only ones that don't probably don't have many active developers, and may "work" at the cost of losing the benefits of other libs. Again, this is all my opinion as a new 3 user and could be wrong, just speaking from initial perspective.
I'm sure it depends quite a bit on what field you're in. In Physics &amp; Astronomy, for example, it is VERY common for a person (or group of people) to build some kind of analysis tools in python or a set of wrappers to help interface python with some existing C++ code and then 100&amp;#37; abandon it once it functions. Whatever version of python was most current when it was written is very likely the only version it will ever successfully run on. I can't necessarily speak to CS fields, but in the physical sciences it's pretty typical for people to write lots of code and follow none of the best practices (e.g. commenting code, handling package dependencies, etc). 
so happy it finally released, was using the beta verison of 3.7 before, and am really happy that its on a stable release now. the thing i am most excited about is the dataclasses, love them so much
Multiple reasons: * Py2 startup time is significantly faster. For CLI applications and various validation scripts this is especially important-- imagine if git's interface layer was in Python, and because of this every time a command was executed you'd have to wait longer for the python VM to start just because it was Py3 * Variety of internal applications that of which upgrading to Py3 would just be wasted time * Libraries that are still Py2 only * Frameworks that are Py2 only. Ex, Pylons and Pyramid-- a mature Pylons application would have to be majorly rewritten in terms of the views/controllers, configuration, and middleware * Why switch at all? Don't fix what isn't broken as they say * other non python pieces and their interaction Same reason why there are many people still on Java 6/7 even though Java 10 was released a few months ago, and 11 will be released in (September?).
Nor do I, it‚Äôs just the first time I‚Äôve seen it mentioned in such an official manner.
See the dozen or so PEPs at the top of the link! Lots of people are excited about Data Classes
At a general level, I write everything I can in Python and only fall back to C or C++ when speed or available libraries necessitate it.
2 will never die-- May run out of official support but with all the companies that still use it, it would be cheaper to write patches to the Py2 VM itself than switch the entire codebase they have to Py3
Wait. Is 3.7 the last Python 3? Are we skipping 8-9 from 2 on?
That‚Äôs not how versioning works.
...I can't tell if you didn't bother to click the link or what but: &gt; Among the major new features in Python 3.7 are: &gt; PEP 539, new C API for thread-local storage &gt; PEP 545, Python documentation translations &gt; New documentation translations: Japanese, French, and Korean. &gt; PEP 552, Deterministic pyc files &gt; PEP 553, Built-in breakpoint() &gt; PEP 557, Data Classes &gt; PEP 560, Core support for typing module and generic types &gt; PEP 562, Customization of access to module attributes &gt; PEP 563, Postponed evaluation of annotations &gt; PEP 564, Time functions with nanosecond resolution &gt; PEP 565, Improved DeprecationWarning handling &gt; PEP 567, Context Variables &gt; Avoiding the use of ASCII as a default text encoding (PEP 538, legacy C locale coercion and PEP 540, forced UTF-8 runtime mode) &gt; The insertion-order preservation nature of dict objects is now an official part of the Python language spec. Notable performance improvements in many areas.
Too noob to understand what the excitement is about for the update. Someday, I'll get there...
Here‚Äôs a link to the release notes: https://reddit.com/r/Python/comments/8ue8kg/python_370_released/
If not in the language then in some library which is unsupported. So it's inevitable at this point.
No, if you look at the official github preparations for 3.8 have been underway for a while. 
I mean...i told you the question might sound stupid to a python user...while Iam just learning it...so is the 3.7 gonna affect 3.6 and should they transit to 3.7?
I'm okay with types but this part of the argument doesn't make sense. Type hints are comparable or worse when writing a thorough doc, as one should. As an example, docstrings: def destroy_the_universe(x, y): """Destroy the Universe Destroys the universe by summoning cuthulu at the given coordinates. :param float x: the x coordinate of the universal plane :param float y: the y coordinate of the universal plane """ ... Vs type hints: def destroy_the_universe(x: float , y: float): """Destroy the Universe Destroys the universe by summoning cuthulu at the given coordinates. :param x: the x coordinate of the universal plane :param y: the y coordinate of the universal plane """ ... We've literally just moved the location of where the type was defined. No more nor less verbose. However, special and more complex types actually need to be / are highly recommended to be imported from `typing`, making type hints more verbose.
But at that point, you're just delaying your failure.
I'm not going to literally repeat what the PEPs say because you're lazy to click the links?
Reading that feature list is like [this vince mcmahon gif](https://thumbs.gfycat.com/OptimisticPaltryFattaileddunnart-size_restricted.gif)
It'll probably just be the release that comes after 3.9, instead of 3.10.
Nice
Looking forward to using `breakpoint()` I suppose.
nice
Less and less relevant considering [the vast majority](http://py3readiness.org/) of popular packages are compatible with Python 3 nowadays.
Wrong subreddit.
Point me in the right direction? 
There's a link... it's clickable.
My mobile must be acting up. Will check when I‚Äôm at my PC. Thank you! 
Same reason people are still running windows XP
One of my Geography professors wrote a lot of code, but there are barely any comments and it's really hard to follow.
3.6 isn't going anywhere. You can still use it if you can't or don't want to upgrade to 3.7. But if you're just learning then you aren't going to notice any real difference between the two. The changes are all more advanced features.
&gt; Deterministic pyc files What does this mean for the execution time after pyc files are generated
Uh...ok
C will never fully transition to C++. They are different, but related, co-evolving languages. C is still heavily used in embedded with good reason - despite its flaws it is simple and easy to reason about it. There's at least one verified C compiler (Compcert), that is, a compiler that can that is mathematically proven to produce assembly that corresponds to the source. That's the kind of assurance you need (or should have, if you are competent) when software errors mean people die. C++ is too complex for this sort of thing. Way too complex. On the other hand the only reason to keep Python 2 is legacy inertia.
I like dict ordering becoming part of the language spec. Also a really big fan of the dataclass decorator. Can't wait to try that one out.
3.6 released Dec 16. Debian Stable (and unfortunately raspbian) is still on 3.5. You can build newer versions, but still
Real example: 100k+ line 6+ year old monolith app with a variety of dependencies (some only py2 compatible). Broke out as much into microservices but a core monolith app remains and it works. 6-9 engineers on a product always iterating frontend and other backend needs. No time or prioritization to go through and make the changes. And honestly a lot are minor but some just become headaches. Like one Django psql json field dependency that unfortunately means a mass migration as the data type would change. Shit just becomes a headache and dropped I priority as other fires arise.
Lol same
Yeah same here I wish this made at least some sense to me; trying to figure out from the comments but it's never a very fruitful approach.
&gt; Frameworks that are Py2 only. Ex, Pylons and Pyramid OK, [let's see what their docs say](https://docs.pylonsproject.org/projects/pyramid/en/1.9-branch/quick_tutorial/requirements.html): &gt; Pyramid fully supports Python 3.4+ and Python 2.7+. This tutorial uses Python 3.6 but runs fine under Python 2.7.
Nice
Yeah, but that's not really a Python 3 thing. That's a "you were never going to do any kind of upgrade of anything" thing. A *lot* of places that talk about Python 3 being a hurdle are really covering for any type of maintenance or infrastructure work being a hurdle due to their organizational structure.
Java developer here. Java 10 really breaks from 8 in terms of backwards compatibility. We're in the process of upgrading our apps in our shop but a lot of third party apps we use are stuck on Java 8 for the foreseeable future :/
And no one wants to do it. It's painful, error prone, you get all the blame and no one appreciates the impact since it's not immediate. Out of a team of 20, only me and another programmer would push it whole the rest were all interested in getting new features out instead. Technical debt is a very poorly managed aspect of programming.
&gt;When I first started writing scripts, I noticed some slight differences in the syntax that were made between 2/3, but it seems like those would be simple to address even in large scripts. They aren't. First, it's not just "scripts", many people have huge codebases based on Python, running complex interworking services. Secondly, the change to strings becoming unicode (instead of raw bytes), is \*hugely\* impactful for many kinds of work. Just as unicode strings made it (presumably) easier for many programmers, it also made things very much harder for others, not just for the transition to 3, but for new code as well. The autoconverters often can't help here. That said, the recent work on type annotations, etc. may help the stragglers to start to safely convert; it's still a large and potentially costly job, though. Things like the improvements in dictionary space usage, and other recent features, may also finally be enough of a carrot. One last inhibitor is that whereas many Linux distros, and MacOs have come with a version of Python 2 for many years, a version of Python 3 has often only recently started showing up. I think that also had a significant effect on early adoption.
Maybe I wasn't clear enough-- historically speaking people used to write things using Pylons. One meta example is reddit itself. Pylons never got a version that worked on Py3, so if people wanted to upgrade to Py3, it would mean switching to a new framework, in this case, as recommended by the Pylons team, you'd switch to Pyramid. But quite a lot of rewriting would have to be done in order to be done.
I think his question is better phrased as, what does any of that mean to him as a user. Insertion order preservation is pretty neat but for the random joe they might not know what some of those things truly offer 
Forget 10, the fact that you're on 8 is a surprise in comparison to all those I see on 6/7.
Hi, OP here. Have released library here: https://github.com/ritabratamaiti/RapidML/tree/master Documentation: https://rapidml.readthedocs.io/en/latest/ Ran into another issue(unrelated to the thread): Due to documentation, GitHub is showing this as an HTML project, despite me putting a .gitattributes file with docs/* linguist-vendored Any help would be nic...
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ritabratamaiti/RapidML/.../**1454dbeb8cba8d192ba7da9511b3e3d6c6749cb8** (master ‚Üí 1454dbe)](https://github.com/ritabratamaiti/RapidML/tree/1454dbeb8cba8d192ba7da9511b3e3d6c6749cb8) ---- 
For me, it's pretty fun to read the updates. It's kind of like getting a look over what new tools are available and what issues may have been handled. It's fun to think about what new things you can do.
&gt;In Physics &amp; Astronomy We are the same people that are still using Fortran. Seeing this argument against using 2.7 in the face of that makes me chuckle. That said... I have ported my stuff over to 3.6 (and will be debugging any issues arising from 3.7 soon). Also, matplotlib just announced that they will be ending support for 2.7. That should motivate a lot of people alone.
It's because the last version in the 2.x branch is 2.7. So, now that it hit the .7 milestone python 3.x is on feature parity :)
There are people still using Python 2. Building on comments I've made previously: the biggest hurdle for those folks is their own organizations. Many places have a philosophy that anything which isn't directly adding a new feature or directly solving a bug customers care about is completely off-limits to do. Which means they never *ever* do any kind of maintenance work. It wouldn't matter if a Python 2.8 came out tomorrow; they'd never upgrade to it, because upgrading any part of their stack is something their managers will never allow. Eventually those folks are going to be forced to switch to something (probably not Python 3; their managers will blame Python instead of their own practices, and advocate switching to a trendier language). But that's still some years off. If you're starting out today, you should learn Python 3. If you do end up working somewhere that's still on Python 2, it's not that hard to learn the differences at a later time.
I'd like to think that each of those bullet points is either self explanatory by the title in what it offers, or is summarized in the first few lines of the respective PEP. The order preservation already existed in 3.6 as mentioned, so that's also not even "new" bar it is now "officially new". If they aren't, well, I'd like to hear from someone which ones aren't and I'll apologize immediately and give an explanation that *should* have been in the PEP.
I think he was asking for a translation...
Add *.html linguist-vendored to that file as well. Also, I think changing your pattern to docs/* linguist-vendored will work
Create an [linguist override](https://github.com/github/linguist#overrides) Create a file called **.gitattributes** in the root of your project repo and tell github to ignore javascript and htmls files. eg: something like *.html linguist-language=txt *.js linguist-language=txt 
The abstracts are extremely basic in terms of necessary comprehension. For example, &gt; This PEP proposes adding a new built-in function called breakpoint() which enters a Python debugger at the point of the call. Additionally, two new names are added to the sys module to make the choice of which debugger is entered configurable. For the breakpoint PEP. For the PEPs that he can't begin to understand, ex, maybe the thread local storage C api, it wouldn't be because he can't understand that abstract. It would be because he can't understand threads, or what a C API is, because he isn't that advanced yet. So again, I am not going to repeat the abstracts of the PEPs. He can click the damned links. And I'm not his undergrad professor either-- it's not my job to teach him what a thread is, and even if I was nice enough to do so, which I am, he didn't ask that, he asked what these new features are.
You mean that you want to exclude HTML lines from the code-breakdown that GitHub does for a given project? Not sure if that's possible, I suspect it simply counts all the lines in non-binary files a given repo. In order to suppress it, you probably want to move the HTML from your `docsource/_build` subdirectory to a different directory and call it RapidML-docs or so and then link it with your project
Yeah, a friend of mine works in a Super K group that still rely on a lot of Fortran 77 code. Most of ATLAS/CMS people have been more receptive to switching to Python 3 but even then it's still surprisingly slow and people still drag their feet.
What I don't see mentioned yet is that some supported enterprise linux OSes don't come with python 3 by default or even at all. 
I just had to set up a Google Cloud VM instance today. All their infrastructure code is Python 2.7, and there's a lot of it. There's just not a lot of added value in v3 to justify the risk and expense of going through all that legacy code.
Yeah, but let's say you're using goodlib v1.0 and v2.0 of the lib breaks some things so you hold off on updating that library. Years later Python 3 support gets added but it's only in goodlib v6.0+ So now you not only have to get your app to work with Python 3, but also update goodlib(and probably many more libraries) that may change in small ways between major versions. Heck, I recently updated a PHP app using AWS S3 and stayed in the same 3.x branch and the update broke(changed) how the library returned S3 domain urls for buckets. Luckily I had excellent test coverage which caught and pointed out the change. But that was within a major version library update using a very common library from a huge vendor. Libraries can be a real PITA to work with.
Also you'd be better off adding a [.gitignore](https://github.com/github/gitignore/blob/master/Python.gitignore) for python first.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [github/gitignore/.../**Python.gitignore** (master ‚Üí 320a610)](https://github.com/github/gitignore/blob/320a610b9ffba3ff28166370b6dd9f73096e34b7/Python.gitignore) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e1f4n4t.)
True but still relevant enough that for teams without a lot of time allocated to backlog it can be hard to find time to replace or rebuild libraries. I think we initially held off due to the issues with flask a while back which obviously isn't as much of an issue anymore.
&gt;Too noob to understand what the excitement is about for the update. S its mostly exciting for people that have been using the language long enough to find the frequent and annoying issues in the previous release(s) that are fixed in the new release. or the release adds/improves something you have been wanting or looking forward to. my reason for being excited in dataclasses and the \`from \_\_future\_\_ import annotations\` that was added, also the asyncio improvements.
You beat me by a couple of minutes. This is a major reason at my place. We use all RHEL 6, that ships with python 2.6. The entire OS is built around python 2.6 (at least some major components of it) You can install python 3, but it is baked in to be a python2 OS.
You assume people actually realize how all of this is organized . Not everyone does . And even if they read it , it‚Äôs not always immediately obvious what exactly each of them does for someone 
The problem with upgrading is how to you get test coverage for all the corner cases. The costs and risks don't come anywhere near the benefits. More elegant string formatting doesn't make anyone any money.
Don‚Äôt worry, you will get there! If you‚Äôre new, one of the more tangible things to try out would be the addition of breakpoint() and learning about pdb. Debuggers can be an invaluable tool for programmers new and old.
Linear algebra people still use Fortran because someone optimized the row-access cache behavior sensing in the 1970s and it still runs fastest that way. Those libraries like LINPAK are still in use, as compiled from Fortran and linked into object files for all kinds of numerics libraries inner loops, including Python's.
Thanks for the reply, that helps me. I actually am versed in PowerShell (intermediate, ~2 years scripting datacenter automation), and wanted to branch out to another language. Not sure why I chose Python, to be honest. We have some linux clients that i'm looking to possibly automate in the future, so that could be a reason I suppose. You mentioned *trendier languages*, do you have any suggestions as to what languages I could possibly learn in lieu of Python or after Python, for jobs prospects sake?
Yes, I understand. But the thread would have been better off had you not said anything in the first place.
Lawls
Yeah, and at least on RHEL 6 if I recall correctly you can't install 3 out of the official repos, you have to go third party. I'm not sure if that was still the case with RHEL 7. With the direction Fedora is taking with the 2-&gt;3 migration, maybe we'll have 3 as default in RHEL 8?
Bur for me when I read the updates, I just cant understand the updated features because I have never used them.
Data class ... Sounds cool 
Correct, official repos don‚Äôt have python 3. We would have to build it from source and have our own repo to support it, but that causes lots of potential issues when you spread that around 4000 servers, you need to have QA every time you compile a new version etc etc. I‚Äôm not sure about Fedora too much with Python 3, but I‚Äôd love it if 8 shipped with it. Would keep me employees for a long time ;)
There are a lot of libraries that are or will soon be Python 3 *only* going forward. Keep learning Python 3, be aware of Python 2, and steer clear of companies that plan to stay on Python 2 indefinitely. You'll hear 1001 excuses, and they all come down to: - They're too lazy - They're too cheap - They won't be around much longer - They'll be around forever, and your headaches will grow exponentially the longer you are there It's worth the work to stay up-to-date, or within a close range (IMHO 3.6 is the sweet spot until 3.7 is widespread).
Because you need more than just python and they test everything for compatibility.
Yeah I can see that everyone is exacted for the data classes module. What surprised me when I read through the updates was seeing "await" and "async" which I have never seen before. I dont think I have seen any tutorial covering it. So I realized I have a long way to go.
[Red Hat Confirms RHEL 8 Will Drop Python 2](https://www.phoronix.com/scan.php?page=news_item&amp;px=RHEL-8-No-Python-2)
Hell yeah! Now if only we could get off of those RHEL 4 boxes we have ü§î
The idea of studying a documentation is so boring to me haha. Plus, it so hard to make sense out for me. But if that what it takes to learn, ill give it a try. I'll also check breakpoint().
Hmmm, I‚Äôm writing a new script today, I‚Äôll use it. Yolo.
Someday buddy :)
How do I install this in Ubuntu?
How do I install this on Ubuntu?
I'm even more lost when I try figure out the update documentation. Its either I don't have enough Python knowledge or I'm just dumb haha.
Async and await are not new. They were added in 3.5. Whats new about them in 3.7 is that you cannot do `async = 1` anymore. And same for await as well. There are tutorials for async and await on YT I think. So you probably have just not needed them yet
Organized? What do you mean? And again, the abstracts of the PEPs are in simple terms.
Indeed, there's always the legacy code issue, but that's not really about the libraries' availability at this point. My point was that there are pretty much no good reason to start new projects on Python 2, especially since [it's getting phased out](https://pythonclock.org/) in about a year and a half. For existing code it's pretty much the time to push for the change though.
Yes. I tried the Data Classes out both in a pre-release and in a 3.6 back port. It's fascinating to me what they accomplished although apparently much of it was inspired by attrs. The metadata is available at run time and I was able to write a mix-in that does type checking. 
For me these feel like the biggest mistakes. We already had `OrderedDict` for these cases, and now all implementations like PyPy and IronPython must use ordered dicts, even if they would've preferred unordered ones. Up to this point it was an implementation detail so everyone got to use what they wanted. And while I love the idea of dataclasses, right now it just feels like a cheap copy of attrs that forces you to use type hinting syntax. I just wish they waited for 3.8 with it and polished it a little more, possibly adding a custom syntax so you don't have to use type hinting.
I'm waiting a month or so for pylint support and then I'll start migrating my company's repos.
Probably me when Arch updates... *runs yay -Syu repeatedly until Python 3.7 comes through*
Considering half my company uses 2.7.8, I don't have a lot of faith that it would even matter.
Is the type checking version you made open source? 
3.7 is going to be backwards-compatible with 3.6, at least in most meaningful ways -- that means your 3.6 code will still work under 3.7. You just get access to some new features if you run that code under a 3.7 interpreter.
According to \[this\]([https://access.redhat.com/documentation/en-us/red\_hat\_enterprise\_linux/7/html/7.5\_release\_notes/chap-red\_hat\_enterprise\_linux-7.5\_release\_notes-deprecated\_functionality](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/7.5_release_notes/chap-red_hat_enterprise_linux-7.5_release_notes-deprecated_functionality)) Python 2 is or will be deprecated as of RHEL 7.5.
I got a 15% performance boost by running my python 2.7 developed code in python 3.6. Startup time matters a lot less than actual runtime unless programs are tiny in which case, who cares?
No company is going to spend money and time on something that offers such little gains in money and time. Like I said, not every company is using Python for a shipped product, so the benefits of switching are much less.
Dynamic Position Keeping Systems. There is still supposedly one out there running on a pure DOS machine to this day.
&gt; We already had OrderedDict for the semi-rare cases, and now all implementations like PyPy and IronPython must use ordered dicts, even if they would've preferred unordered ones. This doesn't make any sense. The only argument I can see for unordered dicts is performance. If performance has not been impacted by making them ordered, then it hurts absolutely no one. If you don't want to rely on the sorting order, then you don't have to.
Yes. Nice to know. https://github.com/uqfoundation/dill/search?q=oren+tirosh
You should probably have Python installed through homebrew and not a manual download. You wouldn‚Äôt run into issues like this
VsCode . Because - 1. Fast 2. customisable. 3. Feature rich. 4. Easy to learn and manage mid to big projects. 5. Good community support.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Use Arq and B2! I would be super interested in what doesn't "work" for you. It will most likely be much cheaper than the Personal Backup Product, and the performance is excellent. Try it and please let me know what doesn't quite work for you! We might be able to work with the Arq authors to fix the functionality that doesn't work correctly.
Bwahahahahahaha... I'm in my room crying... 
I literally just downloaded 3.6.5.
Most of the methods seems to have proper docstring, so using sphinx to generate the list of relevant method and docstring, then list them in a clean way will be a huge improvement. That way, the users will know what are the available shapes and method and how to use it without searching inside the source. 
Startup time matters regardless of the size of the program. If you have a CLI every command you execute will cause the Python VM to start up and initialize. There are plenty of cases where multiple commands are executed-- using the git example, you have adding your files, potentially removing the ones you mistakenly added, committing, pushing. The difference in speed would be starkly noticeable and annoying for the user. Python 3's startup time is anywhere from 2.5 to god knows how many times slower. And that's because of something that changed in the import machinery in Py3. But arguably whatever the change was, it wasn't thought out well. I give you the playbill for [milliseconds matter](https://mail.python.org/pipermail/python-dev/2018-May/153296.html). Unfortunately, I still can use the dependency excuse. Some libraries just didn't update.
It makes a lot of sense. &gt; The only argument I can see for unordered dicts is performance. If performance has not been impacted by making them ordered, then it hurts absolutely no one. Performance wasn't hurt *on CPython*. But CPython is not the only implementation of Python, and it shouldn't be the deciding factor when adding language specifications. The performance might get hurt on other implementations. Not to mention that it's an unrevertable change, meaning that if we some day come up with an even faster dict implementation with the downside of being unordered, the best we can do is add a `collections.UnorderedDict`.
Iterate, and never write a single line of code without: `from __future__ import absolute_import, division, print_function` Heck, *absolute_import* probably would have saved you more time then a forklift port would take. While I can kind-of relate to your pain, I can't really relate to ignoring a decade's worth of deprecation notices. &gt; Python 2.6.0 &gt; Release Date: 2008-10-02 But that is not why I am responding. If your tests and product are that fragile, it is not a *technology* problem it is a *culture* problem. Invest some time on learning about and iterating on the culture problem. I promise you that both your personal work life and the company's bottom line will benefit from the effort.
The point is that it's a coincidence that the current implementation preserves order, now everyone has to implement it like this, or in a way that preserves ordering, even if there might be a better way. 
An open question was asked, vaguely, and out of apparent laziness. I, just like you, could have responded. I did. When the laziness was further solidified, I put my foot down.
A sobel filter? There is one available in sci kit-image! 
Omg you're hilarious. Thank you.
The startup problem has more to do with standard module design. Everyone imports everything at the beginning that they may use so they don't have to do it in a small loop (that turns out doesn't matter), or IMO the worse issue of crashing on some import that you forgot to update because it's in a function. The "flat is better than nested" idea is great for an API, but terrible for speed. My 120k lined 3d gui has a command line option. You'd better believe I do argument validation before importing everything. I also try to minimize interconnectedness. However, do I really need all of BLAS from scipy to do linear interpolation? Don't blame python for murcurial's poor design choice.
Also not OP, but there's a lot of discussion about porting bits of Trio back to asyncio... 
Thanks for the answer it worked ...I used sobel with a bit of a large kernel than usual like 7 to connect the edges. Thanks a lot dude
Honestly? I don't really know, but it seems like a good question to ask on Python's mailing list. It seems like Python should've been able to locate the correct library, but I'm not privy to the details of how Python searches for the libraries, and a quick search for documentation of this subjected yielded no results.
Fortran is pivotal to python in this field, as evidenced by scipy and numpy which use those same LAPACK/BLAS variants that everyone else does. C/Closure/Java all use those library's too or at least have an option to do so to improve performance. &gt;import numpy as np &gt; &gt;numpy.**config**.show() If it isn't configured to use some BLAS it is going to be slow. It is just too hard to compete with the performance even in C++. A FORTRAN compiler can just make assumptions that most others can, and producing non-relocatable code helps too. If you know C or another language, try to write a LU function that even 10 times slower than MKL or another ATLAS/BLAS offering. It is hard and humbling. A potential nice side effect for you is of these large python projects being dependent on the language is that you don't have to choose between Fortran and Python, as these large projects have ensured that the python is up today and works extremely well as a glue language. [https://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html](https://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html)
I'm not sure why you're telling me this.
Ah I missed it was a friend of yours who worked there.
I appreciate your comment, though. What you're saying is true. There are definitely some good reasons to use something like Fortran when it comes to speed. It just happens, in this case, that the people I'm talking about use Fortran 77 because they're lazy fuckers and don't want to have to re-write anything in a more modern language. Plus it's easier just to force all the new grad students to learn Fortran when things need to be changed/updated. 
 The funny thing is that F95 features like `ELEMENTAL` make it so much easier to be lazy....if only they knew.
Where was that?
Did you write the import macro yourself? Do you mind to share it?
Fortran itself is fine, at least the newer versions (2003 and 2008) are. It just fills a very different niche then python, which in fact afaik relies quite heavily over fortran libraries. The main problem why fortran for a bad name is that lots of people use it without really knowing how to code, and then pass their hot messes on to their students.
Glad to help :)
why 3.6.6 and 3.7 simultaneously? 
sudo apt-get update python3.7 If you're running Ubuntu 17.10 or higher Python3.6 is in the repos by default. I just did it on 18.04LTS 
The people in sciences holding onto 2.7 arn't using goodlib, they are using in house libraries that were developed to do a specific thing by someone years ago, and that all of their results and model have been validated against this, and that nobody has the time or effort or willpower to modernize the code and then to re-validate everything. Most of the people in the sciences writing these codes are not computer scientists, they are regular scientists. They are working for effectively peanuts, are fighting every single day to justify the little funding that they do get and to apply for more funding so that they may actually finish their work, and most of the time they have only 2-5 years to do this. And during this time, they are also under increasing pressure to do new research, to publish new research, and to come up with ideas for new research. They (we) go into our labs/office every day and have to make the decision: do I use the limited time i have to do research to get me to my next job/position/grant, or do I go through and update the codebase that I use that I know for a fact works right now as-is? I can't speak for everybody, but I know that I would choose the latter every single time.
A good one I have found is golang for server stuff... Not going to elaborate here as I'll leave it to you research. My main like is I build a binary that just works on all the other servers without installing any deps
I'll keep it in mind if I have any backup/storage purposes in the future. Right now I'm not really in a financial position to experiment (especially not with Arq's $50 price tag), but your solutions do look promising. I still think you should look into a Linux client for the Personal Backup Product - I'm the type of person who can rig stuff up from the existing tools but not all Linux users are like that ;)
&gt; If your tests and product are that fragile, it is not a technology problem it is a culture problem. Invest some time on learning about and iterating on that very real culture problem. I think this sort of response misses a fundamental point. Last year, I was employed by a company that used 2.7 extensively, and had no plan or desire to move to 3.x because it was all cost with zero gain for them. Sure, there were some nice features in 3.x, but it was a major shift that no one really wanted and it came with all sorts of potential sources of pain from old libraries that production code relied on, and which no one was producing new versions of for the 3.x series to subtle changes in behavior that were going to mean someone spent a long time finding and squashing mysterious new bugs... 
&gt; On the other hand the only reason to keep Python 2 is legacy inertia. Perhaps now. Last year when I was using 2.7 extensively, the reason was that half of the libraries we relied on didn't have 3.x versions, and there was no benefit to us for transitioning off of those libraries to newer ones that did support 3.x. 2.x just worked and worked really well for what we did. It made us a LOT of money. Why would we kill that goose? 
Python 3.6.6 is the sixth and current maintenance release of Python 3.6. so those who`s not ready to move to 3.7 branch ;)
Python 3.6.6 is the sixth and current maintenance release of Python 3.6. so those who`s not ready to move to 3.7 branch ;)
That's exactly legacy inertia. It's not as if there is some conceptual or design benefit that Python2 has over Python3; you're just in a position where the value provided by the legacy system completely eclipses the value that would be gained by porting. If you were starting completely from scratch, there would be no benefit to choosing Python2 over 3. This is different from the relationship between C and C++, where certain applications may benefit from (or even require) certain valuable properties of the C language which aren't possible with the C++ language.
Use `random.sample`.
How? Sorry I‚Äôm new to python (not coding)
Read the docs for `random.sample`. Then consider how it might be useful to you.
I hope not. Otherwise what would you do if Python needs to make a breaking change again.
&gt;Not to mention that it's an unrevertable change, meaning that if we some day come up with an even faster dict implementation with the downside of being unordered, the best we can do is add a collections.UnorderedDict Good point, but still "natural" ordering is a feature I immediately found useful. For instance, you can not use an OrderedDict as kwargs.
Not suitable for cryptography (but then neither is a 4 digit no repeat PIN), but: from random import sample print("".join(sample("0123456789", 4))) Now that gives you back a string, which could be converted to an *int*, but it may start with a 0, leading you to a 3 digit int... but it's unclear what your purpose is.
I just want 4 digits that are not the same, stores as a string.
Yet you would still get some who would start a new project in 2018 with Python 2.7 FFS it's 2018.
Unless you vendor it, just use attrs. 
That‚Äôs a lot of stuff.. 
Yep linter and lines commenting is most useful.
the forced UTF-8 is the selling point for me
You said it is pointless and the parent commenter says it is not. (You said it here: "The fact that OrderedDicts still exist and make no mention of "this class is pointless and a thin wrapper around dicts"") 
&gt; without compiling or adding untrustworthy repos You can't, as far as I know (assuming I can't convince you that the PPA I use is trustworthy).
Hey, unrelated, but I've just started learning python, coming from C# for around 8 years, what are the benafits of using a text editor like atom or sublime, rather than an IDE like PyCharm?
Other than using `random.sample` as per u/K900_, if you just wanted to see a pattern in Python that could do this, it might be like: import random, string def getNums(): num_list = [random.SystemRandom().choice(string.digits)] while len(num_list) &lt; 4: new_num = random.SystemRandom().choice(string.digits) if new_num not in num_list: num_list.append(new_num) print(''.join(i for i in num_list))
You could check out NLTK, an NLP library for Python. You should be able to pick it up very quickly given that you already know about context-free grammars, parts of speech tags, lambda calculus, etc. What will be new is the statistical side of things probably (pun not intended) and the programming. How you can use it to make a career switch I wouldn‚Äôt know as a student, but it‚Äôs a solid intro to the realm of NLP. Send me a message if you want to have some tips on good materials to read and such. I just finished an introductory course on NLP and I have some slides and books you might be interested in.
They should have just imported Ordered Dict to the default names pace maybe as odict and used it for kwargs without making it the default everywhere 
 Mostly [web developers in Python](https://www.swavishsoftwares.com/webdevelopment.php) write their web applications using a combination of Python and JavaScript. It is executed on the server side while JavaScript is downloaded to the client and run by the web browser. If you are web developer you should know web applications created in Python are often made with the Flask or Django module. Visit here... http://www.apsense.com/article/how-to-get-started-in-web-development-with-python.html 
then how am i suppose to show the full table
[removed]
‚ÄùLegacy is good enough, no need to change.‚Äù
fortran is actually faster then C or anything else, because complier doesn't have to worry about some edge cases that have no use for numerical computations. newer releases also support CUDA,so there's nothing ancient about it. it also has more scientist-friendly syntax (no curly braces).
dataclasses look awesome, but honestly I'm most excited for the module level `__getattr__`. I am going to do so much dirty magic with that and love every minute of it. For real though, you can do something like this now... from myshell import ls, which, find files = ls('-al', 'some_dir') myshell.py: import subprocess def __getattr__(command): def func(*args): return subprocess.check_output([command] + args) return func
You can make your own in 5 minutes: Open a file and write something like "random.choice". Select "random" and then Tools &gt; Record Macro Goto &gt; Bookmarks &gt; Toggle bookmark Copy the selection Go to top of file, write "import " and paste selection, enter. Goto &gt; Bookmarks &gt; Next bookmark Goto &gt; Bookmarks &gt; Toggle bookmark Tools &gt; Stop Recording Macro Now you have your macro, you can test it out by selecting a word and playing back the bookmark to see that it gets added as an import correctly. If you want to bind it to a key, save the bookmark and then refer to it from Preferences &gt; Key Bindings - User This is how I bound ‚åòI to play it: { "keys": ["super+i"], "command": "run_macro_file", "args": {"file": "Packages/User/add_import.sublime-macro"} },
isn't 8 a long term release anyway until java 11 or 12?
The module just has to visible wherever you're running Python. Change to whatever directory you saved it to and execute python shell there, or change your python path variable (shouldn't have to do anything like this for a class). Also: r/learnpython
hey, if you type import math, do you import everything in that case or do you just import it when calling the specific function?
Objectively, not much. If you are not already emotionally attached to some text editor, IDE is usually better, especially if you just started to learn.
I have tried first applying a Gaussian Blur then processing it with adaptive thresholding and it worked just fine. import cv2 as cv \#input img = cv.imread('1.png',0) \#gaussian Blur img = cv.GaussianBlur(img, (15,15),0) \#adaptive threshold th3 = cv.adaptiveThreshold(img,255,cv.ADAPTIVE\_THRESH\_GAUSSIAN\_C,\\ cv.THRESH\_BINARY,11,2) cv.imwrite('result.png',th3) Here is the output : [https://imgur.com/a/JqsGfII](https://imgur.com/a/JqsGfII)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/U7eKxSw.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
what do you mean by something easier to work with? 
I'm doing a textbook on my own free time. How come I don't have to have my math module visible whenever I use that one? How can I do it so I don't need to have my graphics.py open?
Holy shit! I love it!
So is the idea of the dataclass that it's supposed to be a C-like struct? They should come up with a name for Python that looks and runs like C, call it something like PyChon or PythoC...
Large large masses of Python 2 Spaghetti code lies out there in the wild servers of the internet. Code so messed up it would tax your sanity just to look at it, and take a full team a year to completely update. Which nobody can afford.
&gt; some only py2 compatible Can you give examples? I only know this: http://py3readiness.org/ but believe that it is not full list.
 \&gt; Avoiding the use of ASCII as a default text encoding ([PEP 538](http://www.python.org/dev/peps/pep-0538), legacy C locale coercion and [PEP 540](http://www.python.org/dev/peps/pep-0540), forced UTF-8 runtime mode) Ibuprofen sales just dropped 80&amp;#37;.
&gt; "Python at Facebook is fun again." I must say, since Python 3.5 (it showed already a little with 3.4), I have had a lot of fun as well. What about you folks? Any success stories like that one? Migration path?
Do you accept applications from India ?
Parent answer does that. 
I suspect python 4.0 will be the version in which python will have core support for typing so for example `list` will inherit `typing.Generic` and all types will have `|` and `&amp;` operators for `typing.Union` and the planned `typing.Intersection` respectively. Maybe also add `Any` and a few other abstracts to builtins. 
I should have been more specific, I'm not talking about people using libraries. I'm talking about people coding in Fortran 77 and 95. 
I've never seen anyone use the newer versions. The best I've seen is 95, with an alarming amount of 77. The code base is immense, and that's what people always cite- but as you know you can use that code without programming in Fortran. 
Stay on 2.7?
I meant what would the PSF do.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. While I was at it, I checked [Stack Overflow](https://stackoverflow.com/) but I couldn't find a useful result Though fair warning, this section of the my code is under development, and I don't expect these links to be very useful. *** ^(this bot is written and managed by /u/IAmKindOfCreative)
No, they're just python classes with a little decorator on top to support declaring classes in a more declarative way. 
My guess that's because a number of subsystems are based on Python 2 (e.g.: yum) and they're non-trivial to upgrade. In any case, you should never ever use the system Python. It's asking for trouble. 
Google Cloud's compute engine VM management is in the same boat.
Pypy and cpython have similar dict implementation and that was a big speedup for cpython. As a side effect dicts were ordered as an implementation detail. Jython is stuck at python 2.7 and ironpython3 is still in early stages. Currently community is split between cpython and pypy. They both provide ordered dicts by default and I think it's sensible to ignore archaic python implementations for the sake of simplicity. I used to say "cpython said dicts are now faster because it's ordered now but that's just an implementation detail, don't get confused. " Now I can say "yeah they're ordered." Also I agree with you about dataclasses. 
Their code was already broken. If you depend on undefined behaviour, it will!probably end in tears at some point.
Can you the event loop so that it doesn't leak its internals and thus mysteriously break?
&gt; The issue I am running into however is that there is no real way to differentiate the "month", "weekday" or "days" HTML classes. This means that applying CSS individually is an issue. care to elaborate where the problem is? /* workweek */ table.month td.mon, table.month td.tue, table.month td.wed, table.month td.thu, table.month td.fri { color: black; } /* weekend */ table.month td.sat, table.month td.sun { color: darkred; }
Well... you don't show the entire stack trace, the most interesting part is missing. I'm not even sure the code you show is related to the error you get. However, you might consider calling Thread constructor with `daemon=True` instead of setting this property later.
Might be more helpful if you posted what was actually needed, or a link to the assignment specs, maybe even add what your willing to pay as well. 
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. While I was at it, I checked [Stack Overflow](https://stackoverflow.com/) but I couldn't find a useful result Though fair warning, this section of the my code is under development, and I don't expect these links to be very useful. *** ^(this bot is written and managed by /u/IAmKindOfCreative)
I guess I haven't seen enough of those lists of advantages I spoke of. I didn't even know to want a lot of this stuff. I looked around a bit and most things you listed seem to have something of a response to it in the VScode world, but surprisingly hacky solutions at first glance. I suppose I either stand corrected or don't know enough about VS code to answer adequately.
That and also because of the feature freeze and long version cycles
General life tip, please don't write "not new to coding" and ask a question like this. I have a friend who does technical interviews and he complains about timewasters all day.
Okay that‚Äôs Kewl. Thanks for pointing it out.
Thanks, mate. I'll try there.
You would like to think, but you're wrong.
&gt; You use any other interface. It could be a rest API that runs locally and you write a Python client API that makes calls to it. It could just be compiled to a binary that you can run from the command line, and then you write a python API that simply invokes it and runs the process with something like subprocess. Could be anything, but the idea is you write a python wrapper API. Just like a web API?
sublime starts 10 times faster. it does not need java runtime to work. and personally I don't need any pycharm`s bells and wistles.
We had a lot of tooling around Fabric which wasn‚Äôt py3 compatible until about a month ago. On the metro so I can pull it up atm but off the top of my head it was a psql json field extension for Django, it‚Äôs not even maintained anymore iirc so there‚Äôs this legacy field on some models. In general, there were a lot of unnecessary packages added early on that we‚Äôre paying for now. That link is great, thanks btw.
I found quiet interesting about [chalice](https://github.com/aws/chalice) because is created by AWS. Thanks! Maybe you can create another one for that microfw!
https://imgur.com/a/wRyvcw6 I need at least 60% done correctly. Willing to pay 33$ or 25¬£ preferably PayPal but also can do international bank payment.
Cool, thanks for the answer. We are on the verge of 2-&gt;3 migration for legacy projects and I'm looking for all potential pitfalls not to fall in. Thanks.
&gt; at the end of the day the "code" portion of memory isn't C, Rust, or Fortran, it's x86. With x86 you mean that at the end everything boils down to the set of instructions the architecture has and if you know how they're handled they you can create an interface with another language to interact with it. Is that more or less it?
Pycharm is the norm now -- but I am trying VS Code more and more. I like the VS Code integration with Mongo for example. I haven't debugged, used enough features with VS Code to really give it a fair eval.
Pretty sure such vulnerability could still be patched. If not officially by python foundation then someone from the community will step in to submit it. If its big enough , people would even consider a fork. Would still be much faster and cheaper than migrating thousands of projects of many different companies to python 3
Thanks for the reply, I removed the line that set the thread as a deamon thread and now the next line gives a similar error. I do not have the origianl traceback but it looks the same as the new one except said you can't set thread as daemon while it is running. 
Why do you think he needs to post to learn? He's obviously had the script running previously, I don't think he's a beginner. So why would you send him to learn rather than hello him? 
Then read the docs for the features...
As someone else mentioned, just because a library *eventually* added in py3 support, doesn't mean that it has it on all versions people are using. It's not uncommon for libraries to break internal backwards compatibility or add new bugs, leading to people pinned on older versions. You'd have to upgrade everything wholesale, which can be a lot of effort for very little reward. 
&gt;python.org/downlo... DC Metro?
My advice for PyCharm is to leave the "did you know..." tips on, and to actually read a new one every day. I can't tell you how much I learned just from reading these tips. One of the features I like the most is their refactor in place feature(s). Maybe you know this already, but say you wrote something like this foo = (3/4) * x[0]**2 + np.sqrt(x[1]/x[2]) And then later on you realize that you need to use the value `np.sqrt(x[1]/x[2])` in more than one place. You can just select `np.sqrt(x[1]/x[2])` and hit `ctrl`-`alt`-`v` to extract this part out as a variable. You could even extract it out *after* you've typed it twice (maybe you didn't realize until afterwards) and it'll ask if you want to replace both instances or just this one. But it also goes both ways, you could put your cursor over a variable and `ctrl`-`alt`-`n` to put it back inline. And not only can you extract out variables and things like this, you can extract out entire functions/methods. Let's say you wrote something like this for i in range(10): for j in range(10): df = df.read_csv(f'filename-{i}-{j}`) # plus a long list of dataprocessing stuff Well you can select everything inside the inner loop and `ctrl`-`alt`-`m` to extract it out as a function. It is smart enough to define that function with the proper inputs as well so all you really have to do is to give it a proper name.
Are you sure that is how "scraper.py", line 270 looks like? I don't see any place where you'd call start() more than once.
I mean you could've just done this up till now: from myshell import myshell # as ... files = myshell.ls('-al', 'some_dir') And to be fair even with the module `__getattr__` you probably still prefer keeping things under a namespace, so you'll just end up doing: import myshell myshell.ls('-al', 'some_dir') So technically you changed this: from myshell import myshell To this: import myshell I do agree that there can be some neat usages, but I don't think this is one of them.
Linux Mint 18.3 is on 3.5 as well.. 
I've been using it in production since rc1. It's a small bit-player automation script. After I watched Hettinger's PyCon presentation on dataclasses I knew it was a perfect fit.
How about 'cython'
Yes, this so much. Ideally there would be a decorator that can change the type of the keyword arguments: @set_kwargs_dict(OrderedDict) def foo(*args, **kwargs): print(type(kwargs)) # OrderedDict You could then even create a dictionary that supports multiple values for one key: class MultiKeyDict(dict): ... def __setitem__(self, key, value): self.setdefault(key, []).append(value) @set_kwargs_dict(MultiKeyDict) def ... Maybe in Python 4.0
sudo apt-get upgrade python3.7 That worked for me, but I have to type "python3.7" to run python3.7, not python3 
[What‚Äôs new in Python 3.7](https://docs.python.org/3/whatsnew/3.7.html) 
Do we work in the same place?
I largely agree, but in some cases I think here‚Äôs no need. If I have a service version locked, it works, and it is secure, then why mess with it? Once new features or serious changes are needed, upgrading would just be on the list, but really only if security and longevity were an issue. 
Line 270 is the `thread.start()` in the for loop posted above. it is like somehow the .join() isn't working and the main thread is continuing to try and launch more threads somehow. Is there any default timeout for .join() ? - I though it would wait indefinitely.
Just to be clear: It's at [the "PEP 563: Postponed Evaluation of Annotations" section of that document](https://docs.python.org/3/whatsnew/3.7.html#pep-563-postponed-evaluation-of-annotations)
Python for everything you can. Though one case now I am deploying an algorithm into the wild on an edge device and I feel better shipping only the compiled c++ binary rather than the original python script.
Once a thread has ended, it cannot be started again. You‚Äôll either have to make another thread or better yet: have a single scraper function continuously running and use a queue to pass links into the function.
Except in Python, it looks like it's going to work like a decimal. See Guido's post: http://www.curiousefficiency.org/posts/2014/08/python-4000.html I hope they go with 3.10. Otherwise it'll break all the code that checks that the version starts with '3'. (Bad code but still common.)
Since your machine could run Visual Studio I'd say there's not much that Sublime, or better yet VSCode, would offer that PyCharm doesn't. For **really** small jobs where I just need something to load up quickly I'll use VSCode or vim. If I'm working in a multi-file project I'll opt for PyCharm 9 times out of 10.
r/learnpython
My favorite new feature is the new [dataclasses](https://docs.python.org/3.7/whatsnew/3.7.html#whatsnew37-pep557). 
Yup!
CPU speed is the most important, _as long as_ your data fits in RAM.
&gt; You receive a request, and you need to make two database queries to fulfil that request. Each query takes 50ms of time. With a synchronous program, you would make the second request only after completing the first ‚Äî total time 100ms. With an asynchronous program, you could fire off both the queries one after the other ‚Äî total time 50ms. this is false, right? total time is not 50ms, just the latency is hidden from the user / rest of the program (which can continue processing while waiting).
Start in /r/learnpython. They may suggest you post here instead if the question is above their scope.
You may need to consider GPUs too (graphics). They can be used for some kinds of data crunching. 
Let's use a range, because.. i dunno! from random import sample print("".join(map(str, sample(range(0, 10), 4))))
Meant potentially explaining **map**, but sure.
Whatever this saved on the harcoded string we pay back in extra bytecode and cpu work generating the range and mapping stuff to string.. but you can! :)
Well, the subtle assumption here is that your db will be able to process both the queries fired at, say T1=0, in 'parallel', so you would receive both responses at T2=50. In the synchronous version, T2=100. 'total time' refers to the time it would take to give response of the request you received which is T2 - T1
It really depends on what kind of scientific computing/scripts you'll be running. In general I would say CPU speed, but there are things that could change this
You import everything in the module you imported and all of the modules it traces to. For example file packageA.moduleA has import packageA.moduleB, so packageA.moduleB gets imported. You can import modules from packages without importing entire modules, but not specific files if the imports are at the top. Once you're imported evwrything, the next module that does it loads almost instantaneously cause it's being skipped. The math module in particular is written in C, so I don't know how it specifically works.
I started out just watching youtube tutorials to learn about python. I've been learning python for ~1 year and only just started making the transition to focusing more on documentation than videos 3 or 4 months ago. I suppose it'a lot like getting used to the command line vs a GUI; tough at first, but once you learn it your potential opens up massively.
Well for example, at some point I need to be able to add empty divs to the output so I can retrieve and display events that users have added from a SQL database
isin returns a dataframe of booleans, so your code is creating a single column of true/false values. Please share your syntax errors.
Those libraries also use hand optimized assembly.
You are right! That would fix my styling issue! However, I still for example need to be able to, for example, add empty divs so I can display user events from a SQL database. 
Does someone has information about transfer rates from western EU ? I could have use of B2 coupled on my D.O droplets hosted in franckfurt.
Oracle stops shipping public updates to 8 in January. 
Until you have a bug that was already fixed in a version of numpy (least squares in my case) you're not using. Or you find numpy has a cKDTree which is 1000x that what you coded and it's a critical function in your code. I'm still supporting python 2.4...I was able to update to fix the least squares bug, but I don't get the 1000x speedup.
Barcode scanner would take care of most grocery items, excepting produce.
It really depends on what you mean by big data. As long as you can fit your datasets into a few gigs of RAM, focus on cpu and form factor of the laptop (for the fun of it). If you are dealing with massive datasets you will want to focus on RAM space and if possible a discrete GPU to help render viz and maybe do some deep learning.
Do they? For CPython yes, but if you make a bad decision and I'm writing PyPy, I'd ignore it. Me thinks though that they spoke with all the different groups though.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, this post has been removed as it is not directly related to the Python programming language. It might be more topical on /r/programming, /r/coding, or /r/technology. Cheers, /r/Python mods
That your startup time is longer. It's to prevent you wiping the project, redownloading it, and having different pycs for the same code. It's for build systems that choose to run based on if things are current.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Async? Really?
Oops, thanks.
Well a big one for me was getting plugins to make writing python easier. So i have a good linter and auto complete. Then i just do some of the vim exercises you can find online occasionally to learn new ways to navigate the code and to practice some of the more obscure commands. The big one for me is to always look up how to do something if i don't know how to do it already. So instead of slowly using the arrows key functions to move the code you spend some time to look up a more complex command and learn it, then in the future you have it in your toolbox.
For one of the project I'm involved in, we upgraded a large project (several 100k lines) of code from fixed format / (77 and 95) to free-form / 2008. And I must say that 2008 is not a bad language for numerical works.
I think having dict be ordered by default is the best way to do it. C++, for example, has `std::map` as an ordered dictionary (red black tree) and `std::unordered_map` is an available dictionary that uses hashing and can be more performant.
If you are dealing with massive datasets, don't use a laptop to process it.
Terribly unsafe example, right there...
You aren't supposed to use callbacks in async/await code, and here is why: Callbacks transfer responsibility for running your code, from yourself, and over into the framework that runs the callback. For example, if you have an event based websocket protocol with callback subscriptions, if anything bad happens in your callback (and it will..), it is suddenly the caller of the callback, which is the websocket protocol, that has the resposibility to clean up after the mess that happens in your callback. If the framework isn't robust enough to handle that, it can easily cause it to just die and simply fail silently. The whole reason why all websocket frameworks use the iterator protocol for sending you data is that it is the consumer that becomes responsible for handling any error, and not the producer. Any unhandled error that happens in the coroutine simply bubles up to the caller of the coroutine and can ultimately bubble out of the loop itself. I learned this the hard way.
Of course you could've done it, but not it's much cleaner. I've seen so many `from foobar import foobar` and imo it's really ugly.
&gt; the thing i am most excited about is the dataclasses They do look neat for the average simple case.
Cool. Auto-complete and navigation are the two pain-points most keeping me from using Vim. What are you using for those? A few navigation features I really like about PyCharm but haven't been able to get to work well in Vim are `go to definition` (not going to where it's imported, but where it's imported from), `go to parent function`, `list/go to child functions`, and `list/go to usages`.
Marseille
you might have to play with update-alternatives or something like that.
I guess that depends on what you mean by "hand" -- the method is to try various cache geometry strategies and use the best compiled from several versions to pick which one runs, at least the last time I looked. Usually you see more hand optimization in high frequency signal processing.
&gt; I promise you that both your personal work life and the company's bottom line will benefit from the effort. I believe you, but it's the extent that can't justify the effort. Python 2.7 is N times better than Javascript, and Python 3 is M times better than Python 2. N &gt;&gt; M.
It pains me that you are getting downvoted for this.
Fanboys and elitists will always be fanboys and elitists.
math was just an example. so it's better if you say "from shutil import copytree" (that one is for sure made in python, i've checked) than "import shutil", if i've understood you correctly.
Using callbacks is a perfectly valid pattern. It is easy to fall into the trap of callback hell, but you can't call it garbage just because you've had bad experiences.
Tribes will be tribes.
For PyPI packages, have you considered a local mirror? The [latest release](https://github.com/pypa/pipenv/releases/tag/v2018.6.25) of pipenv supports the --pypi-mirror parameter, [which allows you](https://jacobhenner.com/2018/06/pipenv-pypi-mirrors/) to replace [pypi.org](https://pypi.org) with a mirror of your choosing. 
Did you even read the mailing list? Py2 doesn't have the issue! It's Py3 problem. One of the major reasons this occurs is because the import machienry changed to allow extreme amounts of extensibility. But this also slowed things down. The fact that Py3 attempts to import from dozens of paths while Py2 does significantly less is also an issue, as well as the unoptimized code that was written. Among god knows what else-- when I asked for specifics as to why Py3 imports that much slower no one knew beyond these attributes I'm listing. I'm not arguing against Py3 being good. I am simply stating the objective fact that for various reasons the startup time for Py3 is unimaginably slower, and for validation / verification scripts and CLI tools, that is an enormous problem!
Forgive me, I don't understand this sentiment.
I really hope that will unfuck packages like `click` and everything it depends on.
Perhaps I was unclear, I meant that the docs *don't say that* thus they *have a point* and should be used.
Lots of people depend on undefined behavior, but in this case for CPython VMs it was strictly known.
I said it in the previous comment, I'll say it again. Show me one abstract that a buffoon couldn't understand assuming they know the programming concept itself (ex threads), and I will gladly both explain and apologize. You haven't done this. No one has. Just throwing angry statements my way. Which is doing nothing but proving my point.
Hm, can you elaborate on this? 
Same here. I also usually tackle a problem with Python first to better understand it before I rewrite it in C++ for performance/accessibility. 
Both of the fanboy and elitist urges are explained as the hierarchical urges of the limbic system in accordance with the testosterone pathway attributed to the last 500,000 years of human evolution, taking us further from the peaceful apes and more towards the chimpanzees. Please see Table 1 on p. 192(3?) of http://talknicer.com/Bugental2000.pdf for more information.
For the same reason you see lots of machines running Windows 7. A lot of folks think: if it ain't broke don't fix it. Both Windows 7 and Python 2 have had their deadlines extended, and both deadlines are now in 2020.
But what does this have to do with "tribes"?
&gt; logic variables and unification Please explain yourself, grumpy guy. 
Longevity is always an issue. As Rush put it, "No changes are permanent, but change is."
One of the better plugins for python specifically is [Jedi](http://jedi.readthedocs.io/en/latest/). It allows for jumping to definition (even across files). It can be complicated to jump to user defined functions from other files though. You'll have to make sure your python path includes the file you want to jump to if you want jedi to find it.
Python 5?
Can those internal libraries be open-sourced? So if you can't be bothered to modernize and beautify, some other research group might?
I don't want you to explain it, I am just commenting that you're simply wrong. Lots of programmers don't understand those change logs and would like a better more bitesize description of what is new and what has changed. 
Every act of maintenance going forward on Py2 code should be toward making it Py3 compatible. It's not hard. I've adapted my code style to ensuring it runs in both environments. At a certain point, there's no need for budgets, funding, or whatever bureaucratic BS circus. Small style changes will frequently do the trick. Boiling the frog, or in this case, dunderhead management.
Hi Shark, Yes. Thanks for asking. https://github.com/pythologist/dataclassutils Cheers, Rich
No. Callbacks is what you use in JS, where the eventemitters are the standard. It is an antipattern in python async/await.
Only gsutil, because of boto, I run in python3 with no problems with the other parts though. Here is the issue. [https://github.com/GoogleCloudPlatform/gsutil/issues/29](https://github.com/GoogleCloudPlatform/gsutil/issues/29)
Plotly is looking better and better. I've almost switched to Seaborn exclusively from raw matplotlib (unless i absolutely have to), and I'm starting to think I might need to start using Plotly more.
it wasn't even implementation defined, it was just how the interpreter worked with no promise that it wouldn't change.
Thanks for engaging. I've got some code in a private repo on a home server that I can make suitable for release shortly.
So much less annoying repetitive boilerplate. I wish my project was not stuck on 2.7. We have been "about to abandon the project" for a year, so no one wants to invent a month or 2 of developer time in the upgrade. But we keep pulling it out of the trash bin....
Email-over-Reddit
My understanding is that you‚Äôll benefit from multithreaded uploads and downloads which I‚Äôll be adding soon.
Suit your data into a matrix (adjazenzmatrix) on which networkx can work on. Try multiple setups for visualisation with networkx. Also have a look at the matrix itself with matplotlib.imshow. 
Isn't Fabric just your deployment app? I would understand that you cannot change the code in Fabric, and maybe some patchwork code. But what I don't understand is how Fabric being py2, in any way affects your production code.
&gt; Python 2 can do everything Python 3 can in terms of the results you can get out of it even if the implementation might be better in Python 3 Fortran can do everything py2 can, but improvements in computer science forced the industry to move on.
404
I don't understand this argument. Python 2 and 3 can co-exist side-by-side. To me this is like saying we can't install emacs on this machine because Vi was installed by default. Hit up the package manager, or build the source and install py3.
"It is an antipattern". Why? Because you said so? It's not just a JS thing. It's a C#, Ruby, JS, and more thing. Callback hell is an antipattern. Callbacks are not. The arbitrary limitations without reason need to stop.
This isn't a changelog. The changelog is far more intense. If I'm wrong someone would have asked for an explanation by now and made me apologize, saying why they don't understand the simple abstracts. But none have. The abstracts are extremely bitesize, you can't get smaller without losing important info.
If you consider that's a bug, post an issue on github. 
not really newsworthy, especially as the link does not refer to the actual changes in 3.6*.6* (those are listed [in the 3.6 what's-new section](https://docs.python.org/3.6/whatsnew/3.6.html)). it might be newsworthy had the 3.6.6 release contained security bugfixes, but as it is, it is only relevant to the people who are already subscribed to the four closed bugs.
NP. Feel free to ping me personally on twitter (1st1) or, better, create an issue on bugs.python.org so that I don't forget about it.
Hi All, This is Jon from the release announcement. Feel free to AMA!
i always assume its a decimal.
You can try for help on [their GitHub](https://github.com/vingd/srfax-api-python/). To start, I'd probably comment out these two lines rm $f; rm `echo $f | sed s"/txt/pdf/"`; and replace them with something like mv $f /tmp/tomcat7-tomcat7-tmp/completed/ mv `echo $f | sed s"/txt/pdf/"` /tmp/tomcat7-tomcat7-tmp/completed/ Create the /tmp/tomcat7-tomcat7-tmp/completed/ directory. This will move the completed files into a directory outside of the view of the cron job so that you can verify that the script is generating the files properly. Then I would add a log file similar to this logfile=/tmp/srfax.cron.log now=$(date) env &gt;&gt; $logfile echo "$now: ./srfax.py -s \"Oscar Fax $t\" -n +1`sed s\"/ *//g\" $f|tr -d \"\n\"` -f `echo $f | sed s\"/txt/pdf/\"` &lt; /dev/null" &gt;&gt; $logfile Place these lines above the just above the line starting with "./srfax.py" to add some logging that may help. Also, I don't mean to judge anyone, but this shell script portion is not really written well, but these changes should help out a bit.
I think you mean [Argument Clinic](https://youtu.be/uMRgmmnIrDU?t=4m15s), there's an equally hilarious segment at the end with a chain of policemen arresting everyone in the room for meta reasons.
It has been stated repeatedly that this is not going to happen. Unlike governments "lessons have been learned" actually means something to the Python community.
&gt; If its big enough , people would even consider a fork You can try that route but you **CANNOT** call it Python.
So can Python 1.5, still in production last I heard. If it ain't broke don't fix it :-)
Yes the differences between Python 2 and 3, are the same between Python 2 and Fortran.
Anaconda plugin for Sublime Works rather nicely 
&gt; The jump to v3 development was the best thing that ever happened to the stability of 2.7, too. I must point out that a huge amount of code was backported from various Python 3 versions to Python 2.6/7.
that book is amazing
I suppose, but with the time and if someone strictly used CPython, well, let's just say if it wasn't mentioned in the changelog in 3.6 people would be annoyed fixing bugs.
Mask out anything that isn‚Äôt red. Convert both red lines to paths. Link up ends that are closest to each other. Use that polygon to cut out the bitmap that is desired. Use opencv.
&gt; Not all libraries get updated. Nonsense. Any library worth its salt was updated years ago. The trivial ones that haven't been touched in years should be a piece of cake to update, unless someone has all ready done it for you.
Time heals all wounds and scar tissue forms. While I understand your point there would have been enough angry people to hear annoying complaints about the fact that dicts are now ordered.
No, I don't think there's any default timeout for join().
Couldn't this be a problem with operator precedence? I cannot really tell from memory what part of this expression will count as part of `lambda` and which will not. Welcome to the exciting world of infix notation.
I am talking about callbacks specifically in the context of async/await in python. Callbacks are fine in regular sync python code and fine in JS. And I explained my reasoning above, but let me reiterate it. If you have a consumer and a producer, in asyncio, what typically happens is that the producer is a task that runs in the background continuously fetching data from somewhere. This data needs to be passed on to a consumer. If you use a callback to fetch the data, then who call the callback? Only the producer can, because the producer is the one that knows when data is available. So now, what happens if an error happens in the callback? If the error is not handled it will bubble up from the callback, to where? Into the producer, that called the callback, obviously. So now the producer, which is most often some third party library, is responsible for handling an error it has no chance to know what to do with. Most often the result will simply be that the producer dies and probably does so silently. You program will simply just stop working and you won't be able to know why, because the error has been isolated inside the producer task. This doesn't happen in sync code, because there is only a single path of execution and any exception bubbles up to the user where you can either handle it or stop your program. 
&gt; Technical debt is a very poorly managed aspect of programming. Say it louder please. Not enough people heard you. 
To be honest, all I did was document Data Classes for this update but I thought I'd share it anyway! Let me know if I missed something new for 3.7, thanks!
I can recommend [networkx](http://networkx.github.io/) and [graphviz](http://www.graphviz.org/)
 I can recommend [networkx](http://networkx.github.io/) and [graphviz](http://www.graphviz.org/) 
All of the above has nothing to do with the release of Python3.7.
People don't want you to explain it to them sorry.
Yes so awesome! 
&gt; Just as unicode strings made it (presumably) easier for many programmers, it also made things very much harder for others, not just for the transition to 3, but for new code as well. The autoconverters often can't help here. Someone who hasn't a clue, but the FUD rules on reddit.
&gt; Libraries that are still Py2 only Please list these for the record.
That's a kind of Hobson's choice. But, will probably depend on who do you distribute your programs to. If you want both C++ and Python, and your users are non-tech people who use MS Windows, your life will be miserable... unless, maybe, you can constrain your users to just one Python distribution, but even then, it's a lot of pain.
newswirthy for me, thats enought.
Time to register the username ‚Äúoldsnake‚Äù on GitHub 
According to the documentation here, [https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfunction.html](https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfunction.html), your lambda function is called once, with arrays for the x and y arguments. It's not called 2x3 times with integer arguments. The result of x==y is a 2x3 array, so that's what is returned. Perhaps you want lambda x,y: np.ones(x.shape)
Really? This [Which is the fastest version of Python?](https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b) indicates that the startup speed of Python 3 is consistently being brought back to that of Python 2. No idea about 3.8 but then i really don't care either, I'm just sick of the whingers about Python who've never done anything for the language, mostly as they don't have time, but they do have time too complain about various aspects of it.
I use an interactive debugger. Why can't I just set a breakpoint in my interactive debugger? Not getting it.
Does anybody with any brains really care about voting systems such as reddit's? Look elsewhere and I'm sure that you'll find people saying that Pinochet, Hitler, Trump, Stalin, Putin and Pol Pot are extremely decent guys.
Your life will be much simpler if you chose a specific video format you want to edit.
Well yes, in the example you are giving it's an antipattern, I'd agree, there isn't much sense to it. But you are assuming that your example is the onlt possible case. There's plenty of cases where callbacks are just fine in asynchronous code-- in all technicality gevent does this just hides it from the user.
The planet is only 6,000 years old and flat, please take your nonsense elsewhere, just read the bible. Why did stone age people paint sabre toothed tigers but not the dinosaurs I've no idea, there must be an explanation somewhere in the scriptures. Getting African elephants onto the arc must have been tough, feeding them for 40 days even more difficult, but again there must be an explanation somewhere. Feeding the carnivores for 40 days, tht's a tough one, not sure how you explain that away. Just my ¬£0.02 pence worth.
And in that way I am right-- the initial question was of laziness and laziness alone, the abstracts simple to understand.
Again, I am talking about async/await. Gevent is not async/await.
your lambda function is called once, with arrays for the x and y arguments. It's not called 2x3 times with integer arguments. The result of x==y is a 2x3 array, so that's what is returned. &gt; &gt; Perhaps you want lambda x,y: np.ones(x.shape) Thank you. &gt; According to the documentation here, https://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfunction.html, Those docs say, "Construct an array by *executing* a function *over each* coordinate." That's not English for "calling a function once".
Oh sorry, should have clarified. I'm working with MP4
As other people have said, it all depends what kind of data you mean and what the scripts do. To help you think about it, here are a few examples: - If you try to load more data than fits in RAM, it's not going to go well. But 'big data' generally means it's too big to fit in any laptop's RAM, so you normally process a chunk at a time, reusing the same bit of memory. - Having extra RAM lets the operating system cache files so you can read them quicker. Depending on how you're accessing files, that could be important or not. - If you have to read and write a lot of data, disk speed might be important. SSDs are generally quicker than hard drives, especially for random access. But they're more expensive per GB. - And of course, if your code needs to do a lot of calculations, CPU speed matters. But to really take advantage of modern CPUs, your code needs to run in parallel, which is an extra layer to think about when programming.
This might be a dumb question but how do I update this in Windows? I reinstalled the last update just thinking it would overwrote the old install. And it's still not the newest version
Plenty! Many from autodesk, some for pubsub brokers / queue routing like haigha for amqp queues, building React still needs Py2 because it uses a library from google that they never updated, any complex Pylons app will need a tough rewrite into Pyramid, the internal libraries of many corporations, and more! Just because say, 99% of *public* libraries are Py3 ready, doesn't mean that the remaining 1%, which are just as important, are! Not to mention all the not public ones by corporations. The sad reality is it costs more to upgrade than it does to keep using the old tool.
You're just out of your mind then, it's OK. Good luck with that.
Mainly two reasons: - you are creating some script you want to run anywhere without installing a new language runtime. - e.g. RHEL 6 (and maybe 7?) don't have python 3 in the supported repositories and you might not want to compile or install third party stuff as you then loose the support you pay big bucks for on that part
ark*
Tribal organization as opposed to coalition groups within species is distinguished by hierarchy, which includes behaviors you describe in fanboys and elitists. Just be glad you don't need to pair program with chimps.
I'd use matplotlib like you're doing. Build some the code to be systematic about it. For example, you could make every node an object which has links to other node objects. 
Noob here. How do I update python?.
I believe you can compile your own ffmpeg from source with only what you need. But don't know how much you will gain. And I guess you're going to have to do a bit of reading on the subject.
or anaconda and use Nicki Minaj's face for a logo. In addition to winning the old folks who want to keep python 2.7, you also get more attention from pyladies.com and djangogirls.org plus Nicki Minaj's fans of course
I am not a whiner who doesn't do anything in the language. Nor are the people of the mercurial team complaining about the startup time. I will admit I skimmed the article, but Py3 wins in most speed tests-- and I agree. It's an objective fact. But it doesn't in startup time. The startup times here are strange, but I assume it's because there are no imports whatsoever or are on a very good machine. Again, take this from the perspective of a command line tool or a ton of deployment and commit scripts. In a long running app, Py3 will be better for speed, because of all the improvements in different actions matter. But in CLI tools and all these scripts, you are starting the VM so many times and not doing as many actions per startup, so you actually end up losing.
Is this still available?
I've used Boto for Amazon Mechanical Turk, and their web interface changed substantially over the past year, but the API didn't much. I think people may be waiting for that other shoe to drop.
You can't talk about async/await without talking about asynchronous programming. Async/await is one pattern. It is a pattern that in many languages can be used in conjunction with callbacks, which is another pattern. In asyncio there isnt an easy way to do this, for no good reason. Gevent uses a different asynchronous pattern, but is fine working in conjunction with callbacks.
I must agree with and appreciate that.
Interesting. Care to elaborate on why this is FUD?
So the big problem comes from not just "syntax handling" but kind of a push away from one of the fundamental aspects of python that drew so many people to use python in the first place, that it was easy to use. When python 3 was introduced, the adoption was slow for a very good reason. Python is mostly used as a scripting language. When we need something automated/done quickly, we pull up python, use it to accomplish our goal and then move on. If we need some serious work done, we create a C library to use in python. This means that the vast majority of people that use python didn't have a reason to switch to python 3. It didn't provide any benefits over python 2, has way less library support, and it was harder to write in. Switching from python 2 to 3 meant relearning a lot of how you programmed, the switch on how unicode handed was absolutely painful and not very fun. So why would anyone waste their time relearning how to write scripts, when the reason they started using python was because it was easy and quick to do so. A lot of the people that took the time to learn python 3, switched back to python 2 because the libraries that they wanted to use couldn't support python 3. Again, as a scripting language libraries are important because it means I don't have to reinvent the wheel, someone else did that for me. Now days the drive to python 3 is primarily from new developers who started learning python 3 and so they want the libraries to be updated to use with python 3. In all seriousness, if python 3 fixed the GIL bullshit, then we would have already swapped to it.
For someone who is just learning python right now is there anything major that I should know about and change as I'm building a knowledge base? 
 Returns: fromfunction : any The result of the call to function is passed back directly. Therefore the shape of fromfunction is completely determined by function. If function returns a scalar value, the shape of fromfunction would match the shape parameter. Are we looking at the same documentation?
Also, reading a lot of the comments here, is there any plan to have better backwards compatibility with Python 4.0?
 If function returns a scalar value, the shape of fromfunction would match the shape parameter. I think it should be "... would *not* match the shape parameter."
I hate to break it to you, but python is very popular among scientists who like to write their own packages/libraries. Those people also don't tend to update them. And yet, even though they were only written by a small group of people, they are still useful and used by many others in the field.
Wow, we are just going in circles here.. I litterally just went over twice, the main reason why you don't want to use callbacks in asyncio, you even agreed with me in your previous post and now you say there is no good reason why callbacks can't be used in asyncio. I don't know what to say, dude..
that was the joke but I guess I'm just bad at reddit
Great work! Very inspiring example of two-way binding which is commonly requested feature enabling interaction and detailed analysis of resulting plots.
Anybody willing to explain some the new important features for newcomers a bit? :) 
Try this link https://www.obeythetestinggoat.com/book/part1.harry.html 
Hey hi! Yes it is, if you want we can discuss the details and maybe I could try to give you a better explanation than the initial post I made :)
well that's another story. You need to roll your own generator or take the existing output, parse it with lxml or whatever and augment the tree with your custom stuff.
I agreed that your specific producer consumer example is when you shouldn't use callbacks, not that you shouldn't ever use callbacks in asyncio. But event based code can be asynchronous, and callbacks are a perfect use case to have event handlers along with the async/await pattern.
&gt; Did you even read the mailing list? Put a break point and watch your code execute...
?
I don't find it simple and many others agree.
I want to buy food I'm hungry do please donate on paypal ans stop being ungrateful I can help coding in python 
I'm using \`pyre-check\`, and I love it. However, there is one annoying thing that I hope someone can give me a workaround. I'm using Django model, in which each class has an \`objects\` attribute. Interestingly, this attribute is derived from a Meta-class, but not directly derived from it. What is the best way to resolve the warning from \`pyre\` on this condition? The error I got was: \`\`\` mydir/myfile.py:87:21 Undefined attribute \[16\]: \`MyModel\` has no attribute \`objects\`. \`\`\`
Why would you be insulting torward people openning you thread. I clicked on it geniously interested about your sotuation and how I could give you a hand but you're putting absolutely no effort trying be grateful to the people willing to pay attention to your story. Well, just find a job dude /r/forhire
Bullshit there was no insult in the beginning and I had no attention so I edited the post and insulted your little ego and bomm and thanks for the link
Reddit is popular but those board don't have that much people on it. Don't expect an answer in 10 mimutes. And please edit back your post to something constructive. I've no idea what my ego is doing in there but anyway. Where do you live and what is your background ? 
This looks like there more clutter than regular if-else statements. Also seems not very pythonic. 
I am college student struggling 
In France near paris
I really can code I can help you in projects you have
Then ask for an explanation. Otherwise you either don't care about it, or you do find it simple. Whichever of these is the case doesn't matter, just that it is such a case.
....what?
T'as quel age ? Et quels competences ?
23 ans Master g√©nie logiciel 
Yes, because voting systems are meant for promoting discussion. But instead on reddit they are used as signs of agreement.
Je m'en fou de ta formation, je veux savoir se que tu sais faire. On recherche des developpeurs dans la societe dans laquelle je travaille si t'es pret a venir bosser en Suisse.
En fait j'attends un virement qui n'est pas rentrer donc je suis dans la merde 
Absolutely, but delaying failure over and over costs less than preventing it unfortunately.
Thats the joke
There won't be a really pythonic switch statement without adding it to the language itself, and the proposal to do that was rejected. The previous attempts I found created even more clutter. I think it can be worth the ugly syntax depending on the situation.
En c++ J'ai d√©velopp√© un syst√®me de widget sur sdl ( une librarie c ) et avec √ßa j'ai beaucoup appris sur le fonctionnement de librarie gui et en python et html j'ai fais une application qui permet de virtualiser chrome sur un serveur et le contr√¥ler √† distance avec js et j'ai utilis√© beaucoup de technologie en python de twisted √† kivy
What is confusing and why?
Windows has the "py" launcher. py -3.7 That should run 3.7 if you have it installed. https://docs.python.org/3/using/windows.html#python-launcher-for-windows
En c++ J'ai d√©velopp√© un syst√®me de widget sur sdl ( une librarie c ) et avec √ßa j'ai beaucoup appris sur le fonctionnement de librarie gui et en python et html j'ai fais une application qui permet de virtualiser chrome sur un serveur et le contr√¥ler √† distance avec js et j'ai utilis√© beaucoup de technologie en python de twisted √† kivy
Python 4 will most likely be normally compatible with the last 3.x release. No need to worry. 
T'as l'experience pour commencer a faire des taffs en Freelance, pourquoi tu mendis et reagis comme un gamin de 13 ans sur reddit. D√©sol√© de mes propos hein, si tu es vraiment dans la merde c'est vraiment moche mais tu te rend pas service.
What does this have anything to do with the startup time and the mailing list?
Nah, there really isn't anything paradigm-shifting in this release that would affect newcomers. Maybe some bug fixes, but not features. 
boohoo
I will leave you with some words from someone way smarter than me. https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/
Ah bon tu pense que jai de l'exp√©rience peu tu me donner des bon cannaux de freelance qui ne m'utilise pas pour leurs base de donn√©es et je demande de l'aide contre service c pour 5 jour je recevrais de l'argent dans 5 jours max je rembourse
The current Debian stable was released 2017-06-17 and contains the then-current [Python 3.5](https://tracker.debian.org/pkg/python3-defaults). You get a newer Python with the next Debian stable release (probably in 2019). If you don't like that schedule, maybe Debian (and Debian-"ports" like Raspbian) is the wrong distribution for you? If you like the bleeding edge, maybe ArchLinuxARM is more the thing you want? https://archlinuxarm.org/platforms/armv8/broadcom/raspberry-pi-3
Ah bon tu pense que jai de l'exp√©rience peu tu me donner des bon cannaux de freelance qui ne m'utilise pas pour leurs base de donn√©es et je demande de l'aide contre service c pour 5 jour je recevrais de l'argent dans 5 jours max je rembourse
I'm not going to defend the wording of the documentation; I can see how you can reach either conclusion.
If you're trying to convince me with a damned considered harmful, you won't. They are written by elitists who refuse to expand their horizons. Considered harmfuls are [themselves extremely harmful](https://meyerweb.com/eric/comment/chech.html). There are people who have, quite literally I may add, claimed that conditional blocks like "if" and "else" are considered harmful.
I really wish this book covered Flask instead.
thinkpads, thats what they have on the ISS.
The case is that I and others find these types of notes confusing. End of conversation. 
Can't you just run setup.py?
You are insufferable.. Seriously.. Blocked.
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hang in there. üòî
OrderedDict has different comparison semantics than a dict, and would have been a backwards incompatible change.
Hello! I'm a bot! It looks to me like your post might be better suited for r/learnpython, a sub geared towards questions and learning more about python. That said, I am a bot and it is hard to tell. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. While I was at it, I checked [Stack Overflow](https://stackoverflow.com/) but I couldn't find a useful result Though fair warning, this section of the my code is under development, and I don't expect these links to be very useful. *** ^(this bot is written and managed by /u/IAmKindOfCreative)
Nice technical details. Maybe work on the hook / Attention grabber.
A solution in the core is good but any difficulties you had with https://pypi.org/project/attrs/ ?
The problem is that your data is not in a standard format type for graphs. You have to make a conversion somewhere. Networkx provides several ways to build graphs. If you are using a Pandas dataframe, then use `from_pandas_dataframe`. You can also build a graph from a matrix using `from_numpy_matrix` if you convert first to a matrix form. If you run out of options, just write your own script using Networkx `DiGraph` methods for like `add_edge` and `add_node` to build the graph.
I hope they introduce `(Int, ...)` as syntactic sugar for `Tuple[Int, ...]`
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Others have made reasonable suggestions, but I am curious as to why you need a laptop for this? If you are a graduate student, or even an undergrad working in a lab or in collaboration with a group, then they should have computing resources available. A small laptop, no matter how powerful, will not handle much. Many departments/labs/universities have computing resources available that will blow anything you buy out of the water. For example, I am a graduate student and I have only ever used my laptop for anything coding and debugging. I never run anything on it. Anything of significance gets sent to either a powerful single machine, a computing cluster, or a super-computer. Even the weakest machines available can have 32+ cores and 100GB+ of memory. I would check with your university first to see what resources they have available and not waste money on an expensive laptop.
You don't need an interactive debugger to use breakpoint(); you are not the target audience.
"End of conversation", really? That's hilarious. If you find something confusing, ask for a damned explanation. You won't get fucking handouts. No one is going to hold your hand in your career.
If you can't take a debate without providing arguments that have no ground to stand on, you shouldn't start them. Blocking won't help you against everyone you meet that has opposing views. But if you want to go to your safe space, thats fine with me.
Yeah I think you are right. I was looking into subclasses but I don‚Äôt think it will do the trick. Thanks! 
That and `List[int]` to `[int]` is one of the things I'd really like to see but I doubt it'd happen. 
I understand that. The thing is, I am strugling to figure out why there is an audience for this at all. Why would anyone use this when interactive debuggers exist.
That would be good. Unfortunately Django is still more popular than Flask, but I also like Flask better because it's much more configurable.
If they are using new reddit, they don't even see the sidebar.
Batteries included.
Thats less useful since lists should be homogenous (or any). Wouldn't mind `list[int]` though. 
You need to accept that people can find these release notes confusing. No one asked you for anything. 
If it is your opinion, that the release notes are confusing, which is a valid opinion, and you have a problem with my response, ask for clarity. I was not once asked for clarity, therefore I have no way of knowing anybody has a problem with my response bar the fact that you got ticked off at how I responded and decided to white knight for someone who was lazy to read.
We're stuck on 2 because of Google &gt;:(
You're right, and no, debian stable is not at all for me. The only reason its a mild issue is that I have a few other things living on the (default raspbian install) Pi that I added some scripts to. I built 3.6 on it, which wasn't too bad, and it worked fine for a bit. I added some libraries to a couple projects, though, that depended on system packages (I forget to consider that when writing them, I'm used to having easily up-to-date stuff on most of my systems). Those system packages were either available, but older versions, or not available at all yet. So, it was continue down the rabbit hole, or just throw those scripts on my digital ocean droplet (went with the DO droplet, though it's less 'cool' than running it on a pi). I'm pretty comfortable with most linux, but, admittedly, I'm not the best at dealing with package dependencies outside of the main repos (except on arch, I dual boot that on my laptop). I really like the pi project, and I don't really have any complaints there, just unfortunate. It would be cool if they could track a newer version of python outside of the debian repos (don't know how much work that is though), especially since they're now 2 versions behind and Pis were kinda built to play with python, etc. 
The question was why are people still using python 2. Fabric 1.x is part of that equation because it requires a python 2 environment. And Fabric 2, which is python 3 compatible, has breaking api changes so you can‚Äôt just upgrade the package and be on your merry way, you‚Äôd also need to refactor the fab scripts to be fabric 2 compatible. Silly but not difficult and just not prioritized therefore python 2 hangs on. And yes most use it for deploys but it served as a general CLI wrapper to interact with a large microservice infrastructure, my preference for a CLI wrapper these days would be ‚Äòclick‚Äô. 
Sounds like a good idea. I would use a GUI, but you should start with a CLI and upgrade to a GUI later. However you are confused about something, Visual Studio is a code editor; it has nothing to do with if the final code has a GUI or not. You can use any code editor you want to make your program, and use a [GUI module](https://www.reddit.com/r/learnpython/wiki/faq#wiki_what_gui_should_i_use.3F) in the program. Come visit us in /r/learnpython if you get stuck. 
The infamous metro indeed.
You can run py2 and py3 side-by-side. You don't replace your system python with py3.
maybe...
Im actually making this as a gift, I have no idea how to do what I want to do yet.. Essentially Its a little box with a touchscreen to grab quotes and display them on touch.
Yeah and we do, plenty of apps are in python 3 docker containers or run with local virtualenvs. That isn‚Äôt the problem. What I‚Äôm saying is, there is code cannot not run on the latest Fabric so until that code gets upgraded to be compatible, we have to still run some things with Fabric 1.x which requires python 2 therefore there will still be a python 2 dependency lingering.
Gotta learn sometime. :D
Thanks! I wanted to link to the section but couldn't find a way to do that on my phone.
Sounds fun and easy. Step one I suppose is buying a Pi and touchscreen and enclosure and setting that up. Step two is writing a CLI python program that grabs a random quote and displays it. Step three is to program the GUI to react to a touch and call the program you wrote in step 2. Step four is giftwrap it. Where are you in that process? 
You lost me when the example code uses 2 spaces for indentation
If you're already familiar with flask, you should be able to apply the TDD practices to a flask project pretty easily. At least that was my experience.
&gt;So i my point is, yes Python is cleaner to write code in but that doesn't make it easier to write code that uses Python as language and it's tools to achieve your goal. Your point is that you are a goal moving troll trying to pick a fight. Go back under your bridge.
Sounds like a security nightmare!
That's actually a breaking change IMO
The scientific python community is one of the ones *leading* the way towards python 3 adoption. The scipy stack (which is basically the core of scientific python, practically everything scientific depends on some piece of it) is py3 only going forward already. Future versions will not support python2.
Not useful as such, just a nice short way of saying "ints in a list" that I miss from Haskell. `list[int]` seems effectively the same as `List[int]` though.
Well, MP4 is a container format, not very difficult to parse, so, in principle, if all you need is a cut and paste of some chunks of the video, you could just write it yourself. This one seems to be the best description of the format available: http://xhelmboyx.tripod.com/formats/mp4-layout.txt (the official documentation is garbage).
By this logic, most Asians are 7'6" because Yao Ming is 7'6". 
Correct link: http://pyfound.blogspot.com/2018/06/dr-russell-keith-magee-python-warrior.html
**Cannot recommend this book enough** If you're looking to learn either Django or TDD, this will be an awesome tool for you.
This is a fantastic upgrade for using Plotly with Jupyter Notebooks, great job!
No. This has been done with machine learning, but if it were free and open source I'd be astounded
Lol are you serious 
Erm, no, not really. But sure :) The majority of *open source* scientific python libraries are python3 compatible.
I just wondered how people got the AI to write scripts for them without making it themselves
Consider, for a moment, that the title of your post may be a bit rude to the human beings who work on the project.
Again, you're confusing size with frequency. All of the big packages tend to get updated. But there are thousands upon thousands of small packages written by individual research groups and projects that literally never get updated even once. And this notion that those things are never useful or used is ridiculous.
I beg to differ, it's a short term version of thinking. It's way more expensive long term to find people who specialize in your legacy issues as time goes on after the death of that technology. You could have bitten the bullet and migrated when it was common to find people doing that, maybe a few years down the line you're at a point where you're spending 300k on an engineer because he's one of 20 that hasn't retired yet. Long term thinking requires you to take potentially expensive decisions now to save money later. Which unfortunately doesn't align with a _always keep costs low_.
Put a breakpoint at the beginning of your Python 2.7 code. Step through it. Does python trace the imports or not? I'm telling you it does. The mailing list talks about how milliseconds matter because Murcurial is written in Python. That's problem number #1 if milliseconds really matter. The example given was they removed imports to things that weren't needed and they sped up the code by 11%, so therefore milliseconds matter. Don't import things you don't need! Milliseconds matter to very few people that use Python. Run long processes is standard and putting things at the top of every file (as is recommended) doesn't help your startup time. If Python 2.7 ignores unused packages, please run this... import time t0 = time.time() if 1: import numpy import scipy import pandas import h5py import matplotlib import os import math import scipy.sparse import numpy.linalg import matplotlib.pyplot print('dt =', time.time() - t0) and then this import time t0 = time.time() if 0: import numpy import scipy import pandas import h5py import matplotlib import os import math import scipy.sparse import numpy.linalg import matplotlib.pyplot print('dt =', time.time() - t0) and see what you get.
Go and JavaScript are the trendy languages now. But personally I don't make technology choices based on that, and would avoid companies that do.
&gt; And this notion that those things are never useful or used is ridiculous. I didn't say that. I will however claim that they are used infrequently compared to the big ones. So for a better claim: The majority of scientific python code has a set of dependencies which all have python3 compatible versions. In other words, for the majority of scientific python code, python3 compatibility can be solved by updating to the most recent versions of your dependencies and then fixing any python errors in your own code, it doesn't require any changes to upstream. I stand by that claim. 
Good point as well. I'll stick to learning Python with PowerShell for now... it's very crucial to the type of work I do... And I save the company money ;)
Have you tried altair?
The thing I replied to (which you then replied to of mine), was this: \&gt; Nonsense. Any library worth its salt was updated years ago. The trivial ones that haven't been touched in years should be a piece of cake to update, unless someone has all ready done it for you. So when I said that there are lots of packages in the scientific community that never get updates, I was responding to this idea that all those thousands of packages that aren't getting updates are "not worth their salt". Which is just flat wrong. There are literally thousand and thousands of libraries/modules that never get updated but which are used every day. As I pointed out elsewhere, there are massive libraries of Fortran 77 code from the 70s/80s that people still use every day in neutrino physics. \&gt; The majority of scientific python code has a set of dependencies which all have python3 compatible versions. In other words, for the majority of scientific python code, python3 compatibility can be solved by updating to the most recent versions of your dependencies and then fixing any python errors in your own code, it doesn't require any changes to upstream. Again, that's just not true. No matter how many times you say it, it still won't be true. The fact that scipy or numpy is py3 compatible is not sufficient to make a big homemade analysis toolkit written in python py3 compatible. That's not how any of that works. In most situations, you're daisy chaining multiple homemade packages together in addition to anything like Scipy that you might be using (if you're even using scipy at all, which frankly most physics code does not). 
Consider using the hdfs/Spark or storm/Kafka model, old school works well, you can use s3 or blobs to further park your data after analysis. 
&gt; As I pointed out elsewhere, there are massive libraries of Fortran 77 code from the 70s/80s that people still use every day in neutrino physics. Sure, but those libraries are, by and large, still maintained (they have to be to take advantage of modern compiler stuff to continue to be fast). The binaries people at XYZ University use in their lab may not have been touched in a decade, but those are not *libraries*. &gt;In most situations, you're daisy chaining multiple homemade packages together in addition to anything like Scipy that you might be using (if you're even using scipy at all, which frankly most physics code does not). This code is, for the most part, not open source. I cannot find it. So its not particularly relevant to this discussion. You're talking about binaries, not libraries. Most OSS library code, which is what the prior person was talking about, is py3 compatible, or its dependencies are anyway.
Huh. It definitely looks interesting. What is the reason to use it over seaborn or plotly?
&gt;Sorry! Thanks!
I'm used to these covers being O RLY jokes. Clicked expecting a laugh, instead got an actual cool book. Nice.
&gt;I really appreciate it. I really wish I had a computer programming background instead of biology. Much more help in the medical world! 
No, those librairies are not being maintained. That‚Äôs the point. 
&gt; No, those librairies are not being maintained. That‚Äôs the point. Can you give me an example of an openly available, python2 only package (or fortran77 for that matter) which is unmaintained and doesn't have a python3 compatible fork/reimplementation?
&gt; Django I was interested. Was.
No one said Py2.7 ignores unused packages. But the internal import machinery is faster, whatever the reason is. No one is arguing that a big reason of the issue is the way people import things, just that Py2.7 does it faster, one theorized idea is the way 3 searches for the imported package vs how 2 does. Furthernore just because it matters to the few people who write CLI tools and advanced deployment scripts that milliseconds matter in startup time, does not in any way discredit their point that it does matter. How would you feel if Python made a change that completely fucked up performance on your niche market?
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Yes, but if your business logic relies on a method always returning in an odd number of seconds because that's the behaviour you observed on your Solaris machine using 16-bit Jython 3.6 build 3728 in debug mode, I really don't have any compassion for you. 
I switched to flask not long after reading this book. You can apply at least the large majority of theory and tests to flask projects. In fact, you could apply it to any project, really. But I do agree that it would be nice to have an alternative in a flask context. After all, flask is notoriously lacking in books...
Wow hadn't heard of this, looks very useful. 
Your comparison doesn't even make sense, this is the programming equivalent of comparing apples and oranges.
Does anyone really grok how to actually **unit** test flask? Everyone on the internet seems to think "unit tests" are integration tests for some reason. For me, this is the one downside of Flask. The proxies are great, but make it so that truly unit testing functions requires quite a bit of mocking (`request`, `current_user`, `current_app`, etc).
Alright, your comment gave me a little eurica moment! Because I don't empty/reset my list it still contains my old threads, right? So on the next loop the old threads are in there and when the list is itirated on, the code tries to restart the old theads, right? I worked around the error by enclosing most of the thread starting stuff in a try: except: ... a consequence of this will be a massive list of threads if I leave this running then. 
It says open source, but is it self-contained? Can it run on a machine that's off the network? I was under the impression that only JavaScript Plot.ly could run offline. Thanks! 
Bugs, in this case apparently a documentation-bug, cost users time and aggravation, and that is rude; so now you understand where I am coming from.
To those complaining about the use of Django. The book covers the mechanics of the unit test system that's built into python quite well. Those lessons are applicable anywhere you are using Python. You can't write about TDD without a project to use as an example. The Django app is fairly simple and provides a good intro to TDD as a process. Even if a different application was built, you would still have to do the work to adapt unit tests to your personal needs. Following this book will simplify the path to gaining meaningful experience with unit testing in Python. 
Getting Started ‚ÄúWhere to begin?‚Äù. This is the most common question when trying to create your programming language. Actually, my first question is, "What are you doing that no existing programming language can do?". Followed by, "Do you know how much your successor is going to HATE you?"
Excellent, that static image thing was a big hurdle for me on a previous project that used Plotly
Let's not beat a dead horse. [https://github.com/ericvsmith/dataclasses/issues/19](https://github.com/ericvsmith/dataclasses/issues/19)
God damn this is amazing 
I think the purpose of the project is to deepen understanding and probably also practice. I don‚Äôt think they are suggesting this be used for a critical business project. But maybe they are, and they are insane. üôÄ
Yeah, terminology being "exposed" technically it's exposed to python if you offer any sort of API and just have a python client and library someone can use. But really with a web/rest API, any language with a http client library can take advantage of it. You'll get better adoption if you distribute client libraries pre-built though.
Hi Jon, this looks amazing! I'm about to start work at the APL, maybe I'll get to see you around some time. 
yeah completely, but the whole "tiny bit more code" thing can be said about a ton of other features we use. Decorator syntax is really just a one line replacement for one line of `func = decorate(func)`, overloading operators can easily be replaced by just calling a named function, `__getitem__` could be replaced by creating a `self.items = {}` and invoking `instance.items[item]` instead... In the end it's just a little extra magic everywhere that makes easy to write patterns. With the `__getattr__` we already have in classes, might as well have it in modules too.
Hmm, how so? It's made to invoke shell commands. Plus there's no injection, as in this won't work: `from myshell import ls ; ls('-al', '&amp;&amp;', 'rm', '-rf', '--no-preserve-root', '/')` subprocess would be the module you use to avoid the os.system injection issues (unless of course you enable shell=True). But otherwise a library like this is meant to run shell commands, so if you `from myshell import rm` you know damn well what you're opening up.
If you search on youtube.com for "pyserial arduino" you get a lot of hits. Have a wander through them. Questions about using oython should be posted in /r/learnpython.
I've been doing this, as well as applying much of the pytest approach to Flask. It is has been a bit of an uphill climb, especially with Selenium / live server testing, but worth the struggle. 
Well presumably they made something else better so the net effect is I got a 15% improvement for porting. I use unicode instead of bytes and that's slower, but they sped up dictionaries. I microoptimized my 120k LOC program to load a super complicated 2 gb binary file in 4 seconds. At some point it's fast enough, but the python devs sped up my code. I figure if it now gets 15% slower, I'm not out that much. If my 600 tests take 12 minutes instead of 10 minutes, I don't hugely care. It's automated or I go take a break. I suspect that something got better and they made the choice to not microoptimize python to your edge case.
It depends upon on the use case. I think it was hard lesson to learn that more freedom isn‚Äôt always better. Especially if that freedom isn‚Äôt going to be used and especially if that freedom relies upon a lot of different libraries that you need to maitain to keep it working properly. I always think Django should be the first place to stop and if it doesn‚Äôt do what you want then move onto to Flask. 
Finally a worthy successor for the thousands of apps stuck in python2
Relavent XKCD: https://xkcd.com/1838/
Personally, I don't. I keep my flask handlers thin enough that I don't need to unit test them, because they're just thunking down to something more interesting. For example, here's a slightly edited handler from a work project. @appl.route('/widgets/&lt;country&gt;', methods=['GET']) def get_country_widgets(country): view = widget_view_builder.build_view(country) resp = Response(json.dumps(view), mimetype="application/json") return resp Keep your flask layer to performing HTTP things and marshalling, and you don't need to unit test them. One acceptance test to prove that the flask thing is hooked up will suffice, and then you can focus your testing efforts on your services and domain model.
I'm not disagreeing that a lot of python got optimized from 2 to 3. But the import machinery was not only completely rewritten, but written to cause *slower* load times. I'm not saying this can't be fixed either, it can. And as soon as it is, anybody who is using this and this alone for the "why I can't switch" dilemma will start to make the transition. But until then it is still important to make note of. I wouldn't call it an edge case if a high profile project like mercurial is complaining about it. Maybe rare and niche, but definitely not an edge case. It's not a matter of 12 or 10 minutes, if that's the example you're using you are missing the point. Lets say that on average, in the switch to 2 to 3, everything but startup time got 15% faster. And lets say startup time slowed down by 10%. If my tool has to startup a lot but do small amounts of execution per startup, like in command line tools, or a couple hundred independently working for whatever reason scripts (which by the way is done more often than one would think, just usually in shell or in ruby instead of python), I will get less of a benefit, or maybe even a detriment-- especially in terms of command line tools because user perceptibility of action occurs after, what, 1.5 seconds? Quickest example I can give is pipenv. Because regardless of how you feel about it's usefulness, many agree that it is *slow* because of it's resolution, but find that it is just slow in general. I personally, have found it is significantly slower on Py3 rather than Py2. User perception matters. Also, Py3 hasn't been consisdered generally faster than Py2 until 2014/2015, when 3.4/3.5 was released. 3.4 really started on improvements, 3.5 continued, things got slightly worse in 3.6, 3.7 now definitely, generally speaking, is faster. But startup time has always been slower on 3.x, even in 3.7. Much better in 3.7, only 30% slower on some basic pyperformance tests. But that's still unreasonably bad.
[Why isn‚Äôt there a switch or case statement in Python?](https://docs.python.org/3/faq/design.html#why-isn-t-there-a-switch-or-case-statement-in-python)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/brasilonreddit] [\[r\/Python\] Announcing the first Flask Conference in Brazil - August 2018](https://www.reddit.com/r/BrasilOnReddit/comments/8upuem/rpython_announcing_the_first_flask_conference_in/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
switching to pycharm
I looked it up. It has nothing to do with import machinery. The problem is with namedtuple. People like it and it's just slow.
I went through this tutorial a year ago. It's very very good. Highly recommend. 
Can you elaborate and give a link, because that doesn't make any sense on it's own.
I read it, but I can't explain it. https://lwn.net/Articles/730915/
`if condition1 ... elif condition2 ... elif condition3 ... else`
Caching
Am I misreading, or are they saying the patch was already made yet startup time is still slow? Also according to multiple places in the mailing lists, the import machinery is also a significant factor.
The author created the testing goat idea before the cover was made and convinced oreiley to use a goat.
I'm using `poetry` for three projects at work so far. I'm really liking it.
An entire conference for flask?
How much money did you pay? Your right to complain is as large as the price tag of the software.
&gt; RPLY (same as PLY but with a better API) One thing I'd like to point out is that IME vanilla PLY is *far* more flexible than RPLY. 
Cant wait to try this out. I hate matplotlib.
Dictionaries
Hello! I'm a bot! I see someone has already suggested going to r/learnpython, a sub geared towards questions and learning more about python. I highly recommend posting your question there. Please follow the subs rules and guidelines when you do post there, it'll help you get better answers faster. While I was at it, I checked [Stack Overflow](https://stackoverflow.com/) but I couldn't find a useful result Though fair warning, this section of the my code is under development, and I don't expect these links to be very useful. *** ^(this bot is written and managed by /u/IAmKindOfCreative)
What inspired you to write this? Have not looked at the repo (on mobile), but this sounds like advocating phenomenally bad practice with the help of some hack solution. Designing code to not require circular imports is not difficult. Writing absolute or relative imports is not difficult. Publishing stuff like this only adds to the confusion for beginners and complicates things for people who don‚Äôt know any better.
Like I give a shit what you think my rights are?
One of the main reasons were firstly I found it tedious to write those imports and secondly, if one tried to execute a python file from another directory, all the imports fail. It is again tedious to cd into the directory where the code is to go and execute it, both those things are not required in this project.
Not complaining but why support only Python 2.7, is it because the infrastructure on your day job only supports that version? 
Really no reason other than 2.7 is what i learned at the time, plan to move to 3.x once I invest the time to the learn the changes and make the necessary revisions to the code I already have. 
Just install them. Use the [python launcher for windows](https://docs.python.org/3/using/windows.html#launcher) (comes with python) to launch. py # starts the latest version py -2 # starts python2 py -3.7 #starts python3.7 The biggest advantage to the python launcher is it respects linux shebangs. If the first line in your python file is #!/usr/bin/env python2.7 and then you start your program with `py myfile.py` the python launcher will use python2.7 to run your program. 
I'm for dictionaries, ``` def my_func(param): command_palette = { 'something': 'first command', 'something_else': 'second command' } return command_palette[param] ``` 
What about Django
You're looking for r/learnpython. When you get there, we'll start by asking you what you've tried with looping. You know you need to do some sort of loop, what have you done?
[removed]
How do you prevent causing a city wide traffic jam? traffic is a complex system, changing single traffic light from red to green affects the whole system. pretty sure this idea does more harm than help.
This sounds a lot like [LINQ](https://msdn.microsoft.com/en-us/library/bb308959.aspx) but less composable. Linq allows us to write chained expressions over enumerable data soures, eg. "customers.Where(c =&gt; c.age &lt; 18).GroupBy(c =&gt; c.State).SortBy(g =&gt; g.key)" It's easy then to iterate across those expressions to do something like "myFilteredStuff = stuff.Where(x =&gt; x.size &gt; 5).ForEach(s =&gt; SendToApi(s))" There's then a bunch of syntactic sugar that would allow one to rewrite that in a DSL form from s in myFilteredStuff where s.size &gt; 5 ... Linq works because the foundation of the library is the [List Monad](https://en.wikibooks.org/wiki/Haskell/Understanding_monads/List). Your validator_is_false/validator_is_true thing is sort of like an [Either Monad](https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/10_Error_Handling#the-either-monad) . There's a couple of efforts at implementing Linq in Python, but I don't know how good any of them are. If you're interested in learning more about programming with Monads (without the scary M word) I highly recommend the [Railway Oriented Programming](https://fsharpforfunandprofit.com/posts/recipe-part2/) article.
I remember coding like this, good times...
This is obviously for academic purposes. No successors.
Thanks, that's a good pointer. I'll look into doing that by the next iteration.
Do you know about the Flask [jsonify](http://flask.pocoo.org/docs/1.0/api/#flask.json.jsonify) function? You just pass in a Python list/dict and it takes care of the Response and mimetype. `resp = jsonify(view)`
may i inquire as to why that is? (don't get me wrong, i'm easily hyped for new releases especially of python, but this is about as just-a-bugfix-releasy as it gets.)
what are the pro and con compared to other methods of pakage management ?
That is about building a new system versus merging attrs I the stdlib, it has nothing to do with my comment. 
Did you consider using [Lark](https://github.com/lark-parser/lark) as your parser? And if so, what made you choose RPLY?
Why not?
Doesn't help you as you're using Windows, but anybody having the same problem on Linux or Mac can use 'asdf': https://github.com/asdf-vm/asdf It's a really neat tool, and it works quite well.
I have a pi3b+ and a wooden enclosure.
Sometimes the stars align and you get the tutorial to something right then when you need it. 
Please, don't write compilers in Python. Even accidentally, if anyone runs into this article and thinks it is a good idea to do this, even for something very-very simple will increase unhappiness of this world. This is not because Python is somehow special. Many compilers suck in the same way. Recently, I had to do a research on how different binary serialization formats work, and, in particular, I looked into how they handle their IDL (interface definition language). We are talking about Protobuf, Thrift, Avro and few more. Because people who designed these languages weren't good language designers, and, it seems like for them it was their first time working with parsers, they all designed compilers which can only compile one time at a time. Well, people who created Protobuf, Thrift etc are just... not very good programmers. But, in Python, you cannot really even hope to parse sources of your program in parallel. So, from the get go, you will create a program with a huge defect, that you have no hope of fixing. Why would you do that? Another thing about this article: specifically in Python, you would choose to do something as bizarre as generating a parser rather than just writing it? Why? This kind of makes sense in a language like C, but why do this in Python? Why not use some Pacrat parser? No need for lexer, easier to store context, no need to generate anything...
You never know though. I guess a few languages have evolved out of exercises of understanding
Yea but the point is that it‚Äôs cache layer that invalidates itself, without you having to worry about the cache keys or anything.
I read that they didn't merge the patch and someone else investigated ways to speedup startup without looking into namedtuple because it was controversial.
is there any plt.imshow like function? Can I reverse axis in 3d plot now?
It's the old battle: Notepad on steroids vs Microsoft Word
Never used plotly before, but this release looks great, I hope I can find a reason to try it out asap.
&gt; What are you doing that no existing programming language can do? no other existing language is a language written by me for the purposes of my own personal Shits 'n Giggles
Do you realise that Python 2 will be end-of-life in 2020?
I added the goto line binding ({ "keys": \["super+l"\], "command": "show\_overlay", "args": {"overlay": "goto", "text": ":"} }) and shortcuts to the jump back / jump forward. I also find the git plugin very useful (to visually find where I'm working..). But to me the Sublime Text most powerful couple are shift+cmd+l (multiline editing) and the json and SQL formatter plugin.
is this backward compatible with python3.6 code? Can I change the project python version to 3.7 without any worries?
&gt; is this backward compatible with python3.6 code? Can I change the project python version to 3.7 without any worries? wrong topic
is this backward compatible with python3.6 code? Can I change the project python version to 3.7 without any worries?
Most straightforward way (and esp. since you are on Windows) is to use different [conda environments to manage your Python](https://conda.io/docs/user-guide/tasks/manage-python.html). Install Miniconda to do that. There is also [https://github.com/pyenv/pyenv](https://github.com/pyenv/pyenv), although I doubt if it will run on Windows.
`import math` will work in any directory because it is a module included with the standard library in your installation of python. `import graphics` will only work in a directory where you have the graphics.py file, as it is not part of the standard library. You could create your own module, and save it to one of the directories listed in your `sys.path`, then you could import it from whichever directory you execute the python interpreter. 
Looks great great for your first project! Just a small question: Why the 20+ send keys commands? -&gt; actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END) actions.send_keys(Keys.END)....... 
(Could have been a for loop, right?) Also you have declared the URL of insta but you later on just hardcode it, could be URL variable too.
I've taken your advice and I've added a subplot with KE, PE and Total Energy vs t, right next to each orbit, [one of which you can see here](https://github.com/kitizl/Gravity/blob/master/orbit-energy-vx-0.pdf), or for a [more dramatic version, here](https://github.com/kitizl/Gravity/blob/master/orbit-energy-vx-4.pdf). Either way, at least to my wonky primate eyes, the Total E _looks_ like a flat line. Am I doing something wrong here?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [kitizl/Gravity/.../**orbit-energy-vx-0.pdf** (master ‚Üí 3f51b87)](https://github.com/kitizl/Gravity/blob/3f51b8787227b11639fd77770495d0e0432a7f05/orbit-energy-vx-0.pdf) * [kitizl/Gravity/.../**orbit-energy-vx-4.pdf** (master ‚Üí 3f51b87)](https://github.com/kitizl/Gravity/blob/3f51b8787227b11639fd77770495d0e0432a7f05/orbit-energy-vx-4.pdf) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e1ho5bw.)
I let the text process for 24 hours, and I think I understand. Thank you so much!
Well you have to put brackets around the things you want to print : `print (comred + str(number1+number2) )`
&gt; The results you are getting are obviously bad, the orbits are pretty far from being closed (periodic) as they should be I thought this was simply because of my initial parameters, which I have not chosen to find a stable orbit. Also, I get that the Euler method is faulty (although some new additions, including [an extra plot that plots the total energy](https://github.com/kitizl/Gravity/blob/master/orbit-energy-vx-4.pdf) shows that energy might be conserved for the span of time that the code is integrating), so I don't know why my orbits are not closed. I've tried using smaller time intervals, and that seemed to have helped a bunch. &gt; because it can be solved exactly with pencil and paper I'm gonna be honest with you, this is precisely how this project began. I got extremely bored after the fifth row of calculations, so I whipped this code up simply so that I don't have to do it myself. &gt; I have found three and four body simulations to be entirely doable on a PC with Python Well, that's certainly the next step that I hope to do. &gt; The code isn't yet in a state such that I would show it around, though. Is this because of the reasons you've mentioned above, or something more? I'd love to know why. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [kitizl/Gravity/.../**orbit-energy-vx-4.pdf** (master ‚Üí 3f51b87)](https://github.com/kitizl/Gravity/blob/3f51b8787227b11639fd77770495d0e0432a7f05/orbit-energy-vx-4.pdf) ---- 
I did it and it still does not work
https://www.reddit.com/r/Python/comments/8ue8kg/python_370_released/?st=JIZU65PG&amp;sh=578448a4
nvm man thx for the hlep 
I agree, in this guide I used RPLY because I thought the API was easier and more similar to an EBNF, but I agree that PLY is a more complete project and far more flexible.
It doesn't have much to do with execution time. Source code compiled using deterministic compilation will always output the same binary.
I didn't know this parsing library, I'll try it for sure! Thanks for the suggestion 
3.6 code should run normally on 3.7.
This guide was created with educational purposes, so I was not looking for something that was never done before, just inspire people to do a personal project that could become a new competence. But thanks for the feedback
Because flask promotes bad practices, threadlocals everywhere :) Django,Pyramid, Sanic handle this better. 
Found [Data Structures for free](https://doc.lagout.org/programmation/python/Data%20Structures%20and%20Algorithms%20in%20Python%20[Goodrich,%20Tamassia%20&amp;%20Goldwasser%202013-03-18].pdf), even the [source code is available](http://bcs.wiley.com/he-bcs/Books?action=resource&amp;bcsId=8029&amp;itemId=1118290275&amp;resourceId=31281). Downloaded it myself. 
NanoGenMo might have some python. It's competition to write code that generates a novel. https://nanogenmo.github.io/
The purpose of this post, as stated in the Introduction, is to help beginners understand how programming languages and compilers work. Python is an excellent language to this purpose, especially if it is the language you feel the most comfortable. I understand the importance of doing a compiler that has a good performance in all aspects, but it was not my goal to get there on this post. Nevertheless, thank you for your feedback
It seems to have a better API, especially for interactive and web based graphs.
Are you thinking of this? https://en.wikipedia.org/wiki/Parody_generator
**Parody generator** Parody generators are computer programs which generate text that is syntactically correct, but usually meaningless, often in the style of a technical paper or a particular writer. They are also called travesty generators and random text generators. Their purpose is often satirical, intending to show that there is little difference between the generated text and real examples. Many work by using techniques such as Markov chains to reprocess real text examples; alternatively, they may be hand-coded, like Chomskybot. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
##r/programming --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
Python 3 has renamed raw_input to just input. So change raw_input to input :) 
Are you using Python 3 ? The image from the guide has the code in python 2. raw_input() was used in python 2 in python 3 it's just input(). 
Try using `input()` instead of `raw_input()`. My guess from a quick Google search is that the guide you're following uses Python 2.X, whereas you are probably using Python 3. [This](https://docs.python.org/3/whatsnew/3.0.html) is a list of differences between the two of them. Another option is to use Python 2.X instead of Python 3. Also, as a general tip, when you get an error, Google "python" plus the error. In this case, I googled "python raw\_input not defined", and got a good result immediately.
Yeah I could find either for free, but still wondering what one I should invest my time in.
I wasn't talking about unit testing view functions I don't think. Throughout your application you're bound to have actual logic in non-view functions that interact with the current app or request: decorators, response helpers (pagination, sorting, etc).
Yeah I can understand not wanting to migrate an existing project (although whiners like to make this out to be more difficult than it actually is), but there is no excuse for starting a *new* project in 2.
Can it tell which one's are good boys?
With python 3, you need to write `print("string")` , in python 2 it is just `print string.`
Thank your for your work on this. And for your aplomb, often all too lacking in this sub. 
If I were interviewing you, most of these books wouldn‚Äôt help, because I would be more interested in how you structure code, how you break big problems into small problems, how you work within a team, and how you use available resources to rapidly solve problems. I am far less interested or inclined to find out how well you understand data structures and algorithms because those skills are less of a priority for me when I have a set of features that need to be done by the end of the quarter. Because of that focus, I am far more interested in seeing verifiable experience. That could be anything, but a highly active github profile really helps in the absence of actual work experience. Every school project you complete or personal project you do should be public.
Send me the link for the Elements one please. 
Uhhhh...what does \`curl\` not cover?
&gt; decorators, response helpers (pagination, sorting, etc) These are things I would handle in my view function `view.build(country, page=2, sort_asc=foo)`. They're not things I'd let Flask worry about. &gt; The act of getting to a view functions usually means going through layers of flask middleware Maybe? I think that depends on whether you choose to put them in Flask middleware or not. On that example I sent you, I don't have any middleware except for a handler that records metrics for me. But my point is that these things are mostly irrelevant to the problem you're actually solving, and are usually handled by a library for you, so all you need is an acceptance test that demonstrates they're hooked up. If you've added @requires_role(admin) to a handler, you need to unit test that fact. What is that buying you? A single acceptance test for "When a user is not authenticated" or "When a user does not have admin rights" is sufficient to demonstrate the functionality. If you've written, for example, complex logic for mapping from exception types to status codes then I might unit test that, and so I either: a) wouldn't build it into a flask decorator b) would test it by decorating a stub function that throws an exception. def my_fancy_decorator(f): try: f() exception: # return some Response pass @my_fancy_decorator def throws(ex): raise exc def test_not_found_exception(): resp = throws(NotFoundException()) assert resp.status_code == 404 &gt; which increases the likelihood your test will fail for other reasons - making view function testing fall into either integration or end to end testing. This I *definitely* disagree with. I can test my view to ensure that it gives me back the correct data given some input, and I can test that without ever referring to Flask. The whole point of using middleware is that I can treat it as an orthogonal concern: I can test it once, and then be happy that it'll work the same way applied to multiple parts of my app. I still need a single acceptance test per feature that does the happy path, and probably a few acceptance tests to demonstrate the existence of authentication and exception handling code, but the rest can happen outside of Flask. For what it's worth, I think this is my biggest disagreement with Harry's approach. We have a different understanding of the term "outside-in testing" and the importance of [subcutaneous tests](https://lostechies.com/jimmybogard/2010/08/25/an-effective-testing-strategy/)
So you're saying I could pass your interview knowing all that but unable to code up a solution? Big 4 would most definitely require you to be able to code up a decent solution. And I'm looking for a book I can use to master this skill using python.
No one said faster-- but in 37 it is still ~30% worse than 2.7.
As a hiring manager: THIS.
Nope, it looks fine. You are probably choosing a timestep small enough that the energy is conserved at the pixel level for the total time of your simulation. Nice job with the plots!
Nice! I'm a structural engineer too. I'm working in a Python library for calculate the wind pressures according to my national code, which is based on ASCE 7-05
I think goto line is by default control-G
Yes! The existing `plotly.offline.plot` and `plotly.offline.iplot` functions, and the new `FigureWidget` class are totally offline and self contained (No internet connection or plot.ly account needed). The plotly.py Python library is totally open source and it ships with a bundled version of the plotly.js library which is also totally open source. And now, with orca, you can also export high-quality static images fully offline. The only time you're interacting with the plot.ly servers is when you're using the functions in the `plotly.plotly` package.
Cool! Once you get settled in, feel free to DM me on the APL side so we can grab lunch or something.
There‚Äôs also [pyenv](https://github.com/pyenv/pyenv/), which is what asdf uses for Python. 
If you're interested in this topic, you might also like to check out [From NAND to Tetris](https://www.nand2tetris.org). I learned a lot from the companion book last summer.
What other methods are there?
Thanks! 
&gt; We might add a database-level trigger, but since we have a modern Django application and don‚Äôt want to mess with SQL, let‚Äôs leverage Django built-in signal system: There's a lot of good reasons to avoid a trigger in this contrived example but "ew yuck sql" isn't a very good one. If you can guarantee you only support one database, e. g. only postgres, a trigger would absolutely be the correct thing to do. But if you can't, using signals is probably preferable to writing either a trigger that's agnostic or writing one for each db only to get a big report that someone was using your app with a db you forgot to support. Also, pulling your objects into memory to only save them is a petty janky way of doing the update. Why not write an update query? Again, "gross raw sql" isn't a great reason. You don't even need to write raw sql because django allows bulk updates via objects.all().update(...), no save or signal is emitted so it's more efficient. And I know this is a contrived example, but first + last name into fullname irks me because names are way more complicated than that. 
https://github.com/PonyGE/PonyGE2/wiki Seems a good place to start.
There's not something exactly like `imshow`, but here's what you can do: 1. If the 'pixels' of your image are just scalars that should be converted to colors based on a colormap you can use a [heatmap](https://plot.ly/python/heatmaps/) trace type. 2. If your image is a general RGB(A) image, then you can convert it to a [PIL image](https://pillow.readthedocs.io/en/5.1.x/reference/Image.html) and set it as a background image for a set of axis ([https://plot.ly/python/images/](https://plot.ly/python/images/)). This is actually how the DataShader example from the announcement post works. Looks like reversing axes in 3D is still an open issue: [https://github.com/plotly/plotly.js/issues/1940](https://github.com/plotly/plotly.js/issues/1940)
Thanks for the comment and thorough reading. I agree, things can be made more optimal. I tried to keep details short and simple mainly not to distract from the subject. Also I picked the full name example because it's discussed in Django documentation. It has a side note about name diversity and that first and last name is not the best choice. That's why we are doing migration in the first place. 
Working with simple virtualenvs and pipenv mostly
python is slow and it't an advanced lang,how slow it will be if you write a lang with python?
yes, read that recently so am planning on getting up to speed on Python 3.x.
People just dismiss the LICENSE as some mumbo jumbo, where it clearly mentions that the software is provided "as is". &gt;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. Nevertheless, such retorts are a common strategy among newbies to Linux world to solve an issue. Just say "Linux sucks" and get your wifi modem fixed.
thanks for the link
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
"When they ran the resulting code, they found it was 40% faster and used half the memory." Can we put to bed the "but Python 2 is faster than Python 3" myth yet? This is reasonably in line with my experience with our work codebase. The change to dictionaries and string encoding both seem to have helped, though I've not done any deep investigation on it. I certainly see microbenchmarks where Py2 is faster, but on large codebases doing actual work it seems to be a pretty big win overall.
Need to have location included, please.
I drop a compromised `ls` executable in your path and now i'm running with the privileges of your script or server. At the very minimum you want hardcoded paths for executables you invoke. &gt; definitely not suggesting anyone hook this up to a webapp. Yeah well, you know how it is -- people will google and copypaste, likely not reading the rest of the thread. You should have put a disclaimer of sort, at the very minimum.
I work with ASCE 7 also, have a snow drift script on there its in early stages as I was testing out some things but it essentially takes a set of lines with exterior/interior designations and defined projection heights and performs the windward drift against a projection calc and generates a DXF file of the results. 
So write your own numpy from scratch if you think it detracts more than it adds. Otherwise, please understand that bugs occur in all software, and channels are provided to report those bugs and patch them. Calling the software and it‚Äôs developers idiots and treating people poorly make you look like an ignorant asshole.
Roughly speaking [altair](https://altair-viz.github.io/) is to the [Vega-Lite] JavaScript library what plotly.py is the the plotly.js JavaScript library. Both plotly.py and altair are Python wrappers that build up declarative JSON-specifications of plots, that are then displayed by their respective JavaScript libraries. Thanks to all of the work that's gone into Vega-Lite, it's possible to construct pretty interesting interactive visualizations based on a declarative specification (See https://altair-viz.github.io/user_guide/selections.html). The declarative specification of interactivity is nice because it's totally self-contained and can be embedded without a Python back-end. But if I understand correctly, it's not possible to bring these interactions back to the Python side. For example, I don't think it's possible to run arbitrary Python code on the selected points and then update the plot based on the results of the calculations. Also, it looks like there was some work on a webgl backend for Vega-Lite a few years ago (https://github.com/vega/vega-webgl-renderer), but it sounds like it's not under active development at the moment (see https://github.com/jupyterlab/jupyterlab/issues/4586#issuecomment-391061432). So, at a high level, I think plotly.py 3.0.0 has an edge when it comes to ad-hoc Python-driven interactivity, large dataset support, and the breadth of predefined visualization types. And I think Altair has an edge when it comes to using Python to create fully client-side interactive statistical visualizations of small to moderate sized datasets. 
I'm struggling to think about a language worse than Python for writing compilers. There's absolutely nothing in Python that makes work of someone writing a compiler a nice experience. It has no matching mechanism, no good way of working with text or streams of text, no good way of dealing with binary data, or graphs. It's terribly slow and in its own design is very defective and inconsistent. All this put together creates a very bad precedent. But, people who will read your post will be the same people implementing another garbage languages like Protobuf or Thrift, and then these languages will get accepted by the larger community just the same way Protobuf or Thrift were. And the dark ages of programming will continue.
Thanks! The two-way interactivity was definitely one of the most challenging areas to get right. I'm hoping that we're reaching a point where adding ad-hoc interactivity and linking between visualizations is just a normal part of the exploratory data analysis workflow (not a separate software development task).
Releasing sub-par software is treating *users* poorly, and makes idiotic developers look like ignorant jerks. Please understand that I have been developing software since 1980, and that inept programmers and their sycophantic fanboys are the only people who invoke the excuse "please understand that bugs occur in all software". "So write your own numpy from scratch if you think it detracts more than it adds." Okay, or maybe I'll criticize bad software on reddit, despite the outcry from inept programmers.
Thanks! I hope it's fun to work with for you once you find that use case :-)
Your argument that any imperfection is a form if abuse is frankly ridiculous. Pointing out a bug and criticizing it is fine, but berating people is not. You have multiple options, but you chose to pursue and defend the least productive and meanest one. Live how you want, but you are embarrassing yourself whether you realize it or not.
Totally agree. Thanks to the [orca team](https://github.com/plotly/orca/graphs/contributors) we're closing in on the point where saving static images (both raster and vector) will finally be as easy and reliable as it is with matplotlib. It's just remarkable how much more complicated it is to get this right with a JavaScript-based visualization library! 
This isn't as much about virtualenv/pipenv as setup,py, setup.cfg, requirements.txt, etc. Yes, it does create a virtualenv for several aspects of it but that is to meet the overall unified approach to creating packages that this provides.
"is not... fine" Who cares what you think is fine and what you think is not fine, and why do they care? I don't If you want a safe-space where you can release crap software without being criticized, make a safe-space; but the internet is not your safe-space, sowflake.
Thanks! But don't forget to respect your elders :-). Python probably wouldn't have gotten off the ground as a data science language in the first place without it!
Hey, check how to format your code on reddit or use service like [https://gist.github.com/](https://gist.github.com/). Can you quickly explain me how if / else statement work ? And how indentation affect it ? 
Thanks! But don't forget to respect your elders :-). Python probably wouldn't have gotten off the ground as a data science language in the first place without it!
Is virtualenv no longer the recommended python virtual environment tool? Not being smart, legitimately curious
Thanks very much. I have done too much bug-reporting (other products) recently, and need to spend less time doing that if I'm to produce anything.
You deluded psycho, I am no "newbie to Linux world"; look at you lying to yourself because you can't cope with reality. Why are you babbling about the license? The copyright holders reserve the right to be idiotic and to release idiotic software, but what so what, how is that relevant to this thread?
It‚Äôs not my software, and I‚Äôm fine with criticism about my work. However, I strongly believe that it is better for everyone who in the community if we treat each other respectfully. You‚Äôve been really rude to people who created software that you are apparently using/benefitting from, and it shouldn‚Äôt go unchallenged. It‚Äôs simply unproductive. No one will want to publish OSS software if all they can expect as a result is to be called idiots just because of a minor bug. But your software never has bugs... so you know better, I guess. My software does have bugs which I work through gradually over time, so I sympathize with the creators of numpy who generally seem like very nice people.
This was awesome - thanks for sharing!
Yes, but I was used to this other binding so I spent one year hitting cmd+l and cursing, so this new keybinding it was a great gain in productivity for me :)
&gt; init no longer adds pytest to development dependencies. Seems like adding pytest is a nice default and tried to find out more but [the commit](https://github.com/sdispater/poetry/commit/8c3d49f5e0f88f16696bce04b7fb9d4e72969385) doesn't give a reason.
[removed]
The code I have so far is just too messy, that's all. It's one of several fun-projects I've been playing with lately, so I haven't put too much time into it. One site where you can learn a bit about simulating celestial mechanics is [The Art of Computational Science](http://www.artcompsci.org/index.html).
&gt; how slow it will be if you write a lang with python? Ask PyPy.
Pycharm Pro &gt;&gt;&gt;&gt;&gt;&gt; .... &gt;&gt;&gt;&gt; everything else... It's not even close honestly
&gt; No one will want to publish OSS software if all they can expect as a result is to be called idiots just because of a minor bug. No one will want to use OSS software is all they can expect is idiotic software. You would turn OSS into a welfare program for unfit programmers, a safe-space where they can pretend they don't suck; but that wouldn't be as good for the community as you dream, snowflake. My software has occasional bugs, snowflake, and when it does, I don't pause to tell my clients "all software has bugs" because I am too busy fixing the bugs.
And you honestly believe that insulting the developers on reddit is a more effective solution than filing a bug report? What‚Äôs with all of this popular political terminology, anyway? You seem distracted by your blinding anger towards everyone.
Get fucked 
Ohhhh, I'm so sorry. I misunderstood _The code isn't yet in a state such that I would show it around, though._ to mean _my_ code isn't in a state to show around. I am so sorry.
&gt; And you honestly believe that insulting the developers on reddit is a more effective solution than filing a bug report? Definitely we need to do a better job discouraging bad programmers from releasing software. They could post bad songs on SoundCloud instead if they really need a place to put their name on the internet; at least then they would waste so much of people's time because it's easier to turn off a bad song then to back out of using bad software.
if you want to do that with python may be look for a little Flask tutorial to get you started. Ask google something like : flask tutorial blog Of course, get away from tutorial as soon as possible as they are not that efficient at teaching you anything but can be a good start with a new tech.
Ha, you are a piece of work. I think you are wrong about this, but have decided that I like you. Not that it matters. Nothing matters. Who cares? Not me.
I appreciate the detailed explanation! Definitely something I‚Äôll look more into 
Thank you very much!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
Hi there, from the /r/Python mods. We have removed this post as it is not suited to the /r/Python subreddit proper, however it should be very appropriate for our sister subreddit /r/LearnPython or for the r/Python discord: https://discord.gg/3Abzge7. The reason for the removal is that /r/Python is dedicated to discussion of Python news, projects, uses and debates. It is not designed to act as Q&amp;A or FAQ board. The regular community is not a fan of "how do I..." questions, so you will not get the best responses over here. On /r/LearnPython the community and the r/Python discord are actively expecting questions and are looking to help. You can expect far more understanding, encouraging and insightful responses over there. **No matter what level of question you have, if you are looking for help with Python, you should get good answers**. Make sure to check out the rules for both places. Warm regards, and best of luck with your Pythoneering!
I've been using plotly at APL for about 2 years now, but have faced a lot of pushback. My plots never get put in sponsor briefs anymore and people always ask for the raw data instead so they can recreate my plots in matlab. What has your experience been?
Personally I don't like the idea of such a default, some setups integrate nicer with other test suites.
That's pretty amazing!
Python is being used to translate the original code into a native binary. The performance of the binary depends on how sophisticated the translation is. While the speed of Python execution can affect how much time is allotted for the translation step, the performance of the implemented language doesn't depend on the performance of Python.
My [workaround](https://community.plot.ly/t/use-plotly-offline-to-save-chart-as-image-file/408/25) for that was to use selenium, but it is very inefficient.
I am so excited and can't wait to start using data classes.
Has there been any progress on fixing polar plots? Thats the one thing that I still use matplotlib for. The last time I tried to make a polar plot with plotly it was completely broken. 
looks nice! Just wondering how it compares to [http://docs.python-cerberus.org/en/stable/](http://docs.python-cerberus.org/en/stable/) which I have been using for a long time
Thank you! I will post to learn python asap
I'm not sure specifically, but the Plotly.js team is continually fixing bugs as they crop up (and as they have time) across the various trace type. FWIW, all of these examples are generated by the current Python/JavaScript libraries: https://plot.ly/python/polar-chart/ 
My experiencing trying to do this with Selenium is exactly why I called out "easy" and "reliable" above :-)
My eyes hurt when looking at that image. The design is so poor. That aside, you could try something with computer vision and combine it with basic CRUD. For example having an app that recognizes objects in photos. Hope that is not too basic. 
dedication
Oh cool! In my experience the main concern is usually visual consistency within an analysis product. It is unnecessarily jarring to an audience if you see different plot themes at different points throughout a presentation. And since every plotting library defines its own theme, people tend to assume that consistency means using the same library for everything. But styling in plotly is really flexible. Fonts, background colors, grid colors, default line colors, and colorscales are all configurable. So with a little extra effort, and attention to detail, it should be possible to mimic the styling of the visualizations in use by the rest of the team.
I usually manage like 50 lines. After that its more then one screen can fit, so I start to panic and I usually abandon the project afterwards.
I'm so pumped about this!
Stupid question - is the use case for this similar to structs (as in in C#)?
Pytest is still added by default if you create a new project with `poetry new`, but the idea of `poetry init` is that you already have a project and only want to add the `pyproject.toml`.
Oh, didn't notice the distinction between `poetry init` and `poetry new`, thanks!
&gt; Does Python already do this behind the scenes? Yes, it does. In [1]: a = '' In [2]: b = '' In [3]: a is b Out[3]: True 
Pipenv is just a dependency manager, it doesn't help with packaging. Poetry uses pyproject.toml, the new standard defined in PEP 517 and 518, an alternative to setup.py, requirements.txt, Pipfile, etc. Poetry can build sdists and wheels for you, as well as publish to pypi with a simple command. Similar to Pipenv, it also manages dependencies, virtual environments and features a lock file to ensure reproducibility.
...and all the other similar libraries (marshsmallow, voluptuous, schema, etc.)
This guy gets it. 
Seems like it'd be a bit light on content. I usually go to conferences for new developments or really deep dives into things I can't find out from just reading docs
TIL, thanks. This is definitely becoming one of my favorite languages to work with. In fact, now I'm wondering why C# doesn't just handle that behind the scenes ü§î.
Thx buddy for your suggestion 
Python dictionaries, and JSON itself, really, don't guarantee any specific order.
So there is no way to manipulate the order ?
I write some benchmark cases in [https://github.com/guyskk/validr/tree/master/benchmark](https://github.com/guyskk/validr/tree/master/benchmark). Could you create a PR for cerberus case?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [guyskk/validr/.../**benchmark** (master ‚Üí 1bcced6)](https://github.com/guyskk/validr/tree/1bcced669a28834455cd75ae7c558e113ad92ff8/benchmark) ---- 
You could use an `OrderedDict`, and the builtin `json` module _should_ do the right thing. However, that is in no way specified anywhere, and neither is the order on the reading side.
def is\_good\_boy(doggo): if doggo: return True else: raise Exception('Bamboozled!')
I write some benchmark cases in [https://github.com/guyskk/validr/tree/master/benchmark](https://github.com/guyskk/validr/tree/master/benchmark). Could you create a PR for cerberus case?