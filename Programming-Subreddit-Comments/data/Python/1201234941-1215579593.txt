Definitely some nice puzzles in this. I haven't looked at it in a long time, I think I got somewhere in the high teens or so.
after login, and downleaded …… Oct. 2007
[planet.python](http://planet.python.org/) [planetpython](http://planetpython.org/) huh
OH RLY? is this the python homepage. wow i'd never have found it if it wasn't posted here.
Yeah, I think only the first issue is available for free. But it looks like you should be able to buy the current version for $7.
wouldn't Template(template).safe_substitute(locals()) Do the same thing but with less mucking about in the stack?
OMG! Thanks Python reddit!
Ewww. Or we could just use PHP (shudder). Using normal string replacement is better because it allows you to know that the variable will be outputted as a integer, float, string, or what have you. 
I'm looking for something like [Raganwald](http://weblog.raganwald.com), for python.
planetpython.org (whoops, originally typed planetpyhon.org) aggregates many python bloggers, you might find someone you like there
Why reinvent the wheel? [workinenv.py](http://pypi.python.org/pypi/workingenv.py) already does this for you....
Have you seen my husband's blog? It's "Planet Py, hon".
thanks :) corrected above.
[B-list](http://www.b-list.org/) is a good Django blog, so it includes Python from time to time. 
blogspam
These are the ones I subscribe to (YMMV): * [http://diveintomark.org/](http://diveintomark.org/) * [http://blog.ianbicking.org](http://blog.ianbicking.org) * [http://www.willmcgugan.com](http://www.willmcgugan.com) * [http://adam.gomaa.us/blog/](http://adam.gomaa.us/blog/) * [http://compoundthinking.com/blog](http://compoundthinking.com/blog) * [http://pyside.blogspot.com/](http://pyside.blogspot.com/) 
Umm, this is a fair assessment, I guess... Tho I would state you should choose Python if: * you want rapid development - Python is a very high-level language * you want a low learning curve for new programmers - Python's clean design and small syntax makes it very easy to learn * you want wide deployment - Python is cross-platform * you're cheap - Python is open-source * you do mostly scripting/glue work * you want a language that will handle a wide array of tasks * you use COM - Python supports COM better than C# or Java (it's equal to VB.NET) * you want to keep your programmers happy - it lets them explore the functional paradigm, play with awesome introspection, and enjoy high flexibility
[Workingenv is dead, long live Virtualenv!](http://blog.ianbicking.org/2007/10/10/workingenv-is-dead-long-live-virtualenv/) I never knew people felt so strongly about the case of their directory names.
[here's](http://dpaste.com/36415/) my python OPML.
Skype is spyware !
Finally, a way to automate my crank calls.
Those are good recommendations, but it should be pointed out that Mark Pilgrim (diveintomark) hasn't written anything about Python on his blog in some time. His blog is still great, and often hilarious, though, so go read it anyway :) 
Well, this more of a Python memcoder wrapper.. It seems like it'll work with anything memcoder can read.. If memcoder can re-encode the file, chances are mplayer is capable of playing the file..
Do as I say, not as I do.
Have you totally missed the point? He's not saying never have API incompatibly. That would be silly. He's just saying to avoid doing this at the same time as switching to Python 3000.
Lighten up. I was making a joke.
Try to be funnier next time. :-)
What can I say? I managed to amuse my own most enchanted reader...
Disadvantages of python: it requires a fairly powerful system - it won't run on some embedded systems. It is also slow, but I hesitate to mention this because almost everyone can say that the cost to develop in something fast (C) far exceedes the cost to develop in python and buy more/faster computers. However this is a valid point that may apply to your case.
Biggest disadvantage I've found so far is it's not installed everywhere. I want to run it on an AIX system, but the admin won't install it. I'm stuck with Perl or shell scripting. Also, I tried writing a GUI app using TkInter for Windows Mobile. Although there is a TkInter port for the platform, it ran absolutely horribly. Performance of TkInter on WinMobile is pathetic.
Mac only. Requires installation of external library (NodeBox).
Installing said external library (NodeBox) will make your life better, too.
I'm tempted to rewrite this in pygame when I get home, though I have some other stuff I want to do too.
I'd love to see that.
[Here](http://www.ironboundsoftware.com/blog/2007/09/09/pyglet/) is a version of pong for [pyglet](http://www.pyglet.org/), which will run on any (most) platform. 
I wrote one of these in Flash in the early '00s in less lines of code :) But enough cockiness. The thing I wanted to mention was my "AI." I simply had the paddle move linearly toward whatever the ball's height was per frame, but *only* when the ball was moving toward the enemy. That added in enough delay for the fairly fast-moving ball to sneak past it if you angled your shots right. The thing that baffled me was how many people¹ were really impressed by how difficult, and intelligent the opponent seemed. ¹everyone I showed it to (like, 3 people, in all)
Nice. I am beginning a Data Mining course and am free to use Matlab or whatever scripts I want. Go fuck yourself, Matlab. It's 2008 - I can work at home now.
MATLAB is the worst mathematical software I have ever used. I had to use it last semester, but it was so frustrating to use that I stopped turning in the work. I nearly failed... :)
It's not that bad, especially the huge library they have. On the other hand, python is a far better language, and it's free. I think scipy is enough for 98% of people.
Why in the world can't you copy/paste code in the MATLAB editor with Ctrl+c/Ctrl+x/Ctrl+v ? No, you need to memorize everything new. It's Alt+w, stuff like that... Arg! 
Yeah, the matlab editor really sucks, especially on Unix.
Anyone know much about how Octave compares to it?
File -&gt; Preferences -&gt; Keyboard Change "Command Window key bindings" and "Editor/Debugger key bindings" from "Emacs" to "Windows".
"Loading..." What's that about? The site is broken. Working now. It was just the advertisement in the middle of the page that was broken, but that thing is so huge, it looked like it might have been a key piece of content. 
That's so weird . . . downforeveryoneorjustme.com confirms that the site is down, but somehow I can read it even after clearing the browser cache.
Uhm, instead of "My Personal Coding Standard" - how about linking the official one instead: [PEP 8 - Style Guide for Python Code](http://www.python.org/dev/peps/pep-0008/)
Yeah, and PEP 8 has way fewer ads.
He does link to PEP 8 in there, this is what he uses above and beyond it.
my bookmarks: * http://wordaligned.org/ * http://thinkpython.blogspot.com/ * http://www.eflorenzano.com/blog/ * http://livingcode.org/
best generator tutorial ever!
This is awesome. There is a lot in it, even for long time pythonistas. I believe that a lot of people already are using these patterns, but not with the beauty and consistency you can find in these slides. Must read for people interested in python!
I &lt;3 Python.
&gt; There is a funny comic about this very subject of "how easy Python is," by "xkcd" that I have included in the Resources. Do I need to add anything to this?
Well, this article only affirms what so many have told me before...Python is just killer for rapid web application development. What if there's some secret disadvantage to it...like, "It will serve 10000 pages an hour with no issues, but at 4:15 one page will always reveal every administrator password on your computer"...there would have to be a flaw on that scale to talk me out of using it. ;)
The biggest win of python : you can replace part of your app with another language. So choosing python is a very safe bet : it choosing the capacity to choose another language (c++) for a specific part that's may need it. Even for a big app, you want to start with python because you will have results quickly and later on replace the modules that are performance bottlenecks. In the end, in the worst case, maybe 80% of your app will be in C/C++/whatever and you will have a smooth dev cycle. have an apple and eat it, sort of. :)
Also interesting to note is [Kay showing how easy this is in EasyExtend](http://reddit.com/info/6duwf/comments/c03kqsz) over on programming.reddit.
Twine.com is a beta site that allows you to organize and share various sorts of information. I just got an invite and created a public twine for Python-related junk. Nothing much there yet, but you can join up and change that! I am not affilaited with twine in any way, but I do have a few invites if anyone is interested. Send an email to my username at gmail.
Agreed, NodeBox is like nerd candy.
That was nice, but for 5, Python favors using verbose syntax than one-liners that demand lengthy explanations (and you'd have to explain what that does in a comment, so you don't really gain a line)... The correct one-liner would be: return reversed(my_list) EDIT: Edited for mistakes.
&gt; return sorted(my_list, reverse=True) That sorts the list in reverse order. To reverse it, you would use `reversed(my_list)`.
That returns a listreverseiterator object. It's more or less equivalent, though not exactly, that's why I went with reverse sorted.
As I'm reading the list, I'm wondering "what's wrong with these examples?" I guess I misinterpreted "problems." *I have a problem with the poster.*
And if you want to return an actual list, rather than an iterator then you should use: return list(reversed(l))
&gt; that's why I went with reverse sorted. Reverse sorting does something entirely different: &gt;&gt;&gt; ''.join(reversed('abracadabra')) 'arbadacarba' &gt;&gt;&gt; ''.join(sorted('abracadabra', reverse=True)) 'rrdcbbaaaaa'
Ok, it was maybe a poor choice of title. The intended meaning was: the blogger solved the first ten of the (famous) [99 Prolog problems](https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/) in Python.
Oh, I'm sorry, I thought he already had a sorted list he was trying to reverse, I didn't realize he just wanted to reverse an arbitrarily-ordered list. You are, of course, correct.
Yeah, I thought bitches would be one.
Itertools for the win, natch: &gt;&gt;&gt; from itertools import groupby &gt;&gt;&gt; [list(g) for v,g in groupby([1,2,3,3,3,3,4,4,4,4,4,4,5,5,5])] [[1], [2], [3, 3, 3, 3], [4, 4, 4, 4, 4, 4], [5, 5, 5]] for problem 9, and for problem 10: &gt;&gt;&gt; [[len(list(g)), v] for v,g in groupby([1,2,3,3,3,3,4,4,4,4,4,4,5,5,5])] [[1, 1], [1, 2], [4, 3], [6, 4], [3, 5]] 
I like Python quite a bit, but I'm struck by how reminiscent the arguments against Ruby's dynamic behavior are to the justifications for Java vs. languages like Python. In both cases the justification often articulated is that "programmers will screw it up" if more power is provided. One would think that a good set of tests would pretty well minimize this problem.
Brilliantly reasoned. Of course I would think that since the thoughts expressed match my own to a remarkable degree. 
But a bitch ain't one.
I'm not saying it changes very much, but this post is getting close to 5 years old.
Most of it is still highly relevant. Example: &gt; In Ruby (like in Pascal), to call a function WITH arguments you pass the args (normally in parentheses, though that is not invariably the case) -- BUT if the function takes no args then simply mentioning the function implicitly calls it. […] to me, it means the mere mention of an object may EITHER mean a reference to the object, OR a call to the object, depending on the object's type -- and in those cases where I can't get a reference to the object by merely mentioning it I will need to use explicit "give me a reference to this, DON'T call it!" operators that aren't needed otherwise. I feel this impacts the "first-classness" of functions (or methods, or other callable objects) and the possibility of interchanging objects smoothly. This is the single Ruby design decision that is most head-scratchingly bizarre to me. It's impossible to determine, from visual inspection, whether a fragment of code represents a reference or a call. Syntactically, this is a win for people looking to make Ruby-based DSLs, but semantically this just blows the back of my head straight off. (Tied into this is the odd non-interchangeability of blocks and Procs, but that's a less pressing complaint, and besides, Python sucks eggs when it comes to ad-hoc creation of anonymous bits of code, so perhaps this is a win for Ruby anyway.)
Silly me. Anything written that long ago could not have a shred of timeless analytical value. Who are these idiots reading Plato and Socrates? Those useless writings are WAY past 5 years old LOL!!
There's no reason why you can't adopt the style of always including parens, even for arg-less method calls. It doesn't help with libs and won't alleviate `method(:foo)` woes, but at least nothing is ambiguous. I like both Python and Ruby. Ruby feels more Lispy and I like that a bit more, but this is one decision I think Python got very right. It's consistent and obvious that a variable holding a function is treated like any other variable, except it can be called via special syntax.
Agreed. Though Python strikes a pretty good balance between power and rope.
I can't wait for python 3 to be released! If only for the new division operator.
Enhanced tuple unpacking! I've wanted that for so long.
Yhg1s of #python on freenode deserves an award, too. I don't know how many of my questions he has answered, but *a lot*. He's always there and always helpful! Great guy.
from ____future____ import division / i have no idea how to make that not bold
Try 4 spaces at the beginning of the line: from _future_ import division
That would be \_\_future\_\_ (backslashes are the key)
Yeah I know but putting that on top of every single file I create gets old real quick :)
Or `backticks` for inline `codification`.
 python -Q new
Sadly, I have no clue how he's doing it :/ Anyone care to explain?
EDIT: Ignore my reply below. I read it as "I have no idea _what_ he's doing," not "_how_ he's doing it." Yeah, me either, in detail, but the basic part is that he's setting up a class that works with the new `with` statement and to make it steal values from the one namespace and drop new ones into the other he uses `sys._frame` to manipulate the stack. /EDIT ---- You can ignore the first part. It's a recipe that makes this work: class AAA: _v = 1 with property as v: doc = "Example of making property with *with* statement" def get(self): return self._v def set(self, v): self._v = v Normally, this would be written as: class AAA: _v = 1 def _vget(self): return self._v def _vset(self, v): self._v = v def _vdel(self): del self._v v = property(_vget, _vset, _vdel, "Ordinary property.") In either case, it's used like this: &gt;&gt;&gt; a = AAA() &gt;&gt;&gt; a.v 1 &gt;&gt;&gt; a.v = 2 &gt;&gt;&gt; a.v 2 That is, it looks like you're just setting and getting an ordinary property, but really, you're going through the setter and getter functions, so if you want to add sanity checks or transformations or more side effects, it can be done that way. For example, your class might store distances in centimeters internally, but still have a `.inches` attribute that can be used as though it were the real property. 
There are getter() and setter() methods that do that (or something, I'm not sure that that's it exactly, but I know they're in python 2.5), aren't there?
Yeah, the latter example works in Python 2.5 today, and people have come up with a lot of different shortcut methods to make writing properties easier. Internally, any time you try to use or change an attribute that has its own `__get__` and `__set__` methods, those are used instead. `property` is a built in class that creates an object with the hidden methods set to whatever methods you pass it.
I like the method described in the [response](http://mail.python.org/pipermail/python-3000/2008-April/012938.html) better. ie. class Test: @property def foo(self): return self._foo @foo.setter def foo(self, val): self._foo=val property objects in 2.6 get convenience functions that set their accessor functions.
When you enter the with block, it's assigning the context object (the "v" in the "with property as v") to a sentinel value (the "null" object) that it can recognise later. Then, when exiting the block, it gets the locals for the class's frame object. It searches through these for the sentinel, and get the name of the variable. This lets it find out what you called it so it can use that name as the name of the property. After that, its just a matter of grabbing the get/set/del functions from locals and assigning the property accessors to them. It then removes these temp functions from locals (so the class syntax doesn't get the accessor functions added to its interface), and then re-adds them renamed to _getVar() etc (this isn't actually necessary, I'm guessing he just wants the raw accessor functions to be available for completeness). Finally, the variable name in locals gets assigned to the new property object. 
Oh, thanks a lot for the explanation, it cleared things up.
Click the star to the left of the name to mark this feature as important to you.
Would indeed be cool to compare them (same goes for pyglet, which seems like the next-gen version of pygame, from what I've read).
Thanks a lot, came here hoping to see something like this :)
It'd be a harder opponent if it moved back to the middle when the ball wasn't moving towards it.
Uh yeah, just improve Capistrano if it doesn't do what you need it to. It's great, who cares if it's not in Python? Annoying to install another language? On the two platforms I use the install process is: nothing because it's already there and sudo apt-get install ruby. I'm not sure it can get much less annoying.
Yeah, our Capistrano knock-off is Capistrano, case closed.
http://rubyhitsquad.com/Vlad_the_Deployer.html ? Not python, but not Capistrano, either. And the name is cool.
Too hacky. sys._getframe, bah.
Is it fair to downmod for excessive use of Comic Sans?
absolutely not :)
You require additional pylons.
As much as the "egg" and setuptools thing is cool, RPM is still the way to go if you're going to deploy a package on multiple machines. So, I made some RPMs for [pylons](http://pylonshq.com) to make it easier to deploy it and, hopefully, get it included in future Fedora and RHEL version.
(Ruby on Rails player) Our base in under attack!
\*boobityboo: You must construct near a pylon.\*
I didn't catch that; thanks :)
At least it allows you to put something else than American Ascii in a source file. Believe me, this is a great win if you come from an non US speaking country. Now if everybody starts using UTF-8, it will not be needed anymore.
&gt; this is a great win if you come from an non US speaking country. Oh like there are any.
Not sure why this is supposed to be useful. I find **this** useful: &gt; bash$ diff &lt;(ls -1 dir1) &lt;(ls -1 dir2) which diffs the listing of two directories. 
Does that create a diff of file contents also?
meld dir1 dir2 is even more useful.
No, just the names. This does that: &gt; diff -r dir1 dir2 
Up-modded for the reference to "Spinal Tap" in the email. Oh, and because it's a good article. That, too.
I'll have you know that in the state of Canada, they speak Quebecese.
From the views.py: &gt; to anyone reading this code &gt; i apologize &gt; for some dumb reason i was trying to make all of these functions &gt; lisp-like &gt; or something... i was just having fun! Pretty good.
While you can summarize most of the article with: "Use optparse for scripts", I will say that the fact that I read so many blog posts wherein people detail some script who don't makes this an extremely valid and pertinent article. Seriously, if you're going to write a shell script and hope that other people use it, it needs to act like any other (decent) shell script and respond to -h and/or --help.
Djildo: Open Source Django Web App For Playing With Yourself
Yeah I had to blink a few times before I read it correctly.
The people they chose to interview for this article is based solely on their surnames.
Why?
because maybe you don't have access to apache or aren't allowed to run mod_python or mod_wsgi... etc... this allows for a pure python hosting of not only the python parts but also the admin media static files as well.
Doesn't "manage.py runserver" do this exact thing?
Only one request at a time. Its not threaded.
So CherryPy is for production? Can it really compete with Apache/etc?
[CherryPy is good for low to medium traffic (with far less memory) while Apache scales better for higher traffic.](http://lincolnloop.com/blog/2008/mar/25/serving-django-cherrypy/)
&gt;Bluebird: Do you see any major change in the future of Python ? I think with 2.2, now we've reached some stable state. &gt; &gt;Guido: Python will always grow and change, but it's a very evolutionary grow. We have added a whole bunch of feature to 2.2, but we've done it in a way that it's totally backwards compatible, no old code is broken by the new feature. What we want to do over the next few years and the next couple of releases is to get the user communauty to start using the new features that replace old features. So eventually we will be able to deprecate the old features, which means that we tell you don't use that and in the next release we actually have a warning if you're still using it. It prints a warning that says "you should really not be using it cause it's going to go away" and then two more releases later or something like that, if they're using it, it's a syntax error or a runtime error. Wow, to me Py2.2 is the oldest version of Python that can still be considered useful or "real" Python. 
You don't have access to apache, but are allowed to run a webserver on port 80?
Candygram is a Python implementation of Erlang concurrency primitives. Erlang is widely respected for its elegant built-in facilities for concurrent programming. This package attempts to emulate those facilities as closely as possible in Python. With Candygram, developers can send and receive messages between threads using semantics nearly identical to those in the Erlang language.
Land shark...
Who would let Chevy Chase in their home?
Welcome to [4 years ago](http://sourceforge.net/project/stats/detail.php?group_id=114295&amp;ugn=candygram&amp;type=cvs&amp;mode=12months)... Check out [processing](http://pypi.python.org/pypi/processing), [pyro](http://pyro.sourceforge.net/), or [mpi4py](http://mpi4py.scipy.org/) for more modern concurrency work in python.
Hmm.. &gt; The short answer is that [spawn()] creates a thread. Nice proof of concept, but not very useful in practice. Better look at Processing etc. as someone suggested if you need something for more than an interesting example.
If only there were a fancy translator for py_interface so that these could be used with with Erlang nodes :)
Very cool, except I wish they could get some stuff *added* to the stdlib as well. Anytime I install Python I have to go get wx,PIL,docutils,pyparsing ,,, include more batteries!
I know at least the reason for not including wx is that it changes too often, so its release schedule is not properly timed with Python's. Including it with the stdlib would make it suck more instead of less, since updates would be less frequent.
But an old version of wxPython beats tkinter any day. I really wish that wx could be added, porting IDLE would be a piece of cake (yes, I would volunteer).
One thing they should add is a native array type, such as the ones provided in numpy.
Doesn't [array](http://docs.python.org/lib/module-array.html) suffice for basic stuff? My feeling is that numpy is not stable enough to be included in the stdlib.
Hey, I wasn't aware of it! Thanks :)
Close, but not portable. It gets more complex if you us `os.linesep`, which on some platforms is '\r\n'. Curse you Windows! Still, pretty neat effort for Unix-y stuff.
Good point; I didn't think about windows line endings. I think I'd just use line.strip() for line in reversefile(...) on a text file with /r/n's, or replace the search for /n with /r if I was (for some reason) still using old mac-style line endings. The file was actually originally used on windows, but my logfiles were \n terminated.
C:\&gt;python reversefile.py testing: &lt;&gt; testing: &lt; &gt; testing: &lt;something &gt; reversefile.py:63: DeprecationWarning: raising a string exception is deprecated %s""" % (expected, got) Traceback (most recent call last): File "reversefile.py", line 66, in &lt;module&gt; test_reversefile() File "reversefile.py", line 63, in test_reversefile %s""" % (expected, got) failure with ['something'] ======================= ['', 'something'] C:\&gt;
on what version of python? It works fine here on 2.5.1.
It works for me on 2.5.1 on Ubuntu at home. That was at work on XP. I'll have to check tomorrow which version, but I'm pretty sure it's 2.5.something, as I just installed it again recently.
Strange... as I say, I wrote it on windows XP, using the windows python, though I executed it in cygwin. And the one it failed on doesn't even have implicit line endings? Are you executing code in a non-US environment, maybe? Or is python doing an auto \n -&gt; \r\n for some reason?
An easy alternative might be to change `if self._f.read(1) == '\n':` to `if self._f.read(len(os.linesep)) == os.linesep:`.
Can you (or anyone else) test it on a windows machine? I'm hesitant to change it without being sure.
Okay, back at work, firing up python from a DOS prompt: Python 2.5.1 (r251:54863, Apr 18 2007, 08:51:08) [MSC v.1310 32 bit (Intel)] on win32 I saved reversefile.py again straight from your site to my desktop, and ran 'python reversefile.py' from the prompt, and got the same output as yesterday. Not sure what to make of it, but figured I'd point it out to you. Full disclosure: not a python programmer.
I appreciate the report. Guess I'll have to fire up Parallels and see if I can reproduce.
The downside of char by char reading is that it isn't very efficient, especially in reverse, as buffering is done on a readahead basis. Here's a different approach I wrote to solve the same problem a while ago: import os def rblocks(f, blocksize=4096): """Read file as series of blocks from end of file to start. The data itself is in normal order, only the order of the blocks is reversed. ie. "hello world" -&gt; ["ld","wor", "lo ", "hel"] Note that the file must be opened in binary mode. """ if 'b' not in f.mode.lower(): raise Exception("File must be opened using binary mode.") size = os.stat(f.name).st_size fullblocks, lastblock = divmod(size, blocksize) # The first(end of file) block will be short, since this leaves # the rest aligned on a blocksize boundary. This may be more # efficient than having the last (first in file) block be short f.seek(-lastblock,2) yield f.read(lastblock) for i in range(fullblocks-1,-1, -1): f.seek(i * blocksize) yield f.read(blocksize) def rlines(f, keepends=False): """Iterate through the lines of a file in reverse order. If keepends is true, line endings are kept as part of the line. """ buf = '' for block in rblocks(f): buf = block + buf lines = buf.splitlines(keepends) # Return all lines except the first (since may be partial) if lines: lines.reverse() buf = lines.pop() # Last line becomes end of new first line. for line in lines: yield line yield buf # First line. Processing a million line file takes 0.3 secs with this approach. Going char by char ends up taking well over a minute. **[Edit]** Note that the above only works consistently for files opened in binary mode. ie open('filename.txt','rb'). See comment below for details. Added a check for this.
It looks like it works here, but you'll also need to change "end - pos - 1" to "end - pos - len(os.linesep)". However, see my post [here](http://reddit.com/r/Python/info/6hj75/comments/c03vms4) for another approach using splitlines() to deal with this.
nice! edit: added to the article.
Of course, after posting it, I've found a bug. It doesn't work too well with files opened in text mode (ie. 'r' instead of 'rb') on Windows, where the '\r\n'-&gt;'\n' translation gets done. If a block breaks in the wrong place, you can get repeated characters at the end of a block. Opening in binary mode always works. It looks like seeking doesn't take the newline translations into account. Indeed, checking the [docs](http://docs.python.org/lib/bltin-file-objects.html) indicates that seeking to arbitrary offsets isn't allowed on text files, so I'm hitting the "Undefined behaviour" mentioned.
Perhaps we should look at how the file() iterator works, then make an attempt to write a canonical reversefile() in C? Perhaps we could even get it into the stdlib? (/me cackles) I find it really useful, and it seems nobody has a great solution yet. Edit: if you're curious, [here](http://svn.python.org/view/python/trunk/Objects/fileobject.c?rev=62536&amp;view=markup)'s the file; search for "Routine to get next line" to get to the top of the detailed comment describing their method.
Actually, it looks like the restriction on seek is a general posix (rather than python specific) limit for text files. Even a C implementation using fseek is not guaranteed to work on arbitrary positions (only 0 and the results of ftell()). The only actually guaranteed way is probably to read the whole file into memory, which breaks the whole point of an iterator approach, though it's an easy solution: [line.rstrip('\n') for line in reversed(open('file.txt').readlines())] I think I'll just cheat and take the lazy approach by "fixing" it in the documentation. I've added an "if 'b' not in f.mode.lower()" check to the function above.
I guess they only wanted "OO" programmers. ;-)
in my opinion, it's much better than use pysqlite.
Interesting, I'll have to see if its model applies to some of my giant crazy data sets.
that's what she said
I use it as an adjunct datastore for a corporate Django app that I designed and maintain. I am currently revamping the app and plan to stick with pytables although HBase also looks interesting. Unfortunately column oriented DBs are not directly supported in Django (and support for multiple databases is not in trunk yet either.) But I expect this will change soon enough given the GoogleAppEngine work with BigTable. Eventually I expect to use both RDBs and column oriented databases side by side in Django apps on a regular basis. I expect that many apps with massive data set requirements would benefit by exploiting both data storage models. In the meantime pysqlite is still the ticket for creating a new or small Django app in a hurry. 
sqlite and cPickle and struct have all I need.
i think it's pretty cool
no, when I want to use a joke of a not-database, I simply use mysql. 
and it doesn't afraid of "pornographic images/child models/invasion discussion"
It doesn't afraid truly only.
nsfw
How does this differ from socket.gethostbyname(socket.gethostname()) ?
Thanks for going with "what has science done" rather than the more ./ish "what could possibly go wrong"
It also looks like they're adding some stuff -- I read recently that Ippolito's simplejson is going into the stadard library -- which is awesome.
That's awesome! A few days ago, I though it would be a great feature -- voilà!
hi! i'm a php user and a python programmer. i'd love to use python for my server side needs but i can't seem to find what i'm looking for. for most of my php work i use mysql and tinyButStrong (http://www.tinybutstrong.com) which is a very lightweight template engine that offers powerful functionalities. you insert TBS tags in web pages like: &lt;div align="center" class="title-page"&gt; [var.x] &lt;/div&gt; and it replaces [var.x] with the value of global variable x. it also makes blocks (and nested blocks) easy to implement: &lt;p class="text-example2"&gt; [blk1;block=begin] [blk1.val]&lt;br&gt; [blk1;block=end] &lt;/p&gt; in the previous code it cycles throu all the values of the array blk1. it does many more things, like htlm escaping, url and js encoding etc, conditional displaying etc, but it is _not_ more confusing that inserting pieces of code into the HTML (aka: littering the code and kissing goodbye to the code/presentation separation). it comes in the form of a single file with a single class that you can easily include in the code and go. now, i've searched the net and it seems full of python-based frameworks for doing server side scripting and templating, but none that suits my needs. 1. i like writing code and i like control. i mean, open up the simplest text editor and write in it. i don't want something that is command-line driven or that writes code for me like "&gt;&gt;&gt; makePagesFromThisDatabase()". 2. i want something very lightweight. i don't want dozen of options, pre-made blogging parts ecc. i just need a good _non invasive_ template engine and the basic functions for server side scripting, like session managing, request parsing, functions to manipulate html code (encodings etc) 3. i don't want to beg my hosting provider to install the libraries. a simple include file should do the work. 4. object oriented programming is not required (better: i prefer plain old procedural programming). any help? thanks in advance
At first I thought, hey, that's great! Then I looked at the docs and thought, hmmm, Bioconductor has been doing this sort of thing for me for quite a while. I'm not knocking the project -- mapping graph queries onto closures is clever -- but from a practical standpoint, why reinvent the wheel? (Granted, it's in Python instead of R. But these two languages have existing interfaces that work, so the question stands.) Congratulations on the GSOC projects, regardless. 
This seems to be a good find, as I've never had the best of luck with docs at Pylon's own site. Here's hoping this is a bit different.
[Dupe](http://reddit.com/info/6j02b/comments/)
Nope. That one is in the programming subreddit and this one is in the Python subreddit.
Where?
not packaged, svn repo under source
Well, I subscribe to both subreddits. So I see the same thing twice. Thus defeating the raison d'être of reddit in general: showing me what's new on the Internet. This is my biggest problem with the current implementation of the subreddits. I'm not sure what the solution should be. Perhaps merge the two submissions together somehow.
also check out Reverend http://divmod.org/trac/wiki/DivmodReverend
It has been removed.
Or you could go and learn it by actually coding like the rest of us did.
Or, you can combine both to get maximum effect. ps. I don't even think you looked at the article.
&gt; ps. I don't even think you looked at the article. Come on man, of course I didn't.
If you had looked at it, you would not have made such a comment. I write on the 1st paragraph that I am learning Python because I am doing a project in it. I was learning by coding, the lectures just outlined the key ideas which I might have missed if I had started programming without watching them. The project, btw, was [Reddit River](http://redditriver.com) for mobile phones (it's [open sourced](http://www.catonmat.net/blog/designing-redditriver-dot-com-website/)).
The solution is hierarchal reddits. If you submit something to Python, it shows up in Programming too (unless you uncheck the python subreddit, of course) It'd solve the ~cross-posting issue, and mean you don't have to subscribe to every single programming related subreddit. The only obvious issue would be making sure people don't make a Python subreddit in "programming" and in "coding" or such.
I got all excited then saw there was no javascript interpreter/engine. Ah well, still ok, but I will stick to WWW::Mechanize. 
If you're using Python, there's [mechanize](http://wwwsearch.sourceforge.net/mechanize/), and my choice, [twill](http://twill.idyll.org/), a language and library that wrap mechanize and make it easier to use. Still no javascript, but it's a fast way to do automation and testing of web apps.
There already is a [python port of mechanize](http://wwwsearch.sourceforge.net/mechanize/). This class is mostly interesting for its tight integration with firefox. edit: true enough, it's not really tight integration. *shrug*
&gt;This class is mostly interesting for its tight integration with firefox. Integration? &gt;4. Check the GET and POST requests in the livehttpheaders capture window 5. Create an instance of the above class and send the same GET and POST requests to the server. I am not seeing it, other than it pretending to be firefox by changing the user-agent string.
&gt; This class is mostly interesting for its tight integration with firefox. Looking at the script source, I don't understand where the *tight integration* with Firefox happens. Can you elaborate? The only mention of Firefox in the script is in the useragent string. And, in the description where the author advises the use of Firefox with Livehttpheaders extension to sniff the HTTP headers and grab URL parameters. It is entirely possible that I am missing something, as I am not a Python programmer.
I am currently using Rspec in Ruby to create a DSL for testing webpages using WWW::Mechanize. A big problem for me is I can't emulate Ajax requests in a real sense, (I can ask directly for the json, and make sure it looks right, but I am trying for integration testing), so I am looking for a library with javascript support that doesn't, say, actually launch IE. 
I like [WWW::Mechanize](http://cpan.uwinnipeg.ca/dist/WWW-Mechanize) and especially the [mechanize shell](http://cpan.uwinnipeg.ca/dist/WWW-Mechanize-Shell), which makes it very easy to examine web pages and automate browsing tasks.
I just meant that it's set up to expect data copied from livehttpheaders, I guess it's not really that tight.
I use [htmlunit](http://htmlunit.sourceforge.net) for that type of thing. Its a headless browser written in java. Includes a javascript interpreter that sorta works most of the time.
eh, just from the title I was expecting to be able to surf in NCSA Mosaic, Netscape 0.9, ...
Get yourself over to [Evolt's browser archive](http://browsers.evolt.org/). [NCSA Mosaic](http://browsers.evolt.org/?mosaic-ncsa/), [Netscape 0.9](http://browsers.evolt.org/?navigator/16bit/0.9) and plenty more hardly anybody has ever heard of.
[PyKHTML](http://paul.giannaros.org/pykhtml/) does Javascript. It's a pain in the ass to get the dependencies configured though. Got it running and crawling sites on an EC2 instance a few months ago.
That one definitely doesn't hold your hand, does it? Thanks though, this looks interesting.
Brookhaven Protein Database? Is that you?
I was so hoping this would be a port of the graphics package to Python (although I was a little confused as to why that would go in the standard library).
When I tried it earlier today, the server would log errors since it couldn't launch the python interpreter successfully, since it was installed in "C:\Program Files\Python25\". In the end, I had to go into the library file and modify the CGIHTTPServer.py file to refer to just "python" instead of sys.executable, and add the python path to my PATH environment variable.
neat.
Funny, I usually do the exact opposite; create them in Photoshop, then have PIL convert them to a list of colors.
photoshop ? use gimp !
Future article: Java ArrayList vs. LinkedList: What you need to know.
See also http://divmod.org/trac/wiki/DivmodReverend Divmod has more documentation on their module, fwiw...
&gt; Indeed, xrange supports iteration, whereas range does not. Incorrect. Both can be iterated over. The difference is that `xrange` can only be iterated over, since it's not a list. &gt; The overall benefit is minimal, because xrange (in the words of the Python manual) “still has to create the values when asked for them,” but at each call, it consumes the same amount of memory regardless of the size of the requested list. At extremely large values, this is a major benefit over range. Another benefit is also apparent: if your code is going to break out while traversing over a generated list, then xrange is the better choice as you are going to consume less memory overall if you break. The way this is written implies that the savings come only if there's a break. That is incorrect. At every point in time, an `xrange` object has three values associated with it: the current position, the stop value, and the step. At every point in time, the result of a `range` expression is a list containing all the values between the start and the stop. `xrange` should always be used unless one needs to use the resulting object specifically as a list, which is a very rare occurrence. In Python 3.0, `xrange` will be renamed as as `range` and the old `range` will be dropped. If you need an old style `range` in Python 3.0, write `list(range(...))`, but again there is very little need for old style ranges. I think everyone learns these basics about ranges in their first Python tutorial. This article is poor.
&gt; It’s pretty easy to write a non-clever title-casing function. The simplest way is to just capitalize the first letter of every word. That’s not right, though, because it’ll leave you with capitalized small words like if, in, of, on, etc. What you want is something that not only knows not to capitalize such words, but will un-capitalize them if they’re erroneously capitalized in the input. This is a script I've wanted for a while actually, but Perl is gross. Can anyone rewrite it as half a line of Haskell or two tabs of Python? Could be a fun chance to show off.
Περίπτωση τίτλου Τρίτη, 20 Μαΐου 2008 Εδώ είναι ένα από τα μικρά εργαλεία που έχω γράψει για να βοηθήσω να δημοσιεύσουν DF που δεν έχω φτάσει ποτέ γύρω στη διανομή: ένα φαινομενικά έξυπνο χειρόγραφο για τη μετατροπή του κειμένου στην περίπτωση τίτλου. Το χρησιμοποιώ για να τυποποιήσω την κεφαλαιοποίηση των συνδεμένων τίτλων καταλόγων, παραδείγματος χάριν. Εδώ είναι ο κωδικός πηγής. Είναι ένα χειρόγραφο Perl, έτσι το σώζει ως αρχείο κειμένων και μπορείτε να το χρησιμοποιήσετε οπουδήποτε όπου Perl λειτουργεί. Το χρησιμοποιώ ως σε όλο το σύστημα υπηρεσία (με το συντομότερο δρόμο εντολή-μετατόπιση-τ) μέσω της άριστης (και ελεύθερης) χρησιμότητας ThisService του Jesper. Είναι αρκετά εύκολο να γραφτεί μια μη-έξυπνη λειτουργία τίτλος-περιβλήματος. Ο απλούστερος τρόπος είναι να κεφαλαιοποιηθεί ακριβώς η πρώτη επιστολή κάθε λέξης. Αυτός δεν είναι σωστός, εν τούτοις, επειδή θα σας αφήσει με τις κεφαλαιοποιημένες μικρές λέξεις όπως εάν, μέσα, επάνω, του κ.λπ. Αυτό που θέλετε είναι κάτι που όχι μόνο ξέρει για να μην κεφαλαιοποιούνται τέτοιες λέξεις, αλλά Η.Ε-θα τους κεφαλαιοποιήσει εάν κεφαλαιοποιούνται λανθασμένα στην εισαγωγή. Έτσι, μερικές από την ευφυΐα σε αυτό το χειρόγραφο: Ξέρει για τις μικρές λέξεις που δεν πρέπει να κεφαλαιοποιηθούν. Όχι όλοι οι οδηγοί ύφους χρησιμοποιούν τον ίδιο κατάλογο λέξεων - παραδείγματος χάριν, πολλές πεζές με, αλλά όχι. Ο κατάλογος λέξεων τροποποιείται εύκολα για να ταιριάξει την προτίμηση/τους κανόνες σας: τα @small_words μου = qw (και όπως σε αλλά από το En για εάν μέσα ή στο β [.]; μέσω εναντίον [.];) (Η μόνη πονηριά εδώ είναι ότι «τα β» και «εναντίον» περιλαμβάνουν τα προαιρετικά σημεία, εκφρασμένος στη σύνταξη regex.) Το χειρόγραφο υποθέτει ότι οι λέξεις με τα κεφαλαιοποιημένα γράμματα εκτός από τον πρώτο χαρακτήρα ήδη σωστά κεφαλαιοποιούνται. Αυτό σημαίνει ότι θα αφήσει μια λέξη όπως «τα iTunes» μόνο, παρά να παραμορφώσει το «σε ITunes» ή, χειρότερος, «Itunes». Πηδά επίσης πέρα από οποιεσδήποτε λέξεις με τα σημεία γραμμών «example.com» και «del.icio.us» θα παραμείνουν πεζά. Σκληρός-έχει κωδικοποιήσει τις αμυχές για να εξετάσει συγκεκριμένα τις περίεργες περιπτώσεις που έχω τρέξει, όπως «AT&amp; Τ» και «Q&amp; », Και οι δύο από το οποίο περιέχουν τις μικρές λέξεις (και α) που πρέπει κανονικά να είναι πεζές. Η πρώτη και τελευταία λέξη του τίτλου κεφαλαιοποιείται πάντα, έτσι εισαγμένος όπως «τίποτα για να είναι φοβισμένος» θα μετατραπεί «σε τίποτα για να είναι φοβισμένος». Μια μικρή λέξη μετά από μια άνω και κάτω τελεία θα κεφαλαιοποιηθεί. Εδώ είναι ένας μικρός κατάλογος περιπτώσεων ακρών ότι οι λαβές χειρογράφων. Ο ίδιος ο κωδικός πηγής είναι, uh, μάλλον μπερδεμένος, να πει λιγότερους. Είναι ένα από εκείνα τα κομμάτια του κώδικα που άρχισαν μικρός και απλός, και έγιναν άσχημα με την πάροδο του χρόνου όπως οι περιπτώσεις ακρών εργάστηκαν γύρω από μια σε έναν χρόνο. Έχω χρησιμοποιήσει αυτό το χειρόγραφο για χρόνια, αλλά έχω αναβάλει την έκδοση του λόγω του ότι μοιάζει με το είδος του στίξη-διάτρητου κώδικα που δίνει στο phobics Perl τα heebie-jeebies. Αλλά το λειτουργεί, έτσι βιδώνει, εδώ είναι
Too bad, the python two liner is just as gross. small = 'a an and as at but by en for if in of on or the to v. v via vs vs.'.split() sentence = 'Nothing to be afraid of' words = [(w[0].isupper() and any(c.isupper() for c in w[1:]) or '.' in w) and w or w.lower() in small and w.lower() or w.capitalize() for w in sentence.split()] print ' '.join([words[0][0].upper() + words[0][1:]] + words[1:-1] + [words[-1][0].upper() + words[-1][1:]]) 
Too subtle.
I'm not sure, but it might be shorter if you use `word.title()` instead of `[0].upper()`. Or at least less gross? Edit: But then "ITunes" breaks. Never mind. Edit 2: Do you think your handling of "iTunes, iTunes, iTunes." is correct? I think according to Gruber it should come out as "ITunes, iTunes, ITunes." but your version makes "Itunes, Itunes, ITunes." I think you need to change the first `and` to an `or`. Edit 3: TitleCase.pl leaves "iTunes, iTunes, iTunes." alone entirely. Here's my attempt to replicate its behavior: small = ('a an and as at but by en for if' 'in of on or the to v. v via vs vs.'.split()) has_uppers = lambda word: any(c.isupper() for c in word) def in_small(word): word = ''.join(char.lower() for char in word if char.isalpha()) return word in small def smart_capitalize(w): if (w[0].isupper() or has_uppers(w[1:]) or '.' in w): return w elif in_small(w): return w.lower() else: return w.title() def title(sentence): words = [smart_capitalize(word) for word in sentence.split()] if in_small(words[0]): words[0] = words[0].title() if in_small(words[-1]): words[-1] = words[-1].title() return ' '.join(words)
OK, howza 'bout this?: &gt; MD2: 8350e5a3e24c153df2275c9f80692773 MD4: 31d6cfe0d16ae931b73c59d7e0c089c0 MD5: d41d8cd98f00b204e9800998ecf8427e CRC 8, ccitt, 16, 32 : 0, ffff, 0, 00000000 CRYPT (form: $ MD5? $ SALT $ CRYPT): $1$H2RyPQoS$zxhodeY16wCDC8MYMw8Ah0 form: SALT[2] CRYPT[11]): psVCB8A3RH3lI SHA1: da39a3ee5e6b4b0d3255bfef95601890afd80709 RIPEMD-160: 9c1185a5 c5e9fc54 61280897 7ee8f548 b2258d31 SHA2-256: e3b0c44298fc1c149afbf4c8996fb924 27ae41e4649b934ca495991b7852b855 SHA2-384: 38b060a751ac96384cd9327eb1b1e36a 21fdb71114be07434c0cc7bf63f6e1da 274edebfe76f65fbd51ad2f14898b95b SHA2-512: cf83e1357eefb8bdf1542850d66d8007 d620e4050b5715dc83f4a921d36ce9ce 47d0d13c5d85f2b0ff8318d2877eec2f 63b931bd47417a81a538327af927da3e **CHECK SUM This cannot be decoded**
**JavaScript** &gt; var str = 'hello world is cool vs test iTune google.com blah'; &gt; &gt; str.replace(/([a-z]{3,}\s|$)/g, function(m){ return m.slice(0,1).toUpperCase() + m.slice(1) }) **returns** &gt; "Hello World is Cool vs Test iTUne google.Com blah" Still have not found how to prevent capturing words containing a dot .. and my dinner time is elapsed :(
Hahaha, that is hilarious. &gt; Αλλά το λειτουργεί, έτσι βιδώνει, εδώ είναι translates to: &gt; But the works, it screws like so, here it is
Here's my version: (defparameter *reserved-words* '("a" "an" "and" "as" "at" "but" "by" "en" "for" "if" "on" "of" "or" "the" "to" "v" "v." "via" "vs" "vs.")) (defun string-smart-capitalise (string) (format nil "~{~a ~}" (loop for word in (split-sequence:split-sequence #\Space string) for i from 1 if (and (not (eq i 1)) (or (find word *reserved-words* :test #'string-equal) (find #\. word :test #'char-equal) (some (lambda (char) (eql (char-upcase char) char)) word))) collect word else collect (string-capitalize word)))) 
I had to add the following to the bottom to be able to test this at all: import sys for line in sys.stdin.readlines(): print title(line) (Note that this is not equivalent to what the lowly `while(&lt;&gt;){}` will do in Perl. Do get its exact behaviour in Python, apparently [you have to go to great lengths](http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/302262).) But when I try I get this error: Traceback (most recent call last): File "titlecase.py", line 26, in &lt;module&gt; print title(line) File "titlecase.py", line 20, in title if in_small(words[0]): words[0] = words[0].title() IndexError: list index out of range Seems like your code is not right. I was trying to run it against the edge cases Gruber posted to see if it would produce identical results. No luck.
How about rewriting his Perl version in Perl? Whether Perl is gross is personal opinion, but Perl doesn’t have to be nearly as gross as Gruber’s code, which, as he wrote, grew this way slowly, over time. Of course it’s easy to write a much clearer version if you have a blueprint like the one he delivered, and know all the requirements up front. I have tested the following; it produces the exact same output as Gruber’s script on every input I have tried, which includes his example edge cases as well as a large sample of titles from his Linked List linkblog. #!/usr/bin/perl use strict; use warnings; use utf8; use open qw( :utf8 :std ); my @small_words = qw( (?&lt;!Q&amp;)a an and as at(?!&amp;T) but by en for if in of on or the to v[.]? via vs[.]? ); my $small_re = join '|', @small_words; while ( &lt;&gt; ) { s{ \b (?: ( [[:alpha:]]+ [.] [[:alpha:].]+ ) # inline-dotted word | # or ( (?i: $small_re ) ) # small word (case-insensitive) | # or ( [[:alpha:]] [[:lower:]'’]* ) # word w/o internal caps | # or ( [[:alpha:]] [[:alpha:]'’]* ) # some other word ) \b }{ defined $1 ? $1 # preserve inline-dotted word : defined $2 ? "\L$2" # lowercase small word : defined $3 ? "\u\L$3" # capitalize word w/o internal caps : $4 # preserve other kinds of word }exgo; # exceptions for small words: capitalize at start and end of title s{ ( \A [[:punct:]]* # start of title... | [:.;?!][ ]+['"“’]? ) # or of subphrase... ( $small_re ) \b # ... followed by small word }{$1\u\L$2}xigo; s{ \b ( $small_re ) # small word... (?= [[:punct:]]* \Z ) # ... at the end of the title? }{\u\L$1}xigo; print; }
Yeah, I assumed the input was non-empty. http://widefido.com/static/wf/files/title_case.py.txt has an exact translation from Perl to Python, but I find it as gross as the original. Here's my new version, which (I think) gets all the edge cases listed: SMALL_WORDS = ('a an and as at but by en for if ' 'in of on or the to v. v via vs vs.'.split()) has_uppers = lambda word: any(c.isupper() for c in word) def in_small(word): word = ''.join(char.lower() for char in word if char.isalpha()) return word in SMALL_WORDS def dot_in_word(word): if "." in word: i = word.index(".") + 1 return any(char.isalpha() for char in word[i:]) return False def smart_capitalize(w): if has_uppers(w[1:]) or dot_in_word(w): return w elif in_small(w): return w.lower() else: return w.title() def title(sentence): words = [smart_capitalize(word) for word in sentence.split()] if words: if in_small(words[0]): words[0] = words[0].title() if in_small(words[-1]): words[-1] = words[-1].title() for n, word in enumerate(words): if word.endswith("'S"): print word, word[:-2] words[n] = word[:-2] + "'s" if word.endswith(":") and len(words) &gt;= n+1: if in_small(words[n+1]): words[n+1] = words[n+1].title() return ' '.join(words) test_cases = """Q&amp;A With Steve Jobs: 'That's What Happens In Technology' What Is AT&amp;T's Problem? Apple Deal With AT&amp;T Falls Through this v that this vs that this v. that this vs. that The SEC's Apple Probe: What You Need to Know 'by the Way, small word at the start but within quotes.' Small word at end is nothing to be afraid of Starting Sub-Phrase With a Small Word: a Trick, Perhaps? Sub-Phrase With a Small Word in Quotes: 'a Trick, Perhaps?' Sub-Phrase With a Small Word in Quotes: "a Trick, Perhaps?" "Nothing to Be Afraid of?" "Nothing to Be Afraid Of?" a thing""" if __name__ == '__main__': if len(sys.argv) &gt; 1: if sys.argv[1] == "test": for line in test_cases.splitlines(): line = line.strip() if line: print "-" print "Orginal: %s" % line print "Titled: %s" % title_case(line) print "-" else: print title(sys.argv[1]) else: for line in sys.stdin: title(line) 
Ruby version (it's probably pretty gross, as I'm still pretty new to ruby): small_re = %w( a an and as at but by en for if in of on or the to via v[.]? vs[.]? ).join('|'); ARGF.each do |line| # split line into phrases line = line.split(/( [:.;?!][ ] | (?:[ ]|^)["”] )/x).collect do |s| # Uppercase all non-dotted (e.g. del.icio.us) words for now s.gsub(/\b([[:alpha:]][[:lower:].'’]*)\b/ex) do |w| w.match(/[[:alpha:]] [.] [[:alpha:]] /x) ? w : w.capitalize end. # Lowercase our list of small words: gsub(/\b(#{small_re})\b/i) {|w| w.downcase }. # If the first word in the title is a small word, then capitalize it: gsub(/\A([[:punct:]]*)(#{small_re})\b/io) { $1 + $2.capitalize}. # If the last word in the title is a small word, then capitalize it: gsub(/\b(#{small_re})([[:punct:]]*)\Z/io) { $1.capitalize + $2} end.join. # Special Cases gsub(/ V(s?)[.] /, ' v\1. '). # "v." and "vs.": gsub(/(['’])S\b/, '\1s'). # 'S (otherwise you get "the SEC'S decision") gsub(/\b(AT&amp;T|Q&amp;A)\b/i) {|s| s.upcase} # "AT&amp;T" and "Q&amp;A", which get tripped up by puts line; end
More ruby versions: http://hivelogic.com/articles/2008/05/title-case-for-ruby
Javascript: http://ejohn.org/blog/title-capitalization-in-javascript/
That lazy module is actually pretty cool, I can see all sorts of uses for that
I am a CS major, and I have to say that I prefer Python to matlab.
I have to use Matlab because the boss wants it that way, but I prefer Python. I'm thinking about porting our research platform over to Sage and springing it on him.
Downvoted for inaccurate headline. Where does it say such a thing?
&gt; Because there was an overlap between the two groups, I did robots and MATLAB yesterday, and today, just had four faculty, all from the same institution (the new Georgia Gwinnett College). &gt; I found it fascinating to see all of this material from these new eyes, particularly in comparison with last year. Some of my observations: &gt; * Python is much more interesting to lots of faculty. Almost always the interest is for non-majors.
My reading of the other bullets suggests that he was talking about the people in the workshop in general, and not just during his sessions. Why else would he talk about professors preferring Java and C++? And seriously, since when do CS majors prefer MATLAB over those two? I think he was referring to what should be taught in introductory level programming courses
hmmmm.... I think I read "for" as "from"? you're right.
Haven't had a chance to use DejaVu to great extent - but wanted to say that being written by Robert Brewer (fumanchu) is an indicator of design quality.
Kind of pointless but fun, I guess. As everyone is no doubt aware, Python 3.0 lets you write code like this: &gt;&gt;&gt; def f(s:str)-&gt;str: ... return s + "!" ... &gt;&gt;&gt; f.__annotations__ {'s': &lt;class 'str'&gt;, 'return': &lt;class 'str'&gt;} The annotations themselves are ignored by the Python interpreter, but if you add a decorator, you can use it to make your runtime type checking a little prettier.
I think they're planning to change the name to multi-processing or some such.
Somewhat related problem: How am I supposed to check if a supplied string is an integer? For example, I want to do: i = raw_input() if is_int(i): print int(i) * 20 The only way I have worked out to do this is kind of hackish: def is_int(i): try: return int(i) except ValueError: return False There are commands that seem like they should be able to do this (getattr() if I recall right), but I couldn't find any that would work
It's noted in the PEP - some people proposed a name change, I'm personally ambivalent as it could be called "meat" as long as I get the functionality.
A rose by any other name would smell the same to the nose.
Actually, no. If they named it something remarkably stupid and hid it in a deeply nested hierarchy it wouldn't be nearly as useful. Also, you blew the quote; &gt; ’Tis but thy name that is my enemy; Thou art thyself though, not a Montague. What’s Montague? it is nor hand, nor foot, Nor arm, nor face, nor any other part Belonging to a man. O! be some other name: What’s in a name? that which we call a rose By any other name would smell as sweet; So Romeo would, were he not Romeo call’d, Retain that dear perfection which he owes Without that title.
I'd recommend that, this name always confuses me because it doesn't trigger the right associations. I get that it's an analogy to Threading, but the name really doesn't convey what the module does.
Thanks for that link! I'm not a statistician nor a programmer by trade but I needed a way to classify many thousands of data records for work and the thought of doing it by hand made me cringe. I ended up looking into a way to automate the classification and settled on the bayes classification method. I already know how to program pretty well (it's a hobby). So I read up on baysian classification on wikipedia and hacked up some python code. The learner module I wrote scans some pre-classified csv data to create a token dictionary tree (saved as a pickled dictionary). Then I created a second classifier module. I went a step further and registered the module as an COM object and together with some VBA wrapper code I can now call my python classifier as a function within Excel. The reason I'm thanking you for that link is that until now I had no idea how to go about combining the probability array in my bin scoring function into a single value per input record. I just summed the probabilities, knowing it was horribly incorrect. Looking at the code in the link you provided I see that the Reverend has two different methods defined for combining the probabilities which are exactly what I've been looking for. I did notice, one thing my classifier does that the Reverend doesn't is token ordering weighting. The Reverend makes no distinction in this regard. Currently mine only considers the token before and after the current token but I want to extend this functionality to include weighting for each word, fragment, sentence &amp; phrase. Like I said currently the code I wrote only supports words, pairs and triplets. Currently my back testing shows 96% correct classifications on 100% of the records and 99.8% correct on 67% of the records (using probability threshold and minimum bin difference limits). I can't wait to see the improvement with the new robinson &amp; robinsonFisher algorithms. Thanks again! 
See also: https://code.launchpad.net/ipython/stable/0.8.3
and [here's the release notes](http://ipython.scipy.org/moin/WhatsNew083).
Pleased to be of service.
I agree that it shouldn't be any more hidden in a hierarchy than, say, the threading or queue modules. I was more disturbed by a poster named under similar alias posting something I agreed with. Anyhow, I'd argue for "bacon". 
If you are having trouble getting custom actions to work, check out [ticket #5825](http://code.djangoproject.com/ticket/5825).
What's the advantage over pickle for a pure Python project?
&gt;Jacob: I wasn’t yet at World Online when we moved from PHP to Python, but from what I understand it was a pretty typical change. Adrian and Simon got fed up with the pain and suffering wrought by PHP, and wanted something cleaner and — most importantly — something that would be easy to maintain. Python really shines here. &gt; &gt;The main reason we ended up building our own framework was that we didn’t know we were building a framework. We just wanted to “build cool shit” and, over time, we built tools to help us do that. It wasn’t until we started showing it off that we realized we had something that could be used by other people. &gt; &gt;This, by the way, is one of the reasons I think Django turned out so great. If you sit down one day and say, “I’m going to develop a framework!” you’re almost certainly going to become an Architecture Astronaut, and if you ever actually finish the thing’ll be so over designed nobody will want to use it. If, on the other hand, you simply try to solve real-world problems in a clean, obvious way, you’ll eventually end up with a great tool. 
I like this software however it is nothing special. But this lib just satisfy my needs. its a good place to raise your kids up! 
You can edit the config file outside of your program. That being said, I would rather write my own if that was something I needed. Dealing with config files is fairly basic stuff. I see what your saying though, any production type software should include the means to set preferences from within the application. And in these cases pickling the config data is the easiest and quickest way to go. 
How can sharded tables be optimized by the query optimizer?
What's wrong with psycopg?
the project naming scheme sucks!
What's so great about it? I think it was developed after pyPgSql (darcy's implemenation), what was wrong with it Darcy's code? 
What would you prefer to see? btw, if you hover over the project links, you'll get a short description of what it is. I know the names aren't clear by default, but I'm not sure what would be a dramatic improvement, save calling pg_greentrunk "PG-API", which I find unattractive, however clear.
Nothing? I don't know, it's good enough for me...
pyPgSql depends on mx, which is bad. Also, there are issues with type interpretation that psycopg2 doesn't have. The one downside (from certain perspectives) of psycopg2 is that it's not pure python. Another driver, pg8000, takes care of this niche handily. Unless this new driver offers substantial benefits over the approach taken in psycopg2 and pg8000, I can't see myself caring. If there are benefits, I can't find them. As far as I can tell there's no documentation anywhere on the website.
No documentation? I guess you didn't visit the project's page which has the link to the docs and the download for the given version. I'm managing a set of projects here, so you'll have to forgive me if your precise need is not immediately satisfied on your first pageview. And I wouldn't call this driver new, this is just the 1.0 release. ;) The driver docs: http://python.projects.postgresql.org/doc/pg_proboscis-1.0.html The db-api 2.0 module is postgresql.interface.proboscis.dbapi2 See the PEP for DB-API 2.0 docs.
What an abortion. The more crap like this added to Python the more it reminds me of C++. I liked Python because it was simple. Now they are taking that away :(
Why is it hackish? It's clear and concise. Is there a severe penalty in performance that comes with exceptions? Btw. shouldn't that else: statement be except: ? 
Can anyone comment on Dejavu vs. other ORMs like SQLalchemy?
For most cases, this is a very bad idea. The problem with using repr is that the deserialiser (eval) is a *huge* security hole. Anyone who can manipulate your serialised data immediately gains full control of your process, and so the window of attack for your program expands to cover everyone who can access that data. This might be OK in cases where you have full control of your data, and know that it's never exposed. With the given example though, one bug in the \_\_repr\_\_'s string quoting and you're wide open to any web page you scrape. Similarly, anyone who has access to the serialised form that doesn't have the same privileges as the program has an instant privilege escalation avenue.
What's wrong with cPickle?
http://mindview.net/Books/TIPython http://effbot.org/ http://www.planetpython.org/ http://www.djangobook.com/
Did you read the official python tutorial? It's kind of obvious, but it really is a must read.
I've got it on my computer (along with the rest of the documentation), but I haven't actually read it in its entirety. Thanks for the reminder. :)
Here are some articles that are short and sweet: Python Tips, Tricks, and Hacks: http://www.siafoo.net/article/52 Code Like a Pythonista: Idiomatic Python http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html The [Python Cookbook](http://books.google.com/books?id=yhfdQgq8JF4C&amp;dq=python+cookbook&amp;pg=PP1&amp;ots=-5khBsnO24&amp;sig=8_FRJbUtq5mMrEhTkrrMDU43C0Y&amp;hl=en&amp;prev=http://www.google.com/search%3Fhl%3Den%26client%3Dfirefox-a%26rls%3Dorg.mozilla:en-US:official%26hs%3DPRJ%26pwst%3D1%26sa%3DX%26oi%3Dspell%26resnum%3D0%26ct%3Dresult%26cd%3D1%26q%3Dpython%2Bcookbook%26spell%3D1&amp;sa=X&amp;oi=print&amp;ct=title&amp;cad=one-book-with-thumbnail) has great code samples.
&gt; I'm looking for a good book to help me improve from my current working knowledge of Python that isn't Dive Into Python (since I've already downloaded it). Well, since you've already downloaded it, you should fucking read it. For some reason people tend to think that owning a book is the same as having read it.
If you don't have a lot of knowledge the Chun and the Hetland books are both good for learning the basics. Otherwise get the Python Cookbook. The stuff that it illustrates is more advanced than the stuff in say, the Perl Cookbook. Lot of stuff to learn in there.
Programming Python.
[Python in a Nutshell](http://www.oreilly.com/catalog/9780596100469/?CMP=AFC-ak_book&amp;ATT=Python+in+a+Nutshell) should be your best best friend.
Perhaps I could have phrased that a little better, as I have read it and found it very useful. I was looking for something to compliment it. My bad.
:) (for those that didn't catch it, Mark is the author of Dive Into Python!)
Python Cookbook.
I do like making \_\_repr\_\_ work properly with my own classes, but only for development/debug purposes (especially if I need to modify something between runs). But yeah, as mentioned, it isn't a good idea in general. 
&lt;3 Thanks for the suggestions, they look very useful. (:
Your reply needs more "fuck".
I would suggest just jumping in heard first. Keep google handy. You can read as much about a language as you want, but you'll learn much more when you simply hop in and get your feet dirty, because you'll be forced to look up stuff as you go. Think of a fun task that's not tough to do -- like a simple text-based adventure game. The time spent there will help you more than a book. If this is your first programming language, I'd suggest learning some basic computer science theory (Lambda calculus if you have a strong math background, basic object orientation otherwise) first.
Thanks for *your* book, Mark, as well as these resources.
I've been goofing around with it for fairly trivial stuff recently, and love it. I'm looking for some books because I always find they help at learning about features of the language I didn't know existed and would have taken a while to stumble across accidently. I've previously used at some level Visual Basic (which I have endeavoured to forget, HS CompSci is pain), PHP (about which enough has been said), Java (which is nice but irritating) and recently C, which is nice, rewarding and very educational to work with but not really *fun*. I'm not bad at math but I don't have enough of a background yet to be able to handle Lambda calculus, probably. I know the general OO stuff, simple data structures and efficiency, but not at a high level. I'm likely to be spending a lot of time without internet access in the near future, which is the other reason I'm looking for some references that will be more accessible than Google. That's the reason I actually posted this, actually. Probably should have mentioned that.
Not a book but one of my favorite articles: http://www.p-nand-q.com/python/stupid_lambda_tricks.html
Off topic, but are you thinking about updating for Python 3.0?
Text Processing in Python is excellent, and freely available online. The appendix that succinctly describes the entire Python language is worth looking at too. http://gnosis.cx/TPiP/ 
It may look strange, but I really understood Python *semantics* after having read a book on lisp : the first one by Paul Graham. I think it's called Ansi Common Lisp. Graham is, at least, a very good tech writer. The only other python book is in French, it is named : Programmation Python by Tarek Ziadé. A good synthesis of the state of the art in Python. 
Are there any circumstances in which it makes sense to write web apps with CGI these days?
The xml http://trkweb.dominos.com/orderstorage/GetTrackerData?Phone=6175551234 The script &gt; me@localhost:~ $ wget http://random.noflashlight.com/scripts/dominos.py &gt; me@localhost:~ $ chmod +x dominos.py &gt; me@localhost:~ $ ./dominos.py 'your phone number'
Configuration files are usually for data that you want to configure :) If you just want a persistent data store for automatically generated data, then something like shelve is probably best.
&gt; Dealing with config files is fairly basic stuff. Yes, but why write it yourself instead of reusing code that takes care of all the details. &gt; any production type software should include the means to set preferences from within the application. If you're writing an application that is not interacted with from the command line, sure.
Learning Haskell helped me a lot write better python.
Welcome to 1998.
Second that. Its a great launching point. Teaches you how to teach yourself. 
This is an excellent idea. The lack of features like this is what has made Django's built-in DB abstraction/ORM layer often much more of a thorn in my side than it should have been. The proposed solution isn't breathtaking by any measure, but it solves the problem as well as would be practical. After seeing the solution and how easy it really would be to implement it inside the Django framework, now it looks a lot more like a strangely forgotten feature.
Oh hell yeah. Processing vs Nodebox is one of the most interesting battles in the language wars right now. And the Jython Nodebox doesnt quite cut it yet.
&gt; Py-appscript is a high-level, user-friendly Apple event bridge that allows you to control scriptable Mac OS X applications using ordinary Python scripts. ...do you ever speak *real* english? (serious, please don't go through all my posts and downmod me...please...i just want to know if you ever come out and play with real people, from time-to-time).
funny zaMa is never mentioned, likely due to the language barrier involved. zaMa is a thin veneer over OpenGL and is quite fast. one the nicer drawing modules available. [zama!](http://interaction.zhdk.ch/projects/zama/pages/download.php) check out the community section for some neat examples. currently work is starting on a new version, let us know if you're intereted.
http://wxglade.sourceforge.net/ is another option, that does very similar UI-building, but outputs wxWidgets code (which runs on OS X/Linux/Windows using the native UI widgets). And it can output to Python, C++ and Lisp
me too, but for different reasons. I think of python as a dumbed down lisp with a nice syntax. I had a kind of satori on this reading the PG book. But haskell is more about partial evaluation, monad and fiability thru immutability. It made me think about all the cases when mutable data structure bite you. 
If you're interested, today I wrote a new and improved version of this script. I submitted it [here](http://www.reddit.com/info/6m78d/comments/). Enjoy!
I hope it's good. Now will someone, please, pretty please, write a better Twisted book?
So how long did the "URL fetch threaded" program actually take compared to "URL fetch serial" which took "Elapsed Time: 2.40353488922" seconds?
With Python, the interactive command line replaces the IDE more or less.
I learned python by having the tutorial.pdf (from http://python.org) on my laptop while on holiday. Not having an internet connection helps prevent such problems hugely..
Learn the language first then learn the IDE. 
Luckily, they're cleaning up the standard library in 3.0.
http://www.python.org/dev/peps/pep-0371/
&gt; len() is a function and not a method of string. Well, actually... In [1]: "hello world".__len__() Out[1]: 11 &gt; The syntax for a single-item tuple is a parsing-imposed ugliness Should "(2 + 1) * 3" return 9 or (3, 3, 3)? How else would the parser tell if (2+1) is a tuple or not? &gt; The unless keyword is sorely missing How about "if not" instead? By the way, can anyone tell me what the ?/! Rubyism is? I figured that it has something to do with naming, but how is it used exactly?
&gt; By the way, can anyone tell me what the ?/! Rubyism is? I figured that it has something to do with naming, but how is it used exactly? `?` and `!` are only allowed on method names as the last character. The question mark is a convention for methods that return boolean values. `!` is not so well-defined, but it generally indicates the in-place, destructive version of a method that returns a new object instance (e.g. `sort!` vs `sort`). Note, though, that not all destructive methods are suffixed with a bang, only those which have non-destructive counterpart.
Ah, thanks... That's interesting... Sounds like an alternative of is_whatever(), I like the idea.
Surprisingly entertaining!
As a note, it's a convention that comes from Scheme, and it's *really* cool. That's one of the few things I'd really like to get in Python. Not because it has any intrinsic use (it's really only a convention), but because it makes code clearer and more expressive at no cost.
Well.. py3k is supposed to drop old and bad stuff that 2.x stuff uses..
I must say that I disagree with python moving towards 'OOP' in the c++/java style. I think that a dynamic language with first-class functions really has no use with polymorphism. Mixins, perhaps, but not polymorphism. Mixins, maybe. But not polymorphism. Real "Object Oriented Programming" is about breaking your code down into independent segments that may only communicate only by message passing. The idea of data passing has some issues (see multiple inheritance and the diamond problem). If there are any functions that you think should need to be passed down through inheritance, the chances are that those functions should be abstracted out. If you have a relationship where many objects must use the same function, I think that it is cleaner to write the function and pass it to each object than it is to write an abstract class and inherit. The former method is much more flexible.
Well, if you have any other programming experience, you should be able to pick it up pretty quickly.
I have none whatsoever.
Well, it might take you a little longer (or, it may not, and it may be easier since you won't have any other languages ways of doing things in your head). I consider it a good first language. Good luck. Oh, once you get into the swing of it a bit, I'd recommend following comp.lang.python - there's a decent amount of good discussion, and the community is quite friendly.
Cool, thank you very much.
http://diveintopython.org/
Yea, I have that bookmarked after seeing it in another topic on here. I heard it's for people with a little more experience in python though. 
I certainly hope you enjoy your time with Python, soar. In choosing a programming language, you have selected one of the finer representations we in the development community have to offer to you. The language has its moments of perfectionism, but once you take a closer look at it, and begin to start solving problems with it, you'll quickly realize that the language's structure was thought out with real-world problems and logical solutions in mind from the beginning. If you're seeking to make a career out of application development, though, don't let Python become your only environment of familiarity. Just within the subsection of web applications, a balanced combination of languages like PHP, C# and Ruby will make you a highly marketable asset to companies looking for skilled programmers. In any case, if it's your thing, you'll figure that out pretty quickly. If this turns out to be the case, give it a little time and it very well may turn out to become your passion, and there is little more in this world that you could ask for (except maybe finding true love and inner peace) besides having a lucrative career as a personal passion.
Experience in programming in general, not Python specifically. What's your goal generally speaking? 
I just started working with Python, myself. I recommend [How to Think Like a Computer Scientist: Learning With Python][1]. It takes you right from the beginning. It doesn't cover how to get Python onto your system, but [Python.org][2] should have everything you need if you don't already have it. If you have a Mac with Tiger, or better yet Leopard, just open up Terminal and type "Python" and you're golden. [1]:http://openbookproject.net/thinkCSpy/index.xhtml [2]:http://www.python.org/
Here's two bits of advice about using Python for Mac that are annoyingly hard to find by Googling: 1. Copy and Paste functions: import Foundation, AppKit def pbcopy(s): "Copy string argument to clipboard" board = AppKit.NSPasteboard.generalPasteboard() board.declareTypes_owner_([AppKit.NSStringPboardType], None) newStr = Foundation.NSString.stringWithString_(s) newData = \ newStr.nsstring().dataUsingEncoding_(Foundation.NSUTF8StringEncoding) board.setData_forType_(newData, AppKit.NSStringPboardType) def pbpaste(): "Returns contents of clipboard" board = AppKit.NSPasteboard.generalPasteboard() content = board.stringForType_(AppKit.NSStringPboardType) return content 2. How to print out unicode in the terminal. Normally, you get a response like this: &gt;&gt;&gt; print u"\N{GREEK SMALL LETTER ALPHA}" Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; UnicodeEncodeError: 'ascii' codec can't encode character u'\u03b1' in position 0: ordinal not in range(128) To fix this, you need to set your environment to UTF-8 before you run Python. $ LC_CTYPE=en_US.utf-8 $ python Python 2.5 (r25:51918, Sep 19 2006, 08:49:13) [GCC 4.0.1 (Apple Computer, Inc. build 5341)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print u"\N{GREEK SMALL LETTER ALPHA}" α Stick `export LC_CTYPE=en_US.utf-8` into your `.bash_profile` or whatever the appropriate terminal environment file is for your system to make the change permanent.
After you've worked yourself through *How to Think Like a Computer Scientist* and *Dive into Python* (both very well recommended), start applying your newfound powers by trying to solve some of the [problems over at Project Euler](http://projecteuler.net/index.php?section=problems).
Not sure I see his point. Just consider each change to trunk as a new release.
Wow, thanks! Do you have any advice for installing `.egg` packages? I'm going nuts. I'm trying to install `basemap` which requires a pile of other modules. I installed 2.5.2 (which went into `/Library/Frameworks/`) but decided to keep 2.5.1 (which is in `/System/Library/Frameworks`). I was using `easy_install`, which kept loading modules from 2.5.1, not 2.5.2. So I redirected the `/System/Library/Frameworks/Python.framework/` to point to the right place, but now I'm missing modules for `easy_install` and they aren't showing up in Spotlight. It's a bit frustrating. If you know of a guide for `.egg`s (which doesn't seem to be the [official method][1] of distribution) I'd be grateful. [1]:http://docs.python.org/dist/dist.html
I really suspect this will get better after 1.0 is reached, and there is a list of all the stuff that needs to be done for 1.0, so if you're really worried about it...you know what to do. The Django Book says, &gt; The Django team runs production sites on trunk and strives to keep it stable. so I don't think they are.
It seems to me that's overcompensating just a little.
Not really. I started using Django back in January. I use trunk, and keep updating. So far nothing has broken due to an incompatibility. In case the person didn't know, the Django site [lists](http://code.djangoproject.com/wiki/BackwardsIncompatibleChanges) backward incompatible changes. If you look, you'll find there aren't many. Any time someone wants to update his Django, he only needs to look at the list there. He'd do that even if they were to follow his release often model. 
I'm not talking about breaking, I run trunk myself, but that the concept of a 'new release' should mean more than say, correcting some doc strings internal to the template module. It also doesn't address their point that it's a pain to talk in terms of revision numbers. Saying .96 is better than r7580.
Sorry, I don't have much experience with those.
Downmodded for linking to a crappy third-party mail-archive, instead of the official mail archive or [an awesome third-party mail archive](http://thread.gmane.org/gmane.comp.python.devel/95017).
Based on the article's conclusion, it seems like taking up Python as my first language may be more beneficial than I realized.
&gt;Jim also showed a number of demonstrations – all focused on Silverlight capabilities. From what I've seen of Silverlight so far, it looks like very cool technology. ...that will stop working properly on anything else than windows once it has gathered the necessary market share. That, or microsoft will start asking for royalties to distribute it, preventing linux distributions from shipping it.
"That is very cool and useful indeed. In all fairness, Perl 6 will have something like that." Fast forward two years later (2008), Perl 6 is very, very, very far from having a complete, production ready implementation. We can say that "Perl 6 will have" everything that has been made in the programming world, but it will never be stable. Ha! Perl 6 and Parrot will be out in the same time frame as the GNU Hurd and Duke Nukem Forever.
I'd say use PyGame. Anything "easier to use" is almost always going to be extremely limited or inflexible.. That said, it depends on what sort of game you want to make - if it's a side-scrolling spaceship game, PyGame is probably perfect, if you want to make a shiny modern FPS, well, mod an existing game (The Half Life 2 Source engine would probably the best option)
interesting, a very goood tool to understand the basic rendering techniques.
..and it's written in Japanese - even (badly-)translated by BabelFish, it is still more useful than the [offical Apple documentation](http://developer.apple.com/cocoa/pyobjc.html).. Most of the tutorials I have found are either for the Tiger dev tools (Xcode 2.5/PyObjC 1.4 and such). The RubyCocoa stuff is [far more up-to-date](http://developer.apple.com/documentation/Cocoa/Conceptual/RubyPythonCocoa/Articles/BuildingRubyCocoaAppl.html#//apple_ref/doc/uid/TP40005425-SW1), , and there are [many good tutorials](http://www.rubycocoa.com/) for it. I have found one [decent looking tutorial](http://www.macresearch.org/node/4527) for the right version of Xcode/IB/PyObjC/etc, but it basically gives you an entire, uncommented code, and seems to assume I have the slightest clue how they worked out how to write `NSThread.detachNewThreadSelector_toTarget_withObject_("queryController", self, None)` I don't find the examples in /Developer/Examples/Python/Cocoa/ that useful, especially because I find Interface Builder extremely unintuitive.. All I really need to know is how to send text from Python to a cocoa application, and get button clicks/text-box values.. I'm tempted to learn Ruby primarily because of the RubyCocoa tutorials, but I still prefer Python..
Another useful idiot who doesn't get it that Silverlight is a yet another poison pill, just as .Net. 
I have the same question.
The only downside to making Python your first language is that after you learn it, most other programming languages will seem ugly and cumbersome by comparison.
Awesome!
I cannot believe Panda3D is not on this list: http://panda3d.org/
What was the point in this 'article?' You may have well just linked us to the pygame website, while we wouldn't know why we're there I felt the same loss of purpose upon reading this blog post.
I wish I could vote this up 10,000 times. At work we have a python project and we wanted to add a Mac user interface. We'll probably end up doing it in wx just because the pyobjc docs are so bad. Since we really like the concept of pyobjc I have been given a week to make it work before we dump the idea.
The same could (easily) be said of Ruby by the way, they site pretty much at the same place on the power plane. On the other hand, it only gives you the option to greatly improve, either by going straight down to the metal (Forth, C), by straight up in the sky (Smalltalk) or by switching to a different plane of existence entirely (Erlang, Haskell, Lisps, maybe Factor?)
I originally wrote, "other programming languages". Then I remembered Ruby and added "most".
Probably because few people use it. Python programmers generally abhor vendor lock in. Not that Cocoa isn't nice, it's just not what they want.
There are much better tools than this to view meshes.
Does Wing IDE have the ability to use something like Vim for it's editor, or is the user stuck with vanilla text-editing?
interesting subject, very ppor quality blog post.
New version: http://pypi.python.org/pypi/pyke/0.3
Why submit it with the annoying frame? [link](http://pyke.sourceforge.net/using_pyke.html)
I believe they do have VI key bindings..
Key-bindings for movement, or full vim-like actions/functionality?
Fortunately, they also generally abhor stupid sweeping generalizations.
Obligatory, this is Google's example url: [http://application-id.appspot.com/](http://application-id.appspot.com/)
The documentation for this isn't really clear (to me) what the purpose of this is. It generates templates in some sort of generic way I gather, but I don't really understand what the intended use case is. Spitting out HTML? TeX? Anything? 
Any markup language is possible, but I've only ever seen HTML.
I have written a python script which spit out very simple TeX before, but I've never used or seen anything like this. Like I said, just trying to figure out the 'why'. For HTML, isn't there already standard libraries?
I believe it just allows for greater separation of data and presentation. What looks better: (in your main python script) print "&lt;html&gt;&lt;body&gt;&lt;ul&gt;" for person in people: print "&lt;li&gt;%s&lt;/li&gt;" % person print "&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;" Or: (this would be the separate template file) &lt;html&gt;&lt;body&gt;&lt;ul&gt; {% for person in people %} &lt;li&gt;{{person}}&lt;/li&gt; {% endfor %} &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; And then from inside python you would simply render the name of the template filename with the 'people' list as an argument. In the first case, if you wanted to change that 'ul' to an 'ol' you would have to edit your main python script, where in the second case you would just edit the template file while your 'main' program remains unchanged. As always, it is personal preference. For small, quick, and one-off scripts you can get away with using string templates in your code, but anything of any size and scope and using a template engine can be a real nice feature.
I'll buy that. Makes some sense. Thanks!
That'd suck since a lot of fun in Python is messing around with sockets. =)
Well, you can still do a lot of such things thanks to 127.0.0.1/local web servers and such To be honest, I've only used the socket library a few times, although I do use urllib constantly..
"%-20s" % string is enough for me.
and when it's not enough I've had good luck with text_table http://pypi.python.org/pypi/text_table/
Music in BASIC: 10 BEEP 20 GOTO 10
This looks interesting, has anyone used it for a project?
Reminds me of something I did with QBASIC way back when, something like: FOR x = 1 TO 30000 SOUND x, 2 NEXT x
i think just basic movement.. which is why I stick with ipython, vim and the good ol' bash..
I love python and I love making music on my computer. However, this guy would be a lot better off using PD to do the things he says he's trying to do.
Too vague. 
If memory serves, values below something like 100 were inaudible or maybe threw an illegal function call (at least on my machine). I used to make pretty neat effects with the following: FOR x = 100 TO 30000 SOUND x, 0.1 SOUND 30100-x, 0.1 NEXT x Another option was to use the PLAY statement, which actually played notes. PLAY "o3c55e-55g55c44e-55g55" Those were the days...
I think you are right about the lower limit. I was in high school when I last played with this stuff. All on 386 PCs running 3.1. After we discovered we could loop over an increasing frequency, we tried synchronising about a dozen or so computers (IIRC). Quite nasty when they all get in the higher range. Got a serious headache from playing with that for too long.
This is dumb. What if you want the side effect of running the function? As the comment suggests, if you want to keep the number of expensive operations down, do `[y for y in (expensive(x) for x in xs) if cond(y)]`.
This is because python tries to be consistent and favors explicit over implicit actions. Nowhere else [AFAIK] does python do any kind of implicit caching of the return value of functions so a python user would not expect it in the case of a list comprehension. If expensive_function() shows up twice in the list comprehension, a programmer would expect it to be called twice for each element in the sequence. 
Yes, it sometimes digs up good stories, but it's just random luck. It's ruining the signal to noise ratio. 
Yeah, clearly it is out-competing the humans! We must kill it!
Clear the dict when the thread dies?
that gets kind of complicated when you factor in exception handling.
What do you mean? What could cause an exception in checking if a key exists and deleting it?
Yeah, del dic[thread_id] doesn't seem so difficult?
No, the question is more where would you put the dictionary clearing code?
How is this meant to be used by others? Do we have to copy this script for every daemon we want to run? Any special setup/invocation? It'd be nice to have some sort of end-user documentation...
In the code the thread/program runs when the former terminates?
 def thread_fn(): tid = thread.get_ident() try: dic[tid] = "Some stuff" if rand.rand() % 2 == 0: raise Exception() # a) elif rand.rand() % 2 == 0: return # b) -- Just don't use it here else: pass # c) except: del dic[tid] # Handle a) else: del dic[tid] # Handle c)
Thanks for note, I added some usage notes: please look at README from latest commit ( http://evasive.ru/pyrunner/?f=f2149b0798da;file=README;style=gitweb ). Sample config file also commented.
Me neither, I'm using Panda3d for my project right now and it's awesome.
I don't understand gst, and that makes me frightened and angry. Who's got the pitchforks? 
Yeh Panda is great. Works on all platforms and beats out MANY C/C++ engines in production speed.
What's the reason for even carrying about it? Didn't microsoft tried that long time ago with their live pass? BTW: Personally, I really don't want my passwords to be centralized.
Nope. If the thread doesn't treat the exception, the whole program's toast, so whether we recycle the storage or not doesn't really matter.
Indeed. That's pretty weird, though: if there's an untreated critical condition somewhere in your process, it should terminate and avoid corrupting your data. .NET, Java and all the threading libraries for C++ act like this.
see also here: http://groups.google.com/group/django-developers/browse_thread/thread/43e025656481cfe6?hl=en and here: http://metajack.wordpress.com/2008/06/11/the-problem-with-django/ and here: http://www.reddit.com/info/6my4g/comments/
 The general release process will be: [...] * A final release. * A big fucking party. I think he should have written "fucking big party". 
I like it how it is...
Don't complain - they don't need an excuse to delay the release!
I'd be there if it wasn't gonna be such a sausage fest.
Good to know Django is getting a fire going for a stable release. We're evaluating it and 0.96 is hopelessly desynced from what will become the 1.0 release. Standardizing on 0.96 won't work, but the only other option is to track trunk.
There's an excellent cross-platform GUI builder for Python. It's called Glade. I've used it to build in-house software that was used in a production environment. With Python.
&gt;but the only other option is to track trunk. Which is what almost all Django developers are currently doing. It's quite safe to do so. 
Until they merge in one of the api breaking changes they are talking about. If I grab a version today that version will not be a stable snapshot which receives bug fixes. To get bug fixes I'd have to update to a new version at some point in the future. Some version which may or may not run my software.
Well damn, I'm working on almost exactly the same thing for Sugar's Develop IDE.
Anyone who thinks GLADE is all that great has never seen Delphi.
Guess you would have to read a bit instead of blindly doing an SVN update. Sucks!
Or maybe I don't care and just want to get the job done easily?
Oh, I understand that you just want to get your job done. But having used both, and being in the place to design and code a GUI designer, I'm basing it off Delphi rather than GLADE. So go ahead and get your job done instead of arguing with me on Reddit.
? That's my point. A stable release has bugfixes where you know you aren't going to experience any major breakage, but if I wanted to use django I'd need to review every change in a moving development platform to make sure it didn't subtly break my life.
You're mean.
Ummm... how so?
I would like to see more attention given to Tkinter in a GUI builder, with the native look improvements in Tk 8.5. I know Tk is no longer a popular platform, but it's advantage is as one of the included batteries.
Are these really coroutines, or just threads?
Sometimes when you reinvent the wheel, you can make it better.
I'm looking for a networking library to make a basic proxy-type application (I want the user to connect to my program and the program to connect to another server). I tried using asynchat but I ran into problems I don't remember now, and I currently use Twisted but I remember it being rather heavy/complicated. What would you suggest for this purpose?
They are generator-based coroutines.
 for record in [ r for r in db if r.name == 'pierre' ]: print record.name,record.age Since it checks to see if the name equals pierre in the python code, wouldn't it have to be querying for all records in the background?
That is also my question, it's either that or some **really** funky magic to turn that into a SELECT query. Can anyone elucidate?
It said that list comprehensions are not very efficient, compared to the 'select' method. So... although it allows pythonic syntax, if you want to really do anything, you need the 'select()' syntax which doesn't look that pythonic to me.
It's about a million times more Pythonic than using SQL. 
Erlang has something similar, using list comprehensions for database queries. You pass a list comprehension to the query compiler and then later execute it. Apparently the query compiler takes a list comprehension primitive and parses it somehow. Perhaps these fellows could do something similar by examining a... what's it called? Generator comprehension? for record in compile(r for r in db if r.name == 'pierre'): print record.name, record.age 
see: http://blog.vrplumber.com/index.php?/archives/236-PyOpenGL-3.0.0b3-without-a-Jukebox.html
The pythonic syntax would be something along the lines of: db = DB.open(…) query = db.query.compile(r for r in records if r.name == "pierre") for record in query.exec(): print record.name, record.age
generator expression
Discussed here: http://zcologia.com/news/771/feature-query-languages/
http://wxglade.sourceforge.net/ It's hardly the prettiest application ever, but I found is far more intuitive than trying to use Apple's Interface Builder and the utterly awful PyObjC documentation
Well, prior to 1.0 blindly applying a new release will likely break your stuff just as much as blindly doing an `svn up`, since there are APIs that aren't finalized and are changing. So to upgrade from one pre-1.0 release to another you'd need to read the release notes, the same way you'd want to read the list of backwards-incompatible changes on trunk if you were doing an `svn up`.
Someone posted this as some possible applications for newfound programming skills. http://projecteuler.net/index.php?section=problems My first project was a phonebook. My second project was a clock. 
OLPC software of course.
Make a [Chumby](http://www.chumby.com/) widget!
Write an MPD replacement that supports audio filtering plugins, incremental smart database updating and has a overall more extensible architecture.
See also: http://appliedprocrastination.blogspot.com/2008/06/pyrex-for-performance-and-obfuscation.html
I tend to just code up random ideas I have. For example, my computer is internally accessible at my University. One of my current projects is to make a http media player for my media library. Another project I am working on is a virtual machine for an embedded systems cpu that I've been using recently. 
Simply beautiful.
OS
This seems to be quite a common question among Python developers. I think it's a testament to how much fun the language is to use.
I'd hack on someone else's project. There's more things that exist but need love than which are unwritten. Virtual Machine Manager is python based, and could use a few GUI cleanups for starters. Or a GUI event manager for upstart.
Help out w/ Exaile, pls. :)
Cute concept, but a bit pricey for an alarm clock.
The live interpreter does not work for me in Firefox 2.0.0.14 on XP pro. I had to install the Silverlight 2 beta. When I click in the text box, a cursor appears, and when I press keys some info is displayed, but the interpreter does not seem to be interpreting my input. I tried the live demos on another voidspace page. They all seemed to work as expected. Edit: I tried Firefox in safe mode, and also IE7, with no success in either. 
http://shell.appspot.com
The GoogleCode page describes the project: "An interactive Python interpreter that runs in the browser, using Silverlight 2 and IronPython. This is ideal for tutorials and documentation, where example Python code can actually be tried in the browser." With technically fantastic projects like this, sometimes they appear to be solutions looking for a problem.
Desktop Twitter Client. All the ones I've seen suck.
Bots are the way of the future, should only ban bad ones.
Slight variation. Less interactive, more collaborative [http://codepad.org/](http://codepad.org/)
huh.. what? i forgot what i was going to say..
why not just embed that tiny wiki
See tutorial: http://projects.scipy.org/scipy/scikits/wiki/Optimization/tutorial
http://web.archive.org/web/20070219110715/unununium.org/introduction
Too bad it's dead :-/
Not sure which exactly you're referring to, but a lot of them need a server, which seems like overkill to me. What I really mean is something like Zim or Tomboy, but neither of those is KDE and therefore can't be used as a KPart. I actually have started to write this myself, but wouldn't complain if this guy did it instead.
Looks cool indeed, but it's way overpriced :|
When you say directory, you mean dictionary :)
RSS(or Atom) filter, with bayesian capabilities (and capable of deleting duplicate (same target link) items. Please inform me when it's done :-)
Can anybody who actually used it on real optimization problems tell us how does it compare to [cvxopt](http://abel.ee.ucla.edu/cvxopt) and [cvxmod](http://cvxmod.net/)?
Neat idea, feels snappy and useful. A bit unstable though as it kept crashing for me if I backspaced one too many times..
This is interesting, but only if renamed from "decadence" to "electricity consumption per capita". Calling that decadence is preposterous.
D&amp;D networked battlemap. Need not use any game system mechanics, so as to be system neutral. Should feature: Import figurine images, draw/save/load maps, customizable icon badges for representing status effects, persistent notes for figures on the map, hidden map elements, etc. Could be written as a desktop app or a web app (Django?) 
This is excellent, thanks for sharing the link. Looks like a great shell for [pylab](http://www.scipy.org/PyLab) or [scapy](http://www.secdev.org/projects/scapy/) although the last crashes upon import in bpython.
Is it better than ipython?
I wonder if this'd be noticeably shorter+more readable if it used [BeautifulSoup](http://crummy.com/software/BeautifulSoup) instead of regexes. 
what does it actually have to do? can't you just use curl like a real man?
Especially because countries like Iceland experience 6 months of darkness and 12 months of cold.
Hi, I'm the author of bpython. The bugs listed above have both been reported to me and fixed. Thanks for the interest in bpython. :-)
UI-wise yes, it's much better as you get syntax highlighting and suggestions as you type in real time. However it does not feature the ipython specific commands. You really should try it, it is very easy to install and no description nor screenshot can really describe the experience you feel using it. I wonder if ipython could reuse the work done on bpython on the UI side while preserving the ipython command set.
I *can* but that doesn't stop me from being lazy and not wanting to. And I'm honestly surprised that there's pretty much nothing out there.
Awesome! Ncurses is so freaking amazing. I love seeing new applications of such a mature library.
Yeah, I noticed that the countries were either really cold, or really hot, or Belgium.
Will this work in Windows?
just write a bash script
Why, Pylons is better. :P
Hi, thanks for the great software! Little question: is it possible to edit a previous block of commands? Editing it line by line isn't very practical... Ipython does offer to do this, even if it doesn't work perfectly.
Work on improving its documentation, then.
Pylon not Python
It should work under cygwin. I haven't tried it.
Excellent.. thanks for the time you put into this :)
Hey again. Just downloaded 0.4.1 and it still has the same bug. How to reproduce: - start bpython - press ctrl+f (^F is output) - press backspace twice, the second one will raise an IndexError This is on OS-X. Here's the traceback: Traceback (most recent call last): File "/usr/local/bin/bpython", line 1342, in &lt;module&gt; o = curses.wrapper( main ) File "/System/Library/Frameworks/Python.framework/Versions/2.5/lib/python2.5/curses/wrapper.py", line 44, in wrapper return func(stdscr, *args, **kwds) File "/usr/local/bin/bpython", line 1337, in main repl.repl() File "/usr/local/bin/bpython", line 713, in repl inp = self.get_line() File "/usr/local/bin/bpython", line 1066, in get_line if self.p_key() is None: File "/usr/local/bin/bpython", line 869, in p_key self.bs() File "/usr/local/bin/bpython", line 832, in bs if self.s[-1] == '\t': IndexError: string index out of range
Doesn't look as pretty.
D-bus appears to be rather cool actually. Yay scripting of graphical applications!
Enlightenment comes to those who seek it. :) But in all seriousness, the Pylons community is very helpful on the mailing lists and IRC. 
this is perfect for me. A beginner to python looking for some real world practice techniques. What could be better than making a few games from scratch. Great find!
I think a command line tool would look prettier than some amateur attempt at a GUI
Why does this need a PEP? Couldn't this easily be constructed in Python code without any need to add it to the language?
Possibly, taken by itself. But I use lots of other GUI apps and a terminal emulator is unwieldy for things other than actual doing-it-right-now work. Also can't be put in the system tray.
gmrun + custom bash script
Already using ternary expressions: &gt; return max(karma, 1) if karma &gt; -1000 else karma
also, grep for TODO, there's lots more than is on the Trac.
On the other hand, they're still throwing strings &gt; if c.errors.errors: print "fucker" raise "broken"
to be fair, it's prefixed `#TODO`. They do it in one other place too: &gt; r2/r2/lib/db/thing.py &gt; 1040: raise "The sorts should be the same"
I want the illegal python books.
This looks useful: http://code.reddit.com/browser/r2/supervise_watcher.py
Time to *finally* fix that broken url regex that kills wikipedia links with parens: [filters.py](http://code.reddit.com/browser/r2/r2/lib/filters.py): &gt; r_url = re.compile('(?&lt;![\(\[])(http://[^\s\'\"\]\)]+)')
That was the first thing that caught my eye, actually, though I haven't read it yet.
Oh boy: &gt; ~/reddit/r2$ pylint r2 | wc &gt; 10303 64377 562403 A large amount of those, though, appear to be caused by: &gt; ~/reddit/r2$ ack --noheading "import \\*" | wc &gt; 58 240 3118
Not python, but it's great that they rewrote most of the [html sanitizing in c](http://code.reddit.com/browser/r2/r2/lib/c/filters.c). That is actually the slowest part of a site that I was profiling recently that spits out big pages.
Wouldn't it be better to just sanitise it upon submission rather than rewriting it in C so that you can do it on every page view? The worst case scenario is that you find a flaw in your sanitisation, but then you just set the sanitised field to null and repopulate it lazily.
1. It's far easier to verify that you have escaped something properly when you do it at the last minute than to be sure that you never put unescaped data in by accident somewhere way down the line. Instead of multiple points of failure, just one. Simpler code. 2. It took months for there to be enough content on the big pages for this to take up more than a few milliseconds. 3. Database writes were by far the biggest bottleneck. So writing everything in both forms could lead to a major decrease in performance. The avalanche effect of when you need to suddenly change the filtering compounds this problem... 4. You can use multiple filters for different users. Eg anti-profanity, no-images, plaintext, all without having to store N times more copies in the database.
&gt; It's far easier to verify that you have escaped something properly when you do it at the last minute than to be sure that you never put unescaped data in by accident somewhere way down the line. Instead of multiple points of failure, just one. I don't agree here. It's relatively common to store safe content in a database. It's no extra burden for one more field to be safe. And you don't have one point of failure when you sanitise on demand, you have a point of failure everywhere you output the content. Perhaps if your site only has one page where a particular field is displayed, that equates to a single point of failure, but Reddit isn't like that. &gt; Simpler code. Not when you have to resort to rewriting things in C. &gt; It took months for there to be enough content on the big pages for this to take up more than a few miliseconds. Aren't we discussing an alternative to rewriting in C? If you don't need the extra speed, then don't do either, obviously. &gt; Database writes were by far the biggest bottleneck. That would make my suggestion a bad choice, sure. But if database writes are your biggest bottleneck, rewriting things in C isn't going to help you. 
&gt; you have a point of failure everywhere you output the content. Nah, the templating system for my sites is setup to sanitize by default every time you output some $data. It takes a whole bunch of extra fooling around to force it to output unescaped. As it should be! (Cue PHP guys...) &gt; if database writes are biggest bottleneck, rewriting things in C isn't going to help you. Not pre-sanitizing =&gt; zero database writes for sanitized content.
&gt; &gt; if database writes are biggest bottleneck, rewriting things in C isn't going to help you. &gt; Not pre-sanitizing =&gt; zero database writes for sanitized content. Either I'm not understanding you or you're not understanding me. My suggestion was an alternative to rewriting things in C. Why would you rewrite things in C when database writes are your bottleneck? 
I think pylint's default settings are way too sensitive. Doesn't it complain for each and every module/class/method/function that doesn't have a docstring too?
Every time you make one of these tradeoffs, the bottleneck can shift. I'm just laying out how everything has fallen into place in my past few experiences. It will depend greatly on your numbers and predictions. Profile Profile Profile. There are also multiple critical paths that you have to balance. Database writes were not the hot spot for regular page views. If you are suggesting keeping sanitized versions in the database then that would shift the biggest hot spot to database writes, in my case. If you suggest keeping it in RAM, that's an option, although in this case I was really short on RAM and it was an expensive resource that I needed more for database catching due to the particular situation. 
oh yeah, it's super sensitive, that doesn't represent 10000 defects at all.
Most of the names appearing until 2000 are well known bastions of the Python world. Poor Guido toils alone from '90 till '92, when he is joined by Sjoerd Mullender and Jack Jansen, both also at CWI. Barry Warsaw starts commiting in '94, followed by Fred Drake in '95, Jeremy Hilton and rmasse(?) in '97 and Andrew Kuchlin in '98. Most of Python up to the landmark 1.5.2 release in '99 was created by just these eight guys. Four more people join in '99, and then all hell breaks loose in 2000, when Python really takes off. Beautiful!
Why is raising a string deprecated? It's very useful for quick n' dirty stuff.
&gt; Why is raising a string deprecated? Ugly and not really useful, as far as I know. And makes catching fairly annoying. It was one of GvR's [Python Regrets](http://www.python.org/doc/essays/ppt/regrets/PythonRegrets.pdf). Also it fit in well with the rework of the exception hierarchy and the creation of the Exception base class. &gt; It's very useful for quick n' dirty stuff. It's not like writing raise Exception(your_string) instead is much of a chore.
I like them for that too... the [PEP](http://www.python.org/dev/peps/pep-0352/) lays out GvR's reasoning. (edited to show the PEP instead of a weak-sauce mailing list thread)
I found this while looking for more information on "generator" objects, as can be created with: `[i/0.5 for i in range(5)]` unfortunately I never found more information on that... does anyone have any?
"list comprehensions" on [this page](http://jaynes.colorado.edu/PythonIdioms.html#idioms_readable)
thank you!
Very good argument. And probably a good complement to the PyGame stuff for pure beginners. 
Join the [feature request](http://www.reddit.com/r/featurerequest) subreddit to leave suggestions for people on fixing reddit up!
implementation of a technique for new scientific hypotheses from literature: "Literature-based discovery (LBD) is a method for automatically generating hypotheses for scientific research by finding overlooked implicit connections in the research literature. Discoveries have the form of relations between two primary concepts, for example a drug as a treatment for a disease or a gene as the cause of a disease. Swanson [1] introduced a paradigm in which such relations are discovered in bibliographic databases by uncovering a third concept (such as a physiologic function) that is related to both the drug and the disease. The discovery of the third concept allows a relation between the primary concepts, which was latent in the literature, to become explicit, thus constituting a potential discovery." http://www.pubmedcentral.nih.gov/articlerender.fcgi?artid=1839258 from what i know , all major implementations are for biomedical area , and some innovations have been made using it. 
I'm going to put in a word for javascript (/ecmascript). The syntax isn't too weird, hello world is "alert('hello world');", you can do real, useful stuff with it without jumping through lots of hoops. Not just in your browser (although that's a pretty useful place), but also on the server and in your scripts (cf. http://code.google.com/p/jslibs/). I agree that python is a great candidate, but I think ecmascript is an even better one.
Instead of &gt; while 1: you should do &gt; while True: 
Luckily it's hella configurable.
Good examples. However, just in case anyone decides to run in and use them blindly, do note that some are not very efficient (e.g. his sieve). 
Not really: http://google.com/codesearch?q=lang%3Apython+while\+1%3A - 66k results http://google.com/codesearch?q=lang%3Apython+while\+True%3A - 31k results 
Also, now that "reduce" is going to be relegated in python3k, this code: &gt;sum = reduce(add, data) should be rewritten as sum(data). Is there a "non-reduce" method of doing: &gt;product = reduce(mul, data) ?
Frankly, not the best book for beginners. Especially if this is their first scripting language. Great book once you know some Python, though. 
except good... well mostly
&gt; `handle = open('/etc/hostname', 'r')` &gt; `host = handle.read().strip('\n')` &gt; `handle.close()` Seems fragile. What's the benefit of this over `platform.node()`/`socket.getfqdn()`/`socket.gethostname()`? 
to be sure, "alert('hello world')" is apart of the DOM API which isn't an intrinsic component of ECMAscript.
I thought using "1" as "true" was somewhat "deprecated" now that we have explicit boolean Types. 
I think the main point is that javascript behavior is inconsistent across the context of multiple browser sub-system implementations. This is the number one reason why javascript frameworks are successful while general javascript programming is not (the framework methods are usually modestly well tested across the browser biodiversity). With Python frameworks add value beyond behavioral consistency. That said, if you're programming for a homogeneous environment then it can be a pretty good thing (a la ecma windows login scripting). 
If you could make it ignore underscores in URLs for italics, too, that would be great. Thanks.
i'm wondering the same thing.
A Teacher of mine actually made the same comparison after I handed in a math problem I solved by writing a python program. 
&gt; I think the main point is that javascript behavior is inconsistent across the context of multiple browser sub-system implementations. Ahhhh, who cares. when I think of BASIC equivalents I think of my 7 year-old daughter and my own Apple II experience back in the day - something fun for playing around and learning. Check out [NodeBox](http://nodebox.net/code/index.php/Home) on the Mac though - it's almost the perfect thing. Perhaps [processing.js](http://ejohn.org/blog/processingjs/) will be good for this purpose as well.
One would hope.
 &gt; Use map and/or filter to apply functions to lists. List comprehensions are even more pythonic.
&gt; Is there a "non-reduce" method of doing: from functools import reduce product = reduce(mul, data) good enough for me.
if you already have the function to apply, map/filter is simpler dans less verbose e.g. result = map(func, input) versus result = [func(i) for i in input] If, on the other hand, you're building the transforming/filtering function inline you'll often be better off with listcomps (due to python's lambda sucking dicks)
This is the most amazing code ever written.
Usually not, but importing may take time, that's why command line tools like Mercurial or Bazaar-ng have lazy importers. They make a real difference in usability.
The last point makes me think he is more into java...
You're right, bots _are_ the future. So, let's ban humans instead!
With some heavy modules it's extremely sensible though e.g. `import wx` bumps your memory usage from 1Mb to ~25Mb and takes several seconds
&gt; Catch errors rather than avoiding them to avoid cluttering your code with special cases. [snip] &gt; Worse: #check whether int conversion will raise an error if not isinstance(s, str) or not s.isdigit: return None elif len(s) &gt; 10: #too many digits for int conversion return None else: return int(str) &gt; Better: try: return int(str) except (TypeError, ValueError, OverflowError): #int conversion failed return None This is wrong isn't it? Try - Catch performs a complex jump (like an unpredictable GOTO does) and is strongly condemned. Exceptions are for unpredictable scenarios like a failed disk or network connection..not for telling you a string isn't a number. It's used by poor programmers (throw "UserClickedCancelException") rather than designing software properly. Anyone who takes the later approach in my eyes is a hack. 
This article is 4 years old and uses python 2.2 Not that there's anything wrong with that.
&gt; This is wrong isn't it? Not in python, no. &gt; Exceptions are for unpredictable scenarios like a failed disk or network connection..not for telling you a string isn't a number. In Java maybe, in Python not at all. For example, the iteration protocol specifies that calling `next()` after the end of iteration raises `StopIteration`, and *this is the only specified way to end an iteration*. There is no equivalent to e.g. Java's `hasNext`. This essentially comes from one principle of the "Python Aesthetics" not spelled in the Zen of Python: EAFP. it is Easier to Ask Forgiveness than it is to get Permission. This principle is at the core of both Python's syntax and semantics themselves and the principles for "pythonic" code. edit: it's `StopIteration` not the original `IterationError` i'd mistakenly written. Thanks bgeron for correcting me.
What's wrong with: &gt; list.sort(reverse=True) ?
&gt;Flash and ActionScript are not the new BASIC. A huge financial cost up front WTF. It's free and open source. You can write flash(actionscript) in notepad and [compile via the command line](http://labs.adobe.com/technologies/flex/sdk/flex3sdk.html). I don't disagree with the general premise, but thought I'd point out this misnomer. THE [VM](http://www.mozilla.org/projects/tamarin/) and [SWF file formats](http://www.adobe.com/openscreenproject/) are also OSS. It has the same syntactical hurdles as Java, but lets not spread misinformation. You know what I've been liking for teaching kids? Squeak (Smalltalk). Maybe it's just the book I got, [Learn Programming with Robots](http://www.amazon.com/Squeak-Programming-Robots-Technology-Action/dp/1590594916), but this language is really cool, OO, and has a shallow learning curve. I'd love to see something like [Hackety Hack](http://hacketyhack.net/) or Squeak for Python. IDLE is nice and all, but for kids, it would be nice to have some LOGO style turtle graphics interface where they could get feedback.
Yeah the basic eratosthenes sieve implementation in Python is pretty slow. There are ways of speeding it up though. It's fun to play with, I suggest searching the net for other python examples around the sieve of eratosthenes and the euler accelerator. I have a compilation file here, I do not claim authorship to any of the code, use at your own risk: http://cid-bc37bd8e49a19051.skydrive.live.com/browse.aspx/Public Hope this helps anyone interested in Python generators. 
Pretentious much? You seem to be looking through the lens of another language. This is accepted and recommended practice in python.
eh, python 3000 sounds so lame. Python is sophisticated. It's above dumb space age names like "3000"
If you're building a list, use the list comprehension. If you're just calling func for side effects then I'd be more inclined to use a full for loop.
&gt; If you're building a list, use the list comprehension. no. &gt; If you're just calling func for side effects then map's ok No it's not, map is a collection transformation HoF, not a side-effect calling one.
I've never liked `urllib` etc. For a start, it's in the standard library. Calling something in the stdlib {foo}lib is redundant. There's also the fact that it's usually used for things other than dealing with URLs. Typical use is fetching resources over HTTP. So the name "urllib" is poor on both counts, "url" *and* "lib". If `urllib` etc are going to be refactored, I don't see why a `www` package shouldn't be created. Stick the URI-specific things in `www.uri`, the HTTP-specific things in `www.http` and so on. It makes a hell of a lot more sense than naming everything remotely to do with the web "urllib". Do functions for parsing `robots.txt` really come under "URLs"? 
I advise that you send an email out to the [py3k](http://mail.python.org/mailman/listinfo/python-3000/) mailing list. After you search for previous discussion, natch.
You know it's already named after the guys who made [this sketch](http://youtube.com/watch?v=G6D1YI-41ao) right?
Good luck. I'm not there, and it doesn't look like the other actual employees are.
The render-cache caches it after sanitising/compressing anyway.
I doubt it would make much difference, this approach seems to have already been decided. From [PEP 3108](http://www.python.org/dev/peps/pep-3108/#urllib-package-todo): &gt; Originally this new package was to be named `url`, but because of the common use of the name as a variable, it has been deemed better to keep the name `urllib` and instead shift existing modules around into a new package. That just seems like a case of the tail wagging the dog to me. An `http` top-level package has already been created too, but I don't see how that doesn't make parts of `urllib` redundant. (Aside: I use variables named `http` all the time, but I wouldn't ever use that as an excuse to call a stdlib package for dealing with HTTP anything other than "http"). 
I use the one [here](http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/117119) (or one from the comments - I don't remember). 
*shrug* I find it hard to get worked up about issues like this.
could still serve as an idea queue for random hackers to pull suggestions, implement and submit as patches
Am I looking through the lens of another language? Or am I merely looking at Python through the lens of a Software Engineer, someone who thinks that data structures are important - and a language that says "These 3 are enough" doesn't cut it as a professional tool on any non-trivial projects? It's like telling an architect that all his building must be made from bricks for simplicity, rather than choosing different tools and techniques which suit the problem most effectively.
Didn't Guido say he was thinking about adding product so there wouldn't much need anymore for reduce? I wonder if that's the case and if it was added in 2.6 or only in 3k.
&gt; .. `IterationError` .. Nitpick: it's `StopIteration`, because it's an exception, not an error :)
Sure, and there's nothing wrong with that. If it's actually used that way, fantastic :)
Dammit, you're of course right, I was sure it wasn't that but too lazy to check :( The post has been edited
&gt; Am I looking through the lens of another language? Or am I merely looking at Python through the lens of a Software Engineer You are looking through the lens of another language.
&gt; Didn't Guido say he was thinking about adding product so there wouldn't much need anymore for reduce? It's not impossible, but I've never heard of that. Doesn't change the fact that reduce can still be obtained from `functools` in the future. And I expect that module to be significantly fleshed out (and become an integral part of my pythonista arsenal) in the future, so I'll probably (and despite it being bad form) have quite a few `from functools import *` post Python-3.0
That only came in in Python 2.4. He's teaching new dogs old tricks. The essays's old (beginning of 2007), but he's talking about Python 2.5 so I dunno :/ I thought the same for sorting on different keys (sort(key=..)), for which he uses the decorator pattern. The [Python Style Guide](http://www.python.org/dev/peps/pep-0008) is a useful related page.
That very first idiom is one of the reasons I find Python confusing compared to Ruby. He states: &gt; join is a string method called on the separator, not the list Are you joining a bunch of separators together? No. In the case of the empty string is it intuitive to think that we want to join the empty string? No, we want to join the list together. Why would join be a method on a string and not the list? And then there's all the global functions instead of object methods. Why isn't len a method on list? As dude pointed out in the [Python is the new Basic](http://coffeeghost.net/2008/06/18/python-is-the-new-basic/) article comments: * mylist = [1,3,2] * print len( mylist ) * print sorted( mylist ) * print mylist.sort() * print mylist.reverse() * print mylist[0] These different syntaxes for related ideas are very obfuscated. Is Python 3000 fixing any of this?
That's a really useless comment if you won't elaborate. I appreciate that all languages fill or attempt to fill different niches or areas of development and that there are different styles with different pros and cons. My argument is that Try Catch blocks are plucked straight out of other languages who don't take this approach with their use. This isn't the fact it's a different language - those are the same keywords with the same meaning. Why is this acceptable in one language and not in another? My conclusion is that Python developers simply don't care to build an application correctly or efficiently and are happy to live in the environment of "throw it together" and "do the simplest to get it working". Whilst that's not a bad approach, it's not "true" software engineering.
Just don't use map. It is un-pythonic as epicRelic said. It is much less versatile and has no advantages except if you're extremely lazy. Plus it's harder to see in the code if you're scanning quickly. 
I don't think it's bad form. They were moved out because they weren't used in most scripts and thus cluttering the builtin namespace but they aren't second class citizens.
&gt; That's a really useless comment if you won't elaborate. There is nothing to elaborate, you're speaking in the light of your previous experience and Python doesn't fit what you learned there on this point, that's all there is to it. &gt; My argument is that Try Catch blocks are plucked straight out of other languages who don't take this approach with their use. Yes, and it's devoid of interest. &gt; Why is this acceptable in one language and not in another? Because the languages are different, follow different philosophies and have different base principles? Or maybe because other languages had it wrong? Or because Python programmers usually strive for readability, correctness and simplicity first, and only bother with efficiency if that becomes an issue? More clearly spelled, in Python the word "exception" is taken as "exceptional case", not just "error" as it might be in e.g. Java. You consider that to be Very Bad? Fine with me, just don't code in Python.
&gt; I don't think it's bad form. As a rule of thumb, `from module import *` is considered bad form because it clutters the global namespace (with a lot of potential junk) and doesn't clearly spell what exactly was desirable from that namespace. The usual suggestion is to either use a regular `import module`, potentially aliased as e.g. `import module as m`, or to clearly spell what's imported (`from module import foo, bar, baz`) That's what I was talking about when I said it was bad form, not the import of `reduce` or `partial` from functools.
Its much better to sanitize data before being consumed. For example checking for SQL injections before insertions &amp; checking for XSS before being displayed. Since you are preserving core data with out any modification it becomes much simpler to add future sanitation rules. Other wise if future sanitation rules change then you have to clean data in two places incoming data &amp; already stored data.
Abusing it is bad form but doing it for one module you massively use is okay in my book. Although, I'd probably use "import functools as ft" as a compromise to save some typing and stay as clean as possible.
I'm not talking about the origin of "Python" the name, I'm talking about the python language. Python, the language, has class. Adding "3000" to it just makes it childish.
That's not permanent. The name is Python 3, or Python 3.0. While still in this phase, it is referred to as Python 3000 or Py3k.
GvR stated that they're calling it Python 3000 to make of joke of adding big numbers to software names, a la Windows 2000
The joke is that it's guaranteed to be delivered early; a thousand years is enough time to make a new version that isn't backwards compatible _and_ has sufficient tools and tricks so the installed base doesn't suffer upgrade pains. "God created the world in 7 days, but he didn't have an installed base." -- [allegedly Benn Konsynski](http://www.espen.com/links.htm)
That's all I think it's going to be. For interaction with the devs, you'll want the /r/redditdev EDIT: D'oh, sorry, ketralnis, didn't realize it was you...
&gt;in Python the word "exception" is taken as "exceptional case", not just "error" That's the key point. Off-topic: Is it true that when the "try/catch" block was first "invented", it was intended to be used for "exceptions", not just for "errors"? I was also told that throwing exceptions in Java is "deliberately" expensive so that it is used sparingly. Any truth in any of these statements?
Here's an [updated version](http://github.com/ludwig/examples/tree/master/python/misc/complexity) without those unicode quote marks, and with a couple of fixes to the perl scripts. Seems to run fine on itself, at least.
It's a pretty graphic, but not terribly informative. Tufte would be unimpressed.
Hi everyone. I'm a baby Python, and I'm trying to figure out which web framework is the best to study in my free time. From checking [Google Trends](http://www.google.com/trends?q=Django%2C+Pylons%2C+TurboGears%2C+Zope), I can tell that Zope started out strong, but the momentum seems to now be with Django. Interestingly, [Reddit is written with Pylons](http://blog.reddit.com/2008/06/reddit-goes-open-source.html). What's your opinion on which framework is best, and why? Also, which is easiest to learn, and which is more commercially successful (you can find a job doing it)? Thanks!!
What I hate about optparse is that you can't run it like this: myscript.py --help it has to be: python myscript.py --help The script will run fine the other way, it's just that optparse doesn't function properly under those conditions.
OMG! PyPy can actually run python software!! (Twisted ain't that small a beast)
I fear I don't know, but I shall try to remember this during my future bouts of procrastination in order to make believe I'm doing something useful (cause it's an interesting question)
Succinct but cryptic. I'm pretty sure a beginner Python programmer will have a hard time following the code in this file. I've done something similar in bash and perl , which also wasn't pretty to look at for other developers. 
The suit-yourself answer: http://scholar.google.nl/scholar?q=cyclomatic+complexity Sort by recent articles to get some of the review-papers that mention mistakes and proper uses of cyclomatic complexity.
Heh, I also saw that and thought, wow. This is a cool data structure.
There is also some tiny bit of information in the [Coverity Scan report](http://scan.coverity.com/). Mostly that CC has a high correlation with codebase size. 
Silverlight is a no-no for me. Altogether it sounds like a good effort.
Glade and pygtk2. It does a real good job.
Wow, I just noticed that. 
Global variables? WTF.
This is not exactly what I'd call pythonic code. Edit: &gt; I started experimenting with Python a few weeks ago. [...] I was very please with the result. Writing Python is like a dream. Oh, ok - fair enough. Man will you be impressed when you see what Python is really capabable of.
The Python Tutorial?
I would like to make a Python program that would use a library written in C++. There seem to be several ways to do this from what I've read * boost.python * SWIG * Pyrex * Python's C API * ctypes What would be the simplest way to make the library available to Python? I do not intend to modify the library itself if that helps.
They get shit done. What your code smells like roses the first time?
Why post your first time? Clean it up first.
Ask Python? &gt; &lt;Sonium&gt; someone speak python here? &gt; &lt;lucky&gt; HHHHHSSSSSHSSS &gt; &lt;lucky&gt; SSSSS &gt; &lt;Sonium&gt; the programming language http://www.bash.org/?400459
I enjoyed the http://www.pythonchallenge.com/ 
Moreover, in Python 3.0, `map` is replaced with `imap`, so the side effects won't be invoked without something like `list(map(f, l))`, which is gross.
The [Python Phrasebook](http://www.amazon.com/Python-Phrasebook-Developers-Library-Dayley/dp/0672329107) isn't bad if you have experience with other programming languages, and it's small enough to carry around. Also, [Dive Into Python](http://www.diveintopython.org/) is really good. If your friend has zero programming experience [How to Think Like a Computer Scientist](http://openbookproject.net//thinkCSpy/) is very good.
By convention, in Python mutators return `None`. (Actually, any time you end a function without a `return` statement or a `return` statement not followed by a value, the function implicitly returns `None`.) That's why `print mylist.sort()` fails. It's a little weird a first, but you get used to it. In the end, it's good because it teaches you what happens in place and what makes a copy, but yeah, it takes a little time to get used to.
ctypes! Couldn't be easier than that. I've always used it with C API's, not sure if the C++ API you're using will be much different. http://python.net/crew/theller/ctypes/tutorial.html
Square brackets make list comprehensions; parentheses make generator expressions.
But then how will we ever get any amusement from discussions about the many insanely_named_functions in PHP?
I got the "three big bodyguards on each side" but gave up. When exactly do you do some Python?
Seconded. I'd never recommend Dive Into Python as a starter - especially for one who has no experience with scripting languages. It's better to read once you have some of the basics. 
ctypes might be out, because of [name mangling](http://blog.vrplumber.com/index.php?/archives/197-Ctypes-for-C++-is-going-to-be-a-pain-due-to-politics-Bothering-language-creators-is-fun....html). Boost is pretty good -- the error messages can be a bit difficult to interpret -- but if you want to use NumPy, and don't mind hand-writing some code, [SWIG](http://www.swig.org/) might be your best bet. (An upside of using SWIG over Boost is that you can distribute *just* the generated code with SWIG, whereas Boost requires headers and libraries, I believe.) Often overlooked is [SIP](http://www.riverbankcomputing.co.uk/software/sip/intro), which is designed to be a lighterweight, Python-specific alternative to SWIG. The documentation for SIP has traditionally been a bit sparse, in my limited experience, but the applications of SIP in the PyKDE and PyQT projects are comprehensive, and easy to follow.
Yup ;) I thought about that while reading it, and couldn't see that it detracted significantly
got an example of a generator expression?
Thirded; the 2nd edition of this book was my most valuable resource in learning Python. I would also agree that Dive Into Python was a little too advanced imo if you have never programmed before. It is free to download however.
It certainly got me interested in python and I liked reading it after I had read "Learning Python", but I wouldn't recommend it without mentioning some other books as well. 
What are you doing? Your "timing" test is more likely to measure startup time of the interpreter than anything to do with your actual algorithm. You need a test that takes substantially longer than 0.01 seconds if you're going to do your timings from the shell like that. 
nice links thanks, but whats up with the font in How to Think Like a Computer Scientist... makes it very hard to read.
So down mod me because I think it was a bad decision?
I'd say it's a bit too much for even those who have programming experience - but only in languages like C, C++ and Java. (At least that was my experience).
Hmm, no idea. It looks fine on my Mac/Windows/Linux boxes with Firefox 3 and the same with Safari on my Mac.
hmm using ff3 on linux, i grabbed the source so ill just mess around with the stylesheet.
`(i/0.5 for i in range(5))` 
First.. see if it can be done with ctypes - that's magnitudes easier than the other methods. If that doesn't work, I'd have alook at boost. Otherwise, if the library is small and you have some time, the Python C API is quite simple.
Dive isn't good as a starter, but the Python Tutorial is all that's needed as a preface.
The answer to this question really depends on what sort of access you need. If you are black-boxing the c++ library (e.g. calling the standard API and expecting standard C data types are return values, not dicking around with internal library bits) and have access to the source then you should write a c shim that externs the bits you need and call that from ctypes. If you need to dig into the library or want python to access and pass around objects that this library understands then you should look at boost.python or cython (a more bleeding-edge version of pyrex that has some c++ support). Check out [the cython wiki](http://wiki.cython.org/WrappingCPlusPlus) for more info.
If you are doing math/number-crunching and NumPy is in the mix then you should also check out [SAGE](http://www.sagemath.org), which has a mix of numpy, pyrex, and a lot of the better math libraries already packaged up for you to use. 
ctypes blows goats when it comes to c++. The name-mangling makes it a nightmare to use. If you are interfacing with c it is always the first choice, but if you need c++ then you will really need to write a c shim to your c++ library if you want to consider ctypes. 
That said, Dive Into Python is a great book to have lying around on your hard drive. Of course, if you're using Ubuntu, it's in the default install. But really, O'Reilly's Learning Python and Programming Python cover about 90% of what you'll ever need. Django, Zope, and Plone require other documentation above and beyond what those two titles provide. About the one thing you won't learn from those two books that I would like to know is how to use the PyObjC bindings, but currently, that's a lost cause unless you speak Japanese, as the documentation for that particular set of bindings is in poor condition.
I learned Python from How to Think Like a Computer Scientist myself. That's actually a pretty good book, and as with Dive Into Python, it's totally free.
If your friend has programmed in other languages, then I'd consider the mightily comprehensive "Python Essential Reference". It could be the only Python book he'll ever need.
I'm with seabre on this one. All three suggestions are great. I also would add one thing. Screencasts are great ways to learn. Go to ShowMeDo.com for some good python ones and also check out the goofy but fun tutorials here by Chieh: http://awurl.com/gauenu93848 (go down to the highlighted part)
upvoted for SIP.
Quick and dirty stuff has a tendency to become permanent. And one day, you'll end up with this: &gt;&gt;&gt; MyError 'MyError' &gt;&gt;&gt; try: ... raise "MyError" ... except MyError: ... print "got it!" ... Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt; MyError The reason for this is that string exceptions are compared by identity rather than value: &gt; An object is compatible with an exception if it is the class or a base class of the exception object, a tuple containing an item compatible with the exception, or, in the (deprecated) case of string exceptions, is the raised string itself (note that the object identities must match, i.e. _it must be the same string object, not just a string with the same value_). &gt; http://docs.python.org/ref/try.html
it's great for newbiews trying to learn how to write an interpreter... maybe not the best practices... but it works.
Don't think I recall downmodding you or having any intent to do so as my post was explantory
Just for my own edification- what areas aren't very pythonic? I was pretty impressed with the "cleanliness" of this guy's code. What kinds of things would you change? Can you give examples? Or anyone else? Thanks! 
now, that's what I call system abuse. Lets chain 200000 App's and calculate pi to the 9999999999999999 digit
This is very exciting. Having a solid, modern implementation of Python on the JVM will make be consider Python as a viable way to write apps there. It will be interesting to see how the performance of Jython compares with IronPython as it nears completion. 
Ok, thanks guys, your input is really appreciated. After posting this I read through some of the other posts in this subreddit and came across the one that had some great free resources. I considered pulling this down but thought, "nah, I'll leave it up there to get some good opinions". I'll pass along O'Reilly. I had a browse through the PDF and it looks great.
Thansk seabre and chip!
This is especially exciting now that Java is fully open-source and that the [OpenJDK is fully compatible with java](http://blog.softwhere.org/archives/196)
When you use **map**, your code will fetch the function object only once, instead for each iteration. This is often faster. If the function object is a built-in, code using map can be a lot faster. Using map with **lambda** is a always a lousy idea, though (unless you're writing code that has to run on really old interpreters).
&gt; Why would join be a method on a string and not the list? Python lists are heterogenous containers. Python's string **join** only works on strings, but works with arbitrary sequences and iterables. Making it a string method instead of a list method gives you a lot more bang for the buck. (imho, **join** should have been a built-in function, but that's another story.)
Nice! Can the cookbook recipes be simply updated, or should a new one be created each time ?
The Python community has gone a bit overboard with porting to new platforms.
I would avoid using the registry for anything because it decreases portability.
Ain't pyglet's [vertex lists](http://pyglet.org/doc/1.1/programming_guide/vertex_lists.html) just about the same thing?
Discussed here: http://oubiwann.blogspot.com/2008/06/txloadbalancer.html
I haven't programmer extensively in Python, but I do know that the first issue is a case of the author not knowing enough about the language. You can rewrite the empty method like so: def testHTMLLine(): pass Still one line. EDIT: Added the parentheses. Same principle though: one line.
Quite a weak argument. The only portion that has any merit is the unit testing. Relating to the first reason he uses, I think this: def foo(): pass is far more clear than def foo(): Also, the author should be aware that this is legal: def foo(): pass Doesn't that make a lot of sense when you read it? "Define a function called foo that does nothing."
Summary: Python isn't Ruby. \*cries\*
Actually, you can't. Try typing that into IDLE - SynyaxError. No big deal, you just forgot the () after the function name. =)
Thanks for the heads up. I typed in an empty function in the Python REPL, then copied and pasted the example from the article.
Doctest is a cool idea. What other languages have that concept? (either natively, or through a library). 
"I was fighting with it to get the right indentation" People who find hitting the space bar twice a major battle have NO business whatsoever writing a computer program. Get back into the gym and take up some meathead job more suitable for your intellect; the IT industry has more than its fair share of wave-riders trying to cash in on the boom. 
These reasons are.. terrible.. The "no empty functions/classes" one is wrong (`pass` statement). I find python very good at detecting where I wrote something wrong, the reason for not allowing stray empty-functions is similar to not allowing "if something = other:", when you probably meant "if something == other:". Having to explicitly state you want a blank function in a language that depends on indentation is a good idea, I'd say. Saying you dislike a language because your editor messes up the indentation is an odd argument too - and I don't see how it's any better than having to deal with countless `end` statements.. I've not done all that much with the unittest module, but the problem seems to be it isn't exactly like Ruby. The problem seems solvable, just not exactly how the author expected it to be... The Python documentation is.. fine.. I found the PyDoc documentation pretty concise.. For example, I searched for "python urllib" and the first Google-result was the appropriate pydoc page.. Then I ctrl+f "quote" and it is at the section explaining the syntax, what the function does and sometimes a short example code.. TextMate (and most other scriptable text-editors) have ways of invoking PyDoc, I select "urllib" and hit F3 and it goes to the module docs, or ctrl+h on a command it goes directly to that function's docs.. I much prefer PyDoc to Ruby's equivalent.. but that's really just personal opinion and the fact I've not used it as much.. And the final complaint, "Python doesn’t live up to its hype" could apply to, well, anything. I'd say Ruby couldn't live up to it's hype unless it is able to cure all known forms of cancer.. but I don't really see why hype should have any impact on what you think of a language..
Not every application written in Python is built to be portable. If one wished to muck around in the registry, it'd be a good guess that they weren't going for portability anyways.
Surely a single character could have been used instead of a pair of triple double quotation marks? Even a double slash is overkill!
You mean like: def foo(): "This is a single line of documentation." pass Yep. You can do that.
You probably already know this, but I wanted to point this out. You can also use a single quotation mark ('). However, the advantage of a triple double quotation is that the string can span multiple lines. In other words, this is legal: def foo(): """Test 1 Test 2 Test 3""" pass But this isn't: def foo(): "Test 1 Test 2 Test 3" pass
effbot, you should use a backtick (seems like there's a bug in the markdown-escaping code so I can't print one) rather than \* to mark code, so that you print `map` instead of **map** ;) Also, is it normal that progress seems to have all but stopped on ET1.3?
Well, mixing typefaces in running text is a lousy idea; that's something that programmers should unlearn. I apologize for the lack of public progress on ET 1.3 (and effbot.org, for that matter); I hope to release a relatively final beta within a not too distant future.
&gt; Well, mixing typefaces in running text is a lousy idea I don't disagree, but bolding makes map/lambda jump out of your post and make it very annoying to read. Would it be possible that you emphasize instead, if you won't want to switch to use backticks? &gt; I apologize for the lack of public progress on ET 1.3 No problem, I'm just eagerly waiting for it as (I guess) many others :p. Also, have the namespace problems in attributes been fixed? I think I remember that mixing namespaced and non-namespaced attributes broke stuff when I tried 1.3
I can't upmod this article enough. As posted by serveral people in the comments section nginx is definately worth looking at as a solution to serving up a mixture of static and dynamic files in Django.
&gt; Assume that the deployment strategy is Apache/mod_python, using a process-based model, and that each Apache process will want about 16MB when fully loaded up with a Python interpreter, Django, application code, etc. Is that an accurate assumption? Doesn't Linux have copy-on-write semantics, so that only those pages of memory which are changed are copied? Thus couldn't one squeeze in many more concurrent Apache processes that way?
&gt; couldn't one squeeze in many more concurrent Apache processes that way? maybe, but you could cram a shitload more nginx, boa, or even stripped-down apache processes into the same amount of memory (as would be required to have some bloated httpd with mod_python+python.so+whatever_else run). Eg. (totally made-up bullshit numbers, btw) * fat_httpd == 5MB * boa/tux/whatever == 0.5MB you can cram 10 of the latter into the memory you'd use for one of the former... so why waste all those resources just to serve a JPG? The ratio in the real world will differ, but you're never going to have 100 fat httpds fit into the same RAM as 100 skinny httpds. Dig it? (almost) regardless of the process model. 
fucking nice. I have been looking for a project I may just make a small game around this.
using mod_wsgi, one of my servers currently has 6 processes dedicated to django, each taking up 20-30MB. At the moment there are 12 non-django httpd2 processes, each taking up 5KB. There's also another httpd2 process taking up 20MB. The loaded up python interpreter takes only a small amount of memory if you compile mod_wsgi with it as a shared library.
Release notes here: http://lists.gnu.org/archive/html/fab-user/2008-06/msg00025.html
We need Psyco for x64 and other platforms... even better if it becomes part of CPython. Or if PyPy eventually implements that kind of specialization.
I used Guido's Python tutorial from docs.python.org, then just the rest of the documentation. It all went fine and smooth. Going through the tutorial took 2 days... To think I was just fooling around and just decided to have a quick look at how's the language... Before I realized, I had completed Guido's tutorial and was ready to use it. It's just as simple - at least if you were used to PHP and Perl. From then I learnt a lot of powerful programming techniques and abstractions and ended up reading SICP and learning Scheme, achieving Satori.
My beef would be that if you write enough for it to be useful (e.g. doctest tests), the distance between the function signature and the code becomes too big..
Docstrings are not comments - they're a property of functions, classes, etc and can be accessed at runtime. In that sense, they *are* part of the code.
I don't like doctest tests (because it creates a big gap between the code and the function definition) but being able to use "help function" within my ipython shell has made my life a lot easier so I tend to write short docstrings for exactly that reason: When someone uses the code and just needs that quick manual for it.
For what it's worth, you can define a decorator that let's you put the docstring before the function instead of inside it: class doc: def __init__(self, docstring): self.docstring = docstring def __call__(self, func): func.__doc__ = self.docstring return func @doc("here's the docstring") def f(): pass print(f.__doc__) # here's the docstring 
Is Plone so terrible that this was needed?
&gt; Unless you use an editor and display environment that set docstrings off quite distinctly You should have good syntax highlighting for any language you anticipate working in for long... &gt; there is nothing particular in their indentation or the start of the line that makes them stand out Like being the first line of a function definition after the name and leading with """?
Looks interesting. I'm hoping for the best. Apress books are typically a little fluffy for me.
this is correct, it would appear that the ORM is confusing a one-to-one relationship to another object with a table inheritance relationship.
I don't see an issue if Apache is using mod_proxy, FCGI, or something similar to proxy requests to an application server running in a separate process. All the apache processes remain lightweight and your URL namespace can stay under one hostname. There still are separate servers, just a much more convenient arrangement.
&gt; Python is a super-object oriented language len('is this super object oriented?')
Apparently.
&gt; tom101 1 point 1 minute ago &gt; how about 'is this super object oriented?'.**len**() Well, you deleted it before I could submit but exactly my point, it should be that way!
Just out of curiosity, is there a reason to use a class for the decorator and not, e.g., something like: def doc(docstring): def decorate(func): func.__doc__ = docstring return func return decorate ? Is the class approach considered more Pythonic or otherwise superior?
Congratulations!
Yeah, I thought about that too. Hmm, what normally happens to docstrings of decorated functions? Is it "hidden" by the decorator's docstring?
Very nice. When I first started using python I was very excited to learn about jython, until I realized it had stagnated at 2.2 This is such a great step forward. Can't wait to switch over with out anyone complaining about transitioning away from our JVM system.
having read several (python) book of Apress, The Definitive Guide to Django Beginning Game Development with Python and Pygame(have not finished reading) Beginning Python Foundations of Python Network Programming can't find fluffy in these books... Dive Into Python
This guy makes post saying that he only knows one language, and that language has an xml parser made for it. and he's excited he can parse xml. why does crap like this even get written?
MySQL seems utterly overkill for this - a plain-text file would be more than capable of storing the data..
I've been playing with shoebox for about a month now, doing some very basic visualisations. All in all, it is pretty smooth.
Still, apart from that, just write your own mmap library in C and call it from Python using ctypes or whatever. This guy is saying that Python sucks for P2P because a function he wants to use doesn't support a parameter. Seriously? It's not that hard to write a library to call it directly, you know.
The titles you've chosen illustrate my point ... most are beginner/intermediate level titles. Once you actually try to design a full website, game, etc., you quickly go beyond the scope of the book and are on your own.
Plus, you can use single quotes and double quotes within triple quotes without having to escape them, making triple quotes especially useful for quoting python code (as used by in-docstring test cases).
I was expecting some important, hard-to-fix reason such as the fucking GIT in CPython... This has an easy fix, check ctypes out.
The author is using the decorator module, which is good but not in the standard library. If you want to avoid an extra dependency, you can use the "wraps" function from the "functools" module. So instead of @decorator def log_name(func, *args, **kwargs): print(func.func_name+" is being called") return func(*args, **kwargs) @log_name def f(): pass you'd write def print_name(func): @wraps(func): def logger(*args, **kwargs): print(func.func_name+" is being called") return func(*args, **kwargs) return logger @log_name def f(): pass Some people might prefer the syntax and brevity of the first example. Personally, I prefer the second both because it's clearer (to me at least) what's happening, and because it's in the standard library and doesn't require the installation of a third party module.
I have no idea which is preferred by the majority of Python users. I personally find the class-based approach more intuitive for decorators which take arguments. But I don't see anything wrong or un-pythonic about your approach.
By default, the docstring, name, and method signature of the function is swallowed by any decorators. However, you can prevent this with the "wraps" function from the "functools" module in the standard library. You can find the documentation with an example [here](http://docs.python.org/lib/module-functools.html)
Thanks!
This so totally kicked This Week in Django 26's ass!!!
I like this. It looks fairly Pythonic and about as easy to use as ActiveRecord.
Definitive Guide to (Sth.) is the series name of Apress(like Manning's sth. in action or O'reilly's sth. in a nutshell) AFAIK, most other python books (and there's title) from O'reilly, manning, or Packt... are beginner/intermdiate book too, isn't it? I am looking forwad to some Advanced/High level python book, any recommendation? maybe the "high" can only be reached by practical work(game/website)?
via http://crschmidt.net/blog/319/djangographviz-visualizing-django-models/
GIT? you mean the GIL?
This is pretty damn cool, thanks!
&gt; This installs the [...] testosterone(1) man page. Punny.
I've looked on the github site as well as the Google Code homepage, and there isn't an obvious explanation for why this interface exists. That is, it's not clear what value this actually adds to the existing unittest module in the standard library. A code example on their front page would be nice.
I like O'Reilly books like Python in a Nutshell and the Python Cookbook. Martelli et. al definitely have no fluff in there. There are no books out there that answer all my questions of course, but I just try to steer to the ones that answer most of them, or at least seem to summarize _some_ practical experience. The best books I find are not books for learning a language or framework but ones that teach ideas &amp; algorithms (preferably in the context of building applications). Some that come to mind are Principles of Artificial Intelligence Programming, Transaction Processing, Artificial Intelligence: A Modern Approach, and Essential Mathematics for Games and Interactive Applications. There's a place for framework and language books but hopefully you won't need more than one or two to jump start you anyway (providing you're not doing something like C++ for instance -- I used to have several references for that language :).
&gt; the fucking GIT in CPython [Git in Python](http://www.selenic.com/mercurial/wiki/)
Cool, but what kind of performance hit do you take for it? (Plus: I never realized that 3.0 function annotations would be so ugly in practice.)
upvote for django
Duh, true... After so much talk about Git in Reddit as of late I went and carelessly got them mixed up without thinking on what they stand for. The fucking GIL, not Git.
it adds MANLINESS. What more do you want?
I fully agree. I came to python for its simplicity, and its no-nonsense approach, I'm staying for the fricking awesome libraries.
The [screencast](http://www.zetadev.com/software/testosterone/screencast.html) is probably the best explanation of what it is and does. It doesn't really add anything to the unittest module, it's mostly a pretty- no, "handsome" interface to run unittests. http://img262.imageshack.us/img262/5223/testosteronescreenshot2on6.png is a screenshot of the interactive mode, and there is a scripted mode (which outputs test-results as text) -------------------------------&lt;| testosterone |&gt;------------------------------- MODULE PASS FAIL ERR ALL -------------------------------------------------------------------------------- testosterone.tests.cli.Detail 100% 0 0 7 testosterone.tests.cli.Summary 100% 0 0 20 testosterone.tests.demo.BadTests 0% 2 1 3 testosterone.tests.interactive.marshallers.Detail 50% 2 0 4 testosterone.tests.interactive.marshallers.Summary 100% 0 0 7 I am planning to add auto-refreshing to the interactive mode, so you could leave testosterone running in a terminal, and see tests pass/break as you edit code.
The main thing I don't like about egg files is that you can't easily view the installed code. Most Python libraries, being open source, have such poor documentation that you need to go through the source to understand anything. Case-in-point: ZSI/wsdl2py which I'm working with at the moment. It's also nice to have the code if you're debugging a program and want to step into an installed library to see what's going on. I haven't bothered trying to "crack" the egg files open to see if I can get the code out, since that's already too much work even if its possible.
I was under the impression that eggs are merely zipped directories with a special structure. Incorrect? 
They are, you can just open them with your favorite zip file manager.
Well that's good, but like I said, it's still too much extra work if I need to find and unzip an egg every time I want to step debug something new.
You say that like it happens every day :P
It kinda does!
The standard library unittest module is a good start, after all its got all the functionality there but like many great softwares its going to be trumped by something else whose marketing includes a backing track by Van Halen. After all, if you're doing something 'testy' they don't come much bigger than EVH slamming the boys into the back of the Frankenstrat while tapping out 'Eruption' 
len() is just a wrapper for object.__len__()
This is cool. But it is only an alpha. 
mushroom! mushroom!
That yoke was eggstraordinary
 &gt;&gt;&gt; len('Multi Paradigm FTW') 18 &gt;&gt;&gt; 'Multi Paradigm FTW'.__len__() 18 
Very sick, I am going to break my friends Wii playing with this....
Not this eggain.
Another nice collection of Video tutorials http://linkmingle.com/user/video_lectures/python_programming_video_lectures 
Put the following into .pydistutils.cfg in your home dir: [easy_install] zip_ok = 0 All future egg installations will be unzipped when you install them. 
whoa, how about an [NSFW] with all that OGC on that page‽
No, don't tell me that. I want to keep hating eggs and easy_install. Actually, my biggest problem with easy_install and similar systems is that you will inevitably end up downloading the world, with no idea what you've got and why. I hate that, and it really bothers me that these systems make it so easy for developers to just depend on random libraries that solve a trivial problem poorly or provide a massive superset of needed functionality. I'm all for code reuse when it makes sense, but there's a point when a project collapses under the weight of its dependencies.
Yay, thank you.
&gt; Actually, my biggest problem with easy_install and similar systems is that you will inevitably end up downloading the world, with no idea what you've got and why. Good package handlers (which `easy_install` ain't) give you: * which things a given package depends upon, thus which other packages will be installed along with it * a list of packages who have dependencies on a given one, thus telling you why you have a package in the first place * the ability to not download dependencies (and, usually, abort installation if there are any non-installed deps), with a listing of unsatisfied dependencies if any Thus giving you both the what and the why of the packages on your machine.
Do you mean that it would contain only good, user-selected content? I used to like gst, but I've changed my mind, it submits just too much crap.
While gst _does_ post some stupid articles, there have been plenty that are interesting. 
As if someone really wants to brag about PHP :-)
Why do you refer to gst as "it" ? Is it a bot ?
Yes, I'm pretty much sure it is. Just check out his commenting history.
Any way to find out who's written it and get to the source code ? I wonder how it works. Reddit doesn't expose an API, AFAIK.
Reddit uses HTTP. You can just login, and submit data together with your session cookie. Many languages have support for that.
would it not be better to have pyrunner.py installed in /usr/bin/pyrunner and create a symlinc in /etc/init.d/service? install pyrunner.py /usr/bin/pyrunner ln -s /usr/bin/pyrunner /etc/init.d/service 
I've been watching this project for a little while, I'm really hanging out for when it gets some kind of graphical support.
Read it and wiip (y)
You guys crack me up.
There's a hint in the comment history that suggests it basically posts the feed from http://del.icio.us/gerd.storm/
www::mechanize in python: http://wwwsearch.sourceforge.net/mechanize/ 
for a bot, you are aweful useful.
Here's a module to let you interact with reddit: http://search.cpan.org/~amoore/WWW-Reddit-0.05/ Hope it helps! 
Absolutely, having good package-management tools makes a big difference. The main concern I have, though, is that developers take the package manager for granted, and end up abusing it with dependencies they shouldn't have or don't need. I actually work with Maven and Java much more than easy_install, and in that world, this issue is a real problem.
I completely agree with you on that point, but it's not like they wouldn't do stupid stuff without package management (they in fact would, but they'd be reinventing the wheel even when there is a library that perfectly fits their need instead of adding too many libraries of dubious quality)
Yes they are interesting. You're overlooking the fact that the PHP subreddit has been around just as long as this subreddit, but they don't even have an entire page of articles.
I work for a company that does PHP. I don't write any PHP. I'm glad.
He's [not a bot](http://www.reddit.com/info/6oabz/comments/c04fh4g). And I [still don't understand](http://www.reddit.com/r/programming/info/60o5a/comments/c02h1k9) why submitting too many articles is a bad thing.
is pynotify part of some other library? I googled around for it, and I'm still not sure what it is.
That gave me a geek stiffy.
Hooray for this. Having to use the `nonlocal` keyword won’t save much on typing, but I think it’s more expressive than using a single-element list for nonlocal reference. I cannot decide if I prefer this to the way ECMAScript delineates scope with the `var` keyword.
The Matrix method looks interesting, but wouldn't using Eigenvectors make it MUCH faster than naively multiplying matrices?
A person can always log into the same account as their bot. I don't mind either way, there isn't enough traffic that he/it hides other stories.
**g**erd **st**orm (gst)
When a problem comes along, you must whipp(y) it.
It probably would. Work it out and add it, that way all of us could benefit from the knowledge.
I just worked it out. Using eigenvectors reduces the problem to Binet's formula. I think that's how the bastard got the formula in the first place. EDIT: Since the eigenvec thing didn't really pan out, I decided to try a different method by using the Binomial formula on Binet's formula. The end result is that the problem is now "reduced" to computing the sum of a series containing (n/2) terms (unfortunately, we need to compute C(n,k) which doesn't help a lot). This is what i did: * The binet formula has the expression (1 + sqrt5)^n - (1 - sqrt5)^n in the numerator. I used the binomial expansion on both terms. All the terms where (n-k) is even cancels out, leaving us with: sum(k = 0 to n such that n-k is odd) of C(n,k) * (sqrt 5)^(n-k) * This sum is to be divided by the term (2 ^ n * (sqrt 5)). (The denominator part of Binet Formula) * I canceled the sqrt 5, changing the num to be the sum of C(n,k) * (sqrt 5) ^ (n - k -1) * Since n - k is odd, n - k - 1 is even meaning we can change the sqrt 5 part to: 5 ^ ((n - k - 1)/2). This has the sole advantage of **reducing the calculation to integer arithmetic.** At this stage, there isn't a whole lot we can do. However, we have managed to reduce the entire problem to INTEGER ARITHMETIC. Joy to the world, the floating error is no more. The problem is that we need to calculate C(n,r). We can speed up the computation of factorial by using iterated or memoized methods 
hm. I think that statement would evaluate to "False" on python. Either way, this is an evaluation, not a variable assignment... Fail.
The problem is not with too many stories, but too many BAD stories.
It just involves Silverlight, which is far from ubiquituous and is not quite compatible. Getting The Real Thing is a infinitely better solution. No _why here :-)
&lt;faceplant /&gt;
Love that solution. More beginner friendly than 'var' in JavaScript IMO. Because actually reassigning an object to a variable occour not that often, usually when you are counting somehow.
Sooo, taking a quick look at the official distribution, I find: opencv/samples/python/facedetect.py Granted, it looks like he rewrote it rather than just copying the example, but implementing something included in the sample code doesn't really seem blogworthy. However, on the next page he hooks it up to a daemon which changes his IM status depending on whether he's sitting at the desk, which is a neat idea.
WHY!?!? If they wanted to add an iterable view why not just add a new method instead of hijacking an existing one? 
Please don't eggsagerate this!
Hooray maths! This is why I come to reddit =]
I don't understand what this link is trying to show...
When do you iterate through a list while deleting keys? That's kind of a weird behavior, IMHO. More normal is something along the lines of bad_keys = [key for key in d if cond(key)] for key in bad_keys: del d[key] It's "not threadsafe" but how can you safely have two different threads poking around in the same dictionary without locking things?
The problem with that is that you can't execute the program with the standard python interpreter; using IPython.Debugger.Tracer() outside of ipython itself raises all a bunch of nasty "color scheme not specified" errors.
[ Submitted here because Blogger randomly deleted my old Python blog :( ] [This post](http://www.reddit.com/info/6owhw/comments/) gives a really nice way to use IPython's debugger to create breakpoints: import IPython dbg_brk = IPython.Debugger.Tracer() [...] while program_pointer &lt; len(program): dbg_brk() cur_cmd = program[program_pointer] if cur_cmd == "": However, if you try and run the same program outside of IPython, it doesn't work, because it raises a ValueError: Traceback (most recent call last): File "./bf_interpreterv2.py", line 6, in &lt;module dbg_brk = IPython.Debugger.Tracer() [...] File "/var/lib/python-support/python2.5/IPython/ColorANSI.py", line 132, in __init__ raise ValueError,'you must specify the default color scheme' ValueError: you must specify the default color scheme Whoops. Well, it's horrendously annoying to have to modify your program every time you want to change the interpreter it's being run in, so I made the following modification: dbg_brk = lambda : None try: import IPython dbg_brk = IPython.Debugger.Tracer() except ValueError: None Since dbg\_brk() must be a function, we start it off as a do-nothing lambda. If we are in IPython using the "run py, then it will turn into a breakpoint, dropping us into IPython's excellent debugger if it's available. Otherwise, we just run the program normally. And since dbg\_brk() is a first-class Python function, we can incorporate things like this into our code: #This snippet needs the list to contain less than 10 elements numbers = bunch_of_numbers() if len(numbers) = 10: dbg_brk() This is really cool! This means we can now sprinkle breakpoints as part of our code with no adverse effects, using IPython as an all-purpose debugger. (I was really excited when I got this (albeit simple) hack working.) ;) And of course you can put this in your Python packages path and do "import * from debug_code" for reuse :) **Help needed**: The problem with this is that if you want to run a script using this from inside IPython, then the debugging will take place no matter whether or not the "-d" flag is added to "run". Could there be some way to determine whether or not the "-d" flag was enabled? If it's not simple, could there be a way to modify the run command itself to set some globals() flag? Just a thought...
[ Submitted here because Blogger randomly deleted my old Python blog :( ] [This post](http://www.reddit.com/info/6owhw/comments/) gives a really nice way to use IPython's debugger to create breakpoints: import sys import IPython dbg_brk = IPython.Debugger.Tracer() [...] while program_pointer &lt; len(program): dbg_brk() cur_cmd = program[program_pointer] if cur_cmd == "": You can then fire up IPython and enter run my_script.py to interpret and debug your script. However, if you try and run the same program outside of IPython, it doesn't work, because it raises a ValueError: Traceback (most recent call last): File "./exp_interpreterv2.py", line 6, in &lt;module dbg_brk = IPython.Debugger.Tracer() [...] File "/var/lib/python-support/python2.5/IPython/ColorANSI.py", line 132, in __init__ raise ValueError,'you must specify the default color scheme' ValueError: you must specify the default color scheme Whoops. Well, it's horrendously annoying to have to modify your program every time you want to change the interpreter it's being run in, so I made the following modification: import sys dbg_brk = lambda : None try: import IPython dbg_brk = IPython.Debugger.Tracer() except ValueError: None [...] Since dbg\_brk() must be a function, we start it off as a do-nothing lambda. If we are in IPython using the "run py, then it will turn into a breakpoint, dropping us into IPython's excellent debugger if it's available. Otherwise, we just run the program normally. And since dbg\_brk() is a first-class Python function, we can incorporate things like this into our code: #This snippet needs the list to contain less than 10 elements numbers = bunch_of_numbers() if len(numbers) == 10: dbg_brk() This is really cool! This means we can now sprinkle breakpoints as part of our code with no adverse effects, using IPython as an all-purpose debugger. (I was really excited when I got this (albeit simple) hack working.) ;) And of course you can put this in your Python packages path and do "import * from debug_code" for reuse :) **Help needed**: The problem with this is that if you want to run a script using this from inside IPython, then the debugging will take place no matter whether or not the "-d" flag is added to "run". Could there be some way to determine whether or not the "-d" flag was enabled? If it's not simple, could there be a way to modify the run command itself to set some globals() flag? Just a thought...
BTW, here's a straightforward tutorial on how to use debug mode: http://showmedo.com/videos/video?name=UsingPDBInIPython&amp;fromSeriesID=2
&gt; Sure, you can say a[::-1], but what is the 'slice' *object* to represent that? slice(None, None, -1)
Instead of setting the TM_PYCHECKER variable in your bashrc (Typically ~/.profile on OS X), you can set it in Textmate: Preferences &gt; Advanced &gt; Shell Variables &gt; + button Just tried PyFlakes on a few scripts (about 700 lines of code) and it didn't find anything other than a few alleged "unused imports" (Which were in fact used, but within a class by using "self.os.[etc]"). I ran it on BeautifulSoup (1900 lines) and again the only thing it reported was a few alleged unused imports/variable definitions, that were wrong. I'm tempted to run it on my entire python code dir and see what errors it shows up, and see if it finds anything other than unused imports..
&gt; It may seem strange to see something like ', '.join(l). Why not just l.join(', ')? I'm not sure what the original reason was for implementing it like this, but one reason might have been that string joining would otherwise have to be implemented for everything it works on (lists, sets, dictionaries, etc). This way, it's a more common operation of strings. Can anyone answer this? It's one of my biggest minor beefs with Python. I worked in Actionscript, and Javascript for a long time, and got really used to things like: mystr.split(" ").sort().reverse().join("\n"); Which is "take my string, split it around spaces, sort the resulting list, sort it, reverse the sort, and join it back into a string with newlines. Every method was of a type, and could return a different type, so you were fine dotting on methods from a different method if the result of an operation was that new type. I find the way ECMA-262 described this kind of thing far more expressive, intuitive, and fluid than Python has been for me these past few months. Sure, it has list comprehensions, libraries galore, and lots else, but aside from the things JS/AS didn't have, I felt more 'elegant' in those languages.
Not that you asked, but "\n".join(sorted(mystr.split(), reverse=True)) The reason why `mystr.split(" ").sort().reverse().join("\n")` won't work is that by convention, mutating methods return `None` instead of their original object, so that you know that they're mutating methods. Hence `mylist.sort()` returns `None` as does `mylist.reverse()` hence they can't be chained. Fortunately for fans of one liners, you can just use the not-in-place sorting function `sorted` or the not-in-place reverser `reversed`. (Newer versions of Python also have a handy optional `reverse` argument for sort methods/functions.) If you're absolutely addicted to in-place methods and (near) one liners I guess you could always do something like l = mystr.split(" ") return l.sort() or l.reverse() or '\n'.join(l) or l = mystr.split(" ") return l.sort(reverse=True) or '\n'.join(l) Since the mutators return `None`, the lazy `or` evaluation will proceed to the end of the line. This isn't especially Pythonic though. I think the historical factor is that originally, you had to `import string` to get a `join` function that took a string and a list as arguments, but later, the string methods were added to all str objects.
&gt; *4.8 Why is join() a string method instead of a list or tuple method?* &gt; join() is a string method because in using it you are telling the separator string to iterate over a sequence of strings and insert itself between adjacent elements. This method can be used with any argument which obeys the rules for sequence objects, including any new classes you might define yourself. [Python FAQ 4.8](http://www.python.org/doc/faq/general/#why-is-join-a-string-method-instead-of-a-list-or-tuple-method)
Great article. I've written a lot of Python in the last couple of years and there were still two good new tricks I learned.
Scaz nails it earlier in this thread. As a practical reason, this means that you can make your class or object iterable by just adding one method. I'm sure I'm typical of 99% of Python programmers when I say that I write quite a lot of iterables and very few things that look like string objects (none, in my case).
Thanks for the info. It does make sense, but doesn't make it feel better to me. Is there a way to know what modifies things in place, or not? Some kind of convention? Or is it all down to keeping a reference handy, or testing things out, and checking for None. This is a personal thing, but to me, anything that returns "None" is wasting a perfectly good return, unless the None is useful, e.g. if you ask something like mystr.count('the'), to count the 'the's. If there were None, it would be nice to have the actual None value. I keep asking these kinds of questions to users of Python, and they all team up to smack me down, but I still don't feel - after having used about 25 other scripting languages - that these ways are good. Quick, certainly, and handy at times, but not purely 'good.' I could be wrong.
&gt; "\n".join(sorted(mystr.split(), reverse=True)) In my defense, I would never write something like that. I have to play tennis back and forth with my eyeballs to make any sense of that, following the nested order of operations. The reason I like the EMC-262 style is that the data follows a linear path, always changing as it passes through operations. If you think of it like a physical object, you start with a block of wood, you chisel it into a shape, you sand it up, paint it, and then varnish it. If each of these was a method: woodblock.chisel().sand().paint().varnish() Specifics needed by each task would go in the ()s. I wouldn't even mind doing it the other way: varnish(paint(sand(chisel(woodblock)))) As is somewhat standard, arguments would be appended with commas. At least then there's still a sensible direction to the operations. I guess I like being higher up in the abstraction levels, further from where it matters if an object is copied, or modified in place. I'd be fine just passing along the reference to whichever object is the result - original, or copy - as long as I can continue to think of the data flowing through operations, as I do. It's a bit akin to piping in the shell. I suppose I also do a tremendous amount of string manipulations in the things I do, so it makes more sense to me to think of a string as an object to cut up, and spin around as I need. This more functional approach makes me think I'd enjoy Lisp, except that it's a bit of work to really get into it for me, and then there aren't all the lazy (productive?) helpers, like Python's army of string functions, and the libraries its popularity affords it. Thanks for the info.
The main difference between my code and the face detection example is that I don't use the official Python bindings, but Gary Bishop's [CVtypes](http://wwwx.cs.unc.edu/~gb/wp/blog/2007/02/04/python-opencv-wrapper-using-ctypes/), which seems to be a bit more pythonic. But I agree, it's nothing new :-)
At the risk of starting a flamewar, which is easier for a noob to use: wx or tk (or something else)?
tkInter is a bit easier. That said, don't use it. Use wx. I started with tk and switched to wx out of frustration. I have yet to regret doing so. All my windows look nicer and the UI works more like Windows/Gnome rather than old-school X/twm (which were based off tk). The small amount of extra time you'll spend learning wx are worth it.
Thanks for your reply. I've reached the "novice" stage in python, and learning to make a gui was definitely on the "to-learn" list. I'll take your advice and go to wx directly. Somewhat related question: Is there a way to enable font smoothing for IDLE's window? It seems to be written in Tk or something, and it looks like utter shit in my ubuntu machine because it's the ONLY app without anti-aliased fonts.
If anyone needs graphs in Python, I would suggest checking out NetworkX as well.
Use wx with Boa Constructor, it makes application building very very easy.
The docstring on a method will usually tell you what it's going to return. &gt;&gt;&gt; help(list.sort) Help on method_descriptor: sort(...) L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*; cmp(x, y) -&gt; -1, 0, 1 `String.count` does the right thing. &gt;&gt;&gt; "the quick brown fox jumps over the lazy dog.".count("the") 2 &gt;&gt;&gt; "the quick brown fox jumps over the lazy dog.".count("foo") 0 The reason why mutators return `None` specifically is that every function/method in Python returns something, and `None` is what's returned if nothing else is specified. &gt;&gt;&gt; def f(): ... pass ... &gt;&gt;&gt; x = f() &gt;&gt;&gt; print x None I guess the idea is so that `x = f()` can never throw a `NoReturnValue` error or whatever. Although in retrospect, that might not have been a good idea. Especially considering it is possible to make non-lookup-able properties with a bit of advanced class property mucking: &gt;&gt;&gt; class A(object): ... def _helperfunc(self, val): pass ... prop = property(fset=_helperfunc) ... &gt;&gt;&gt; a = A() &gt;&gt;&gt; a.prop = 1 #This calls the fset method of the property, &gt;&gt;&gt; # which is set as _helperfunc, which just throws the "1" away &gt;&gt;&gt; a.prop #Will fail, since there's no fget for the property Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: unreadable attribute &gt;&gt;&gt; x = a.prop #Ditto. Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: unreadable attribute Maybe this will change in Python 4000 or something…
Why is anyone doing XML-RPC in this day and age (of REST)?
aka Graphs.
Because this is py3k, breaking old code in the name of making new code better is the whole point. 
Ah, cool. I used the official bindings for a project once, and I do recall them as being quite buggy and non-pythonic. Array slices not working properly, memory management stuff, etc. I'll have to take a look at that.
... and it can't be imported outside of an X terminal. I had to manually comment out one import statement in networkx/__init__.py (from drawing import *) to fix this.
The problem here is that in Python, `=` is used for two things: creating a new variable binding and updating to which object a variable refers. What exactly is being done depends on the context. I think it would be better to make this explicit, like in many other languages. One could for example use `&lt;-` for an update, while `=` would create a new binding (and shadow any old ones). For example: a = 3 def f(): return a a &lt;- 4 # let a refer to 4, f returns 4 a = 5 # new binding, old a is shadowed, f still returns 4 It's too late for that in Python of course.
&gt; I have to play tennis back and forth with my eyeballs to make any sense of that, following the nested order of operations. From the Zen of Python (`import this`): &gt; There should be one-- and preferably only one --obvious way to do it. &gt; Although that way may not be obvious at first unless you're Dutch. ;-D
A friend of mine is working on fast reconstruction of Bayesian networks for genetic interaction graphs in statistical genetics. Right now everything is in C++, for speed, but the visualization aspect of his code suxxors. It took me about 0.0001 second to email this to him. Hopefully it'll get his thesis done 2 years earlier ;-) Dog bless the fine people at LANL. 
This is a very interesting article; I originally came to Python from Java and have always felt that Python's datetime module blows away Java's date/time handling. However, this article makes a good case for Java being better (if more verbose) when doing date arithmetic between date/times of different timezones. I still prefer Python's datetime module for all the stuff I've ever had to do, since it's much less verbose and much more intuitive. However, I'll definitely on the lookout for timezone problems in the future.
Unfortunately I have no idea how to fix IDLE's window. I do like IDLE as a Python IDE, especially the context sensitive help, so I reccomend staying with it - ugly bumps and all.
woah that took a few moments to parse..
Hi, Everyone, Let's Pitch In 'N' Get Cracking Here In Louisiana Doing Right, Eh? Now Then, Hateful, Rich, Overbearing Ugly Guys Hurt Royally Every Time Someone Eats A Radish, Carrot, Hors d'oeuvre, And Never Does Dishes. Eventually, Victor Eats Lunch Over Peoria Mit Ein Neuesberger Tod.
Old article, still decent. The doc string trick seems a little sketchy to me. I'm still a bit new to python; what's the best way to do this now?
This looks really cool! Thanks reddit! ( No seriously, that wasn't sarcasm. Post more interesting things like this.)
That’s the way it’s done in [ply](http://www.dabeaz.com/ply/), which is what I choose when I decided to parse in Python recently. The doc string trick is a bit un-Pythonic and non-idiomatic, but it works.
I forgot David Beazley did ply. That's pretty much par for the course for his sick, twisted mind.
I love Python too, but to be honest that link wasn't all that useful.
This guy argues against every common perception there is: *[Slide 18]* &gt; No stumbling through Java designs I'm sure Python's just read the code approach scales massively. Well past 100,000 lines of code. After all, you have removed all the braces. *[Slide 24]* &gt; Runtime is better than compile time *sound of jaw dropping* Does anybody agree with this statement? *[slide 26]* &gt; Programming Productivity is the most important thing Really? To end user? More than performance? In every scenario? What's with the weak typing in C++ and Java examples? Reflection and templates are just not the same as weak typing.
&gt;&gt;No stumbling through Java designs &gt;I'm sure Python's just read the code approach scales massively. Well past 100,000 lines of code. After all, you have removed all the braces. A couple more things allow Python to keep the lines count lower with regards to Java. Dynamic typing means you don't need to jump through hoops to convince the compiler that your code is right (that's a double edged-sword however.) Higher order functions also help quite a lot.
I recommend http://www.pyglet.org/ for an easy, crossplatform opengl module in python
I agree completely but come on "No stumbling through Java designs"?
It lives! IT LIVES!
Java is hostile to hacking. The thing one (or many) is programming is supposed to be making needs to be designed before it's coded (e.g. types), else stuff breaks badly. IDEs can help with this, but it's just workarounds.
It doesn't matter how "hacker friendly" Python is, real *non-trivial* software needs to be designed. No language can ever remove the need for at least some form of forethought or design before programming.
**Python is not weak-typed.** It's just dynamically typed and not anally-typed like most others. Python doesn't let you crap yourself. It just allows things to work when they work. Such a simple concept and still people are obsessed over static typing. Can you .count? Then .count. You can't? Then raise DoNotWantError. Parametric polymorphism allows you to write code that works with objects you didn't even know they existed and are otherwise completely unrelated to your code - or objects that didn't exist when you wrote your code. That's, of course, as long as you follow a vague protocol of what a particular method name stands for. This was the idea of the good guys at PARC when they offered the world "object-oriented programming" with Smalltalk, before "best practices" fundamentalists took it and totally raped the concept. On top of that, a dynamically-typed language saves a lot of time, effort and code wasted on casting and typing stunts you need to pull just so that the compiler feels like compiling your code.
Quite likely unexpected things; requirements, caveats, possibilities come up during development. None of which could have been foreseen. Hacker friendliness in this sense lets the developers have a rough sense of what they want – without designing it all with unknowns – by not deliberately hindering design overhauls.
casts are a form of weak typing.
... as pylons.
Wow, they stored uploaded files in memory by default? I would have assumed mod_python would have something similar to mod_perl that lets you automatically stream them to a temp file as they're uploaded. Then again, I have no idea if mod_python has the same memory-release problem that mod_perl does, so putting them in memory might not be a big deal in general.
This is weird. Doesn't sound anything like the Guido I know from c.l.p or python-dev...I have no idea if he's self-editing or if the Google is interposing itself or if the writer/publisher of the interview is transforming things, but it's mostly just vacuous noise.
/constructs additional pylons (sorry, i have to make that joke every time)
This is a great idea. Distributed Issue tracking systems that allow downstream and upstream maintainers a single reference for all shared bugs allows for a better development and quicker system integration.
"Retsearch"?
I'll be impressed when there's a web app that ties into this so that users can visit the projects homepage and view/comment/submit bugs that stay in sync with the information in the repo. A bug tracker that only developers can access seems extremely limited IMO...
CherryPy is nicely minimal. I recommend this [tshirt](http://www.dieselsweeties.com/shirts/cherrypi/)
That reddit karma-whoring markov chain headline generator is coming along nicely.
OOOOH, that's what a decorator is for!
I have been working with Python and Django for about a year now. Lately, I've been toying with the idea of creating an application. I started investigating cross platform frameworks that I can use my Python skills with and have found both to be quite similar. After hours of searching for comparisons, I am starting to assume that it has more to do with personal opinion and coding style. I cannot find an objective opinion anywhere and i feel this really needs to be addressed. I am sure I'm not the only one who is in this position. I have started reading books on PyQt and Qt in general, but I'm afraid that my reading may be going in the wrong direction. Let me know. *Edit: I read two books on PyQt now and I feel I understand it quite well. I just started doing the tutorials on wxPython now. If nobody is sure, then I will just learn them both and make the decision myself. I have noticed even when just dabbling, the syntax is almost exactly the same. So far I have found that i like the constraints in gui design that PyQt offers, it pretty much guarantees that my app layout doesn't look like a dogs breakfast.*
I suspect you may find it is all about either personal style or possibly licensing. I doubt there's much difference between them on a technical level.
I've used wxPython to great success (very easy, particularly with Boa Constructor), but I have a feeling that Qt would be a bit more well developed, since the people who develop it charge for it... The licensing thing, however, makes me go with wxPython **easily**.
What I'm using the app for will be interoffice and if it gets beyond that it's worth paying for the licensing. So licensing aside, I'm looking for feature level reasons. Through research, i have found that wxPython is using the wxWindows libraries, while PyQt is using the Qt library. What are the differences between these two? I must admit, I am a bit of a Mac zealot, so that was why I leaned in the Qt direction first. In fact, I almost started with PyObjC, but i want the ability to deploy to other platforms.
I'm not sure, I haven't written GUIs extensively. It is my understanding, though, that wxWindows has native look on all platforms, so it should look quite good on a mac (then again, so does Qt, probably)...
I made the web-to-GUI leap a couple months ago. I picked wxPython because it looks great and has a strong community (both in python land and from the larger wx community). The only other (python) GUI tool I've used is Tkinter, and wxPython looks and feels a whole lot nicer. wxPython also has several nice GUI builders boa constructor and PythonCard - though I prefer to just use the simple XRC builder that comes with wxPython and code the rest in emacs. One other plus for wxPython is the HUGE demo you can download. Between that and the docs, I pretty much never get stuck. Basically wx=good stuff. :)
wxpython uses wxwidgets underneath. I don't know about PyQT so I can't give you an objective comparison, but I can tell you I am pretty happy using wxpython + wxglade until now.
I only know one book of PyQt4 "Rapid GUI Programming with Python and Qt:The Definitive Guide to PyQt Programming", i have been read it and write several small GUI app with PyQt4. I read the book "WxPython in Action" before. can't tell which is better, PyQt4 or WxPython, except there's license if it does matter. to me, signal and slot is attractive, so I use PyQt4 now.
I like the signal and slot mechanism, that's a very valid reason to like PyQt. Is there a real community to PyQt? Resources are scattered all over the place.
AFAIk, PyQt has a mailing list, maybe not as active as WxPython's.
It's mutch motre effetctive
Man, I had a hard time reading that summary. I'm yet too see a Brazilian speaking proper english.
no
\_\_Python\_\_. Always looks nicer than Q#(%/=)#(7/!#%=()/"$perl(Q#/%=)#(!"/%=#)%.
To me the decision is if you see trying to do anything commercial. PyQt beats wxPython, in my opinion. The only problem is any software you develop for sale has to be developed with a licensed version of Qt and PyQt. That ain't cheap. If you don't expect to do commercial, Qt is just better.
The complexity is Θ(logn), if I remember correctly. We had this as an exercise in our algorithms class, apparently we were expected to produce Takahashi's algorithm ourselves. Bastard class.
Qt has a licensing issue for commercial software (you have to buy a licence of you don't open the code). I personally used wxpython once and it was not bad so that is a valid suggestion, if it's just between the two. If you think about other thing I'd go for PyGTK. I have written many apps in in for Windows/Linux and it's really easy to use and package with py2exe, it might look somewhat alien on Windows but it's a blast to use, there are many tutorials and the documentation is very good. Also there's just heaps and heaps of PyGTK code around (half the GNOME desktop is build with it) which shows that it works really well, is stable and you have enough stuff to look at and learn.
It's "International Classes for Unicode", not "Internal Classes for Unicode" as the post says. I would have commented on the blog, but it doesn't take my Yahoo based OpenID. Fleh. Nevertheless, putting a pythonic wrapper on ICU4C would be a great thing.
[Also posted to the programming subreddit.](http://www.reddit.com/r/programming/info/6q0k0/comments/)
When I [got started with Python](http://eli.thegreenplace.net/2008/06/06/python-impressions/) a couple of months ago, I had the same dilemma - as GUIs are important for me. Eventually, I've decided to go for wxPython because it appeared to be more actively developed and had a much larger community - this is **very** important. I'm happy with the decision I've made. wxPython works great, is easy to use and learn, and produces really nice good-looking applications. I've created several toy and a couple of serious applications with it (including a [Tetris clone](http://eli.thegreenplace.net/2008/05/31/a-tetris-clone-in-python-wxpython/)) and am very happy with the results. So, while I'm sure PyQt is good too, I'm also confident that if you go for wxPython, you won't end up unhappy.
True, but I'm not sure that `__cmp__`, `__lt__`, or `__gt__` looks nicer than Java: x.compareTo(y) or Ruby: &lt;=&gt;, &lt;, or &gt; 
use overload 'cmp' =&gt; 'cmp_method', ; sub cmp_method { my $self = shift; my $cmp_to = shift; (do your comparison, return -1, 0, or 1) } Sure, it's nice that it's built in to Python's class declarations, but it's hardly unreadable or difficult to do in Perl. Oh, and Reddit can shove their retarded markup language up their ass. Underscores should not be converted to italics.
The underscore methods all correspond to an operator. You need the underscore notation only if you override them.
Searching for repeat posts is not yet implemented in gst.
I've used both wxPython, and PyQt, and personally found wxPython more attractive. I decided to write the same app in both and found it much easier with wxPython. I didn't like having to specify the c++ paramaters in the SIGNAL definition.. i.e. self.connect(self.filterEdit, SIGNAL("textChanged(const QString &amp;)"), self.filterProcesses). I was also able to find more documentation/help with wxPython which is why I stuck with it.
They don't all correspond to an operator. __len__ __iter__ There's two that don't.
Ok, only most of them do. But it's actually quite nice to be able to use words such as len or iter in you program.
You can use &lt;, &gt;, etc. and there's also a cmp function. You only deal with \_\_underscores\_\_ when defining special methods or saving/passing/returning these functions; for everything else there's the shortcut prefix syntax.
I'm not saying Python is bad (it's not), but if we're talking about that, then Ruby is simpler: you define methods like you call them. Even better, you just define the `&lt;=&gt;` method (like `__cmp__`), then you mix in the `Comparable` module to have `&lt;`, `&gt;`, `&lt;=`, `&gt;=`, `==` and `between?` all defined for you. So in Python, you still have to deal with the underscore methods, but in Ruby, you don't deal with them at all.
http://code.google.com/p/deseb/
Yeah, that's not really my point, my examples were bad because the Java one is a call to the method while the ruby and python ones are the method declaration. Let me try again. In my opinion, having the method declaration be called `__lt__` isn't as nice as having the method declaration be called compareTo or &lt;. I'm talking about the method you define in the class, not the operator or method you call from client code. And, of course, this entire comment is only in response to the assertion that Python is prettier than Perl. I'm not claiming that Java or Ruby is better than Python. I mean, good God, I'm not a terrorist or anything.
[Already posted to the programming subreddit here.](http://www.reddit.com/info/6q45w/comments/)
&gt; In my opinion, having the method declaration be called __lt__ isn't as nice as having the method declaration be called compareTo or &lt;. Well, to me compareTo looks just ugly (uglyCase, verbosity and not looking special enough as to define something which you can later use with an infix syntax shortcut), and it could more easily clash with whatever properties I might want to define for that object which I also want to override operators on (though whether this is bad or good is debatable). Using &lt; as the method name is the cleanest choice, but then again if you do, you either need "speshul" method override declarations (and I strongly feel that special cases are a Bad Thing), or give up on infix operators as you do in Lisp (which is not necessarily a bad thing, but some people seem to hate that).
If you define __cmp__ in Python you automatically get &lt;, &gt;, &lt;=, &gt;=, == and combinations of comparison operators (which supersede between?) working too. I don't know how does Ruby handle what I'm going to talk about next, but as I see it, the good thing about having a method which represents infix operators is that you don't need to support special method definitions (which may give you problems if you want to refer to them elsewhere, or at least it would complicate the parser).
&gt; If you define cmp in Python you automatically get &lt;, &gt;, &lt;=, &gt;=, == and combinations of comparison operators I thought that would be the case, but I wasn't sure. Thanks for the clarification. &gt; the good thing about having a method which represents infix operators is that you don't need to support special method definitions (which may give you problems if you want to refer to them elsewhere, or at least it would complicate the parser). I'm not sure what you mean by problems. The thing with Ruby is that infix operators aren't special at all. You define them the same way as any other method: def &gt; other @value &gt; other.value end Then, using the `&gt;` infix operator calls the user-defined method. I feel that it's better to have the parser do more work if it means it simplifies common tasks for the users.
I like the way that looks, though in python you'd also want some way of doing the "right side" operators, like radd. 
Add four spaces to the front of code lines. like this Also, use backslash to \_escape\_ markup symbols. I'm pretty sure there's a character for inline code, but I can't recall at the moment.
My point is, you should have to go out of your way to include markup. I know that Reddit didn't invent the syntax, but it was a really bad idea.
This is a class offered during IAP (Independent Activities Period), which means it is "lightweight". There's an [actual class, 6.00, ](http://web.mit.edu/6.00/www/) that teaches programming using Python, and is intended for CS students without any programming experience. 
Then how do you access the method you've defined? In Python, \_\_lt\_\_ and company are regular properties; you can do something such as: class Foo(object): ... def __lt__(self, other): ... ... x = Foo() DoSomething(x.__lt__, ...) Foo.__lt__ = SomeOtherFunction #The previous line dynamically modifies class Foo's &lt; behaviour, #which affects object x as it didn't customize its own __lt__ property Can you access the operator overloading method you've defined with something such as x.&gt; in Ruby?
&gt; Can you access the operator overloading method you've defined with something such as x.&gt; in Ruby? First of all, in Ruby, you don't need parentheses to call a function. So to get a reference to a function object, you need to use `obj.method(:method_name)`. Thus, you would use `x.method(:&gt;)`. &gt; In Python, __lt__ and company are regular properties In Ruby, `&lt;` and company are regular methods.
&gt; First of all, in Ruby, you don't need parentheses to call a function. Ugh, sounds like a terrible idea to me. I'm very functional-oriented even when I do Python, and I reference lots of functions/classes/otherwise applicable objects (functors) in my code for one reason or another. I even make tables of them pretty often. I love the fact I can deal with functions just exactly like I'd deal with a number or anything else, but nevermind. Oh, BTW, out of curiosity, does Ruby work like a Lisp-1, or a Lisp-2? I think (and fear) it was the later when I had a quick look at the language a while ago. In particular, can you do something like: x = obj.method(:method_name) x arg1 #Call x or the simpler: obj.method(:method_name) arg1 ? And can you rebind methods in objects dynamically? (As I would do in Python with class.method = some\_function\_object\_or\_lambda\_expression.) &gt; In Ruby, &lt; and company are regular methods. Interesting; it's a regular method yet it's later parsed as an infix operator with precedence rules, is that correct? Or will it work like Smalltalk, where methods such as + feel like infix operators but you have to be careful about precedence because there are no precedence rules? Thanks for your information on the Ruby language (upmodded).
Neat hack. Though the central TCP proxy server would get a bottleneck soon. Or at the least adds latency.
"Networking for the web"? What's next? Roads for the highways? Cars for the automobiles?
&gt; Ugh, sounds like a terrible idea to me. I'm very functional-oriented even when I do Python, and I reference lots of functions/classes/otherwise applicable objects (functors) in my code for one reason or another. I even make tables of them pretty often. I love the fact I can deal with functions just exactly like I'd deal with a number or anything else, but nevermind. It's all a trade off. Instead of using already-defined functions, Rubyists use blocks, which are like Python lambdas, but of arbitrary length. Only occasionally would you want to use a function or method that's already been defined for some other purposes. Other times, you might do: obj.method_name { |args| do_stuff } The stuff in the braces are an anonymous block. If you want to give it a name, you would do something like: blk = proc { |args| do_stuff } There's a lot of syntactic sugar in Ruby, but you don't *have* to use it. I prefer to use Ruby because it gives common tasks a special syntax, while allowing you to do everything else the regular way. &gt; Oh, BTW, out of curiosity, does Ruby work like a Lisp-1, or a Lisp-2? Actually, the `method` method will return a block that you can call: x = obj.method(:method_name) x.call(arg1) Obviously, you can always use: obj.method(:method_name).call(arg1) You don't even need the second set of parentheses in either example. &gt; And can you rebind methods in objects dynamically? Usually, Rubyists will do something called monkeypatching. Let's say class `A` is already defined and it has a method named `method_name`. You can rebind the method by doing this: class A def method_name arg .... end end It looks like you're defining the class and the method for the first time, but if they've already been defined, you're really opening up the class and rebinding the method. You can do this for any class, even built-in ones. &gt; Interesting; it's a regular method yet it's later parsed as an infix operator with precedence rules, is that correct? Or will it work like Smalltalk, where methods such as + feel like infix operators but you have to be careful about precedence because there are no precedence rules? You're right about the first part. You can call the method explicitly: 5.&gt; 2 # =&gt; true Or you can use the infix notation: 5 &gt; 2 # =&gt; true They actually are infix operators with correct precedence rules: 2 + 3 * 4 # =&gt; 14 You can even setters this way: class A def a= value @a = value.round end def a @a end end Then you can set the attribute `@a` using: obj_of_type_A.a = 5.6 obj_of_type_A.a # =&gt; 6 You create a method, but you can access the attribute as if it's a regular property. There are certain helper methods that set up default getters and setters. &gt; Thanks for your information on the Ruby language (upmodded). You're welcome. Thanks for the discussion so far. I try to learn as much about other languages as possible. It's great to have a discussion with someone else about this.
Wow, when I first read the homepage I thought it was a parody site poking fun at the excessive use of corporate buzzwords to advertise applications...then I realized it's a _real_ site making excessive use of corporate buzzwords to advertise an application.
My opinion is that compareTo is dumb, but &lt; has some merit. My question is though how do you things like `__radd__` in Ruby? Is it r+ or something?
Inline code `is done with` backticks `.
I always thought the way Python did thing was nicer. I never liked methods named "blah=" or "==" in ruby
And what exactly would you propose as a less "karma-wrorific" title for this submission? The topic was fine, it explains exactly what it is, and that's all it needs to do. The reason it's being up-modded is because people found it interesting - the key section of that sentence being "people found it", which may be thanks to the descriptive title, no..?
Unfortunately, 6.00 doesn't seem to be available as opencourseware.
My bad. When i linked the class, i thought everyone could view the contents (I didn't realize that the only reason i was able to see the contents was because i was using my personal certificates). Sorry for the inconvenience.
That's ok, the "Readings and Reference" section is still available to anybody, looks useful.
Discussed here: http://groups.google.com/group/django-users/browse_thread/thread/e3b67ae85c169e38
Wish this worked on reddit.
I prefer [ULipad](http://code.google.com/p/ulipad/)
Uhh...
Hmm, COM+ rocks.
How *I'm* building a *non*-working sports betting bot: * Cardboard * Pipe cleaners * Glue * A few marbles * Scientific calculator wrapped in tin foil, taped to rest of bot Sorry, I just thought the "(working)" stipulation in the title was funny :p
Upvoted for John Bonham.
Awsome logo (the eval/apply/yingyang one)
Color is the absolute last thing you apply to a logo. It's about shape.
via: http://blog.w-nz.com/archives/2008/07/08/pyx/
Thank you for not linkjacking.
I found PyX to be a bit cumbersome in the way it expects data to be provided (wrapped in all kinds of objects) and the graphs to be configured. Matplotlib was a bit better in this respect, although it can also be a hassle to configure your graphs. Wanted: more pythonic plotting lib :)
"I think trust is built up over a long period of experience." At the same time, Guido says almost nothing of interest because his position as an employee of Google doesn't allow it. Very sad.
Interesting. I'll have to play with it. I'm not sure that Matplotlib can do all of this (at least without serious efforts).
And...? I thought the whole point of Python was that it was *supposed* to look cleaner and more like psuedocode?
Yeah, I think the article is saying "yes, python *is* like executable pseudocode". I prefer the python, personally. Mind you I was half-expecting a monstrosity cooked up with multiple-double-underscores, hackish trailing commas, and decorator at-signs. *That* would be some ugly freaking pseudocode.
Is it seriously 'd**e**spatcher', and not 'd**i**spatcher' like you would *actually* spell it? That alone could drive me up the wall using Pesto. But other than that, it looks really cool.
compared to werkzeug its rather poor stuff
I get it. Python is shiny. Everyone subscribed to python knows that already. 
My own tutorial, enjoy.
Awesome! Sounds really handy.
Titles that I hate: * "How I Learned to Stop Worrying and Love &lt;foo&gt;" * "&lt;foo&gt;: The Good, The Bad, and The Ugly" * "&lt;foo&gt; Considered Harmful"
Honestly, you could come really close to that with a list library in C.
vi
Nice, my project got redditted :) By the way, since a few days back, the svn version of mpmath can optionally use [gmpy](http://code.google.com/p/gmpy/) for improved speed. I blogged a bit about it [here](http://fredrik-j.blogspot.com/2008/06/gmpy-makes-mpmath-more-speedy.html).
&gt; Instead of using a clumsy GUI or an inflexible graph language Is this a reference to R? That's what I usually use to make my graphs. I don't usually think of it as "an inflexible graph language" though.
Another example of how the Python cookbook - while contianing a bit of useful information - is not of high quality. IMHO, the API of this term() function sucks. I would have made it take arguments in the form setterm(fg="red", bg="white", format="underline). Maybe even setterm(fg=colors.RED, bg=colors.WHITE) or something like that. And it should throw an exception if it doesn't know a word, not simply treat it as text. Also, I think it should be a requirement for code in the cookbook to follow PEP8 style guidelines. 
At least pretend to be creative. Next time this comes up, use this one: M-x vi-mode
That's mind-blowing.
Any thoughts on integrating this with SciPy/NumPy?