what do you get with rvm and gemsets that you don't get with pip and the cheese shop? I thought rvm and gemsets was just a way to manage library versions.
&gt; Isn't that possible in basically every single programming language ever? Yes, but some languages make it easier than others. Saying that its possible in every language so your particular language's warts aren't a big deal is a pretty narrow-sighted thing to say. Brainfuck is turing complete, but its not a good idea to write serious apps in it.
But we're not talking about Turing-completeness; we're talking about being able to find bad, copypaste-able code online. This is possible in any language, and has nothing to do with the language itself— it has to do with the community. There are many gripes against PHP. You don't have to make any up.
&gt; But we're not talking about Turing-completeness; I was using it in as a poor analogy. Just because you can write bad code in any language doesn't mean you'd want to pick a language that pretty much forces you to write bad code. PHP doesn't force you to write bad code, but it certainly wiggles its eyebrows suggestively at you. &gt; we're talking about being able to find bad, copypaste-able code online. This is possible in any language, and has nothing to do with the language itself— it has to do with the community. Yes, and some languages have better communities than others. Whether one *can* find bad code or *can* write bad code is irrelevant. What is relevant is how easy it is to do so compared with writing code the wrong way. If it is easy to do the wrong way, then newbies will tend to do things the wrong way. Network effects mean that the "wrong way" will get propagated easier, unless the community expends extra effort into correcting misconceptions. This is in contrast to a language that encourages its users to do things the right way -- in this case the right way becomes commonplace with much less effort from the community. PHP, in both its libraries and communities, has historically made it easy to do the incorrect way (magic quotes anyone?) It has gotten better, but, from my point of view, it is still struggling with its legacy. &gt; There are many gripes against PHP. You don't have to make any up. I'll keep that in mind should I feel the urge to make things up about PHP. As it stands, I haven't made anything up. "You can do it wrong in any language," is, and always has been a **terrible** excuse for programming languages. I flat out reject it as a viable argument.
Yeah, based on the questions the OP is asking s/he'll need to learn _a lot_ before this project would even be halfway feasible.
You can fix the atomic issue with a symlink. Keep your code in directories like this: /srv/your-app/2011-09-03-130104/index.php /srv/your-app/2011-09-03-130104/includes.php /srv/your-app/2011-09-03-130104/etc... (The directory name is the date and time of the deploy) Then have a current symlink which links to the most recent deploy: /srv/your-app/current =&gt; /srv/your-app/2011-09-03-130104 To deploy new code atomically, rsync up the new directory and then switch the current symlink to point at it once it's uploaded. For bonus points, have a second symlink called /srv/your-app/previous which always points to the previous deploy directory - that way you can easily revert back to the previous known good deploy if something goes wrong.
&gt;no really actually likes PHP May I direct your attention here: [/r/php](http://reddit.com/r/php). There are plenty of us that love php.
I'm coming from pylons, and even though I prefer the return a dict approach from pyramid, unfortunately, I had invested quite a bit of energy into adapting pylons to handle what I wanted. I wrote a lot of code to have a single controller action present the same data in multiple ways, depending on the URL, request method, etc. Basically hamfisting my way around the limitations I perceived in pylons. Since I was learning (pylons, that is) as I went, I also wrote some code that isn't too pretty and is kind of biting me in the ass with respect to the migration. Part of that is pylons, and the larger part is me, I know. And long run, I'll be better off investing the effort into moving to pyramid since it more closely matches what I wanted anyway. tl;dr: Basically I need to rewire a bunch of stuff I should have written and it's tedious for me to do so. Not the problem of the framework authors or anybody else. Just frustrating.
Yes, companies are motivated by profits, but they're not supposed to be dumb about it. If you can make $7 trillion in Q1 by blowing up the Earth, only an idiot would do it, because in Q2, you'll make $0. If AppEngine stays stuck on Python 2 and stays slow forever, people will switch to something else. Google needs to retain customers and get good word of mouth expansion by making things run smoothly.
&gt; Instead, you'll see options like synchronize this online application with a git-hub (or similar) hosted WSGI application, map it to this url, and use these database options. AppEngine is a good example of this new style of hosting. Ya, that's where the market is moving. But expect to see a more rapid adoption of RoR as a platform as opposed to python. What's really needed for this is buy in from the major control panel vendors. I know for a fact that cPanel takes feature requests pretty seriously (forums.cpanel.net).
perl was the defacto web scripting language before PHP.
I'm sorry! D: I didn't mean to offend, honest... It's just that with my limited experience in coding I don't have much practical experience to negate what I read. And, what I've read is that no one is really enthusiastic about PHP, but rather, it's something people deal with.
Sure, me neither. But in that space, Python, Java, etc. are just as popular. None of them are "the standard".
No, it's the standard. That doesn't mean it's a good standard If you ever have the chance, poke around /home on a shared host. It'll be 90% php. If a host is setting up services, they are *required* to have PHP, they are not required to have anything else. 
You might consider using the strategy outlined here to port the application piecemeal: https://docs.pylonsproject.org/projects/pyramid_cookbook/dev/porting.html Or of course, you can continue to use Pylons. It's not dead or anything; it's maintained but not improved.
I don't think a shared host would be a very accurate gauge. Real businesses don't run off of shared hosts, they have their own infrastructure. I think you're vastly underestimating the amount of Java and ASP.NET enterprise web applications out there. Besides, just because PHP is popular, it doesn't make it any kind of standard.
&gt;PHP, in both its libraries and communities, has historically made it easy to do the incorrect way (magic quotes anyone?) It has gotten better, but, from my point of view, it is still struggling with its legacy. But the original statement was that PHP is a bad language because there are bloggers who write bad code, not that it's *easy* to write bad code. I agree that PHP makes it easy; I do *not* agree that PHP is a bad language because some amateurs writing PHP tutorials don't practice wise security measures. That has less to do with the language and more to do with the language's popularity.
Oh my goodness. Thanks so much. This is awesome.
It's complex, supports regex, and has a standard theme format meaning you can share between IDEs. See: https://github.com/radiosilence/Dogs-ColourScheme/raw/master/dogs-sublime.png
moron question
whatever you do, for the love of kittens, DO NOT execute that line.
I'd agree with that, not a ruby fan. But they have had better upgrade systems and haven't created a divide like python did with not allowing 2.x scripts to run on 3.
from the wxpython devs: "Python 3.x support: (unknown) It is expected that some things being done for the Next Generation project will make it easier to be able to maintain support for both Python 2.x and 3.x in the same source tree, so I've been delaying putting much effort into a Python 3.x port in order to prevent wasting time on something that may end up getting thrown away once the NG switch is made. If that Next Generation project ends up being left on-hold for too long however then I'll probably revisit this item and move up the priority" Python 3 is still largely unadopted but its getting better every week.
but why oh why is it so widely adopted, I mean I drool at Java job opportunities!
During the bubble php was easier to learn than perl. IMO that is the only reason. 
yes and the answer was a joke about the joke. Buy yourself some sense of humor ;-)
Good package management but again it comes down to 3.x not running 2.x do now lots of packages are not running up to date. Rvm and gems have done a better job of staying up to date.
Non. N'est ce pas. Vraiment!
At least on a mac, it's extremely clunky and unpleasant. For one thing, it can't deal with a single script generating multiple plots in any sensible way. The plots themselves are so-so in quality, not the worst but nothing like what's available in R or mathematica.
That image is just hidden out of the way as a joke. Either way you would have to go out of your way to make it show up where as this is the starting screen you actually see. http://git.gnome.org/browse/gimp/plain/data/images/gimp-splash-2.6.png And if you or your co-workers are that much of a prude you can easily remove the name gimp from the logo if you want. Most Gimp imagery is of Wilber the dog and not their name. Of course I managed to use it at work and even speak the forbidden name without anyone getting offended or giggling.
Python should never be like PHP. 
Python will quite happily run as a CGI if you don't mind the startup time of the parser. Works fine for simple form processing scripts though.
Thank you for this info...
How does the performance take a hit? I thought wsgi was more preferred over fastcgi.
If you're on shared hosting like WebFaction, you'll have your own Apache restart script which runs in your user. If you've got a DS, you can simply do apache2ctl graceful
You can't really compare RoR to Python. RoR is a web framework, Python is a language. It would be more accurate to compare Ruby on Rails to Django. However, I'm not sure I agree with your post. The syntax for Python is significantly easier for beginners to understand than Ruby. The Rails ecosystem has some great resources out there, but I'm not sure that trumps the simple 'Type in and see what I get' factor.
It appears to be one of the entries for http://www.pycontest.net/job My solution (4th place) was seven_seg=lambda x,j=''.join:j(j(" _ | |_ _|_|"[ord('¼$ØÚdÊÌ¤ìê'[int(q)])/l&amp;14:][:3]for q in x)+"\n"for l in(64,8,1))
Would you say Gunicorn is ready for serving in a production environment?
I built an entire web framework around the ZODB which I absolutely love. However, I did miss SQLs reporting ability. Apples and Oranges. Coding with OODBs is faster because you don't have to worry about SQL or using an ORM, but there's no analogue for aggregate reports etc.
Indeed. One wonders how English-speakers would respond if that language was mangled to similar degree as often. Edit: 'walla' reminds me more of the generic Arabic oath 'wallah' ([I swear] by God), than 'voilà'.
It's worth it. There a different licenses depending on your use. 
They are fixing that for Mac users: http://wiki.wingware.com/FeatureRequests
In my experience English is mangled more often than other languages, simply as a product of the number of non first-language speakers. Actually, first-language speakers mangle the shit out of English, too. *Addendum:* Oftentimes when speaking a language other than English, I encounter the puzzled expression of "that makes no sense whatsoever and I refuse to parse it" when there is a minor grammatical mistake. Whereas English speakers, especially in Britain, are so used to people speaking English very badly (Eastern Europeans, Indians, Chinese) that they use lax parsing and just-fucking-figure-it-out. Actually I heard from some English speakers that Americans refuse to lax-parse, too, as if minor pronunciation differences obfuscate meaning entirely. "You pronounced the 'T' in that word? Hah, bad luck pal, no comprehension from me!" (I should point out that this is merely a point of interest for me; from my experience in America I was understood perfectly throughout and encountered no issues; it's likely hinged on exposure to foreigners.)
That's an interesting discussion you had over there on pythonsg. Thanks for posting. And the Singapore manners are fascinating! The general conclusion you reached is correct: you need to define, accept, and discharge project roles and responsibilities. Regarding your specific concern at seeing external source in a repository: be not afraid. This is actually an ancient configuration management strategy. In the dark ages when CVS was king, it evolved to the "vendor branch pattern", which was a way of doing DVCS before the term was invented. It gave the configuration manager fine grain control over exactly what upstream changes to the vendor's code you accepted into your project. 
Just a quick fyi: the phrase is "by *and* large". Edit: turns out the root is fairly [interesting](http://www.phrases.org.uk/meanings/by-and-large.html). Edit2: notes dupe. But my link is good nonetheless, so I'll leave it here.
CherryPy does that too, per default. I dunno how it works when you aren't using the built-in HTTP server though.
Unlimited not enough?
PHP was first, or rather all the modern web dev stuff for Python came later. Also the built-in templating made it easy to add a bit of PHP code here and there to existing static HTML websites, but in Python you need to be pretty well-versed in programming to even do a basic website.
[PyFilesystem](http://code.google.com/p/pyfilesystem/) gives you a much nicer interface to ftp. &gt;&gt;&gt; from fs.opener import fsopendir &gt;&gt;&gt; ftp = fsopendir('ftp://ftp.mozilla.org') &gt;&gt;&gt; ftp.listdir() [u'README', u'index.html', u'pub'] 
I always config the views.py in django as `touch-reload` when using uwsgi. Everytime I deploy code from source repo to prod server it auto reloads the new code.
You might like this post I wrote a couple of years ago [comparing Python and Ruby techniques in this area](http://positiveincline.com/index.php/2009/06/dynamically-extending-object-behaviour-in-ruby-and-python-a-quick-warts-and-all-comparison/). Although you can achieve similar results with either it's interesting to see just how different the two languages are underneath.
Why change the name when it's not a whole new language? Windows NT and derivatives broke compatibility with lots of programs too, they still retained the Windows moniker because it was the same idea and they had a brand. Now, if Python retained nothing but the brand, it would have been wrong. But lots of programs are trivial to convert and some can even be done automatically (2to3). Regarding libraries: If you are using an unsupported library (i.e. author doesn't update to v3), that's just *one* of your problems. Regarding print(): What's so bad about this? You didn't explain anything. I, for one, believe that it is better using a function, since they are used everywhere and every Python programmer knows what it is. Print was magic to novices before. Regarding WordPress: PHP was 8 years old when WordPress first came out. Your argument doesn't make sense. There may be lots of WordPress sites, but those people are just users. I don't think their use really makes the language more popular, they just use WordPress (and therefore PHP) because it is the most popular blogging solution. WordPress appeared at a time where blogging was unknown to more people (therefore easily quickly building a large user base) and it used a platform that was already widely available.
Facebook has a lot of C processes which massage the data and generate lookup tables for fast retrieval. PHP is largely the views.
Speaking of trouble: lambda-mode looks nice, but pressing backspace on any λ crashes emacs (24.0.50.1-git) with SIGABRT
Perl got there first
&gt; Breaking backward compatibility with 2.x was a terrible mistake. I don't care if there are great reasons to make those changes You don't care, but others do. Wait a few more years and everything will be running Python 3. &gt; turning print into a function from a novice's perspective is mind numbingly bad I don't think English has a single word to express how I feel, so here's this: **ಠ_ಠ** First of all, statements like while or print are a retarded Fortran legacy. The poor cousin of expressions, they are exactly the same as any other language feature, only they can't be used anywhere. They are no different from expressions, and most expressions can fortunately be functions, which are first-class values of the language which you can manipulate and pass around. Statements are made to be different and limited just because. print as a statement is a retarded limitation over what should be real function. As a function, print can be passed around as a first-class object, introspected, renamed, decorated, replaced and whatever you need. As a statement, it's worthless. For example, in Python 3 you can do map(print, some_array). Please learn deeper aspects of programming before complaining abuot a Fortran-like legacy. You still haven't said why it's mind-numbingly bad; is it because now you have to type parens? Statements exist because people still don't know how they are shooting themselves in the feet for absolutely no gain with them, and these people are both creating programming languages and demanding programming languages they can use, which hurts. Not only print should be an expression and preferrably a function, but so should def, class, if, while, try, with, import, from, return, yield and everything else. The fact they aren't in Python 3 is my single main gripe with the language and the core reason why I consider it inferior to Lisps. Not homoiconicity, not macros, not tail call elimination (which is my second biggest gripe with it); the main reason why I think Python is a great but not a terribly great programming language is that not everything is an expression. One quality of a programming language is expressiveness: how you can combine its structures and shape them how you need. If you want further insight into programming and programming language design, I suggest you learn Scheme/Racket, maybe through SICP. &gt; IMHO Python 3.0 should be morphed into a new language The idea is that everything migrates to Python 3 so Python 2 can die one day. It's not about yet another programming language, it's about the evolution of one.
I'm in there; doesn't mean I like it :P
Most web "developers" aren't even programmers.
Are you familiar with [Dive Into Python](http://diveintopython3.org/files.html), specifically the _Files_ chapter? There's also a great chapter on regex. It's a great book, and it's available online for free. Addendum: the above link is for python 3 language; you might find that you have to use 2.x, in which case check out the earlier _Dive_ book, specifically [the files chapter](http://diveintopython.org/file_handling/file_objects.html) and [the regex chapter](http://diveintopython.org/regular_expressions/index.html)
Not yet.... but i will be, thanks. I started looking at the google classes too. Pretty useful. I went for 2.x, based on the logic offered on the python download page. Correct you think? Or worth starting with 3 these days? Edit just had a peek, looks really cleanly written. I'll dig into it in the morning. Thanks.
For me it depends on two things: 1. Do you require libraries that are 2 only? 2. Are you likely to be adding to or writing for a system that's already written in 2? If either of the above are true, use 2, else just use 3 from the start. As an example, I use 3 for everything I can, but need to stick with 2 for the time being for some stuff where I'm using _numpy_ and _scipy_. 2.7.x (or any &gt; 2.6?) pull some stuff from the 3 branch too.
Ah. Ok. I might start over with 3 then. I've not got very far, so am unlikely to have learnt a great deal that needs unlearnt, and I have no legacy to manage. Thanks. 
Hehe, go take a look at the WordPress source and say that again ;) I've been coding PHP (amongst other languages) for a decade, so you can imagine I've seen my fair share of shoddy code. WP made me exclaim: "eww!" so many times :D I hope you realise I'm not actually arguing with you, just posting for your amusement.
I code in Python 2. I do not object to Python 3 breaking compatibility, in fact I think it's a great thing; the purer the language: the better. 2to3 is a great approach to urging libraries through the transition. If the libraries aren't maintained then they'll slowly lose their users over time anyway, Python 3 will be yet another contributing factor. You don't want to move to Python 3 because it seems like hard work, and a bunch of libs you rely on see that transition the same way you do? Stick to Python 2. Nobody is going to knock down the door to your office and "rm -rf" your Python 2 installation. The libs you rely on won't browse reddit of their own accord and decide that Python 3 has hit critical mass and they have to commit suicide. Your stuff will sit there chugging away, working just fine. Also, it's "christen" (which is a verb), not "christian" (a confusingy uncapitalised proper noun). And your use of "it's" in "it's 5 minute" is incorrect; it should be "its" as you meant to use the possessive form.
&gt; You don't care, but others do. That's exactly my point. To at least this novice user these things make it harder to get into. Clearly many senior Python gurus wanted these changes or they wouldn't have happened. &gt; so here's this: ಠ_ಠ That just about sums up how the Python community feels about newbies. &gt; Please learn deeper aspects of programming before Again, the OP is wondering why in the world Python is being outdone by PHP. I articulated my reasons why I think it's lagging, and you reinforced nearly to a T the hard core programmers only attitude of the Python community. &gt; map(print, some_array) A compromise that would have favored beginners would be for the senior programmers write a helper print function to accomplish this. Instead they obfuscated the every day utility of it by making it a function and necessitating extra syntax. When you're learning a language you tend to use prints everywhere just to check the value of things. &gt; why it's mind-numbingly bad; is it because now you have to type parens? Annoying more syntactical for little immediate perceived benefit. &gt; The idea is that everything migrates to Python 3 so Python 2 can die one day. It's not about yet another programming language, it's about the evolution of one. Yes, and I propose a different idea. One that accommodates the novices and let's the Python 3 initiatives continue on their path. &gt; Wait a few more years and everything will be running Python 3. I'm wondering about that. Maybe it will, maybe it will stay in limbo. If the Python community at large loses momentum then what's the motivation to do more work on it? Some things that might be interpreted as warning signs are Guido stepping down and Py 3 [dropping support for various platforms](http://blog.python.org/2011/05/python-33-to-drop-support-for-os2.html). I think it dropped support for some other platforms as well, perhaps something mobile, but I don't immediately find it. I'm for Python and would like to see it succeed. Appreciate the tips on Scheme/Racket. Perhaps one day I'll check it out. As it is, I don't have the time or commitment to become an intermediate/senior programmer which is what it seems is required to keep up with it.
You imply below that you're using git - we do a local clone and then a pull, much quicker than a remote clone!
Whats the standard python template language?
Reason 1: It's very easy to get started. &lt;?php echo "Hello World"; ?&gt; Drop that file on your web server and you're already using PHP. Compare with Python where you normally have to install one of a large number of types of software, learn its syntax, and even then still usually have to edit 4 or 5 files to get something to show on screen. Why do you have to install something for Python? Well... Reason 2: PHP (normally) runs one page at a time. It doesn't require a background process, and therefore is unlikely to hog memory or CPU power if something is coded wrongly, unlike a Python web app. This makes it a safe choice for commodity hosting, which is what most people use, or at least learn on. So by the time they're in a position to consider using Python, they're probably already quite experienced at working with PHP. But why couldn't Python do this? Couldn't we get Python web dev on commodity hosting with a few changes? Well... Reason 3: Python is a general purpose language; PHP is a language and a bare-bones web development framework in one. When you install PHP you have the language and, web-server permitting, you can serve up the pages too. Python does not come with this capability. You have to choose which of the 3rd party web development frameworks you wish to use, and these typically range from the PHP-like (eg. Python Server Pages) to all-singing all-dancing content-management systems like Django, with a plethora of choices in the middle like Pylons, Turbogears, Flask, etc. Which one of these would you choose to make the 'standard' Python web install? Couldn't we just have picked one? No, because again, Python is a general purpose language, and there are conflicting requirements. Most of the users of Python are interested in typical application programming, not web development, and would prefer to write a server as a long-running process, meaning they can use all the best practices from application development. This is not compatible with the PHP style of one-script-per-page approach, nor with the idea of only running the process for the duration of that page request. So ultimately it's been left to the individual developer to choose. And this has meant... Reason 4: There's no clear place to start with Python web development. With PHP there are various frameworks but you don't need any of them to get started. With Python, you need to pick one, and you usually need to make this choice based on the answers to questions you don't yet fully understand - such as what kind of processes your web server supports, whether you'll be able to install extra packages on there, whether it runs Python 2.4, 2.5, 2.6, 2.7, or 3.x, whether you want MVC or not, what kind of template language you want, whether you want an Object Relational Mapper or not, if you need authentication/authorisation built in, whether you want form-generation and handling or want to do it manually, whether you prefer to map URLs to functions directly or have them link to files/functions/views implicity, etc etc. More often than not you'll pick one, work through the tutorial, think "Great! It works!", and then start on your own project and get stuck when you discover that the documentation is 2 years out of date, or it doesn't support X feature, or it can only do Y if you install packages A,B,C, and D and ask on the mailing list for B about C compatibility, or you find that they no longer use the same ORM as they did in the tutorial so half the documentation is completely irrelevant, or they DO use the same ORM but that's upgraded and changed all its syntax so you can't understand it any more, or they implement 2 parallel features to appease people from different alternative frameworks but never explain the benefits of each... aargh. Python web development is not for the faint-hearted. You have to be comfortable with reading through source code, poring over page after page of Google Groups, and searching multiple mailing lists to find the answers to what you want. This brings me to an addendum that... Reason 5: PHP's documentation is much superior to that of Python's web frameworks. You want to know how to do something, then you'll almost always find an explanation on php.net. It may be awful code or outdated or insecure or all of the above, but you can get the job done. With Python, the language documentation is pretty good (though too often the useful stuff is buried in the tutorial, rather than in a reference), the web development expertise is split across 4 or 5 big frameworks, 4 or 5 big support libraries, and 20 smaller ones, and you have to cast the net wide to get all the information you need. Mailing lists, Google Groups, various websites (often never finished), blogs, and StackOverflow - you'll need all of these for anything more than the most trivial site. That takes time and effort that, if you were using a more homogeneous environment like PHP, would not be necessary.
voilà
I've seen a number of REST API wrappers use this approach, it's a lot easier to maintain a list of mappings than it is to maintain separate methods for every single endpoint. Consider the [flickr API](http://www.flickr.com/services/api/), you don't even need to maintain a mapping of endpoints since all methods use the same endpoint. It's a bit magic, but instead of writing 50 methods you can just override `__getattr__` and they'll all just work. If you need to massage the data returned using decorators wouldn't be a bad approach.
there's a csv module for reading csvs (http://docs.python.org/library/csv.html). 
Don't write an operating system with it.
Wow. So if PHP does something better than Python, you'd rather Python keep doing it worse... *just* so that it wont be "like PHP"? wtf is that about?
&gt;But thanks for your condescending tone through your comments. Dude, if you're doing strange things, expect people to do this: 0_o &gt;we've made quite a few changes/fixes to Zend and use a lot of the library everywhere. So basically you can no longer update Zend with official releases, because you did what you're not supposed to do, and modified a 3rd party library instead of extending it...?
[Relevant](http://www.reddit.com/r/Ubuntu/comments/ics7u/why_does_youtube_flash_video_run_jerky_shitty_on/c22u181) The way mashmorgan used Walla is acceptable too without being related to voilà.
There's some things the books won't tell you; 1. Crunch large datasets using generators so only the things that need to be in memory are. i.e. stay away from appending 6Gb of data into a list, unless of course your system has 8Gb+ of ram and you know you're not going to exceed system limits. 2. Most structured files have an existing module for i/o purposes, and they all pretty much implement the same interface. So for your CSV files, don't try to parse them the hard way with `line.split(',')` or the '`re`' module - use the existing '`csv`' module instead. 3. Use IPython as your 'python' interpreter. It'll make debugging much easier. You can get some plugins like ipdb that make the python debugger invoke ipython even if you ran the program with the std python interpreter. Python has really good introspection and ipython makes use of that. 4. If it doesn't exist in the stdlib, look on pypi for an existing module. 5. Research what modules people regularly use in your target domain. If you're familiar with Matlab, you'll want to use `numpy` and `matplotlib`. There's a lot of cool stuff out there. 6. Stick with Python 2.7 for now, most of the useful stuff from Python 3.2 is backported and the stuff you want (numpy, matplotlib, etc) is the best supported right now. But use "`from __future__ import print_function`" and start using print-as-a-function as in Python 3 so possibly *the* most common keyword is forward-compatible. 7. Look for similar projects to what you need on github / bitbucket and experiment with how they do things. Remember python supports procedural, functional and object-oriented paradigms &amp; you're free to mix them. Some ways will work better than others. e.g. `dict` types are O(1) lookup so they shit all over lists for structured data. Learn to love the '`collections`', '`functools`' &amp; '`itertools`' stdlib modules. 8. Some of the python core devs post neat tips on twitter, find &amp; follow them 
&gt; To at least this novice user these things make it harder to get into. I'm genuinely sorry it's more difficult for starters (I'd rather have Python be very user welcoming so more people use it), but it's necessary (or very, very, very desirable) for other Python programmers and probably the guys at Google and other companies who get paid to develop Python; that's why it was done. &gt; That just about sums up how the Python community feels about newbies. Hahaha, it's probably true. While being less newbie-friendly, the good thing about being strict is that it sets a high standard. Once you're in, you're in for a world of good. A bad thing about PHP is that it's so easy to start, but it's also so easy to do it all wrong. register_globals, magic_quotes, `&lt;?mysql_query("INSERT INTO table VALUES ($lol)";?&gt;` and so on. Everybody's in, including webmasters who can't tell a function from a tapir, producing all kinds of bullshit. It wouldn't be a problem if it weren't for the fact you end up having to use and what's worse, fix and maintain their bullshit, because boss X wants/hires you to use Y. I really prefer to enforce higher standards; it forces me to be a better programmer and it forces others to not produce shit. &gt; A compromise that would have favored beginners would be for the senior programmers write a helper print function to accomplish this. I agree that it would have been more backwards compatible to make a new print builtin function (maybe call it out), then keep print as a statement (though I'd rather make it an expression, even with its special syntax). &gt; Annoying more syntactical for little immediate perceived benefit. However, for completely new users, there's no harm in requiring parens, if it's a function after all. I would rather have to type parens everywhere (as in Lisp) than be able to omit them everywhere and complicate the syntax (as in Perl). IMHO making a special case for print with a print special expression is a special feature that doesn't feel to come with special enough justification. &gt; Yes, and I propose a different idea. One that accommodates the novices and let's the Python 3 initiatives continue on their path. Python 3 can't really get adopted if there's no plan to have Python 2 die. It's hard enough to convince ponty-haired bosses to use Python, it'd be even harder to convince them to use &lt;all-new-language-they-havent-read-about-in-a-mag&gt;. &gt; Guido stepping down This will be a good thing; I hope we can finally get functional programming features into the language. &gt; Py 3 dropping support for various platforms They are ancient platforms that have been deprecated by their vendors for years. Nobody should be using them anyways. I wouldn't support them myself if I were maintaining Python. &gt; Appreciate the tips on Scheme/Racket. Perhaps one day I'll check it out. As it is, I don't have the time or commitment to become an intermediate/senior programmer which is what it seems is required to keep up with it. If you ever try Scheme and/or Racket (which is a Scheme "with stuff", an IDE, and awesome libraries - ready for production use) and make an effort to understand and master it, you'll go from intermediate programmer to god programmer.
1. Yeah, that's rather complex. You should basically be able to get by with `open('file.txt', buffering=1)`, which basically buffers the file by line. For memory-saving reasons and depending on what you want to do with this text, you could theoretically separate your multi-gigabyte file simply like this. criteria1 = open('blah1', 'w', buffering=1) criteria2 = open('blah2', 'w', buffering=1) for line in open('hugefile.txt', buffering=1): if re.match(r'stuff[0-9] that goes into 1', line): criteria1.write(line) elif re.match(r'stuff[0-9] that goes into 2', line): criteria2.write(line) criteria1.close() criteria2.close() 2. I usually don't mess with re.compile because I generally don't build huge regex, and I just get by with specifying the regex directly in the function. You don't even have to prepend your regex with r, really... //Matches ('Speaker', 'blah de blah text') in 'Speaker: blah de blah text' re.search('([A-Za-z&amp;\\(\\) ]+?) *:+ *(.*)', line) 3. I just scroll up to find equal signs if I forget, but if you have trouble understanding the code itself, do some `print()` and some tests to find out what's happening to your variables at different stages in the code. Also, scope in Python will probably not affect you yet. 4. You forgot to read the file. I know, I've done something like that too. stuff = open('file', 'r').read() // Py3 version print(stuff) // Py2 print stuff 5. Use the csv module. ;)
Guido has beard.
I would LOVE for wxPython to be ported to Python 3! I reckon they should do like the [PyPy folks](http://mail.python.org/pipermail/pypy-dev/2011-September/008288.html) if it's the usual case of lack of development resources. Also, matplotlib and py2exe/py2app should follow suit. It's been far too long without Python 3 support.
&gt; Who came up with that rule? Well, according to [PEP8](http://www.python.org/dev/peps/pep-0008/), it was Guido van Rossum and Barry Warsaw. 
Shitty question. Well let's see. What is Python? it's an relatively new, interpreted, dynamically typed, loosely object oriented, programming language which is currently in between two major versions (2.8 and 3+). * So if it's relatively new, it won't have as many libraries, legacy features, mature libraries, comprehensive documentation as older languages, arguably. * It's interpreted so it isn't as fast as C (which doesn't do behind the scenes error checking, memory management). Even if you can compile it, you're compiling parts of the logic inside the runtime. Remember that C is portable assembly, aka platform independent. * Dynamically typed, so fewer errors are caught at compile time than other languages, which may arguably lead to a poorer quality product. Function calls, garbage lines of code are not caught until too late perhaps or more time must be devoted to testing the code at runtime to ensure all the data types are as expected. * Object Orientated so maybe not appropriate for some things, compared to LISP, Prolog etc. You get the idea yeah? So now you can take this concept and use it to compare lots of languages. 
PEP 8 only talks about clashes with keywords: &gt; - single_trailing_underscore_: used by convention to avoid conflicts with Python keyword, e.g. &gt; Tkinter.Toplevel(master, class_='ClassName')
AFAIK, the only available py3k GUI toolkits available are PyQt and Tk.
I agree. As I said, it's harder to learn how to write good code in PHP than in Python. In fact, from my experience I would say that a lot of people who write bad code in Python come from another language trying to apply its principles in Python whereas the same will often result in better code in PHP. The intuitive answer in PHP is usually wrong. That's all I'm going to say about that.
What is this "Next Generation" project....I never heard of it. *wonders why*
Just get WingIDE and put it in VIM mode :) Way easier!
Yeah, I've been reading about security issues with the protocol, I really didn't know it was that problematic. SSH is the way to go then?
#2 Wow!! If I call a regex once or twice, than I don't compile, BUT, if I'm going to call it a lot, as it is often the case in a parser, because you're looping over a big file, then I've checked and compiling the regex does save you a lot of time. Also, compiling and using compiled regex is not that complicated.
I live in the state of Georgia where they mispronounce EVERY FUCKING TOWN. Martinez is pronounced like "Martin-Ezz", Houston "HOW stun", etc... right on down the line. I live literally 10 miles south of a town named Buchanan. It is literally the next town. If, in a conversation, you mention you are going to "Bew-canon" people here stare at you quizzically. You repeat it twice, the describe that you are going North on 27 over the interstate and there is where you will stop and they say "OH! You're going to "BUCKhannon!" Ok!" The same thing happened when I lived near Martinez. 
1) This is a file I/O problem, not a regex problem. Since you obviously can't read the whole file into memory, read just the smallest part that's needed to do processing at one time. If the file is semantically line structured, this could be one line at a time. 2) I don't know what you mean when you say multiple re's are joined in the compile call, but that sounds very suspicious. 3) The built-in locals() function will return the local namespace's dictionary that maps variable identifiers to their values. globals() does the same for the global namespace, and other objects have `__dict__` attributes if you really need it. I believe modifying these dictionaries directly is not guaranteed to always produce the expected effect. 4) The open call returns the file IO object, which you must call a method on to get the file contents. If you're working in python 2x: http://docs.python.org/library/stdtypes.html#bltin-file-objects python 3x: http://docs.python.org/py3k/library/io.html 
If I was going to spend the money, I'd get the one with all the features. $95 is a bit steep though and the $45 one looks like it lacks a lot.
 import pylab as mpl #create two test cases test = [] test.append( range(10) ) test.append( [ xx*xx for xx in range(10) ] ) #loop that generates multiple plots in a sensible way for case in test: mpl.figure() mpl.plot(case) #show our plots mpl.show() 
Also there's a memory footprint issue in shared hostings. You could have thousands of websites made in PHP "running" but only a couple of python for the same memory.
The link you posted to is from 2009...much of what is written there is wrong. Example: "No powerful IDE for Python" Ever heard of WingIDE? or the countless others?
No, you can only apply for an API key with a premium spotify account.
Learning the Vi/Vim editors. This is a good beginner to average to expert book. The only, up to date complete book on Vim. Others are either not books, incomplete, or out dated.
Oh I see. He does have a point though. @above I guess I'll check those out after I get home.
I think that has a lot more to do with the fact that php is "established" and it's been around and widely accessible for such a long time, so a lot of people end up working on php projects even if it's not their first choice in language. As opposed to Python, where anyone working in that clearly already likes it enough to put the effort into either finding a server or setting one up to develop in Python. When something is the vast majority, you're bound to find a lot of people talking about how they don't like it.
Uh, they did ship the 2to3 converter which will in fact convert most scripts. Anyway, that's the *point* of a major version bump. It breaks stuff. In fact, my main beef with Py3 is that they didn't go FAR ENOUGH. 
Matplotlib has a working but unreleased [Python 3 branch](https://github.com/matplotlib/matplotlib-py3) that can be compiled. For binary packaging, only [cx_Freeze](http://cx-freeze.sourceforge.net/) seems to have got there yet. PyInstaller has a [ticket](http://www.pyinstaller.org/ticket/85) open, but it doesn't look like anyone's working on it.
...Only when you explicitly configure it on the site to do so, and usually on the dev/non-live site usually since it slows performance.
In wsgi daemon mode this works. In embedded mode you have to restart Apache. 
I'm going through that chapter right now, pretty cool... Python regex stuff is pretty powerful
Try Pyinstaller instead: http://www.pyinstaller.org/ Its function is similar to py2exe but it also generates Mac OS X and Linux binaries. See: http://www.pyinstaller.org/wiki/SupportedPackages -- Note: wxPython is supported.
Thanks, I'll have to try it. 
The tricky thing with "the useful stuff" is that with almost any software, people have vastly different ideas of which bits are useful. I've never used SAS, but do you *know* there are large parts that no-one uses? Other groups might use it in quite a different way to how you use it.
Seconded, PyInstaller works great with wxPython and completely skips over the MSVCR*.DLL problem. PyInstaller also works with lots of packages that aren't listed in that Supported Packages list, e.g. [xlrd](http://pypi.python.org/pypi/xlrd). I just put together a wxPython + matplotlib + xlrd app last month with PyInstaller and it was just about painless.
No, with web2py, changes are reflected immediately -- no special configuration required, and it doesn't slow anything down. If you have bytecode compiled your app (which improves the speed), though, you will need to re-compile.
Awesome! I was hoping I wouldn't have to rewrite my program in a new GUI.
Nice list, though you should have listed vundle first! I installed most of those by hand, then looked at vundle and had to install them all again :P
Erlang can do that no problemo.
http://www.devpicayune.com/entry/building-python-26-executables-for-windows
Sure it *works*, but running a crappy editor like Notepad++ on an OS with actual powerful editors is the devil's work, friend.
I have both Eirc4 and Eirc5 on my windows box, and I compiled nothing. I could go look up the downloads again, but I'm pretty sure I just went to the website and clicked "Download"...
Will that not delete some other pixmaps you may want to keep? Or is it basically just the ugly troll in there?
N.B. Qt and PyPy are not at all comparable. Qt is a UI framework, PyPy is a Python interpreter. Each may have some value in this project, although at the moment I don't think you can use them together. Using standard Python, you can use PyQt to create Qt interfaces. As far as I can see, what you want to do is write a free (partial?) implementation of SAS in Python. A few thoughts: * Do not underestimate how difficult it will be to correctly deal with even fairly simple code. You're really making a huge challenge for yourself here. * There's plenty of open source statistics stuff out there. It's probably more realistic to try to improve that and persuade people to adopt it over SAS, than it is to try to provide a drop-in replacement for SAS. You already know about R, and there's stuff under development for doing stats in Python. * Your other comments suggest that you want a way of executing SAS code directly as Python code, or of doing some simple transformations to make it into Python code. I think this is very unlikely to work for anything beyond a few simple statements. The syntax is very different - you will need to parse it into some abstract form (see Python's AST, Abstract Syntax Tree, for comparison). I notice on your blog that you compare Pylab to Matlab. But Pylab is a *similar interface*, and definitely not a drop in replacement. You cannot take a matlab file and run it in pylab. Providing similar SAS-like tools for Python would probably be a much more tractable task. Also, an unfortunate fact: if you copy SAS and undermine their business model, there's a chance the company that sells it will resort to asserting patents against you. IANAL, and I have no idea if they'd get anywhere with that, but it's something to be aware of.
acct_rdt did not state specifically that PHP was a bad language, but that it, and its community by extension, was "forgiving" in a manner that led newbies to do the wrong thing. I'm by no means a PHP expert, but this doesn't seem to be particularly controversial. Moreover, just because a language or community encourages you to do the wrong thing doesn't necessarily mean the language is without merit. I do most of my professional work in Java, which has some huge warts, but the size and depth of the ecosystem surrounding it still makes it a great go-to language for most problems, despite those warts.
I picked up the $95 and I couldn't be more pleased. Definitely worth it.
&gt; You don't want to move to Python 3 because it seems like hard work I'm on 2.x because Pyramid and Django are also on 2.x. As well as PIL and likely other tools I'll need to use. &gt; Your stuff will sit there chugging away, working just fine. There's a strong possibility that some tools will one day be 3.x compatible only and others will still be stuck on 2.x. What's with the grammar nazism. &gt; a confusingy uncapitalised proper noun I believe you meant confusing**l**y
I just put that DLL in the source folder and later in the app folder (PyQt4)
&gt; IMHO making a special case for print with a print special expression is a special feature that doesn't feel to come with special enough justification. This is where we differ on this one. I think print is so common the special syntax was justified. I would be for the 'out' function as a compromise. Water under the bridge now. &gt;you'll go from intermediate programmer to god programmer. As in all things practice makes perfect. Need to carve out the time and drum up the motivation to make any of that happen. Anyhow, thanks for the feedback.
Any unstated drawbacks we should be aware of?
I just set it up for the first time two weeks ago; haven't used it in a production environment yet. I... don't really know what people say when they mean production-ready; it just seems like an arbitrary gold stamp to me, most of the time. E.g., apache+mod_wsgi is vulnerable to slowloris while nginx+gunicorn isn't, so... if your definition of being production ready involves being resistent to slowloris, then apache+mod_wsgi is not production ready. Does gunicorn do whacky shit I don't expect it to? No, not that I've noticed. I'm primarily using it because it consumes far fewer resources and I'm generally using small VPS servers. I don't work on anything high-traffic.
Oh, of course. I use vim. :-)
&gt; Why change the name when it's not a whole new language? Because I like 2.x and want 3.x to go somewhere else. :D Plus Viper is a great natural name for Python++. &gt; Regarding print(): What's so bad about this? I was particularly fond of the simplicity of the previous syntax. As I noted in a different comment I think it was fine letting print be different than every other function. It's such a common idiom the shorthand version was great. &gt; PHP was 8 years old when WordPress first came out. I'm not familiar with the history so perhaps that suggestion is invalid. I don't know how popular PHP was prior to WordPress. I theorize that WordPress made PHP the gateway programming language for many people. But likely a truer reason it caught on was it was designed specifically for web applications, whereas Python was designed for programming in general. &gt; I don't think their use really makes the language more popular, they just use WordPress (and therefore PHP) because it is the most popular blogging solution. I was thinking in terms of plugins, themes, and the entire supporting market of tools available to support said users. A majority of them require PHP expertise.
This should get you started with the basic commands you need. # find lines that end in 'the end' and return 'the end' rex = re.compile(r'(the end)$') F = open('myfile.txt') # open for text read is the default for line in F: line = line.strip() # strip newline from end of line print line # print out the whole line M = rex.search(line) if M: print ' ',M.group(1) # print out the matched part, indented 
this. I thought this was a pretty standard deployment scheme with Capistrano / Drush / whatever currently being used ...
Fanboism. 
It's always good practice to use the r"" (raw) string. Otherwise, characters like \n and \b will not be matched correctly.
Why the downvotes exactly? Look at some job postings in SF, LA, NYC, Austin etc. I've been happily writing backend Python systems on contract for several years now; most of the *interesting* projects are not in PHP, most of the shitty clones being built by non-technical people are. 
cough cough google?
not "walla"
Production ready would be "Handles a number of concurrent requests without falling over." 
Pretty sure Google's Chrome OS supports this natively, too.
I have been using Komodo Edit in Vim mode since out of the IDEs it appears to have the most accurate Vim bindings while still providing IDE features. You almost certainly can replicate all the features provided by Komodo Edit in Vim(text snippets, autocomplete, local and remote browsing, templating, and hotkeyed terminal commands, to name a few), but it would take you a long time to do so. I find my time is better used writing code.
From sysadmin's perspective, it's mod_wsgi vs. mod_passenger &amp; implementing the proper automation for either. So yes, it is python vs. RoR. Unless you are talking about running your own http service (don't do this in shared hosting). And just because python is better, does not mean it will have quicker uptake within the market. The demand has been on RoR for awhile now.
oh... umm, yeah, there's a ridiculous number of benchmarks regarding concurrency tests in this setup, every single one of them agreeing that nginx+gunicorn is much more performant than apache+mod_wsgi. In my own benchmark I had only a simple blog, so it wasn't something substantial enough to be relevant for any application where performance *really* matters. Either way, here's what I was getting with a simple `ab -n 1000 -c 30` in Apache: Server Software: Apache/2.2.16 Document Path: / Document Length: 13640 bytes Concurrency Level: 30 Time taken for tests: 27.331 seconds Complete requests: 1000 Failed requests: 0 Write errors: 0 Total transferred: 13811564 bytes HTML transferred: 13640000 bytes Requests per second: 36.59 [#/sec] (mean) Time per request: 819.930 [ms] (mean) Time per request: 27.331 [ms] (mean, across all concurrent requests) Transfer rate: 493.50 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 0 0.3 0 3 Processing: 443 815 138.6 805 1584 Waiting: 443 804 138.7 798 1583 Total: 443 815 138.7 805 1586 and here's what I was seeing in nginx: Server Software: nginx Document Path: / Document Length: 13640 bytes Concurrency Level: 30 Time taken for tests: 8.952 seconds Complete requests: 1000 Failed requests: 0 Write errors: 0 Total transferred: 13770000 bytes HTML transferred: 13640000 bytes Requests per second: 111.70 [#/sec] (mean) Time per request: 268.570 [ms] (mean) Time per request: 8.952 [ms] (mean, across all concurrent requests) Transfer rate: 1502.09 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 0 1 0.5 0 10 Processing: 33 264 21.0 266 328 Waiting: 33 264 21.0 266 328 Total: 36 265 20.8 266 331 this is showing the homepage for a personal blogging engine that I wrote that (stupidly) translates markdown in the template layer because I haven't yet implemented a caching strategy for it, so this is "every request queries the database" situation, with the database being MySQL running on the same VPS. The server itself is a 512MB Linode slice. It's also on my first day of using nginx so the configuration could be tweaked more. edit: it's worth noting that the nginx setup also consumed about a quarter the amount of memory in this time, but I don't have any records for that. The ab records I just copied out of an email that I had sent to another web nerd.
Wow, that's a performance increase of between 3 to 4 times as efficient. I'll run some tests on my app on Friday and see how it goes. Although it looks like we're going to have to use Apache/Gunicorn since there are other apps depending on Apache.
I respectfully do not agree. Ruby on Rails is for building web apps, Python - out of the box - isn't. You can make your own webserver if you feel, but there is no equivalent to ActiveRecord or the URL handling magic which is where Rails is great for rapid application development. However, Python is really great at more than just web because it's just a language with a bunch of libraries. Once you're comfortable with the libraries and using the command line help, you could easily be implementing sockets or connecting to external hardware or reading from webcams or things which a web framework can do. I use Python daily for running simple general purpose scripts for deployment, find in files, resizing images on servers but I only ever use Ruby for web apps. Actually, I use SCSS which is Ruby, but I don't actually see any of the code, just run it from the command line.
^ Could not have articulated this point any better than this.
Right, sorry, I know what I was thinking of -- when importing modules, you have to explicitly set reload to true otherwise the python process will only import the module once.
Haha good point, edited.
The possibility the ecosystem moves on doesn't affect the stuff you write now that will continue to work the way it does now. If you want the new features, embrace the new ecosystem. The grammar corrections are teaching you to write correctly. Thanks for the typo correction :)
If You're asking for a alternative, py2exe work very well with pyqt, and they seem to work together to support it. 
1. See etrnloptimist's post. `for line in open("filename"):` 2. I would refer to the [very basic introduction in the tutorial](http://docs.python.org/dev/py3k/tutorial/stdlib.html#string-pattern-matching) and the [full re documentation.](http://docs.python.org/dev/py3k/library/re.html#module-re) Take note of the difference between `match()` (tells whether or not your regular expression matches the **entire** text) and `search()` (searches for a match anywhere in the text you're matching against) I know I'm copping out by pointing you towards the documentation, but using the documentation effectively is infinitely more useful as a skill than the knowledge of how to use any given capability. 3. [`dir()`](http://docs.python.org/dev/py3k/tutorial/modules.html#the-dir-function) 4. `print(file.read())` Note that you'll need to 'rewind' afterwards with `file.seek(0)` You can see what else you might want to do with `file` by `dir(file)` Basically, use `dir()` judiciously. Here is simple, stupid csv reader to get you going. There is a [csv module](http://docs.python.org/dev/py3k/library/csv.html) but I can't be asked to figure it out. for line in open("big_csv_file.csv"): for chunk in line.strip().split(','): print(chunk)
Download this: http://python-distribute.org/distribute_setup.py Run it with the desired python to install distribute for that python. May need to `sudo` it. Regardless of what the default easy_install points to, you can use `easy_install-3.2` (or `pip-3.2`) to install it with that python. 
How did you install distribute and easy_install? How did you install Python 3.2 (official python.org? homebrew?) In any case, you probably still called the system python instead of python-3.2 when installing things. This can happen for instance if you invoke scripts that contain #!/usr/bin/python as the first line (and hence, invoke the system python). Invoke the scripts with your python-3.2 instead. 
And even that has changed recently. It is no longer necessary to use local_import() to import application-specific modules -- now you can just use regular import statements. As you suggest, though, imported modules will not be reloaded automatically. However, you can do this: from gluon.custom_import import track_changes track_changes() That will reload any application modules, but only when they have changed (so it's faster than the old local_import with reload=True, which reloaded on every request, regardless of whether there were any changes).
It'd be nice if he mentioned why.
Here's what I do to get python working nicely on Mac OS X: 1. Make sure XCode is installed 2. Install [Homebrew](http://mxcl.github.com/homebrew/) 3. `brew install git &amp;&amp; brew update &amp;&amp; brew install python &amp;&amp; brew install python3` 4. Add `export PYTHONPATH="/usr/local/lib/python2.7/site-packages"` to your `.bashrc` or equivalent 4. Add `/usr/local/share/python` towards the start of your `PATH` and run `easy_install pip` 4. `pip install lxml` I'm going from memory, but this is what I remember doing a few weeks ago, and I can `import lxml` successfully with both `python` and `python3`.
If I remember correctly, the more non standard packages you had, the more tricky it got. So if your code is pretty vanilla, it's great. 
I found that imagemagick is subpar for resizing images smaller, especially with making thumbnails. The only acceptable python solution I have found is PIL using the Image.ANTIALIAS filter.
to put in a nutshell: import Image METHOD = Image.BILINEAR MAX_WIDTH = 1680 def resize_to_screen_width(file_path): """Resize a large image to screen width. Image ratio is kept.""" print "# resizing image...", img = Image.open(file_path) width, height = img.size ratio = float(width) / float(MAX_WIDTH) new_width = int(float(width) / ratio) new_height = int(float(height) / ratio) img = img.resize((new_width, new_height), METHOD) img.save(file_path) print "done." 
Lots of good answers, but I'll bite. 1 - How much memory have you got? if you're regularly working with multi-gig files and don't have 4 or 8GB, get more memory. Once you have 2-3 times the memory relative to the size of the file, just read the damn thing into memory. Sure, you could split it into chunks, work sequentially through the chunks etc, but - that stuff is hard (I do it regularly). just read the file, do your thing, finish up. fh = open(filename,'rt') contents = fh.read() fh.close() lines = contents.split('\n') these = [ x for x in lines if matches_my_re(x) ] job done. If you *really* must split it up, then just do the processing in passes. I'm assuming you can treat the data in each line in isolation to the rest - just cut the file into 10MB chunks then do the processing on each chunk, accumulating the results. If you need an example of how to do this simply, just reply. 2 - http://www.regular-expressions.info/ - great site for learning regular expressions. Please bear in mind this quote attributed to Jamie Zawinski, 'Some people, when confronted with a problem, think “I know, I'll use regular expressions.” Now they have two problems.' make sure (*damn sure*) that your data is regular. If it's not, don't try and parse it with regular expressions - instead, chop it up into bits that are regular. You don't give an example of your dataset here, so it's hard to make the call. 3 - you can print local and global variables at the python REPL: print locals() print globals() bear in mind, just about every large structure in python at runtime is either a list or a dictionary or a wrapper or some sort around a dictionary- this includes the members and methods of classes, the local variable set, etc. as an example, type thing = 'blarg' stuff = dir(thing) print stuff at the REPL. you now have a list of all the stuff in the thing instance. If you're not sure of the type of an instance, use print type(thing) to check. 4 - see top example, and then "print contents". GL! (edit for formatting) 
The author suggests trying redis for session storage, caching, and message bus backing. Sessions would be sort-of OK, if you had a lot of them and you were having contention problems. If this were the case, you probably would have evaluated redis already for this application. For caching, the author calls a purpose-built caching tool "old-fashioned" for unspecified reasons and suggests using redis though it necessarily has more overhead in order to provide features other than caching, and does not explain why redis would provide any additional value over memcached. And then the author suggests replacing a message bus with a key-value store. Square peg, meet round hole. Again, no reasoning is offered other than that the author was having implementation troubles with the particular message bus being used. Finally, the author takes a pot-shot at critics of key-value store overuse, and compares SQL to an increment command.
No, he said that PHP lets users copy and paste bad code, and this was a negative thing. I pointed out that *every* language lets you copy and paste bad code, and it's not fair to judge a language based on unpublished and amateur blog posts.
the link is only broken because you included the period at the end :) http://teddziuba.com/2009/09/twisted-vs-tornado-youre-both.html
Wonderful. Thank you. Your view on memory is pretty much my logic. I have 8gb RAM on quad core i7 machine. I'm not hungry for system resources. I read the 1.6gb file in, and linecached it, and still had plenty of RAM to play with. The important distinction that I was missing was read. I was making an assumption that the open call had an inbuilt read job associated. I can see that its a two phase job. Get the file. Interpret the file. Agree on the re, I do lots and lots and lots of testing to see what regularity is available. In the two case I am working on right now, one is xml, so the structure is implicit in the data, and the re masks can be built around deserialing the data, and the other is CSV, with regular, repeated maskable elements. Awesome, thanks again for your thoughts. I appreciate it. 
Great stuff, thank you. I am slowly getting me head around it. I spend a couple of days poking at the basic notion of python, and now I real feel ready to start attacking my actual problems! :) the re stuff is very useful, thanks. 
Of course there is.... and now I know to look for it! thank you. :) 
Avoiding migration by using a loosely defined schema is part of it. Another thing I really like about one of the newer NoSQL solutions, CouchDB, is that it comes with a restful API out of the box. A lot of stuff you would have had to write from scratch in your web server code, like authentication, replication of data between client and server, saving and retrieving resources is handled for you without writing any code. It's a database solution designed for web apps and mobile clients, rather than SQL which was designed before web apps became ultra popular like they are today. Another thing about SQL and a tool like Django is that you end up creating an antipattern where the ORM creates its own set of problems. Rather than trying to morph the interface of SQL to suit OOP programming, a document database like CouchDB takes a different approach and exposes an interface more similar to objects in Python.
Not at all :) The main part of an mvc application (not web), is that the view is listening models change. The second part is that the view can't modify a model by itself, it must call an other layer called the controller. In your case, the controller is listening the model, that's not is role. it is a controller. The view is the good listener. Why it is like that: Think of what you have to do to implement a new view. The second part is that the view must know the controller for asking changing the model. For exemple, this user story: turn the page. 1. The turn page button is clicked 2. The onclick call the controller 3. The controller verify it is not the last page ) 4. The controller ask the model to do a page turn 5. The model perform a page turn 6. The model notify listeners 7. The view reveive a page change event and redraw a newpage Hope it's help
Unfortunate that PHBs prevented the author from using PIL, which is the most sensible course of action. That being said, ImageMagick has python bindings (PythonMagick) which the author ought to have used.
https://github.com/facebook/hiphop-php
I disagree. "Dead simple" gets PHP's foot in the door. Easy for programmers to get started with. Fast turnaround for small small webapps. By the time the programmer needs a cms, they already are experienced in PHP, many small company webapps are already in PHP, and so they just go with a php-based cms like drupal. Before you know it, the boss is mandating that future development be done in PHP. 
Don't act so surprised. I've yet to meet a PHP hacker who consistently observes best practices. I'm sure they exist, I've just never met one. 
Some great tips, thank you. I have 8gb RAM and nothing else for the system to do, so I'm erring on the side of crunching data in a very hacky way.... :) I will look at the csv module - very clear steer from my questions in this direction. I'll look at Ipython, sounds like something that will help me out, cheers. Thanks for your time, I appreciate it. 
1) Yip. Thank you. 2) I guess its me shoehorming someone elses work into a set of tests. Its not been that fruitful. I will abandon the inherited code, and start over. It works in the usecase it was desgned for, but is not really that easy to tweak for me. 3) Ah, OK, thanks I will explore. :) 4) I think I was missing a step - the read process. I will be investigating that this morning Thanks for your your comments, very useful. 
Great, thanks! I'll start chucking some stuff around and see what I can get working! Appreciate your time, thanks. 
&gt; You can put a single .php file in a directory on nearly every hosting accounts out there and it works. You cannot say the same for Python. This is the main reason why. Yes. Though, I'd add that there's another force at work. Since php is so easy to get started with for webapps (deployment, but also being able to mix code with html), many new users go with it. The boss needs a quick webapp for something, you whip it up quickly in php, and everyone's happy. This goes on for a while, and before you know it you've got php all over the place doing various webby-tasks. When the need arises for a larger webapp, the programmer is most likely *not* going to switch to Python/Perl/Ruby. They're going to go with what they already know -- PHP. And that's how you get to where we are now. 
d'oh. fixed.
holy crap i had no idea the "-3.2" existed. I ended up deleting everything from when i built lxml with fink in /sw/, but after that easy_install-3.2 worked like a charm! :D thank you!!!
Very interesting. Thanks!
yeah i'm learning very quickly the -3.2 flag is very important. I have the official python 3.2 binary and .eggs. It was just a matter of specifying python 3.2 and not the default 2.7. thanks a ton!! 
how do you like homebrew? i've tried macports and fink and although they're convenient they create new directories (/opt/local/var or /sw/ with fink) to build everything and i have to mess around with PATH variables and blow everything up. /endrant. thanks for the help!! 
Not sure how well this has aged, but Text Processing in Python http://gnosis.cx/TPiP/ was a good reference for me.
I don't see how this relates to Python.
It is. This is the method we use with capistrano (handles the release directories and symlink).
Finder, Launchpad, Mail.App, Chrome, iCal, iTunes, Spotify, Terminal, iTerm, Transmit, Textmate, Xcode, Pages, keynote &amp; VMWare Fusion Along with this I have the following folders in my doc: Dropbox Downloads Applications
I've used the converter, it works well but isn't the same as python 3 simply running 2.x scripts which it really should have IMHO. They should've done all the tuning they wanted on the backend, the front end (scripts being run through python cli) was perfect.
I used to use MacPorts, but now only use Homebrew. By default it puts all its stuff in `/usr/local`, which is intended to hold this kind of thing. Fundamentally, their philosophy is different. MacPorts and Fink both seem to not "trust" the stuff that comes with the system, and instead build their own ecosystem. So when building stuff you'll find something depends on _curl_, so it'll fetch and build that, even though Mac OS X already comes with curl. (This is just a rough example.) Homebrew takes a different philosophy: use everything that comes with the system that we can, and only use Homebrew to supplement these. If Homebrew can just use a binary that comes with Mac OS X, it will. This has the advantage that you don't have to go building loads of stuff to get a few things you want, but comes with the disadvantage that sometimes you aren't satisfied with the version of a tool that comes with your Mac, yet it's not in Homebrew because it'd be redundant. For example, there's no _rsync_ in Homebrew, since it already comes on the Mac. (Though to be fair, there is [another repo](https://github.com/adamv/homebrew-alt) that contains these duplicates.)
from one of my projects: &gt; options = { 'py2exe':{'dll_excludes':['MSVCP90.dll'], 'unbuffered': True, 'compressed':2, 'optimize':2,'bundle_files':1}}, is the dll exclude the fix you're talking about? also don't forget the manifest the user just needs the runtime. edit: i switched to pyinstaller... it is better.
Do you actually use launchpad?
Why keep apps in the dock when you can launch them with spotlight?
I just wanted to get a feel for what other developers setups look like. I'm sorry if this is off topic for the subreddit.
Wow, thanks. Python packaging for Windows is difficult and doesn't seem to be improving much.
Works, but the license to that file is really murky.
It you probably could've gotten a better response had you qualified that. Otherwise, it justs looks like a generic "What software do you have on your computer?" post.
Sorry. I've edited my question to hopefully give it more context.
I've reversed my vote now, but this post is quite a ways in the hole. Hopefully things will turn around for you.
The only apps directly accessible in my dock are Finder and Chrome. Everything else is a folder with dozens of apps in them. They are, from left to right: * System - 28 apps * Programming - 15 apps * WordProcessing - 13 apps * GraphicsApps - 13 apps * MusicApps - 33 apps * ScientificApps - 6 apps * Trash So I basically have dozens of apps available but only 9 icons in my dock.
Not Pythons.
wxTNG was the project-name of wxWidgets 3.0.... at least it was a few years back, when I was still interested about wx. 
I am not using Redis for any of those things and doubt that it would be particularly effective for those purposes, but I am using Redis as the basic technology underlying a simple graph database that is helping my Flask app kick butt. Redis couldn't come close to handling most of the scenarios where a graph database gets used, but if you are tracking smallish graphs and/or dictionaries and such that don't change a lot, it can be wonderful. I'll open source the code sometime soon.
Only apps that are running. I really don't use the Dock...
I know several programmers who love Zend (i'm not a fan), and never modify its contents, they'll patch it by extending.. (btw, i didn't downvote you)
&gt; ugly SQL-queries with I used to do this as well take pot shots at tools/languages that I didn't _like/understand_. I've fast come to realize that you use the right tool for the right job. This technology zealotry is very annoying.
Ugly, terrible code. * All functions (except for logThis) take no arguments and rely on global state, making them untestable independently and hard to follow. * The program consists of simply calling the functions one after the other, using them just for segmenting the code. * Subsequently, sys.exit called anytime, anywhere and everywhere. * Sometimes vars are returned, though never used. * Functions in camelCase. Variables sometimes have underscores (extension_list), sometimes they don't (todaysdate). Upon closer look. * Unportable shebang. * Not using logging. logThis * Always prints the same time. Generally you don't want this and if you do, format it only once beforehand. * datetime.strftime returns a string, not need to wrap it with str. sendMail * Useless and invariable variables: emailto, fromaddr, COMMASPACE. checkParams * If there are not at least three arguments, sys.argv[3] will actually raise an IndexError. * Manipulating paths with (r)partition instead of functions from os.path. * Not using optparse or argparse. checkState * Funny. checkExists * subprocess.check_call takes a list as its first argument, here it will always raise a TypeError. * subprocess.check_call returns an (int) exit code, not a list. * In any case stringifying the "results" makes the following condition always evaluate as True. checkImageExtension * This str.rsplit should only split once using a second argument, so that "foo.bar.jpg" passes the test. makeTempDir * Doesn't delete the tmpdir created. makeSizes * str.find(haystack, needle) returns the 0-based position of needle in haystack, none of these conditions will ever be True. * This rsplit curiously splits four times, then only cares about the first part. * This time a correct use of subprocess.check_call. Alas, to no avail. Stringifying the "results" makes the following condition always True, again. * The condition would be wrong anyway since an exit code of zero means success. * Using readlines instead of iterating over the file object. * Parsing the "ini_file" is just wrong. * Creating a weird "sizes" dict instead of just storing a tuple of two lists. makePaths * No need to stringify "publish_image_path" as it's already a string. * os.mkdir doesn't return anything. * Running a command using os.popen. Failing to close the pipe. resizeImages * Using subprocess.check_call and stringifying the return value again. In conclusion, this person has absolutely no idea what they're doing. 
no
Every few months I check the [wxPython-dev mailing list](http://groups.google.com/group/wxPython-dev) to see it there is something new about Python 3 support and so on. [Today someone asked about it](http://groups.google.com/group/wxPython-dev/browse_thread/thread/ab12a017ad72254f) (was that you, OP?) and there seems to be at least two efforts in porting wxPython to Python 3. As far as I know, the long term plan is [Project Phoenix](http://wiki.wxpython.org/ProjectPhoenix/). 
And now you have 10 windows stacked on top of each other. And command-W won't work so you'll either have to kill your python session or close each window by aiming and clicking the red dot. And heaven forbid you try this: for case in test: mpl.figure() mpl.plot(case) mpl.show() # some command to wait for space bar here I don't really get why the community needs to be so defensive of software that's just not quite as good as the alternatives. I love python but I don't feel the need to pretend that matplotlib is as good as plotting in R or Mathematica.
1. There are ugly SQL queries. 2. It doesn't mean *every* SQL query is ugly I see that the your point of reading Reddit is to disagree with that's written, but now you're just imagining things to disagree with.
I install Python with the installer from www.python.org, that includes 3.2. However I want to comment on HomeBrew as it is the best source of open software for the Mac that I've experienced so far. As has already been noted they go out of the way to avoid redundant and massive installs. HomeBrew isn't perfect but I suspect that is due to limited uptake by the packagers. In any event if there is a program you want and it is maintained via a HomeBrew formula it is a good way to go to get that software. The biggest issue to date is that some packages are often without their GUI interfaces where that is possible. 
Good point.
Thanks for the recommendation! I think we'll use this from now on for our Pygame project. Question: When you say it generates OSX binaries, will I be able to generate them from a Windows box?
THUMBNAIL OF KITTENS? LEADS TO CODE ARTICLE? DISSAPOINT.
I don't have either of those problems. I'm not using Mac OS X, either, but rather Fedora 14. I can kill the windows with keystrokes (Alt+F4) and they're not stacked on top of on another. Those seem like problems with your window manager, not matplotlib, anyway. &gt;I don't really get why the community needs to be so defensive of software that's just not quite as good as the alternatives. I love python but I don't feel the need to pretend that matplotlib is as good as plotting in R or Mathematica. What was I getting defensive about? I merely showed you how to "generate multiple plots in a sensible way." I have no idea how good the plotting in R or Mathematica is. Feel free to use what you want. Regarding this: for case in test: mpl.figure() mpl.plot(case) mpl.show() # some command to wait for space bar here show() is a blocking call. You might use draw() instead or fork the process. More at [stackoverflow](http://stackoverflow.com/questions/458209/is-there-a-way-to-detach-matplotlib-plots-so-that-the-computation-can-continue)
Lets not forget that the author doesn't even properly call the close method of open file objects.
The tutorial on for loops you gave me just struck me as condescending and irrelevant to the point I was making (matplotlib's behavior when you dump a for loop's worth of plots is exactly what I was complaining about). I know how to make multiple plots, it just can't be done elegantly in matplotlib without unreasonable hassle, which was my whole point. I get that you were trying to be helpful though so sorry I took offense. Anyway if you think matplotlib is a passable plotting package you should play around with ggplot2 in R one of these days.
&gt; There are ugly SQL queries. Beauty is in the eye of the beholder. :-)
http://awesomescreenshot.com/0eajvao97 I admit it can seem beautiful in some sophisticated, oedipus complex + fat momma way (it's not mine, I've just found this screenshot my friend sent me a couple of weeks ago)
&gt;And then the author suggests replacing a message bus with a key-value store. Square peg, meet round hole. Redis IS a Pub/Sub message queue, as well as a key-value store: http://redis.io/topics/pubsub
It should be noted that Redis stores *all* your data *in RAM*. Yes, everything is kept in RAM. So if you're thinking of using it for anything large when your RAM is small, don't. Edit: It is configurable to have a specified amount of RAM available - most accessed data will be stored onto the RAM and rest onto HDD instead (cf blake82's correction post below)
Explain!
That query is generated. Using a key-value datastore all that logic would just be elsewhere. Not necessarily prettier. That SQL sure is a bit cumbersome to debug, but Redis querying with the same complexity might be as well.
yes, you're right, you can make interactions with Redis complex. you still can make SQL complex, too there are things SQL can't do in a simple, beautiful and straightforward ways. some examples are here: http://antirez.com/post/take-advantage-of-redis-adding-it-to-your-stack.html there are things Redis can't do in a simple, beautiful and straightforward ways. oh, it's a huge revelation, isn't it? you know, I think these arguments are stupid. I believe the world would be really better if everyone just assumed right away that there is no generic approach to *everything* which works beautifully every time, and that everyone knows and understand this fact How many stupid claims like "this guy is suggesting to try Redis, but Redis can't replace my parents (in a simple beautiful way)!!" should we be arguing about?
There is absolutely no need to compile redis yourself. This is not 1998. http://chris-lamb.co.uk/2011/07/27/official-redis-packages-debian-squeeze/
Not true, you can configure it to have access to a limited amount of RAM, and then put everything else on the disk. It will then keep the most often accessed data in RAM.
Thanks for this answer. I felt like a retard the day I wanted to code my first python web-app.
&gt; I believe the problem is that most of the maintainers of these libraries simply do not see any benefit to spending any time creating a Python 3 version of their library. They do not believe that there is enough demand to warrant the effort. Um, no, not as simple as this. Many packages that I need are still Python 2 only - I am not going to change until that is done, and when enough early adopters have succeeded in using Python 3 then I will have a case to switch over. Only when the cost of not switching is greater than switching will I then be able to switch for projects that I've already started.
This. We need Python 3 pushed, and get rid of Python 2.
Blogspam. The content is really at http://python3wos.appspot.com/
People will start supporting and using Python 3 if they see an actual improvement from Python 2. Other than some (stupid) syntax changes, there is no big difference. If Python 3 has JIT Hotspot compiler I myself will port any 2 module to 3 that I need, without waiting for the author. 
Another option is simply to port the libraries yourself. Good python code can be mostly ported using the 2to3 tool and you'll be doing the world a great service by finishing the job.
The WoS would be much more useful if it could show the dependencies of these projects and whether their 3 or 2.. if something has dependencies that are all ported (or none), then that makes porting a lot simpler.
Unless you're paying money, you aren't a consumer. If you are a community member, you need to help. If you are neither a consumer nor a community member, you'll need to wait.
cmd+[space] Spotlight FTW!
The advantage of Python 3 comes primarily for new users, who won't have to learn a number of little quirks that Python 2 accumulated over the years, like the difference between old style and new style classes. It also comes for everyone who ever has to deal with non-ascii characters, because it deals with unicode in a much more sane way.
That's never going to happen..
I'm a community member, and I'm porting my shit. I'm moving to Python 3 as soon as it becomes the default in Debian stable.
Perhaps once more of the Linux distros make Python 3 default in their distros, more people will come along, such as yourself.
PyAudio. I attempted to write a noise cancellation program a few days ago since they keep playing Adele at work and it drove me up the wall. PyAudio plays very very nicely with ALSA. With a bit of hacking around you can get that too (like having two streams, one showing left channel, and the other showing the right channel)
A minor caveat though is if you're using 2.7+ you'll need to install pywin32. Not a big deal, and still easier to configure than py2exe.
At what point are you trying to snag the audio stream? You'll find that many distro's aren't really using ALSA anymore, but have moved to OSS. There are some bindings for talking to oss via ossaudiodev, but I'm not sure if they're exactly waht you're looking at doing... http://docs.python.org/library/ossaudiodev.html 
1. It's not quite as bleeding edge (or volatile) as Ruby. 2. It's not Java/C#/C++, Scheme/Clojure/Haskell, Prolog/Erlang or any other language that isn't Python. 3. It's not sensible for performance-critical programs (e.g. nanosecond reactions). 4. It may not match your aesthetics or taste. 5. It may not be accepted at your workplace or in your industry. That's all there is to it, really. Most of the reasons given in the SO answers are bollocks. Especially the stuff about packaging (hello virtualenv/buildout) and IDEs (PyCharm is a branch of IntelliJ, which is amongst the best IDEs available for Java; there's also Komodo IDE, WingIDE, PyDev (for Eclipse!) and some others) is pretty dumb. EDIT: As for `re` and `string.join`: RTFM. As for idioms and dynamic typing: if you find that these make you write worse code, you are probably not meant to be a Python programmer (you may be thinking in some other language still). Also, good IDEs can help with some of that.
Do you still need this?
It's not that big of a deal for me. Also, the patches are not going to write themselves. I welcome though, however.
Are there still packages left which could be ported relatively easily? As far as I understand it (which, granted, is not very far), some of the most "influential" packages aren't trivial to port (e.g. because they rely on non-Python modules) and that's what holds people back. As long as those "influential" packages don't make the switch, porting those dependent on them seems like a wasted effort.
Great looking site. Nice job!
&gt; Your browser does not support WebSockets. I'm using ff 5.0, this is the most up to date version of ff on Ubuntu 11.04, which is the latest version of Ubuntu available. 
Clicked a rageface, hit Enter. error 405: method not allowed.
Odd, I'm pretty sure FF 5 should support it, maybe it's an error in the code's browser detection?
That probably means javascript is not allowed to run on the page. Are you using a plugin that blocks javascript?
I've only tested on Chrome 13, Firefox 6, Safari 5 and Opera 11. I'm going to make it fall back to ajax long polling when websockets aren't available in a future version.
Looks pretty good so far! Design question: Why did you use Redis instead of a message queue?
Ok. PM me if you want me to test it then.
Best part: the names you gave to each face. _Seriously: commenting from work to look at source this weekend 
Did someone just post a library to /programming or /JavaScript to the client side fall back?
Redis is (among other things) a message queue.
FWIW, it's more of an issue for libraries than for applications. You shouldn't create a module called `math` and put it on PyPI. You _can_ create a module called `math` for a local application, though. However, when the module really is application-specific (or part of a bigger library), you should probably put it inside a more general module to create your own namespace. This is just common sense. You may find "utils" descriptive in your own project, but releasing a module with that name on PyPI will confuse the hell out of people.
Yes, the blazing fast speed is lost though. You're right, I should edit my post not to confuse people. Thanks :)
Aha, so I see. I'm reading up on it right now (well, playing with the tutorial anyway :)
Great work. I work on a site with a very similar stack ( gevent instead of Tornado ). Some comments: * re.compile [these regex](https://github.com/ragechats/ragechats/blob/master/ragechats.py#L54) you call them enough that you'll see a performance increase if you precompile them. * [TornadIO](https://github.com/MrJoes/tornadio) can abstract a bunch of transport methods (long polling, vanilla xhr, ... ) into one API instead of just relying on websockets ( which have iffy support among browsers ). * Wrap your io loops in wildcard except statements. Normally this is bad practice but the alternative of having your code fall out of the loop if json.loads or something fails is less desirable. * Use [msgpack](http://msgpack.org/) for data you put on the wire, it will be much faster to serialize/deserialize and is smaller in size than JSON. Also consider ZeroMQ's PUB/SUB sockets for performance. [I wrote a very similar chat application](https://github.com/sdiehl/zeromq-chat) a while back and zmq drastically outperformed redis.
The publish/subscribe features in Redis are super easy to use. I've looked at ZeroMQ and RabbitMQ before and they boggle my mind.
&gt; You shouldn't create a module called math and put it on PyPI. You would be amazed to see how many people do that though. Not necessarily with math but 'json', 'xml' are not uncommon.
&gt; i' m on os x 10.7 and have changed my .bash_profile, so terminal defaults to 3.2 instead of 2.7. Yeah. Don't do that, horrible idea.
Design question: Why did you use Redis instead of just a few lines of code in Tornado for passing messages ?
WebSockets are just a draft specification still. There are many draft versions and Firefox 5 probably used an older one that Tornado does not support.
I know 10x more about python than R and like python 100x more than R; however, I still find myself using R. The net of superior tool and inferior user is still favorable for me when doing interactive exploratory plotting. I wish matplotlib could spend some time learning from the competition. 
Wow TornadIO looks amazing. I will definitely use that instead of trying to write my own long polling code. I considered zmq but it looked much more difficult to use that Redis, and I was already using Redis to store other information. I'll have to take another look at it though. Thanks!
Good question. That's exactly how I originally designed it. But then I wanted more than one python process, on more than one server. So I had to incorporate Redis.
You can thank the reddit community in /r/fffffffuuuuuuuuuuuu for the names.
For what you're doing zmq isn't really much more difficult than redis. [Read this tutorial](http://nichol.as/zeromq-an-introduction) and I think you can probably get zmq pubsub up and running in about 10 minutes.
Very nice, but I tried to tell a story and realized it didn't have the required girl faces. EDIT: I think it would be better to have a vertical split instead of the horizontal. With 3 or 4 faces in a row. But it's very simple and effective, so I like it.
In the future I'd like to add a more complete collection of rage faces and also a better way to organize them along the bottom (tabs with sad, happy, rage, etc).
FireFox disabled support for WebSockets in 5 due to a security error in the draft specification. Once that error was fixed, they re-enabled them in FireFox 6. You can enale them in 5.x in about:config.
The list doesn't really seem up to date. BeautifulSoup and Jinja for example are marked red, but run on python3. 
Not the best answer but check out the gspot codec tool. It might have an API or command line interface you could exploit. 
Read the disclaimer on the bottom of the page: "If a module is red though it supports python 3 it's because they don't have the "Programming Language :: Python :: 3" tag. Consider contacting the maintainer to fix this. " 
At least it's not [yet another nester](http://pypi.python.org/pypi?%3Aaction=search&amp;term=nester&amp;submit=search).
I think it's irrelevant. Compiling and installing Python 3 from source is trivial and waiting for some arbitrary thing like a distro packaging it is just procrastination.
Out of curiousity, have you done any load tests? We looked at this kind of stack a couple of years ago and IIRC back then you had to compile your kernel with a certain option to fully benefit from and use the non-blocking IO. I really like to know if this has improved. Altough I assume that with the likes of Tornado and node.js, it almost certainly has.
This is actually not using any of the async/non-blocking features of Tornado. Each python process (currently 6 running across 2 linode slices) has it's own thread that's just listening for messages from Redis. I've done some basic load testing with ab and httperf and the bottleneck right now is surprisingly haproxy (or perhaps linux). Once you get around 40,000 open websocket connections it just stops responding to anything. I haven't really spent the time to look at error logs to figure out why.
Well, I don't have a big draw to going to Python 3 until macs do - part of the reason I'm learning / working with Python is it's cross-platform-ness.
Some feature request: Tab-Complete the participants' usernames. Notify when there is activity in a room. Notify when my name is mentioned. Other than that: Amazing work!
Invent Your Own Computer Games with Python http://inventwithpython.com
Yep, if you can get the code and like the license then stop complaining and start coding. I remember seeing the Google IO 2011 video about Python. In that both Guido and Wesley Chun agree that it is reasonable to expect Python3 adoption to take about 10 years. Pretty reasonable in my opinion considering the massive amount of Python 2.x code that is out there and running well in production.
The sideways scrolling is not ideal from a usability perspective, most monitors are wide screen, why not put them to one side?
Maybe Tornado,although you get a web server with it also... http://www.tornadoweb.org/
Shame is not a good motivator. What about a low hanging fruit tree. So we can target the dependencies which will have the most impact. Don't complain unless you're prepared to do something about it. Maybe I should take my own advice and come up with a site... the dependency tree should be easy to build from pypi.
Looks promising, thanks.
TNSTAAFL
Flask (or Bottle, or CherryPy) Very lightweight; can use whatever protocol you like or standalone.
Try Cherrypy. It's documentation isn't always the best, but it's fun once you get the hang of it, and then it begins to make sense.
http://flask.pocoo.org/ Sounds like exactly what you are looking for.
There are many lightweight frameworks, check out http://wiki.python.org/moin/WebFrameworks#Basic_Frameworks . I prefer Flask, but that is up to you.
[Pyramid](https://docs.pylonsproject.org/docs/pyramid.html) for my choice for web service stuff.
Rageface story! Copy-paste it in the chat, relive the story which isn't actually that true. &gt; /hmmm /fuckthatbitch /fapfap /reallydetermined /busted /pissed /what /creepymegusta /sweetjesus /excitedtears /excited /dad /pokerface /badpokerface /sonmegusta /thefuck /trolldad /shaking /gtfo /truestory 
Ty. Will check flask and CherryPy out.
Best thing I know of is [MediaInfo](http://mediainfo.sourceforge.net/en).
I am trying to use [Quicksilver](http://qsapp.com/) more, but my dock contains the following: Finder, Activity Monitor, Firefox, Chrome, Safari, Camino, X11, Mail, KeepassX, Pages, Scrivener, Quicksilver, and Temperature Monitor I spend the majority of my time using xterm, not Terminal.app
Tornado supports the newest draft spec of websockets in the git repo if I'm not mistaken. 
Nope. I'm using FF6, if it helps.
+1 for CherryPy fast &amp; fun way to do python dev for the web (contrast with doing web dev in python)
The change in CPython: https://github.com/albertz/CPython/commit/2670e621458fd80311fc02897b698ea2a36d494b
The list is a bit disingenuous as easy half of it is an individual red mark for minor zope/plone modules. There are other web frameworks that work fine in Python3 making the lack of something from Python 1.x days not such a big deal.
 set(arg or []), set(someFunc() or []) or def liberal_set(x): if isinstance(x, (set, list, tuple, basestring)): return set(x) return set() or you could just validate your input... 
 [] if (not x) else list(x)
IMO, set(arg or []) is compact, pythonic and readable. But maybe that's just me.
If you get to the point where you're going to use `ffprobe`, consider using `midentify` instead. Easier to parse.
was there any discussion of that on python-dev?
 def liberal_set(x): try: iterable = iter(x) except TypeError: iterable = () return set(iterable)
Python has extremely strong ties to the iterator pattern. None is not iterable. Consider returning an empty collection of whatever (presumably a list) instead of None in someFunc and whatever method provides the value assigned to `arg` Failing that, use what semarj suggested: set(arg or []).
I just sent a mail. However, I think it takes a bit until the mail gets approved (I was not yet subscribed to that list). Edit: http://thread.gmane.org/gmane.comp.python.devel/126754
It went through ;) Let's see where it goes.
Well, the answer is kind of expected. But even without direct support in cpython, you still can get the source code of, lets say, decorated function via inspect module, and get an ast tree by ast.parse. And then do all the crazy things ;)
I'm validating at the moment, but your first example is pretty much exactly what I meant. Thanks!
Will do. Thank you.
Why not make None iterable? It could simply produce the end-of-input signal when you attempt to iterate it.
In realtime?
I'd try OpenCV rather than matplotlib.
Sounds cool, but I don't know what this entails.
This is kind of like asking 'Are there any good reasons why I should not use a screwdriver?' Well, what are you trying to do? If you're baking lasagna, then yes, there are plenty of reasons why you should not use a screwdriver. 
Ok it works, I had to turn network.sebsocket.override-security-block to true.
It's more a suggestion to change the base libraries, rather than to make a change from the average Python programmer's end. Thinking about it, though, led me to ask myself: why not make everything iterable? Regular stuff could simply act like a single-element list, while things like `None` could act like an empty list. But upon further reflection, I think this is probably a bad choice; it will lead to not producing error messages where you might want them, because most of the time you will not be trying to iterate over a non-iterable on purpose.
you saw it coming, didn't you? vim, NERDTree, grep, good old command line :)
you saw it coming, didn't you? vim, NERDTree, grep, good old command line :)
I don't think buffering=1 does what you think it does..
+1 to that...I am learning CherryPy as well. 
&gt; that stuff is hard (I do it regularly). just read the file, do your thing, finish up. fh = open(filename,'rt') contents = fh.read() fh.close() lines = contents.split('\n') these = [ x for x in lines if matches_my_re(x) ] That's just plain wrong. Reading the file iteratively is not hard... The following does the same thing without requiring gigabytes of memory with open(filename,'rt') as fh: these = ( x for x in fh if matches_my_re(x) ) if you are working line by line there are not many reasons you wouldn't do it like this.
don't call isinstance ever, please. :(
because we already have a thing for that: ()
Do you know the color? Find the pixels with that color and average their coordinates. 
Here's an idea that's easy to implement: Instead of a "wall of shame", since -- as you point out -- shame is not a good motivator... Instead of that wall, put up a wall of "reasons why Python 3 is better than Python 2". Just a simple site with a list of bullet points. Extra credit: have it so you can click on each bullet point and some javascript would unfold it to show a more detailed example illustrating the point. To get started, you could ask on /r/python for reasons why Py3 is better than Py2 (after searching first, of course). 
 iter(x) if x else []
care to expound?
Need the /actually guy
No, it is just a recording. However, if I find a fast enough method, I may consider it.
Just black and white for now. I will have to play with coordinates though, esoecially since I need a scale.
Whoa, sounds pretty cool, really need to sit down and learn it. I did find another tool though in the meanwhile which is pointy clicky(good for a noob like me) called imagej. 
Sure. I'd like to see it. What are you using for the gui?
"Ever" is an exaggeration, but he wants you to duck type.
I do, but not from the dock.
Kragen explains it pretty well: every time you call "isinstance" you make your code less flexible. http://www.canonical.org/~kragen/isinstance/
Wait what. runserver in production?
Nice fun project. The keyboard feels very natural and the UX is smooth. E.g. when I click a face, I don't have to then click back on the input field. This may seem obvious, but you'd be surprised how many sites ignore simple stuff like this and make for painful interactions.
I saw you mentioned that RabbitMQ "boggled your mind". Was Redis really that much simpler to work with as a message queue (which doesn't seem like it's primary purpose), or is it more that you've worked with Redis before, so it was easier to adapt to this?
It's not plain wrong - it works just fine, and (to the actual point) it's obvious and easy to understand for the OP. Your code also works just fine, and assuming things should be split by line, works just as well as my example - however, the OP didn't state how the original file was laid out, so switching to some other method of splitting up contents is trivial with mine - not so much with yours. Listen, I'm not going to argue this with you, you're perfectly entitled to your opinion and your code is also a great example for the OP. My opinion is that memory is there to waste (right up to the point you fill it). I've spent far too much of my professional life agonising about how to manipulate bitfields in unions and defragmenting asynchronous streaming systems to worry about this sort of thing in practical cases where you really can just throw the system capabilities at it.
i think it's more of a proof-of-concept. 
PiCloud dev here. We actually do support doing DELETE https://api.picloud.com/job/?jids=12, though that isn't the official recommend way. While our methods certainly accomplish RPC over HTTP, I disagree that the API is not RESTful. We did a lot of research in making our API pretty standard, which isn't easy to do as there is no official standard for what is REST. Looking at the REST [wikipedia article](http://en.wikipedia.org/wiki/Representational_state_transfer), our API satisfies the requirements. It fundamentally involves transferring resources (job identifiers) between the client and server. All the 6 constraints (esp. the statelessness of requests) are obeyed and the API obeys the listed guided principles. Even though we aren't entirely obeying example given in the web services section, we are obeying and defining the four aspects described. For instance, our GET methods are all safe and the POST functions are not and we communicate with JSON (or raw octet/streams). For the example you cite, we don't recommend the DELETE HTTP method as it feels very inconsistent with our kill command. Kill is also idempotent, but there is unfortunately no KILL HTTP command, which forced us to use its own URL. As kill is pretty close to delete, we opted to keep those methods consistent. We considered semantics like 'https://api.picloud.com/jobs/12', but those were very limiting due to the lack of ability to manipulate or request multiple resources in batch. The ?jids= notation is just as RESTful regardless. Finally, the interface to publish a function should be thought of extending our REST API. cloud.rest.publish(square, "square_func") causes a job id creation end-point to exist, namely: https://api.picloud.com/r/unique_user_id/square_func
Blog link describing feature: http://blog.picloud.com/
I agree with your description about REST. We do not consider the actual act of publishing a function 'RESTful'. However, once that function is added to our API, it is used to create jobs in a RESTful way. POSTing to it creates a resource (a job), and a URI to that resource is returned. That resource can then be queried as it changes state on the server with GET. That said, admittedly, we are dealing with a concept where there is no standard. So it is very easy to get into discussions on what is and is not RESTful.
And it's py3k compatible!
I agree, but procrastination is rampant.
Well still trying to figure out my options. While I am still quite enamored with Pycharm I really don't like the price. I have tried several options none of which are really cutting it for me. I tried to follow some tutorials on setting up Vim as a Python IDE, but blast it if I can't get past the UI. Vim is like the Dwarf fortress of text editors if you know what I mean.
Ah :P That wasn't me. Been busy with coursework and a couple websites.
Very cool! How about something like [this](http://i.imgur.com/nKc2e.png). So when you type "/rageface" or click a face it will be replaced with a box that can be deleted with a button. Also, when you backspace through the box, it'll delete the whole thing, rather than backspacing individual letters. Also, if you type "/notarageface" for something that isn't an accepted rage face, it'll add an extra "/" before it. Other than that, good work!
Is it just me, or is there no download link in that post at all? &amp;#3232;\_&amp;#3232; 
We tried CherryPy and it worked well for the simple parts. However when we tried to SSL it all came crumbling down :/ The documetation for SSL support is rather poor. I have all the preqs installed (pyopenssl, openssl, certificates, etc.) and still craps out and the google/stackoverflow info we found hasn't really helped us all that much. 
wxPython with wxFormBuilder
It would be nice to have more details on how the authentication is made, but you can use [httplib2](https://code.google.com/p/httplib2/) to do this. The authentication example on [this page](https://code.google.com/p/httplib2/wiki/Examples) shows how to do it if the authentication is basic authentication. If you scroll down, you will see an example with a form.
Thanks, I'll try it later, but what's this?: HTTPS support is only available if the socket module was compiled with SSL support. By the way, the website is a https url, and the form with a name username and a password field named password is sent to another https url, I just want to send this information and get the server response, right now I only get 400 Bad Request, using this code: http://docs.python.org/library/httplib.html (Last One)
I get this: httplib2.SSLHandshakeError: [Errno 1] _ssl.c:499: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed How do I send it even if the certificate is not valid?
Blog links to http://python3wos.appspot.com/ Better version is http://py3ksupport.appspot.com/
I wonder if the [new PostgreSQL 9.1 unlogged tables](http://wiki.postgresql.org/wiki/What%27s_new_in_PostgreSQL_9.1#Unlogged_Tables) are a better alternative for storing session data, assuming you need to run a postgres server anyways. If the performance is comparable, it seems like it would avoid the additional resources required to also have Redis running.
You can use the disable_ssl_certificate_validation=True argument in the Http object creation. See https://httplib2.googlecode.com/hg/doc/html/libhttplib2.html#httplib2.Http
&gt; What is Python? it's an relatively new You kid, right? Python is even older than Java.
I stand corrected, I never new it was so old.
There isn't. But it is available on PyPi http://pypi.python.org/pypi/PyOpenGL/3.0.2a1 
Web.py It was used to originally make Reddit and it's a very capable microframework.
Anyone have a sftp/scp module that they can recommend? Something like [pysftp](http://pypi.python.org/pypi/pysftp/)?
Nice job. Thank you for sharing.
Does it handle level2? For example, if a user uses Google Checkout than transfers the transaction on the Google side, does it handles the notification from google like gchecky does?
I strongly recommend bottle.py on the [rocket web server](https://launchpad.net/rocket) which supports ssl very well and it really fast and readable.
&gt; I strongly recommend bottle.py on the rocket web server which supports ssl very well and it really fast and readable. Nice. Will def check that out as well.
download is on pypi http://pypi.python.org/pypi/PyOpenGL/3.0.2a1
A double-ended queue (`collections.deque`) might be more efficient but if it's not a performance bottleneck then it's probably more trouble than it's worth and I would just use a list like you (presumably) are. I don't really know much about statistics or understand what you're doing, but the code seems reasonably pythonic to me.
I work as a programmer. Do you have a point, or are you just trying to offend?
Yup, no point, just trying to offend. Glad we cleared that up.
 start_value = input("Start value:") end_value = input("End value:") increment_by = input("Increment by:") for i in range(start_value, end_value, increment_by): print i
Does the OP care if the program is dealing with strings or integers? E.g. does it matter if the TA or prof. inputs "1,110" instead of "1110"?
Ahhh I see. . Idk what I was doing wrong but my list would not include the first number from the users input startVal = input("Enter a starting value ") endVal = input("Enter the ending value ") increment = input("Enter an increment ") for count in xrange(startVal, endVal, increment): print count + 1, 
The example code you've given is missing some things. E.g., accuracies.append(m.validate(validation_set)) If m is not `model` then ignore the rest. I'd have written your main loop like this. from itertools import combinations, islice for val_index, training_indices in enumerate(islice(combinations(range(len(chunks)-1, -1, -1), len(chunks) - 1), folds)): # assumes chunks supports __getitem__ validation_set = chunks[val_index] # assumes modeler(Data.marge([1,2,3,4])) == modeler(Data.merge([4,3,2,1])). If they're not equivalent, reverse `training_indices` training_set = Data.merge(chunks[i] for i in training_indices) accuracies.append(modeler(training_set).validate(validation_set)) Just kidding. Use a deque with popleft(). Although if the assumptions stated are actually true the above code should work and could probably be executed in parallel easier, since no state is being mutated except for `accuracies` But seriously, use the deque
Right now we're dealing with just ints ;) Str() comes next week :/
is that m.validate supposed to be model.validate? And does that function alter the contents of validation_set? It looks like you need a circular buffer. I can't find anything that will help your exact case but maybe using a nice generic function generator might help make things a little bit cleaner. def circ_get(chunks, folds): for _ in xrange(folds): first = chunks.pop(0) #popleft if you go with deques yield first, chunks chunks.append(first) def xvalidation(data, modeler = None, folds = 10): if modeler is None: modeler = lambda d: id3(d, 'entropy') chunks = data.chunk(folds) accuracies = [] for validation_set, rest in circ_get(chunks, folds): model = modeler(Data.merge(rest)) accuracies.append(model.validate(validation_set)) return avg(accuracies) then you can use list comprehension* on the last few lines: def xvalidation(data, modeler = None, folds = 10): if modeler is None: modeler = lambda d: id3(d, 'entropy') return avg([ modeler(Data.merge(rest)).validate(validation_set) for validation_set, rest in circ_get(data.chunk(folds), folds) ]) the circ_get algorithm that you're trying to do seems like it's trying to pair each element in a list with the rest of the elements in the list. I don't even know how to describe doing that. None of this code has been tested. EDIT: just realized list comprehension might be needed instead of generator expressions, depending on how avg is implemented. 
pyobjc?
Try to formulate your question more specifically. What is the result you have? What have you tried to get to the result you want? What are the problems you encountered in reaching this goal? General notes: * input is unsafe. e.g.: &gt;&gt;&gt; startVal = input("Enter a starting value ") Enter a starting value __import__("evil") &lt;-- evil code now running --&gt; * You have as input: start, increment, number of values * You have to give xrange: start, increment, stop Think about how you can get from one representation to the other.
Recursion ...
Not really.
 range(startVal, startVal+desiredOutputs*increment, increment) or def it(start, step, inc): i = 0 while (i &lt; step): yield start + i * inc i += 1 for i in it(2, 3, 5): print i 
Your print statement should just be "print count,", not "print count + 1,". The first time that print is executed, the variable "count" will have a value equal to startVal. If you print count+1, it's going to output a number one higher than startVal... making it look like it's missing the first number from the user input. The "for count in xrange(startVal, endVal, increment)" construct will cause the variable "count" to take on the values startVal, startVal+increment, startVal+increment+increment, and so on in order until the value equals or exceeds endVal. Hope that helps!
I am sure I read that OP wanted to do this without loops and recursions would be a way to do that. But I no longer see the no loop part. You could probably do it with list comprehension as well, but if this is for a class then recursion is probably what the are looking for. Then again I mint just be crazy.
Cool hack. There should be more experimentation with Python like this.
This might help you get started using the appscript module. from appscript import * addbook = app('Address Book') newperson = addbook.make(new=k.person, with_properties={k.first_name:'foo', k.last_name:'bar'}) newperson.phones.end.make(new=k.phone, with_properties={k.label:'work', k.value:'555.555.5555'}) addbook.save() Any additional contact properties can be found by looking at the "person" entry in the Address Book's dictionary in the AppleScript editor (under the file menu). The only difference is that you should put underscores in the place of spaces and prefix property keys with k. Edit: Add example to add a phone number to a person.
I think you could work directly with the sqlite file as described here: http://krypted.com/mac-os-x/querying-address-bookapp-from-the-command-line/ 
There are three ways of doing this: 1. Running a browser-based unti tester (see: Selenium) 2. Posting to the authentication page directly (if they're smart, this won't be possible) 3. Using a mechanize client. I've never messed with one in python before, but in perl WWW::Mechanize is awesome for this.. and it seems to have a python port/ripoff: http://wwwsearch.sourceforge.net/mechanize/
&gt; is that m.validate supposed to be model.validate Yes &gt; does that function alter the contents of validation_set No
Starting with Python3 input is the same as raw_input. OP didn't specify which version he is using though.
input() will return a string so you'll need to cast that to a int, like so: startVal = int(input("Enter a starting value")) The catch here is that if you enter a letter like "a", the call to int() will throw an exception. 
 def it(start, outputs, inc): for _ in range(outputs): yield start start += inc makes slightly more sense.
It's important to note that when using 'for i in range' the start value is included in the range and the end value is not. For example: end = 5 for i in range(1, end): print i This will print numbers 1, 2, 3, and 4. The way I normally handle this when I want the end to be inclusive is by adding a '+1' to the second argument of range: end = 5 for i in range(1, end + 1): print i This now prints 1, 2, 3, 4, and 5.
&gt;- Don't use spaces around the '=' sign when used to indicate a &gt; keyword argument or a default parameter value. &gt; &gt;Yes: &gt; def complex(real, imag=0.0): &gt; return magic(r=real, i=imag) &gt; &gt;No: &gt; def complex(real, imag = 0.0): &gt; return magic(r = real, i = imag) http://www.python.org/dev/peps/pep-0008/
Oh, if you didn't check the mailing list, [there is progress on the Phoenix front!](http://groups.google.com/group/wxPython-dev/browse_thread/thread/ab12a017ad72254f#msg_49d71847e84d267f) &gt; I know this just sounds like the same old tune that I've been singing before, but the good news is that Phoenix is moving forward again. There has been a lot of progress in the last few weeks, (http://trac.wxwidgets.org/log/wxPython/Phoenix/trunk) and the future is looking shiny (smaller, faster, \*and\* stronger.) 
This only works for reading. The sqlite db is basically the "cached" form of the contacts for quick load. The real contact information is in the Metadata/ folder located in the same place. If you delete the sqlite db, AddressBook will happily recompile it. The same does not apply to the Metadata folder and its contents. If you'll notice, the article doesn't provide any data insertion examples.
Reddit is not your homework army.
Reddit is not your homework army.
Using httplib2 I'm doing the second thing and all I'm getting is the same result no matter the username and password are right or not, I think they're smart... :/ I think I'll have to try #1 or #3, but I remember there was a C brute-force password cracker terminal-based application where you'd enter the login address, username and password and the program returned 200 if it was right and 202 if it was wrong. I had used it in this website before when I had forgotten my own password :P!, do you know any application like this (best if it was in Python, but it doesn't matter...)?
Hasn't been updated in years and does not seem to work with Lion/Xcode 4.
Have you read the [Address Book Programming Guide for Mac OS X](http://developer.apple.com/library/mac/#documentation/userexperience/Conceptual/AddressBook/AddressBook.html#//apple_ref/doc/uid/10000117i)? I found it quite lacking when I was trying to do some CardDAV stuff, but the [class reference](http://developer.apple.com/library/mac/#documentation/userexperience/Reference/AddressBook/Classes/ABAddressBook_Class/Reference/Reference.html#//apple_ref/occ/instm/ABAddressBook/people) has some promising looking stuff. [This MacTech article](http://www.mactech.com/articles/mactech/Vol.25/25.08/2508MacintheShell/index.html) has a worked example.
So you're trying to humiliate me now, by being bad analogy man? you'll have to do better than that. If you want to educate, feel free to, you know, actually make a point, address the OP's questions, whatever.
try http://docs.python-requests.org/en/latest/index.html
yupp
AFAIK, the Python way of doing things is to "not" use getters/setters which were made famous by Java for the purpose of "abstraction". If you ever feel a need to encapsulate your setting / retrieving logic, you can make a few changes to your class and `x.something = 1` would then call your custom setter method as opppossed to setting your field directly. [Link for your reference](http://eli.thegreenplace.net/2009/02/06/getters-and-setters-in-python/)
What you want to do is use [properties](http://docs.python.org/library/functions.html#property) class Thing: def __init__(self, whatever): self._whatever = whatever @property def whatever(self): return self._whatever if you want to be able to set the attribute @whatever.setter def whatever(self, new_whatever) self._whatever = new_whatever Same goes for deleter
It is rest-ish but not restful. Restful interfaces /must/ be hypermedia driven. As a quick rule of thumb - if you only need one end point and the rest of the api is explorable through links, it's restful. If you have multiple endpoints and users must construct urls, it's not restful. It's not about the operations you expose (POST vs DELETE), but how you expose them - and your delete operation requires constructing a url. A genuine restful interface would expose a link/form to the delete operation from within the job resource If you explore things beyond wikipedia and look to the sources, you can find this hammered out. A better explanation than wikipedia is the richardson maturity model: http://martinfowler.com/articles/richardsonMaturityModel.html You have one and two, but for three instead of using hypermedia controls you are using identifiers passed around in parameters that the client must know how to construct in advance. 
Thanks, those newperson examples are exactly what I've been searching for! May I ask how you get from all the Class descriptions to newperson.phones.end.make() and how you determine the new= and with_properties=? While attempting to use the AddressBook module, I had searched through the Programming Guide (not knowing ObjC or any Apple programming in the past), and got stuck trying to create an ABPerson object. ABPerson seems to have an addPropertiesAndTypes method but I couldn't find an example for what to use in parameters. I might just jump ship and use appscript with your examples instead.
Right, my very shallow understanding is that the Python-ObjC glue code is now included by Apple (since 10.5). You're automatically using it when you use the AddressBook module. Please correct that if I'm wrong!
To follow up, the beauty of properties is you can start with this: class Thing(object): def __ini__(self, whatever): self.whatever = whatever x = Thing("foo") x.whatever Then when if your set logic becomes complicated, you can do this: class Thing(object): def __ini__(self, whatever): self._whatever = whatever @property def whatever(self): return self._whatever @whatever.setter def whatever(self, new_whatever): self._whatever = new_whatever.strip() x = Thing("foo") print x.whatever x.whatever = " bar " print x.whatever #prints bar The idea is that in the common case, you don't need special logic for your getters and setters, so you don't use them. We are all adults and agree to behave in terms of the publicly accessible fields. But, when a getter or setter requires more logic, like normalizing or validating in a setter, you can switch to a property like I just showed (stolen from PCBEEF above). The beauty of this is if you have lots of "x.whatever" code littered throughout your code, you don't have to change them to "x.getWhatever" and "x.setWhatever()".
Thanks, yes I had found that article in my searching, but it's a read only example. I found another article (I think also from MacTech) which explained how to convert from ObjC specifications into Python parameter passing, but I still need a table of what specific parameters and keywords to use for AddressBook in particular.
Sorry, can't say either way. I would wager that you are wrong, unfortunately, since [this article](http://developer.apple.com/cocoa/pyobjc.html) hasn't been updated in years.
To save others' Google searching: * http://www.mactech.com/articles/mactech/Vol.25/25.06/2506MacintheShell/index.html * http://www.mactech.com/articles/mactech/Vol.25/25.08/2508MacintheShell/index.html * http://news.ycombinator.com/item?id=2031808 * http://diveintomark.org/archives/2003/03/13/address_book * http://www.libertypages.com/clarktech/?cat=19 * http://developer.apple.com/library/mac/#documentation/userexperience/Conceptual/AddressBook/Concepts/WhatsInAB.html#//apple_ref/doc/uid/20001021-BAJGJJAH * http://developer.apple.com/library/mac/#documentation/userexperience/Reference/AddressBook/Classes/ABPerson_Class/Reference/Reference.html#//apple_ref/occ/cl/ABPerson 
Hrm... The PyObjC EGG is v2.2b3 and the notes reference that it's a beta, which requires OSX 10.5. The modification timestamp on AddressBook/PyObjC.bridgesupport is July 10, 2009... Perhaps I shouldn't be using it :) Cheers
I use properties too, like other people posted, but keep in mine, there is no private access modifier in Python. 
properties are so much better than private variables with getters/setters because of the simple fact you can start with something simple and have a clean path open to gain more functionality when needed, as opposed to having to build in more complexity from the start. Really works well with the YAGNI principle.
Had the exact same question in mind a while back, thanks for asking.
Thanks for this!
For class attributes as opposed to instance attributes you can make a 'classproperty'. You could also add properties to a metaclass, but then they're bound to the class object and not visible as instance attributes. On the other hand, with this method while the property can be accessed from the class, the setter can only be used from an instance. Writing to the class variable name directly will clobber the property. class classproperty(property): def __get__(self, obj, objtype): if self.fget is None: raise AttributeError, "unreadable class attribute" return self.fget(objtype) def __set__(self, obj, value): if self.fset is None: raise AttributeError, "can't set class attribute" self.fset(type(obj), value) def __delete__(self, obj): if self.fdel is None: raise AttributeError, "can't delete class attribute" self.fdel(type(obj)) #e.g. class A(object): _x = 'x' _y = 'y' #a regular property accessing a class attribute @property def x(self): return self.__class__._x @classproperty def y(cls): return cls._y @y.setter def y(cls, value): cls._y = value &gt;&gt;&gt; A.x &lt;property object at 0x00C2EA80&gt; &gt;&gt;&gt; A.y 'y' &gt;&gt;&gt; A().y = 'yy' &gt;&gt;&gt; A.y 'yy' 
First of all, you're confusing things: what you're talking about here are instance attributes not class attributes, class attributes would be... well, on the class. Second, don't create getters and setters. [Look up properties in the Python doc](http://docs.python.org/library/functions.html?highlight=property#property), and realize that you can just switch your normal instance attributes to properties if and when you need those. &gt; I have the habit (probably because I come from other oo languages) That's because you come from crummy languages, actually, really. Probably one in particular, whose name starts with J and ends with ava. No offense meant, but most (OO) languages don't require anywhere near that much ceremony these days, even when they mandate a bit of it (as in C#)
&gt; First of all, you're confusing things: what you're talking about here are instance attributes not class attributes, class attributes would be... well, on the class. Yep, totally right. Thanks for the correction as said I am far from being a python veteran :)
OP asked how to do something super-simple and I demonstrated the easiest way to do it. Given you're assuming that's how I write any code that's performance or memory critical, I think it's pretty easy to see who's the idiot at this point.
Unless your variable absolutely needs to be reactive to other things within the system, the best way to access it is to simply use the name: x.whatever. If your 'whatever' is updated by a different thread/process/etc. between uses, then you'll need to use properties.
hmm, I have been trying to implement this, but I think I'm making it too difficult because I don't fully understand. Do you have any examples of how everything should be imported and linked together?
For the general "repeat" part, you could use itertools.cycle. The complication is the "merge the rest of the elements" part, though you can do that with islice, taking the next N-1 elements, and then advancing again to skip to the next element for the next loop. Ie: num_chunks = len(chunks) iterchunks = itertools.cycle(chunks) for _ in xrange(folds): validation_set = next(iterchunks) training_set = Data.merge(islice(iterchunks, num_chunks-1)) next(iterchunks) # Skip over the repeat of the validation_set for next loop #Rest as before, except omit the chunks.append line This assumes `Data.merge` will accept an iterator - if not, wrap the `islice` with `list()`. Not sure this approach is any better mind you: the remove / re-add may actually be clearer. 
I'm no statistician, but I've found that most things in Python have already been done. In this case, you're probably looking for [SciPy](http://www.scipy.org/). For cross-validation specifically, see [this StackOverflow post](http://stackoverflow.com/questions/6629165/k-fold-cross-validation-for-determining-k-in-k-means), and this link to the [general cross-validation method](http://scikit-learn.sourceforge.net/dev/modules/classes.html#module-scikits.learn.cross_val) in scikit-learn. SciPy is a mixed blessing for me. I don't have enough training to recognize that the interesting problems have these ready-made solutions, but when I do stumble into one, it's almost always exactly what I was looking for. The drawbakc, of course, is that SciPy is **heavy**. Please let us know if this helped!
Either way, good luck :)
You name your project "Flask Heroku" but the only code that is actually Heroku related boils down to one line in one file? (Procfile) For me, this looks way more complicated than it needs to be. Deploying to Heroku is just dead simple.
It follows the best practices in [Flask's documentation](http://flask.pocoo.org/docs/blueprints/) and already has [HTML5 Boilerplate templates](http://html5boilerplate.com/) to reduce cross-browser issues. I don't see that as being overly complicated?
Test this at a Python shell: 'lot' in 'slots' (As an aside, I disagree with the question, there are better ways than using eval(). But focus on getting it working first.)
Here is by your method, but as takluyver said, eval is not the best choice... ab = eval(input("Enter a list of words: ")) for word in ab: if 'lot' in word: print(word)
I don't think the issue is that eval is wrong, but rather the way the question is phrased. Eval is not required, there are other ways, but the question is worded badly.
you may have to try something like looking at how the authorization form submits in firebug or chrome developer tools, it may do a referrer check, but there are ways to fake a referrer. Most CLI based brute forcers I've seen rely on HTTP basic authorization, which is perfectly acceptable, but from how I read your response, not what you're looking to do.
It's a bad habit to eval() user input, because that means that a malicious user could type in code to do something you don't want. In this case, it's not a problem, but it's a bad habit to get into. A better way might be to ask the user to enter words separated by, say, spaces, and then do: wordlist = input("Words: ").split() If you want the user to type in the Python list format ["here", "are", "some", "words"], you could also use a safe version of eval(): import ast wordlist = ast.literal_eval(input("List of words:"))
So, how did it go?
Do you have a specific requirement for using Python 3+? I'd stick to 2.7, you'll have much better luck finding compatible libraries.
In typeobject.c you can look at the function [type\_getattro](http://hg.python.org/cpython/file/e6407b2d2f0c/Objects/typeobject.c#l2427). It searches for the attribute in the metaclass hierarchy first (scroll up to [\_PyType\_Lookup](http://hg.python.org/cpython/file/e6407b2d2f0c/Objects/typeobject.c#l2376)). It returns a data descriptor from the latter if present. Otherwise it searches the class hierarchy and returns the value. Else it returns a non-data descriptor or an ordinary attribute from the metaclass hierarchy. Additional information: Since a class is an instance of its metaclass, attributes set on the metaclass aren't visible to instances of the class (in other words, the metaclass is not a superclass of the class). Instead you can use the metaclass \_\_init\_\_ method to set attributes on the class object that are then visible to its instances. In playing around in the REPL I find it simpler to use 'type' to create classes and metaclasses. For example: #type is an instance of type #a metaclass is an instance/subclass of type M1 = type('M1', (type,), {'x': 'x_M1'}) M2 = type('M2', (type,), {'x': 'x_M2'}) M3a = type('M3a', (M1, M2), {}) M3b = type('M3b', (M2, M1), {}) #a class is an instance (not subclass) of a metaclass C1 = M1('C1', (object,), {'y': 'y_C1'}) C2 = M2('C2', (object,), {'y': 'y_C2'}) C3a = M3a('C3a', (C1, C2), {}) C3b = M3b('C3b', (C2, C1), {}) Finally, "Metaclass Programming in Python" ([part 1](http://www.ibm.com/developerworks/linux/library/l-pymeta), [part 2](http://www.ibm.com/developerworks/linux/library/l-pymeta2), [part 3](http://www.ibm.com/developerworks/linux/library/l-pymeta3)) is perhaps a bit dated now (it's from 2003/2007), but still worth a look.
NumPy and PyEuclid.
Last time I checked, numpy only existed for python 2.x.
I actually just installed it from some guy's website who has packages for win64bit python 3.2 for scipy and bumpy.
I only asked since the book I bought was for python 3.2.
NumPy has had Python 3.x support since version 1.5 ([NOTES.txt](http://sourceforge.net/projects/numpy/files/NumPy/1.5.0/NOTES.txt)), which was released 2010-08-31. The current version is [1.61](http://sourceforge.net/projects/numpy/files/NumPy/1.6.1) -- not that his has anything to do with symbolic math (scratches head).
If you don't need the reordering of the training set (which for most cross-validation tasks, I don't think you do), I'd do it like this: for validation_set in folds: training_set = Data.merge(chunk for chunk in folds if chunk is not validation_set) model = modeler(training_set) accuracies.append(model.validate(validation_set)) chunks.append(validation_set) Alternatively, this is a bit cleaner: def xvalidation(data, modeler = None, folds = 10): if modeler is None: modeler = lambda d: id3(d, 'entropy') chunks = data.chunk(folds) def accuracy_for_fold(validation_set): training_set = Data.merge(chunk for chunk in folds if chunk is not validation_set) model = modeler(training_set) return model.validate(validation_set) return avg(map(accuracy_for_fold, folds)) But as the other commentators have said, your code is basically fine; I wouldn't worry too much about it.
I found [this](http://www.lfd.uci.edu/~gohlke/pythonlibs/) site that has lots of unofficial windows binaries (quite a few 64 bit and python 3 supported packages).
his requirement was symbolic, so not numpy, or pyeuclid
http://diveintopython.org/toc/index.html
*Most* python 3.2 code should be valid 2.7 code. If you run into any problems you can always post in /r/learnpython :)
See what [SAGE](http://www.sagemath.org/) uses. I know SAGE is about symbolic math and that SAGE uses Python. Sorry I'm not diving into it for you, but I have my own overloaded schedule and behind-schedule projects. :) Edit: Sorry if that sounded a bit dickish. Don't know if this is what you're looking for, but among other packages, SAGE incorporates [SymPy](http://en.wikipedia.org/wiki/SymPy). 
Exactly. This sounds like something that would be more appropriate for Ruby but in Python explicit is an important design choice.
If you're just learning the biggest thing you're likely to run into is the different **print** syntax.
I seriously just googled "bumpy python"
Last I checked (which was, admittedly, some time ago), SymPy was still in the process of porting to 3.x. A fair amount of the work had been done, though, and it mostly just needed someone with a bit of time that the devs didn't have, so if this is still the case, I'm sure they'd love for (the generic) you to help them out. Edit: Forgot to mention that SymPy is fuckin' great.
Why? The function-like print works in Python 2.7 (and 2.6)
Maybe is not relevant since i dont see a counter involved in your code, but a function i love in python is enumerate(). It lets you loop every iterable (eg, a list) without setting counters or xranges: for index, item in enumerate(mylist): index now contains the current repetition number of loop item has the content of mylist[index] 
Only if you from __future__ import print_function otherwise it doesn't really "work", print(foo) is parsed as print (foo), which becomes print foo because parentheses around single objects don't do anything.
According to a [SymPy blog post from July](http://sympy.blogspot.com/2011/07/sympy-071-released.html), Python 3 porting is "almost completed".
Plus some things like the syntax for printing to a file have changed completely. print &gt;&gt; sys.stderr, "some error here" vs print("some error here", file=sys.stderr)
Have you asked the author(s) if they consider porting their code to Python3? The more requests authors get, the more libraries will be available for Python3 eventually. I hope.
Ty for your answer. Did none of those. I'll try them. I work on a local server running on EasyPhp, so I do tests on 127.0.0.1. So I guess I have all privileges, but I'm quite noob: where and how are those general_log directives? ps so far i tried my script with increasingly complex queries and it works, but the one i posted goes blank.
hey zynix, ty for your interest. It is fixed, without a change: i probably messed up something when copy/pasting the query onto the script. Anyway, the info you posted seems invaluable for the utter noob I am. 
We created [markmin](http://web2py.com/examples/static/markmin.html) because we wanted it to be extensible, support html5 and be close to markdown. It is faster then markdown and it can convert to both html and latex. The source code it short. I can port it to Python 3 easily if you think it would be useful to you. If you need markdown than I will not bother porting to 3 for now.
It's been put on temporary hiatus. I am currently taking a computer science, and it's taking up all my time :(
I like curl as much as the next guy, but curious, why was urllib insufficient? requests?
You can see the status of any open Python 3 issues [here](http://code.google.com/p/sympy/issues/list?q=label:Python3). The latest pull request to go in addressing Python 3 support was [here](https://github.com/sympy/sympy/pull/558). From that, it looks like if you clone the github master, you should be able to use Sympy, with the exception of a couple errors, but more errors will likely turn up as support for Python 3 is finalized and people start using it.
Why not pycurl?
Because urllib don't support socks proxies without monkey patching, custom network interfaces, debugging, certificates validation.
what does 'symbolic' exactly mean?
Do you think that pyCURL API is user friendly? And did you look library readme?
This seems nice, I figure by the time I have gotten used to Python 3, they should complete it hopefully.
I'll try this out temporarily, thanks.
Doing math relating to symbols like x,y,z etc. Mainly manipulating algebraic expressions in relating to symbols rather than specific numerical quantity.
This seems really good.
Off-topic: &gt; If you need markdown than I will not both for now. Wha'?
fixed the typo. I meant to say I will only port if there is a need.
For the community I would like to offer to minifig (the OP) my belief that masklinn was not intending to be insulting by his characterization of a certain language. :)
Thank you very much for the offer, but i think i’ll stick to markdown. if my project is ever going to see the light of day, i want to maximize the number of people who don’t have to learn a new syntax^[1] and since every programmer and their grandma uses stackoverflow, reddit and github, that’s markdown :D ^1: i.e. change parts of the systactical subset they already know. for the extras like footnotes and so on, they will have to learn a new syntax, but they should still be able to do e.g. lists like they are accustomed to
What is a typical use-case for properties? 
i commented on the previously existing [bug report](https://github.com/trentm/python-markdown2/issues/64#issuecomment-1837968) but got no answer so far. strange, as one of the reason why python-markdown2 was created is that the author [got no reply on to his mails](https://github.com/trentm/python-markdown2/wiki/Why-Another-Python-Markdown) to the creator of python-markdown. …does that mean i’ve got to create python-markdown3? ;)
I don't have anything insightful to say, but I figure somebody should congratulate these guys. Lightweight thread-like programming is really handy for dealing with concurrency.
Might want to take a look at [Misaka](http://misaka.61924.nl/), it's a Python binding for [Sundown](https://github.com/tanoku/sundown) which is pretty much what Github is using.
Priorities?
Sounds pretty nice, never heard of it. Downsides are afaics the lazy approach to unicode punctuation and whitespace (=ignore) and the missing documentation (e.g. for extensions)
Oh man, I'm sure this is awesome, but when I tried to read up on it I think I broke my brain. If some kind soul doesn't mind, could you offer a breakdown for what this means for Python (talk to me like I'm four years old. :) )
You are trying to do something that many people do all the time. So typically there will indeed be an easier way to do it. Personally, I'd suggest Django, but there are many other such systems (sometimes called "frameworks"). 
I think one of PyPy’s next big incompatibility enemy is [gevent][], and yet *tealet*, PyPy’s green threading implementation (actually CPython also doesn’t have it but it has been supported through [greenlet][] black magic which includes bulk of ASM codes that hack C stacks) that hides its most primitive continuation implementation under the hood, seems able to help PyPy to emulate gevent. The currently remaining thing is libev/libevent (for asynchronous I/O multiplexing) binding through ctypes (not CPyExt). Plus, does anyone know is there a plan to support language-level async I/O facilities (that implement 99.9% compatibility of existing built-in I/O interfaces — actually `gevent.monkey` provides it) by PyPy? [gevent]: http://gevent.org/ [greenlet]: http://packages.python.org/greenlet/
When you post code, indent with four spaces or use a pastebin like [this](http://paste.pocoo.org/). Your questions: **"is there an easier way to do it?"** If you want to easily edit data from the DB, you can use django's [admin area](https://docs.djangoproject.com/en/dev/ref/contrib/admin/) or [generic views](https://docs.djangoproject.com/en/dev/ref/generic-views/). Instead of CGI, use a web framework, like [flask](http://flask.pocoo.org/), django, pyramid, etc. They have all kinds of tools for handling requests (reading the form data), validating form data, saving data to the DB, templating (replacing your strings of HTML), etc. **"is it worth to compare edited/unedited data for the sake of saving a few updates?"** Probably not, unless it's going to be a bottleneck and you are worried about performance. Just do what is simplest to start. **"is there a way to pass the full query results list via form?"** Yes, for example if you are using an ORM plus a form library, the form library validates / converts the data to the right format, and the ORM stores that cleaned data to the DB. If you are going to use the MySQLdb driver directly, please remember to use parameterized expressions / bind parameters! (see [this explanation](http://stackoverflow.com/questions/775296/python-mysql-with-variables/775399#775399)) 
This gives PyPy a greenlet module, so both gevent and eventlet should just work. We (PyPy) don't play to add langue level async, but that's because we don't plan to modify the language at all, we implement it (and make it fast), and leave the design to other people.
As I know, some part of gevent was written in Cython.
Ah, I wasn't aware of that, they should provide a pure Python version!
 print (x,y) prints a tuple in python &lt;= 2.7
&gt; See what SAGE uses. The current Sage version (4.7.1) uses Python 2.6.4. Derived from: sys.version_info[:3] 
-yes, the pasted code looks creepy indeed. -i know there are frameworks, i just wanted to do something with plain bricks, because prior to this i only had a murky idea about server side scripting, and diving barenaked into a framework looked too scary for me. ty for your advice, its much appreciated. side note: python really IS great. I liked it when I started with it some time ago for a hobby. Then i started this project to make some custom views of a web shop kit (prestashop, made with php, smarty, ajax) because the mere sight of php code makes me shiver. 
try [web2py](http://web2py.com/) it is designed for this. It won [the Bossie award for best open source development tool](http://www.infoworld.com/d/open-source-software/bossie-awards-2011-the-best-open-source-application-development-software-171759-0&amp;current=10&amp;last=7#slideshowTop) and [raked highest among python frameworks](http://www.infoworld.com/d/application-development/pillars-python-six-python-web-frameworks-compared-169442) according to InfoWorld. Here is an example of a complete program to connect to a db, define and create a table, create an interface to list records and add new ones. db=DAL(mysql://root@passwd@localhost) db.define_table('customer',Field('name')) def index(): form = SQLFORM(db.customer,request.args(0)).process() db.customer.id.represent = lambda id: A('edit',_href=URL(args=id)) rows = db(db.customer).select() return locals() EDIT: modified the example to do exactly what you asked. Using only API in stable. Mind that you only need the first two lines to use the built-in web based database administration interface.
Oh, I must not have been clear. :) I meant that the OP could see what libraries SAGE uses for symbolic math. SAGE is just a bunch of libraries pasted together with Python and given that browser-like front end. I hear it's awesome work, but I haven't a clue how to use it! And I actually tried, once.
I'm breaking my self-imposed Reddit ban for this. ;) "implementing" would also work, I suppose, you are correct. I chose "emulating", as I won't pretend to know the true internals of the Ruby version; while I can program in (and sometimes even enjoy) Ruby, I've no time to spend reading the internal source code, so the true method might be doing something I'm not. I personally don't like it being a freely-available trick, as I think it introduces rather sloppy coding practices in general. There's very few cases where this even makes sense, at least in my opinion, hence why I'd probably never submit a PEP on it. Cheers, though. **Edit:** Didn't note that I'm the author of the original post. Whoops.
I'm half/half on this; the reason I chose AttributeError is because at the end of the day, it is really that - it doesn't exist in the dict. I tried to straddle a line between magic and non-magic, really. _NotImplementedError_, to me, is that... in this case. I'm the author of the original post, in case you couldn't tell. I don't check Reddit much anymore, so I didn't catch this when it was originally submitted.
Decorators would be another nice approach, yes, but I went for ease of use over anything else. Decorators require you to have a little more knowledge about endpoints (and maintain them yourself), whereas mine is just "grab the function call, pass params, done". Feel free to fork or something if you care; it's an actual project on GitHub. ;)
I know this is not what you are looking for, but just in case, you know about [moinmoin](http://moinmo.in/)?
The *point* of gevent is to use an event loop written in C for speed, i.e. libev or libevent. Pure Python version would defeat the purpose. As hongminhee suggested, writing ctypes binding to libev or libevent for gevent is the sensible solution. (Or Cython ctypes backend...)
Nobody uses CGI in 2011. Use a WSGI-based framework. [Flask](http://flask.pocoo.org/) is a small and very nice one.
That point is completely moot for PyPy. The python level loop that shifts around python objects will be simply much faster
Can we see squares.py?
Here it is! http://pastebin.com/M4mhyZns
Well, I'm on Ubuntu, and simply going into Python in the terminal, importing squares.py, and giving it a depth value, all depths I've tried (1, 2, 3, and 6) work great. The central (largest) square is always the same size in the drawing area, and there are simply more and more small squares falling away behind it. It's pretty neat. I'm not using Python 3. Maybe something has changed?
Yeah I have a feeling it is something on my system, since there is no reason why running the same code should produce different results. Thanks for testing it though!
do you have php background? :) if you do it in python, you usually avoid mixing python and html like this also, consider abandoning the old-fashioned CGI in favor of some WSGI microframework I love bottle.py, but please do a research first, because there are many other options also, i think MySQLdb is considered to be the ugly kid and you should use oursql instead
First, that is to be seen. (I don't exactly doubt you, but does Twisted running on PyPy outperform gevent running on CPython?) Second, libev/libevent provides platform abstraction in addition to speed. Pure Python event loop will need to deal with OS idiosyncracies. Again, completely possible, already done by Twisted, but a lot of hassles.
Well, given that the current Sage is using Python 2.6.4, no Python-based library requiring a newer release would work with it. So it seems that answers the original query, at least with respect to Sage. For those who are interested, [my Sage tutorial](http://arachnoid.com/sage) 
It seems to work for me too w/ Python2.7 and Python3
Go cobrateam!
The equivalent Python loop would outperform equivalent C loop in PyPy, yes. Twisted and libev are definitely not equivalent at all. Regarding the OS - well, too bad, it's work.
Finally, I'm going to write a Python script to procrastinate for me. Well, maybe not today.
You could always just use `discount`, the C markdown by calling it with `Popen`. That's what I do.
I came here thinking, would't it be cool if there was a *curl* wrapper that is a drop in replacement for *requests*, thats what it ended up being:).
How this compares to mechanize?
Ooh javascript too? Pretty.
From my understanding Mechanize provides a browser-like Python module that will behave as if it were a real browser -- it can be used for scraping or testing. This seems to provide a module that controls an existing *real* browser, so especially for testing purposes (and ESPECIALLY for any page that executes Javascript; AJAX etc.) you get a true browser instead of having to work around what limitations exist in Mechanize. I suspect that you'll experience quite a speed hit if you are expecting performance out of Splinter, when comparing to Mechanize. If anyone has benchmarked Splinter I'd be quite interested (from a testing perspective). TL;DR: if testing: Splinter if scraping: Mechanize
How does it compare with [Spynner](https://github.com/rndbit/spynner)
In my knowledge, there's a web automation tool called [Selenium](http://seleniumhq.org/) and its script can be written in Python. I haven't really touch both, how do they compare?
This supports javascript.
Does it run on Windows?
I am sorry are595, I 've done it in Java few years ago for my previous company. but I never wrote a GUI program in Python, only deamon and web apps. 
This looks absolutely incredible. Thank you for posting. Anyone have any experience with it? If so, how is it? How mature and reliable is it?
I used selenium a while ago for testing and it was not very advanced then (but google was using it, they said). The code of the splinter example looks really similar, though.
Also see Selenium.
Looks like it uses Selenium to handle the actual automation portion for firefox/chrome, the non-selenium option is zope headless.
hi all, ty for your answers. It seems a framework is the way to go, but what are the server side installation requirements? I mean, I dont have a server, I have a website on a commercial (paid) ISP. They offer support for python, but can I expect to have support for Django, web2py or others? Do I install them on my domain, or I need server admins intervention? 
Not this one but I used Selenium/Webdriver and it was very good.
Glad this was already mentioned, I was like "welcome to QA products 10 years ago" 
It depends. Most shared hosting providers only give you a web root, and possibly some CGI support. Python frameworks are usually based on WSGI and served by a separate server. For Apache, `mod_wsgi` exists as a built-in WSGI server. For other web servers, you'll likely use a standalone like uWSGI or GUnicorn, either as a master process or with one instance for each web application. The core difference is that unlike PHP, Python (and Ruby and Node.js) is not about augmenting static web pages. It is about creating web applications. That is, you write an application that happens to produce responses (usually HTML, but maybe PDF, an image or a different format like RSS) to web browser requests. The usual solution is to either get a VPS (ideally with dedicated resources or on-demand scaling, but cheap ones with shared resources should do for small projects) or a dedicated server. There are a handful of providers that offer WSGI hosting similar to traditional shared hosting, but they may be restrictive in what they let you install. You can write simple CGI scripts in Python, but that's a very small niche and you'll be hard-pressed to find relevant help or tutorials. Even trivial apps often make use of existing libraries or frameworks (PyPI is one of Python's strengths) and it may be difficult or impossible to install them by just throwing them in some place in your web space and to use them from within CGI scripts. If you really want to get into Python programming, it's a good idea to either get an affordable VPS or convert an old desktop PC to Linux (Ubuntu is often considered the most beginner-friendly flavour these days). That'll give you a sandbox to work with. If you're a little more adventurous, you can also install a VM (e.g. Oracle VirtualBox or VMWare, both of which are free) inside your regular operating system and work from there -- this is by far the cleanest way to set up (and reset) a sandbox for development. I suggest you look into the Django documentation or possibly buy a book (*Pro Django*, *Practical Django Projects* and *The Definitive Guide to Django* are good ones, though I would recommend picking only one of them as they have a lot of overlap), preferably a fairly recent edition. Django is relatively beginner-friendly as it mostly follows the same design principles as Python itself, comes with lots of batteries included and introduces concepts you'll frequently come across in other frameworks.
web2py is the only framework that has a web based IDE and managemtn system. You can try it [here](http://web2py.com/demo_admin). It comes with its own web server which is really good and supports ssl. It also supports third party web servers like apache, lighttpd, nginx and uwsgi. [here](http://vimeo.com/28112026) is a video that shows how easy it is to deploy for free on fluxflex (free hosting). Web2py code usually runs out of the box on Google App Engine.
wow, ty, you people at reddit are really helpful. I see Django is the most mentioned framework here, althought i took a look at web2py and i found it very friendly. By now I'll stick to local cgi learning (via easyphp local apache server) just to get the feel of what i'm doing. Seems a hard decision between Django and web2py. This one claims i can make it work with some edition of config in my ISP, I have to take a closer look at that. Anyway, the sure thing im learning with this web thing is a lot of acronyms. 
yes i like this. My only caveat here is i'm quite new to this and I only have a commercial host (apache server) wich says it supports python (and i think it only does it on demand) . I read something on web2py docs about configuring some apache files, but can I do that editing, or I have to ask my ISP to do it for me or grant me persmissions?
So, looking at the code, this is tricking gdb into running Python's evaluation code to run an arbitrary file. It's a little unclear whether this should be considered a bit of an exploit -- does the process being injected into have to be configured in any special way for this to work (besides having debugging symbols turned on)?
The process being injected into does not require special configuration in any way, and you don't even need to have python-debuginfo installed.
You do actually need the python-debuginfo for the memory-viewer tool to work, but injection seems to work fine without it.
See also this blog entry of one of the developers of Splinter: [Splinter: Python tool for acceptance tests on web applications](http://f.souza.cc/2011/05/splinter-python-tool-for-acceptance-tests-on-web-applications/). "*There are many acceptance test tools on Python world: **Selenium**, Alfajor, Windmill, **Mechanize**, zope.testbrowser, etc. Splinter was not created to be another acceptance tool, but an abstract layer over other tools, **its goal is provide a unique API** that make acceptance testing easier and funnier :)*" (emphasis by me) For me the big advantage is that it can process Javascript (AJAX) *and* I can tell the browser to **wait** until all AJAX codes are fully loaded. With PyQt and webkit I could never add the feature to wait X seconds before getting the generated HTML source.
I'm on Arch, I couldn't find python-debuginfo package in aur Is it available only on fedora?
I have been using webfaction for a couple years. Pretty nice and simple, but I am starting to outgrow it. I get 80mb on a shared server and the 2 django apps I always run stay just below that. If I add a third, I have more outages. At this point, I could upgrade to a bigger shared server or move to Rackspace for about the same price. Also, I have played with Gondor while it was in beta and really love the concept and execution (similar to Heroku but for Django). They just went out of beta with the cheapest option being $10/mo for an app plus $10/mo for a database. There is also Ep.io that is similar but offers a free option below a certain threshold. I will probably put some pet projects on Ep.io in the future. 
I have been using Webfaction for small and medium-sized projects for the past year. Haven't run up on any major problems yet, although I typically don't run more than one Django site on the server at one time. This is a list of reasons Webfaction is nice/things to look for in a host: 1. Appropriately priced (Webfaction is $7-10 month, more if you need HTTPS). I feel like Gondor and Ep.Io are a bit overpriced for what they are offering. 2. Good support. Sometimes you need to rewrite some Apache configuration files (like if you're installing an SSL cert). Sometimes things break and you don't understand why. Webfaction's support is really good and responsive, I've never waited more than a few hours to hear back from them and it's usually much faster. Their documentation is also really comprehensive and kept up to date. 3. Lots of options. You can run pretty much anything on Webfaction: any Python/Ruby thing, Wordpress, PHP, git repos, etc. 4. Lets you install anything inside your instance, in your home directory. If you've ever witnessed the pain of a GoDaddy account where programs like git cannot be installed, you will appreciate this. That's my 2 cents. If anybody has experience with Gondor or Ep.Io, I'd love to hear about it! I'm curious, myself.
The -debuginfo package is an RPM-ism containing the DWARF metadata for debuggers (info on structure layouts, mapping from variables to locations and registers, etc): we strip it out and package it separately from the main package because it's large relative to the rest of the package. I believe Debian does something similar with -dbg packages; I don't know about Arch. On Fedora/RHEL6 that package also contains the pretty-printer hooks for gdb7 onwards, which is what the memory-viewer tool uses, to translate from pointer values to human-readable representations of the Python objects. The prettyprinter hooks need the DWARF data in order to work, so it makes sense to package them with the DWARF data. They're present in the python.org code repository in the Tools/gdb subdirectory of cpython; I don't know to what extent other distributions package them. Some (old) notes on them can be seen at http://fedoraproject.org/wiki/Features/EasierPythonDebugging and also at http://docs.python.org/devguide/gdb.html Having said that, the memory-viewer is just one of the payloads; you could always just use meliae to dump a JSON representation of the live objects, and then view that e.g. in RunSnakeRun's graphical viewer. The pyrasite code is using gdb to inject (machine code) function calls using the CPython C API into the python process; AIUI in order to do this I believe it needs either the DWARF data _or_ dynamic linkage metadata, and with the latter, gdb seems to be smart enough to make good enough guesses when generating the function calls (the code in question seems to be in gdb's infcall.c sources, and has some smarts for guessing at the prototype of the function, if I'm reading that right) So it works for us without the debug data because we're using a dynamically linked build of python, your mileage may vary. Hope this is helpful
It means PyPy now has the greenlet module (http://packages.python.org/greenlet/), which lets you use things such as eventlet (http://eventlet.net/).
AWS. You very well may fit in the free usage tier, but even if you don't it's inexpensive and reliable. At work we use Rackspace. No complaints about either.
Every host is different. Check if they have mod_wsgi installed of it they allow you to configure mod_proxy on mod_rewrite in .htaccess. Feel free to bring this up the web2py google group and we will help you. Hosts that only support centos with python 2.4 tend to be a major problem for all web frameworks. If one works usually the all work. 
Easy enough but how do I add or delete a friend with this?
Thanks! Many of the projects are just hosted on a free tier server. I haven't looked at scaling with multiple servers, and I'm not sure if I'd rather have someone else take care of scalability or spend my time doing it.
Thanks, I'll check them out. The price is certainly better than Rackspace, and give or take the same as EC2. EC2 has less support, but I've had similar support through Rackspace. Neither require extra costs for SSL. Maybe I'll just build my own hosting platform :D
Thanks, I'll check them out. I'm using Rackspace and EC2 right now and loving it. Nginx is great for the lower memory servers. I definitely have a lot of room to grow. Gondor is a bit more expensive than I'm paying now, but not too much more. It might be worth it to not have to deal with the server myself. Or maybe I'll just build my own hosting platform. :D
Any free hosting for intro level undergrad stuff??
What school do you attend? 
remember that i want to use a extensible solution in order to add custom syntax.
Maybe the best... After Komodo of course.
Take a look at pyquery, it has this, and is based on lxml and thus is super fast.
Answered my own question, the key is to use DocumentText.
upvote for pyquery, it totally replaces BeautifulSoup.
I love PyCharm... totally worth the splurge if you're hacking in Python for more than 20 hours a week or just love yourself a little bit. Django templates work really well, auto-complete works very well... and it's really not that expensive.
Rochester Institute of Technology. Any reason you ask? And this is a second week work in the intro class. 
[Sublime Text 2](http://sublimetext.com/2) is also an amazing Python editor. :)
I will try pyquery but BS has its right to live. lxml is quite difficult to install and there are occasions where you cannot use it, e.g. on Google App Engine. BS is just one file written in pure Python. If you like lxml's css selector but you cannot use it for some reasons, BS might help you out.
Ah, okay. So efficient concurrency?
Arch keeps it all in one package, sometimes puts documentation in another package if it is substantial.
Heroku is beta testing more first-class-citizen Python/WSGI support. That's when I'll be excited about Heroku.
 def checkHeight(height): if height &lt;= 132: print "Sorry. You must be at least 1 meter 32 cm to ride." else: print "Have a great ride!" height = int(raw_input("Please enter your height in cm: ")) checkHeight(height) 
I got it to learn Python, and the intellisense in it is an amazing learning tool.
Works fine from depth 1 to 7, then it get stuck, or it draws something so small that I cannot see it maybe.... Cool assignment btw! I like both the concept and the results.
Ah! If I wait long enough with high values, then it draws something, but it doesn't look like anything, I suspect it draws sub-pixel stuff.
Try now, I believe you are on windows? def checkHeight(height): if height &lt;= 132: print "Sorry. You must be at least 1 meter 32 cm to ride." else: print "Have a great ride!" height = int(raw_input("Please enter your height in cm: ")) checkHeight(height) raw_input()
Minute detail: "At least 132cm" is 132 and up. So your condition should be: height &lt; 132.
Yeah after a certain level the squares get so small you just can't see them. 
exactly! And you need the last line to keep the console window open to see output
boring
I just do pre- and post-processing in Python, while leaving the Markdown → HTML to discount.
Please post things like this in r/learnpython.
I'm debating. If i should get a new license or renew my current one. It's only $10 more then I get a brand new license. 
Actually, Splinter uses Selenium. So it appears it is mainly a new API? `sudo pip install splinter` `Downloading/unpacking splinter` ` Downloading splinter-0.4.tar.gz` `Running setup.py egg_info for package splinter` `Downloading/unpacking selenium==2.5.0 (from splinter)`
Is there an equally good intellisense/code completion in any other editor?
sweet, made my job easier. thanks man!
yeah, did the same research - overall it was much easier using BS
Pretty good... but it's no vim.
Your license is valid for a year, if V2 comes out within this period, you have a free upgrade
In my experience not really, I was actually really surprised the first time at how well it 'understood' my code, especially when you consider how dynamic python can be.
Does vim have as good or better autocompletion/intellisense support? Even for django template variables and custom tags? 
I am using ep.io and fluxflex. Both have free options. I really can't attest to "best" or even stability, as I am just getting my feet wet. However, it seems to me that fluxflex gets too litlle attention. So here is a link: https://www.fluxflex.com Mind: The do other things then python (e.g. on click redmine (RorR) setup) but you can also deploy e.g. a web2py site extremely easy, via the github plugin (supports global hooks).
You can have vim inside PyCharm with the help of vim emulation plugin — http://blog.jetbrains.com/pycharm/2011/04/pycharm-your-vim/
From their FAQ: &gt;Licenses are perpetual for the licensed version of the software and for all versions released within one year since purchase date. (depending on license)
The license is actually valid forever, but only for versions released within the year since your purchase.
PyScripter, represent!
No, it's an IDE.
vim is no emacs
For $50, it wouldn't have to save you much time or headaches to pay for itself. Other than games on Steam, PyCharm is the only PC software I've actually bought in the past few years. Love it.
A pity PEP-0355 was rejected, although I do understand why. As described in the reasons for rejection, a class that is not based on string and is not that all encompassing might have been accepted.
** Actual link: [Wing IDE 4.0.4 Released](http://wingware.com/news/2011-09-19) **
Looking forward to see where this goes. At the moment it's not that much of a leap forward from the CoffeeBrew plugin that came before - just nicer highlighting and it looks like they've fixed a text highlighting bug. A couple of things I'd like to see in rough order: * Ctrl-click to go to definition * A function to compile a highlighted section (like the emacs mode) would be awesome. That said I'm beyond impressed with Pycharm and the speed with which they crank out solid new features! *edit - grammar*
so...should i get a new license or not?
&gt; Auto-enter closing quotes, comments, and parentheses, braces, etc Wow, I'mna check it out.
I felt a bit silly chiming in on the two services that you've already used ;) But you can count it as a vote that, IMO, you're doing it right. On scalability, one of my biggest suggestions would be to *not* try and do it all yourself. Rather than trying to set up your own redundant database, use SimpleDB or RDS, whichever is most appropriate. Rather than setting up and maintaining your own load balancer, spin up multiple EC2 instances and use Amazon's ELB. If you are a startup/small business, this lets you focus on doing what you're good at. With web applications, one of the best things you can do is to avoid putting all your eggs in one basket. My primary apps run on AWS, but I've got an "ohshit" image on Rackspace that I can make active in an hour or two -- that's actually much faster than my own needs dictate. At the very least, you should be making &amp; testing regular off-platform backups; I trust Amazon to not screw up my DB more than I trust myself, but that doesn't mean they're going to be the only people that have a copy.
This is what I do. FUCK THE POLICE.
Still get the same DLL error with PyQt4.
Thank god.
 History in shells operates on whole blocks Option to filter shell history by entered prefix Use dynamic analysis for goto-definition in the editor, when available Auto-editing (must be enabled with Editor &gt; Auto-Editing preferences): * Auto-enter closing quotes, comments, and parentheses, braces, etc * Tab through auto-entered invocation arguments * Apply quote, comment character, or parenthesis to selection Support ## comments and new block syntax in Mako files Allow scrolling editor one page below the last line Refactoring can move symbols to a new file PyLint panel improvements, including support for version 0.23+ Commands to copy editor and project file names to clipboard About 70 other minor features and bug fixes included vi mode improvements 
depends on what you are looking for. Personally I want a cross platform IDE, not just one that works on Windows. Pycharm fits that bill. However Eclipse and Pydev are free and work just as well. I however am a complete Novice and can't really code much as it is, so I may not be the best judge of IDE character.
It really isn't painful on nginx. I just run a fastcgi daemon under supervisord and do an fcgi proxy pass to a unix file socket. Luckily though, I don't deal with shared hosting.
Still needs X-11 on the Mac. 
&gt;Allow scrolling editor one page below the last line This ones awesome too, because the page used to just stop at the last line of the file, making editing down there awkward.
This might be a better post at [r/learnpython](http://www.reddit.com/r/learnpython).
This could potentially be a stupid question, but how exactly are WSGI and FastCGI different/similar? I just know that WSGI is Python specific and FastCGI is language agnostic.
The version of the plugin which will soon be bundled with PyCharm 2.0 EAP is already much further along. It does support Ctrl-click, completion and many other code insight features. We don't yet have any built-in solution for compiling CoffeeScript to regular JS but we'll figure something out.
This really depends on what you want. How much traffic do you get? How much resources do you need? Do you want it fully managed Engine Yard style or you just want something small for a personal blog? Do you want support? Do you want a stable system? For example, AWS (EC2) is cheap, but does not include any support of any kind. Support costs extra and is VERY expensive and you have to get a high level tier to even get phone support and it stops at the virtual machine layer, leaving a lot of setup work. Plus they are unreliable and they often lose data, but they are cheap. You see, it is all trade-offs. What it really comes down to is how important is your app and data, and how much do you want to spend.
Thanks, didn't know that existed!
A WSGI app is just any callable in Python that takes two arguments, an `environ` dict (with HTTP headers and things) and a `start_response` callable, and returns an iterable of content to return. FastCGI is a wire protocol that a web server can send over stdout or a socket to your process. They're similar in that they're both in the general realm of web service interfaces. They both provide some abstraction above HTTP that is helpful for writing reusable stuff on top of them (Python web frameworks can all implement WSGI, web servers can all implement FastCGI, so things can interoperate between them).
I use the `with` statement for instrumentation. I'm doing research that involves automatically generating blocks of code and tracking the number of loop iterations they incur. The code doesn't strictly need to be human readable, but the `with` statement helps keep it that way nonetheless.
This is really good. I force myself to use the with statement when opening files... but never thought of implementing it myself. Now I've got a bunch of scripts that I want to re-visit and implement it!!!
Posting the own blog is already quite ... , but posting the own blog with content copied 1:1 from another site instead of posting the original link is really ... 
WTF? Is there any information in this comment in addition to the orginal release notes or to the copied ones in your blog? This kind of noise is really annoying for people who read reddit because of the valuable content of some of the smart guys here.
Please stop spamming with your blog. I thought your last post was borderline - this one is clear. If you're not going to offer anything more than a changelog, you should just directly post the changelog or news post on the Wing site.
No idea about your problem, but... def drawSquare(original, depth, length): if (depth == 0): return turtle.forward(length /4) turtle.left(90) # DRAW BOTTOM LEFT SQUARE ....
&gt; there is no reason why running the same code should produce different results. Consider this your introduction to CS :-)
In the post I mention some problems with this approach. If you have a solution for them, let me know. It'd be nice to solve them together with the community.
This is a novel way of attaching to the process. But there's tons of other, in some cases simpler, ways of doing this.
Thanks! It is good to hear someone thinks I'm doing it right. Good suggestions. My apps usually rely on SQL, and I haven't used RDS because they don't have a tiny version, but I think I'm almost to the point where I'll need to. ELB is definitely the route to go for instance scaling. How are you doing the data backups so you can get them to Rackspace when an "ohshit" moment happens? A third party backup or maybe CloudFiles? This is a really good idea and I'll have to implement it soon. Thanks!!
I love the integration with GitHub. I'll take a look at fluxflex (and ep.io), though if I keep hosting them myself, I think I'll have to set up a way to do the GitHub deployment..
App Engine, ep.io, fluxflex and EC2 all have free options, depending on how you want to do it.
I have mostly smaller apps, but some of them are starting to grow. I am just trying to be a bit proactive about scaling, as I'm growing out of my EC2 free tier. My experience with Rackspace has mostly been EC2 + support for not too much more. Thanks for the comment!
why, just why is it so fucking ugly?
In this space, there is also [statsd](http://github.com/etsy/statsd) which is language agnostic (but has no viewer), and [logd](http://hiidef.github.com/logd), which is based on statsd but also handles logs and *does* have a viewer. `logd` and `statsd` are both written in javascript (nodejs). `logd`'s viewer is a django app. They both use graphite for saving &amp; displaying stats/charts. (full-disclosure: I am the author of logd.)
the outcome would be the same, either way you get a support extension for 1 year and access to 2.0 ... so the cheaper option should be the way to go.
seems pretty hacky. also, you can do that with misaka, too (in a more portable way)
Really good. I would have overlooked this forever. Thanks.
Missed one: 5. From time to time the answer to "run" is "no". No explanation. By the way, I didn't make clear that I'm a big fan of the idea of this tool... If only it worked. 
Thanks for this brilliant article btw &lt;3.
Fun fact: If you're coding for various "enterprise" Linux distros (*cough* RHEL and CentOS), the Python there is currently too old to use the "with" statement. I was bit by this about three months ago.
Great examples. I thought this was going to be a typical "How does with work?" with just the file-like concepts, but it actually showed a different use case.
Python 2.6 is needed.
I have it in version 2.5.2. If it's missing in version 2.5+, try `from __future__ import with_statement`.
Thanks! Didn't know that.
"Fluxflex" sure doesn't roll off the tongue well. Something to keep in mind when you think of a name for your startup. Only two syllables but tons fricatives. Just my opinion, I guess.
I hadn't seen misaka before. Looks neat.
PyCharm is cross-platform, I believe it is a Java thing. Me too am novice, thats why I really want a good intellisense, to help me see whats there what can I do... without resorting to documentation every minute
Wing 4.1 will be entirely made of toolbars, tab bars, buttons, and scrollbars, except for an 80-character-wide window with a single line of code. Wing 4.2 will replace the space occupied by 79 of those characters with a new "navigation bar" allowing you to select which character of code you want to see in the remaining space. In Wing 5.0, the process will finally be complete: you will write your code entirely by selecting things with the mouse. You won't ever need to see the resulting code; after all, it's either right or it's wrong, and if it's wrong that's what the Debug Probe is for.
http://code.google.com/p/pycparser/
Ya know, I saw it before but I thought it was only good for executing c code. But it should work, and even describes the fix to the attribute keywords. Very nice. Thanks for having me give it a second look!
Sorry for my narky comment. The main benefit I see of the GTD approach is to undermine the control we imagine we have by assigning dates to everything. It does away with micromanagement. The main features as I see it are to: * Prioritise actions to find your next action. * Break down actions so the next action is easy. * Regularly review If you have something that needs doing by a certain date, do it now, unless there is something more important to do. Maybe the date is important to help you prioritise, but GTD doesn't use it directly for scheduling - you just have a priority queue. For me the simplest idea in the book was the two minute rule. If something will take fewer than two minutes, do it immediately, rather than entering it into the system, if possible. Many actions can have their next action sliced off into 2 minute slices. Getting started is often for me the most difficult part, and the first slice is the hardest. I think of it as broaching. I think you're doing a good job with this project. A colleague of mine is writing something similar, and we're having similar discussions.
Maybe you can adapt [ctypeslib](http://pypi.python.org/pypi/ctypeslib) to your needs ([old docs](http://starship.python.net/crew/theller/ctypes/old/codegen.html)).
God, I am happy that from the beginning I was writing Python in VIM and simple text editors like Gedit...
but what does pyquery have over lxml?
Thanks! This is helpful.
yeah, look above: http://www.reddit.com/r/Python/comments/kjg7c/need_extensible_markdown_implementation_in_python/c2ktme8
My immediate reaction to this is that it gives the impression Django coders are the new PHP coders. Which gives me the impression that maybe it's time for me to move onto something new :-)
Personally, I use PyQt and pyinstaller. I just like PyQt. It works very well for me with quick development using QtDesigner, then modifying the code/callbacks in my regular IDE. With pyinstaller you have the option of creating a single file (which is really just a zip that gets uncompressed at 'runtime'), or creating a directory with all the files. You'll end up doing a bunch of boilerplate with both of these solutions. You'll make a few batch files for PyQt to compile your UI and your resource file (if you want to use one). You'll have to make and tweak a few files for pyinstaller as well. This all works under virtualenv for me as well, so that's a plus. You'll still have to test deployment though. Pyinstaller does a good job of getting the necessary windows files and the PyQt files. I can't speak for other UIs.
pyinstaller looks like just what I was looking for. I'm not sure about PyQt yet, I'll have to test it. There are lots of UI libraries for Python, I'm just trying to figure out which one the community likes best
A while back I was in the same situation. I chose py2exe and wxPython. Neither feels very Pythonic IMHO. Not necessarily in functionality, as both work ok, but more in feeling. Py2exe spits out strange looking files, and window layout wxPython is one of the most frustrating things you can do in Python. I think these two areas are relatively overlooked. Imagine a GUI framework based on CSS with Pythonic syntax, and then to deploy cross platform in a slim executable without bloat.
I'd have to second the PyQt recommendation. You get the nice abstraction of Qt in python without having to use something like pywin32 and making direct api calls which (from my experience) is not fun. 
I seriously wonder what toolkit they use - I would have thought GTK. But even for a GTK app on Mac the screenshot looks tremendously ugly.
How about this? https://bitbucket.org/leapfrogdevelopment/punkybrowster
&gt;How are you doing the data backups so you can get them to Rackspace when an "ohshit" moment happens? A third party backup or maybe CloudFiles? I've got a script to push database dumps onto CF. Getting everything back up to life means provisioning a server from the snapshot in cloudfiles, pulling the latest version of the app from git, apt-getting any critical updates on the server, hammering the DB dumps back in, and fixing DNS to point at the new server. As I said, it's about a two hour process, which is much faster than I need my site back online. The biggest mistake most people make is that they set up a backup system, assume it's working, and discover that it's horribly busted once they *actually need* their files. This actually bit me at an old job -- we lost a ton of photographic data that could not be recreated (photos created of the construction of an office complex). Ever since then, I've been sure to test my backups regularly.
Your main options for cross platform GUIs: - PyQt is probably the favourite for 'serious' applications. It's a fairly big framework, but the results look quite polished on all platforms. - Tkinter is quick and easy, and it comes with Python, but the widgets can look rather clunky. - wxPython has been quite popular in the past, but I think fewer new projects are using it now (my subjective view). It tries to use native widgets, but I've still seen wx GUIs looking out of place. The only one of these with no Python 3 support. - PyGTK/PyGI: Probably mainly used for applications in a GTK environment. PyGTK is the older bindings, and PyGI are the new ones.
Turtles all the way down.
I don't have experience with either, but there is also [PySide](http://www.pyside.org/), which like PyQT provides Python bindings for QT, but does not require a commercial license (it's LGPL licensed). PyQT is free for open source, but requires a license if you use it commercially. Not that there is anything wrong with requiring a commercial license, and in fact PySide is looking for funding as their current primary source (Nokia) is set to stop at years end.
You can't hear nothing outside iTunes? How do you call this? iDeaf? :-)
I've had some luck with a variation of this [emacs setup](http://hide1713.wordpress.com/2009/01/30/setup-perfect-python-environment-in-emacs/). r/emacs is another source you might want to check out. EDIT: the setup mentioned is only if you need the "IDE" features... emacs is distributed with a python mode out of the box that is pretty good. The only change that I make every time is to add the following snippet to your .emacs (turns on autoindent every time you hit enter) ;;; bind RET to py-newline-and-indent (add-hook 'python-mode-hook '(lambda () (define-key python-mode-map "\C-m" 'newline-and-indent))) 
Just because something's successful doesn't mean it's crap. Goddamned hipsters. :-)
I've been using [pandoc](http://johnmacfarlane.net/pandoc/) with slidy to generate slide, but this looks pretty cool, too.
It is GTK, as far as I can tell.
I hope Flask and Werkzeug are not affected by this. Someone knows?
It does tend to mean it's less remunerative though :-)
Yep, that was my point (I think it's in 2.5 though). All I'm saying is three months ago I wrote something that made heavy use of "with" only to discover it wouldn't work on the target platforms my team wanted so I had to go back in and put the old try/except stanzas instead...
WSGI does not specify what to do in such a situation and since you get some sort of error from your server anyways the request dies. Since the user is already disconnected at that point they won't see an error either. The only problem there is that you will have an error entry in your server log but no further damage is done.
&gt; Incorrect. You don't get error from the server, you get a truncated upload, which is the point. You get an error as soon as the buffer is empty. Werkzeug for instance will read until it consumed content-length bytes and if that is not the case it will try to loop until it did. Then the server will either block until the client supplied that data or if the client disconnected the socket will give you an exception (typically some sort of Value or IO error).
As far as gui tools go, I think it's (py)qt &gt; (py)gtk &gt; wxwidgets (wxpython). The designer from qt is fantastic for placement of widgets (provided you use the stock ones). You can adapt a python class and have it show up in the designer, though it takes some work to setup. There is a bit of a learning curve, but once you're there, qt and pyqt are definitely the way to go. I use py2exe to bundle my application into a single folder with dlls and exe files. I use innosetup to create a distributable setup.exe file.
Another vote for (Py)Qt here. I've used it on Linux and windows with good results. This was for in-house use though, so I can't speak to distribution.
You tell py2exe `bundle_files = 2` and it puts everything into one archive. Then you'll have to do class custom_py2exe(build_exe): def plat_prepare(self): build_exe.plat_prepare(self) self.dlls_in_exedir += ['tcl85.dll', 'tk85.dll'] (but for corresponding QT dlls, if you want to use QT). I haven't used pyinstaller though, so it might be even better.
Or have there been others I don't know about?
Thanks man, it works! Actually I tried spynner but the two should work the same way: import spynner browser = spynner.Browser() browser.load(your_url) browser.wait(3) print browser.html The good thing is that during browser.wait(N), the browser object is working and downloading (while a time.sleep() would block everything). And it's headless, i.e. no browser window is opened.
What the heck is this even trying to do? It's like nightmare fuel for python. 
This is a rather cool use of gdb. The method used in inject.py should work on any process that is using pythons C API. For example #include &lt;Python.h&gt; void main(){ Py_Initialize(); while (1) {} } Compiles with gcc -I/usr/include/python2.5 -lpython2.5 on my system. Run the exec and then: &gt;&gt; from pyrasite.inject import CodeInjector &gt;&gt; ci = CodeInjector(pid_of_exec, 'payload.py', verbose=True) &gt;&gt; ci.inject() This is really just a wrapper of gdb, but interesting never the less
It reminds me of [Langton's ant](https://secure.wikimedia.org/wikipedia/en/wiki/Langton%27s_ant) because of the "highway".
I will investigate this issue.
Had to look to make sure some of mine hadn't escaped :)
Way to go. This could perfectly reasonably be done in a single line...
I'm an amateur programmer, and I just have to say that I am shocked that there are "professionals" writing this stuff...
wow. 
I didn't think you needed to declare (or initialize) variables like that in Python....
How exactly would you do this in a single line? 
make pythoners/pythonians/pythonites feel queezy?
And I thought the "if not not not not bool:" my co-worker found was bad... 
This is an obviously pathological example, but it does show a basic weakness in Python syntax: it's up to the human to make sure all the indentations are consistent with the meaning of the algorithm. If the human makes an indentation error, Python will blindly follow what was typed, not necessarily what was meant. While writing Python code, every so often I trace a program bug to an error in indentation that would otherwise have escaped my attention. In languages with explicit scope delimiters you can write a "beautifier" that detects some kinds of syntactical inconsistencies and focuses one's attention on program structure. I actually wrote a "beautifier" for Python [now posted on my Website](http://www.arachnoid.com/python/pybeautify_program.html) that is almost completely useless, because it can only detect the most obvious kinds of indentation errors, and doesn't really beautify or correct anything. The obvious solution to this problem is to break Python code into small functions and avoid any serious dependence on structures whose complex indentation might come back to bite you. 
TIL...thanks.
It'd be a lot easier to crack this nut if we knew what *this* is trying to do.
Doesn't Sikuli use OpenCV image recognition ? I would suggest sticking to Sikuli, I don't think you can program something faster, just change the variable "#Settings.MinSimilarity = X" in Sikuli
You need to realize that employers want the least expensive programmer they can hire. I think in this case they succeeded beyond their wildest expectations. This reminds me of an astronaut joke -- they asked John Glenn what he was thinking about while waiting on top of the rocket. He said, "All I could think about was that everything in the rocket was made by the lowest bidder." 
`itertools.permutations`
I made the mistake of running it. It's created a 60 MB file so far. I think it could be worse, too.... genpassword("abc", 3, "derp.dat", 3, False)
This is an obviously pathological example, but it does show a basic weakness in C syntax: it's up to the human to make sure all the scope delimiters are consistent with the meaning of the algorithm. If the human makes a scope delimiter error, C will blindly follow what was typed, not necessarily what was meant.
Holy crap, that thing is O( n^15 ) in terms of runtime! This is a perfect example of why you should use [hashlib](http://docs.python.org/library/hashlib.html) to generate your passwords instead of rolling your own. 
Nobody inspects the spammish repetition
You're missing the point. In C, if you omit a delimiter the compiler will complain. And if you position a logical block between the wrong delimiters, it's obvious on inspection, especially after applying a beautifier. Further, most modern code editors will highlight a delimiter and its opposite partner, simplifying the task of sorting out code logic. In Python you can't examine delimiters to discover that a logical block is misplaced, because there aren't any.
Nope. You need to perform a k-permutation **with repetition**. `itertools.permutations` performs a k-permutation; a permutation will never pick, for instance, "ZZb" and "bZZ" -- which this code does. I don't think Python has a built-in for repeating permutations. Actually, because of the insanely odd termination rules, this resists a one-line answer. If you call the function with `('aZb', 3, 'test.out', 6, True)`, the output will terminate at ZZZ and will never continue to the Bs. If, instead, you call it with `('abZ', 3, 'test.out', 6, True)`, it continues on. EDIT: Fixed per simtel20, thanks! DOUBLE EDIT: [Check out krunk7's one-liner above](http://www.reddit.com/r/Python/comments/kmur4/finally_a_piece_of_python_code_is_featured_in_the/c2ljs45)
You don't have a terminating element. If List=3, you must have a Z or the program ~~never halts~~ prints `|{a,b,c}|^15`, or 14 million lines.
For the curious/insane -- a co-worker &amp; I spent a few minutes figuring out what this actually does. Ignoring some odd stopping rules, this program performs a `maxchar`-permutation with repetition for the input set "wlc". For a set `{'a', 'b', 'c'}`, a k-permutation with repetition is of cardinality 3^3, or 27. Note this isn't the same as a plain old permutation; a plain permutation would never yield `{a,a,a}`, which a permutation with repetition will. I don't think Python has a builtin for a permutation with repetition. The stopping rules are baffling. If List = 1, the program only halts quickly if a 9 is in the set wlc. If List = 2 or 4, it only halts quickly if z is in wlc. If List = 3, 5, or 6, it only halts quickly if a Z is in wlc. Otherwise, all `|wlc|^15` loops are performed. Also, the halting character (z, Z, or 9) *must* be at the end of the set in order to achieve a proper permutation with repetition. For example, we perform a 2-permutation with repetition on [a, b, Z], the set achieved is: `{(a,a), (a,b), (a,Z), (b,a), (b,b), (b,Z), (Z,a), (Z,b), (Z,Z)}` -- correct, as it is of cardinality 3^2. If, however, we give this program the set [a, Z, b], the output is limited to: `{(a,a), (a,b), (a,Z), (Z,a), (Z,b), (Z,Z)}`. Totally broken. The other variables: verbose is a bool that controls whether each choice is printed, and txt is an output file where each choice is written. My co-worker &amp; I surmised that it appears to be a hopeless attempt to print out all passwords containing some set of characters -- noting that the password must always contain a 9, Z, or z, or else the program runs for a long time. EDIT: messed up the halting explanation.
&gt; I don't think Python has a builtin for a permutation with repetition. I think it does now in itertools.combinations_with_replacement()? http://docs.python.org/library/itertools.html#itertools.combinations_with_replacement (new in 2.7, though).
itertools.combinations_with_replacement() http://www.reddit.com/r/Python/comments/kmur4/finally_a_piece_of_python_code_is_featured_in_the/c2ljngc
That's just him moonlighting in a doo-wop quartet.
No. A combination with replacement is **not** the same as a permutation with replacement.
So you can throw out this kind of PoS code and get back to real work.
You don't. Not at all. Never. Ever.
I think I figured it out. Basically, you pass in a word for wlc. Each loop of the 15 nested loops is there to loop from 0 to len(wlc), basically so it can loop through the letters of the word. The reason there are 15 loops is so it can do this loop for each character in the word (but only up to strings of length 15, so watch your wlc length!), so it can concatenate the many loops through wlc back up to create all words possible out of those letters. It checks the length of the word in the innermost loop - let's call that *n* - and only uses the index values of the innermost *n* loops to do the character lookups in wlc. Basically, if you gave it the word 'cat', it would start writing out to the file: ccc (indices 13, 14, and 15, all at 0) cca (index 15 increments) cct (ditto) cac (index 15 loops to 0, index 14 increments) etc... Of course, the maxchar argument screws everything up, because while you can specify a length shorter than len(wlc), effectively clipping wlc's length to only the left *maxchar* characters, you can also specify a length longer than len(wlc), which would add in more loops, so a wlc of 'cat' with a maxchar of 4 would end up giving you combinations like 'cata' and 'ttct', and never output only 'cat' (if that matters). Anyway, we've now concatenated a string in the innermost loop. After a quick check of the verbose argument to see if it should also be printing these to standard output, it writes the concatenated word into a text file. Now we move on to Loop, an argument that can be a number from 1 to 6, inclusive. This is where my head melts a bit. Each of the 6 values for Loop is linked to a particular character. For example, a Loop of 1 is linked with a character of '9', while 4 is linked with 'z'. Before all the loops started, the code created lword, which is an array of maxchar 0s. If you give maxchar of 6, lword will be [0, 0, 0, 0, 0, 0]. At the end of the innermost loop, and let's say Loop is 1, it will fill lword with 9s (i.e. [9, 9, 9, 9, 9, 9]), then compare it to a string of the word it built up earlier in the innermost loop. Hilariously, it str()s both of these in the comparison, which does nothing. Also, it says i=0 before all these checks, but then uses i only for for-in loops, so that initialization was also pointless. Only if this check works does it set end to 1 and break its way Kool-Aid Man style out of all the loops. This is the only thing that will end this, so if you pass in 'cat' for wlc, maxchar of 3 (which would be 'correct' - wlc is 3 letters long), a List of 4, then it will write out every combination of c, a, and t to text file, then do it again more than 530,000 more times, each time writing out the same set of permutations of c, a, and t to the text file. It would not quit early, because str(['z', 'z', 'z']) (set by List being 4) would never equal str(['c', 'a', 't']), nor str(['t', 't', 't']), nor str(['t', 'a', 'c']), nor any other combination of those letters. In short, the whole thing makes no frigging sense whatsoever.
Thanks for this! Looks great, I'll let you know if I end using it for something.
I'd appreciate it if you could expand on that a bit. I'm reading the example from the link I posted: &gt; combinations_with_replacement('ABCD', 2) results in &gt; AA AB AC AD BB BC BD CC CD DD which looks like this function will, in fact, create ZZZ. However this isn't my strong suite so I'd love to have the distinction clarified. Thanks! 
Nice. Better than [my attempt](http://www.reddit.com/r/Python/comments/kmur4/finally_a_piece_of_python_code_is_featured_in_the/c2ljp4l) at decoding that monster.
As I said elsewhere, this is incorrect. P(5,2) over {1,2,3,4,5} with replacement has cardinality 2^5. C(5,2) with replacement over the same set has cardinality C(n+k-1,k), or C(6,2) = 15. A combination with replacement is not the same as a permutation with replacement.
Hmm, Although that's not the gist I got from TFA, I don't entirely disagree after being thrust into this community. It's a victim of success and gives the illusion of abstracting detail and making things idiot proof but doesn't. I think web2py does a lot better in this regard as a nice environment for bad programmers. The most alarming thing to me is how terrible the Django ORM is. Especially for people coming from something like .net or Java. These gotchas need to be better pointed out in the main project documentation. The other thing I got was that although Django is often compared to Rails, I think Django is a lot less mature and "enterprise" ready than one would expect for it's brand name recognition. Lots more gotchas than I was expecting and evolution seems to be slow.
Damn, I didn't even notice that PyQt had a commercial license... I'll try PySide then
I was wrong, sorry. I didn't notice that it was generating a whole list of passwords, and that there are some crazy-ass constraints that may or may not be significant. Anyway, making a password in a single line is easy: def generate_password(): alphabet = string.letters + string.digits return "".join([random.choice(alphabet) for ix in range(8)]) 
My thinking was that it's making passwords. It doesn't matter how it's doing it. You just need to make a good password.
That was a *terrible* example on my part, which I've now fixed. Consider `w = {a,b,Z}`. How many 2 digit strings can I make using those letters? Answer: {aa, ab, aZ, ba, bb, bZ, Za, Zb, ZZ} are all valid. Note that in English, aZ is *not* the same as Za. Order matters! But a combination means order is irrelevant. A combination with replacement will not give me both 'aZ' and 'Za' -- it'll only give me one of those. Thus we must use a permutation with replacement.
&gt; I don't think Python has a builtin for a permutation with repetition. [x for x in itertools.product(['a', 'Z', 'a'], repeat=3] *edit* More generally: func = lambda x: [p for p in itertools.product(x, repeat=len(x))] func(['a', 'Z', 'a']) *edit2* Several have noticed, the list comprehension basically simplifies to: func = lambda x: list(itertools.product(x, repeat=len(x))
Okay, I threw in a small $20 USD donation. It would be GREAT if PyPy supported Py3k.
It's no builtin, but you've done it in one line. Congrats ;-) Ah, but do note: your solution performs what the code *attempts* to do. It doesn't actually horribly fail the way this code does. Bonus points if you can do that in one line!
Very nice info. Maybe this should be in /r/django/
On python-forum.org, we had someone ask for help with their script a while ago, and they posted code extremely similar to this, saying they got it from somewhere else. Here is the thread: http://www.python-forum.org/pythonforum/viewtopic.php?f=1&amp;t=27111. In the .py file in the .zip attachment, there is a function which looks pretty much identical to the code posted. I wonder was the person who originally wrote the code in the linked article the same person who came to python-forum.org for help, or did he just rip the code from there? EDIT: [This](http://www.governmentsecurity.org/forum/index.php?showtopic=26829) appears to be where the code originally surfaced. I wonder does the guy know his code is famous...
I'm not missing the point :-P c: if(foo) bar(); baz(); python: if foo: bar() baz() the C version doesn't do what you want, but as you said, a code formatter will 'fix' the indentation. the python version just does what you want.. In my experience the only people that ever complain about indentation in python are the people who write code like def check_user(username): ok = False if activated(username): if not disabled(username): if not locked(username): if not flagged(username): ok = True else: log("flagged") else: log("Locked") else: log("Disabled") else: log("not active") return ok instead of the more sane def check_user(username): if not activated(username): log("not active") return False if disabled(username): log("disabled") return False if locked(username): log("locked") return False if flagged(username)": log("flagged") return False return True somewhat of a contrived example, but I see code like that all the time. I think part of it comes from people that were told that functions should only ever have one return statement. 
Here is a challenge if you are interested: [Problem 349](http://projecteuler.net/index.php?section=problems&amp;id=349).
ah, yeah, I knew there was something in itertools that did it
 func = lambda x: list(itertools.product(x, repeat=len(x))) 
You do if you want to perform type specific functions to a variable. For example, you can't just do: for i in list: foo.append(i) without first declaring foo: foo = [] So on occasion, you will need to declare an empty dict/string in order to perform dict/string operations later.
If you want to have some golfing fun, try to make it halt early if z, Z, or 9 isn't strictly the last character, and to run `|x|^15` times if z, Z, or 9 is not in x. How short can we make an accurate reproduction, bugs and all?
_queasy_
I recently downloaded Ninja-IDE and love it. This one looks a bit cluttered D: I'll stick with Ninja for now.
I love gedit :D I started messing with python on my linux OS, so it already had Gedit. Then I found out you can get Gedit for windows too.
&gt; In short, the whole thing makes no frigging sense whatsoever. Awesome TL;DR :D Thanks!
If I'm reading this correctly, then it would be valid to use: w = ('a', 'b', 'Z') a = itertools.product(w, w) The result is : print [ foo for foo in a ] [('a', 'a'), ('a', 'b'), ('a', 'Z'), ('b', 'a'), ('b', 'b'), ('b', 'Z'), ('Z', 'a'), ('Z', 'b'), ('Z', 'Z')] The permutation with replacement as you've described so far seems to describe the cartesian product. Am I understanding you correctly? 
You have failed by not failing hard enough. 
I think this is considered "art" in some places...
pythonistas
&gt;The permutation with replacement as you've described so far seems to describe the cartesian product. Am I understanding you correctly? For distinguishable elements in the set, absolutely. Note that given a set W, and some integer `n&lt;|W|` we can observe that `\prod_{i=1}^{n} |W| = |W|*|W|*...*|W| = |W|^n = |P(|W|, n)| with repetition`. This means that `|P(|W|, 3) with repetition` for your W is P(3,3), or |WxWxW|. It won't hold, however, for a W containing indistinguishable elements (i.e, W={'m', 'o', 'm'}), but that's likely not going to occur in this case.
I dunno, but I love the reaction from one of the participants: "Holy shit on a stick."
For Windows I would rather recommend Notepad++.
That thing is clearly identical. Now it exists in 2 places.
I tried Notepad++, but there were a few things that bothered me to death (auto-indention that used tabs, even if i was using spaces, was one thing) I recently switched over to Ninja-IDE, and I love it.
The guy is going to look into it. Why berate him? He's already gone farther than 98% of software authors.
&gt;You need to realize that **some** employers want the least expensive programmer they can hire. FTFY
It is not declaring but creating. Python cannot guess on which object you want to append ;)
Well, initializing, which was more targeted to his question, than actual declaration of type. I chose the wrong word there.
Yes I do, I am offering $300 now. 
Let's talk then, I'm free now if you are.
Okay, please add me on Skype or Aim Aim: Seasonal Skype: dino.rotyndra
haven't used AIM in a good while...but sounds good. 
Basically I was testing a language guesser and I started to run into a segmentation fault for a piece of text. I narrowed the error down to this file: http://confiles.com/download.php/1305/crash.py But the problem is that it works with some interpreters but not with others, even with the very same version r271:86832 works on ubuntu but not on mac. debian's r261:67515 crashes too, for example. So I believe the actual problem must be in the GCC version used to compile it (or flags used). Where should I report a problem like this?
For anyone who stumbles on to this discussion, go read item 2 in http://blog.dscpl.com.au/2009/10/details-on-wsgi-10-amendmentsclarificat.html This is my reasonably detailed analysis of various issues associated with wsgi.input, including this specific one, from back in 2009. Short story is that servers are not required by WSGI specification to produce an exception on a truncated read. PEP 333 version of WSGI specification doesn't have that WSGI server is required to provide empty string as EOF indicator. A WSGI application/middleware is not supposed to read more than CONTENT_LENGTH. So, it all gets very messy. PEP 3333 version of WSGI specification does make empty string as EOF indicator required. As explained in my analysis, a WSGI application/middleware had to be able to cope with that anyway.
No, you shouldn't; you should use bcrypt. Here's a [Python implementation of bcrypt](http://pypi.python.org/pypi/py-bcrypt/).
This is not a WSGI server problem. The WSGI specification doesn't dictate that an exception must be raised and returning an empty string as EOF indicator is valid even when truncated input. It is up to the WSGI application/middleware to cope with it gracefully. This has been known for years. See item 2 in http://blog.dscpl.com.au/2009/10/details-on-wsgi-10-amendmentsclarificat.html What should be tested is the behaviour of specific WSGI frameworks and applications to truncated input and how they deal with exceptions vs empty string. 
yay rss
&gt; the C version doesn't do what you want ... I'll say -- as well as being syntactically ambiguous. &gt; I think part of it comes from people that were told that functions should only ever have one return statement. Yes. Mathematicians, or people who want their code to be readable and maintainable. &gt; instead of the more sane ... A massive rationalization for a function with five exit points. The fact is that syntactical whitespace is one of Python's drawbacks. When Python programs were at most 15 lines in length, it didn't matter. Now it matters. Don't get me wrong. There is plenty to like about Python. To me personally, high productivity is near the top of the list. But the absence of block tokens represents a flaw. 
Not really -- not in a survival-of-the-fittest economic environment. No one is going to hire a more expensive programmer than the task demands. As one example, Microsoft is famous for hiring people who write incredibly bad code: [Ending Microsoft’s Cowboy Spaghetti Code](http://www.vexite.com/2005/ending-microsofts-cowboy-spaghetti-code-culture/) They had everything to lose, but they did it anyway. 
&gt; The obvious solution to this problem is to break Python code into small functions and avoid any serious dependence on structures whose complex indentation might come back to bite you. Honestly, this is the obvious solution for any abstraction in any language, so you're not telling anything new here. 100 line functions, get off my lawn!
There's literally nothing bizarre, untoward, or unseemly about multiple return statements in either Python or C. Look through the Python standard libraries. Look through the C libraries for the Linux kernel. Programming isn't a purity test, and multiple return statements are perfectly easy to read and maintain. 
I'm a tad confused by this part: qs = Orders.objects.all() # There are about 2,500,000 rows in “orders”. for order in qs: order.age_in_days += 1 # POINT A order.save() The author of the slides goes on to claim that at POINT A, all 2,500,000 rows are in memory. He goes on to explain that Django doesn't use Postgres's named cursors. Is this a postgres specific issue? At work we use Django with a MySQL database, and I know for a fact (from closely monitoring memory throughout a troublesome function) that I did not have all rows in the database at that point.
look cool, well integrated. too bad it uses the very slow beautifulsoup.
That in one line: lambda x: "".join(random.choice(string.letters + string.digits) for i in range(x)) Plus this lets you specify how long you want the password.
[Advanced string formatting](http://www.python.org/dev/peps/pep-3101) (Python 2.6+) will do that for you: class C(object): 'C' c = C() c.foo = 'foo' c.bar = 'bar' print '{obj.foo} {obj.bar}'.format(obj=c) 
&gt; Only if this check works does it set end to 1 and break its way Kool-Aid Man style out of all the loops. Thanks to you, I just went back and read the end of the function and said "OH YEAH." out loud.
Hey, at least it's NP-easy. (That is not a real thing but you know what I mean.)
Which is why kids, you should spend some time reading through the Python standard library.
You mean as opposed to a big lump of for loops squeezed into five lines?
&gt; Programming isn't a purity test That depends. How many lives are you willing to lose? [SOFTWARE HORROR STORIES](http://www.cs.tau.ac.il/~nachumd/horror.html) 
Try pygame for something like this. Hopefully someone with more experience can give you a better answer. 
Note that the above uses Appscript and *not* PyObjc. I'd definitely suggest using Appscript instead. It's very simple and there's a program ASTranslate that will translate Applescript to Python + Appscript. To install just do sudo easy_install appscript at the command line. I do all my scripting with Appscript and have for years.
&gt;A massive rationalization for a function with five exit points. def check_user(username): msg_test_pairs = ( ("not activated", lambda x:not activated(x)), ("disabled", disabled), ("locked", locked), ("flagged", flagged) ) return not bool([log(msg) for msg, test in msg_test_pairs if test(username)]) Another way to perform the same thing. One indent level, custom indents, one return statement (although the hyper-indented version uses a return variable, which is exactly as bad), and two lines (split for readability). Maintainable/extendable, at least as easy to read as the hyper-indented version, and uses only builtins. As `Justinsaccount` points out, you don't need block tokens if you don't write like a crazyman.
Don't mathematicians like haskell? Haskell code often has tons of exit points. Haskell equivalent below (adding in the logging monad left as an exercise to the reader): check_user username | not (activated username) = false | disabled username = false | locked username = false | flagged username = false | otherwise = true I found the above python clear for the same reason the above haskell is clear. Maybe if the function in question were more complicated I'd feel otherwise.
Of course, Haskell junkies might be tempted to try something like this: check_user username = and [ x username | x &lt;- [ activated, not disabled, not locked, not flagged ] ] ... which is admittedly awesome but probably less readable.
The line of i# = 0 was more along what I was thinking.
This isn't password hashing, its password *generation*. I'm presuming they would take this file and hand out the passwords one by one to users.
For that example it is a bit weird, but I do things like this all the time.. any time I realize I have a lot of repetitive if statements I try to figure out how to store the 'data' about the logic in a dictionary or list of tuples. That usually simplifies the meat of the function to a simple dictionary lookup or for loop. I forget what really popularized that, LISP? edit: so for that silly example function I would have wrote for msg, test in msg_test_pairs: if test(username): log(msg) return False return True which mostly does the same thing... I guess use of any() would be more correct in your case. I also probably would have replaced activated with inactive or something which would have made all of the lambdas unnecessary. Also, lambda x: foo(x) == foo so ("disabled": disabled) does the same thing anyway.
I don't see anything in your link relevant to our discussion. Always using a single return statement does not prevent you from making other stupid errors. 
The absolute easiest way is to just print it out on the console. the monospace font will make sure everything lines up in a grid
&gt; I don't see anything in your link relevant to our discussion. Really? You said "Programming isn't a purity test". But it is. A high level of coding discipline is required to make programs that don't kill people. Functions that have multiple exits are bad coding practice. Your reply is that they're common. That's true, but beside the point. &gt; Always using a single return statement does not prevent you from making other stupid errors. True, and a different topic. 
&gt; Haskell code often has tons of exit points. I don't know where you got that idea -- it's a principle of structured programming to have functions with one entry and one exit point. [Coding Tip: Have A Single Exit Point](http://www.tomdalling.com/blog/coding-tips/coding-tip-have-a-single-exit-point) ... [Single Function Exit Point](http://c2.com/cgi/wiki?SingleFunctionExitPoint) 
Yeah, I wish it was defined what exception was raised when a client disconnects. And the part where WSGI can't handle chunked transfer encoding still makes me sad. We've had to de-standards our apps and server to make some of these things work.
Yeah, but look at where MS is today… MS paid the price for their shortsighted coding practices. Their codebase is a mess and most of their projects are death marches to nowhere. Every single goddamn Raymond Chen blog post should come with a note at the end that says, "And this is why no matter how good of an idea it sounds like to do a quick and dirty kludge, you should not do it under penalty of death."
Well, companies have different levels of foresight, and have different strategies. For some, they believe that having better-written apps will make them more money (and thus, better programmers are "less expensive"). That's not what the OP was talking about, though.
The library's huge! I normally just Google "python [thing I want to do]" and find a library for it, standard or otherwise.
Donated $30.
They're bashing Gray Hat Python in that forum! It's such a fantastic book, i feel like they didn't even give it a chance.
I usually do that hut just skimming through the library helps me come across tools that are rather helpful from time to time. This and also the many python packages out there.
&gt; Functions that have multiple exits are bad coding practice This simply isn't true. Can you provide any documentation supporting that statement? Even PEP-8 has "good" examples with multiple exits.
As somebody already mentioned in the comments section of the blog, I wish they had a bar/counter to track the amount of money they've raised so far. I'm happy to donate $50, but if I knew that the goal was achievable/reachable I'd happily put down $100.
If you remain on python 2.7, py2exe is a great tool. The "lot of files" issue is a settings issue. In my app, everything is bundled in the .exe file (except a couple of Microsoft DLLs like gdiplus.dll and msvcr90.dll) Regarding the UI library I only have experience with wxWidgets and it works great for python 2.7 but, unfortunately, it is not ready for python 3.x and it looks like it will still be some time until an official version for python 3.x will appear. The community is great tho and its leader, Robin Dunn, one of the greatest out there. PyQT is free only for GPL apps but the commercial license is quite affordable and from what I remember, people are satisfied with Riverbank's support. PySide might be an option but with Nokia pulling the plug on financial back-up... the project future is a little bit uncertain. 
use [PyGUI](http://www.cosc.canterbury.ac.nz/greg.ewing/python_gui/) as UI lib.
If you want animation, use a wx.Timer and a buffer (wx.MemoryDC) that's updated at every step in the timer event handler. After the buffer is updated, call Refresh. In the OnPaint event handler just blit the buffer onto the wx.PaintDC. In order to draw the grid, the simplest way is to just iterate over the 2 dimensions and draw rectangles for each coordinate. Here is some code to get you started: http://pastebin.com/DP8GJYm6 I increased the size with each iteration just for fun (in that place you should compute the next iteration of you game of life or whatever. 
Just to let you know, that using QtDesigner and then manually editing the slots/signals will cause some annoyances. If you are to edit the \*.ui file and re-compile it into a \*.py, then you will overwrite the signals/slots setup. It's best to setup the slots/signals in QtDesigner itself. I'm not 100% that you said you were doing this, but it sounded like and, and if not, then it's good advise for anyone starting with PyQt.
Could you go into more detail about this, or link to something? Very interesting!
It did Langton's Ants in PyGame a while back. If you already know wxPython, it might be best to stick to that. At least then you can implement gui controls quite easily. http://willmcgugan.com/2007/5/18/langton-ants-in-pygame/
I don't remember where exactly I found all necessary information, but it took about half an hour of tweaking the sample installation script, reading py2exe documentation and searching the Internet for "py2exe dll not found" or something.
I'll look into it, I'm about a month away from release and would like to tidy some things up like that. Saves people mucking around my install, not that I'm truly bothered, it just looks more professional with just resource folders rather than dlls and other such nonsense scattered haphazardly. This is Python's only downfall IMHO.
There has to be a timing attack in there somewhere. 
From hundreds of examples: [Coding Tip: Have A Single Exit Point](http://www.tomdalling.com/blog/coding-tips/coding-tip-have-a-single-exit-point) [Single Function Exit Point](http://c2.com/cgi/wiki?SingleFunctionExitPoint)
&gt; Yeah, but look at where MS is today… Yep. They paid the price. Their initial impulse was to hire the least expensive help they could find, and they got what they paid for. 
You're right, I wouldn't recommend either one for password *generation*, but `bcrypt` is no worse than `hashlib` for the purpose. I'd rather `hashlib` never got associated with passwords at all. For password generation, you probably can't beat a passphrase, and if you aren't allowed a long enough string for that, then try picking off just the first letters of a memorable sentence or two, then doing 1337 transformations (selectively) and adding a symbol or two. That will probably get you a password you can remember while giving you decent resistance to (online) dictionary attacks. 
That's correct that the compiled *.py will always be overwritten when recompiling. I think there is a large warning at the top of the generated file. I was referring to the boilerplate __main__ script where you should designate additional slots, signals, callbacks etc... 
&gt;I forget what really popularized that, LISP? I always think of it as a result of first class functions, since it's talking about them as passable objects. I'm not sure what started first class functions, though LISP seems a likely candidate. You're right about the lambdas, I feel a bit stupid for not having noticed that. Fixed the code :) The 'any' wouldn't always work, unless `log(msg)` always returns something `True`-ish (`True`-ish is any `x` where `bool(x)` == True). Since `log(msg)` must return *something* if called (even without an explicit `return`, it returns `None`), and because `bool(mylist)` returns `False` for empty lists and `True` for all others, it basically tests whether or not `log(msg)` was called at all (and it will be only if the `if test(username)` conditional is met). So in other words, it doesn't matter what `log(msg)` returns - *if called*, it *will* return *something*, and therefore make the list non-empty, and therefore make the `bool()` return `True`. The list can only be empty if the `if test(username)` conditional was always `False`! (I also had to add a `not` there :( I can't seem to code today).
You can set all that in the QtDesigner, can't you? I've not had to explicitly set a slot/signal connection in a long time. Just using a pyuic4'd UI file and a regular old class instance of the Form, connects my functions to the widgets easily. This *is* possibly what you are saying but I've just come out of a code coma and not inhaled my coffee yet.
AFAIK you can only set the signals inherent to the widgets inside QtDesigner stage. You *can* set custom slots. Those slots have to be defined somewhere. You put your custom slots in your main. For example, someone changes a QSpinBox. You can set the signal to valueChanged(), but you can connect it to a custom slot that you define in your __main__ code, to do something else, such as disable another input. I set additional slots and signals that your ui can use. For instance, I'm using a serial connection to communicate with an external controller. I create a QTimer inside my __main__ that gets fired on each timeout. I add a signal/slot inside that __main__ code to handle the timeout (send a command from a queue in a separate thread). I may have been doing it wrong all along, but I don't think you can add a QTimer inside of QtDesigner.
There's still more demand than supply for Python programmers (at least in London and the UK). 
I've never had to use QTimer so I can't comment on that. But as far as signals go, you're correct, only the ones inherted from the class are avaliable in QtDesigner. I'm not sure how it would go for custom widgets as I've not done that either.
350GBP per Developer AFAIK.
Custom widgets aren't that bad. There is one big face palm moment that wasn't documented, so I'll mention it here in case it save someone a few days of their life. To get them to show up and register inside designer the names must be all lowercase.
Also a good suggestion. To be honest, almost anything would be better than the code shown.
350GBP means different things to different people. Some might view the cost prohibitive, other, quite reasonable. 
Definitely true.
Hm, that seems a tad weird, but it's compliant with PEP-8 so I don't mind really. I heard that you had to code a few bits and pieces in C++, is that true? My C++ is rusty but I've got a few needs for custom widgets in the foreseeable future.
No C++ at all, just a straight class reimplementation in my case. I wanted a QSpinBox to highlight the entire spinbox contents when it received focus, but for some reason the selectAll() method wasn't working inside the slot. I looked up a fix and it seems as though it is/was a registered bug. In my reimplementation, I added a few lines to the **event** method to setSelection on an 'enter' event: def event(self, event): if(event.type()==QEvent.Enter): self.setFocus() self.lineEdit.setReadOnly(True) count = self.lineEdit.text().count() self.lineEdit.setSelection(0, count) return QDoubleSpinBox.event(self, event) If you want to make more advanced widgets, you paint them using QPaint objects, etc... You need to make two files for the widget to be used in QtDesigner, one is the widget itself, the other is the plugin that QtDesigner will load on startup. The plugin is a *.py file as well. It's small and easy to configure. Just make sure it is all lowercase and the string ends in plugin.py, e.g. mycustomwidgetplugin.py 
&gt; It really isn't painful on nginx. You could add lighttpd to the list as well.
The arguments made in those article don't seem to be very applicable to Python. Here are some reasons as to why: * Python has garbage collection. This means that we never have to worry about freeing memory or destroying anything before exiting a function. * Python has constructs like "with" and "finally", which allow us to not have to worry about freeing locks or closing sockets either. * Python has exceptions. Any "raise" statement is by definition an exit point. Surely they shouldn't all be grouped at the end of a function. * Python has generators, where "yield" statements are technically exit points, which by definition occur somewhere in the middle of a function. Multiple exit points don't hurt readability either, as some articles like to claim. People read code from top to bottom, not from bottom to top. The sooner they're able to figure out they don't need to read any further, the better.
350GBP for me is about 2.5 months wages, so yeah, prohibitive.
http://bugs.python.org would be the best first start.
Ah no, I was meaning a completely from scratch widget. Not subclassing a widget, unless the process is the same?
I'd rather donate towards Numpy support. Py3k is irrelevant for me.
IIRC, to do it from scratch you'll subclass QtWidget, then go from there. There are a few tutorials out there that show you how. No C++ needed AFAIK.
Another post, sorry -- want to be sure you notice this one! If you've got it crashing on Debian, install the debug symbols so you can attach a good backtrace to the bug report. That will be very helpful.
I'll look into it further then, I was putting it off because I'd heard you needed to do loads in C++.
Thanks for the tip, I get automatically a a backtrace with it crashes on the mac (the newest downloaded version, apple's built-in works). I'll make sure I put it on the issue. My main concern is if this might be a GCC issue rather then a python issue.
You may be right. I'd start with a Python bug report first, though -- they'll better be able to file an upstream bug if needed. Be sure to post a link to the bug report. I'm curious now :)
Ubuntu 10.10, python 2.6.6 http://paste.pocoo.org/show/480529/
Also, [this](http://timdijkstra.com/word/source.php) looks related.
If an attacker is successfully executing the millions of online attempts it would take to hack a short lowercase password, the character set limitation isn't really factoring into the security (even a 5 character password chosen from a-z should take millions of attempts to guess). I don't mean to suggest that people should avoid using symbols, just that they probably don't need to focus on them.
&gt; [x for x in itertools.product(['a', 'Z', 'a'], repeat=3] Wouldn't this be simpler: list(itertools.product(['a', 'Z', 'a'], repeat=3)) In general [x for x in xs] means list(xs)
You don't know where I got the idea that Haskell code has a lot of exit points? I got the idea from [learnyouahaskell](http://learnyouahaskell.com/syntax-in-functions#guards-guards) and the [gentle guide to haskell](http://www.haskell.org/tutorial/patterns.html). The principle of multiple exit points is built into the language with several syntactic mechanisms dedicated to it. I'm well aware that there are some schools of programming that emphasize having only a single exit point, but it's clearly not the One True Path. Your [second link](http://c2.com/cgi/wiki?StructuredProgramming) actually makes my point for me. It refers to a religious adherence to single-exit-point coding as "cargo cult coding", and as it says, "In practice, what should actually be forbidden is long, run-on functions. That rule actually fixes the problems the previous rules feebly attempt to fix!" As I said, "Maybe if the function in question were more complicated I'd feel otherwise." It's really just important that your function is clear. But that haskell code is clear as a bell and completely adheres to standard Haskell coding style. IMHO, the python code above is nearly as clear.
A couple of things: * I don't trust most places to do a good job of implementing security, given the widespread &lt;20 char limits on passwords. * Lots of places *require* you to use mixed case, numbers, and/or symbols, so there's a fair chance you're not imposing any burden on yourself that the software wouldn't already impose on you. That said: I agree. If it's possible for an online dictionary attack to work, then the software is doing it wrong.
If you don't trust their security, how is a stronger password going to change anything? I certainly wouldn't share anything I considered sensitive over system I had fundamental misgivings about. I'll admit there is some middle ground around things like forum passwords (where it is a bummer to lose the account, but not a 'real' problem), but I prefer generating those and then storing them in a password safe (or on paper in a notebook) to trying to come up with anything on my own. As far as brain-dead policies, getting as many people as possible up to speed on what exactly is brain dead about them is one of the more likely ways of actually changing anything. So it isn't about the burden, it is about the thought process that says that non-random replacement is useful.
I don't give sensitive information unless I really need to, but I'd rather not lose anything if I could avoid it. I, too, use a password safe, but lots of people don't, so having a good heuristic can't hurt.
Sure. I switched from PHP to Python/Django when Python looked like a fairly obscure choice, and did quite well out of it financially. I'd be pleased if I could do the same trick again. The rest of you can do what you like :-)
If you are enough crazy: &gt;&gt;&gt; class C: pass ... &gt;&gt;&gt; c = C() &gt;&gt;&gt; c.foo = "foo" &gt;&gt;&gt; c.bar = "bar" &gt;&gt;&gt; &gt;&gt;&gt; print "%(foo)s %(bar)s" % c.__dict__ foo bar 
It seems the page has been removed.
sweet. 
[see also](https://github.com/search?q=python-github), and [my python-github](https://github.com/jmoiron/python-github) (shameless plug) Edit: You should look into using some kind of a template to setup your projects with a proper `LICENCE` file, a working `setup.py` stub, some test stubs, sphinx doc layout, etc. I like using `paster` (part of `pastescript`) to do this; I have made [some templates](https://bitbucket.org/jmoiron/paster-templates) that do just what I describe. Install those, and run: paster create -t vanilla (projectdir) And it'l ask you some questions and create all that nonsense for you.
I found in the issue tracker what seems to be the "prequel" of this issue, seems to be the same error although my interpreter is not affected by the original. So I posted it there. http://bugs.python.org/issue10254 (post msg144421)
Paid email newsletters? Edit: As in, where do you find paid email newsletters.
Not yet, but we're going to add Windows support ASAP. It seems a little hard to setup our development environment on Windows (and we also don't use Windows =/).
Hah, maybe Scala or Haskell then (or F# if you can cope with Windows). I don't think they'll see as much adoption as Python did - but they're definitely being used commercially.
lolwut?
In a real deployment environment you need to be able to control your dependencies. Depending on a third-party service to be able to deploy your own code is always going to be risky.
What is scikit?
Readings, videos, even homework -&gt; http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/index.htm 
I never needed anything besides [python.org](http://python.org) and [stack overflow](http://stackoverflow.com/). Also, you can find your way with Python just fine without OOP.
The "sample" is just a PNG image of the table of contents. Feels sketchy.
It is absolutely free.
If you're running code that requires Python 2.6, you can install it via [EPEL](http://fedoraproject.org/wiki/EPEL); which you then just have to call the python2.6 binary explicitly (since the standard python binary remains for the older version that the system requires).
The sample is an image of the first issue that went out today morning. I will add archive on the site as we go along.
sounds like the problem http://www.depot.io/ is trying to solve
I can confirm this. I did readings/videos/homework for this in the summer of 2010 and was prepared enough to work through a big project (how published) the following year. Before that I'd only done some C. edit: also, if you plan on actually making anything you should probably use Python 2.6. Lots of packages (matplotlib, pygame, pyprocessing) aren't ported to Python 3 yet. As far as learning the language there's almost no difference - most of the interesting differences are changes in capabilities you won't use in the course.
Yeah, but OP should really learn OOP for anything but the smallest projects, and Python is probably the easiest language to learn it in.
(tool)kit of sci(py): [Scipy Toolkits are independent and seperately installable projects hosted under a common namespace. Packages that are distributed in this way are here (instead of in monolithic scipy)](http://projects.scipy.org/scikits)
As a former GIS professional who is now a full time developer, would be interested to see why you think Python would help with your GIS career? 
There's also the *Python-URL!* email newsletter that has been around for a while, although it doesn't seem to come around as often as it used to. It was mostly comp.lang.python summaries.
True, but with pypi you are allowed to deploy your own servers to host your set of packages you use for your in-house deployment (or development) builds. I think the point of this article is to encourage the usage of a standardized repository of packages in order to unify the development/user community.
Assuming you're primarily interested in using Python within ArcGIS, one of the best ways to learn will be to go through a general knowledge self-paced tutorial or two, bookmark docs.python.org, and then play with the model builder in Arc. If you really only have basic programming knowledge, start with Learn Python the Hard Way (linked over there in the sidebar). Next, I would recommend [Dive into Python](http://diveintopython.org/). Don't worry about learning Python 3 right now; ESRI is still using Python 2.6 in version 10. The official documentation for Python is an invaluable reference. Make sure you have it handy. The search on the docs site is a little rough to use for the really basic stuff, but if you're trying to figure out the functions in a particular module, it's really easy to find the info you need. Do not hesitate to use Google either, as it will turn up results from both the official docs and sites like Stack Overflow that are relevant and often very helpful. Once you're familiar with the basics of the language, open up Model Builder in Arc (I would recommend Catalog; I'll explain why in a minute) and use it to build a one-tool model, then export it to a script (Model &gt; Export &gt; To Script &gt; Python...) and examine the resulting Python script. I've found that ESRI's online documentation is a little... lacking when it comes to scripting (I think they're trying to sell courses), so it's nice to see a generated script that does exactly what you need it to do. You can pretty easily make small tweaks to the script to get it to do what you need it to do, or incorporate the script into a larger Python program to leverage the capabilities of Arc. I recommend using the ArcCatalog version of Model Builder because the resulting scripts use absolute paths to the data, whereas the scripts generated from within ArcView tend to use relative paths, as ESRI assumes they will only be used from within an MXD, and it's a real pain to change everything to do what you want. Don't assume you need thorough OOP knowledge to use python in conjunction with Arc. Using the Field Calculator in 10 doesn't really require knowledge of classes (pretty much just one-liners or the occasional function), and once you look at an exported model, you'll see that it's pretty much just running a single function for each Arc-dependent item. I've written some fairly complicated Python programs that use Arc's tools, but most of the time I dump the data I need to a shapefile and then use packages like [dbfpy](http://dbfpy.sourceforge.net/) to access the attributes and [pyshp](http://code.google.com/p/pyshp/) to deal with the geometry. You may want to try working with Arc's tools for a while first to get comfortable with the language, though. Don't hesitate to ask questions here, either. You can also PM me if you'd like.
Is this a serious post? From the article: &gt; In the past, Microsoft let thousands of software engineers create their own code. As the chief architect, what Bill Gates does is filter those programs that produce the least bugs to get into the base code of Windows. Engineers would stitch those chunks of codes to create the intended program afterwards; hence, inadvertently creating spaghetti codes. Programmers literally browse thousand lines of codes if a bug pops up, making bug hunting a nightmare. What?
Look up a book titled "Python Geospatial Development". Even if you don't buy it, look through the table of contents and research the open-source software it references. I think you'll find that there is a pretty solid community of GIS programmers who use python and that book covers the basics well. Also, try /r/geospatial.
&gt; Is this a serious post? Are you married to your position? [Battling Google, Microsoft Changes How It Builds Software](http://www.site.uottawa.ca/~ssome/Cours/SEG3202/microsoftImportanceOfDesign.html) A quote: "Longhorn was irredeemable because Microsoft engineers were building it just as they had always built software. Throughout its history, Microsoft had let thousands of programmers each produce their own piece of computer code, then stitched it together into one sprawling program. Now, Mr. Allchin argued, the jig was up. Microsoft needed to start over." 
&gt; Assuming you're primarily interested in using Python within ArcGIS Why on earth would you assume that?
Primarily because I hear this sort of question (phrased similarly) at work often. Veteran users of GIS - Arc users in particular - have just started realizing that VBScript and VBA are going away at some point, and they know they've got to start learning the 'new' way. The ones who are not Arc users have started to realize that learning Python can make their jobs a little easier. I put this line up front just in case I'm way off the mark, then everybody can ignore my ramblings.
I like the idea of an edited collection of what's new in the python world, even though planet python and reddit keeps one up to date quite well. But I generally don't like giving away my E-Mail address easily. Have you considered publishing the newsletter on a weekly blog?
Looks nice!! Will try it soon.
I hate email newsletters. Why not just make it a blog and let me read it however I want ?
The problem with a predefined exception is that there is no module for WSGI, the type of the exception would itself need to be in the WSGI environment dictionary which doesn't help if that has not been passed to code where it is needed. As to chunked response content, you can do that now. A WSGI application should simply not supply a response content length and use yield to have a generator as a response. A WSGI server that supports HTTP/1.1 can then return it as chunked response where each yield becomes a chunk. Apache/mod_wsgi does this fine and I think some other servers as well. Chunked request content is a difference matter as WSGI specification doesn't allow for it due to its reliance on CONTENT_LENGTH for input. If using Apache/mod_wsgi you can however set an option to allow chunked request content to be acceptable and so long as happy to step out side of WSGI specification and ignore CONTENT_LENGTH, you can have chunked requests.
Professional just means someone's paying you. :)
The newsletter will have curated links with (very)brief summaries. An email is a better medium for this kind of weekly digest. The blog, on the other hand, is better suited for writing longer posts.
I will be adding an archive page where the past issues will be available. But the advantage of subscribing is that the information comes to you and you don't need to remember and go to the website to check for the updates.
Right, but it could be specified that something like an IOError is raised when trying to read from a wsgi.input that's been disconnected without fulfilling its content-length or without properly terminating chunked encoding. Or something, I obviously haven't thought this through entirely. Chunked request bodies are my problem. Also, that's related to raising an error and not just returning an empty string when the client has disconnected, because I need to know whether the chunked encoding was properly terminated, not just that the client disconnected. We've modified our server and code to handle all of this stuff, but it kind of means we no longer have a "WSGI" app, which has some downsides.
huh. "unify" in what sense? python's a big community, stuff that's heavily used by some groups is useless to others (django, numpy, twisted, matplotlib, lxml, to name a few). how does using pypi change anything?
The advantage of RSS is also that you don't need to remember and go to the website to check for updates. Well, that's mostly how I check blogs.
It is called whenever the window/panel needs to be repainted. This includes (but is not limited to) resize, hide/show, explicit call to Refresh. :)
I totally understand. It's about a month salary in my country. I do hope you are referring (as me) to the wages of people around you, not your own. 
Not everything needs to be a fucking blog. TBH I prefer that it's email
No, I am not. I do pretty ok for myself compared. For someone like my girlfriend who works in an 'entry tier' job, it's about that. Maybe even less. Happy cake day! EDIT: Which country are you in?
For emacs users: Rope Ropemacs Ropemode Pymacs Example at my github: https://github.com/bitemyapp/dotfiles Does better than the typical stupid ctag/etag bullshit like this module does, actually executes Python in the environment on your code to find where everything is. Can follow the origins of variables, imports, auto-complete, etc. Also, is your dev environment version controlled and automatically deployable? If not, it should be. I can sit down at virtually any unix machine and have my dev env rolling in 5 minutes. Lastly: nyan-mode is fucking awesome. Vim users should feel bereft for not having it.
Thanks! I'm from [Romania](http://en.wikipedia.org/wiki/Romania). 
Namely easy-install and other related features that fetches all the packages for a new developer who wanted to try a new framework. Instead of having to pull together packages from various separate locations I can basically specify the dependencies I need within my setup.py file, and easy-install will pull everything for me. Sure there is a single point of failure, but this issue had been raised before and can be alleviated by running a local mirror once the developer have the entire dependencies figured out. For instance, I needed some sort of OAuth handling library, first thing I do is search for it on pypi, and basically it exist (oauth2). So I have my package depend on it and rerun buildout (which uses distutils, which setuptools is a wrapper of), and I can use it in my environment right away. This makes dependency a lot easier to deal with, without having the developer to go around injecting 20 different URLs for the 50 packages s/he might have to use. Then s/he can set up a local mirror if needed be, based on those packages that was fetched earlier.
Ahh, ok. I know where Romania is. Living in Poland myself, from England originally. Wouldn't mind a visit to Romania though!
ArcGIS has a Python interface to most (or all?) of its toolbox tools.
I would start with inventwithpython.com It teaches python through creating games, which is a LOT more interesting than a regular programming textbook. It assumes no programming experience and is great for beginners. And it is semi-fun! I am in a GIS programming class at my college and just reading this and doing the tutorials has given me a huge leg up in the class.
okay, not the same guy who sends the django weekly. so i can sign up and enjoy. -- django dude is being lazy.
Oh... I was under the impression that Poland does better than Romania from an economical point of view. I've been to Poland on business at a congress in Nałęczów. Great people, reminded me of home. 
I was thinking maybe Erlang or node.js, although I'd definitely be up for learning Scala or Haskell if a suitable gig came along. Edit: and I should really pay more attention to flask and the other python frameworks.
Yep, I love it here, hence the reason for staying! What kind of business are you in?
I work as an IT guy in one of the most successful plastic surgery clinics here. :)
Interesting... and what exactly does an IT guy *do* in a plastic surgery clinic?
Google python osmosis. Great video series
I maintain the photo database (all pictures taken before, during and after the interventions). I also help the main surgeon with his PowerPoint Presentations that he uses at various congresses he attends to. I also implemented some small pieces of software to ease various tasks around here. One of them ended up being used by the main breast implant manufacturer as a tool to help doctors select breast implants. :)
The problem with this approach is that, if you follow this rule to the letter, you'll end up having code that performs badly by default. Tis better to understand the common ways to optimise up front, then you'll start to code that way by default. Eg, returning early &amp; often, getting the most common tests out of the way first with special cases later on in the code, when to use sets/tuples/named-tuples because they're more *correct* (and therefore usually more performant), etc.
So basically you're a programmer that looks at tits all day? Sounds pretty standard to me. XD
&gt;Lastly: nyan-mode TIL codename madness reached even emacs
Technically, a programmer that alternates between reddit and tits all day and while this sounds standard as behavior, there is one big difference: most NSFW links are actually quite safe for my work. :D 
Thanks for the suggestions. At this stage of development I don't mind if the project misses docs, a proper LICENSE, etc. But I will follow your adivice ASAP. My project lacks authentication, I'm thinking about how to implement some features. I'll read your code, I'll surely find interesting ideas. Thanks for your feedback.
matplotlib has a working Python 3 branch, albeit not released yet. Pygame works under Python 3, although I guess it's less well tested.
It's... beautiful... I wish my job was similar. I just got finished with a nightmare of printer problems. I *guess* printers can print porn, one can dream...
Thanks; that's some help. But your link gave an internal server error for me.
Nice try Nigerian spammers! */subscribe*
At work so can't watch the entire thing, can someone summarize?
If you want something to practice with, register for http://projecteuler.net/ and solve some of the puzzles. One of the benefits is that when you have a correct solution you can see how others have solved the same puzzle.
Wait.. You claim to have knowledge of Java yet know nothing about OOP? How the heck did you manage that?
Regardless of whether the OP is looking at ArcGIS or another solution, Dive Into Python is a good guide for programmers coming to Python from other languages.
I've not read it myself, but a non-developer I know told me he enjoyed ready [A Byte of Python](http://www.swaroopch.com/notes/Python) which is available in print or free in PDF form, much like Dive into Python (that another commenter already mentioned). 
To get started, this [google's python class](http://code.google.com/edu/languages/google-python-class/) as the name says, is really one guy from google teaching you python. It will show you some of python basic structures, some basics of the syntax, and a few libs and get you doing some practical stuff. also, it's not very long! but, you won't see much OOP in python in this. 
GeoDjango makes building a mapping system much easier as well.
I'm not so sure that the WSJ really understands how software is built, or that their metaphor is meant to be taken seriously by those who do. It's quite a non-sensical statement that the software was "stitched together into one sprawling program".
Upvote for Dive Into Python.
Not necessarily. If you're mainly doing scripting, you don't really need OO at all. In fact I'd go so far as to recommend newer programmers get as much experience with procedural and functional programming first, before even going into OO.
FYI, you may want to start with a shorter title and put your question(s) inside the post.
His assumption is right. I am insterested in using python within ArcGIS. Thanks WhyCause for your answer.
I'm finishing my degree in a few months and while looking at job opportunities I've seen that many GIS-related jobs ask for some programming knowledge
You could, like, start by reading the sidebar?
Java (&amp; C#) are the most OO mainstream languages ever... It would be near impossible to code in Java without, at some point, dealing with some of the OO principles. Otherwise why waste performance with a VM language and not code in C?
Yes please post an archive. I don't want to subscribe (I get enough emails as it is) but it looks like you've got some excellent content.
I'd just like to add that Thinking in Java by Bruce Eckel is fantastic for learning OOP, and java syntax. Since you're somewhat familiar in java, it would be ideal for the OOP side of things. It's very well organized, and easy to skip the parts primarily about syntax and just read the OOP parts. The concepts are easily translated to other languages, like python. I'd also like to mention WhyCause's post is great, def. do what he suggested.
No problem, I hope it helps.
Turbo Pascal? People still use that? Does Borland even exist anymore? Edit: Yes they do, but no compilers.
Good point. Not everybody needs OO, and you can code functional-style in Python and feel good :)
shift + f2, non-problem
&gt; the money is calculated considering a hourly rate of $60 Is that what a typical (experienced) developer makes?!
agreed I'm actually enjoying email newsletters again, as long as they are only once a week.
In the US at least it's lower than what a good freelancer can make.
[Nyan-mode, created by the pimpest dude in #emacs on Freenode.](http://nyan-mode.buildsomethingamazing.com/)
Wow, okay. $110k+/year is pretty damn good either way.
Well, in the US at least freelancers take home pay need to be computed differently from a salaried employee. This is because they pay self-employment tax themselves, they have less job security, and they have to pay for things like health insurance out of pocket, rather than have it from the employer.
If anyone is trying to use the windows package and gets an import error, see this: https://github.com/scikit-learn/scikit-learn/issues/359 EDIT: the problem has been fixed. New win32 binaries are available: http://pypi.python.org/pypi/scikit-learn/0.9
if you make 60$/h every now and then you don't come back home with $110k/year, period. There is also a lot of volunteer work that goes on in PyPy that noone would pay for, like bugtracker gardening. Also a 1/3-1/2 is taxes, depending a bit where you live, so it's way less. I guess personally I would be happy to take $40k/year home and yes, at $60/h.
Nice! As a recommendation for Phase 2, try Beets to organize your audio directory. http://code.google.com/p/beets/wiki/GettingStarted
Wouldn't using mimetypes make more sense than a hardcoded list of extensions? Also, "==False"? Yuck.
You still have to group the mime types into whatever folder you want to separate things into, eg a torrents directory. I don't program python a whole lot, so 'not f()' usually doesn't pop into my head.
usage: [vimeo](http://vimeo.com/29503670), [mkv](http://www.jimmyr.com/sort.py.mkv)
Most GIS related jobs will use ESRI products, most embedded tool development is done with .NET or VBA (shudder), most web development done with .NET or Java with interfaces in either Flex or JS, and most geo processing done with Python.... After all that...whats your level of relational database experience/knowledge?
Oh, hey. I discovered Reddit through your site. This is pretty cool, I should make something similar in bash.
If I place this script in the same directory as the directory that it is sorting, will it sort itself?
Also no reason to use "!= None" (unless you're specifically trying to distinguish None from another false value, which you're not), just take it out. Edit: btw, you can also omit a .keys() when you're iterating over a dictionary. That's what you get by default when you say "for k in d" (where d is a dict :) Final edit: Just a style thing - almost never "save a line" by doing stuff like "if foo: bar" as you're doing. Of course it doesn't matter for your quick script, but since you said you don't do much Python I'm just offering some of the community's "standard practice" rules you should generally follow.
Fair enough. I just know that when I was first learning to program, I did some decent size projects in a functional way and then later realized how much more easily they could have been done using OOP. But it depends on the project I suppose.
J-Jimmy? Off topic, but I used to love your videos. I'll check this out. 
My experience with relational databases is almost zero. A few years ago at a job I used make/manage small databases in MS Access... quite basic stuff
One of the nicer things in the Python community is code style consistency. [PEP 8](http://www.python.org/dev/peps/pep-0008/) is used for the standard library and although that's not necessary for user code, it's a nice guide nevertheless. One of the things it recommends is to avoid comparing boolean expressions with True/False. ;) Your script works and that's what counts, but here are some tips anyway: * Use `os.path.join()` for path concatenation instead of adding them together. This way you won't have to worry about missing or duplicate path separators in each part. * Use `os.path.splitext(s)[1]` to get the extension. Before comparing it, use `os.path.normcase()` to convert it to the proper case instead of always using `lower()`. This will handle the case sensitivity difference between Windows and Linux. * I prefer to always use `'/'` in literal path strings. Windows accepts them just find and you can use `os.path.normpath()` if you want to convert them to the native platform format (e.g. for displaying). It looks cleaner and, on Windows, it avoids the need for escaping the backslashes or using raw strings. You could also speed up the `grouping()` function by splitting the extension strings once at the start of the script and using `'in'` instead of `count()` to search for a match. `count()` has to test all elements and although it doesn't matter for such a small number of items, it's (again) a matter of style. EDIT: Also, the special Windows folders like the desktop and My Documents and localized and therefore you need to use a special function to get their real names if the system language is not english (in greek, for example, they are called "Επιφάνεια εργασίας" and "Τα έγγραφά μου" respectively). One way is to use `shell.SHGetFolderPath()` from Mark Hammond's [pywin32](http://sourceforge.net/projects/pywin32/), which every Windows Python user *should* have installed. Oh, and Keith's suggestions are also great.
What screen cap software do you use on Ubuntu? It seems to work really well. Also, nice little script.
yes. but, you can add to _ignore=[('exact','sort.py')]
Thanks for the tips. For safety, I'm not going to push any changes until the link gets a bit more stale. 
ffmpeg's x11grab 
Thanks for reviewing the code. edit: I'm not understanding how I'd benefit much from os.path.splitext(s)[1]. Just setting it to lower seems to be easiest. I wouldn't know how to add the pywin thing conditionally.
The point is that if it's a blog, you can read it via an email subscription, as well as via Google Reader, Thunderbird, the web, etc.
you can use something like os.path.split(__file__)[-1] to automatically add the script to the ignores.
For unix/linux you can just use os.environ.get('HOME') which should return the correct homedir for the given user. No need to do concatenations with the user name.
Isn't there a method in is.path that returns the users home directory? What happens if a user doesn't have that enviroment variable!
hey jimmyr! I love your site. It's my homepage! It's good stuff. I use it all the time. It actually led me to reddit, and for that I thank you a million times. PS: Nice script. It's a good idea! Much respect, Jnaranjo.
os.path does not have a function that returns the current users home directory. I don't remember ever having been in a unix/linux/osx environment where $HOME is not set. However, if you want to go bare metal there is a function in the pwd module to look it up directly from the password file. import pwd,os home = pwd.getpwnam(os.environ.get('USER'))[5] http://docs.python.org/library/pwd.html#module-pwd
This is way cool!
I made a library organizer[ a while ago](https://github.com/shadyabhi/pLibraryOrganizer) but this one does a lot more.