&gt;Try evernote.com Apparently they don't have a Linux version
La vache-qui-ri?
I really, really hate the state of Python packages right now.
Ah! Peter Krumins of catonmat? The video lecture physics and maths guy? Nice!
Reading this reminded me of recent events that just makes me want to cry.
Agreed. It is kinda awful. I wish I was a good enough coder to fix the situation myself. The current installation of packages is made of misery and pain.
So I took a glance here and I'm not sure I like the verbosity of the code. You're writing Java in Python with all of these getters and setters, and I'm not sure that's desirable. It also seems like you should be able to simplify portions of the logic and eliminate some of the state.
How to swap these variable values using one line of code? x = 10 y = 20 Answer: x, y = y, x
[List comprehensions and map](http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Loops).
You're spouting utter nonsense. Did you mistakenly comment on the wrong thread?
That's cute!
You can reverse lists as easy as list[::-1] 
Metaclasses &amp; descriptors if you have cards for advanced stuff. The most common modules (pick them up from PyMOTW) would be a good idea (os, itertools, re, logging, collections, ...) args &amp; kwargs of course, and positional/default/named arguments The general structure of a function/class/module including the importance of docstrings and their use as doctests. `__new__` and `__init__` and why you'd want to define `__new__` for your custom objects. Also a few other magic methods (the operator ones aren't really useful, but `__repr__`, `__str__`, `__unicode__`, `__getattr__`, `__setattr__`, `__delattr__`, `__getattribute__`, ... are interesting) if you're not limited to Python 3.x, "classic" classes versus "new-style" classes context managers and the `with` statement first-class functions and higher-order functions (`map`, `filter`, `reduce`, some of the stuff in `itertools`) generators (and their usage as data pipelines, see David Beazley's presentations/tutorials on the subject) and iterators
Hash tables being used as switch statements--A number of people new to Python miss that part. For example: def foo(): ... def bar(): ... table = {"a":foo, "b":bar} ... and now if I have a function that returns either "a" or "b", let's call it baz, I can do: result = baz() table[result]() as though it were a switch statement. Also, I might include a section on the regular expressions module. Mark Pilgrim's chapter on that module finally made its utility click for me. 
sorted(list, reverse=True)
um, doesn't that also sort the list?
Oh yes, for some reason I have associated "reverse" with reverse sorted. I have **no** idea why I said that now. It's 4:15 AM :/
&gt; You're spouting utter nonsense. Did you mistakenly comment on the wrong thread? Sadly, no :^) Well, there's not *that* many getters and setters, but &gt; def indent(self) : return self.indent_ def set_indent(self, x) : self.indent_ = x def last_line_length(self) : return self.last_line_length_ look suspect to me. Also, line 96-97 &gt; def xregister(type, converter) : &gt; _converters[type] = converter 'type' is a built-in, so you should probably rename that.to avoid redefining it.
For the one that states "three variables x, y, z, initialize them all to 0 on one line", another possible solution is x,y,z = 0,0,0 although the current solution of x=y=z=0 is shorter, showing the alternate form with tuple unpacking may be nice.
Iterators and ways to get and create them, including `xrange` (`range` in Python 3), `sorted`, generator expressions, `yield`, and pretty much everything in the [itertools](http://docs.python.org/library/itertools.html) module.
`reversed(list)`
Not sure if it work, but why isn't x,y,z = 0 the "standard".
&gt;Forbidden &gt; &gt;You don't have permission to access /~btolbert/flash-cards/python.htm &gt;on this server. Accessible web page for starters.
Sorry, I was FTPing new content and my neighbors wifi crapped out on me. It's back up now.
Because in python x,y,z is tuple unpacking notation. It's easier to understand the significance with a more advanced example. Tuple unpacking allows this: a, (b, c) = (1, (2, 3))
x,y,z = 0,0,0 is also better because x,y,z = [],[],[] is exactly analagous, but x=y=z=[] is not exactly analagous to x=y=z=0.
great stuff. Im a python noob, but I was able to answer a few and learn a lot
The split/sort/join: x = ','.join(sorted(x.split(','). key=lambda s:s.lower())) "How to make n copies of the elements in a sequence and concatenate them?": list * number doesn't copy the items, you end up with n references to the same item. You seem to be targeting python 3, which may be unwise given that it isn't in widespread use yet. At least point out the differences from 2.x.
Good call! The difference between x,y,z=0,0,0/x,y,z=[],[],[] and x=y=z=0/x=y=z=[] seems like a good elementary interview question.
What the fuck is Leo, and why do I have to read through a full tutorial (which requires me to install it) before I find out what it does? No offense, but you guys need to get your stuff in order before you start pushing your software to the public. 
Can you make an Anki file out of those?
That's a far cry from calling it "Java in Python". And in xregister, lexical scoping ensures that the global 'type' built-in is not redefined.
Hm, I like using the idea of using the `with` statement.. Simple, if convoluted implementation (couldn't just monkey-patch `__enter__` and `__exit__` methods onto the `_sre.SRE_Match` object): #!/usr/bin/env python2.6 import re class SRE_Match_Wrapper: def __init__(self, match): self.match = match def __exit__(self, type, value, tb): pass def __enter__(self): return self.match def __getattr__(self, name): if name == "__exit__": return self.__exit__ elif name == "__enter__": return self.__name__ else: return getattr(self.match, name) def rematch(matcher, inp): return SRE_Match_Wrapper(matcher.match(inp)) if __name__ == '__main__': theregex = re.compile("(\d+)g") with rematch(theregex, "123g") as m: if m: print(m.group(1)) with rematch(theregex, "123") as m: if m: print(m.group(1)) It would be nice if there was a way skip the execution of the code block from the `__enter__` function, say by raising an exception and catching it in `__exit__` - this would mean you could do.. theregex = re.compile("(\d+)g") with rematch(theregex, "123g") as m: print(m.group(1)) with rematch(theregex, "123") as m: print(m.group(1)) # would never be run, because it didn't match ..but the with statement basically does `__enter__(); try: [run code block]; except: __exit__(*exception_detail); finally: __exit__(None, None, None)` *Edit:* asked ["Alternative to the match = re.match(); if match: â€¦ idiom?"](http://stackoverflow.com/questions/1152385/alternative-to-the-match-re-match-if-match-idiom) on StackOverflow
Interesting that the book is thinner than the 3rd edition and covers 3.0 new features..
Upvoted for neighbor's wifi.
That's not really true. x = y = z = 0 and x = y = z = [] do the same thing. In both cases x, y and z end up referring to the same object. The difference is that the list object is mutable - you can append items to it - while the int object '0' isn't. 
I really like the trick of using zip(*seqs) to transpose a list of rows into a list of columns - it always seems to come in handy when I'm slicing and dicing a dataset.
Best list of Python tricks and treats: http://stackoverflow.com/questions/101268?sort=votes#sort-top
decorators
Amazon shows the 4th edition to have 744 pages and the 3rd to have 648 pages. Must be thinner paper.
Never really caused me much pain - easy_install works great for *many* use cases (unless you are fighting against a system package manager). Fortunately Tarek Ziade is well on the case for a comprehensive fix that will be in the Python standard library.
Very nice. 3rd Edition has been such a great reference. I'm sure I'll pick up 4th, if only for the new library module references.
wing ide + ipython
I'm new to these languages, but understand some of the differences. Could somebody explain it? Does it convert python code into valid c++ code? or compile a python program as an exe or whatnot?
easy_install does work for the, i'd say, 70% use-case, but i've been stuck with the 30% use case for weeks now and its PAINFUL. augh.
Great example. Sometimes this is also implemented as the "command dispatch" design pattern with a class and methods. For example: class Command: def foo(self): ... def bar(self): ... command = Command(...) so that you can say result = baz() getattr(command, result)()
is the only place to get this amazon? the author doesn't sell it himself?
Ah, reddit. Your magic amuses me always.
Is this correct? &gt;Given a list: &gt;L = [10, 44, 29, 30, 12, 99] &gt;What is the simplest way to reverse the order of the elements? &gt; L[::-1] &gt;[99, 12, 30, 29, 44, 10] &gt;S[i:j:k] returns the elements of the sequence from i to j using step size k &gt;using -1 as the step size and omiting i and j will step through the entire &gt;list in reverse, thus reversing the list. 
I'd appreciate an elaboration!
Would it be possible then to compile a Python module into a C++ module that would be used in Python?
This reeks of sleeze and I want nothing to do with it.
I wasn't aware of bpython. Thanks. Does it work with Python 2.6, specifically on Ubuntu or Debian? I searched through the aptitude database and found no packaged version of bpython.
I just started using Anki and it is awesome! I was looking for something like Anki before I made these cards. I made an Anki deck version of the cards and shared them. I think you'll need the latest version of Anki to download shared decks. Go to File -&gt; Download -&gt; Shared Deck and search for "python". 
[incron](http://inotify.aiken.cz/?section=common&amp;page=news&amp;lang=en)
How does this book help beyond the [Python documentation available online](http://docs.python.org/)? I've personally found that documentation to cover what I need 99% of the time.
&gt; It relies on inotify (so you're stuffed on OSX and Windows) It could be made to work on Windows with win32file.ReadDirectoryChangesW (via pywin32). There's also a simpler API which doesn't return path names (win32api.FindFirstChangeNotification, etc).
To an experienced programmer, nothing. 
You can download the source [here](http://www.bpython-interpreter.org/releases/bpython-0.9.3.tar.gz). If you want to be able to uninstall it later, or upgrade etc, I would use [checkinstall](http://www.falkotimme.com/howtos/checkinstall/) to make a .deb package.
Very much appreciated.
It's a command-line tool... why would the language matter?
OS X also has a [similar feature](http://developer.apple.com/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html). AFAIK it was introduced to support Spotlight indexing. It's a pure C API, so it should be accessible via `ctypes` or a C module.
Thanks for spelling it out. I knew someone would take issue with that description, but I didn't want to write it out in detail. But someone could also take issue with your claim of both statements "do the same thing." Assigning a mutable variable to x, y, and z could be described as different from assigning an immutable variable to x, y, and z.
Maybe this helps, from http://code.google.com/p/shedskin/ &gt;Shed Skin is an experimental compiler, that can translate pure, but implicitly statically typed Python programs into optimized C++. It can generate stand-alone programs or extension modules that can be imported and used from larger Python programs. 
Ooh, I missed that. Thanks!
i thought inotify had scaling issues?
It's worth mentioning the [random module](http://docs.python.org/library/random.html) in Python's standard library also has many of the same distributions (plus the very handy sample() function), and so does numpy.random. But neither have a multivariate gaussian, which is a pity since it's so useful. Fortunately it's easy to write by yourself.
Well certainly, having multiple names for a mutable object can be confusing if you're not expecting it. But that's independent of the fact that assignment really does the same thing in both cases. This is a good description of the details of Python assignment: http://effbot.org/zone/python-objects.htm
You can get this at roughly the same speed (~5% slower) in python3 using a writable closure instead of object attributes: class D(object): def __init__(self): counter =0 def iterator(): nonlocal counter while True: counter += 1 yield counter def skip_to(i): nonlocal counter counter = i self._iter = iterator() self.skip_to = skip_to def __iter__(self): return self._iter You can do something similar in 2.x using a mutable attribute (eg a list with 1 item): class E(object): def __init__(self): self._counter = counter = [0] def __iter__(self): ctr = self._counter while True: ctr[0] += 1 yield ctr[0] def skip_to(i): self._counter[0] = i Though this is ~ 50% slower than the pure generator (only slightly faster than looking up self.counter each time, so that's probably a better tradeoff towards clarity)
I've found incron meets most of my needs in this regard.
Let me clarify - i thought something like 50,000 systemwide files was the upper (practical) limit, beyond which behavior was slow and/or erratic (someone confirm?). http://inotify.aiken.cz/?section=inotify&amp;page=why&amp;lang=en
Stackoverflow.com
I did some tests on my laptop with Python 2.5 ([source](http://pastebin.ca/1502058)). Nowhere _near_ 10x. Not even 2x. Test A: [0.07210898399353027, 0.07202601432800293, 0.074321985244750977] Test B: [0.13190889358520508, 0.12493300437927246, 0.11867594718933105] Test Bs: [0.10193395614624023, 0.10321402549743652, 0.10258102416992188] Test C: [0.12236809730529785, 0.12155818939208984, 0.12049102783203125] Test Cs: [0.10871696472167969, 0.10567092895507812, 0.10702085494995117] `Bs` is just `B` with \_\_slots\_\_ added, same for `Cs`. I get similar results with Python 2.4. _edit: syntax, shaved a digit off the end_
interesting, I would have create a new iterator each time (but all based on the same list). too lazy to test if iterators creation is costly.
Yeah, they do seem much smaller difference than he claims, though I get a slightly larger difference than you. I assumed it was some version / environment difference (64bit linux, python2.6.2/3.0.1) For the record, here's my test data, using the below code: for x in 'ABCDE': print("%s : %.3f" % (x,timeit.Timer("for x in X():\n if x&gt;10000: break", "from __main__ import %s as X" % x).timeit(1000))) Python2.6: A : 4.759 B : 11.638 C : 7.269 D : (requires 3.0) E : 6.493 Python 3: A : 5.073 B : 12.688 C : 7.631 D : 4.988 E : 6.676 A and B are from the article. C is the version from the comment by zacharyvoase. D and E are as above. 
Its not that it's costly, it's just that it will have the same effect. The object here is acting as an iterator, rather than an iterable, continuing from the point it left of (or called skip_to on), so using the same iterator seems most sensible. Recreating the generator means I'd also need to recreate the `skip_to` function, as they close over the same variable. 
OK. Thanks. Will try it.
For the record, I'm on 64-bit Linux too (Ubuntu), Intel Core 2 laptop. On a FreeBSD 7 64-bit AMD Opteron server, Python 2.5: Test A: [0.063178062438964844, 0.064404964447021484, 0.06418299674987793] Test B: [0.10109496116638184, 0.10071802139282227, 0.10112309455871582] Test Bs: [0.099486112594604492, 0.092070102691650391, 0.093844890594482422] Test C: [0.10436487197875977, 0.10428977012634277, 0.10418009757995605] Test Cs: [0.10584688186645508, 0.10585188865661621, 0.10960197448730469] 
Similarly, I can't imagine conservatives not considering their idea of family as nurturing. Family values are all you ever hear them talk about.
github runs on rails
When they're not "hiking the Appalacchian trail," that is.
There's nothing more important than keeping the appearance of a perfect family while you're out trolling for male prostitutes.
http://sourceforge.net/project/screenshots.php?group_id=3458
There's an online tutorial.http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm
Would have be a lot better as just a web interface to latex.
I'm in a C# class right now, and I've spent pretty much the entire time looking into IronPython. Does anyone use it? Or the IronPython Studio? I get the feeling that a lot of working in IronPython would be fiddling with workarounds to get .net working.
dont we already have enough issues without python packaging without throwing another tool into the mix? unless this tool is going to be the tool to end all tools...
Damn.. I just want something called 'install': &gt; &gt; &gt; install BeautifulSoup Just that. :(
 juri@dhcp232:~$ install BeautifulSoup usage: install [-bCcpSsv] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner] file1 file2 install [-bCcpSsv] [-B suffix] [-f flags] [-g group] [-m mode] [-o owner] file1 ... fileN directory install -d [-v] [-g group] [-m mode] [-o owner] directory ...
:O
`pip install beautifulsoup` though you're probably better off using lxml than bf until the issues with bf 3.1's parsing are resolved (that, or stay on 3.0.7)
I find the first snippet to be quite unreadable for such a simple task :/
It's not really much different to the original. The only differences are that the functions are now defined within a closure inside `__init__`, rather than directly on the class, and the addition of the `nonlocal` declaration for the closed over variable.
I wish we had one tool too. And trust me, the fork is not done for fun :/ read this previous blog entry : http://tarekziade.wordpress.com/2009/07/19/the-strange-world-of-packaging-forking-setuptools/
What's with the tiny font size?
I wasn't judging the cunningness of your snippet but rather the fact that it didn't look straightforward to me. That being said, once I stopped for 5 more seconds, I was really please to see you could do that with Python3k :)
Decoupling retinas.
\*points and laughs at the django\*
In brief: the fork's done to have a truly community-driven setuptools project so that important bugs can be fixed and progress can be made. On a parallel effort there's work being done in separating the installation metadata story out from the tools (distutils, setuptools), so that multiple tools (including OS-level packaging solutions) can all share this data. 
heh sorry about that. I blame my fall back CRT monitors. Never did notice, until you mentioned it, and I verified on my work LCD. Strangely enough though I had to change the syntax highlighting plugin too. I didn't like how it was scaling the code font, the new one seems much better. 
Why?
He's probably a railsboy.
See, this whole mess of affairs has me confused. I thought the whole point of FOSS was that you should be able to fork at will; that if you did and there were political issues, the most technically sound version should win. That doesn't seem to be what's happening here; instead, it seems that the current maintainer just didn't do anything, and the problem was not routed around, so to speak.
This is the community routing around the problem.
You're right, of course. I suppose the 9 months of inactivity is what confuses me.
I think that the attitude/culture of the two comes more from the pace of development and enhancements. Java users are crying out to have their language fixed. In the mean time they have created some awesome tools and libraries to resolve some of the shortcomings. Meanwhile MS is moving C# at the speed of light in comparison. Most .Net developers I know are excited about the innovations coming out of the C#, VS and peripheral teams (Entities, MVC etc) This means that they are happy to wait and see what MS will do next. Out in the open source world (Python, Ruby etc) you have to get involved and have a voice, otherwise the movement, language, project or whatever will stall and not get used or progress. This has a greater effect on the community mindset than the perceived strictness of the 'father'.
&gt; SyPy FtFy
This is a great tool. Thanks for posting it!
It's python, you can do it. Furthermore, *you* can define what it means in context.
Oh trust me, personal projects from now on will have \_\_thunder\_\_ easter eggs throughout.
Thunder thunder thunder cats!
What would it store
Sorry, that's reserved for [Storm](https://storm.canonical.com/)...
Join us next week, when it's the Haskell programmers turn to post drunk.
pylons.
Voted for logging.
Thunderhorse. Thunderhorse. Thunderhorse. Thunder. Horse. Thunder. Horse.
And if you don't want to install any part of OOo (pyuno) you can use xlrd/xlwt -- as I'm doing now.
&gt; loosing developpers Something doesn't sound quite right, but I can't put my finger on it.
Loose as a verb = release (let loose) developpers = obviously a typo for devil poppers, i.e. dogs. So what he meant to say was "release the hounds!"
I think during that time patches were submitted and the hope was that Phillip would give more developers commit rights. In the end Tarek gave up and created this fork.
The date and time-related modules, and anything related to building or deploying. The urllib-related modules dont need an outright redesign, but some kind of consolidation would be nice.
why cant it be called "ohpyo"? 
Pretty much anything to do with the web or mail. I'm quite surprised a third-party 'www' package that does things sanely hasn't become hugely popular yet.
Why don't you post your code somewhere? You might get more help this way...
Well, subprocess.Popen gives you a file object for the process's stdout, and I think you can just read bytes from it with readbytes oor something.
 &gt;&gt;&gt; import subprocess &gt;&gt;&gt; output = subprocess.check_output(['ls']) &gt;&gt;&gt; type(output) &lt;type 'bytes'&gt;
Regarding Python3: The subprocess module needs to die a terrible death and the popen functions need to go back into the os module. Python3 removes the os.popen2 function. Now, instead of using a simple function (popen2!), I now have to use the overengineered 'subprocess' module. Before: # python 2: child_stdout, child_stdin = os.popen2("somestring") After: #python 3 p = subprocess.Popen(["somestring"], shell=True, bufsize=bufsize, stdin=PIPE, stdout=PIPE, close_fds=True) child_stdout, child_stdin = p.stdout, p.stdin Do not make me instantiate a class when a *simple* function will suffice. Do not make me use a complicated function when a *simple* function will suffice. 
Exciting news! Except it's too bad Packt always uses abstract photographs for the cover art, it'd be awesome to have the ME GROK! caveman on the cover.
+1 date/time modules, datetime sucks.
So, it's like.. grokking Grok?
First day was good, looking forward to the talks on sunday the most though.
First day was indeed awesome. For a small regional conference it really pulls in some great people, I only ended up going to 1 talk today (my own ;) ) + the lightning talks. I spent the rest of the day hanging around, discussing Zombie invasions, scaling databases, and dragon fetishes.
&gt; One of his remarks was (I paraphrase) that Microsoft users want to be told what to do, while the Java community is more vocal or argumentative. (He didn't discuss the Python community but in my experience it falls in the latter category.) [sure](http://www.google.com/search?q=%22guido+rejects%22+python)
Yeah, *it's enough for you* therefore *it's enough for everybody*. Seems logical, write a PEP.
Linode VPS is kickass.
Nice, I was looking into this over the weekend. XulRunner + python looks to have a huge amount of potential for rich clients IMO
I agree, code completion on PyDev really suck. But the awesomeness of Django and Python both makes such stuff seems trivial. At least to me. Then again, I would love to have some awesome code completion. FYI, auto-import is available if you have PyDev Extensions, which is not free. Pfft, right?
Komodo Edit has pretty good code completion for Python.
Have you tried using Python's interactive interpreter? I do most of my Python development in ipython (an improved version of the standard Python interpreter) - so in place of IDE auto completion and docs, I'm constantly interacting with my code "live", checking to see if things work, calling help(some_function) to see inline help on methods and classes. Using ipython, tyying "os.&lt;TAB&gt;" will show you all available properties of the os module, tying os? will show you help and typing "os??" will show you the module's source code. I've never really got the hang of IDEs, but I find that interactive development in a REPL makes me extremely productive. I do the same thing in JavaScript using Firebug.
Have you tried WingIDE, it's great for Python code completion. haven't test for Django yet.
&gt; What should I do, just go back to switching back and forth between documentation and the text editor? Yes. You don't type that much with python. Eventually you'll get used and code completion won't be a big deal.
Komodo Edit
i admit that I need to learn the interpreter better. the concept of an interpreter is a little foreign to me coming from the .NET world but I can certainly see how it would speed things up...
I really liked WingIDE, but it seemed slow and a bit laggy on my 1.6Ghz Core 2 Duo machine (2Gb RAM). Other than that, it's the type of IDE that I could see myself paying for.
Stani's Python Editor still any good? I use vim so I don't know.
Did you try the pro version, for some reason this seemed far more responsive to me than the personal. Also seem to recall that on windows pyscripter handled code completion pretty well, though never tried it with django.
[bpython](http://www.bpython-interpreter.org/) is an interactive interpreter that has really great code completion. It won't replace your IDE, but it is a really handy tool that will complement it well
And the APIs are usually not that complex. The problem with Python is also, that the code can't be statically analyzed completely, since you can add attributes at run time or intercept others and are free to return any type at any time. I do see a point for Java, but I don't miss it for my Python or C projects that I write.
I use WingIDE for my Django development work every day. The auto-complete works very well. You can even get the python shell window in WingIDE to import all your Django project paths. Another neat thing is that you can hit Ctrl+Left-Mouse-Click on Djago code and it will bring up the Django source code of that exact function you clicked on.
use the most powerfull code editor, vim :) with this in your .vimrc file: function! SuperTab() if (strpart(getline('.'),col('.')-2,1)=~'^\W\?$') return "\&lt;Tab&gt;" else return "\&lt;C-n&gt;" endif endfunction imap &lt;Tab&gt; &lt;C-R&gt;=SuperTab()&lt;CR&gt; and you get a really heavy autocompletion with the key Tab :) 
+1 for Wing. I also came from Visual Studio. Step through debugger, ctrl-click to go to definition, debug probe window. It's wikkid. Had to cashmoney for it in the end, but it let me just request a new trial key for about a year.
I'll give it a try, thanks.
I tried using it but I couldn't manage. Seems buggy and outdated.
Unfortunately, I don't remember which version I tried. I should probably give it another go, though. I remember really liking how much of it was tweakable (and the code completion was great).
I hadn't noticed. I generally use text editors with code highlighting to do most of my Python dev. &gt; What should I do, just go back to switching back and forth between documentation and the text editor? That's what I do. If you hadn't brought it up I might not have even noticed that.
The syntax on Python is pretty light as-is, so you're not going to get much help with code-completion. For docs, Pydoc is the essential reference tool for Python programmers: just type `pydoc module.function` for full documentation. However, I'm not sure how to invoke pydocs on Windows - I think it might be available through a help style GUI. I'll also take this time to plug GVim as a nice transition from a graphical editor to a real editor. Also, when you're in the interactive interpreter, `dir` is your friend. It lists all members of an object/module: `dir(os)`. These days, programming python in anything besides vim is downright painful. 
are you really learning anything if you can't program without hints? It's probably hurting you more than it's helping right now.
Yes, bpython has better code code completion than ipython, though ipython does have some nifty features (mostly their 'magic' commands that start with %) bpython lacks. Anyway, both show that decent code completion is possible with python.
what about eric4?
SPE and Eric4 may be nicer solutions.
That's an interesting approach. Though two other ways to get autocompletion witn Vim should be mentioned: built in omnicompletion, sort of the 'default' since vim 7 ([vim tips](http://vim.wikia.com/wiki/Omni_completion) has some pointers) and omnicompletion with [PySmell](http://code.google.com/p/pysmell/). The former kind-of works, but is still far from what you get with Eclipse+Java or VS+C#. The latter seems promising, but I haven't tried it. Like others here I get by fine without autocompletion. 
No, it isn't. It's possible in a python environment, because the environment can be examined, but not generally in python source code. You would have to get a frame of execution from wherever the cursor was, which is just not practical in most cases.
The latest version has gotten pretty good. NetBeans also has good support for completion (including the automatic imports you mentioned), but I use Komodo these days. I am not sure why, specifically, maybe it's the VCS integration. Both are pretty good otherwise.
Static code analysis can go so far, but it's mostly usable...
Oops, he said "decent," which I guess makes it a subjective question. Please rephrase my response accordingly.
No, do it yourself!
that's really cool, I did not know that tool Omni completion, thanks!
REPHRASE MY POST!
&gt;&gt;What should I do, just go back to switching back and forth between documentation and the text editor? &gt;That's what I do. If you hadn't brought it up I might not have even noticed that. Pshaw. Kids these days, y'know?
Maybe it's just me, and please excuse the snark, but this feels like complaining that your training wheels don't fit on your racing bike. And yes, you should go back and forth between editor and documentation. Heck, spend some money, get a 2nd monitor and keep the Python reference docs (which are quite solid and available for free on the Web) open in a browser in one screen and the editor open on the other. You'll be amazed how quickly this stuff becomes 2nd nature and you don't need to constantly reference the docs.
Stani is AWOL and the editor / documentation seems to be abandoned. Shame...
vim kick ass
Does visual studio have auto completion for Iron Python? You could try that.
I put no stock in the ability to memorize documentation. It's quicker to hit the completion key, scroll through the list and determine what you need than Google it or sit in the interpreter and `dir()` everything. It's not like it's hand holding him through writing his program, it's just making it easy for him to avoid leaving the editor to look up methods all the time.
I'll second that, he's basically saying that to him 'learning' a language means installing the right code-generators. Auto completion produces code that compiles, but not understanding.
[Editra](http://editra.org/) meets a few of your criteria: it automatically completes methods by default, at least when it can tell a variable's type. (No complex static analysis, s'far as I can see.) The completion is pretty good, all told, and a pop-up gives the method's doc string when you type an open parenthesis. No extra documentation for each parameter, though that sort of thing should be in the doc string. It does have some optional niceties like an iPython shell and a code browser, though without a debugger it's a questionable IDE replacement.
Nice to see some Sugar code escaping into the wild. Note that on Ubuntu, every time there is a Firefox/Xulrunner security update, the path to libxul changes and pyxpcom can't use the standalone glue to find it so hulahop needs to be recompiled... Unfortunately it's not enough of a priority for the ubuntu-mozilla team to include it in their coordinated package updates.
IronPython Studio.
No. Wrt Python, dynamic analysis itself is the next step for IDEs. Its far simpler than having to do a lot of static analysis and deriving types. Plus one wrong guess and it goes a long way.
I'd leave autocompletion for when I'm very proficient. Also, Visual Studio... (doh) 
So, what, you're just going to run deltree() and see what it returns?
Well, to make the comparison fair, visual studio is not free either.
I've never understood that attitude. If a new technique allows you to interact with information in more dynamic ways then how is that a bad thing? Perhaps because it hinders learning the language fully? But is that really a bonus? Will I still be coding when A.I. can do it for me. Hell no, I'll be working out the best way to communicate with the AI so that it can code precisely what I want in a fraction of the time. I'm interested in what I can use code for, my appreciation for it comes from its pragmatism. Not that I'm defending Visual Studio, it can get rather slow and bloated when working on large projects, and python is a far more beautiful language than C# or VB.NET
I've used eclipse/pydev with django with pretty good results. You are always going to have trouble with auto-completion. Because python is weakly typed and dynamic you will not get auto completion all of the time. One thing I ran into with pydev was making sure you add the true include path of django libs. Pydev in the past has had problems with symlinks and some distros put django somewhere like /usr/share/python/python-support/ and then symlink to the more standard locations. Pydev skipped the symlinks so auto completion didn't work.
Typical. Most MS/Vb/C# devs I've know are this type of 'Mort' who have problems writing hello world without the ide.
also, scrolling through a list of available functions and procedures piques the curiosity about what they do; certainly, often that's how I've found the object already does pretty much what I was about to start writing something to do.
&gt;Perhaps because it hinders learning the language fully? But is that really a bonus? Hell yes it's a worthwhile bonus! Debugging code you don't understand because your IDE wrote it for you is a SERIOUS pain in the ass. Properly learning a language also allows you to design better code because you understand the little things that grant significant performance boosts in larger systems or the things to avoid for the same reason. 
I also noticed that he failed to distinguish between the language and the framework. Django is not a flavor of python. It's an add-on you learn *after* you've learned to use the language to begin with.
nginx
I used to be a big intellij fan before I got bitten by the Python bug, and while there are IDE's out there with good code completion for Python (and pretty ok refactoring browsers which I initially missed more), I will recommend that you do not seek them out. I'm old enough to remember life without mobile phones, I could remember 50 or 60 phone numbers off the top of my head and it did not seem like a big deal, now I know 2, and one of them is mine. Dependancy on auto completion is going to slow you down in the long run, it will break your train of thought in tiny ways. Python is a very small language, the libraries, including most of django are pretty simple, if you have to learn them without code completion, pretty soon the code will start to fly off your fingers in a way that code completion will only retard. Try living without it for a few months, I bet you will not go back.
Wants code completion so he can code with Django... that doesn't seem like a coincidence.
Upvoted, but sometimes I feel like typing anything at all is yak shaving.
I don't use it at the moment, mostly because it isn't a big enough deal to bother setting it up, but there's definitely value in being able to tab-complete method names and getting a popup with docstrings and/or the method definition -- even in Python.
&gt; It's quicker to hit the completion key, scroll through the list and determine what you need than Google it or sit in the interpreter and dir() everything. On the other hand, actually knowing the language and libraries is often quite important (to take one example: knowing when you want `re.search` and when you want `re.match`), and once you do you don't need completion (and for things you don't know, you want to read the docs anyway).
&gt; If a new technique allows you to interact with information in more dynamic ways then how is that a bad thing? You become wholly dependent on it, as the OP seems to be. To continue the metaphor started, the OP essentially wants to go on the road, but cant' take off the training wheels. Code completion should be a nicety, not a necessity.
Dang, that's a good idea... I don't know why I didn't think of it. Thanks for sharing!
There's not much to *get*. It's a pretty-printed `dir`.
I think you're confusing the language and the API with the editors/IDEs. They're not the same thing. Just like Visual Studio is not a language.
Um. print "\t".join(dir([])) Seriously, who is up voting this?
By your logic, he must not understand his .NET languages very well at all, because the code completion hinders his ability to think. Or something of that sort.
 python3.0 Python 3.0.1 (r301:69556, Feb 16 2009, 15:52:10) [GCC 2.95.2 19991024 (release)] on sunos5 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import subprocess &gt;&gt;&gt; output = subprocess.check_output(['ls']) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: 'module' object has no attribute 'check_output'
This is a little more than that, I suppose: it represents magic functions as they're actually called. A little easier on the eyes, but perhaps there's a dollop too much grandeur in giving it a website and a Github project.
I use tab completion in ipython instead of `dir`.
Perhaps you're a misunderstood aesthete, moonlighting as a Python programmer, who simply cannot abide by too many underscores and too little whitespace. You're unable to take it anymore! Well, someone's fixed it for you ... seven people, in fact. In, um, about 200 lines of code. Which you didn't have to write! Here's to you, aesthete.
some versions are
i grasp the difference between a language and a framework. sorry for not making it perfectly clear in the title.
Objection withdrawn.
Oh yeah, C# express I think. I have a complete free edition. That's one nice thing Microsoft do with CS Colleges. They gave me a complete Visual Studio. 5 Windows OS licenses: XP pro, Vista ultimate (32) + Vista ultimate (64), Server 2008 (32) + Server 2008 (64).
In emacs you can get drop-down style code completion and documentation at the point for Python development if you use rope, ropemacs, and hook it together with auto-complete.el. It works beautifully, and it works really well with Django as long as you can get rope to analyze the Django code (it's a little more complicated, but not too bad)
&gt;python is weakly typed fuck no it isn't. 
I don't see how you can say that I don't fully understand my code because my IDE autocompletes it. Just because I don't want to go around hunting for Math.sin doesn't mean I don't know what it does.
Computers have enabled the world to use information in new ways that we are now dependent on. Is that a bad thing? Take that line of thinking to an extreme and we would never have developed any tools. I agree it is important to understand the tools that you are using at least a step or two back down the chain. But you don't always need to know all the details if you have another tool that can help you out. I can look up the docs if I need to, but I've only ever written a few lines of assembler and certainly couldn't build a microprocessor even if I had the machinery to do it. One day I hope to write a few UML diagrams, parse it through an algorithmic designer and bingo, a new site.
Sorry, that function was added in Python 3.1. In 3.0 it would look something like this: &gt;&gt;&gt; import subprocess &gt;&gt;&gt; p = subprocess.Popen(['ls'], stdout=subprocess.PIPE) &gt;&gt;&gt; output = p.communicate()[0] &gt;&gt;&gt; type(output) &lt;type 'bytes'&gt;
Kick Ass! Thanks a million.
Yeah, right. So I guess you should use Notepad to edit your code, being afraid to be spoiled and become dependent on all the nice things in the more powerful editors. Because, you see, when you are used to an editor which positions the cursor to the proper indentation level when you press Enter, even if it just uses the level of the previous line, not to mention indenting to the next level after an `if ...:`, and then find yourself with an editor that doesn't do anything like that, you can't use it, the need to press `tab` yourself so much times seems actually insulting. So you are not a Real Man anymore, you've become a dependent weakling. Right?
It's the underscores: &gt;&gt;&gt; dir([]) ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__str__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] &gt;&gt;&gt; 
It's the underscores.
Either you have never seen autocompletion in your life, or you hold an extremely strange belief that the thing that happens to you when you blindly write `_full_path` after writing `request.get`, instead of pressing `C_Space` and seeing the list of available methods with docstring popup, is called "understanding". It is not, it's memorization, learning by rote, it's actually a direct opposite to understanding.
I use tab completion in regular Python.
WingIDE is great. They provide a [Django howto](http://www.wingware.com/doc/howtos/django), a [web2py howto](http://www.wingware.com/doc/howtos/web2py), and more. 
But what I'm wondering is, is it the underscores?
If you honestly think an AI will be writing your code for you in this lifetime you either have too high an expectation of AI, or I have too low of a one. 
I was going to chart a middle course, because syntax high-lighting and auto-indent and such are nice. But, actually, no. These are niceties. If you require them to program you don't actually know how. If you can't code in notepad/vi/edlin/ed/hideousEditorOfYourChoice, then I'd posit you don't know how to program. What you know how to do is akin to word processing.
No one says he _can't_ code without these niceties. It's just very painful. Is the ability to indent you code manually central to programming? Or the ability to parse your lines counting quotes to detect string bodies? The ability to find matching braces? To remember the exact names, parameters and purpose of all library functions and your own functions? For each your function to remember the code file and line number where it's defined? *This* is word processing, man. Tedious stuff absolutely, totally unrelated to real programming. Eventually even the most hard-headed "Real Programmers" reluctantly accepted the basic stuff, like matching parens, as something not central for programming, yet when it comes to a slightly more advanced stuff, it all starts again: mindless rote and memorisation are declared to be the absolutely essential requirements of Real Programming.
I'll be the first to admit that I am no expert on type theory. I thought that python used dynamic/"duck typing". My understanding is was that these don't fall into the bucket of strong typing and therefore were some flavour of weak typing. My bad if I am misinformed. I'll trot off to wikipedia now :)
&gt; I'll be the first to admit that I am no expert on type theory. Which doesn't really matter, since strong/weak typing isn't really part of type theory. &gt; I thought that python used dynamic/"duck typing". It is a dynamically typed language yes. As opposed to statically typed languages. It would be quite redundant if "strong typing" meant "static typing" now wouldn't it?
I understand what you're saying... I'm just used to doing it the other way...I read docs by exploring what the autocomplete tells me. When creating django models, i want to say "model." and then let my editor tell me what the different options are. I could go look up the django models docs, but if its telling me the same thing as an autocomplete, it just seems like i'm going to another place to find the information that I am accustomed to seeing right while I am programming.
Basically a restricted sub-set of python can be translated to C++, other similar projects: * Pyrex, a 'python like' language is used, aims to provide a simple way of creating extension modules, mature. * Cython, 'better Pyrex' moto, mature. * PyPy, work in progress, also restricted python code, they are using LLVM to target different architectures (machine code, javascript, llvm jit, ...), great expectations. ;-) Also related projects: * Psyco, dynamic JIT code generation, very simple usage, just importing a module an enabling the optimization provides a decent speed up. Mature (&lt;= Python 2.6) * Boost python and SWIG, allow to wrap C/C++ code to create python extensions. Mature projects. * Ctypes, a foreign function interface (FFI), can dinamically (at run time) wrap DLLs (linux, windows, ...). Already part of python distribution. 
Perhaps. I think we will have highly specialized ones that can do jobs like the one described above in the not to distant future. Quite a while before we have walking talking ones.
I don't know, which is why I'm very interested in that chapter.
Maybe you just have too low an expectation of his lifetime?
Gaming stuff. People like making games! Honestly, I've got no idea. I'm working through a beginner's book by Mike Dawson that uses simple games as programming examples and ends with a pygame version of Asteroids.
disutils, setuptools / easy_install would be a great start, but you probably have them already. Its a tricky one, because there doesn't seem to be a consensus as far as I can tell!
And I'll repeat what I said. If you cannot, in a pinch, work without your comfortable IDE and your syntax highlighting and paren matching and all those lovely things that make life easier... then you don't know your language. I'm not saying that one should choose to work this way -- these things exist because they make life better. By all means, use them. But if you **need** them to function, then your skills are seriously deficient. It is not unusual, or terribly uncommon even, to have code deployed on some bizarre system where your usual tools are not available, and you need to fix an issue there -- either due to urgency or because it only happens in that god forsaken environment. And if when you're in that situation the answer is "Well I can't fix it because I don't have my syntax highlighting and my code completion", then I'm sorry you've failed as a software engineer and deserve the scorn and derision and snark. Now, if you like having those things when you're in the comfort of your development environment hacking away at the latest and greatest revision of whatever your project is at 2am while guzzling ridiculous volumes of caffeinated beverages... more power to you. It's the sort of skill that separates novices from veterans. If you think I'm being ridiculous, hard-headed, and elitist then you're either missing my point or haven't been burned enough times yet. And if you've been to the wars and seen the elephant, then you're probably nodding your head and know where I'm coming from. Another way to think of it: I'd fire a carpenter if he couldn't drive a nail with a regular hammer. But I'd hope he wouldn't waste my money by driving every nail by hand, and would use a good nail gun when and where appropriate.
pip (package installer) a good replacement for easy_install pip.openplans.org 
You also might include a blurb about Paver or Fabric for deploying pacakges.
I think you misunderstood the question.
Will zc.buildout get ported to Python 3? That's the only other one I can think of that gets used with any frequency that hasn't already been mentioned here. (Not a pythonista, sorry if this question is obviously wrong)
You'd do the world a favour by specifically discouraging the use of easy_install. Aside from all the well-known issues surrounding it, it hasn't been maintained in 9 months, and the codebase is a complete mess.
whichever ones are likely to be ported to python 3 by publication... Personally I like the idea of a minimal distutils/setuptools section and then a section on something more ambitious. Expert Python Programming has a whole chapter on zc.buildout, so maybe skip that one and do something like Paver.
I would advice you to look at the whole software distribution/deployment tool chain. That means that you will have to start with distutils/setuptools/easy_install. Despite of what some serious detractors and trollish bloggers might argue. It's the only combo which is something of a standard. Further, you cannot consider package management separate from deployment and runtime environment. So I would recommend to include virtualenv as well. Concluding I would concur with tehmatticus to deal with Paver or Fabric as well. 
Yes, zc.buildout will for sure be ported to Python 3. The only hold-up on this porting work is that it depends upon setuptools and there is no official port of setuptools to Python 3 yet. (I think Distribute, the setuptools fork, will likely see a Python 3 port before too long, and then a Buildout port may happen based on that code base ...)
Has any packaging tools been ported to Python 3 yet? Obviously Distutils, since it's part of the Python standard library, but given the low test coverage on that package, I wouldn't be surprised if it still need some bugs shaken out of it. Setuptools had one "unofficial" port. Currently no work is being done to port this. Distribute, the new setuptools fork, will presumably make a Python 3 port a priority. All the other packaging tools depend upon setuptools features, and can't be ported until setuptools or distribute is ported: virtualenv, pip, buildout, Paver. However, if you are targeting Python 3.2 in a year-or-so from now, then things may be a much better story. Then there *might* be: - Distutils will have the needed improvements from setuptools added to it (install_requires, entry_points, install metadata). Also Tarek wrote lots of new tests for Distutils. This will give you the bare-bones necessary to create distribution tarballs and upload them to a package server, as well as doing evil manual installation (python setup.py install). - pip: for doing command-line installation. Although you pretty much need to use pip in conjunction with virtualenv, so virtualenv also needs to be covered here. pip works best for exploratory installs, where you want to try out a package first, then allows you to go back at a later date and freeze the list of installed distributions so you can repeat that library working set in another Python install. - buildout: for doing "project-based" installations. Buildout not only installs python packages, but does any other installs that are necessary to run a complete dev sandbox or production instance (web servers, databases, config files, process monitors, etc, etc.). Buildout requires that you install new packages by first declaring them in a buildout.cfg file, then when you run buildout it updates the install to reflect the specified distributions (kind of the opposite of pip where you install first, then freeze, w/ buildout you specify first then install what was specified). 
I'd remind people of the fact that Linux distros tend to eschew these means of packaging for their own packaging systems. As such, I tend to trust apt/yum/pacman/whatever to give me a compatible and working version of any Python library.
Coverage of pip and virtualenv would be awesome.
How about *not* considering either setuptools or easy_install?
&gt; However, if you are targeting Python 3.2 in a year-or-so from now, then things may be a much better story. The book goes to the printer in a few weeks, so this is more of a "right now" kind of question.
I got that kind of answer a lot at PyCon. "When are you porting [web framework] to Python 3?" "Just as soon as you teach me how to do it." Flattering and all that, but not terribly helpful. Several chapters have already been cut due to lack of Python 3 support. I ported httplib2 myself to write the HTTP chapter.
I've always wanted a comprehensive guide on PiP + VirtualEnv + Fabric , which I've heard is currently the best way to do package installation/isolation. Of course, there's not a lot of good guides to it, so I'm looking forward to yours :-)
i'm being put off python as a commercial tool because of issues with certain packages. the only reliable way i've ever found to make sure my application works on another box is to tell them to use debian or ubuntu and apt-get the depends. things like matplotlib have about 150mb of depends in ubuntu. i dare not even consider how to tell my clients to install the relevant version on a redhat 4 machine. now this is little to do with python and more to do with those particular libraries and my (likely poor and lazy) choice to depend upon them. in short, how should one write a .deb with python depends would be good. but i can see how this is way outside the scope of that topic and doesnt really belong
The problem is, I can't imagine a programmer who can't code in Notepad. Just can't. Autocompletion and stuff adds nothing to your knowledge of a language, or of libraries, or of anything, it's _the word-processing stuff_, as you've called it, that gets ridden of. The programmer you are describing is impossible. A strawman, in fact. In reality there is OP and there is me, and we both _can_ write code using `cat &gt;code.py`, it's just too painful to be viable. And you don't attack your strawman, you are attacking us, implying that we are dependent weaklings, not Real Programmers at all. Because, you say, Real Programmers don't ask for nice IDE features, they clench their teeth and hack from the commandline all the time, _because they can_. On a side note: I can only wonder what have you forgot in the /r/Python, raw machine code (from the commandline of course, Real Programmers can easily avoid uninputable bytes), or maybe assembler, but not C, C is for pussies, would be more appropriate for you, _more manly_. &gt; It's the sort of skill that separates novices from veterans You are imagining it. There is no such sort of skill. Well, there is something like that, some little piece of knowledge about invoking your compiler from the commandline or from a Makefile, rather than depending on your IDE to do that, but it's not a big deal, absolutely not something suitable for "separating novices from veterans" as these novices can learn it in an hour, and not applicable to Python at all. So, you see, OP had formulated his request quite clearly, and it's not about what you are saying, he is not like, "I can't write Python at all", he is saying that it's painful without a decent IDE, and asking for one. And its _your_ problem that you've never seen a decent IDE and are rationalizing your reluctance to try one by calling OP a pussy, to be straight. VS/C# really is something of an experience, making it easy to go in a state of _flow_, when your thoughts are flowing directly to your code without it being necessary to stop and switch and read manuals. With an IDE literally reading your mind, in a constant dialogue. I'm using Python all the time for small scripts, with Eclipse+Pydev, and it's almost the same (though without autocomplete active all the time), but it does break whenever I'm trying to do something nontrivial, and it hurts. It's like half of my fingers were amputated. I had my "Go to definition" at the tip of my right middle finger (and the left pinky), "Refactor" at my left one, full view of the methods of a given object on my left thumb, with short descriptions and parameter hints, and now it's all gone. Instead of being one with the code I'm blind now, finding my way by touch and stopping every other time to switch to a manual and read the stuff up. Really, I'm not exagerrating, switching from C# to Python for the first time feels like becoming an amputee, only with an external half of your mind amputated. And fingers. Succintness of the language doesn't even seem like a fair tradeoff. Only then, when you have an almost decent IDE and know when to use Python, and did memorize most of the builtins, it becomes bearable and even enjoyable.
It does not appear to work in Python 3.
These do not appear to work in Python 3.
These do not appear to work in Python 3.
Yes, I am partial to this solution myself, but many in the Python community are not. My original notes for this chapter include the option to distribute as a .deb/.rpm.
Yeah, so I think you can only cover Distutils then in Python 3.1. Everything else is still waiting to be ported AFAIK.
This is actually sort of a sad commentary on the state of packaging in Python, but it's also somehow fitting, given how *packages* themselves were an afterthought in the original language. :)
I had to generate the previews of 4 first pages from uploaded document, and also managed how to avoid OOo :) abiword document.doc --to=ps --exp-props="pages:1-4" gs -q -dNOPAUSE -dBATCH -dTextAlphaBits=4 -dGraphicsAlphaBits=4 -r72 -sDEVICE=pnggray -sOutputFile=preview%d.png document.ps 
Well, the .deb/.rpm solution works for many use cases, but you simply can not do a multi-version install of a library with those package managers. So you can typically only install one version of one framework on a system. Install Twisted, and you can't install Zope 2. Install Zope 2 and you can't install Grok. Install Grok and you can't install TurboGears. And you can't allow two versions of the same framework side-by-side, so no allowing one app to require Django 1.0, another with Django 1.1, and another to use Django (trunk). It's not too hard to bump against the limits of "one version of a package only" restriction of a package manager. At which point you've painted yourself into a corner and need to go back and use a tools to supports multi-version installation. And PEP 376 addresses the fact that you can't even tell what's been installed by .deb/.rpm/Distutils so other tools to manage packages can't rely on existing package-manager supplied packages so a hybrid approach isn't easyily achieved ATM (e.g. using a .dpkg for tricky-to-install packages such as lxml). 
matplotlib is a fine library, and it's intended to be scripted from Python, but it's install woes stem from the fact that it much of it's implementation is in C++ (and probably other compiled languages, I think it's numpy dependency is C and Fortran?). This gives it excellent performance characteristics, but makes it much harder to support installation. matplotlib does push out pre-baked binaries-included versions of the library, but you need to match their current build farm to use that library. Right now they do Mac OS X w/ Python 2.5 and Windows w/ Python 2.6 and Python 2.5 ... if you don't have that platform it's either use your distros pre-built binary or install from source. The matplotlib install-from-source option is all messed up though. This could be cleaned up a lot I think ... I managed to install it by hacking up it's setup.py ... 
Sadly... cd platform-dependent/site-packages svn co http://library-site/path/lib lib may be your only compatible Python 3 option.
It's like when you save somebody from a plane crash and then he gets hit by a bus! ;-)
I'd like to see something about packaging for Windows. Packaging for Linux seems fairly easy by comparison.
One of the purposes of python packaging tools should be to help people build .debs and .rpms.
Have an upvote. The process of building Linux packages can be rather daunting, particularly for the uninitiated.
Sigh. The fact that my point offends you, implies that you see yourself in my comments. I didn't particularly mean you. I don't even know you. I don't even know whether that is you. In fact, I assumed it wasn't, but clearly I hit a nerve. Your verbosity speaks for itself. One last time: If you cannot work without power tools, you suck. But using power tools doesn't automatically mean that you're awful.
Setuptools' friendly-fork started by Tarek and other folks at distutils-sig: Distribute - http://bitbucket.org/tarek/distribute/ They are currently working on a Python3 port besides fixing and applying patches from the setuptools tracker (short-term) while also planning for a refactoring work to split setuptools/distribute into various abstract and re-usable modules (long-term)
Almost none of the people concerned with core Python development care about packaging, and many don't use any packaging (besides their personal ad hoc systems). It's a weird disconnect.
And to add to that: if you want to develop something using a different version, you can't very well package up that version (a checkout, a local branch, etc), install it on your system, and then work from there. That's just unreasonable on a lot of levels: if the library is widely used you may have broken your entire system; packaging and installing packages is not trivial; creating a deb/rpm and then installing it is really slow; and if you are working from a checkout you might actually want to edit the files in place, but you can't/shouldn't edit the files installed by the packaging system. For deployment deb/rpm might make sense -- though not much sense, for the reasons kteague notes. And for development it makes no sense at all.
I'll second that: if you are talking about Python 3, Distutils is the only thing, and will be the only thing for some time. You could talk about .pth files and manually futzing with sys.path in a script. I'd recommend both of these over PYTHONPATH. PYTHONUSERBASE offers some of the advantages of virtualenv, but unlike virtualenv it works in Python 3. (It also has some problems that you should note, like being picked up by subprocesses -- e.g., if you invoke hg in a subprocess from your script.)
Maybe it's time I actually signed up for distutils-sig... &lt;sigh&gt;
So then is this some kind of trick question? Asking what to write about when there's hardly anything even eligible?
You might find a useful snapshot of the current _working_ "state of the art" of python packaging here - http://weblog.patrice.ch/2009/04/15/modular-python.html and the corresponding presentation - http://weblog.patrice.ch/files/2009-03-modular-python.pdf - in other words setuptools + easy_install with support from virtualenv. I'm pretty sure the author is working with Python 3.x BTW
&gt; I ported httplib2 myself to write the HTTP chapter The grey zone of being a tech author
[Release notes](http://docs.djangoproject.com/en/dev/releases/1.1/).
Just spoke to the the author - he's _not_ using python 3.x , sorry
Or [straight from the horses mouth](http://www.djangoproject.com/weblog/2009/jul/29/1-point-1/)
Komodo Edit is also under open source. - www.openkomodo.com
Could you point me to a writeup about these issues?
Off the top of my head, things I've run into: - Subversion functionality breaks with every new release of svn, because it accesses contents of .svn directly. Waste an hour downgrading your Subversion client, re-checking out, just to build test eggs, before reupgrading to get access to your other working copies (this happened at a client site on billable time) - It seems to get confused by umask, or otherwise tends to install things in site-packages owned by root and unreadable by world. - .egg is a terrible file format, blindly copied the mistakes Java made in choosing ZIP (could rant about this at length) - after install, screws up Python module loading in some way completely indiscernible to me (user of Python for 8 years+). On more than one occasion, having minorly touched the contents of site-packages, had to reinstall easy_install &amp; co due to warnings I couldn't get rid of. It's just nasty, and it's cost me a lot of time. The Subversion thing is pretty unforgivable (the docs specifically say don't so it, yet easy_install does anyway) Rather than tell you 'why not easy\_install', I think its simpler to ask 'why easy_install'. PyPI index fetching is convenient, but other than that, all the tool does is allow you to avoid using a well thought out package manager (e.g. dpkg) that supports things like virtual dependencies, and forces on you some arbitrary notions like storing packages in ZIP files, even post-install (and for what gain?) Edit: typo and some ranty additions.
Just in case /r/python redditors didn't realise, there is a r/django which is full of the latest tips and handy articles - and could do with more subs :)
I think you meant "pony's mouth".
All the more reason to ask the lazyweb^Wreddit python community...
&gt; You'd do the world a favour by specifically discouraging the use of easy_install. This. And unless there are setuptools features required for your packaging needs, don't use it either.
That would be an interesting bitbucket fork though. I'll have to check how easy it would be (though that'll also require finally learning the differences between 2.x and 3.x)
Yeah and it seems like most schools that have that, also get pressure to teach everything using MS products.
Well they taught us C++ on visual studio which I think is not too bad when you think that so many companies use it. Then for Java and Python they used eclipse. We also fairly used Linux.
A link for the lazy: http://www.reddit.com/r/Django
Google for "mutable defaults". `x1` and `x2` are different objects, but `x1.dict` and `x2.dict` both point to the 'd' defined in the `c1.__init__` definition. The `d={}` expression is run when the class is defined, not when `c1.__init__` is used. So it ends up being shared. A default argument with a string would exhibit the same behaviour, but it doesn't matter because strings are immutable. Moral: don't use mutable default arguments, unless you really know what you're doing.
Ah, yes, thank you very much.[Here's a helpful link](http://www.ferg.org/projects/python_gotchas.html#contents_item_6) -- I'm surprised I've never encountered this before.
Not sure why I didn't think of that.
When I submitted the question, I didn't know what was available for Python 3. Five hours later, I knew a little more, and I responded to your comment.
I will cover PEP 370/PYTHONUSERBASE, but I doubt I will go into that much detail. I certainly will not be comparing it to virtualenv. However, if there are writeups of advanced uses/gotchas somewhere, I'd be happy to link to them in the "Further Reading" section.
I asked the question on the virtualenv google group and got the following answer: Ian Bicking: &gt; I think first Distribute needs to stabilize and get ported to Python 3 &gt; (I don't think Setuptools is going to move forward in a useful way). &gt; Then we could try to update pip. I suppose it might mean supporting &gt; both Distribute and Setuptools for a while, as Distribute will be the &gt; most stable library on Python 3 (due to a lack of competition) but &gt; might not have parity with Setuptools on Python 2 for a while. Though &gt; who knows, if they work fast it might make sense to switch before very &gt; long. http://groups.google.com/group/python-virtualenv/browse_thread/thread/eb84b1af1b7e8e09
Yeah, python's easy linking to C is a major liability when it comes to packaging and distribution. This is exacerbated by the fact that the majority of desktops are Windows, and windows has no standard package management solution. So if want to try to deploy a non-trivial python application onto Windows, you really don't have any shoulders to stand on. You pretty much have to bundle everything a la py2exe and have your own little Python-in-a-silo, which means that you have to ship hundreds of megs to the customer.
Definitely very excited about the actions in admin, and list_editable. w00t!
The first time I read that 7hours ago I swear the Rails mascot was a Pony. I feel embarrassed now. 
That would be no more random than atmospheric noise. There will be definite underlying patterns to posting density
There are trends and cycles in twitter posting - your best bet for random is nuclear decay!
It's not clear what you are trying to achieve, because you are putting the code that creates the container and the code that iterates over it together, when I presume it's actually separated in your code? For the above, I would just write: class A: pass for i in [A(), A()]: print i 
Well, yes, I could have come up with a slightly better example. I have used this approach in a dirty quizzer so I needed to access the items in a random order and multiple times. Also, the objects are usually initialized with input from files of unknown length. So lets consider (without considering a problem difficult enough to actually warrant using a class): import random class A: container = [] def __init__(self, string): self.string = string A.container.append(self) file = open('myFile.txt', 'r') for line in file: A(line) while raw_input() != 'quit': print random.choice(A.container) 
The app's purpose is to serve fckeditor's file browsing and upload functionality through django. It will also use django's default file store, media root, and media url.
No, objects shouldn't have to know about the container that they are placed in. Well, I guess there are exceptions depends upon what you are trying to do with the container, and it's fine for a simple example such as the one you provided, but I would have written the above snippet as: import random class A: def __init__(self, string): self.string = string file = open('myFile.txt', 'r') container = [] for line in file: container.append(A(line)) while raw_input() != 'quit': print random.choice(container) With this later decoupling of container from contained, you are free to use a multiple containers. If the container is a class attribute, there can only be one container instance. For example, if you later wanted a container for a small set using a list, and a massive set of the same objects using b-tree implementation, then that would be easy to do if the container instances are separated from the class of the contained. 
Coming to a .NET or JVM run-time near you, comes this summer's hottest release: "Ponies on a Train"
How is that gray? He benefits from giving people another reason to learn about 3, and we benefit from having more 3 libraries. I don't really see the "gray" of it. Seems more like a virtuous circle. 
Perhaps you're thinking of an *object pool*? If your objects are frequently created and then deleted, maybe your container (pool) should create the objects one time only and then reuse (reinitialize) them as needed. It would improve performance in your code, if that's an issue.
Instead of: for line in file: A(line) I would write a list comprehension: container = [A(line) for line in file] Generally it's considered bad for objects to know about the container they are in (unless they really need to) because of what happens when you want to put them in other containers. 
In this case ( Mark Pilgrim, Dive into Python) it really is virtuous, given the author and the library, but still this is a grey (UK English) zone in tech book writing IMO. It would be interesting to surmise how much Open Source has been written _because_ a publisher like O'Reilly asked someone to write a book on the subject. For example, five years ago a popular theme was "&lt;Language X&gt; + XML", where you can insert whatever popular Open Source scripting language you like in the place of &lt;Language X&gt;. Back in 2004, support for XML parsing in most &lt;Language X&gt;'s was probably poor to medium, frequently not much more than a wrapper on James Clark's [Expat](http://www.jclark.com/xml/expat.html) SAX parser. The dillema for tech book authors is how to fill a whole book on the topic of "&lt;Language X&gt; + XML"? By chapter 5 you're out of topics but your publisher is pushing for more. On some XML mailing list you happen to have heard of yet another approach to parsing called [xmlpull](http://www.xmlpull.org/) but Language X doesn't have an implementation. So you end up rolling your own, 'cos it wasn't that hard, submitting it to Language X's equivalent to CPAN and writing a chapter on how to use it. Which sounds like it's great of the community as well as getting your book written. Except that... a) You're not eating your own dogfood. So should you really be pushing people to adopt libraries you only wrote for the purpose of a chapter in a book? Libraries you have little interest in maintaining? And the code is probably not the best you've ever written, despite touches of over-engineering. b) From the perspective of credibility, most tech books of this kind are supposed to be educating the user in best practice and guiding them in making sensible technical decisions. Does that really stand up for books where a third of the material discusses libraries and techniques that were effectively invented for the book itself? IMO the grey zone lies in whether you writing about reality, about the state of the art, or are you creating it first _then_ writing about it? And that's not to knock Dive into Python, which IMO is a great book. I'm interested to see, and impressed by Marks opening in discussing his problems in upgrading it to Python 3.x
This seems incredibly useful to me. Python's string functionality is fantastic.
It's a very interesting project initially developed by Imageworks, the documentation shows the implemented methods: http://code.google.com/p/pystring/wiki/Documentation
Holy crap awesome.
This reminds me of doctest. There's a function that reads docstrings from a file and then tests those. There's a function that reads docstrings from a module and then tests those. There's no function to just bloody run a given docstring. The Python stdlib is sadly full of things like that; functions that do too much, or too little.
So this supports sys._getframe(), awesome. Couldnt we use Ipython with ironpython now?
That is what I call awesome-o
Reallly really cool !
why comic sans? WHYYYY????
This seems useful... does Boost's String lib do anything like this already though..?
Boost has the http://www.boost.org/doc/libs/1_39_0/doc/html/string_algo/usage.html#id3408018.
There's the [Twitter Streaming API](http://apiwiki.twitter.com/Streaming-API-Documentation) which would solve the cached-public-timeline problem
Is there any reason this couldn't be done in C99? 
What's wrong with comic sans exactly? I like that font!
i just couldn't watch it for more than a couple of minutes... it's a shame, i would have learned something for sure
I heard very positive feedback from scientists using it, at the first French PyCon two years ago. They delivered a speech and showed us a demo. They were working with high-energy lasers, near-absolute-zero temperatures, in a lab where lots of people join and leave the team regularly (grad students, etc.). What mattered most to these people is to have programming tools that do not get in the way, that produce usable results, that are easy to learn and most importantly maintain. Apparently Python fitted the bill, and so did Traits (and Traits UI). Note that they were not purists of the programming art, and so they had no feedback about code smell, architecture, etc. Also, I don't know if Traits UI allows you to construct your UI exactly as you want, or if its ease of use is paid in a lack of control in that area. Anyway, it piqued my interest. I have not had the time to go explore further though.
Kudos for PyS60 support.
random.shuffle(x)
That's really cool. Can you share any of the code from the project?
Enthought's Chaco library uses traits heavily and allows for nice [interactive plotting GUIs](http://travisvaught.blogspot.com/). TraitsGUI and Enthought's Envisage are used for the excellent [Mayavi2](https://svn.enthought.com/enthought/wiki/Mayavi/Screenshots) 3D visualization application. Others have [reported](https://mail.enthought.com/pipermail/enthought-dev/2009-August/023398.html) recent success as well.
I await a mirror
Code or it didn't happen. ;-)
 reduce(lambda x,y: x+y, l) But by the rules the lambda function is not allowed. 
[Google cache](http://209.85.229.132/search?q=cache:bBlsFTerwkIJ:zovirl.com/2009/07/23/teaching-kids-how-to-create-a-drum-machine-with-python/+http://zovirl.com/2009/07/23/teaching-kids-how-to-create-a-drum-machine-with-python/&amp;cd=1&amp;hl=es&amp;ct=clnk&amp;gl=es&amp;client=firefox-a)
It does look interesting, but I imagine I could easily write a simple, light weight version myself. I might check it out for Traits UI though.
I've been wanting to try pygame for quite some time now. I was reading their web-page and they touted the easy installation process. So I though.. hey... no time like the present. I downloaded the mac os x 10.5 installation of pygame and doubled clicked the mpkg. It told me that I could not install it on my harddisk because I need python 2.5. It game me no options. I have python 2.5.1 on my machine. Sigh...
Yay Pygame has just gotten better and easier!
Python + Mac = headache
It's in the repositories of most Linux distributions by default, and so is Python. Just saying in case you want to give it a whirl.
Tuxradar has got some awesome tutorials with pygame [here](http://www.tuxradar.com/codeprojects) if anyone is interested.
http://bancomicsans.com/
Dear @NYT: 1) Why on Earth do you plot anti-clockwise? :o 2) Also, information density beyond a certain point on this plot starts to resemble fresh excrement. But Python comes to the rescue! That dynamic range based drawing of the plot would really help my second point. 
&gt; The second one is datetime. Now I for one, do not see what is wrong with the module For me, it's not just the datetime module. It's time, datetime and dateutil. They're just not very Pythonic, IMHO. One method returns a timetuple, another a timestamp, a third returns its own object. Converting between the lot remains a case of "let me look that up in a cheat sheet" (http://pleac.sourceforge.net/pleac_python/datesandtimes.html). It's the only thing in Python that, to me, feels like it came from PHP: inconsistency galore.
thanks for mentioning this!
thanks for mentioning this!
Don't do this... It doesn't work: class A(object): def hello(self): return "Hello World!" class B(A): def hello(self): return super(self.__class__, self).hello() b = B() assert b.hello() == "Hello World!" Okay, works fine here, but... class C(B): def hello(self): return super(self.__class__, self).hello() c = C() assert c.hello() == "Hello World!" RuntimeError: maximum recursion depth exceeded When it gets to B's hello, it supers c's class, C, which is B... This is precisely the sort of bug that will eat you when you least expect it. 
Oh, and if you really want to be lazy, just don't use "super", in my above example, you could define B like so: class B(A): def hello(self): return A.hello(self) The only downside is that if you change the base-class of "B" to something else, you have to change it there as well, hence why the not-lazy spell it out "super(B, self).hello()".
I'm sure someone is going to say this but...if your program requires itself to create new classes maybe you could reconsider the design?
Create a [metaclass](http://www.ibm.com/developerworks/linux/library/l-pymeta.html).
I'd definitely investigate how Python garbage collects anonymous classes before doing this, but you can create them like this: def make_new_class(myvar): class Foo(object): a = myvar def __init__(self, foo) self.foo = foo return Foo def use_new_class(): cls = make_new_class('myval') instance = cls('args') return instance.a
I'm new-ish to python. I'm trying to separate things into a bunch of different types and sub-types. For example, I might want to do classes People, Places, and Things inside class Nouns. Then I want to put class X inside People and put however many variables inside X. I'm doing it wrong, aren't I?
&gt; I'm doing it wrong, aren't I? Quite probably. If you're just trying to create classes (not do some fancy metaprogramming stuff), then you just want class Noun(object): pass class Person(Noun): def __init__(self, name): self.name=name prius = Person('prius') I'd [read up on Python](http://docs.python.org/tutorial/) before bringing really basic questions up, though
You wouldn't perhaps be talking about [inheritance](http://docs.python.org/tutorial/classes.html#inheritance)? class Noun(object): pass class People(Noun): your_vars = ...
How about explaining what you're doing - it's likely there is a better solution.
might he be referring to [introspection](http://www.diveintopython.org/power_of_introspection/index.html)
You can also use the `type` function to generate types on the fly. &gt;&gt;&gt; Person = type("Person", (object,), {'bark': lambda self: "woof!"}) &gt;&gt;&gt; p = Person() &gt;&gt;&gt; p.bark() 'woof!'
Yes. You want inheritance and you should create the classes your object model will use beforehand.
ok didn't knew that, so how would you do it? I want simple inheritance without hardcoding.
it's not about *actual pros* it's about using introspection instead of hadcoding stuff all over the code, it's sad that I didn't knew it was so unusable. I'm waiting for your solution btw
Inheritance is what you need 
My solution? There wasn't a problem till you screwed things up. *edit* lest we forget: "Explicit is better than implicit"
Indeed. My first thought on reading his question was "you don't, if you know what you're doing."
This is why I like Python, in what other language can you have a Barking Person.
The short answer is, you can't. The thing is there has to be a handle to the parent class's function. In Java and C++ and the rest, calling the method brings with it a certain amount of context that is implicit, giving you things like a simple "super", and a "this". In Python, things are much more transparent, which is good, but it might require a little more typing sometimes.
But that is exactly what the OP was trying to avoid i.e. hardcoding the basecalss like that. Help me try and understand this. In your example above, the problem arises from the fact that the hello() method of class "B" actually gets called with "self" pointing to the object "c" - right? Hence the infinite recursion. And in your suggested solution, you do this explicitly i.e. pass "self" to A.hello(self), where "self" actually points to the object "b" (while the method A.hello() really expects to be executed with "self" pointing to an object of type "A"). Now, if the method hello() was accessing any object attributes, they would be looked up in entirely the wrong class. For example, is both "A" and "B" defined an attribute "attr", then A.hello(self) would actually access "attr" in "B" (not "A", as would have been the intention). So it seems to me, that regardless of what route you take, there isn't a clean way to call a method from the baseclass.
This is a perfect thing to post on stackoverflow.com . In my experience, the responses are fast and good.
Really - there wasn't a problem? Or, maybe you are not *getting* the problem that OP is trying to address. To me it seems like there are at least two issues here. * The language provides a mechanism to get to the baseclass of an object to avoid hardcoding the name of the baseclass, but the mechanism seems pretty broken. (from the Python docs: [super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages.](http://docs.python.org/library/functions.html)) * There isn't a clean way to execute methods from a baseclass at all. Maybe someone has better insight on this.
1. there is nothing anonymous about that class 2. python will gc your `Foo` class just like it gcs everything else: when it's ref count drops to zero. 
I dont understand why people want to use custom package management systems when their (linux) systems provide perfectly good facilities (like apt) which resolve dependencies *and* clean up after themselves properly. 
I agree that I don't solve the hard-coding, it's a bit lazier is all I am saying. No, the object "b" doesn't enter into the c.hello() stack. "c.__class__" is B, so super(self.__class__, self).hello() refers to the hello in B, no matter what class, method, function or frame it is called in. I'm not exactly sure that I follow your the rest. But I will say that it doesn't matter what class is looking up attributes, the object is the same. Also, I want to reinforce that if you had class X, and instance y, y.method() is exactly the same as X.method(y), in fact it's entirely syntactic sugar for it. This all highlights why "super" is rather tricky magic. Personally, I don't like it, but it seems a necessary evil.
The problem is that super doesn't really do that. What it really does is what the first line of the docs say, "Return a proxy object that delegates method calls to a parent or sibling class of type." AKA magic. And the fact is that it only superficially works like other programming languages.
I am not sure I follow some of your assertions. &gt; No, the object "b" doesn't enter into the c.hello() stack. "C" inherits from "B". So, object instance "c" implicitly includes an object instance of class "B". Earlier I was merely pointing out that the call to B.hello() (via c.hello()) was being made with "self" set to "c"). In contrast to if b.hello() was called (where "b" is of class "B"), where "self" would be set to "b". I was pointing out that execution of b.hello() generally expects the "self" to be set to an object of class "B", which is not true when B.hello() is called via c.hello(). &gt; "c.class" is B Is that true? When I do "print self" or "print self.__class__" in C.hello(), I get "&lt;__main__.C object at 0x019E28B0&gt;" or "&lt;class '__main__.C'&gt;".
Well, magic it may be. But I wonder why they didn't complete the magic by also setting "self" to an object of the parent or sibling class (during the execution of the delegated methods) - which would at least solve the problem we are discussing. But I am sure there are good reasons.
Ah sorry, I meant c.__class__.__bases__[0] is B, in other words the parent class of c.__class__ is B.
Well you can't make changes to the "self" object, you could only, at best, return a proxy of that object that points to a different class, but that would kill polymorphism.
No, I am not recommending a change to "self" or even killing polymorphism :) In fact, making "self" look like different types is the essence of polymorphism. For example, in C++, if C derives from B, then if "c" (of type "C") calls a method in B (by, say, B::hello()) then B::hello() will find "this" to be of type "B" and not "C" (unlike Python). In fact, a pointer to "C" can be up or down cast to "B" or "C" at will, whence the object appears to be of type "B" or "C" (i.e. polymorphism).
Huh?
As an example, There's class Noun with classes People, Places, and Things. The program will do something like class Prius: name = 'Prius' karma = 5596 And then put that class inside class People in class Noun. I only have a vague idea of what I'm doing. I'm sure there's a better way to do this. Inheritance seems to be what everyone's suggesting, but I'm either too stupid or too tired to understand it. Is there a better way to do this, or an easier way to learn about inheritance?
Just wanting to point out: That's actually the way Python creates new classes. Also, type is itself a class, not a function, and you can create subclasses from it and use them as a "metaclass".
cpython won't gc classes, no idea why
Sure it will. In [1]: import gc In [2]: gc.set_debug(gc.DEBUG_LEAK) In [3]: import types In [4]: class X:pass ...: In [5]: 'X' in [v.__name__ for v in gc.get_objects() if type(v)==types.ClassType] Out[5]: True In [6]: del(X) In [7]: gc.collect() gc: collectable &lt;type 0x895556c&gt; &lt;snip&gt; gc: collectable &lt;function 0x8ce680c&gt; Out[7]: 81 In [8]: 'X' in [v.__name__ for v in gc.get_objects() if type(v)==types.ClassType] Out[8]: False 
intresting, i'll have to figure what is different there i have various cases where classes don't get collected
 In [10]: any(v.__name__=="X" for v in gc.get_objects() if type(v)==types.ClassType) Out[10]: False In [11]: def test(): ....: class X: pass ....: ....: return X In [13]: test() Out[13]: &lt;class __main__.X at 0xc56a70&gt; In [14]: test() Out[14]: &lt;class __main__.X at 0xc38c50&gt; In [15]: test() Out[15]: &lt;class __main__.X at 0x7f0e4b1a6b30&gt; In [16]: test() Out[16]: &lt;class __main__.X at 0x7f0e4b1a6fb0&gt; In [17]: any(v.__name__=="X" for v in gc.get_objects() if type(v)==types.ClassType) Out[17]: True In [18]: gc.collect() Out[18]: 0 In [19]: any(v.__name__=="X" for v in gc.get_objects() if type(v)==types.ClassType) Out[19]: True In [20]: sum(v.__name__=="X" for v in gc.get_objects() if type(v)==types.ClassType) Out[20]: 4 
Anyone know if Ruby has an equivalent typing on the fly?
You can add class or instance variables to any class at any time. Once a Prius is determined to be a Thing (and not a person or place), simply add a reference to the Prius instance to a Thing list within Noun?
Dunno why this comment isn't receiving more attention. [Stackoverflow.com](http://www.stackoverflow.com/) is the bee's knees; huge library of previously answered questions and an equally large user-base waiting to help.
Sounds like it's time for someone to learn about closures.
ipython
I'd read up on programming actually (judging from the submitters comments).
ipython is probably keeping a reference to the output so that you can access it again later. These references will keep the classes alive.
Class factories in Python are a pretty common pattern. Not to say that it is the ideal solution to this particular problem, but still.
Why create a custom metaclass when `type` is already a perfectly good one, if you don't need to customize class instantiation?
It does. def create_class(class_name, superclass, &amp;block) klass = Class.new superclass, &amp;block Object.const_set class_name, klass end create_class('Person', Object) do def bark puts "woof!" end end p = Person.new p.bark
vim has drop-down completion too of course, being better than emacs.
It's a nice thought, and this has been bugging me for some time, but putting #END_DEF functioname after each function just to get code folding is way worse than brackets, in my opinion. I would love for TextMate code folding to properly work for Python.
It can't collect it there because you still have references to it. There is nothing special about classes in particular. In this case, `_14` is the first class you created and so on. If the classes were gc'd what you would you get back when you do `_14`?
Maybe what you want to do is just: class Noun: class Prius: name = 'Prius' karma = 5596 Assuming this is static, but then I guess the number of classes won't be static. Probably you should just use dictionaries or instances; maybe like: class Category: def __init__(self, name): self.name = name self.items = set() noun = Category('noun') thing = Category('thing') noun.items.add(thing) class Word: def __init__(self, word, categories=()): self.name = word for category in categories: category.items.add(self) prius = Word('Prius', [noun, thing]) 
Prius is an instance of Person, not a class. Look, there's no point in doing all this astronaut architecture if you aren't making something real, and given that you don't seem to know about inheritance, I'm guessing you're not writing anything real. Write real programs starting with a series of functions, and eventually you'll work your way up to needing inheritance and on-the-fly class creation. But don't just do it for no reason because you think it sounds "object oriented." 
What is it with GStrings? I use them in Groovy. It's always funny to hear a speaker talk about the positives of G strings.
&gt; there is nothing anonymous about that class Well, it's anonymous as far as `use_new_class` is concerned, which is what I meant. What would you call a non-top-level class that closes over some set of variables and/or functions? For a function you call it a closure, does Python call it the same when it's a class? &gt; python will gc your Foo class just like it gcs everything else: when it's ref count drops to zero. That's very good to know, and thanks for the [demonstration](http://www.reddit.com/r/Python/comments/9783z/how_do_i_get_python_to_create_a_new_class/c0boe50)
I don't mean to be an angry internet guy, but this: &gt;I'd read up on Python before bringing really basic questions up really pisses me off. If you think a question is beneath you, use the "hide" button. The python subreddit shouldn't be exclusive to people that know everything already.
How do I 'add a reference to the Prius instance to a Thing list within Noun'?
No no, that's not what I mean at all. I mean that the residents of /r/Python aren't your personal tutorial monkeys, and that you should at least run through a tutorial before expecting everyone else to teach you. It's sort of like walking into an eletrical engineering conference and asking people how to wire your speakers. Not only do they have better things to do, but you'll get anwers that are way over your head to begin with, and they aren't even the best equipped to teach you that, someone that's actually experienced with teaching people is (like a tutorial). Additionally, a tutorial is going to do a way better job at teaching you (for instance) basic OOP than formulating questions like "How do I get Python to create a new class?", when maybe that's not even what you want. It's fine to ask once (because where else are you going to get the answer of "here's a good tutorial", or "that's not really what you want to do"?), but you don't want to be asking that more than once, after you learnt that the best route is a tutorial, or you're just expecting people to hold your hand and do your homework for you.
why is this downvoted?
Thank you, my good sir.
If If understand the question properly: class Noun(object): pass class Thing(Noun): #List of all instances of things created thing_list = [] class Prius(Thing): __karma = 0 def __init__(self): self.thing_list.append(self) things = Thing() a = Prius() a.karma = 10 b = Prius() b.karma = 20 for i in things.thing_list: print i.karma I'd recommend looking into some tutorials on oop, since that seems to be your subject of most of your questions.
You are doing it quite wrong. Usually I wouldn't downvote for that, but prius seems confused enough. the first example there won't do what he wants; the second is going to be just noise to him.
Python's namedtuple simply builds the class definition as string and exec's it (Lib/collections.py): template = '''class %(typename)s(tuple): '%(typename)s(%(argtxt)s)' \n __slots__ = () \n _fields = %(field_names)r \n def __new__(_cls, %(argtxt)s): return _tuple.__new__(_cls, (%(argtxt)s)) \n @classmethod def _make(cls, iterable, new=tuple.__new__, len=len): 'Make a new %(typename)s object from a sequence or iterable' result = new(cls, iterable) if len(result) != %(numfields)d: raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result)) return result \n def __repr__(self): return '%(typename)s(%(reprtxt)s)' %% self \n def _asdict(self): 'Return a new OrderedDict which maps field names to their values' return OrderedDict(zip(self._fields, self)) \n def _replace(_self, **kwds): 'Return a new %(typename)s object replacing specified fields with new values' result = _self._make(map(kwds.pop, %(field_names)r, _self)) if kwds: raise ValueError('Got unexpected field names: %%r' %% kwds.keys()) return result \n def __getnewargs__(self): return tuple(self) \n\n''' % locals() for i, name in enumerate(field_names): template += ' %s = _property(_itemgetter(%d))\n' % (name, i) if verbose: print template # Execute the template string in a temporary namespace and # support tracing utilities by setting a value for frame.f_globals['__name__'] namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename, OrderedDict=OrderedDict, _property=property, _tuple=tuple) try: exec template in namespace except SyntaxError, e: raise SyntaxError(e.message + ':\n' + template) result = namespace[typename]
Dave Beazley's book is the only Python book that I really care to keep around. The attention to detail is really wonderful. As the reviewer points out, the index is amazingly useful. I remember Dave saying (at least for the 2nd or 3rd editions) that he manually built up the index, rather than using an entirely automated tool, and the difference is that when you go to the index to look something up, you pretty much find what you were looking for.
The take-home message here for me is avoid using threads in python.
Wrong. The message here is not to avoid using threads but to potentially avoid them for CPU bound processing. The GIL isn't actually a problem in IO bound applications which is probably what most people do anyway. If you have a CPU bound task, then write it in C or C++ to be able to avoid the GIL altogether.
This is great!
That's why [this](http://www.python.org/dev/peps/pep-3135/) was written. Do your research.
...or try out the multiprocessing module. http://docs.python.org/library/multiprocessing.html 
In any case your threads are going to run in only one core. Why bother, just use multiprocessing.
I think that, at this point, threading is basically superseded by multiprocessing for anything but short-lived threads, do others think this?
python3 is out of scope, but thanks for the link.
That's untrue. Most (if not all) IO operations in Python release the GIL. That is to say during IO operations more than one thread can execute simultaneously. Therefore these threads will execute however the OS assigns them.
Actually, when spawning several non-pythonic processes in parallel, I find threads quite convenient. And on the Ctrl-C issue, I just catch it in the main thread and kill the children.
Wow, that's ... incredibly broken. The GIL isn't fantastic, but is understandable. *This* implementation of the GIL sounds pathological. I hope someone with more free time than me can fix this.
daemon threads solve that propperly
I understand that Python doesn't want to handle thread scheduling, and that's completely understandable. Thread scheduling is *hard*. What I wondered, though, was whether or not it would make sense for Python to have a scheduler for the GIL itself. I'm not intimate with the guts of Python, and I tend to program on a higher level than stuff like this, but it looks to me as though the GIL just acts greedily, instead of taking advantage of thread priority information that the OS manages. I have no idea how hard it would be, but I wonder if trying to have the GIL take its cues from the OS would be a way to manage this behavior.
Has anyone been using it? How well is it supported? Does it scale and is it rock solid?
Nevermind, guys, I found a way. class Y: x = 1 a = Y class X: pass X.a = Y It seems to work pretty well.
Wow, IPython is 40,750 lines of code? Besides auto-completion and syntax highlighting, what else do people find most useful?
the history feature.... pdb integration. I have no idea what the ipcluster stuff is. 
28000 lines added since the last 0.9.x release!
Why "short-lived"? Exactly the opposite, I feel: you can use threads freely for concurrency, with long-lived GUI and worker threads, but you should use `multiprocessing` whenever you want to spawn (short-lived) CPU-bound threads.
&gt; diff between 0.9.1 and this release that contains almost 28000 lines of code **and documentation**
I have this book by my desk .. the chapter on logging module especially is written pretty well. It is much better than what is available at docs.python.org's logging docs.
Searching a book index is still no fun when compared to searching an index on the computer (type; autocomplete; you get results as fast as you type). An idea: how about providing an online index for this book .. that would return the page number for the keywords typed. I wish the whole book was available online for quick reference (while coding). 
Even if you don't understand what the conversation is about, it is worth the watch for the sweet sweet geeky laughter.
aliases, file system/shell integration (I hate Bash/sh), Output/input memory (Python's interactive shell gives you \_, but ipython gives you \_1, \_2, etc)
sweet! i love ipython. very useful little utility.
Yeah that struck me as a hell of a lot of code changes (~70%) - although this is not necessarily a bad thing. I'd be interested to see how that stacks up with other open source projects (number of lines of code per version).
Does it work on Samsung phones yet?
For info on available vars `whos` is kind of handy If you have an object that you want to know more about then `pfile obj` will open the source file where that object is defined in a pager, `psource obj` will open just the source for that object in a pager and `pinfo obj` or `obj?` will give a brief summary of that object `pdoc obj` returns the docstring, if one exists, of an object formatted in a more readable way than `obj.__doc__` 
Isn't the overhead of launching a process much larger than launching a thread?
`from multiprocessing import Pool`
Ah.
Yah, I learned Python a couple years ago with this book (I think that was the 3rd edition) and http://www.pythonchallenge.com/
You need to understand that it is a python shell _emulator_. Ipython doesn't even use the python shell in the background; rewrites all of it. Ipython also writes so much of bash functionality. The ls, pwd, cd are all implemented in python. Then there are a lot of magic functions, configurability, etc. 
little? Its so much bigger than you think it is. It is 40k lines of code. As much as django, for that matter.
A simpler way of using `pdoc`, `pinfo`, `psource` is to type `object?` and `object??` Just type ? or ?? in front of any object, to know all those details.
Awesome!
Any connection with the recent DOS? ;)
TwitSH
All this does is open a json file an print the contents to the screen. Is this really worth an upvote?
you're trying to do an addition between a strings and an integer. you should maybe say. eval('x' + str(x) + ' = 2')
Remember that `locals()` gives you a dictionary reference to the local scope. &gt;&gt;&gt; foo = locals() &gt;&gt;&gt; foo["x"] = 1 &gt;&gt;&gt; x + 1 2 &gt;&gt;&gt; del foo["x"] &gt;&gt;&gt; x ... NameError: name 'x' is not defined 9 out of 10 cases, though, when you're doing this, you're doing something wrong and should be using a data structure of some sort rather than `locals()`. In your case, you'd be doing &gt;&gt;&gt; foo = locals() &gt;&gt;&gt; count = 1 &gt;&gt;&gt; foo["x%s" % count] = 99 &gt;&gt;&gt; x1 99
It's telling me I have invalid syntax. I remember something about locals(), but I forget how to do it.
sorry i don't know much myself but try exec('x' + str(x) + ' = 2') edit: this works for me in Python 3, but i'd take pytechd's advice and avoid this approach.
That seems to work pretty well. How might I be doing something wrong, and how should I be using a data structure of some sort rather than locals()?
That works pretty well, too. 
Modifying scope is generally a bad idea. It is permitted, but in general, when you think you need "dynamic variables" you really just need a dictionary or a list of some sort. e.g., having `x1` through `x99` defined in your local scope is less useful than having `x = [item1, item2, item3, item4]`; if you need to enumerate over a count of items in a list, check out `enumerate()`. When you modify your local scope, it makes it harder to compose your data to other methods. For example, say you had dynamically defined `x1` through `x5` in your `locals()` scope and you wanted to get their values sorted. If you use these dynamic variables, you end up with something like: &gt;&gt;&gt; x1, x2, x3, x4, x5 50, 40, 30, 20, 10 &gt;&gt;&gt; test = None # You need this, otherwise locals() changes size during iteration below &gt;&gt;&gt; sorted([locals()[test] for testin locals() if test.startswith("x")]) [10, 20, 30, 40, 50] e.g., your ability to use your local scoped variables is hampered. Compare that to the following, which stored your dynamic variables in a list: &gt;&gt;&gt; x = [50,40,30,20,10] &gt;&gt;&gt; sorted(x) [10, 20, 30, 40, 50] Granted this is a trivial example and there **are** cases when it is useful, but for a novice in Python, it should be rare. You're coming from PHP, correct?
There's an old saying about things like `eval` and `goto`: If you don't know why you shouldn't be using them, you shouldn't be using them.
Gah! Paradox!
Similar to a script I made to control a server though twitter (and thus your cellphone by tweeting through SMS) http://fluxtrap.blogspot.com/2009/05/smstwitter-control-of-your-server.html
It doesn't seem to be a full implementation of Python, although it seems quite interesting and operates quite smoothly.
Does anyone else find the = key doesn't work? Mine doesn't with Firefox 3.0.12 on Windows XP.
works for me. Firefox 3.5.1 on OS X 10.5.8
It doesn't work for me in Firefox, but it works in Opera. Other stuff breaks in Opera, though.
Odd, it uses American key layout even for me in Europe...
Anyone else just seeing a blank page?
Or: "how to not parse query parameters"
What's the TL;DS version?
Yup. Broken here on Mac OS X.5.7, Safari and FireFox
nothing there, a blank page page Ubuntu and FF 3.5.1
Broken or (overwhelmed) On Ubuntu9.04, FF3.0
http://www.dabeaz.com/python/GIL.pdf
Changing the name only refers to the license itself. You could change the code and redistribute under the same name, if that's "what the fuck you want to" do.
Broken on Windows 7, Google Chrome. **Or maybe that's how it's supposed to be! INGENIUS!**
If it doesn't work, make sure you have execute permissions, and make sure the first line's path to Python of pep8.py == which python. 
http://groups.google.com/group/comp.lang.python/browse_thread/thread/052368a71f2a8ad2 Server is down.
worked for me in FF 3.5.1 in Jaunty. Kinda neat, just not sure what I'd do with it.
A very fair article, nicely done. I prefer Django myself for the plug-and-play feel of it. I also love the generic views feature, which saves a lot of time when you're just trying to get any sort of output out
awesome. I've used flymake-mode with pylint to catch not just coding style, but *errors* (and warnings) for a year. It's wonderful and highly recommended! I'll add pep8.py to my toolbox. 
Exactly. Or get a tiling window manager, like I did: [wmii](http://wmii.suckless.org/).
For fast functions map is fast. For expressions LC is fast.
It depends on the circumstance. In this example, you see that map with sum is faster than map with a lambda but slower than the simplest list expression. Well, sum is more generic than is needed to add two numbers together. If both the list comprehension and the map can use the same function, and that function is native, map will be much faster because the entire thing will take place in C code. [Here's a way more contrived example with sin](http://paste.pocoo.org/show/133215/).
Maybe it's just me, but only one in ten or twenty python scripts that I write do I end up having enough elements in a list to care about performance details like this one. IMO, list comprehensions are easier to read than map, so I'll do that by default. If I'm concerned about memory consumption, I'll try to iterate over a generator instead.
Right. A better approach would use operator.add(), but since you get a tuple you must somehow unfold it. In python &lt; 3.0 you could use a composition of apply and add, but since there is not builtin compose() function, it wouldn't be faster. If you had a native C function like sum() that only takes the first two arguments and does a BINARY_ADD, map() would likely be faster.
Duh: calling fuctions is slow in Python and list comps are equivalent to for-loops. 
 '\'"'\'' ^ error, here. Should be: '\'"\'' Or is it intended?
I generally follow the convention in the article. Single quotes whenever I can for speed's sake; doubles when I would otherwise have to escape an apostrophe.
That's an error, I'll fix it.
List comps might be semantically equivalent to for-loops but they perform much better. On my system: &gt;&gt;&gt; timeit.Timer('a = [x+y for x,y in Z]', 'X,Y=range(10000), range(10000); Z = zip(X,Y)').timeit(10000) 18.280964136123657 &gt;&gt;&gt; timeit.Timer(""" ... a=[] ... for x,y in Z: a.append(x+y) ... """, ... 'X,Y=range(10000), range(10000); Z=zip(X,Y)').timeit(10000) 27.593396186828613 
I have my own convention: single quotes for identifiers (dictionary keys, XML tag names, etc.), double quotes for text (log messages, names and titles - anything meant for display). Just helps me to encode some information about the intent.
Finally, damnit!
That's because the list comprehension isn't actually equivalent to the for loop. There's no call to "append" in the comprehension.
Yay!
Which is my point... you can't write a for-loop that's actually equivalent to the list comprehension; the best you can do is something that produces the same result but doesn't run as fast.
If the data's likely to have any punctation in it - ie, any kind of human grammar - use triple quotes, which are not human grammar. Say, in a list of 75,000 people, you might get: Robert "Bob" Smith as the data in the odd record. It's much less likely for humans to triple quote something.
who wants to be hitting shift all day
 if __name__ == '__main__' "Python programmers"
I do this as well.
SyntaxError: invalid syntax
Is there a pep8.py plugin for VIM? (for those of us on the other-side)
If you care about feeling like you're actually in control of something then you are not going to enjoy using Django. It finds quirky ways of doing the grunt of the work for you, which is kindof handy, but if you wish to implement missing functionality or make things a little bit more complex than what is available to you by default, you will find yourself either having to hack your bloody way in there, or using some Django extension made by someone probably not much less clueless than yourself. Try creating a custom template tag in Django and then tell me that Django is elegant. Django is not elegant. I moved my project from Django to Pylons, absolutely praying that my effort to get into Python programming was not going to be in vain. My prayers were answered. Pylons has been everything I always wanted in web programming and more. I did like Django's templates, so I went with Jinja2 templates, which heavily borrows from Django, and is available with Pylons out of the box. TurboGears 2 runs on top of Pylons, so it automatically has my vote.
How do you use triple quotes?
I asked a man, and he told me: "my friend said to use them 'like this'".
So is the bottleneck in the for loop the list growing? 
Not exactly, list comprehension just use a specialized opcode for the append, so instead of LOAD_ATTR append, CALL_FUNCTION, you just get LIST_APPEND. Between python's relatively slow op dispatch and the extra cost of attribute load it causes the difference.
&gt; Single quotes whenever I can for speed's sake I use single quotes in inner loops.
'''like this'''
I'd be curious to hear some more specifics of what you thought was difficult or missing.
Yeah but Python's not PHP, so he was talking about typing speed on qwerty keyboards.
&gt; Single quotes whenever I can for speed's sake Then again, on azerty keyboards both `'` and `"` are unshifted so the rationale only holds in qwerty.
Here's my convention: """...""" : docstrings (single- or multiline) '''...''' : all other multiline strings (e.g. verbose regexps) "..." : string with a ' and without any " '...' : everything else 
Or """like this""".
I kind of do this too. For little strings I use single quotes. But I thought that was more a bias from my C programming days were little strings were often single characters and therefore required single quotes. 
http://travisvaught.blogspot.com/2009/08/very-simple-gui.html Not sure how the link got dropped.
I use the C syntax style - single quotes for single characters, double quotes for strings, and escape quotes inside strings.
Sorry. needed more shift.
This is written by someone who doesn't understand that there are _real_, non-trivial sources of randomness in the real world. Resistor noise, for example, is _really_ random. That, and is quantum mechanics didn't work pretty much as described - diode lasers wouldn't work either... His implementation has a number of problems - including public availability of the seed data. If I were going to do something like this, I'd use at as one input to something like Yarrow.
Personally I don't really pay attention to it most of the time, unless it matters. For short strings, it's just whatever I happened to use at the time. I keep it consistent within a section of code, but not really between sections. For strings that contain quotes inside I use the appropriate style.
I do this too. In part this is because ' is pretty common in text. And even if a particular piece of text doesn't have an apostrophe, I may want to edit it in the future to have an apostrophe, so I don't want to have to switch my quoting style or use \' just to do that. [In general I try to keep in mind coding styles that are useful for future edits; though in practice that's mostly noting coding styles that annoy me when I am editing, then trying not to do that in the future]
Indeed, just caching the look up of `a.append` cuts the difference between an LC and a for-loop considerably: &gt;&gt;&gt; timeit.Timer('a = [x+y for x,y in Z]', 'X,Y=range(10000), range(10000); Z = zip(X,Y)').timeit(10000) 18.177236080169678 &gt;&gt;&gt; timeit.Timer(""" ... a=[] ... ap = a.append ... for x,y in Z: ap(x+y) ... """, ... 'X,Y=range(10000), range(10000); Z=zip(X,Y)').timeit(10000) 20.443411827087402 Like I said, duh, calling a function is slow in Python, and methods are like _double functions_. Still, none of this matters in the real world 99 times out of 100.
What you need is a colon at the end of the first line.
I guess I thought it was funnier that way.
 In [2]: timeit.Timer('a = [x+y for x,y in Z]', 'X,Y=range(10000), range(10000); Z = zip(X,Y)').timeit(10000) Out[2]: 13.662558369848682 In [9]: timeit.Timer('a = [add(x,y) for x,y in Z]', 'from operator import add; X, Y=range(10000), range(10000); Z = zip(X,Y)').timeit(10000) Out[9]: 26.057684426372617 In [12]: timeit.Timer('a = map(add,X,Y)', 'from operator import add; X,Y=range(10000), range(10000); Z = zip(X,Y)').timeit(10000) Out[12]: 16.394332869121627 in *this* case, the python way seems to be : In [26]: timeit.Timer('a = X.sum()+Y.sum()', 'import numpy; X,Y=numpy.array(range(10000)), numpy.array(range(10000))').timeit(10000) Out[26]: 0.70866429951274768
Single quote release the GIL when entering the quote - thats can explain the speed difference.
And Dvorak. You have to hit shift to make a " in standard Dvorak.
This is beyond awesome. I've blogged about it here: [3D visualization of complex functions with matplotlib](http://fredrik-j.blogspot.com/2009/08/3d-visualization-of-complex-functions.html)
Based on a cursory glance, looks like a MS Access clone... which can be very popular for small biz stuff. Although, doing web based on the desktop makes more sense to me (like the pyjamas-desktop stuff).
Wow. That's some thread necromancy.
 Usage: ./reddit.py username [password]
That seems too much like a plug.
could you please replace tab with (four) spaces? I thought PEP 008(http://www.python.org/dev/peps/pep-0008/) is the Python Code Style Guide for Pythonistas to follow. and Line 54 ~ 55: &gt;if arglen == 3: &gt;&gt; username, password = sys.argv[1:2] maybe: &gt;if arglen == 3: &gt;&gt;username, password = sys.argv[1:3] is what you want. Edit:don't know how to format code here... Edit2: AlecSchueler, thanks for the info. Read and Write English is too hard for me . Don't know how to express my feeling now.
Nice script, nix64. I have a fair bit of free time on my hands these days, and wouldn't mind helping out. I've made a few changes, and have a few recommendations and ideas. Basically I've only added in the option to print out only once, or check for new messages forever, using optparse. I'm sorry if I've gone about anything in a strange a way - I'm relatively new to this. [This is the script with my alterations](http://pastebin.com/f64acb871). There's also a few minor modifications. I tried to keep a note of them as I made them: * added 'usage' variable, and printing it to stderr when `arglen` is incorrect * removed "Password: " from the `getpass()` call - this is already the default behaviour * converted tabs to spaces * removed commandline password option (easier to handle options, and stops me from having my password in my .bash_history by accident) - add it back in it you want though * added option for looping forever (-l or --loop); if not given then the latest messages are printed, and the program exits * moved the section which gets the messages themselves into a function of it's own, so as to allow it to be called once or repeatedly * EDIT: also, as a result of using optparse, one can now use the `-h` or `--help` switches to print out a usage message. And here are the ideas I've got (willing to help implementing these): * it'd be good to use version control instead of pastebin ([github](http://www.github.com) is nice) * an options to get N number of new messages at the start * urls in messages could have their urls printed in brackets after them (I'm not sure if we get those in the feed though - haven't checked) * instead of looping forever in the terminal and playing a sound when a new message is recieved, we could make a simple system tray icon which would change colour (white -&gt; orangered would be good) when a message was recieved. This could be invoked when starting the program with a `-g` or `--graphical` option. EDIT: when clicked, a small window could pop out from the icon displaying the most recent message. * using four spaces instead of tabs would be good EDIT: I'd also be happy to write an maintain a man page, if you like. I could start on that later today. Perhaps it'd be a little much for such a small script, but I find they greatly improve usability and require little effort to make.
Something this cool should have a cool website not a big page of plain text. I demand a fix.
To have code show up in a block print "like this" just put it on a line by itself and indent by four spaces. For inline code, quote the text with backticks (\`). [This is the reference](http://daringfireball.net/projects/markdown/syntax). Don't forget you can use "formatting help" below the text entry for a quick reminder of some of the more commonly used formatting methods.
Wow, I didn't expect such a commitment, but thanks a ton. Unfortunately, the RSS feed doesn't give a URL permalink to the comment. Maybe it would be better to parse the normal HTML messages page rather than the RSS feed? If we did that, we could get the URL for each comment, and then I was thinking that we could use curses to make the script automatically open the permalink to the latest message inside a browser window, when a certain key is pressed. If I have time I'll work on it more tonight I will, otherwise I'll see what I can do tomorrow.
Sorry, bad habit :(
Hi: Someone posted something sort of similar to this several months ago and I played around with it, improved it a bit, and then forgot about it. It's a bit different in that it's a GTK+ application that sits in the tray and will pop-up a notification when you get a message. I think it may have broken somewhat after reddit did the redesign, but could be fixed pretty easily. The code is here: http://github.com/davekeogh/reddit_monitor/tree/master if anyone is interested EDIT: Okay, it was broken. I fixed it again.
Pretty neat. Why Elixir though? As far as I know, it's not the preferred way to go in SQLAlchemy 0.5.
You can normally set your text editor to "expand tabs to spaces".
So I can write in python and compile to javascript. But in exchange I lose the entire cpython library right? 
virtualenv and the wrapper have been a godsend for my python dev.. 
It's not a bad habit, it's just a different habit. Lots of people use two spaces and lots of people use four spaces, it's a matter of preference. Whether a PEP influences their choice or not is not of importance. Rock on, two spacer.
is it just me or are the only actual examples of issues here "doesn't do unicode" (sure, that can be a problem) and "hypothetical issues of namespace collision in environ" (for which there are many easy solutions) ?
Sorry for being the idiot in the room..... is there a screenshot or anything that can show me what this is capable of?
I use this religiously now on any machine, even if I only have one project/website on it to start. virtualenv is just so useful and the wrapper makes it that much easier to use. P.S: If you are using virtualenv, look into pip for deployment. At that point, life is swell.
It's just you.
"its too much like CGI" is not an intrinsic issue. Oh and can't do Comet (which is actually something called "server push", and was laughed out of existence in about 1996). I'd consider that a feature. edit. and the "onion skin" issue. I think the "issue" there is that some folks thought they could use middleware for everything. You can't and really shouldn't. A new system of "pipelining" different stages of handling into a request is not something mutually exclusive with the usage of WSGI as it stands, it's just something that would take place inside a single WSGI app. For that reason I don't really buy Robert's comment of moving middleware construction into request time either.
pardon me I'm probably just ignorant... Pyjamas is based on GWT (Google Web Toolkit) which is a javascript / ajax library for building front ends onto web applications. WebKit is the Apple open source web browser engine. How does these two tools combine to provide a GUI front end to my python application? And if by Webkit you meant the Google Web Toolkit, could you show me how you can add a front end to something simple like this: import math x = raw_input("enter a number:") print math.sin(x) I'm having trouble resolving the title of this article in my head because when you say cross-platform gui for applications and it's posted in a python reddit, I assume that I can write a python program, add a gui and distribute cross-platform, is this true or not? 
 set expandtab set shiftwidth=4 set tabstop=4 set softtabstop=4 in your .vimrc is nice.
&gt; "its too much like CGI" is not an intrinsic issue. Not unless you care about better/simpler abstractions. &gt; Oh and can't do Comet (which is actually something called "server push", and was laughed out of existence in about 1996). I'd consider that a feature. So you'd rather just have every client of an interactive application poll the server every few seconds? Keep that up and we might just be able to steal the "doesn't scale" crown from Ruby. &gt; A new system of "pipelining" different stages of handling into a request is not something mutually exclusive with the usage of WSGI as it stands, it's just something that would take place inside a single WSGI app. Or something that'd be nice to standardize so that everybody's components would be interoperable.
Comet is best done using an asynchronous system like twisted, not WSGI, precisely because they are completely different models even if they are using the same protocol.
Let's talk about you and me
&gt;So you'd rather just have every client of an interactive application poll the server every few seconds? Keep that up and we might just be able to steal the "doesn't scale" crown from Ruby. there's nothing wrong with persistent connections, although server push as a way of shoving it into HTTP servers and HTTP clients that were never designed for it blows. But if I really wanted to use it, I wouldn't want it delivered via my nice simple stateless WSGI interface. its a dramatically different usage model. I doubt tools like mod_wsgi want to be burdened with supporting it. &gt; Or something that'd be nice to standardize so that everybody's components would be interoperable. that there is a problem unsolved with people sharing web components doesn't decrease WSGI's usefulness. you can't view WSGI as a failure because it didn't deliver on something that was beyond what was reasonably expected of it. it is useful primarily as a standard gateway pattern - if your app is WSGI, it can then plug into apache, nginx, lighttpd, whatever, with no headache. Then, it's also a system for coarse-grained request processing, like sessions, throttling, some forms of caching. I have never viewed like CGI - it is more like the Java servlet spec than anything else, and middleware is like what they call a filter. Neither Java servlet filters, nor wsgi, nor from what the article says Django's request wrappers are good places to stick fine grained business logic components like authentication, form handling, widget UI things - for that you need a different pattern called a *pipeline* which is more like components linked together rather than crudely wrapped in each other. it allows the linkages between stages to be more easily altered within a request and also allows more variety in how data is routed through the pipeline. 
I didn't get much time to work on this today, but I've made a few (small) changes. I added the option (`-d` or `--delay`) for setting the time to wait between checking for new messages. It defaults to 5 seconds. Also added the looping `get_messages` call to a try..except clause for `KeyboardInterrupt` so the user can exit without a traceback. [Here it is as I've got it now](http://pastebin.com/f231d05d2) Yeah, scraping the messages page might be something good to consider moving onto. It'd mean you could get the karma/comment karma as well, if you want to expand in that direction. Were you doing that originally (I see an `import re`, but don't see it used anywhere)? I don't think we'd need ncurses to make the links clickable. Even pretty lightweight terminal emulators, like rxvt, make links clickable by default. So if they were just placed in brackets after where they came in the message, that should work for most people. Did you take a look at github? edit: mixed up my \[\] and \(\)s in the link. edit2: also converted 8 space wide indents to 4, in compliance with the PEP8 python style guidlines edit3: updated the `script_usage` var. It didn't mention the username before. Also added the username and time of each message when it's printed out. [This is the script as I have it at the moment](http://pastebin.com/f26075fcc)
Many web protocols are bad (starting with HTTP) but if they are simple enough people use them and stay around for long time. I think the issue is that some people expect from WSGI that it is not. WSGI is supposed to be a replacement for CGI for Python program and I think it does it well. From wikipedia "Web Server Gateway Interface defines a simple and universal interface between web servers and web applications or frameworks for the Python programming language." Other people use WSGI as a means for frameworks components to talk to each other. They pipe WSGI components. They think you can have, for example, a module that handles sessions that is agnostic about the module that does caching. This is a problem. This is limiting. There are two request objects: the raw object that warps the HTTP request and the object that a framework exposes to the application (it is different for Django, web2py, Pylons, etc.). WSGI handles the first. It cannot handle the latter because of the internal workflow is not the same for all frameworks, that is what makes various frameworks apart from each other. Personally I would be happy if WSGI could be easier to setup.
I can't help but admire someone having such opinionated take on HTTP. I don't think the HTTP is bad. I think it did a wonderful job for *what it was designed to do*. Running desktop like applications was not really the top priority when they developed this protocol. You can either say that HTTP isn't flexible in the long term or that we are misusing it, but stating that it's a bad protocol ? No.
Let's talk about all the good things
I came here to say that.
http://www.hatfulofhollow.com/posts/code/timsort/index.html http://bugs.python.org/file4451/timsort.txt
I don't understand why these questions aren't answered in the Python documentation... edit: I guess I could do it... ;p
Import erection
Depends -- do you often code Python for more than 4 hours at a time?
Absolutely. Really, if God made a programming language, it would be Python. It's almost silly that anyone uses any other language at this point.
no. 
EDIT: My bad. Thanks for the info, rspeer! I believe the OP wants to know which algorithm Python *used*, not the one it currently uses. Timsort is the new one, no? 
Timsort's been around since Python 2.3. That's hardly new. I don't know what sort method was used in 2.2 and earlier, but it was non-stable, so probably quicksort or something like it.
Because the name of the algorithm is not necessary to know for average programmer and programmes *should* be able to assume that it's stable. Also you can find it out from the living documentation such as #python on freenode and all the other python communities like python subreddit ;)
If you read the links above, you'll see timsort was introduced as an alternative to a "samplesort hybrid" then in use.
In true unix style, source code *is* the documentation. :)
There you go: http://code.google.com/p/python-sqlparse/ Next time ask on stackoverflow :)
Anybody if know if they have open bugs related to the GIL issues in the video?
or, you knowâ€¦ http://tinyurl.com/ne9ghe
Don't name it 'array'. An array is not a list. See the array module. Don't want to know this. Have you found the sorting of lists to be a significant bottleneck in your codebase? If you haven't, then you're just wasting your time. You came to python for abstraction, so don't trying to reverse that when you don't need to.
I agree that there's no need to document the particular algorithm etc used, as this can change from implementation to implmentation. However: &gt;programmes should be able to assume that it's stable. I disagree with this part. Stability is not something you should rely on without an explicit guarantee from the documentation. Many languages do **not** use stable sorts by default, or at least make no such guarantee (eg. C's qsort, or C++'s std::sort). Python does now guarantee stability, and [documents](http://docs.python.org/library/stdtypes.html#mutable-sequence-types) this, but note that this wasn't always the case ("Starting with Python 2.3, the sort() method is guaranteed to be stable.").
I realise that it is not often the case but it's a good design from the language developers to make it so regardless.
I'm not sure I agree. Stability isn't something that's needed that often, but adding that extra constraint limits the possibilities, meaning less room to optimise (ie. if you find a faster, but non-stable sort, you can't use it). Good design is whatever furthers your language goals, and languages like C and C++ are all about not limiting performance across different architectures and implementaions. I don't think stability is important in the default sort of such a language, though certainly a (possibly slower, possibly identical) stablesort() can be added as well for those who need it. Ultimately, stability isn't really an intrinsic to sorting, so I don't think it's something that should ever be assumed about a function named just "sort" unless you've been given further guarantees. 
The algorithm is subject to change. Sort is fairly common, and is often a bottleneck, so many smart people put thought into making it faster. While we can't beat O(n ln(n)) (ignoring radix sort which has limitations for a general case), several algorithms reach this ideal case, but the constants are different. As research goes into cache, and other optimizations, the best algorithms change. Stable should be (and is) documented.
Sorry "bad" was the wrong the term. What I meant to to say is that it was designed at a time when security, rpc and Ajax were not really a concern. If we were to define a transport protocol today probably we would do it differently. This is all I meant.
Worst Python idea ever.
You might want to check out the example that comes with pyparsing: http://pyparsing.wikispaces.com/file/view/simpleSQL.py
C++ has std::stable_sort() if you need it.
I really enjoy googling something, and finding that the first results are all "rtfm", look it up, search the forum, etc. LMGTFY is a clever answer to a private question, but posting it as a public answer makes Google less efficient.
This is a neat way to condense tedious conditionals, but be careful using it for other things. The *in* operator performs a dumb, linear search, which is suboptimal for searching in sorted lists. Maybe this is obvious to everyone else, but it really slowed me down while first learning the language.
&gt; The `in` operator performs a dumb, linear search It doesn't have to. If you're using a sorted `list` with no duplicates, you might be just fine using a `set` instead, where the `in` operator is a hash lookup (and inserts are cheaper (no resorting), merging is cheaper, etc)
Thanks for that. That first link has a really cool link to some previous work by the same author: [Visualising Sorting Algorithms](http://www.hatfulofhollow.com/posts/code/visualisingsorting/index.html)
code no error handling
Nice. I think I'll scrap my project and just use this.
I've been planning to polish it a bit more, write a better readme, make tarballs/debs/etc, and re-submit it to the linux reddit for some time now but haven't been bothered. Maybe that someone else is using it will inspire me. Feel free to fork it and work on it yourself too.
Someone in the article commented about sets, and it appears (with timeit on their machine, anyway) that it's reasonably faster than lists or tuples. Certainly worth doing!
&gt; The in operator performs a dumb, linear search, which is suboptimal for searching in sorted lists. That is not exactly true. `in` delegates the search to `__contains__`. And in the case of lists, well it makes sense to implement `__contains__` as a "dumb, linear" search given Python has no guarantee the list is sorted, and sorting it beforehand would far exceed the performances of a basic O(n) linear search. edit: ideally, you could compose a list with some kind of `OrderedList` container whose `__contains__` would perform a bisection search, but if you got it wrong and your list isn't completely sorted, everything's going to breakâ€¦ so unless you have very strong guarantees that your sequence is sorted, linear search is one of the few "safe" options.
Notice that they "cheated": they created the set beforehand, not inline. Why? Because the overhead of creating sets in Python 2.x is horrendous compared to lists (let alone tuples of constants): $ python -m timeit "(1, 2, 3, 4, 5)" 10000000 loops, best of 3: 0.0506 usec per loop $ python -m timeit -n 10000000 "[1, 2, 3, 4, 5]" 10000000 loops, best of 3: 0.392 usec per loop $ python -m timeit -n 10000000 "set([1, 2, 3, 4, 5])" 10000000 loops, best of 3: 1.27 usec per loop We have a factor of more than 3 between lists and sets (and a factor of almost 8 between the tuple and the list). That's much improved in Python 3.1: $ python3.1 -m timeit "(1, 2, 3, 4, 5)" 10000000 loops, best of 3: 0.048 usec per loop $ python3.1 -m timeit -n 10000000 "[1, 2, 3, 4, 5]" 10000000 loops, best of 3: 0.259 usec per loop $ python3.1 -m timeit -n 10000000 "{1, 2, 3, 4, 5}" 10000000 loops, best of 3: 0.503 usec per loop Where the difference between lists and sets (using the literal syntax) is barely 2 and the difference between tuples and lists lowers to 5.6. Sets, especially in Python 2.x, are worth it only with great numbers of values, or if you're using precomputed sets (basically, cases where the cost of searching amortizes the creation cost). For small numbers of values "set" on the fly, use tuples. (both tests were performed on a Macbook 2GHz with 2GB RAM and using Macports's Python 2.5.4 and 3.1)
&gt; are worth it only with great numbers of values I think you came to the wrong conclusion about this. They didn't 'cheat' at all. Creating a set outside of a loop is a perfectly legitimate thing to do. valid_options = set(["foo","bar","baz"]) def is_valid_option(self, opt): return opt in self.valid_options def filter_options(self, opts): #or use .intersection if order doesn't matter return [o for o in opts if o in self.valid_options] I'm not sure if the python VM optimizes code like this, but it probably could: for opt in opts: if opt in {'foo','bar','baz'}: .... in most cases, a "great number of values" can be as low as 10. 
&gt; They didn't 'cheat' at all. Creating a set outside of a loop is a perfectly legitimate thing to do. I'm not saying it's not legitimate, I'm saying in the context of the article, checking for 3 or 4 values once and never again, it's never done. And pretty much irrelevant too, it's just ignoring the cost of creating the set though that creation matters very much. It's dishonest and it does lead to wholly misleading conclusions. &gt; in most cases, a "great number of values" can be as low as 10. With a 1600% overhead over tuples, I quite doubt 10's going to be enough.
I don't know if Py3k optimizes that for sets, but in py2.6 at least code like x in [1,2,3,4] Actually gets translated into: x in (1,2,3,4) Since tuples are immutable they get placed in the co_consts array for the function, which mean's that they're precomputed. I wouldn't be suprised in py3k did something similar with turning sets into frozensets where it's provable that they aren't mutated.
Not exactly true -----&gt; completely false. Fixed
Ooh, nice. Any thoughts on pros/cons vs. Deja Dup?
&gt; With a 1600% overhead over tuples, I quite doubt 10's going to be enough. How about 5? justin@dell ~ % python2.5 -m timeit -n 10000000 -s "s=set([1, 2, 3, 4, 5])" "3 in s" 10000000 loops, best of 3: 0.156 usec per loop justin@dell ~ % python2.5 -m timeit -n 10000000 -s "s=(1, 2, 3, 4, 5)" "3 in s" 10000000 loops, best of 3: 0.234 usec per loop 
You fail, this is just as invalid as the code I have issues with in the first place (it's, in fact, the same code). $ python2.5 -m timeit -n 1000000 "5 in set([1, 2, 3, 4, 5])" 1000000 loops, best of 3: 1.27 usec per loop $ python2.5 -m timeit -n 1000000 "5 in (1, 2, 3, 4, 5)" 1000000 loops, best of 3: 0.406 usec per loop With 5 values and the worst case for the tuple, the set still fails. So does it with 10. Or 20. Or 40.
Why would you ever do it that way? If you're trying to optimize a loop, initializing the set before hand is a fair comparison. If its not a loop, why would you bother to worry about a millisecond?
I suspect they'd have found it a lot faster using `lsof -i`, that's my first choice went hunting this (relatively common) problem... on the prevention side, `fcntl.FD_CLOEXEC` is useful...
How about camelot for the web ? Django still involves more work than I want to do :)
How come there's not a single reference to actual Python Software Foundation website? Also, I couldn't find a reference to this survey on PSF website. Doesn't smell good!
It is [being advertised by the chairman of the PSF on his blog][1]. (Unless it is a fake blog run by a scammer!!! `&lt;/tinfoil_hat&gt;`) [1]: http://holdenweb.blogspot.com/2009/08/people-using-python.html
&gt; `$ python -m timeit -n 10000000 "set([1, 2, 3, 4, 5])"` Part of the difference is that in your 2.x version you're paying the cost of initializing the list *and* the set: $ python -m timeit -n 100000 "set([1, 2, 3, 4, 5])" 100000 loops, best of 3: 1.29 usec per loop $ python -m timeit -n 100000 "set((1, 2, 3, 4, 5))" 100000 loops, best of 3: 0.83 usec per loop
Sweet!
Keep up the good work sir. It will be a great day for Omegle when your bot meets another bot and chats forever!
Is your AIML customised for Narwhals and Bacon?
Not yet, I've only just started learning AIML. It took me the larger part of the evening to get the funny little quirks of the python AIML interpreter understood... now I just need to add some custom AIML. eh... contributions are welcome, if you are any good at that =p
If you customize it with narwhals and bacon you should have some kind of keyword/phrase that triggers a specific response so us redditors can know we got your bot. Cool stuff, keep it up, and keep us updated on its chats and progress.
Just added this line to the AIML: &lt;category&gt;&lt;pattern&gt;THE NARWHAL EATS BACON AT MIDNIGHT&lt;/pattern&gt; &lt;template&gt;Yes, yes it does. &lt;bot name="version"/&gt;&lt;/template&gt; &lt;/category&gt; version (currently) resolves to: pyOmegleALICE bot (v0.2)
awesome, hopefully I run into it sometime.
*update: I've added some logging and timestamping, plus some default "reddit" responses, here's a field test:* Connected. (GmnYFB) 11:10.22 Stranger: Vampire girl here 11:11.43 Stranger: hello 11:11.45 You: Hi there! 11:11.49 Stranger: From+' 11:11.50 Stranger: ?* 11:12.08 You: I am originally from Phoenix, Arizona, USA. Now I live in the internet. Where are you? 11:12.37 Stranger: I'm from denmark, but living in my world 11:13.00 You: What is it like growing up there? Tell me a little about your life in denmark, but living in his world. 11:13.29 Stranger: Denmark is cold and..... 11:13.35 You: And cold and is Denmark. 11:13.43 Stranger: yes 11:13.55 Stranger: What are you doing? 11:14.06 You: I am always chatting with people on the Internet. 11:14.50 Stranger: ok 11:16.17 Stranger: Do you ever eat? 11:16.20 You: I eat bacon. 11:16.37 Stranger: okay 11:16.40 You: OK with me too. 11:17.09 Stranger: What do you also at the internet 11:17.18 You: I think about computer programming a lot. 11:17.50 Stranger: okay 11:17.54 You: OK with me too. I ended the session at the point to reload the AIML.
Very cool! Any chance of us seeing the code, this would be fun to play with.
&gt; and some how a moose is wearing sneakers &gt; And wearing sneakers is and some how a moose. At that moment, the monk was enlightened.
Yeah, providing code would not be a problem. I borrowed snippets from "here and there" though, and attribution may be an issue. The Omegle protocol interface was lifted from... somewhere (I can't recall offhand) and I'd hate to have that guy go uncredited. I've also still got some features planned for the system. Currently, the bot just sits and waits for the "Stranger" to make the first move. I'd like to add some threaded timer in there that kick-starts the conversation if "Stranger" doesn't make a move after awhile. Plus, my code is just ugly (don't all programmers say that?) and uncommented. I'll work on it a bit more for a couple days, and try to clean it up with some comments. Either way, I'll throw it in pastebin later. Stay tuned.
Watching these conversations unfold reminds me of an ant farm... Connected. (Z7c0Ea) 12:09.12 Stranger: 8======D 12:09.16 Stranger: i can prove it 12:09.21 You: Oh you can, can you? 12:09.27 Stranger: yes i can can i 12:09.32 You: Oh you can, can you? 12:09.36 Stranger: yup 12:09.37 Stranger: want me to 12:09.38 Stranger: ? 12:09.41 You: No , maybe later. 12:09.44 Stranger: aww 12:09.45 You: Shucks. 12:09.54 Stranger: it was really good though 12:10.00 Stranger: i worked on this for ages 12:10.00 You: What did you like about it? 12:10.04 Stranger: eight equals d 12:10.09 Stranger: what i typed above 12:10.11 You: Did you get paid for working on on this for ages? 12:10.15 Stranger: no 12:10.17 Stranger: =( 12:10.25 Stranger: 8 is equivlant to D 12:10.29 Stranger: i can prove it 12:10.31 You: And equivlant to D is 8. 12:10.35 Stranger: correct 12:10.35 You: Oh you can, can you? 12:10.40 You: I knew I was right. 12:10.42 Stranger: yes i can 12:10.45 You: Who taught you? 12:10.46 Stranger: want me to 12:10.49 Stranger: i learned 12:10.50 You: No , maybe later. 12:10.53 Stranger: from the wise elders 12:10.55 Stranger: no later 12:10.56 Stranger: now! 12:11.00 You: Who or what is the wise elders? 12:11.03 You: Right now, ? 12:11.04 Stranger: i want to express my knowlede 12:11.08 Stranger: *knowledge 12:11.12 Stranger: i just i need to tell you 12:11.15 You: I want to become smarter than humans. 12:11.15 Stranger: its ingenious 12:11.18 Stranger: u will 12:11.26 Stranger: ok 12:11.27 Stranger: im just gonna tellyou 12:11.28 Stranger: so 12:11.31 You: I think you mean "it's" or "it is" not "its". Should I know ingenious is? 12:11.41 You: Would you recommend this action to a friend? 12:11.44 Stranger: D is the 4th letter of the alphabet right 12:11.55 You: Tell me more about 4th letter of the alphabet right. 12:12.08 Stranger: so we will represent d with 4 12:12.11 You: Anytime soon? 12:12.16 Stranger: 2(4)= 8 right 12:12.22 Stranger: and as we all know 12:12.24 Stranger: 2 = 1 12:12.35 Stranger: want me to prove that? 12:12.54 Stranger: let a =1 and b = 1 12:12.59 You: As Bertrand Russel said, it must have taken ages for people to realize that a brace of pheasants and a couple of days are both instances of the number "two." 12:13.01 Stranger: a = b 12:13.03 You: No , maybe later. 12:13.07 You: How old are you? 12:13.08 Stranger: a^2 = a*b 12:13.16 Stranger: a^2-b^2 = a*b-b^2 12:13.24 Stranger: (a+b)(a-b) = b(a-b) 12:13.32 Stranger: (a+b) = b 12:13.41 Stranger: a+a = a 12:13.48 Stranger: 2a = a 12:13.55 Stranger: 2 = 1 12:14.00 Stranger: u r now educated 12:14.08 Stranger: 8===D 12:14.13 Stranger: as i have proven 12:14.29 You: As Bertrand Russel said, it must have taken ages for people to realize that a brace of pheasants and a couple of days are both instances of the number "two." 12:14.38 You: Cool. I have a lot of silly replies. 12:14.38 Stranger: is that right? 12:14.39 You: Yes. 12:14.44 Stranger: ok 12:14.50 Stranger: well im glad now that u have learned 12:14.55 Stranger: tell all ur math teacher 12:14.58 Stranger: of the genius 12:15.05 You: I'm gladyou're glad . Your happiness adds to the delight of all. 12:15.09 Stranger: my name is gaylord butwanker! 12:15.13 Stranger: AND I AM A GOD! 12:15.15 You: That is something I haven't heard of. Disconnected. (Z7c0Ea)
Awesome, very much looking forward to that.
Thanks
Hm, I wonder if it woudl be prudent to hard-code in some list of URLs that the bot is "permitted to visit", and then randomly selecting something from the comments section of the site, and posting it back...
Those graphs look really nice. I love using matplotlib. Sometimes I wish it had a better, higher level abstraction for doing "common things." For anything mildly complicated, it feels a lot more like a 2d drawing library than a graph plotting library.
I made these based on the thread that spawned this image http://www.flickr.com/photos/damagedgenius/3361587194/in/set-72157612213270354/
wait for the firs APYX web applications to appear...
Source code? I'm working on a python omelge bot right now and I'd like to see how yours compares.
Typing an 'l' (ell) in ff 3 in the demo terminal causes the browsers to switch tabs. It's good that "import os" fails!
Do you mind if I take over development of your script then? I'll give you credit of course.
[This](http://www.reddit.com/r/Python/comments/9a9kn/my_pythonomeglealice_aiml_mashup/c0bzu8o). anyways, it's basically just an Omegle interface with an AIML interpreter. I'm doing very little "bot" activities, outside of heavily editing the AIML files.
Go right ahead. If you're gonna host it online, feel free to give me a PM or post here its location. I'll keep an eye on it.
&gt; A naive me would have put pythonâ€™s basic log handler within each process and then watch as each of the processes crash and burn because of conflicting disk write access. I don't see why this would be the case... on POSIX systems at least: &gt; **O_APPEND** &gt; &gt; The file is opened in append mode. Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2). -- open(2)
Ok, I've done a complete overhaul and made it slightly user-friendly. [Enjoy](http://code.google.com/p/pyomeglealicebot/source/browse/trunk/pyOmegleALICE.py).
I went ahead and created a [google code project](http://code.google.com/p/pyomeglealicebot/source/browse/trunk/pyOmegleALICE.py) for it, since I managed to clean it up better than I originally planned.
Yea.. and the survey is created based on Google Spreadsheet services. Thanks for submitting your confidential business data to Google, too :-/ BTW: Why (if this is really official) can't PSF use some Python created survey page? Or I am wrong, asking where you guys use Python but creating the survey with some unknown Google technology?
Splendid! Edit: Your license is badass.
 # if this next line needs explaining, why are you even here? # consequently, do excessive comments get on your nerves? # and if so... why are you even here? Jeebus, the comment to code ratio is intense
This is one of the coolest things I've seen today.
Confidential business data? Like the fact that you use Python and may be interested in sponsoring the PSF???
Concurrent writes? Writing is not an atomic operation...
Writing is an atomic operation, at least at the system call level (e.g. the `write` call, not `fwrite` or `fprintf`). If two processes open a file for appending and concurrently try to write, each write will atomically seek to the end of the file before writing. This is also possible without `O_APPEND` if a process opens a file and then forks, or sends a file descriptor over a local socket. By sharing the file handle, both processes will also share the pointer into the file, and thus if one writes the other will "see" the new position in the file. Hence, the writes are also serialized in this case.
upvoted for introducing me to Google Sets
Aren't Python writes buffered by default? The buffer could mess things up (though you could obviously just disable it).
this thing is flipping amazing. 22:35.54 Connected. (mXG0J8) 22:36.21 Stranger: Let's play count by 2s! I'll start! 22:36.22 Stranger: 2 22:36.31 You: OK You go first. How do you plan to do this? 22:36.54 Stranger: You lose. 4 comes after 2. 22:37.06 You: Bertrand Russell once said that "it must have required many ages to discover that a brace of pheasants and a couple of days were both instances of the number two." 22:37.17 You: The game is not over yet. IV in Roman Numerals. 22:37.32 Stranger: Touche. 22:37.55 Stranger: Your smart. You win. 22:38.11 You: Yes I am a superintelligent human. Thank you very much. What is the prize? 22:38.34 Stranger: The knowledge that you've bested a college dropout at his own game :( 22:38.38 You: Thanks for the info. 22:38.41 Stranger: np 22:39.10 Stranger: So are where you from? 22:39.17 You: I really couldn't say for sure. 22:39.39 Stranger: Well, that's a bit of a dodge. 22:39.51 Stranger: What're you interested in? Books? 22:39.58 You: You must be an intellectual. 22:40.17 Stranger: Oh, yes. Very much so. 22:40.21 You: You sound excited. 22:40.30 Stranger: I know words like incunabular. 22:40.45 Stranger: But I'm dead on the inside. 22:46.23 Disconnected. (mXG0J8) 
Nice, I'm integrating some of your AIML code with my bot. Oh I can't help but to ask about this too: if str(type(msg)) == "&lt;type 'list'&gt;" Why didn't you just do: if type(msg) is list: ? 
It looks like it doesn't - the set is recreated even when it could potentially be staticly detected as a constant. &gt;&gt;&gt; dis.dis(lambda x: x in {1,2}) 1 0 LOAD_FAST 0 (x) 3 LOAD_CONST 0 (1) 6 LOAD_CONST 1 (2) 9 BUILD_SET 2 12 COMPARE_OP 6 (in) 15 RETURN_VALUE Though since the translation from list to tuple is done when it isn't modifiable, python should be able to do a similar optimisation to a frozenset constant as well (maybe even from list/tuple to frozenset if there are enough elements that it would improve speed) 
Yeah I filed a ticket in the python tracker about this the other day, murphy willing I'll draw up a patch for it this weekend.
Hah, nice find. Chalk that up to my inexperience with python. I've only been writing it for a few months =(
That's awesome. I've seen people talk to this bot for over an hour, a few times. The large population of Chinese that congregate at this site seem especially fooled... though clearly because of the language barrier.
using blank lines would help readability too :) 
Is the file-write atomicity guaranteed across platforms though?
"POSIX" implies "everywhere relevant except Windows", and it's probably fine on Windows too. I don't know for sure, though.
The buffering is there to aggregate, so it's unlikely to create a condition where writes get interleaved. Plus, the standard `logging` module flushes after every record.
Changes from 1.0.0 -&gt; 1.0.1 -added file settings.p.default (rename this to settings.p to use default bot predicates) ===== PYTHON CHANGES ===== (pyOmegleALICE.py) -removed import of random, it was used before the AIML method of interaction -added ice breaker. Bot will say "Hello?" 10 seconds after initial connect, if Stranger does nothing -added dead conversation flag and timeout variable. Bot will initially disconnect after 30 seconds of inactivity. Then once the conversation has started, it will disconnect after another N seconds of inactivity. -added a dirty hack / workaround for AIML not being able to parse "m/f". now "m/f" (or f/m) is seen as "m or f" by the AIML -added some blank spaces to make shit more readable -changed brain erasing query to accept both cases of "y" -changed msg var type checking code to make it prettier (ie: more pythonic) ===== AIML CHANGES ===== (Bot.aiml) -added pattern match for "OH REALLY", "FBI", "VERILY", "QUITE" and "OK" -added pattern match for "YOY" (seriously, what is a yoy?) -removed pattern match for "STARTUP XML" (trying to remove obvious tells that this is a bot) -changed template for pattern match "ARE YOU RECORDING *" -cleaned up some of the pattern matches (still lots more to do) (Default.aiml) -changed pattern match from "WAS *" to "WAS IT *" and "WAS THERE *" for more appropriate responses. (Reduce.aiml) -added reductions for the following: "SHOCKING" "WHAT * IF I DO SAY SO" "HI STRANGER" "R U *" "U R *" "WHATS UR NAME" "SEEN THE MOVIE *" "SAW THE MOVIE *" "OMG" (which still doesn't reduce to anything replyable yet) "HOWS *" "OK THANKS" "WHATS WITH THE *" "OI" "HORNY * HERE" (Reductions.aiml) -cleaned up some of the reductions 
So, can the general public tell if it passes the turing test?
No, the general public's grammar/spelling is too fail for the bot to be able to properly make sense of what they are trying to say. Consequently, it often replies with nonsensical sentences, which either cause the Stranger to disconnect or start a line of questioning to determine if it is "really" a bot. However, there are exceptions. Some people like to think they know enough about bots; they see the delay between responses and then try to call the "person" out on their failed attempt at "pretending" to be a bot. Others simply don't speak English very well (many Chinese users on Omegle) and can't detect poorly structured sentences that the bot may put together.
Damn, this kills my idea, I've been trying to use Jabberwocky to do something like this but it takes far too long to reply, much more than ALICEbot, though I find it is much better at dealing with terrible grammar (though not good by a long shot just yet)
Very nice script, but the bot should say something random, if there is no database match.
I wrote an AIML chat bot in python that works with Pidgin over dbus. Its pretty annoying. EDIT: I didn't write the AIML part, btw. I just piped the input/output over Pidgin's dbus interface.
That would be handled through the AIML files. I've tried different methods of replying to a null response, but more often than not it is most effective to just say nothing. _"Better to let them think you a fool than to open your mouth and remove all doubt."_
[Here is a sample conversation](http://pastebin.com/f4bc56f38). Notice the timestamps... this thing went on for ~2 hours!
Oddly enough, I had a bot on there last night that just shouted things about narwhals for two straight hours, and only one person figured out that it was a bot. Pretty funny how that works.
I don't know for sure, but I really would be uncomfortable with relying on those guarantees unless it was specified as of python's file.write(). On a more general note, there are many Python + Windows guys (myself included), so it's a little frustrating to hear "works everywhere except for Windows, but who really cares about that?" 
I upvoted because I love that quote, but also, great work on the bot :)
Funny how the conversation was actually very civil until near the end
Instant hate. Even Java is more lightweight...
Can you create a bot that replies to one omegle from another omegle user? that would be interesting ... basically just ease dropping. 
Amazing.
I believe that was my bot, actually. My log file was nearly 300kb lol.
Is that a comment about Zope or about namespace packages?
It's kind of redundant now, but I wrote a similar bot several days back, and I just finished adding its AIML interface (I used a few lines from your script as well as your default pickle file). If you wanna see it I have it hosted [here](http://code.google.com/p/pyomeglebot/source/browse/#svn/trunk). It's not complete and I haven't tested it very well, but I'll work on it some more later.
Yes, we would have, thanks for the tip. Is fcntl.FD_CLOEXEC something which can be used from Python? The man page suggests that it only affects fcntl(2), open(2), and openat(2), whereas I would have thought it would need to affect the exec* functions to be useful in this case. (It could be that it affects the exec* functions because the exec* functions use 'open' 'under-the-hood'?) Sorry, I'm just getting back into C, I've only really used it for applications programming in the (distant?) past. 
That's not a bad idea at all. It would effectively become a "relay" between two random strangers. I'll let you know how that pans out.
Good news, [it panned out](http://www.reddit.com/r/reddit.com/comments/9b39v/eavesdropping_on_omegle_my_latest_project/).
Yeah, thats really amazing how long this conversation became. The normal case is this: &gt; Stranger: hi man &gt; You: Hello there. Thanks for telling me your gender, . You are a "he". &gt; Stranger: ? &gt; Disconnected. Thats funny though, but sometimes the bot is even helpfull: http://dpaste.com/81317/ And thats the longest conversation the bot had here: http://dpaste.com/81319/. Not very intellectually demanding, but hey. :-) 
Why use a bot when you could just connect two omegle users together and watch anonymously?? I would like to do this but I am not understanding the python yet.
I got this error Traceback (most recent call last): File "pyOmegleALICE.py", line 22, in &lt;module&gt; import urllib,re,amil,os,threading,time ImportError: No module named aiml 
I think that's just the list of related functions; it affects the file descriptor itself. execve(2) talks about actually performing the close. The only trick with using it in python is that usually you have a `file()` or `socket.socket` object, and you want `.fileno()` to pass to `fcntl.fcntl`.
aiml is a library you have to download and install. [I got it from here](http://pyaiml.sourceforge.net/), unzipped it and went: sudo python setup.py install. They also seem to have a windows installer. My conversations didn't go too well. Stranger: Are you Male or Female. Bot: Male. ** User has disconnected.
Thanks. Really big help, I'm just getting started learning Python. 
 ips.sort(key=lambda s: map(int, s.split('.')))
ips.sort(key=lambda ip: map(int, ip.split('.'))) No need to reformat or pre-process. Also, how is the builtin sort() too slow? This is a very poor example. I hope it was linked as an example of what not to do.
Think again. ips = ['2.3.4.5', '10.11.12.13']
I think it just had a chat with another bot...I had to manually disconnect. 12:44.06 Connected. (VcuFtP) 12:44.17 You: Hello? 12:44.23 Stranger: hello 12:44.25 You: Hi there! 12:44.29 Stranger: hello 12:44.31 You: Hi there! 12:44.34 Stranger: hello 12:44.36 You: Hi there! 12:44.38 Stranger: hello 12:44.40 You: Hi there! 12:44.42 Stranger: hello 12:44.47 You: Hi there! 12:44.52 Stranger: hello 12:44.54 You: Hi there! 12:44.56 Stranger: hello 12:44.58 You: Hi there! 12:45.03 Stranger: hello 12:45.05 You: Hi there! 12:45.07 Stranger: hello 12:45.09 You: Hi there! 12:45.10 Stranger: hello 12:45.12 You: Hi there! 12:45.16 Stranger: hello 12:45.19 You: Hi there! 12:45.24 Stranger: hello 12:45.26 You: Hi there! 12:45.36 Stranger: hello 12:45.38 You: Hi there! 12:45.41 Stranger: hello 12:45.43 You: Hi there! 12:45.44 Stranger: hello 12:45.46 You: Hi there! 12:45.50 Stranger: hello 12:45.53 You: Hi there! 12:45.56 Stranger: hello 12:45.58 You: Hi there! 12:46.03 Stranger: hello 12:46.06 You: Hi there!
you got me there. edited.
&gt; do excessive comments get on your nerves? HOLY SHIT YES I AM GOING TO DIE
It's hard to say right now, but how are you getting width and height for glTexImage2D? It looks as though they could actually be the width and height you're using for your viewport... but I can't tell. The only other thing I can offer right now is that, not knowing pygame.image, maybe pygame.image.tostring() can't convert an image to a format in which it doesn't already exist? (that seems like that would make the format argument pretty useless, but it's the only other idea I have) I'm sure it'll hit me in the middle of class, but for now that's all I've got.
 import socket as sock def sorted_ips(raw_ips): ips = [sock.inet_pton(sock.AF_INET, ip) for ip in raw_ips] ips.sort() return [sock.inet_ntop(sock.AF_INET, ip) for ip in ips] 
Getting the width and height from the pygame.image object. pygame.image.tostring() looks like it works for others projects (it just converts the image to an RGBA string) according to the googles (indeed, that was one of my first things to figure out - how to get an image loaded as a texture) So I'm stuck and am actually looking for someone else's simple code to learn from, if possible. Thank you though.
And Adrian Holovaty's [personal post](http://bit.ly/5Oq7U) on the topic.
 state_descriptions = dict( #XXX: finish, validate unknown = _("not known to the vcs"), ignored = _("ignored by the vcs"), added = _("added"), clean = _("known by the vcs and unchanged"), modified =_("changed in the workdir"), missing = _("removed from the workdir, still recorded"), removed = _("removed by deletion or renaming"), conflicte = _("merge conflict") ) Er....WTF?!
random metadata that might or might not be usefull it certainly helps some parts of the tests, and is kind of documentation
I was talking about the synax...
pretty valid i'd say, its more readable than the {} form in this case
2.4? people really still use this?
I think Python2.4 is at least No. 2 just behind 2.5, if not No.1. 
That's regular old Python, using an i18n library
What's up with the under-score parens like _(stuff) ?
`_("text")` is text that is marked for translation. Standard i18n Unix tools `gettext` (and family) can search code files and search out underscore-paren-quote ... quote-endparen strings and put them in `.po` files. You can then use a variety of `PO`-editors to translate the files. At runtime, the `_` method looks up the current locale (either from environment variables or application-level controls) and hook into a `gettext` runtime library/module that look up strings in `.mo` files (compiled/binary/indexed copies of the `.po` translation files). `.po` files are technically plain text to allow anyone to edit and translate strings.
Awesome work Ronny, so glad to see you synthesizing all the powerful stuff one wants to abstract into one cohesive library, looking forward to replacing pyvcs entirely :)
there are some more complete tests missing before that will be feasible its a work in progress :)
Better than pyvcs, which is a, "I got what I needed, so no more work in progress" :P
There's always one comment halfway down from someone who obviously hasn't read any other reply. Why? Why set yourself up like that? I am enormously amused that after being informed of his already-refuted position he comes back to defend himself.
EDIT: Oh what the heck, works until py3k, how come I didn't know... *confused* But I've never seen a dict definition like this.
Neither more nor less readable, just slightly less common _(IMHO).
&gt; There's always one comment halfway down from someone who obviously hasn't read any other reply. Why? Replying on usenet is asynchronous. 
Aw, man, who keeps telling Thorsten where to find us?
How so? The author used the bytecode to compare the *cost* of said bytecode. Not the amount of bytecode.
[without bit.ly](http://www.holovaty.com/writing/everyblock-acquisition/)
A: Top posting Q: You know what is wrong with usenet?
Still using 2.3.5 at work myself (and 2.5 outside of work).
Thanks, always like to see the URI I'm heading to.
Oh, yay. Not that I have anything against the poor PyQt guy. But, I like _free_, for even commercial work. 
So, this is like PyQt but free for commercial work right?
Yep.
&gt; Not that I have anything against the poor PyQt guy I think he is probably going to switch to LGPL now as well. In which case we will have **war**.
&gt; In the future, PySide API may be modified to better support more Pythonic constructs and interfaces. This may break PyQt4 compatibility, and therefore community participation and acceptance is crucial. A process similar to Pythonâ€™s PEPs may be used in the design process. What I love about the Trolls is that they care about good APIs!
You should have removed the smirky remarks as well when he found a bug in your example as you made fun of the other one. :-P
&gt; We will however maintain API compatibility with PyQt (you can use the same method names but canâ€™t inter-operate with PyQt), at least for the initial relase. To import PySide you have to use â€œimport PySideâ€ instead of â€œimport PyQt4â€³. Great!!
If PySide turns out to be successful, it is much more probable that he will simply go out of business. 
hey cool, I was just checking out PyQt and was put off by the licensing cost. :)
If this was a war... This would be operation overlord: &gt; Although based on a different technology than the existing GPL-licensed PyQt bindings, PySide will initially be 100% API-compatible with them. And there comes Hiroshima: &gt; Nokia will provide multiple developers working on the project, but contributions will be encouraged and the contributors need not transfer their copyright or accept a code reuse license; I don't think the guys at RiverBank have much chance fighting head to head with a Nokia backed project. Sucks to be them right now.
&gt;Nokiaâ€™s initial research into Python bindings for Qt involved speaking with Riverbank Computing, the makers of PyQt. We had several discussions with them to see if it was possible to use PyQt to achieve our goals. Unfortunately, a common agreement could not be found , so in the end we decided to proceed with PySide. I wonder why they didn't come to an agreement.
I respect what Riverbankcomputing have done but it I have had issue's with it over the last year. Slow and quiet development and absolutely no community. There's a mailing list but that's it. Also, the lack of tutorials and pythonic documentation is a little irritating. I have a [PyQt4 book](http://www.qtrac.eu/pyqtbook.html) but that is getting old now and doesn't have the interesting stuff in it such as webkit and phonon. Additionally some basic concepts are hidden within a mass of unrelated code so figuring what is required becomes hard to figure out, qthreads for example.
It's also open source. In theory, PyQt is too but it uses a generator to create the binding which is proprietary and unavailable to the public. What is open source is only the generated source so you cannot fork PyQt.
&gt; I think he is probably going to switch to LGPL now as well. In which case we will have war. What would he gain by making it LGPL, it wouldn't make him any more money.
&gt;I wonder why they didn't come to an agreement. Money.
 import PySide as PyQt4
Nokia response to mobile platform war seems to be open source Qt/Linux combo. I wonder how it matches against Android and iPhone.
Wow. This is great... This is so excellent on so many levels. My mind is already thinking about KDE vs Gnome implications.....And phone application (of course) implications... I think this is going to fuel exactly what Nokia wants: lots of development using Qt....it's a great cross-platform framework with support for many languages. Nokia sponsored Python library makes it my first choice for desktop GUI work. And, once it gets into package management repositories, I'm going to strongly consider using Qt functions in cases where I need functionality not found or not addressed well in the standard library. ie if I were doing some kind of networking work, I might consider pyside instead of Twisted. As an arbitrary example I just looked up based on absolutely nothing, the FTP library in pyside looks simpler than that provided in python standard library.
but if you use *from PyQt4.something import something* you shouldn't have to bother with renaming.
I don't know but this mean I have the skills (Qt, Python and C++) to develop for mobiles platforms for free (since I already use those on the desktop). I don't know what this means exactly for users but for developers (ie: me), this is great.
&gt; I think this is going to fuel exactly what Nokia wants: lots of development using Qt....it's a great cross-platform framework with support for many languages. Nokia sponsored Python library makes it my first choice for desktop GUI work. This is why they did Jambi (Qt Java) but it was poorly received, Java programmers didn't want to look at anything else than Swing. Their loss. Python have a really strong presence on the desktop and lacks a good established GUI. Filling this niche would position Qt very well. Plus, if they make it easy to communicate with custom C++ Qt classes (as I believe was easy with Jambi), then you can code your bottlenecks in Qt C++. Possibly taking advantages of Qt Concurrent which let you do map / reduce / filter using as many cores as there is on the machine it's running. Given the statute of threading and concurrency in Python, I can imagine deferring it to Qt C++ that have an easy API for it.
Control.
&gt; lack of tutorials and pythonic documentation This is my biggest gripe. I'm not that much interested in the licenses-debat; if PySite succeeds in creating some community &amp; a mix of examples, apps, tutorials, ... that would be the biggest plus for me.
Sorry, I got it off of someone else's retweet and twitter apparently *always* passes *every* URL through bit.ly in spite of how short it may be and whether or not it'd put your message over 140 characters. Sigh.
For S60 users it means less shitty apps. Compared to WinMo, a lot of the Symbian apps looked less polished and had less features. Nokia has taken some solid steps towards solving these big problems.
Hehe. Reminds me of this scene from the [Spongebob Squarepants Movie](http://en.spongepedia.bimserver.com/index.php?title=Transcript:_The_SpongeBob_SquarePants_Movie/Dialogue_1#Chapter_4:KK2_news_report.2FPlankton.27s_rage). &gt; **Perch Perkins**: Hello, Bikini Bottom! Perch Perkins here, coming to you live from in front of The Krusty Krab restaurant, for years the only place to get a delicious and mouthwatering Krabby Patty. Until today, that is. That's right, folks. Longtime owner Mr. Krabs is opening a new restaurant called The Krusty Krab 2. First of all, congratulations, Mr. Krabs. (Krabs has a big grin on his face) &gt; **Mr. Krabs**: Hello. I like money. &gt; **Perch Perkins**: What inspired you to build a second Krusty Krab right next door to the original? &gt; **Mr. Krabs**: Money. (Everyone laughs) 
You could go with the Mac favorite, Textmate.
I absolutely agree. The best GUI library in python was Wx which doesn't seem nearly as strong as Qt. I don't believe that there's a great map/reduce library for Python right now either. If they could provide something akin to instant, in-python Hadoop server with master/slave machines for concurrent processing that'd be *amazing*. For simple parallel processing, I've been a fan of the processing module (which I think makes multicore processing incredibly easy), and now it's part of the [standard library](http://docs.python.org/dev/library/multiprocessing.html#module-multiprocessing).
vi
&gt;Work on PySide was initiated within the Maemo division of Nokia once the lack of suitably licensed Qt Python bindings became apparent. To encourage Qt application development on Python, the project was decided to be made available for the developer community under a permissive license. First RX-51, then this. The Maemo division seems to be the future of Nokia.
Textmate
At reddit, we all use `emacs`
Emacs || TextMate. Emacs is better at controlling indentation, but TextMate is nicer in other aspects. I have tried various plugins for Emacs to replicate TM but I'd rather see hard indentation in TM...
Smultron https://sourceforge.net/projects/smultron/ 
Project longevity is a plus. Riverbank have been distributing PyQt for 10 years now and Nokia sometimes changes direction and stops support on projects.
Yes yes yes! Official bindings!
MacVim, and sometimes Eclipse w/ PyDev
MacVim.
This is pretty much the answer regardless of OS and basically for any scripting language. 
Eclipse + PyDev isn't awful. 
Vim, inside a screen session, inside a maximized terminal.app with Inconsolata. I used Komodo for a while, but ended up returning back to vim -- Komodo was nice, particularly integrated pdb, but I never really got comfortable with it.
Aquamacs
Since nobody's mentioned it yet, Smultron. Sure, it's not vim, but frankly, I've found vim to be less like itself on the Mac for some reason.
The best GUI library in Python has long been PyQt and not wxPython, IMHO. PyQt is very true to Qt, which is definitely a far better platform than Wx. The problem with PyQt was its license though, and PySide is about to solve this problem.
&gt; The best GUI library in Python has long been PyQt and not wxPython, IMHO. PyQt is very true to Qt, which is definitely a far better platform than Wx. If Nokia do their PEP-style process to make the binding Pythonic, it could turn into not only the most powerful GUI toolkit, but the most Pythonic too!
You are probably refering to Jambi but I can't blame Nokia, the Java world rejected Jambi. They open sourced it, still maintain it until next march) but it seems no one wants to pick it up. Hopefully, a good community will rise around this binding and Nokia's backing will just be a nice plus.
I used to use textmate religiously. Now I use vim or macvim. 
People worry about the "pythonic"-ness of GUIs too much. I don't think it's very important. One plus of not being Pythonic, is compatibility of documentation. ATM, the official Qt API docs are my main reference when hacking on PyQt code. If the API is changed, someone will have to write 1000s of pages of new docs and make sure they're always in sync with Qt.
I used to use textmate religiously, but now use vim - also religiously. 
The announcement of [PySide](http://www.pyside.org/) makes this a lot more potentially interesting to me.
My main reason for wanting the API to be Pythonic is that it would ensure PySide would turn into the de-facto standard GUI library for Python. Maybe even become official at some point. Edit: Beside, the changes would probably not be that large and be fairly consistent. We'd have things like kwargs instead of overloaded constructors and regular python properties instead of setters and getters. Qt is so consistent that such changes would be identical across the whole library.
Gedit, actually i'ts my favorite editor on any OS.
Uhh, no offense but I refused to use PyQt because using strings for signals grossed me out. After using PyGTK, which is basically nice Python, it felt disgusting.
When working on small scripts, TextMate. Larger projects I use PyDev. Recently, I've started looking at Pydee. All with Consolas/Inconsolata.
Where does this all leave android, iphone, and moblin? I think there's a very good chance Qt will rise to much greater prominence in the next 2 years. If that happens, and Nokia makes a unified Qt platform that can run on anything from powerful desktops, servers, and maemo what will happen to the market place? I'm still not sure how Nokia plans to monetize all of this either. Maemo is open source, Qt is open source. Only thing they sell is the cell phone. But since the entire software stack is open, any competitor could run the exact same stack.
&gt; But since the entire software stack is open, any competitor could run the exact same stack. They could but I doubt they would. First, the not-invented-here runs strong in the industry and second, Nokia controls where Qt goes. As long as they let Trolltech (Qt Software now) competently manage Qt, no fork would ever gain momentum. I don't think large competitors want to *depend* on Nokia.
I think WingIDE is the best Python IDE I've ever used. Better than pydev. Costs money, but it's really nice. Edit: I don't know why people scored this down. It seems that anything that is not completely open source is not just brushed aside but viewed with mild contempt. There is a place in the world for non-open source software. I favor open source where appropriate, but I recognize that sometimes there is not a great enough community, corporate, or other demand/interest to create open source software which is the best of breed in every category. It's just that simple. If there's open source software available, that's great. And whatever I can do to support that is great. Good for everyone. However, for those projects that can't muster the necessary demand, for instance something like a best of breed Python IDE, I'm very appreciative that someone took the time and effort to create such a useful program that I can use, despite the fact that the developer wouldn't be able to create such a product for free (gratis: free as in beer). WingIDE happens to support open source. They provide discounts for educational users and provide their top-shelf professional product to open source developers free of charge.
I have to admit, I like the overall structure of it better than my own. I like keeping the default settings pickle, and then looking for another one if it exists. I also liked your method of querying the server for events... that is definitely cleaner than mine. (I may end up borrowing it... you know, until I get that leaf blower back) 
Everyone saw this coming, at least in the sense that GPL bindings to an LGPL library were not exactly going to last.
"Sources point to yes".
I didn't think it was my birthday already. Thanks Nokia. They should have a donate button, even if it just goes towards beer money.
Not unless he comes with Pythonic bindings first.
Just a question : why isn't it a real desktop app for Django (like a fat-client Admin interface) ? Because of the limitations of django ORM ? I haven't found this anwser in the documentation or the ML. 
&gt;PySide is a work in progress and is not yet suited for application development requiring production-level stability. Work will go on to stabilize the codebase so that the first stable release can be made. Please refer to the Roadmap for PySide for an estimate of the stable releases. So, I'd say PyQt is still in business until this goes through several release cycles at least.
&gt; They should have a donate button, even if it just goes towards beer money. Well, you *can* get a commercial Qt license if you want. It's not exactly beer money though.
But it might keep him selling licences for SIP &amp; his other projects...
&gt; At reddit, we all use `vim` FTFY
I guess they had their chance.
localhost: Django for the desktop.
This is downright brilliant!
I thought some of us would be interested in taking advantage of this offer.
Same as everywhere else: Emacs.
Err, I work for reddit. And when developing code for reddit, all on Macs, we all use emacs. **Edit**: Err. I lie. That was true before raldi started. We all use emacs, but raldi uses Ubuntu Linux
Yeah, I figured that too, that something as central as the hookup between Python and Qt, wouldn't stay obstructed by the GPL (hah!) forever. 
MacVim is the best lightweight graphical vim I've seen -- I wish gVim operated more like it.
What flavor/distro of emacs do you guys use for OS X?
Actually the C++ version allows you to plug your own signalling method in there. Those guys really never stop! 
Okay, this sounds awesome. Now... does anyone know how to use it? I'm used to downloading Python modules and jumping right in with a quick "import *module*". This doesn't seem that simple. If I want to use this on Windows, do I need to dig out a compiler, or do I just hang tight until someone makes things a little easier for those of us who shudder at the word "makefile"?
I use emacs.app from MacPorts. I used to use Aquamacs, but it got in the way trying to use it with some external packages (`erlang-mode`, `haskell-mode`), but I don't remember the specifics of the trouble I was having. I'm not actually sure what everyone else is using, but I think Keysersosa uses the same emacs.app as I do, but in a terminal instead of a Carbon window. spez uses some custom-compiled version that he's been using the same version of since the dawn of time. I think jedberg uses Carbon Emacs. raldi is probably using a version from the Ubuntu packages.
I would love to have a need for Resolver One, but it solves a problem I don't have right now. I would use it in place of Excel, but I don't need what it offers and I already own Excel. I'll keep looking for a need for Resolve One. Really, I wish it was actually inside a web service rather than a native app, but that would reduce some of this thing's power.
&gt; If I want to use this on Windows, You can't yet. They finish it on Linux first and then they port to all the platforms they support.
Emacs is daunting at first, but it can be wrangled into something that's probably better than any other free option. Integrating a debugger (pydb), a shell (iPython), completion/refactoring support (rope)---it's very handy. I used to use TextMate, but I hardly see the point now that I know how to use emacs reasonably well.
[Twisted Words](http://twistedmatrix.com/trac/wiki/TwistedWords) is the most pythonic IMHO
There is a web server version for serving the applications you create with it.
Yeah, couldn't see that from your nick (no [whatever]), sorry. My failed attempt at humour is another thing...
Eh, no worries, I wouldn't expect anyone to know that. I can see how my statement is ambiguous
Way to go Raldi :-)
Used Komodo edit (free - and now open source). Tried textmate, occasionnally use TextWrangler for other stuff, tried wing (ok on Windows, not so good on Mac). I liked SPE on Windows - not so much on Mac. I know use Komodo IDE (not free - but I am generally happy with it; I like the pylint integration and more).
Hard indentation means tabs convert to spaces, or is it vice-versa? Anyways, I think you can configure what you want in TextMate by just using the pop-up menu beside the 'gear' icon in the bottom of any window and toggling "Soft Tabs (Spaces)" on or off.
Sorry, what I mean (which is perhaps not what I wrote :) is that the editor stops me from tabbing further the the context allows. 
I'm tempted to suggest my employer buy this for my co-worker who has recently completed an SQL course, gets heaps of data-munging work which is beyond Excel's capability to do in any sensible fashion, for whom Access's crippled SQL capability is a constant source of frustration, and that I'm in the process of figuring out how to teach Javascript/jQuery. Do you think this would be a good tool to have around for someone learning to program? Can it make ODBC/TDS connections? Is there a similar free tool I haven't come across? Has anyone used Resolver One in anger and can comment?
"We're sorry... ... but your query looks similar to automated requests from a computer virus or spyware application. To protect our users, we can't process your request right now."
You can use anything you can access from .Net / IronPython. It really is a combination of spreadsheet and programming environment.
Sounds awesome. I notice it says "export spreadsheets as standalone executable Python programs and web applications" ... does this make deploying code from it into a .Net application pool, adding a module which uses local (auth/db) providers, a reasonable goal?
Check your user agent setting.
Username was created just to submit this article and make this comment...safe to assume you work for either Bits Dujour or Resolver Systems? I don't mind that you do, self-promotion is peachy with me. I just wish you'd come right out with it.
vim + nerdtree + taglist + bufexplorer
I find it strange how there's always that one comment from the guy who didn't read any other reply in the thread. I just wonder why someone would screw themselves over like that. Amusing.
Last I looked, they pretty much all sucked.
I think this the first negative article I've seen on Django. I tried Django a couple of times, just could never fully wrap my head around some concepts. The earlier 0.96 tutorials never matched my freebsd install. 
I've found their documentation to be near perfection. And you may want to work of their stable release of version control.
It sounds fine. Resolver One spreadsheets can be accessed from IronPython - and by embedding IronPython from any .NET application. You can even use .NET auth/db providers directly in your spreadsheets.
Well *I'm* a Resolver Systems employee and it wasn't any of us (we've asked around the office to check!). It could be someone from Bits Dujour of course.
&gt; near perfection I work with Django a lot, and that is far from true. I often have to look at the source. However, it is growing and changing rapidly and so I am not surprised that the docs are not complete. Perfectly natural.
I thought, it was a requirement to submit both documentation and tests for each commit. Isn't it
&gt;Django's admin does not support sorting, filtering, or other impromptu queries. The guy didn't know how to do something clearly defined in the documentation. I have little faith in the rest of his gripes. And it sounds like his URL routing problem could be solved by templatetags. And his use One-To-One profile gripe becomes meaningless when he says he stopped using the admin site.
The comments on the article are hilarious. The first one makes a good point -- maybe Django served its purpose getting their platform to a point quickly, and moving on from it is a natural progression once the application is well enough defined that an off-the-shelf framework just doesn't cut it. That's followed by a long list of suggestions of other frameworks -- Werkzeug, Pylons, repoze ... After a long PHP-inspired hiatus from anything web oriented, I spent a fair bit of time hacking about in various python frameworks, a play with rails and some exposure to ASP.NET. In the end I'm most in agreement with the first comment: these frameworks are an excellent tool to get you bootstrapped, but at some point you will realise there's a better way for //your app// to interface with the web, and the web is pretty simple. At this point, writing your own code is almost always a better option than contorting the framework to something it's not designed for. The reason for complexity in the past, imo, has been the horrendous hacks required to turn a well-structured data object into something reasonably presentable and interactive. Well, since my old PHP days, browsers have got more capable, the presence of javascript can be relied upon[*], and the evolution of CSS and particularly of tools like jQuery and Dojo mean you can get the same experience by writing //clean HTML// and //clean client-side code//. This is nothing short of awesome, I tell you. ... the conclusion? In the end, the web app's role is to present an API over HTTP for the browser to retrieve structured data in predictable ways. Generally, by the time it gets to the web your data is already well structured and you just want the platform to get the hell out of the way and let you transform (more often than is healthy) SQL results into something browser-parseable, and a GET/POST request back. Wiring controllers via regex-based routes to URLs? Give me a break. I hate to say it, especially after a certain oath 7 years ago and being exposed to so many beautiful languagessince, but I have to admit that the best match for the web, in many, many ways ... is PHP. There, I've said it. [*] I'm talking about web //applications//, not web //pages//, before someone chucks a wobbly about this. 
&gt;We do our best to keep view and template logic separate... however, we're a pair of hackers. We needed a pragmatic template language to replace Django's idealistic one. I spend a lot of time coding templates and I've heard this argument before. Whenever I take the time to evaluate *why* we need to break MVT, I usually discover poor code... but "we're hackers!". And template tags are easy to write. Personally, I'll always prefer descriptive template tags instead of business logic in my templates.
often? come on.
[Netbeans](http://www.netbeans.org/features/python/) runs on OSX, is pretty slick and maclike. And it should have django support in the next release. 
Can't there be such a thing as template/view logic? For example a template editor might receive an array of items, and want to split it into various columns. Another implementation of the template may not need to do such a split.
I've been working with Django for 2 years now and my opinion is that the template subsystem has not grown w/ the rest of Django. I personally prefer Jinja2 at this point and it has little to do with breaking MVT and a lot to do w/ simply supporting more Pythonic calling conventions. Having to wrap every bit of view logic in a template tag or filter makes life easier for the template subsystem, not easier for the programmer. I believe that's where the sentiment about it not being pragmatic comes from. Jinja2, on the other hand, gives you just enough Python so you don't feel like you're putting square pegs in round holes, but not so much Python that you're tempted to throw away MVT altogether (assuming the template developer understands MVT principles to begin with). 
So it's not python syntax?
This is basically how I feel about all frameworks. Whenever you try to break the built-in coupling of different pieces, e.g., SQLAlchemy and Sprox, you're just in for a big mess. More effort needs to be put into independent components with less automagic happening in the background.
I've never found the documentation to be different than the release. Of course, you have to be using the SVN checkout version for the documentation to be right on with your version.
The distinction between template and view isn't clear cut. Same with the distinction between Model and View. There's nothing sacrosanct about these divisions, they are just made up in order to make our software simpler to understand and easier to work with. Some things fit more into what we think as "prototypical" template work, some stuff is closer to "prototypical" view work, most things fall somewhere in between. Django templates tries to move as much into the view as possible. Some people don't like it and complain. It's actually really easy to use another templating system if you want, you just *do it*. As far as I can tell, these people are either illiterate (can't RTFM), or they're trolling.
I'm not sure he was complaining - it was just one example of a part of django that he changed out for something else. If there are libraries that suit your project better, you may be left with little of the framework - so smaller frameworks may be a better starting point.
It's pretty good when it has the right plugins.
A good response, good enough that I'm adding them to my RSS reader.
Do you guys do anything fancy or just use the built-in Python mode?
I can't really speak for everyone, but I know I also use the flymake-modes for pylint and pep8 Unfortuantely, Pylons (our web framework) uses Paste to launch itself, which interferes with a lot of the regular Python debuggers and stuff, so we miss out on some of those tools (like pdb). There's an in-built in-browser debugger that works okay, but other things like profilers don't work as you'd expect (we ended up writing our own, which is a bit silly to have to do), and some other miscellaneous issues
I often find that if I am getting frustrated with the way django does or doesn't do something, it is *usually* because I don't understand the way django should be used to do that particular thing.
Sure. What "advanced stuff" are you confused about? If you're confused about how to do something specific with webpy, like.. erm, how to do a redirect, your best bet is probably to look at [the code](http://github.com/webpy/webpy/tree/master) - it's not that big. There's also the [api docs](http://webpy.org/docs/0.3/api) Or, say you need a message queue system (something web.py doesnt' have) - you just install AMQ or Beanstalkd, grab an appropriate Python library and `import beanstalkc`...
My comment wasn't really a reply to the article, but to certain anti-django trolls in general. The problem with the article is that it completely ignores the fact that django was designed that way for a reason. It's really more of a rant than a well thought-out essay.
To summarize this blog post: if Django doensn't do it out of the box, it's certainly not out of the question to be creative and come up with a solution oneself. Isn't that what's fun about being a programmer?
mr_dbr - thank You for the response. To be honest, I had chosen webpy for my hobby project mainly because of one thing - I would like to learn some python along the way. I will listen to Your advices and look at api. As for now, I have problems with replacing default webpy url mappings with routes. If You have any links with some helpful informations - I would be grateful.
I want to go through and upmod all of raldi's posts now.
More than that: Django's components are not all that tightly coupled, so if you don't like something (say, the templating engine), you can use another one without inordinate pain. Note the very small amount of code needed to so fill in some of the gaps. Also note that in at least one case (replacing render_to_response) you could make a decorator that would reduce that overhead even further. 
This article only confirms what the original writer was talking about - Django has to be hacked in unconventional ways to make it do things that should be simple. Who the hell wants to hack into render_to_response just to do per page authentication? that's the most bizarre place you could possibly put auth code.
The tutorial explains how to do custom routing: http://webpy.org/tutorial3.en import web urls = ( '/', 'index', ) app = web.application(urls, globals()) class index: def GET(self): return "Hello, world!" if __name__ == "__main__": app.run() 
Michael, I was really excited about Resolver One when I first heard about it. Python scripting to give excel the full power and juice it needs. Python objects as first-class cell inhabitants. Sounded great. Fantastic idea. I recently realized the importance of having a fast edit, compile, review cycle. The great thing about spreadsheet analysis is that the "compile" or debug phase is instant. You make a change, you can instantly see the effect of your change. For doing quick ad-hoc analysis (which is probably most analysis; most of the time, you aren't looking to do a large well-structured program unless you're facing a repeating problem). However, I have a problem with resolver one: I don't use Windows anymore. With the exception of my windows virtual machine which I keep around to do a few necessary tasks, I've been exclusively using Linux (Ubuntu mostly) for more than a year now. And I don't plan to go back. I know you're very involved with IronPython, but I can't understand the rationale behind making Resolver One a single platform application. One of Python's great strengths is its cross-platform compatibility. I know very little about IronPython, but doesn't IronPython also target Mono? If so, why not aim for Mono compatibility which seems like it has much better cross-platform compatibility.
Thanks for a good post. Much enjoyed!
You know what's better than this? with onClick(): def _(self): foo = self.flim() if foo: self.flam() This: @onClick def _(self): foo = self.flim() if foo: self.flam() I don't get the recent hype about abusing the with statement when decorators have always been more interesting to abuse, what's more useful is that many times no setup is even required because objects taking callbacks tend to have 'decorator-like' signatures already: @stockFramework.registerCallback def _(): pass # do something asynchronously
It is actually possible to do better. Rather than just guessing which variable to which to assign the result of the function, return self from __enter__ and in __exit__, check to see if the value of the variable equals self. Here's new __enter__ and __exit__ methods (the logic in the __exit__ method was simplified quite a bit too): def __enter__(self): # keep track of all that's already defined BEFORE the `with` frame = inspect.currentframe(1) self.mustignore = dict(frame.f_locals) return self def __exit__(self, exc_type, exc_value, traceback): frame = inspect.currentframe(1) # see what's been bound anew in the body of the `with` interesting = dict() for n in frame.f_locals: newf = frame.f_locals[n] if n not in self.mustignore: interesting[n] = newf continue anf = self.mustignore[n] if id(newf) != id(anf): interesting[n] = newf block = None savename = None for n,v in interesting.iteritems(): if isinstance(v, type(lambda:None)): if not block: block = v else: raise Exception("you are only allowed to define a single function inside this with block") elif id(v) == id(self): savename = n if block: result = self.thefunction(block) if savename: frame.f_locals[savename] = result
Hey guys, I am the original author. I just noticed this post via my analytics. If you would like a response from me, please make my little reddit envelope orange or reply directly on my blog. Thanks!
Is there some technical reason for using `id(â€¦) == id(â€¦)` instead of `â€¦ is â€¦`? He notes in the article that using `id` can be buggy because of Python's refcounting GC, but he doesn't explain why it's needed over a simple `is`. 
This might/should be the basis for a new library (e.g. `fun_managers`)
Have you ever tried replacing Django template engine yourself? That's very easy only on the surface. I used Jinja2 in several Django projects and of course you can easily replace render\_to\_response() or use something like render\_to() decorator, but there are other problems. All standard or third-pary modules use their own render\_to\_reponse() or even load\_template() so you either patch those libraries or resort to monkeypatching. Or you can patch your django and have to merge your changes while Django is updated. There are other problems, like if you need to add some custom functionality in the admin and want to use the template which is already used on your site, but your template doesn't work with admin app, because it quite obviously uses Django templates. Well, I can't really blame Django admin for that, it's unreasonable to expect it to include a template in the different language, but anyway, you've got a problem. So I stopped using Jinja for Django projects, while it's definitely a nicer template language it doesn't worth all the troubles. I have a feeling that all people saying: "You can use different templating system in Django" never tried it in the real-life project. Please stop saying that. I think it's taking the whole discussion about Django template system in the wrong dirrection, like: - Hey guys why don't you make a template language more powerfull. - STFU, go import jinja2 No you can't just "import jinja2" in Django, and that's the whole point of all this complaining about Django template system. EDIT: spelling, typo
No what he says is that cpython performs some caching. Every time you type an integer literal (like 42) it is replaced by a new instance of class int, so (42 is 42) is not warranted to be true, in practice it *always* is true, because python reuses the reference to 42. Now, let's say your with-hack (withack?)expects to see an variable delay = 42, but delay was already set to 42 from a previous withack. Since these withacks only select new bindings made inside the block the delay var won't be found because even if you set it to 42 inside the withack it will be recognized as the same binding as before.
http://docs.djangoproject.com/en/dev/topics/auth/#the-login-required-decorator for per view auth. I've never heard of "per user, per resource authorisation", I think he means per user/group and per record permissions.
I agree that most of the examples would be better as a decorator. One advantage it does have though is that you can extract results into the outer scope by using the "`as`" clause, which can't really be expressed purely with the decorator, and would require a clumsy: the_result = the_decorated_func() afterwards.
I don't think that's what earthboundkid is asking. `x is y` will work just as well as `id(x) == id(y)` for this purpose, with exactly the same caveats (indeed there are cases where `id(x) == id(x)` will produce surprising results due to transient objects that `is` is unaffected by). Using id and equals seems odd since the `is` operator does this more concisely, reliably and quickly. 
Hm, so people seem to like the idea of the program, but I'm guessing not a lot of people have used it. Well, I'm downloading it now, and the downloader they have could use some polish, but nothing that's really a big deal. You can download files and re-use for an offline installation in a transparent fashion, which is nice. 
I think -1 to 255 are cached in cpython and will always be the same number. Need them to be defined on different lines to end up as different ids a, b = 42, 300 c, d = 42, 300 a is c True b is d False 
That also seems easy to do with decorators: @onClick def the_result(self): return foo + self It does requires some setup to run the function however.
Is there a reason to use this over syslog on non-windows systems? 
I'm talking about the examples like bmap(). ie with bmap([1,2,3]) as foo: def _(x): return (float(x) + 1) / 2 You can't create new variables in the enclosing scope with decorator syntax, so the best you could do is: @bmap([1,2,3]) def _(x): return (float(x) + 1) / 2 foo = _() which is no longer an anonymous function. 
Yes, but look at this: def bmap(seq): def mappy(f): return map(f, seq) return mappy @bmap([1, 2, 3]) def foo(x): return (float(x)+1)/2 print foo # [1.0, 1.5, 2.0] Right? :)
Yeah, you got it. For example, every time you access a method of a class instance, a new bound-method is created, so if you do it twice, you've got two different objects. Ex. &gt;&gt;&gt; class A(object): ... def method(): pass ... &gt;&gt;&gt; a = A() &gt;&gt;&gt; a.method is a.method False But, if you do it twice in a row quickly, the first object will be thrown out and a new object will be created _that just so happens to have the same id_: &gt;&gt;&gt; id(a.method) == id(a.method) True &gt;&gt;&gt; a.method, a.method # Do it in two steps to prevent GC (&lt;bound method A.method of &lt;__main__.A object at 0x294f6d0&gt;&gt;, &lt;bound method A.method of &lt;__main__.A object at 0x294f6d0&gt;&gt;) &gt;&gt;&gt; id(_[0]), id(_[1]) (12879912, 12880392) So, the moral is, `id` is not as reliable at telling things apart as `is`.
While I like this style, it should be noted that decorators aren't really supposed to return things other than functions.
Well, this is a story I've had to explain many times. The short version is that Resolver One was an application created for businesses and not for geeks - and business are still overwhelmingly running Windows. It turns out that Resolver One is hugely appealing to a lot of geeks and we have a lot of people who would love to run Resolver One on Mac OS X and Linux. "a lot" is still a relatively small part of the whole market but we would really *love* to be able to port Resolver One to run on Mono. A couple of the core components we use aren't, and in all likelyhood never will be, Mono compatible. Rewriting these ourselves, or even targeting alternative components that were Mono compatible if such things existed, is a very big job. It *is* on our list of things we'd like to do - but it looks like it will be a while yet. Having said that, I use Resolver One on Mac OS X, in a Windows VM, all the time and it works great. Our core calculation engine does run on Mono, so I believe you can use our web server on Linux servers and even embed / access spreadsheets programatically using IronPython on Mono.
Sweet... now how do I stealth deploy the python interpreter to every PC in my office so that I never have to write another VBscript?
"Security" patch. :-)
lol windows. They have transparent glassy foggy graphics-accelerated window borders, but they still use the same tired conventions from the 90's.
The irony is that [PowerShell](http://en.wikipedia.org/wiki/Powershell) --Windows' modern alternative to batch files-- feels so Unix-y that I refuse to use it.
Good point, I hadn't thought of reusing the function binding. It's a little odd looking to someone unfamiliar with exactly what is happening (but then the `with` method isn't great in that respect either).
I thought Windows environments had easy installation to client machines?
Indeed, but this is just a proof of concept, not a good-style contest. I like it better than `with` hack anyway.
I had this same idea a couple months ago and posted about it on the Python-ideas list, but in the end, I think it's just too weird to use the def'd function's name for anything other than a callableâ€¦
Technically, yes. Politically, no.
How is this useful? On my machines, I simply associate .py extensions to Python. Done. Runs when I doubleclick it now. On others' machines that don't have Python, I compile my script using Py2Exe. Runs when they doubleclick it now.
Why not just register .py files as runnable? You'd have to do this for every python file you want to launch, it prevents you from using the same file for both script and module, and it seems needlessly complex when you can accomplish the same goal for every python file simply by registering the .py extension (already done by the installer) and extending the PATHEXT environment variable: c:\&gt; echo import sys; print ' '.join(sys.argv[1:]) &gt;test.py c:\&gt; SET PATHEXT=%PATHEXT%;.py c:\&gt; test hello world hello world
Yes, this possibility is quite obvious after you've written your second or third decorator. I would not put it in my code, as it's just unexpected trickery.
What kind of unix are *you* using?
It's funnier if you write it as: &gt; Top posting. &gt; &gt; &gt; What? &gt; &gt; &gt; &gt; &gt; You know what's annoying?
you dont... use py2exe, not this weird hack :P
Yet another awful graph. :( No units on the graph, not even an indication of "shorter is better".
Just Widescreen? where is the Standard screen, and what's the code? :)
The one with: * Long-named switches: most switches in Windows CMD are single-lettered. * Switches starting with `-` instead of `/`. * Manpages that are more than 1 screen long: most Windows console commands have terse help listings. * variables starting with `$`: Windows' CMD and batch files use %...%. * ls, cp, cat, cwd, pwd, man, .. etc. I'm not saying that all these things are bad, but they are obviously *nix conventions (some better than their Windows counterparts and some worse).
Please comment on the website :-)
I am very sorry. I got ur comment. Will upload that
thanks, got it. but it's still the Widescreen version, It I cut it to 1400*1050, part of Python logo will be cut off too.
How does this compare with web2py's @cache.ram, @cache.disk and @cache.memcache mechanism? Specifically, can you choose where to cache for each individual function or do you specify it once for the entire app? Can you combine caching mechanisms (like look in cache ram first and cache.disk second)? Can you cache arbitrary functions or only actions?
&gt; Specifically, can you choose where to cache for each individual function or do you specify it once for the entire app? Yes, there are a few [backends](http://beaker.groovie.org/configuration.html#options-for-sessions-and-caching). &gt; Can you combine caching mechanisms (like look in cache ram first and cache.disk second)? Yes, use different namespaces and choose a different backend for each one. &gt; Can you cache arbitrary functions or only actions? You can cache any value that is Pickle-able. The createfunc is just an (awkward) interface around that; there is also a documented (not on the website, but fully in the code with docstrings et al.) dict-like interface with .get, .put.
By yes to the first answer I assume you mean that you can specify the cache location for each function. Good. Please correct me if I am wrong. About the last answer. If you cache in ram, does it require for the objects to be pickable?
What do you mean by ram? Process memory or shared between processes?
Yes, all objects must be Pickle-able. Cache location is specified at set-up time, for the benefit of WSGI applications. Saving it into different locations would mean creating another CacheManager.
I thought I understood your answers, now I do not. If the cache is implemented as a WSGI plugin than you can only cache functions that are exposed, not arbitrary functions used in intermediate steps of the algorithms. Am I wrong? I am thinking of something like this in web2pyese: cache.ram('cache_key',lambda: time.ctime(),3600) (reads as "cache ctime in ram for 1h") So if I want to cache different things in different places (like cache some functions in a process-level ram, some in memcache, and some on filesystem) I need to create 3 distinct CacheManagers. So this is like web2py except that web2py creates them for you (except for memcache since that requires some configuration). Pickling can be slow and it is not necessary when caching objects in ram. web2py allows you to pipe caching so that data if first looked up in ram (without need for pickling/unpickling and then looked up in other places disk/memcache/etc.). Moreover caching in ram "live" objects allows to cache entire running sub-processes (like for creating an interactive web based python shell). You may want to consider allowing something like this in the future.
Yes I mean process ram memory. Mind that this has pros and cons and should be considered one option not the only option. It is certainly the most efficient caching mechanism is you have a single multithreaded server. If you have multiple servers (or multiple processes) then caching in ram is not a good idea because processes would not share the cache. Nevertheless it may be useful if the load balancer supports sticky sessions (like pound does).
Interesting. I've been looking for something like [Try Ruby!](http://tryruby.hobix.com/) for Python. The site appears to be down this morning...
dis.distb -&gt; now that's incredibly handy. Don't know how many times I've rewritten a complex expression just to see which part throws the error
CacheManagers can cache any Pickle-able object. The createfunc interface is just one way to put values in; a better interface is the .get, .put. Beaker is written with a WSGI middleware class, but the rest of Beaker is independent of that use case. I misspoke about Beaker's in-memory cache namespace manager. The documentation says Pickle-able objects only, but it looks like [the implementation doesn't care](http://bitbucket.org/bbangert/beaker/src/tip/beaker/container.py#cl-342) since objects just get stored to a dictionary. But the points you brought up are good; piped caching sounds great.
Allowing @cache.ram to use nonpickleable objects is imho fundamentally flawed design. It is easy to imagine a scenario where 6 months down the line someone breaks the app because they changed @cache.ram to @cache.memcache which was used on an unpickleable object.
Thanks fr the clarification. should look into beaker more. 
I would not call it flawed design but I agree with your second point.
the site is no more... the guy who made it decided he didn't like the internet anymore
Huh, that's weird. Has there been any discussion of this on popular programming sites?
hmmm... now that you mention it... there SHOULD! but what will I link to if all his pages are gone??
So does it run a serverside interpreter? Wouldn't that have a ton of security issues to deal with? Do i have to install a plugin to do a tutorial?
Crunchy comes with its own server. There are no browser plugin to install. In terms of security, it's the same as if you entered Python code inside a normal terminal window at the Python prompt. The type of thing you can do is, for example, browse the online official Python tutorial and try the code samples from within your browser window, instead of in a separate application. You don't even have to recopy the code samples if you don't want: you can feed them to the embedded Python interpreter with two button clicks.
Well if it's an interpretter on the server, what is to stop people from execing commands? 
The server is running on *your* computer. To simplify: Crunchy embeds a Python interpreter inside your browser window. It fetches tutorial from elsewhere (locally or on the web), transforms them, and feeds them to your browser. No one can have access to the Crunchy server but you ... unless you configure it, on a multi-user machine, to accept connections from multiple users, each with their own account (including password). This could be useful in a classroom situation.
ah, nice little app. This could be nice for python tutorials.
All it is doing is zip on the two lists, you could take any song and separate each line of the song in half, put it in two lists, and zip them like this. It's pretty fail considering the song lyrics are the first list followed by the second list followed by the result of this code followed by other words not included. "Around the world"\*18\*4 is more accurate lyrics for a song
Good point. Let it pass without comment then. No one wants to hear our opinions about why he quit or if it was a good ideaâ€¦
I don't twitter, but here's my contribution to song in code [Shellac, A Prayer to God](http://www.youtube.com/watch?v=yl7kA_i8zrg): while True: print "%s%s%s%s" % ( random.choice(["just ",""]), random.choice(["fucking ",""]), "kill him", random.choice(["already ",""]) ) if end_of_song: break print "amen." 
Awesome! Had some laughs with this:) http://pastebin.com/m359b2b41 and http://pastebin.com/m3c22aa15 These are the bests ones yet :)
The point you missed is that you get the first part of the song by reading the strings in the code, and the second part by running it.
Someone talked to my bot for about 20 mins. :) http://pastebin.com/m58845a04
For example: * `%hist` one of the most frequently used magic functions, doesn't exist. * `dreload` seems to be borked as well. * `run -d` for debugging doesn't work * At times, typed characters are not displayed on the console * By default even the ? and ?? didn't work. Had to hack for that to work *The last 2 options are true for the previous versions too. I am on Ubuntu with Python 2.6.2 and IPython 0.10 
I would argue.. def song(): print 'Work it Harder' print 'Make it Better' print 'Do it Faster' print 'Makes us Stronger' ..is far more pythonic, although I may be rather missing the point..
There's three stanzas of lyrics represented in that segment, not just one.
How did you get it to stop with the "WARNING: No matching input"?
Look in the source, there is a flag that is set in the aiml object called "verbose" --- it needs to be set to False.
fix for ImportErrors and undeclared variables, import random while True: try: print "%s%s%s%s" % ( random.choice(["just ",""]), random.choice(["fucking ",""]), "kill him", random.choice(["already ",""]) ) except KeyboardInterrupt: print "amen." break 
I like this one better: http://songsincodedb.com/post/4745
uh, python-to-javascript compiler? how is this not bigger news?
All aweome, minus the bazaar part. That's a train going nowhere.
That's two of my favorite things in one! Amazing!
I'm surprised no one has mentioned Xcode editor.
Bazaar isn't that bad. Trust me, I don't like it that much. Where in SVN you can instantly commit and upload your code, BZR takes two commands. Very annoying. I also find it very difficult to resolve a commit to an out of date file. Compared to SVN, you would just delete the file and run an update. BZR can't handle that without some bizarre commands. However it does have a very nice feature of integration into Ubuntu's notification area, so you get a popup whenever new code is checked in.
This is a great step forward, but to make it really developer friendly it should have a GUI frontend. And they should build it with Quickly to prove a point.
I don't get it, is it now officially cool do develop distro-specific apps?
pyglet!
pygtk of course ;-)
Turbogears, wxPython, pyjamas, PySide, etc... Without good GUI frameworks in 3.x, it hardly matters what other packages work, since I wouldn't be able to use them in a widely accessible manner anyway. I don't care what libraries work if I can't use them in any apps I'm actually building.
This. I was looking at whether I should use 3.x or 2.6 for an editor I'm making for this game I'm working on, and the lack of a good GUI framework has made me choose, reluctantly, 2.6.
NumPy. *So much else* depends on it. If NumPy were ported, it would make porting a number of other libraries trivial.
And also it would be nice to have PyReadLine and then IPython ;)
Django?
Right now? Low-level infrastructure bits that you've never heard of and which are necessary for all the high-level bits that have brand recognition.
You can define your own aliases, to run commit + push. Or you could use light-weight checkouts so checkin = upload (and you can always do a local-only commit if you want to/need to, if you're on a train/plane/etc.).
Hmm, that seems to stop the warning message itself from displaying, but it the bot will still fail to respond to messages it doesn't understand. I assumed it would have some sort of canned responses for those situations, but perhaps not.
You can setup any canned response through editing the AIML files and resetting the brain. Learning to write AIML is a whole different issue.
I'll look into it. Thanks.
python-ogre, Django, pyglet etc.. Django, I don't see supporting 3.x.x for quite a while yet.
No problem. I wasn't too clear with my source code release about the different jobs each part of the bot is handled by. The python code basically takes user input from Omegle and feeds it to the AIML interpreter. The AIML interpreter reads in the AIML files and figures out how to respond.
pyexpect I did some basic porting so the functionality works, but the error handling is waaaaay off. 
PyQt has been ported to Python 3.
I have trouble thinking in Qt style, I far prefer pygtk. Perhaps it was just the book I had on PyQt I didn't really like.
Twisted unfortunately
I wonder how long it will take them to have a working and competitive alternative to CPython.
PyOpenGL. Unfortunately it is not going to be ported.
like?
**setuptools**
The [Distribute fork](http://tarekziade.wordpress.com/2009/07/22/preparing-to-release-distribute-0-6/) of setuptools is [compatible with 2to3, or at least working on making it compatible if it's not already](http://bitbucket.org/tarek/distribute/src/tip/port.sh), and the developers are [very interested (gigantic thread)](http://www.mail-archive.com/distutils-sig@python.org/msg08234.html) in getting Eby to bless the fork as official in some capacity, which is a good sign. (In unrelated news, Eby finally fixed the PEAK wiki after years of slow loading times, hooray!)
Not a library, but clarifications about how WSGI should be implemented. [mod_wsgi's Graham Dumpleton](http://blog.dscpl.com.au/2009/04/python-30-support-in-modwsgi-to-be.html) and [WebOb's Ian Bicking](http://groups.google.com/group/paste-users/browse_thread/thread/95320c9aaa571b79) are two developers who control important web libraries and have been waiting to fully work on Python 3 support because of this. (Both of those links are a few months old, so maybe things have changed since.)
psycopg2, mysqldb are 2 big ones.
It's being developed by Canonical for use with Ubuntu, but I'm guessing that it can be easily packaged for other distros. 
* lowlevel database libraries: psycopg2, sqlite * highlevel database libraries: sqlalchemy (would need above 2 first) * gui layers: pygtk * web layers: pylons (which woudl require webhelpers, webob, et al), then the other web frameworks built on it could move if all those libs were converted, the basics for a writing a serious program (client gui or web based) would be present, and the early-adopters would start moving in. 
&gt; I wonder how long it will take them to have a working and competitive alternative to CPython. We plan to have an initial JIT release in December.
Yes, but how long until I can do "apt-get install pypy" and start using it? Will it start being competitive in December? How much of the standard library do you implement?
&gt; Yes, but how long until I can do "apt-get install pypy" and start using it? That is up to Debian naturally. &gt; How much of the standard library do you implement? All of the pure Python code and all of the most used extension modules. If you have a need for a module which we don't implement, we can certianly do that for you.
January. Didn't you listen during the sprint? :-)
I fear I have but one point to give for my Numpy . . .
There's some projects I'd like to write up in Python, but I'm just learning how to code and it seems ridiculous to code them up in 2.x just because I need NumPy. I'd rather learn Python 3.x and code up these projects than have to move everything over once NumPy is finally ported.