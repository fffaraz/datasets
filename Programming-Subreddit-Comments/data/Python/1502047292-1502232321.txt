So, based on how I am understanding this, there doesn't seem to be much to *automate*. Your biggest issue is the concurrency, which can be solved by Office365/exchange server or simply using google drive. Without that, it sounds like the ideal end product would be a database with fields: Date | Visitor Type | Name | Times | Extras | Ref # Then there is a gui/front-end that allows you to search for records, edit specific records, and select files that are relevant to that record. A database is key here, since it support concurrent access read/write, and down the line you can automate report generation, etc.
On my experience, it is often simpler to factor out the numerical core as a pure, numba-compatible function from your high level object oriented wrappers. As an added benefit, this makes it clear which parts are intentional complexity, and which parts are written the way they are for performance reasons only. 
Try `pip install --user textblob`. That will install it to your user environment.
Lookup SQLAlchemy. It has basic functionality to connect and query databases, but also has an ORM (object relational mapper) that allows you to treat tables as classes and object instances as rows. Great way to start. Easy enough for a beginner, powerful enough to get through advanced usage. As a bonus, it has excellent documentation
Hmmm. I think I will add this to a few of my classes. It seems easy enough since ~~I don't think it'll break backwards compatibility.~~ (See edit) When I read [this site](http://www.navedali.com/technology/python/property-in-python) it also shows how to do getters and setters. I wonder why so many libraries still have them explicitly (I'm looking at you matplotlib) **edit**: In my testing it *does* break it. If I used to reference the property with `()` for a function and add `@property` I can no longer call it. This absolutely makes sense, but does mean that it may break compatibility.
Thanks OP! I will check this out.
Yeah getters and setters alone have convinced me. That combined with a class constructor variable and you can already save some code and a lot of typing. If that variable never needs to get set then you just have a single property such as "number_of_products_with_assets" instead of having to type "get_number_of_products_with_assets()" every time.
Various folks here are telling you how to fix the mechanics of this. Their answers will work. If you're just learning the how the language works, that's fine. However, your example problem and some of the solutions presented make me worry that you're headed in the wrong direction here. You should step back, and think about whether adding two bank accounts is a sensible thing to do. It isn't a sensible thing to do if doing so creates a third bank account, as some of the solutions suggest. Adding account balances ('amount's in your terms) is a sensible thing to do, so: print(sum([bc1.amount, bc2.amount, bc3.amount])) is actually a better statement of the problem and the solution, or more generally: accounts = [bc1, bc2, bc3] print(sum(account.amount for account in accounts)) and these will work without overloading the operator.
Spin up a .sqlite. Interacting with sqlite is straightforward and simple.
Yes the problem is with them not using the proper syntax. They seem to require static type info for names, Python has type hints of PEP484 for that now. The Graphene project may predate the PEP, I am not sure, but GraphiQL seems to do a lot with types and it might form a useful showcase for Python types if they were used. I thought that maybe there might be such a library already available, hence the question. :-) 
Of course you're spot on with you're analysis. But technically speaking HTML together with CSS is Turing complete so if you really wanted (hint: you shouldn't) you could use that. 
Maybe something involving data? You could have it read in a CSV file and do some processing. Maybe implement one or more algorithms for prediction or classification. Add a couple graphs and you got something. 
i have no idea whats csv file?could u plz tell?
&gt;In Java i would just create a variable at the beginning of the class, and then manipulate the value of that variable throughout the different methods. You can do the same in python classes. Initialize the instance variable in `__init__`. 
Good article, and in my experience I agree that it is almost always not a good idea to use root logger, since usually you do use some external library. OP, if you have a folder with several python console scripts, and you would want to use some standardized logging settings for each of them, what would you recommend - use some common json config to setup logger attributes? (for example, when formatter, handler and logging level should be always the same). 
There is an entire chapter on [data persistence](https://docs.python.org/3/library/persistence.html)
I studied both of your 101 and 201 classes and were awesome. Thank you!
Thank you for your response
Thank you for your response
Fwiw, be careful with property: @property def a_property(self): return [1,2,3,4] `obj.a_property.append(5)` does not do what you think it does.
Thanks for the kind words. That's so nice to hear!
aw. I won't bother with them, then
Is there a good best practices document somewhere?
The code you've shown has a global `count` at the module level and two *functions* that manipulate that global. You need something like this:- class MyClass(): def __init__(self): self.count = 0 def method_1(self): if something: do stuff self.count +=1 def method_2(self): if something_else and count &gt; 0: do stuff self.count -= 1 
Just FYI -= works in python just like +=
Thanks!
It says Advanced level tho. 
There are three modules before you get to the advanced section. I'm sure it gets pretty technical towards the end.
Topic-related, for those who struggle to grok decorators, this link helped me. https://pythonconquerstheuniverse.wordpress.com/2012/04/29/python-decorators/
~~give me a sec im fixing the formatting...~~ I thought about trying a dictionary to store keys that access the the rooms like dict = {1: room1, 2: room2, 3: room3, etc.} but couldn't quite figure out how to access an object through referencing it through a dictionary.
This is cool :D can probably get you banned though. If they ever release vanilla servers I might try something like this
First off: this would be best posted on /r/learnpython. Second: what's wrong with assigning the actual room object (`room1`, `room2`) to `player.location` instead of using a number? Most other languages in the IF space (Inform, TADS, etc.) use the same design.
Sorry I should have read the rules first. The reason I decided to store it as an integer is simply because of how I chose to make traveling between rooms work. While it's probably not the best way to do it, i have it layed out like a grid: 21, 22, 23, 24, 25 16, 17, 18, 19, 20 11, 12, 13, 14, 15 06, 07, 08, 09, 10 01, 02, 03, 04, 05 so that if someone wants to travel north or south I just add or subtract 5. If they want to travel east or west I just add or subtract 1. Though maybe that was just a dumb way to lay it all out...
Perhaps it's best you forget.
You must love pandas!
May I also recommend one my older presentations in a Python meetup: [Using functional programming in Python like a boss: Generators, Iterators and Decorators](http://nbviewer.jupyter.org/github/akittas/presentations/blob/master/pythess/func_py/func_py.ipynb)
I guess I understand what you're trying to do, but I thought it might be better to see how those other IF-specific languages laid out how their "world" behaves. In general, rooms/locations/places all have direction properties pointing to other room objects - or if not, the property has code that prints out something to the effect of "This leads nowhere."
The types have method definitions: https://github.com/graphql-python/graphene/blob/master/graphene/types/scalars.py
MPL has them because matlab had them for a long time, and the idea of MPL was to port matlab plotting capabilities to python. Nowadays it is much more advisable to use this syntax from matplotlib import pyplot as plt fig, ax = plt.subplots() ax.plot(x,y) ax.set(xlim=(0,1), xlabel='a label', ylim=(0,1), ylabel='a label', title='a title') etc.
It had better come with food and a tank cause I'll be damned if I have a pet sn√¶k running rampant in my home.
Nope. Definitely not why we're here. 
Thank Guido for wheels. Not only are they safer, they're faster to install. 
Exactly right, so youre suggesting using office365? Wouldnt the best program there still be excel? And is there a built in "gui/front end" or are you suggesting to build one with python? Edit: im not familiar with exchange server, is that similar to office365?
Great question! Your proposal (type annotations) is something that I've been researching and investing my time lately. Graphene is used not only in Python 3 environments (about 60% of installs in the last month) but also Python 2. Because of that it's API must remain compatible with both environments. However, given the increased adoption of Python 3 I'm trying to move the codebase towards this new capabilities of Python, and pushing slowly the developers to update to latest versions of Python (as they will get new features). The next version of Graphene (2.0) is trying to move the codebase further to make this transition much easier in the future, not only regarding type annotations, but also for a improved resolver API (arguments are directly passed now as keyword arguments in the resolver function), subscriptions with observables (async iterables), and other cool and special features only available in Python 3 (`__init_subclass__`, class arguments, ...). The syntax that you are looking for will be implemented not that far in the future, after 2.0 is released officially. Actually I've already researched and put some thoughts in to the 2.0 PR in Graphene (see Type inference section): https://github.com/graphql-python/graphene/pull/500 I encourage also to take a look on the PR and provide as much feedback as you can (and want to provide! no rush if you don't have time now!) :)
I'm guessing there is no prop.setter equivalent? I assume one could roll-their-own? If not, seems like it would be a good addition to property decorators.
There is, but `@setter` is a bit weird: @a_property.setter def set_a_pro(self, val): # do something This is fine when you have strict getter/setter properties, but it doesn't work if, for example, your property just doesn't have a setter, and you perhaps don't realize that.
Hi, thanks for posting this! I'm impressed with the effort you've put into the documentation, and I have some feedback on the code, hope you don't mind: 1. Make sure that you names things in a way that others can understand; the module and variable naming should be more verbose and self-explanatory. For example, you have files `gb.py` and `lb.py`, which should be named `global_best.py` and `local_best.py`, respectively. The class `GBestPSO` should be called `GlobalBestPSO`, or `GlobalBestOptimizer`, or something like that. Whatever you go with, be consistent. 2. Your use of `**kwargs` in `GBestPSO.__init__` is a little suspect - they seem to be mandatory, in which case they should probably be passed as normal arguments. 3. Some more naming examples: rather than naming the dimensions parameter `dims`, call it `dimensions`. The `optimize` function takes a function `f` as an argument. Don't call it `f` - that's completely opaque. The docstring says it's an objective function, so call it `objective_function` or `objective_func`. To belabor the point, when dealing with velocities use that actual word - `min_velocity` rather than `v_min`, for example. 4. You define `GBestPSO.assertions` but all it does is call it's super-class function. So you should just get rid of that, and let inheritance take care of it. 5. With a little refactoring you can get rid of some redundancy. For example, both GBestPOS and LBestPOS have a method `reset`. In GBestPOS this resets the variables `gbest_cost`, `gbest_pos`, and `pbest_pos`. In LBestPOS it resets `lbest_cost`, `lbest_pos`, and `pbest_cos`. So basically these methods do the same thing. Could you remove the prefixes from the variables, and move that functionality to `reset` in the superclass? It would look like this, and I think it would mean you could remove the `reset` implementation from every subclasses. def reset(self): # (The existing code in the reset function) # Initialize the global best of the swarm self.best_cost = np.inf self.best_pos = None # Initialize the personal best of each particle self.pbest_pos = self.pos 
They said Python3 isn't gaining traction? Wat? Am I missing something? I thought 3 was better and I've been using it for some time.
Yes I'm not totally sure the difference between office365 and exchange anymore, with the rebrandings and all. But that sort of cloud platform (made famous by Google drive, which is why I referenced it) would allow multiple people to make edits at the same time without errors, and there is a version history so you can simply reverse any erroneous edits. But no, there would not be any interface/front end on top of excel. 
I've done this course. It counts as like 15 CEUs for comptia security+. However, if you have never done python, then it might get confusing because they skip over some important python concepts that get used in later modules. That being said, it's still a neat course. 
I see security as one of the areas where 2.7 is holding out, mainly because when you access a system it will more than likely have 2.7 on it instead of 3.x so most security related stuff is still in 2,7 and will be until vendors upgrade and then those upgrades get used by large amounts of servers
Then perhaps use the ipython shell it is the REPL on steroids and a gateway drug to jupyter notebooks.
Hi thank you for the reply! I tried print(rgb.dtype) it says uint8 
&gt; ax.set(...) Instead of `ax.set_title()`? I like that! I have been a matplotlib user for nearly three years (almost always using the OOP interface, `pyplot` other than you did) but never heard of this way to set things. It seems much cleaner and I can do it all at once
Yes. `ax.set` wraps most of the `plt.set_`/`fig.set_`/`ax.set_` commands into one nice bundle. And since it's all kwargs, if you're making a bunch of plots over the same thing, you can do my_plot_stuff = dict(xlim=(0,1), ylim=(0,1), ...) ax.set(**my_plot_stuff, custom_attribute=value)
why? When you have a class with property-like values that *do* need calculation, this sounds really nice. What‚Äôs the downside? Serious question.
GUI stuff in python requires using a GUI toolkit. Your best bet for a low effort school project is to use the TK toolkit to create a tic tac toe game. If you want to do some more work and make something that looks cool, download pyGame and do a quick tutorial. PyGame is a powerful and simple toolkit for making games in 2d. You could very quickly crank out a tower defense game, an asteroids clone, or a tank battle clone.
Hey wow, thanks for this. I'll do some refactoring this week and will remove some redundancies in the code. :) Thanks so much! Anyway, sent you a message to ask some more questions, hope you don't mind
Thanks for all your answers, i think ive got a better idea of what i need to do now!
Intersting lessons, testing is important and measuring is uber important. Go is nice for a quick and fast command like tool, but this whole one binary to rule them all, gets old very quick.
Like I said, definitely a novice. Is there a better/simpler way to accomplish this?
I'm working on a text based adventure to teach myself more than python basics. Focusing on slow typing text for immersion and multiple choices that evaluate and store certain inputs to change the story. 
No, I was being serious. RMS is such a widely used metric, but I wouldn't have thought of it myself, so I'm impressed. 
No one seemed interested
Nope! NDAs up the wazoo my whole career, sadly. I hate it. I've gotten really into functional programming the last few years, which has made my Python crazy in ways I think most tech artists would hate anyway.
It makes wrapping other languages much easier. With the .NET wrapper I'm using I have to call a setter/getter. This lets me re-write it so it's more pythonic and wrap any casts or decoding and have it still behave like a parameter.
UPDATE: Package can now be downloaded using PIP or from AUR (arch users). PyPI: https://pypi.python.org/pypi/torrench AUR: https://aur.archlinux.org/packages/torrench/
I think the course offered in [Coursera](https://www.coursera.org/) is pretty good, it may be a good start. If you already have a knowledge about programming, you could try [Codecademy](https://www.codecademy.com/) to learn about the language syntax itself.
I learned Python at [Treehouse](https://teamtreehouse.com). The course by Kenneth Love is really great. But there are tons of really good courses out there for free too. After the course I practiced at CodeWars and HackerRank because learning by finding ways to solve a problem is what works best for me. 
The only problem is the power-hungry-ness of electron. As a gui it's open source and pretty easy to use if you just want a gui. And deployment is pretty easy for a lot of platforms. 
`method_missing` is cancer and one of the primary reasons why Rails is dog slow. Of all the features of Ruby, that's the worst one to emulate. 
Thanks syrusakbary. That's the reply I'm after. I shall read as you suggest, but you should note that I think I have much more experience in thinking of what "codes well" than I have in GraphQL (or REST for that matter) , so thoughts are likely to be less technical and more stylistic. *Everyone* thinks they can, and so does, have an opinion on style :-) Thanks again. 
You're up against the fact a lot of hip companies are encouraging remote work (GitHub, WordPress, etc) and they're often paying San Francisco salaries. So given the choice of WFH and earning $120k or commuting to your office with outdated practices for half the money, I know what I'd choose. This means you're only getting the bottom of the barrel, if that. It's a tough market and your CEO isn't doing you any favors. I know a guy who's an incredible programmer, works remotely for a SF company from the sticks in Georgia, and makes $200k a year.
Yes i know about both and have used both.I forgot to mention thaat games are not allowed only productive softwares and i am already using tk.
Only if your program's function is to create logs
The /r/learnpython [wiki](https://www.reddit.com/r/learnpython/wiki/index) has an excellent list of resources. Take a look at that.
* Physics simulators? Depending on how complex you want this to be, you could either limit yourself to one type of simulation (projetile motion, etc) or add menus and stuff to let people use different kinds of simulations. * Something that works on a phone? Can't think of anything specific, but you should take a look at Kivy if you plan to build an app of sorts.
Ok, bit of a guess, because I can't test this (don't have OpenCV on my phone), but Uint8 means your image expects it's pixel values to be unsigned 8 bit integers, so each pixel's value in each color channel should be an integer between 0 and 255, inclusive. If your sepia function receives a white pixel RGB value (255, 255, 255), then your function tries to set the images channels for that pixel to Blue=238.93500000000003, Green=306.765, and Red=344.505 ... none of which are integers, and two of which are above gamut. OpenCV is pretty finicky about data type, so where you give back floats I believe it just reads the first 8 bits and chucks the rest, which is likely why you end up with bizarre values. Never tried this (or much) in OpenCV -- in VFX we use programs that are designed for image manipulation more than computer vision -- but after a bit of googling it looks like you need to **cv2.transform** the image with a matrix, and that operation takes care of datatypes. def sepia(rgb): mat = np.asarray([ [0.393, 0.769, 0.189], [0.349, 0.686, 0.168], [0.272, 0.534, 0.131]]) return cv2.transform(rgb, mat) What I don't know is if this will actually come out sepia, because OpenCV likes to think in BGR instead of RGB. You may need to swap the first and last arrays on the matrix, or do one of their channel order conversions.
Thanks, that solved some of the issues. But when i try to call these two methods in a 'while True:' loop, i'm getting this error: "NameError: name 'self' is not defined" if i remove 'self' as a parameter, it obviously complains that it's missing because it is used when defining the methods. 
Thanks, not really sure why i thought it wasn't :D 
Thanks! Is the __init__ the python equivalent of a constructor? And should i define all variables within it? Because so far this is the first variable which have caused me trouble, and so far i haven't been using the init.
It stands for a [Comma-Separated Values](https://en.wikipedia.org/wiki/Comma-separated_values) file and is used to store tabular data in plain text. Say you have the following table: Programming Language | First Release ---|--- Python | 1991 C | 1972 Java | 1995 You could store in a file (say `languages.csv`) like this: Programming Language,First Release Python,1991 C,1972 Java,1995 Since your data is stored in plain text it's easy to work with.
I've also noticed this. I will try what you recommended and see.
**Comma-separated values** In computing, a comma-separated values (CSV) file stores tabular data (numbers and text) in plain text. Each line of the file is a data record. Each record consists of one or more fields, separated by commas. The use of the comma as a field separator is the source of the name for this file format. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Maybe you could make a mortgage/loan calculator?
Also, its interesting to read about why and how closures work. It brings out the philosophy behind the language's design.
Haha i feel so much for you bro
I don't think any of these could be coded by a beginner in 8 hours time... Just my 2 cents. There are endless coding challenge for beginners that would be much more reasonable that are a Google search away...
Now look into descriptors &lt;3
Apparently, using the plot.imshow (matplotlib)will show sepia. But using cv2.imshow is kinda bluish. But thank you for the explanation :) Here's the output: cv2.imshow [Screenshot!](https://hostr.co/file/970/78H1y40fULE3/weird.png) matplot's imshow [Screenshot!](https://hostr.co/file/970/NpB0M2DkVrvs/Wow.png) 
That's what I'd expect if the R and B values were swapped.
You forgot to open &lt;rant&gt; there. I just wish they were both likely to be present in any given install of Python; at work I've spent way too many hours ssh'd into random machines.
"Magic" aside, one of the greatest strengths of pytest is that it makes much better use of *Python* than unittest does: it very nicely leverages free functions, decorators, context managers, ‚Ä¶, for a very simple reason: unittest is an xUnit framework. Which means it is fundamentally rooted in SUnit, the unit-testing framework for Smalltalk in which every non-local code blocks is a method in a class somewhere (and of course messages are camelCased). That is why you deal with test suites, override `setUp` and `tearDown`, inherit from `TestCase`, ‚Ä¶: it has its origin in the testing framework of a language for which classes and method calls are the core tools, nay, the only tools. In fact, worse, `unittest`'s direct ancestor is probably JUnit rather than SUnit itself[0] which is hosted by a language more constraining and limiting than Smalltalk, especially circa late 90s/early aughts. Also of note: the pytest runner can run `unittest` tests just fine, if your codebase currently uses unittest and you want to migrate, you don't have to do it at once, you can just start with `pytest` as a discovery/runner tool and start introducing fixtures and pytest-style tests afterwards. [0] SUnit does *not* have a whole slew of `assert*` methods, it has `assert: aValue`, `deny: aValue`, `should: aBlock` and `shouldnt: aBlock` (with variants with messages and ‚Äî for the latter two ‚Äî exceptions), because it can easily give access to the live stack: you're essentially always running `pytest --pdb` except Smalltalk doesn't unwind by default so it doesn't even need the mess that is `post_mortem`, when an assertion error is raised you can see the "live" code right at the top of the stack.
As a beginner to python, machine learning is still above me. Not the concept of it, but the technicalities of it all. Still working to wrap my head around the specifics. Maybe if I get another month or two of tinkering with it here and there I'll probably get ML down
Seconded. A month @ 8 hrs/day, *maybe*, on a couple of them.
Sure I do, but I honestly haven't pushed a lot of things there. Many of my tools are very domain specific, so it wouldn't make any sense to post it anyway. https://github.com/segfaultsourcery
I've tried teamtreehouse and code academy. Code academy is free. Teamtreehouse has a lot of well thought out instructional videos, but they can be lengthy. I learned faster with code academy because I spent more time hands on.
Oh, I thought this would be hosted in a machine at his work place or something.
Thanks for the info. I'll keep this for the future, maybe something to aspire to!
I don't have a good answer for Flask introductions, actually. I've been using it for such a long time. What I can tell you is that I often tend to make REST APIs using Flask's blueprints, and some miniscule amount of HTML to present it. I mostly use homegrown tools, actually. [Slinkie](https://github.com/segfaultsourcery/slinkie) would be one I've actually shared, but I often use the standard csv module and matplotlib.
I could make one for Google but I'm not entirely sure of the Google voice api. Someone made a python package called Google_voice but I have zero idea how to use it and the documentation sucks. There's nothing on Google about it. I'm not sure how to use it.
That's interesting. Do you have an example?
Oops... Maybe best as a forewarning, not even to be syntactically correct, eh :)
Add `logging` to this list. No clue how these non-python packages ended up in standard lib. Thank god that the changes have to go through PEP now.
Gotcha! Thanks anyways!
Bugger forewarning, I just want to know how to parse!
Honestly any one of them is a good project to spend 3 months on.
Awesome article and website. Keep it up!
Wrote a handful of 1-3 pages of django micro-sites, as part of my boot camp. Will be working on ORM and OOP the next couple days.
Very interesting! Thanks for sharing!
Thank you, I gonna try to swap it then notify you. Lots of thanks!!
Yeah, in your case I would recommend returning a tuple or another collection that can't be modified in-place as it better reflects the readable-only property :)
I see a lot of hate for logging, any alternatives?
Please go to /r/learnpython and read the side bar :)
Hi, it's now working. But it seems that the video is now faster compared to normal? 
What's wrong with logging? Sure it's Java name conventions, but other than that, I can't think of anything prickly about it. 
it's just awkward and implicit. You need to add formatters and the whole setup in general is not designed with humans in mind. 
I recently found [logzero](https://github.com/metachris/logzero) here on /r/python and it's great! 
Afraid I got no idea on frame rate; honestly I'd be doing all of this in ffmpeg.
I tried to fix it by adding a delay. Thank you for the response!! I'll try to consider yung ffmpeg because it seems the audio is removed when using opencv. Do you have any references or anything that could help me, besides the documentations, related to video processing?
You nee to change the value of time.sleep. The number in the brackets are the delay in seconds.
It works mostly fine, but can't parse everything, for example for this article it returns empty text, it is probably fooled by the embedded video: http://insider.foxnews.com/2017/08/06/maxine-waters-dershowitz-being-black-license-call-people-racist Also, for some long NYT articles, it just parses the first part, not the whole article. But overall, it is quite good.
I'm not sure what rule I might be breaking. This isn't an assignment of that is what you are referring to, its a personal project I'm tinkering with. Is there something else I'm doing that breaks the rules? I'm still pretty new to reddit
I meant it to have it like that so it has a delay of 100 milliseconds.
Too small letters. I can't see the code when he is using Geany. Pass
Java makes me want to die of boredom. Fuck Java.
Have you tried reading the docs? https://pip.pypa.io/en/stable/installing/
I've heard good things about [logbook](https://logbook.readthedocs.io/en/stable/index.html), [structlog](https://structlog.readthedocs.io/en/stable/) and (as mentioned by u/Fakeman), logzero. I haven't tried any of them personally, they're all still on my todo list, but could be worth a look.
Upvoted for "nay".
+1 for pytest. I think the one of its most important features is fixtures. The fixture 'scope' is really comfortable and intuitive, greatly reducing unnecessary lines of code found in other test runners. btw, after watching the pytest's community for a while - it is no surprise pytest is successful - all PRs/issues I saw were addressed really quickly and releases are frequent too. 
Sadly, sometimes you don't get a choice.
I fixed your mismatched XML with flair. :)
But there's no xml declaration, no doctype, no schema defined, no namespacing. :P
There's only so much one can do with flair.
The answer lies in your words: By doing this, you're obfuscating the fact that they need calculation.
It's convention to name the first parameter of a method 'self' (though it can be called whatever). It's a sort of back reference to the instantiated class, and will allow you to access attributes of that class. It's similar to using 'this' in Java. When you call a class method, you don't actually need to supply that parameter: class MyClass: def __init__(self): self.count = 0 def method_1(self): self.count +=1 c = MyClass() print(c.count) # outputs 0 c.method_1() # increments MyClass.count print(c.count) # outputs 1 
&gt; If you are about to ask a question, please consider r/learnpython or the learn python discord. Your question should be posted in /r/learnpython 
I once opened tests for some project I cloned from github and it took me 20 seconds to realize this was Python and not Java. Pytest should be standard testing framework in Python, not this abomination we use for unit testing (and logging).
Honestly it takes a *lot* to make truly compliant XML as I'm finding out recently.
&gt; Wondering how the things I'm learning will be of any practical use in the future. They won't, software is totally impractical and having a tool in your belt capable of solving literally any problem is completely useless, I'm pretty sure you won't use it at all in the future. /sarcasm
Hey this is rad, thanks! 
Unfortunately Tensorflow doesn't yet work on python 3.6... Install python 3.5. I use Pycharm, I solved it by: 1. Starting a new project 2. Make sure the interpreter on the create project screen is 3.5.* 3. Click on the little gear next to the interpreter address and select "Create Conda Env" 4. Name it what you want... 5. Create the project then go to Tools &gt; Python Console 6. Input: import pip 7. Input: pip.main(['install','tensorflow']) 8. Repeat as necessary substituting tensorflow for other modules needing to be installed. That should sort you out... Good luck! üëç 
Guido should at least have got rid of the camel case names with python3.
I've forked your repo. I reworked the XML generation to avoid messy string handling by implementing a simple XML context system. I added "Expression" and "Constant" types to make it possible to perform operations on XacroProperty objects and receive an evaluable expression.
I like the simplicity of just using `assert`, but the way it implements it is [some scary dark magic](https://docs.pytest.org/en/latest/assert.html#advanced-assertion-introspection) &gt; Reporting details about a failing assertion is achieved by rewriting assert statements before they are run. ... pytest rewrites test modules on import by using an import hook to write new pyc files Does this rewriting ever fail? Does it ever make it confusing to understand how your code is running?
Oh thank you! I didn't realize those were different sub reddits ...
Shudda tested it. 
I have been using Pandas ,Numpy,and Seaborn together a lot recently. But I have used Pandas only to create dataframes for storage and display and the save the result in Excel. I consistently use Numpy for all mathematical operations (arrays and matrices). I find the transition back and forth seamless, easy, and convenient. And Numpy is fast. Why would I want to use Pandas for array operations? And even if I employ these techniques, isn't a large Numpy array operation likely to be faster than Pandas? [This was not a rhetorical question ... I am truly curious. And for me it is not an academic question. I am using single arrays that are multiple gigabytes in size].
So i basically just need to make an instance of my class, and then call: class_name.method_name within my loop? 
Pytest is up there with Requests in the class of modules I didn't think I needed until I tried them. "Python has nice built in tests and HTTP handling, so what's the point in going elsewhere?" [tries it] *Ohhhh....* In both cases, I'm never going back.
&gt; &gt; Does this rewriting ever fail? I've not seen it fail in 4+ years of using it. You can use command-line options to disable the rewriting too if you so desire. &gt; Does it ever make it confusing to understand how your code is running? The only oddity I've noticed is that if you were to print out all of the locals after an assert (*not* using the ``--showlocals`` cmdline option), you'll see some variables named ``@pyassert0`` or ``@pyassert3`` which are used to expand both sides of the assertion (and executing them only once). 
I guess you'll find useful vdist (https://github.com/dante-signal31/vdist). It lets you create DEB and RPM packages from your python projects, including both python dependencies inside and system packages dependencies. With vdist you can even deploy a python3 application in systems with only python2 available.
While it's doubtful that using a grid for mapping your rooms is the best approach, here's how you would reference a room object through a dictionary: rooms = [Room(1, 'title 1', 'description 1'), Room(2, ...), Room(3, ...)] d = {room.num: room for room in rooms} print("{}\n\n{}\n".format(d[player.location].title, d[player.location].description)) I would define a __str__ method in the room class to make the above less verbose: class Room: ... def __str__(self): return "{}\n\n{}\n".format(self.title, self.description) Then you can print title and description by printing the object: print(d[player.location])
I just make it compliant enough for whatever parser I'm using. ¬Ø\\(„ÉÑ)/¬Ø Stupid JSON and no stupid trailing commas. It's 2017, people... *grumble grumble*
I don't get the implicit part, but I can see where you're coming from. Maybe it's just that I'm used to the logging module, but it is a bit clunky to setup. dictConfig does make it easier though
Thank you! :)
I have a question which is important to me. On micropython if I upload an infinite loop I have to **reflash the firmware** to fix it, which sucks! Is Zerry better about this? 
I guess you'll find useful vdist (https://github.com/dante-signal31/vdist). It lets you create DEB and RPM packages from your python projects, including both python dependencies and system packages dependencies. Python dependencies are directly included inside package along its own and self-sufficient python interpreter. System dependencies are set as dependencies of deb/rpm package generated with vdist. With vdist you can even deploy a python3 application in systems with only python2 available.
If by class_name you mean the name of the instantiated object ('c' in my example above), then yes. Also, take a look at https://docs.python.org/3/tutorial/classes.html Going from Java to Python classes is fairly straight forward.
I think he is referring to the Zen of Python [0] where it says: Explicit is better than implicit. [0] https://www.python.org/dev/peps/pep-0020/
Yes that was exactly what i meant. Thanks a lot, i will have a look. 
Unfortunately I'm targeting a third party's parser that I don't have access to. ;_; If anyone's got a nice remote job going, on an unrelated note...
Does Pynsist give a single file .exe option?
If you haven't stumbled across it yet, look at the pytest.parametrize decorator. My tests radically changed once I discovered that. https://docs.pytest.org/en/latest/parametrize.html
You could also use Excel. CSV is a simple file format that has fields and records. It's easy to use and most data applications work with CSV. Excel and other spreadsheet software will save as CSV. 
Probably, I don't get where the implicitness is though. 
I guess you'll find useful vdist (https://github.com/dante-signal31/vdist). It lets you create DEB and RPM packages from your python projects, including both python dependencies and system packages dependencies. Python dependencies are directly included inside packagealong its own and self-suffcient python interpreter, while system dependencies are set as package dependencies. With vdist you can even deploy a python3 application in systems with only python2 available.
Pytest is the first thing I setup in a new project. Love it. I also like the "sure" library. Allows tests like: foo = 1 + 2 foo.should.equal(3) Just reads better for me. 
It depends a lot on what types of calculations you're doing. If all you need from your dataframe is strictly math, or if you're working with a single array at a time, NumPy is probably your best bet. The way I see it, Pandas can do almost everything that NumPy can do (though it may sometimes do it a bit slower), and then it can do some things on top of that. Some of the advantages Pandas offers over NumPy include: 1. Indexing. If you need to join dataframes, indexing is hugely helpful, as it will keep track of your series alignment for you, instead of having to do it manually. Having column names to refer to your data also helps quite a bit! 2. Groupby. As far as I know, there is no streamlined NumPy equivalent to the groupby functionality that exists in Pandas. 3. Streamlined operations. Pandas is much more high-level than NumPy, so things like complex string operations, data imports/exports, prepping data for graphing, and time-series operations require a lot less manual coding, and are built-in with all the optimizations already in place.
They mean that `key` and `reverse` are keyword-only arguments. That is to say, `sorted(a, b, c)` is not the same as `sorted(a, key=b, reverse=c)`.
r/learnpython https://www.python.org/dev/peps/pep-0457/
Have you looked at the source for how namedtuple works? Sometimes in Python it seems like dark magic is the way to go. 
This is where sqlalchemy is doing such things: https://github.com/zzzeek/sqlalchemy/blob/master/lib/sqlalchemy/sql/elements.py#L4256 I won't pretend to know exactly how they did it, but the filter method is able to take a call that looks like someqry.filter(tbl1.col &gt;= 5) and the filter method is receiving something more than just True or False as an argument. Perhaps something to do with the inspect module and the interpreter stack? https://docs.python.org/2/library/inspect.html#the-interpreter-stack 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [zzzeek/sqlalchemy/.../**elements.py#L4256** (master ‚Üí 4b4f8fb)](https://github.com/zzzeek/sqlalchemy/blob/4b4f8fbf25f1a5a76c1579c1a3fd6ffad07c8c66/lib/sqlalchemy/sql/elements.py#L4256) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dlaakn3.)^.
Yes, but you can define variables outside the constructor. Those will hold the same value across instances of your class (static). Values defined inside class methods (prefixed with ```self.```) are member variables and are one per instance.
Every time you want to change the firmware you have to edit it and [uplink it](https://docs.zerynth.com/latest/official/core.zerynth.docs/gettingstarted/docs/index.html#verify-and-uplink-a-zerynth-project) to the microcontroller. So if you start with this code ("[Hello Zerynth" Example](https://docs.zerynth.com/latest/official/core.zerynth.stdlib/examples/examples.html#core-zerynth-stdlib-hello-zerynth)) # import the streams module, it is needed to send data around import streams # open the default serial port, the output will be visible in the serial console streams.serial() # loop forever while True: print("Hello Zerynth!") # print automatically knows where to print! sleep(1000) and then you want to change the output "Hello Zerynth!" in "Hello Python!", you need to change the firmware as follows and uplink it to the MCU. # import the streams module, it is needed to send data around import streams # open the default serial port, the output will be visible in the serial console streams.serial() # loop forever while True: print("Hello Python!") # print automatically knows where to print! sleep(1000) This is the standard way of working with microcontrollers. Anyway, the uplink phase is very fast in Zerynth.
So if I needed to have all of the function items in a class for later presentation, maybe what I'd do is call an initialization func, then run the calculations based off of those initialized np.zeros, then using a separate, non jitted function, add them all into a class?
will be checking it out sometime this week.
If I read the PEP and [this](https://bugs.python.org/issue26729) correctly, "/" means that *iterable* is position only, "\*" is there to allow for the *cmp* parameter to be provided and ignored for backwards compatibility (it's a deprecated part of the signature from 2), and the rest does indeed mean that *reverse* and *key* are keyword-only. IIRC, the latter two have always been keyword only, but the issue seems to have been nobody knowing that sorted(iterable=range(5)) would fail.
What gave it away, you couldn't find a class named AbstractServiceFactoryFactoryProviderImpl?
Well I'm still getting myself set up and have only had a cursory look at the book so far to see what it contains and it certainly looks promising! While the second edition isn't released until October, I did find a link to the first version [here] (http://www3.canisius.edu/~yany/python/Python4DataAnalysis.pdf) that I think will do in the meantime!
Hey, it could be worse. Turns out my team rolled their own that silently chokes when it doesn't have a BOM. Except it only handles UTF-8, so... üòï
cool story
Idk if I'm crazy or just hadn't had enough coffee yet, but I think your math is off. (2 * 0.6) + (9 * 0.3) = 3.9, not 7.5 edit: other than that, great post! Learned a lot having never attempted to learn NN's in the past.
I hadn't, thanks! Here's [more info](https://stackoverflow.com/questions/17916853/how-named-tuples-are-implemented-internally-in-python) and a link to the Python source. Long story short; it makes a new class for each namedtuple. It generates the class by starting with a template string, filling it out for the requested named tuple, and then passing that string to `exec()`. Metaprogramming is fun! But that seems relatively straightforward compared to modifying byte code to rewrite assert statements.
PythonAnywhere
StructLog is great. It's useful for formatting and outputting to json and has a minimal calling convention. It integrates with other loggers including the stdlib as well.
https://stackoverflow.com/questions/1133857/how-accurate-is-pythons-time-sleep You might need a low-latency OS. https://en.wikipedia.org/wiki/Latency_(audio)#Computer_audio 
I see that most of the projects you thought of look like machine-learning and even deeplearning projects. You most likely will end up with neural nets in every cases. Is this what you want? Question answering looks like a real challenge to me. Gathering data and figuring out the way to train the model is not trivial. Things like character recognition are way more accessible. 
Still using logging, but logzero might be a good replacement.
Yes, I can see your point. I mostly do mathematical operations, some of them fairly involved, like Fourier Transforms, The only data wrangling that I ever do is slicing and rolling (aside from visualization, displaying results, and saving results). Thanks for the answer.
Is there a VM you can use or request access to? Using a VM has been my workaround in my current corporate job. 
I see, so it may just be the that the OS is incapable of doing so?
I left the company and now work at a startup that supports my quest to become a developer by letting me write automation scripts and going as far as setting me up with a professional IDE, even though I'm not a developer officially. :)
I'm not entirely sure what he means by implicit either. I do think the amount of hidden state in the python logger leads to a certain kind of "implicitness." Where some of the options on the various loggers at different levels lead to messages being suppressed. For example in my boilerplate function to set up basic logging for my apps I have a line: `logging.getLogger().setLevel(logging.NOTSET).` Which I found I needed because by default the root logger was hiding stuff below the level of INFO, but it isn't something I set, it was just something that the root logger had "out of the box."
Guess one man's "elegance" is another man's "magical bullshit". But, Pytest is so flippin useful and featureful that I put up with and learn all it's weird magical bullshit ways. 
I am absolutely new to testing, and i picked up 'mock' instead. I am in python 2.7 Will it hurt me in the future? Should i switch to pytest instead?
I sort of get around logging my using the most basic boilerplate code. DEBUG = False def log(*args, **kwargs): """do something, and print for log and screen""" ... print(*args, **kwargs, file=open('log.txt', 'a')) print(*args, **kwargs) if DEBUG: log('this is a thing I want logged if program exploding') Now, I don't write server side code, so it's not like I'm logging webserver requests, but it is a heck of a lot simpler than fighting the `logging` module. If the program is crashing, turn DEBUG on, and rerun it. Works on a per-module basis, which is great. edit: why the downvotes, I wonder to myself...
You can look at ASIO on windows, but beware of licensing. https://en.wikipedia.org/wiki/Audio_Stream_Input/Output You can look at the linux RT-Kernel and perhaps the PyAudio or JACK-Client. 
Normally when we talk about blockchains we are talking about a no-trust distributed system. This isn't that as far as I can tell. 
As long as it's fast. Arduino takes about 10 seconds to upload but micropython takes me a few minutes using some annoying script that I always have to google for (on the esp8266 anyway)
No
Citation?
Do you think that question answering still be as challenging if the questions are required to be in a specific category and have only one answer? Because I've been researching the concepts a bit and it doesn't seem to me like QA would be terribly difficult, but you might know better than me. Also, the main reason I'm hesitant to go for the character recognition is because it's a data science group, and character recognition seems like it would have much to do with data collection. But if the other options really are too difficult for college kids then it would be fine.
I honestly don't think that there are any python "batteries included libraries" that aren't like that. There's an equivalent for pretty much all of them that's probably better.
In Python we write an underscore as the first character of the name of functions to say "this is private". It's not enforced but it's the polite way to do it. 
Nope. It bundles Python and your application source code together. 
Zerynth and Micropython are two completely separate projects. Zerynth has been developed from scratch thanks to the support of a Kickstarter campaign. For a more detailed comparison take a look here: [Micropython vs Zerynth](https://community.zerynth.com/index.php?p=discussion/382/zerynth-vs-micropython) Zerynth takes about 10-15 seconds to upload, and you haven't to to use any script. Take a look here: [Python for ESP8288 using Zerynth](https://www.zerynth.com/blog/python-for-esp8266-in-just-a-few-clicks-using-zerynth/)
&gt; People can get python news anywhere, okay? They come to /r/python for the atmosphere and the attitude. Okay? That's what the flair's about. It's about fun.
Could be. I didn't even consider that possibility.
I probably use stdlib for 90% of stuff (judging by import counts) because most of it is excellent, and 3rd party packages aren't often *enough* better to make it worthwhile. But when the *are*, wow, are they ever.
For question answering, it really depends on the precise thing you want. If the goal is for the model to completely choose the answer with no restriction (just by forming an english sentence), than it is really hard. On the other hand if it is, for example, choosing the right answer between four propositions when the questions and answer were already the same during training is really much easier. About data collection, character recognition doesn't really involve more than question answering. Most people, for their first project, use things like [MNIST dataset](http://yann.lecun.com/exdb/mnist/), where the data are provided and well organised. But I don't see obvious available datasets for question-answers. So I would say that you would have more work to do in data gathering with the question-answers problem.
So much this. No more manually collecting errors so we can tell whether 1 of 100 or 99 of 100 test cases have failed!
AFAIK, you only have to pay for it if you want them to manage your app for you either "On-Premise" or own their own servers. Dash is a Flask app at the end and you can do whatever you want with it. https://plot.ly/dash/deployment The code itself is under MIT License (https://github.com/plotly/dash/blob/master/LICENSE)
Monty Python my behind.... [THIS](https://s-media-cache-ak0.pinimg.com/564x/1f/47/50/1f4750431ba950d562cbb2658c76da9e.jpg) is where the name "Python" came from!
&gt; I don't get the implicit part I think these concerns is what they meant, quoting from a [post](https://www.electricmonk.nl/log/2017/08/06/understanding-pythons-logging-module/) recently submitted here: &gt; "One thing that's not immediately clear is that the logger names don't include the root logger." &gt; "When you log a message, the level is only checked at the logger you logged the message against. If it passes, every handler on every logger up the hierarchy is called, regardless of that logger's level." &gt; "By default, loggers have a level of 0. This means they use the log level of the first parent logger that has an actual level set. This is determined at message-time, not when the logger is created." &gt; "[Invoking `basicConfig` with a `DEBUG` level] causes debugging output for all loggers in your program, including every library that uses logging. This is why the requests module suddenly starts outputting debug information when you configure the root logger." I don't have enough experience to tell if these are valid concerns, but these aspects of `logging` do seem more implicit than the Zen calls for.
Title and github domain are quite misleading... it's about an API to a paid service.
http://commoncrawl.org/
Pytest and pytest-watch made me so happy.
That's awesome, thanks for the share!
Time to bring [this up](http://web.archive.org/web/20160818035145/www.javafind.net/gate.jsp?q=%2Flibrary%2F36%2Fjava6_full_apidocs%2Fcom%2Fsun%2Fjava%2Fswing%2Fplaf%2Fnimbus%2FInternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonWindowNotFocusedState.html) again....
that's too lines of code, right? 
Anyone who can explain why I should use pytest rather than doctest. def sum(*x): """ &gt;&gt;&gt; sum(5,5,5) 15 &gt;&gt;&gt; sum(5,15) 20 """ total = 0 for i in x: total += i return total
First of all, make sure you're sure about what version of Python you want to learn (2 or 3). I got into Python using Codecademy (which teaches Python 2), but I did not really enjoy their course. The course is also focused on teaching the syntax, not programming itself (if that makes sense). For Python 3 I'd really recommend checking out sentdex on YouTube. E: I also found [Learn Python The Hard Way](https://learnpythonthehardway.org/) pretty good. Other than that, I would really recommend just starting with little projects to really get the feel of coding, which (at least I) don't really get from courses alone.
Those are different things. Pytest replaces all the `unittest.TestCase` boilerplate with simple test functions like: def test_add(): assert 1 + 2 == 3 We use pytest with mock extensively, and pytest fixtures are a great way to configure mocks you use a lot. It's certainly better than unittest when you want the same mocks *most* of the time but don't want them for a specific test or two in the suite.
I'm fairly sure you can use them together. Doctests tend to be a poor fit for tests where you need a lot of setup/teardown.
What's pytest-watch
`mock` and `pytest`are orthogonal. Using one doesn't have any bearing on using the other. BTW, if you were on Python 3, `mock` would be baked into the stdlib.
Totally This! +1
I tried structlog *way* back in the day and had a problem with it just refusing to log ANYTHING I sent to it. I assume I had a bad config, but it was (supposed to be) a fairly straightforward setup. Is this (or was this) a common gotcha?
I'm just sorry.
Do you support file syncing? Basically only copying files which having been updated more recently in the source than the destination.
Reinstall it? use easy_install -- something like `python -m easy_install pip`. python makes it so you don't depend on anyone else BUT yourself :P -- ps. get rid of your anti-virus, it only detects virus AFTER the fact, it's useless
how? 
nice, just tried installing somethign with easy_install and easy_install got deleted too, now i have to disable my anti-virus 
you cant install it with easy_install and it says that ialready have it installed, so makes no sense, i just want the PY FILES
`pytest` is quite nice. We switched over a few months back at my work and it has made unit testing so much easier. Some of the features I like are: * Test fixtures! Never repeat yourself again! * Conditionally skip tests. This is great if you have continuous integration that doesn't know how to call out to certain services. Another package I would highly recommend, which mixes well with `pytest`, is [`vcrpy`](https://github.com/kevin1024/vcrpy). It's great for recording http requests and sessions.
try this. $ wget https://bootstrap.pypa.io/get-pip.py $ python get-pip.py -- you'll probably have to just download it using your browser, without wget because youre on windblows.
DUDE I have installed PIP BUT MY pip.py FILES GOT DELETED
and wget is for linux not for windwos
 nvm i solved it, some guy told me to "python -m pip uninstall pip setuptools"
It looks pretty good. However, there's some changes I'd recommend, like calling .tolower() on xString (I don't know the 3.x syntax :$) Also note that you've created two infinite while-loops. Even though it is a first snippet of code, I'd suggest you avoid those at all cost (avoiding while-loops as much as possible is also considered Pythonian). Other than that, the logic looks neat. One thing I'd do personally is using whitespaces to seperate blocks of code and make it easier readable. Hope it was sort off useful, and good luck with your ascend into coding!
This should be obvious. Your docstrings are going to become way too large once you're dealing with functions that handle edge cases etc..
Cloud9 IDE
Two? Obviously there's the True loop but I don't know what the second one is? Possibly see one in the overarching loop (which was intended, as I wanted to be able to make it so you can check one number and then another over and over without having to restart the file). If you've got any advice in how I could change the overarching loop I'd appreciate it. (True loop could be changed quite clearly but this was mainly as a small initial piece of code)
I like [daiquiri](https://github.com/jd/daiquiri), easy to use with basic defaults like logzero but with more advanced options if you need them
For those who are interested in such a lib https://github.com/codelucas/newspaper
Some (most) of your 'not terribly difficult looking' ideas are things some big companies have spent a considerable amount of money and time and brains and data and infrastructure and compute power etc... on. Then again, if no one tries we'll never get anywhere üòÜ But you could also have a look at the challenges available on e.g. kaggle, upside is there is data to work with. Some of these challenges even offer prizes üòâ Whatever you do, have fun
ps. i did not downvote you, its interesting how other people in this sub found it as frustrating as me..
You're using doctest to test a very simple function there. When you want to test a more complex function and you have to use mocks and you want to have a significant number of test cases, you want something like pytest or unittest.
Yes, there is a [copy_if_newer](https://docs.pyfilesystem.org/en/latest/reference/copy.html#fs.copy.copy_dir_if_newer) function that does that.
fuk off luzer
doctest is a tool to check your documentation (where it contains examples as snippets) . unittests should check your logic, including invalid input, edge cases or massive use. non of the above you would like to add to your documentation. 
Woops, I did not see the break statement in the last while-loop :$ Obviously, you could (and 'should' in a real project) remove that loop entirely. There is not so much a problem with the overarching loop, however, to improve readability you could use a function: xString = 0 x = 0 def func1(xString, x): #All the if-else-statements def func2(xString): #From line 15 on while xString.lower() not in ('quit', 'stop'): func1(xString, x) func2(xString) That is just one way of making it a bit more readable IMO. Maybe try: import this in an empty project ;) 
You don't have pay for it at all. You can host everything yourself. Thats what I do. I use both plotly and dash at work. 
Yep... the more I look into it, the more I'm beginning to realize that lol. As of now, I'm going to go with optical character recognition, since there is already a large database easily available and lots of other people have done projects with it. It won't be easy, but I think it's perfect for the group.
Parametrize is awesome indeed! Concise tests while having great coverage. You can combine multiple parametrize decorators btw. Not often needed but sometimes it can just help to prevent the paramatrize set from growing out of control. Was actually one of the things I missed most in the UnitTest framework coming from PHPUnit (which has data providers, same concept as parametrize)
There are good equivalents to `ast`, `dis` or `importlib`? 
You don't have to test for the wrong answers, as you don't give points for wrong answers. You also do not have to increment both points and correct, simply add one to correct for ever correct answer, and then at the end multiply correct by 10 to get points. Think about how you can turn the evaluation of answers into a loop. 
Great, sounds good! Will have a look at it tomorrow! Did you work on the master or dev branch? I‚Äôm relatively new to Python, any major mistakes/style ‚Äúviolations‚Äù you found? Thanks a lot
Thank you! I'm kind of a n00b but i definitely will go back and do that
We all started out as n00bs ‚ò∫
I do have enough experience with loggers, and python's logging framework is not pleasant to work with for those reasons. It's not uncommon to have logs not getting written because of some misbehaving third-party library that messes with your logging settings. 
Oops, forgot to say this... check out /r/learnPython perfect place to ask this type of question
thank you so much!
Same here, I use NumPy most of the time to do computations (calculations). I use pandas to read in CSVs though (it's faster and more robust than NumPy's data reader) and when I have to work with heterogenous data types. If all my data are floats or integers, NumPy is just as great.
Not too bad. def __int__(self): return self.amount def __add__(self, other): return bank_account(self.amount + int(other))
Contrary to popular belief `__init__` is not the constructor, it's the initialiser, `__new__` is the constructor.
Wonderful, gotta love what they were smoking at Sun Microsystems. A good occasion to bash API doc generators as well. Fuck those! It's not "documentation" if a half-assed program can generate it. That abomination you linked, what's it for? It's a "State", what other "states" are there? Which "transitions" are valid? The only thing it manages to document is what `bool isInState(JComponent)` does, well, great, I think 99% is already documented in the method name and signature. But, fair is fair, no words are wasted on what the constructor does.
Further you should find [Python is Not Java](http://dirtsimple.org/2004/12/python-is-not-java.html) and [Java is not Python, either...](http://dirtsimple.org/2004/12/java-is-not-python-either.html) useful reads.
No no, it's running on a web server inside our network. Manager just browses pages on https://internalnet.example.com/
My tools are typically read-only, because if I tried to write to the third-party database chances are I'd screw things up. Lots of export-to-Excel, though.
The bytecode syntax is well documented and rigid, so it's not too difficult to ensure transformations can be done safely. The standard library provides modules like `dis` and `opcode` to allow introspecting the available commands and properties of them, so the code can adapt to different language versions to a certain degree. The only real issue is if a new version of Python was to change something with bytecode, but that's well advertised beforehand.
If you put the condition inside the log function you wouldn't have to always check if DEBUG is true before calling log.
https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
Thanks for the advice!
Yeah, but you can just do (1 + 3).should.equal(4) or something like that. Reminds me of my Ruby days. Wish I could test like that again 
There is a talk from Pydata conference that answers your question completely: https://youtu.be/CowlcrtSyME
No worries! Glad to help! 
You are repeating a lot of logic. You should write a function for "ask a question, get an answer, return # of points scored", something like def get_int(prompt, lo=None, hi=None): while True: try: val = int(input(prompt)) if (lo is None or lo &lt;= val) and (hi is None or val &lt;= hi): return val except ValueError: pass def ask(question, options, correct_answer, right_points=1, wrong_points=0): print(question,) for i, opt in enumerate(options, 1): print("{}) {}".format(i, opt)) ans = get_int("", 1, len(options)) return right_points if ans == correct_answer else wrong_points then your code becomes print("Each question is worth ten points:") total = ( ask("Who was the fifth President?", ["George Washington", "James Malone", "Abraham Lincoln"], 2) + ask("What is 28 x 56?", ["986", "1,392", "1,568"], 3) + ask("How many eggs does a hen lay?", ["1", "4", "12"], 1) # etc ) print("You answered {} questions correctly, for a total score of {} points.".format(total, 10 * total))
Ah. I'm trying to have the option to sort transactions existing and split them (then add child-data), preferably from a web front end. And I've found that copying and pasting rows in Access is the fastest data entry method. Access just also tends to be pretty limited in other aspects of workflow and reporting.
Hyperbolic. Really the only horrible package is httplib. Not even once. Many are simply indispensable. Collections. Itertools. Functools. Sys. Os. Shutils. I must be the only guy here who doesn't hate logging. I've never felt the need to replace those. Better is subjective. There's always a cost to adding a dependency.
Takes a bit of getting used to, but makes you think more clearly about the kind of data you are dealing with. Want to read raw bytes from a file? Open it in binary mode. Want unicode strings? Open it with an encoding. Want to avoid mistreating unicode as binary and vice-versa? Know what format your data is in. I didn't realise how used to Py3 strings I'd got until I had to write some string handling code recently in Py2, and had to jump through hoops to do things I was doing naturally in Py3.
Wow. What a strange trip. 
Follow up, Looks like USB devices aren't accessible through WSL. Back to the drawing board :/
Nah it was out of scope ;-)
`logging` is really powerful and useful once you grok it, but the documentation is absolute garbage. I mean, all the info is in there... spread out rather haphazardly among at least 3 different pages. Some of the examples are also pretty bad, my favorite case being the example for `logging.handlers.SocketHandler` which doesn't even appear in the `logging.handlers` page (but instead [here](https://docs.python.org/3/howto/logging-cookbook.html#sending-and-receiving-logging-events-across-a-network)), and proceeds to do weird stuff without explaining why (such as making an `unPickle` method which just returns the result of `pickle.loads`).
I think most of the people who doesn't hate logging are the ones that don't blame the tools for their own shortcomings. 
&gt; Collections. Itertools. Functools. Sys. Os. Shutils. `contextlib`, `sqlite3`, `json`, `argparse` (another module that gets a lot of undeserved hate), `asyncio`, etc., etc. Really, it's incredible how much one can do with only the standard library in Python. &gt; There's always a cost to adding a dependency. I'm just glad that in the Python world, it's not generally common practice to add tons and tons of dependencies like it is in some other languages. Depending on the kind of software you're working on, limiting external dependencies can sometimes make a *huge* difference.
I really dislike libraries that feel the need to mess with logging. It's not impossible to deal with, just a pain in the ass. Something like Django or aiohttp, sure that makes sense for them to setup logging in a default fashion. But anything short of a framework should register loggers and set a null handler and that's it. 
Doctest is better suited for making sure that the examples in your documentation checks out. You do seriously not want to document all 768 corner cases of complexmodule.RealNittyGritty.veryspecialized_method_that_handles_all_credit_cards() 
Alright, I see where people's complaints are coming from. The logging documentation is rather lack luster, focusing more on the technical rather than the practical. 
&gt; It's not uncommon to have logs not getting written because of some misbehaving third-party library that messes with your logging settings. Please name the perpetrators, so we can avoid dealing with them. 
I'd almost go the other way. I really like python, because with `pip`, I can trivially add a new package to a project. Contrast this with C++, my other main language, where adding an external project means needing to figure out how to compile it, how to link against it, and how to distribute it with the current executable.
Disclaimer: I'm a C coder. I don't have to think about what a pointer is. Neither does the concept of a ~~Promise~~callback scare me. But seriously. The concept is really simple. The logger(s) is a tree, with some random decoration attached to the leaves, branches or trunks. If you're unable to grok that, I question your ability as a programmer in general. 
Celery does it. http://docs.celeryproject.org/en/latest/userguide/configuration.html#worker-hijack-root-logger
I have no experience with Celery. But ... a framework that radically changes the whole execution model is not the generic third-party library.
Don't get me wrong, being able to `pip install` (or more commonly for me, `conda install`) things is a huge benefit. It's definitely more challenging in the C++ world. For what it's worth, check out some of the packages on conda-forge for C++. That simplifies some things a bit! If you're mostly using C++ behind the scenes for Python, then also check out pybind11 and scikit-build if you haven't already.
I use this for various languages. Especially when in testing a new language. With python being my new journey, I found it works great with that. 
Not sure what that disclaimer has anything to do with anything. As for your actual comment, I don't recall if the documentation represents the logging module as a tree, which might be some people's hang up on it. The other side is since Python is extremely beginner friendly, some might not know what a tree is 
also ctypes; if I'm building sources anyway I might use cython but if I want to avoid adding a build step and a dynamic lib is available, ctypes is freakin sweet. I have used it to extremely good effect on several occasions, and I've even been paid for it.
Oh, `pybind11` is an absolute work of art. My default build script with scons will automatically download the latest version of `pybind11` as needed, because I use it so often. I've been meaning to find a decent package manager for C++ at some point. I've been wanting something that integrates decently into a build system, since otherwise everything has a load of configuration. It looks like `conda`/`condra-forge` would fit that pattern. How would it compare for pure C++ projects to `buck` and `buckaroo`, which seem to fill a similar niche?
It does have a bit of a learning curve and the defaults are questionable. But I just put my config in a YAML file or hell in a YAML string literal. There's tons of plugins for syslog, loggly, whatever.
The main benefit to using something like conda is that, while primarily being used in the Python realm, it is fundamentally a language-agnostic package manager. The main downside (for a general audience) is that since conda is primarily used in the larger science and engineering communities, the focus is on packaging things that are of most interest to people doing scientific computing. I haven't really looked too much at C++-specific package managers. In general I feel like there are too many of them and none of them are necessarily good enough to be worth using other than in personal projects (I doubt I could convince colleagues to settle on anything other than conda, anyway).
`ctypes` is definitely convenient. I prefer using C++ if I'm writing something myself, in which case pybind11 is the go-to choice. But if I just have a shared library with some documentation on how to interact with it, `ctypes` is great for that.
Right, and often the answer is caching. Sometimes the answer may actually be getters and setters, but that doesn't justify throwing properties out all together.
I'm working on Riven. Yet another web framework but this time faster than Japronto (not only on bullshit benchmarks as pipelined ones but also on real world use-cases) and with more features than Flask.
Collections, itertools and functools are an intrinsic part of the language. In other languages their functions (e.g. "reduce") are not even considered modules at all, much as len() and sorted() are not imported from a separate library either. os and shutil are **prime** examples of what I was talking about. Path.py has a nicer more "requests" type API over the top of it. sys just kind of a mess - it doesn't really have a primary function, and is more a hodgepodge of things that didn't really go anywhere else. Why stop there though? Are you a fan of csv? argparse? optparse? getopt? curses? select? one of the myriad clusterfucks that deal with processes? (subprocess, Popen, Popen2?), email? smtp? xml parser?
in the course does it teach python 3 or 2.7? I just started to learn python but I've been reading stuff on 3 so I don't want to get conflicted if it teaches 2.7 
ast, dis and importlib are the furthest possible thing from "batteries included" libraries. How exactly would python even **function** without module importing and an ast analyzer? Jesus. I'm talking about XML parsers or SMTP clients or web servers... "batteries included" stuff. 
&gt;json Have you used cjson? &gt;argparse (another module that gets a lot of undeserved hate) Have you used click? &gt;sqlite3 asyncio Yeah, async is great. I'm currently using aioodbc instead because sqlite3 is synchronous.... 
I think 2.7 but the differences between the the two are minimal if you're a beginner. 
There were apparently a lot of initial misunderstandings about Python 3's utf-8 strings. The result was a lot of unnecessary FUD. Python 3 strings are fine (actually awesome), they're just different from Python 2 and for some people *different* is a synonym for *worst thing evaar*.
1. read the formatting help. 2. go to r/learnpython
Can you help me fix it?
Once you've posted your question on r/learnpython and used readable formatting (indent all code by 4 spaces on reddit) you've got a reason to expect help.
&gt; Not sure what that disclaimer has anything to do with anything. The only strange, and that's stretching it, thing about logging, is the indirect nature of handlers. That indirection can look a bit like pointer indirection, if you squint a bit. 
[Codenvy.io](https://codenvy.io/)
For the amount of path manipulation I do I don't feel like I need to add another dependency. Os.path has been getting the job done for me for 10 years. I use csv, argparse, *multiprocessing*, and threading all the time. I've used subprocess, email, smtp, xml etree and minidom with great success on paying work with with a "no external dependencies" clause. I've written select IO loops in C so that's no thing although I'd prefer to use gevent or twisted for async IO. Haven't looked at asyncio yet. *A lot of the clunky is the unix showing through
Not really, but maybe that's my lack of C. Handlers, formatters, filters, etc strike me as classic OOP: a series of interfaces working together to handle a big task as many smaller ones. 
Oh, just the best thing ever. https://github.com/joeyespo/pytest-watch
This is some very interesting stuff, trying to learn a lot from it. Thanks 
Good mod
What school and major? Congrats!
Can't agree with this sentiment more, also take a look at Nose too.
In addition to earlier comments; note that you're hitting disk on each tick. That's going to introduce some unpredictable latency. With a 0.1 Hz tick, you're probably going to notice small variations. Keep that audio sample in ram.
True, but I also do things like: if DEBUG &gt; 2: log('foo') Which gives me variable debug levels for no extra cost. I suppose I could build a debug level into the log function...
Build something of interest or do a Kaggle project.
You get the Key ID from the ui, after you make a service account and upload a public key. See https://developer.box.com/docs/authentication-with-jwt#section-5-constructing-the-claims The objective of using JWT like this is your client and Box don't have a shared secret. You can prove you have the secret private key (you're the only one who can sign with it). The public side being compromised is of little importance. https://github.com/box/box-python-sdk/blob/master/README.rst#other-auth-options implies OAuth2 is easier than dealing with JWT directly.
I think mock can be nice to use sometimes to produce weird intermittent errors on command. Pretty sure it would work seamlessly with Pytest
Browsed over it quickly... I'll keep it in mind! 
Hah, wow. Some other user mentioned, 'some man's "elegance" is another man's "magical bullshit" '. ... I think I understand where they're coming from now
Hah... Didn't know what you meant until I read another users comment about how it re-writes the .pyc file for asserts or something to that effect. Magical bullshit indeed
LOL my first flair ever... Thanks! 
I'll refactor to JSON üòÅ
Holy shit that's insane
You should cross post this on /r/options
Oh I do love iPyhon. For tab completion if nothing else.
Thanks for the heads up! Going to adjust this now.
Unfortunately there is _nothing_ seamless about working with datetimes/dates/times/timedeltas where each of python, numpy, pandas _and_ matplotlib seem to do their own thing! Of these I find numpy the best but it can be a pain to convert sensibly.
Discovering the .str.* methods was a very nice treat! For speed I find it's usually necessary to try and avoid .map(...) even if it's the easiest/most readable method.
OP is here. Welcome any feedback, no matter positive or negative.
Matlab Transpiler that goes both directions.
Well in that case, thanks! 
What kind of programming do you want to do in the future? Try something that would serve as a stepping stone for that. Has anyone ever heard of a programming *video* game? You have a character, move around, and invoke commands to interact with the world (not really sure how it would work out, write your own combo attacks as functions...?)
&gt;Wonderful, gotta love what they were smoking at Sun Microsystems. They were playing "Supercalifragilisticexpialidocious" from the Mary Poppins soundtrack on repeat. For the youngsters: https://www.youtube.com/watch?v=tRFHXMQP-QU
The python job market is 60%+ django web sites. So learn that.
If I wanted a newline, I would put in a gd newline... üòí
"".join()
I wish it was statically typed and compiled. It's such an easy language to get a grasp of that these things would be pretty cool to me
Yeah go with Django. I'm not even pro with Python but I I've been able to make (with the help of my youngest brother) some fun web-apps based using Python3 and Django. :) and that doesn't just go with Python, but any Language. I'm trying to convince my other brother who's currently doing C# in his CS course to get involved with web frameworks such as NancyFX. I just think the cool thing about starting off with Web-Dev after learning the foundations of a language is that it allows you to put visually put your ideas into practice - and if you keen, get it out there on the WWW. 
Yeah, but the C++ way builds character, and it's that really what software development is all about?
In Python 2.x, I don't like that there are two different kinds of classes. I get the reasons why it was done, of course. The standard library needs to be PEP-8ified and made more hierarchical. The last two things really just irk me from an implementation perspective, though the first one does make it difficult to create true transparent proxy objects: Special methods like `__div__` aren't looked up via `__getattribute__`, which breaks the principle of least surprise. `__getattribute__` itself cannot be changed via modification of the metaclass, which likewise violates the principle of least surprise. Bound methods could've been implemented using currying and not the essentially *sui generis* mechanism (descriptors) that ended up being used. 
Have you heard of [else Heart.Break()](http://elseheartbreak.com/)? I'm not sure it's exactly what you described but basically it's a puzzle game where you can 'hack' any object you see to look at it's code, and then edit it to do other things. It's pretty cool with the amount of things you can do, like hacking a door to get you to the other side of town.
AST rewriting isn't really dark magic (just verbose and hard to debug, fu'd AST will just segfault the interpreter), import hooks are the dark magic. Even so, the only time I've seen it fail was when I had an other import hook in the project and they'd mess with one an other. Was mostly the other hooks' fault, due to the test folders having been imported modules. In other words, not really. 
After using Haskell a bit, I like its function argument syntax of `fun arg1 arg2` instead of Python's `fun(arg1, arg2)` (but obviously Python is much easier for most everything, especially for someone without a computer science background). The way I use Python at work as an engineer involves doing a lot of stuff in the REPL as opposed to writing scripts, and I hate having to type the parentheses and commas.
* the lambda syntax (probably impossible to find an elegant form due to the inherent nature of python's indentation syntax) * the lack of an *explicit, universal, platform independent* global IO encoding **default** (preferably UTF8) * the broken ``print`` function in python 3 (lack of an encoding parameter) * no way to make an object explicitly immutable
If you want to try some full stack projects, go for Django or Flask.
What are *UTF8 strings*? I think the misunderstanding goes on üòà
And here I am, reinventing `parametrize` for unittest: https://medium.com/@vadimpushtaev/unit-tests-cases-table-924b3e55300c
i feel you..i had this issue too but fortunately got it working.. follow /u/alanjcastonguay, oauth2 is much easier.
What are some of your ideas and interests? With a Lyle more information I'm sure we could lead you in the right direction?
Not everything is unicode on python! The base idea to have an *internal* representation of unicode (and call the type ``string``) and built most APIS upon this type is imho a good thing. Lots of languages uses a similar way to handle strings that way. But at the beginning of python 3 they exaggerated the use of strings - also in areas where it was inappropriate like FS related stuff. On top there was a lack of methods to manipulate ``bytes``, what is a no go if you deal with data that needs to be handled as bytes. So that was a bad impression people gained at the beginning of python 3... but changing a reputation *tag* is hard üòâ There is also still a lack of functionality. Consider the ``print`` function: If you deal with none ASCII chars inside of your CLI program and use ``print`` to output things, everything might work fine in your development environment. Now you spread your tool and immediately windows users will start to complain about ``UnicodeEncodeError``. Oops... your tool is not working platform independently. The problem is that the ``print`` function offers no way to define an output encoding. So python relys on the default platform encoding. In most windows systems that is not unicode aware. So in order to run platform independent there is one way: Offer an ``encoding`` parameter and preferably define a platform independent global IO encoding. So there is still space left for making the language better üòâ
Unicode in Python 2 and the datetime module. Both make my head explode every single time. 
The *distribution model*. Things like **pip**, **virtualenv**, and **pyenv** have made it easier, but at the end of the day your user has to either have Python installed and at least a minimal ability to run a command line tool to even get your code, or you must either write a full installer (tedious) or use a freezing tool like **PyInstaller**, which is brittle and ludicrously inefficient. The *performance*: ultimately you can improve things a lot by using **pypy**, but it's never even close to C, Rust, etc, or even languages with significant runtimes like Haskell or Go ... The *testing ecosystem*: ultimately this is a side effect of the next item, but **unittest** is the built in but it's arguably one of the least Pythonic modules in the standard lib, **nose** is still common but it's best ideas never really took off, **py.test** is the best of the lot but doesn't ship with the language (I live a lot in ssh talking to machines with no Internet access)... and on top of there being no good *standard* for testing, the simple fact is if you're not fuzz-testing your code with ever conceivable type of argument you never have the slightest clue how buggy your code actually is, because of... *Duck-typing* ... this is arguably one of the best features of the language, but also one of its worst. I'm okay with *dynamic typing* on it's own, especially now that there's a syntax for type-hinting and all that can bring to an IDE, even though *static typing* would make refactoring **much** easier ... but the quacks like a duck thing means that -- while it does give you an excellent foothold into hacking and debugging someone else's library -- it also means that you simply cannot *reason* about your code without looking at the spaghetti of possible types that could be passed in. And I'm not just talking about custom types, the number of things in the standard library that can use **.append** or **.pop** but with different fundamental *behaviors* isn't small... the edge cases become the norm, and I've literally spent years of my life on chasing down bugs that ultimately came down to not having tested for every conceivable variant of an input that some goofball *might* attempt no matter how strongly worded the documentation.
This is one possible way to apply my suggestions, how it might look: https://gist.github.com/yarko/403d5c3c06946638fb637ef837cd8060 Besides the various simplifications for readability (e.g. `quitting`, `even`), separating input handling from calculations I hope shows its benefit. You can see more along these lines in this presentation: http://rhodesmill.org/brandon/talks/#clean-architecture-python
Well, just‚Ä¶ strings. Unless I'm missing something?
which is why Python 3 was born.
How you can't tuple unpack key/value bindings and instead have to explicitly call dict.items()
That's the only reply I can get behind till now. The rest reads like "I want to stick to Python although reasonable argument XX makes it not the best language suited for my task". :)
I love pytest mostly because of @pytest.mark.parametrize
A Matlab ‚Üî matplotlib/gnuplot converter would be really cool.
Somethings modify in place. Some other things don't. I can normally remember function names but my brain likes to assume they returned the modified thing. It's trips me up. 
If you can get away with a joke project, an xkcd phone (app) based on the comics: - https://xkcd.com/1363/ - https://xkcd.com/1465/ - https://xkcd.com/1549/ - https://xkcd.com/1707/ - https://xkcd.com/1809/
[Image](https://imgs.xkcd.com/comics/xkcd_phone_4.png) [Mobile](https://m.xkcd.com/1707/) **Title:** xkcd Phone 4 **Title-text:** The SpaceX system carefully guides falling phones down to the surface, a process which the phones increasingly often survive without exploding\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1707#Explanation) **Stats:** This comic has been referenced 51 times, representing 0.0309% of referenced xkcds. ---- [Image](https://imgs.xkcd.com/comics/xkcd_phone_2.png) [Mobile](https://m.xkcd.com/1465/) **Title:** xkcd Phone 2 **Title-text:** Washable, though only once\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1465#Explanation) **Stats:** This comic has been referenced 23 times, representing 0.0139% of referenced xkcds. ---- [Image](https://imgs.xkcd.com/comics/xkcd_phone.png) [Mobile](https://m.xkcd.com/1363/) **Title:** xkcd Phone **Title-text:** Presented in partnership with Qualcomm, Craigslist, Whirlpool, Hostess, LifeStyles, and the US Chamber of Commerce\. Manufactured on equipment which also processes peanuts\. Price includes 2\-year Knicks contract\. Phone may extinguish nearby birthday candles\. If phone ships with Siri, return immediately; do not speak to her and ignore any instructions she gives\. Do not remove lead casing\. Phone may attract\/trap insects; this is normal\. Volume adjustable \(requires root\)\. If you experience sudden tingling, nausea, or vomiting, perform a factory reset immediately\. Do not submerge in water; phone will drown\. Exterior may be frictionless\. Prolonged use can cause mood swings, short\-term memory loss, and seizures\. Avert eyes while replacing battery\. Under certain circumstances, wireless transmitter may control God\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1363#Explanation) **Stats:** This comic has been referenced 42 times, representing 0.0254% of referenced xkcds. ---- [Image](https://imgs.xkcd.com/comics/xkcd_phone_3.png) [Mobile](https://m.xkcd.com/1549/) **Title:** XKCD Phone 3 **Title-text:** If you're not completely satisfied with the phone after 30 days, we will return you to your home at no cost\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1549#Explanation) **Stats:** This comic has been referenced 18 times, representing 0.0109% of referenced xkcds. ---- [Image](https://imgs.xkcd.com/comics/xkcd_phone_5.png) [Mobile](https://m.xkcd.com/1809/) **Title:** xkcd Phone 5 **Title-text:** The phone will be collected by the toll operators and mailed back to you within 4\-6 weeks\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/1809#Explanation) **Stats:** This comic has been referenced 3 times, representing 0.0018% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dlbk76e)
People who complain about Python and do precisely nothing about it.
scope
One major pro since Python 3.3 is the [PEP 393 -- Flexible String Representation](https://www.python.org/dev/peps/pep-0393/) which can save up to 75% of memory when compared to the 2.x wide build.
This is my number one issue debugging. 'Oh, so you wrote an equal somewhere in your code? Good luck finding all the variables that changed!'
Then why do you need help? Can't a search engine find suitable material to at least get you going?
4 ways to format strings Lacking of datetime encoding in default json encoder
Using white-space as syntax
The concurrency story is not very good in Python. The GIL and the lack of builtin green threads all make taking advantage of modern processors a chore. I really dislike asyncio because it alters the whole structure of your program, and gevent Is the only alternative that I usually use, but monkey patching feels a bit hackish, there's no preemption, and you do have to be careful about the modules you are importing and in which order. All in all I really miss this in Python having worked with Erlang, Haskell and Go. 
How would that work if you had def f1(arg1, *args): ... def f2(arg2, ***): ... f1 arg1 f2 arg2 Is that calling f1(arg1, f2, arg2) or f1(arg1, f2(arg2))? I like the explicitness of the parens. Edit: downvoted for asking. :-/
Making a GUI for an app
Would you feel better writing it as `str.join('', ['a', 'b'])` or is it still evil? 
What's your usual logging approach? I've tackled it a bunch of times from all sorts of angles but I've never really found a way that felt natural. 
Nim would be a good fit for you probably? 
It's the former - you'd do `f1 arg1 (f2 arg2)` for the latter (i.e. they thought of this when they designed the syntax)
What's the alternative? ['1', '2', '3'].join(',')? Then every sequence type would need to implement the join method, as opposed to the current implementation where any iterable (whose elements are strings) can be used with str.join.
I feel like imports always become a mess due to the different usage of programming paradigms. It gets even worse when libraries don't adhere to naming conventions. 
Could be nice :) The actual syntax allow you to specify the separator, so with your proposal it would be something like: str.join(iterable) # default separator is an empty string str.join(iterable, ', ') 
In Haskell there's other ways to denote that that I like a decent amount. As an example, the second one is equivalent to: f1 ar1. f2 $ arg2 Assuming things uncurry like normal. This is interpreted as follows: f1 ar1 is a partially applied function, equivalent to lambda x: f1(arg1, x) . Is function composition, so (f . g) (x) =f(g(x)). The $ is just insanely high operator precedence - everything to the right of it is evaluated first So, we take a function f2 (or lambda x: f2(x)), and use the composition operator to send its output to f1 arg1, a partially applied function. This "pipeline" is then a 1 parameter function, which is applied to arg2. The first one I think is just equivalent to f1 arg1 f2 arg2. The only tough part is that essentially everything is curried by default in Haskell, so its really (((f1 arg1) arg1) f2) arg2 for a 3 parameter function.
GIL.
&gt; the lambda syntax (probably impossible to find an elegant form due to the inherent nature of python's indentation syntax) What's wrong with this: def foo(): myfunc = lambda bar, baz: \ [item for item in bar if baz] ? &gt; no way to make an object explicitly immutable. What's wrong with `namedtuple`s? 
The fact that its not statically typed makes it so easy to use. You can't have the best of both worlds. 
Are you referring to print? In 2.7 you could just do print "blah", In 3x that looks like an end kwarg which is kind of annoying but at least explicit.
The split of version 2 and 3.
That's kinda the point of the language. It forces you to have better indentation. 
No variable declaration, no local scope, forced useless temp vars due to attrocious complex expressions forced by forced indentation syntax, GIL, defs and assignments not being expressions. 
This is actually quite good since it allows you to do things like &gt;&gt;&gt; x = ['ask', 'questions'], ['hear', 'lies'] &gt;&gt;&gt; ' and '.join(map(' no '.join, x)) 'ask no questions and hear no lies' Takes a while to dig it but it does make sense. Ditto with `str.format()`.
This is mine as well.
&gt; I wish it was statically typed and compiled. I'd prefer that too, but with the new `typing` module the situation became _much_ better IMHO. 
del
Eh, [JSON](http://json.org/) has no support for datetime.
I'm not a Python expert, but wouldn't it be better to have a supertype for sequences that has all those useful methods (like sort or grep or map or whatever) and have the various sequence types inherit from it?
 class Foo: def __init__(a, b, c, d, e, ...): self.a = a self.b = b self.c = c self.d = d self.e = e ... attrs package makes it better, but it's not included in the standard library.
&gt;with your proposal It actually works though. `"".join(iterable)` is literally `str.join("", iterable)`
Create a tuple containing all the arguments. setValue(*(self._facebook_signin_btn + (value,))) That's pretty hideous though. Why can't you just do this: setValue(self._facebook_signin_btn[0], self._facebook_signin_btn[1], value) Or if you're going to do this more than once: partialSetValue = functools.partial(*self._facebook_signin_btn) ... # later partialSetValue(value) (Ugh, camel case. See PEP8.) 
 d = {} d{'key'} = 'value' File "&lt;stdin&gt;", line 1 d{'key'} = 'value' ^ SyntaxError: invalid syntax Edit: Downvoted for having an opinion in a post asking for opinions? That's pretty great. 
&gt; The distribution model. Things like pip, virtualenv, and pyenv have made it easier, You mean harder. These are great for quickly writing a little script at home. They are absolutely awful for production. I want a distribution I can pick and and put anywhere when a machine goes down or someone wants my software installed. I don't want to have some proprietary installer jamming files everywhere.
Could always do some *args trickery, but I agree it's not ideal.
Yeah, this complaint always strikes me as rather bizarre. Are you *not already* indenting your code? Is your editor *not already* doing it for you anyway? Where's the inconvenience supposed to be?
Have you ever used pipenv? Is it as good as promised?
&gt; setValue(self._facebook_signin_btn[0], self._facebook_signin_btn[1], value) That's seems cleanest to me. I don't know why I didn't came up with this sooner. &gt; (Ugh, camel case. See PEP8.) Good to know, thanks ! 
The number of people in the online comminities, wanting Python to be something else. 
Just use teampus.com share all you want on your lan and no login Easy
Used it many times for back end development and deploying applications on remote servers. It enables you to dump a requirements.txt file and pip install it back on your server. Also helps you separate different project's dependencies. I would definitely recommend using it.
&gt; I want a distribution I can pick and and put anywhere when a machine goes down or someone wants my software installed. I am using docker. Solves all the problems.
THere are many statically typed and compiled languages. Most of them are far less elegant than Python... because they are statically typed and compiled. Nothing comes for free. If you want different language, use it, but it will be different.
Have you seen OOP in nim...? :-(
It's not that bad actually. Have a look at this talk and then see if it changes your opinion :) [Facts and Myths about Python names and values](https://www.youtube.com/watch?v=_AEJHKGk9ns)
It's an implementation problem of Cpython, the language itself doesn't have GIL :)
 d{'key'} = 'value' That is not how you define keys. d['key'] = 'value'
The messy documentation and the shady concurrency
I've written a little script to extract TODOs from my LaTex files. I've added support for python, c, c++ and javascript.
Agreed, as someone with similar although less ambitious aspirations, it was a thorough and enjoyable read. 
Touch√©, but I still don't like it :P
Apart from that I wish PyPy were completely cpython 3.6-compatible for all platforms, and the main implementation, for performance and speed reasons, there is nothing directly bad about Python, **for a dynamically typed language**. Previously, I would have said it needed good string formatting, but with the new f-strings, I don't really feel that's a problem. It would also be nicer if there was a universal, consistant and simple way to package python applications into nice non-python-requiring distributables, but there are (slightly painful) ways to now. That's not to say that there isn't things I like in other languages that I wish Python were to have: Ruby's blocks are nice, for example, but they're not things whose absence makes Python bad. Yes, I wish there were a static language based on Python, something like [Crystal](https://crystal-lang.org) is attempting to become for Ruby, but I wouldn't want Python itself to be static, *that's not what it is*.
How about this? new Date().toJSON() "2017-08-08T09:41:52.324Z" json has no no support for datetime but it has support for string which is obviously. Anyway, every time you have to subclass python encoder and add datetime support by yourself or to use subclassed encoder from 3rd party app, like `DjangoJSONEncoder`. All it does is, surprise, add support for datetime. WTF Python? Just convert to iso string!
That was the one prevented me from starting using Python before. But after I used Python a little bit, I accepted it.
Python's `json` library isn't even a bijective anyway. It encodes both lists and tuples to lists and stringifies all keys.
My high performance modules are cython compilable. If you have a certain amount of discipline, you can get exactly what you're asking for.
Duck typing. Honestly I don't recommend Python for projects at work anymore. Quick scripts or glue code? Ok, sure. Anything more? For all that is good and holy in this world, flee from Python. Python is a very friendly language. It's just unfortunate that friendliness is often the enemy of robustness when it comes to programming languages.
No, *easier*, it actually used to be *worse* -- ahh for the days of "no, I know it says .egg, but it's just a .zip... no, *please* don't unzip it, just use Python.. no, not Ogg Vorbis, *sigh*" -- because those three at least a) aren't proprietary and b) always put things in predictable locations. Combine them with Docker and you get as close to portable as you can with a language that ultimately still needs the interpreter present. What you're asking for is only ever possible with statically compiled binaries, and of course even those you can only move them from machine to machine if they share a common OS and architecture.
I have no idea who downvotes this comment. Are we missing something?
Someone else has pointed out, but threading is poor. numba and vectorize have shaved weeks if not months of wall clock time off my lifetime workload. But aside from those, I never hit full CPU utilization in my data intensive tasks. Not without some *serious* modification of my code. And I understand that multithreaded code is always hard. But I should be able to use thread local objects without hitting the gil.
I have no linkedIn account, what does this link contain?
I wouldn't go quite so far as to not recommend it, it's a hugely popular language with an enormous number of uses well beyond just glue and scripting -- for financial reasons alone there's a lot of good reasons for a business to use it -- *but* it has serious issues around robustness, speed, and scale that need to be compensated for, and the features that make the language so accessible also mean that the compensation is too often a much bigger project than the application itself. 
There is no split, 2 is legacy. 
Yep, next installment will be on Pipenv :D
Yeah the issues with robustness, speed, and scale are exactly the reasons why I recommend other languages. Python is great because it's accessible. In a professional environment where reliability matters and dozens or more engineers are working on the same codebase, it's just not worth it IMO if you're not building an outward facing library. I've seen too many Python projects turn into crumbling castles.
Not being able to tell what an imported module function returns without inspecting the entirety of their code or trial &amp; error. I'm not even using anything obscure but people just don't document their function parameters and returns very well in general. I am willing to concede that maybe I'm just terrible and missing something though.
Big upvote, thank you very much. Intuition in 1/2 an hour. A nice talk as well.
The people who constantly badmouth and insult it. 
Little thing: mutable default arguments persist across function calls. Big thing: distribution. All the documentation is spread over the entire internet; there is no reason to use distutils any more, and yet the setuptools documentation is still "this is what we changed from distutils". It's trivially easy to publish something on npm - there's a command that will ask you questions and set up your package.json for you. Why does Python require you to grovel around historical and partially-complete documentation to do the same thing? Edit: thing: the whole concept of virtual environments kind of sucks. It's awesome that I can keep my environments separate, but there's no built-in support for global stuff (i.e CLI apps) apart from "stick it in the system directories", which doesn't play nice with system package managers. pipsi is probably one of the most useful Python tools I've found - why isn't it in pip?
For me, it makes it easier to follow the code. Which in turns, makes debugging that much easier.
Yes, that's my point. A dictionary literal uses `{}` while actually using a dictionary uses `[]`. Compare this to an array which uses `[]` for both. Endlessly confusing.
Adding another layer of software to fix every problem eventually results in a computer running only layers, no actual software.
Because of duck typing, sequence types don't inherit from any super type. All you have to do to make a sequence type is make a class that "quacks" like a sequence type. That leads to things like map, sort, len, etc. being functions instead of methods.
A less confusing solution might have been to make it a standalone function like len or reversed: join(seq, separator).
I started learning python in 2009, and I'm still using it almost daily now, even switching to python 3 around a year ago. I'm not a professional by any means, but there's some right nonsense I run across often enough. Print as a function? Fine. Print automatically adding newlines and requiring me to use the "end" argument to suppress obnoxious-by-default behavior? Bleh! Why? Sorting things. It's not really an edge case to have to sort something slightly more complicated than a list of primitive data types, so why did they make it *annoying*? In python2, you'd pass a function name as a second argument to .sort() and everything would be fine! Now here's an 18 line abomination to fix something that wasn't fucking broken. [example](http://code.activestate.com/recipes/576653-convert-a-cmp-function-to-a-key-function/) Package distribution. Maybe it'll be easy_install. Maybe it'll be pip. Maybe I'll just download, untar it, and do the ol' "python3 setup.py build &amp;&amp; python3 setup.py install" ritual and pray for the best. Oh, hell, what's a .whl file? Which versions of python does this package support? Wait, I can just get in APT? What's it doing there? Then of course, if I want something to run on Windows, that's another fun matter. Sane operating systems? No problem, they'll probably have python installed. Windows? Good luck! You'll either have to tell them to install it themselves or draw an Elder Sign on your floor and begin chanting to the Old Ones, begging them to turn your code into an executable.
The language is awesome but so many supporting features and services feel a bit arcane and craggy sometimes (even though it gets it done) and are intimidating to try and improve. It can't be helped and is a effect of maturity I guess.
You're missing something. UTF-8 is an encoding for Unicode. Data in UTF-8 format are necessarily bytes. In [1]: '√•bc'.encode('utf-8') Out[1]: b'\xc3\xa5bc'
The API documentation is so poorly written, has a problem with clear examples, and is so aesthetically ugly that for me StackOverflow is now Python's API documentation.
Maybe this will help? https://nim-by-example.github.io/oop_macro/
That would force all custom iterable objects to inherit from that type as well. Here's a custom class that can be used with `str.join` without any additional code: class Stupid: def __iter__(self): yield "a" yield "b" Now I can do `' and '.join(Stupid())` without needing to inherit from some base class. 
Help? It's not a problem with the how... It's a problem with the way...
&gt; forced useless temp vars due to attrocious complex expressions forced by forced indentation syntax Do you have an example of this?
When I was learning algorithms and data structures at university, implementing and managing a list in C was one of the first things that I learned. 
You mean Tkinter isn't adequate? (I hate it, to be clear.)
Python's more about protocols than object hierarchies. So instead of implementing a bunch of different methods on sequences, every sequence already implements `__iter__` and then anything you need can just be a function that operates on sequences. `str.join` is just a method on strings, and it's in *one place*. It's a design choice for sure, but I think it's simpler this way.
Whattya mean? Python reduces scope automatically to the minimal scope in which the variable is assigned? Maybe I just don't understand what you mean. Could you clarify?
[removed]
It's like salt water to a thirsty man
By your logic, one would have to use () to access an item from a tuple. Now **that** would be confusing. 
I think the point was they find it annoying that you have to use square braces to access a dictionary even though you define a new dictionary with curly braces.
What are the other languages you recommend instead and what particular benefits do you see them having in specific use-cases?
I'm not advocating a change. I'm saying it one of my least favorite things, because it's confusing.
Some layers are necessary and isolation is a good thing in many cases. Docker (or something similar) solves a lot of problems for a relatively low cost (far lower than what we had before it).
Type annotations help. I wrote a py3.6 app recently and found myself doing it to help myself write faster. I assume this translates to library consumers.
Is there a programming language where this isn't painful? 
I think you are labouring under a misconception. {} defines a dictionary object. Like the covers of a book called **d**. d[something] references or assigns an element *inside* object **d**. Like a page or a line on a page. It is a matter of ambiguity and scope. It is two different kinds of actions, and two different syntaxes. There is different stuff happening behind the scenes. In C, defining an array can be done one of several ways, and [] is called syntatic sugar. Its just a strip of reserved cells in memory, and you are expected to play nice, and stay inside the bounds. In python, the structure is different, and not necessarily contiguous. You don't need to think about it's shape. For example, you can make a really cool sort of array with a dictionary called a sparse array. sparse = {} sparse['1,1'] = 14 sparse['154,176'] = 25000 for key,value in sparse.items(): do_stuff(key, value) and you don't have to mess with all the undefined areas, or even step through them. The dictionary is not a literal either, its a variable. A literal is a value itself, like the number 42. With x = 42, x is a variable, 42 is a literal. 
Hold the water, I'll just have the salt. 
I found it a lot more comfortable to play around w/ that in Objective-C on NeXTstep using InterfaceBuilder.app, and the one successful graphical project I had was using Runtime Revolution, a HyperCard clone. Really wish PythonCard or some similar graphical tool for laying out projects and integrating their code was more prevalent.
Yes, I'm 100% aware of what the two lines are doing. The "literal" I'm talking about is the `{}` part, not the `d` part. I'm just saying that it's confusing to use one kind of braces HERE and another kind of braces THERE for this one particular object type but not another. You are so used to it that you can't conceive of anyone being confused, but trust me, some new users are very confused by this. For a long time I had to google "python list vs dictionary" to try to remember when to use what. The use of `{'k': v}` for a dict literal really gives a n00b the impression that they can use `d{'k'}` to get `v` back out. 
This is one reason why Go is so damn appealing, build an actual binary with no external dependencies and call it a day. 
Why are you here?
This one can help OOP be a bit more usable, as a separate module you can import: https://github.com/jyapayne/nim-extensions And there's also an active thread on this subject (as well as vs Crystal) over in the Nim forums over here: https://forum.nim-lang.org/t/1246/4 
It doesn't work in many cases. You will often need some data, some helper applications, not to mention build environment if you want to compile it yourself. I am using services written in Go and docker is still needed to deploy them.
Run your own pypi mirror?
Documentation and packaging edit: forgot all those stupid packages names that make searching on google a PITA
&gt; It's an implementation problem of Cpython, the language itself doesn't have GIL The language itself is defined by the CPython implementation. You can't separate the two.
&gt; The fact that its not statically typed makes it so easy to use. You can't have the best of both worlds. You can, with decent type inference.
My bad, I didn't remember it could be used this way. Anyway, with this syntax you are forced to provide a separator. If you see the separator as an option, it seems clearer to use it as a second optional parameter. A class method would be perfect for this. 
Check out cython, really.. check it out.
&gt; It's not that bad actually. https://en.wikipedia.org/wiki/Learned_helplessness
I've made a lot of desktop UIs with Python and .NET. My problem is when I want to integrate my own custom widgets and when I need to dynamically layout the UI based on runtime values. Static layouts are fine for a D&amp;D tool, but they fall short for dynamic layouts. Since a lot of my UIs are dynamic these days (I maintain an internal platform that comes bundled with a configurable UI), it's just easier to write the code in the first place. 
I find that there are times when I don‚Äôt want to use whitespace properly, but I *always* want *you* to do it so I can read your flipping code. And there‚Äôs the rub - Python makes us give up the ‚Äúgood for thee but not for me‚Äù mentality so that we all benefit from readable code. And what looks like its greatest weakness becomes its greatest strength.
Maybe Python 4 will just be a refactoring of all the standard libs with modules that do it better. 
\*\* as exponent. &amp; Vector math. I came from Matlab / Engineering and \^ &amp; .\^ work great and are easy to use. \*\* is just annoying for anyone that has written down \^ for all of college.
&gt; desktop UIs with Python and .NET So Ironpython?
&gt; but there's no built-in support for global stuff (i.e CLI apps) apart from "stick it in the system directories" If you want things to be available system-wide, you have to install it in a system wide location. If it's just for you as a user, I think you're looking for "pip install -u ...." 
can't you just download all your dependencies and put them in the same folder as your script or if you want something cleaner another folder and add it to your python path? that's what virtual env and pip do at the end of the day
I think most people gonna hate me but I hate idendation. It creates a clean looking code but a small mistake in indendation can cause a lot of problem and its too rigid. I some times use tab for idendation and most of the time it breaks the code. I really dont know why?. I would love the curly bracket instead of idendation.
Most editors/IDE's these days have either auto-formatting based on your [EditorConfig](http://editorconfig.org/). Also some languages have formatting embedded in their native toolchains, like golang with `go fmt`: https://blog.golang.org/go-fmt-your-code. Python whitespace is also not consistent because if I use tabs and render it as 4 spaces in my IDE you might render it as two spaces. So now if we copy/paste code between each other that subtle (**invisible whitespace**) difference might actually have a functional side-effect. Once you "messed up" the white-space due to copy/paste you are really gonna have a hard time recovering since there is no other character (like a `{` or `BEGIN`) indicating control-flow. You might find quite a few problems by just googling ["python whitespace copy paste problem"](https://www.google.co.za/search?q=python+whitespace+copy+paste+problem). I really do not find python more readable. As a matter of fact it seems less readable as one's eye can easier follow control-flow in code with actual characters/keywords and not white space. I guess the conclusion is that if you are gonna work on a small project and never copy/paste code between co-workers or from online sources then the white-space issue might be less prevalent, otherwise it can cause you real headaches.
I found that I had a big difference in learning programming when I was when college versus later in graduate school. In college I found myself where you were. In grad school (physics), I had projects that I needed to do. I knew I could do them in Matlab, but I wanted to expand my skills to I decided to try them in Python. I guess this is a long winded way of saying "Have a concrete project that you know is generally within your skills, and start trying it in a new language." What are some of your ideas?
I deal with a lot of other peoples' code, and there are two things I dread. * 50 lines of code that should be 5 lines of code. * 1 line of code that should 10 lines of code. I've done it before too, so I can't hate. When I first learned about list comprehensions, I went through some old stuff and thought "Hey, this could just be a triple-nested list comprehension with conditionals, a few zips, and a lambda". Python is very unrestrictive. It can be pretty funny (try blocks catching *KeyboardInterupt*s somewhere in the code, so there's a probability it'll print cuss words in the terminal and ignore you), but someone, somewhere is going to abuse a neat trick in a dumb way and destroy my sanity. 
Do you have a language as an example? Because i don't think it is as easy as you think it is. 
Maybe sooner than we thought: https://www.reddit.com/r/crypto/comments/6s6woz/tfhe_fast_fully_homomorphic_encryption_over_the/ I Did not test the library yet though.
So the version 3 didn't get enough reaction
from __future__ import division
You've really missed out on what Python does, then, if you really want a compiled and statically typed language.
mostly syntactical things listed below (though I'm sure I could think of a couple more if I thought about it longer) ``` with (thing as a, thing2 as b): ``` is a syntax error (because `x as y` not an expression) ``` variable, ``` creates tuples. I suppose I might miss this if they took it away, but right now I feel like it just creates more problems for me when moving pieces of code around and ending up with a tuple where I don't expect it. My initial thought would be commas outside parens is a syntax error. I kind of wish annotated function args with default values were ordered like `fn(a=3: int)` since the typical styles are to have no space around the equals, and 1 space after a colon, and I think `fn(a: int=3)` looks kind of stupid. I haven't fully thought this one through yet though.
Yah if people made use of it sure. I was dealing with this recently where the return was a tuple and it was difficult to figure out what the values were and in what order. I think from the OS module.
I really don't understand why this isn't the top comment. Python's concurrency is poor _at best_ and completely inadequate for modern software. That said, it's unfortunately an implementation detail that doesn't show up universally in all python interpreters.
Yes, that's what I'm doing for now. But it isn't really a great solution either. I have a number of medium projects that share dependencies, some of them code that I wrote. I'd like to save space and have them individually upgrade in a controllable way some how. I think I'm going to have to have a globally shared "mylibs" dir that's versioned somehow so everyone gets the right stuff.
Delphi
2 is still _today's code_ for a majority of python developers.
The acrobatics you have to do to install packages from behind a corporate NTLM/ISA proxy.
That's why we use Python 3
Use soft tabs
Because people keep pushing 2, even to the new python devs, while it's better to start learning with version 3...
 I just hate magic methods syntax (eg. \_\_init__()). It's just ugly and hurts beauty of python code.
Yeah, it's hard to justify building anything real with Python anymore where concurrency is such a chore. I've not used Erlang or Haskell, but Go makes this such a breeze and it feels so natural after just a little bit of experience. Hard to go back :/
&gt; "It's so easy!" It's easy to *get started.* Take, for example a = [lambda x:x[0], lambda x:x[1], lambda x:x[2]] b = [lambda x:x[i] for i in range(3)] test = list(range(5)) a[0](test) # returns 0 b[0](test) # returns 2 These differ because of how the lambdas interpret the "context" of `i` (that is, the list comprehension uses `i` as a reference so it changes "under the hood" as the comprehension advances) but there's absolutely no way of figuring that out unless you just know the Python spec in advance. To construct `b` "like you'd expect," you have to use b2 = [(lambda y:(lambda x:x[y]))(i) for i in range(3)] which is emphatically *not* simple or elegant. Edit: Oh, and I *fucking hate* matplotlib. I feel like I'm fighting the whole library every time I try to use it. Edit edit: Fixed from ddollarsign's comment.
I regret having only one like for you.
Swift gets pretty damn close. 
I really am curious about bots (such as on Reddit or Twitter) and analyzing data for results. We used a lot of Numpy and that's a go to for outputting information into a graph or table. The bots aren't too far over my head but I immediately come up with an idea and have no idea where to start. 
Separately, not at the same time. Sorry, should have clarified. My Python based UIs have been with CPython and Tkinter, wxPython, or PyQt5.
Only if you come from Perl or Ruby.
We have tons, and I bet industry has thousands, of Matlab scripts to do random things just because that's the tool Engineers had at hand. Just something that got you 90% of the way there and needed some hand coding to finish would make Python very valuable for a lot of organizations. BSD license it and put it on your resume. 
Holy crap this is the bane of my existence 
Just a couple: Discord bot for Welcoming people to my Discord channel(I've actually gotten very close with this one) , a program to read through the front page of Reddit and give me an average amount of comments for each blown up post(clueless on where to start). Another is some sort of bot/program to text me the weather for the day in the area where I live. I didn't think of this one but saw it somewhere and it piqued my interest but once again something that is of interest to me just not knowing where to start or what tools need to be used through Python to start. 
I prefer this: from typing import NamedTuple class Foo(NamedTuple): bar: str baz: int baz = Foo('hello', 42) For the rare cases in which I need a mutable object I use a `dict` and for the even rarer cases in which I need to build a custom data structure using `class` I can live with the `def __init__():` boilerplate. 
I don't remember specifics since it's been so long since I messed with Python. All I remember is Python would automatically append a newline to everything and the official solution was really kludgy. 
Came to say this. 
I thought Dabodev would be it for a while. It seems like it hasn't been updated in a long time though.
You can already do that (though with reversed argument order): str.join(',', ['foo', 'bar', 'baz'])
Thanks for sharing your experiences. I can definitely relate to the first point. We ended up relying heavily on testing and invested a lot of time into it on our end, but I definitely felt myself missing static typing (we never tried using python type annotations to be fair)
Either some things I try to do have slim documentation or I'm too much of a newb to understand it. So less python and more my inexperience. But sometimes these docs are crazy hard to find.
&gt; 2 is legacy They must have forgotten to tell the VERY useful libs' devs that.
I still believe Javadocs are the GOLD standard.
When I first learned about list comprehension, I assumed it was multithreaded. Why else would you write a single line for loop in that way? I really wish you could add some argument to list comprehension to just do what `pool.map` does. Everyone already knows the syntax for it. Using the multiprocessing library when you're passing multiple arguments is a hassle.
Monkey-patching *feels* hackish, but in practice it's not that bad. Patch as early as possible. Stick to pure Python network libraries (unless a library offers some way to plug an event loop in, e.g. psycopg2). Use subprocesses to distribute and handle CPU work (see [gipc](https://gehrcke.de/gipc/)). I think this is actually a pretty decent solution given the restrictions inherent in the language.
TIL about attrs, thank you so much!
https://wiki.python.org/moin/Python2orPython3#Should_I_use_Python_2_or_Python_3_for_my_development_activity.3F &gt; Short version: Python 2.x is legacy, Python 3.x is the present and future of the language 
hmm I'm just trying to get people to program at work instead of using Excel, I'd fall over myself to get more people to use Python just to get off the ground.
&gt; the number of things in the standard library that can use .append or .pop but with different fundamental behaviors isn't small. Operator overloading is a blessing and a curse too. Gives you more semantic dsl, but also can be tricky, especially when combined with dynamic typing. Spent a bunch of time yesterday trying to figure out why the hell my simple "+" operator wasn't working as expected, only to find that the var I thought was a tuple was actually an numpy array where "+" works differently despite them both being "list like" types.
It'd be a lot easier to just use docker
Do you have good test coverage? That's supposed to help with refactoring 
I simply agree that 3.x is the future. I just come across a good amount of libs that haven't moved the the "future" (oh sorry, is it suppose to be 'future', I always forget that silly little quirk).
Moreover, what would `['a','b','c'].join(',')` even do? I would expect `[1,2,3].join(0)` to return a *list*: `[1, 0, 2, 0, 3]`. For consistency, `['a','b','c'].join(',')` would also return a list: `['a', ',', 'b', ',', 'c']`. Now how do I get from that list of strings to a string? `str.join` seems strange at first, but it actually makes a lot of sense and I don't see an alternative.
s/concurrency/parallelism, but indeed. The concurrency provided by python is quite good nowadays.
We can't use python for mobile applications and it lacks multi processor support
In some cases yes, but it's still much better than having to manage runtime dependencies in Python, Ruby, node, etc. Also, I'd argue that if you're packaging data with your application, you might have design issues. Or if by data, you mean config files then sure I'll agree with that. 
I don't think GIL is a big deal. The domains where Python is popular get along just fine, and the domains that do need concurrent threads already use other tools. You chose the wrong tool for the job if GIL is holding your project back.
The general preference is not to use lambda; it's rarely necessary. def foo2(bar, baz): """Yields each item in bar if baz.""" if baz: for item in bar: yield item By making the lambda a function, you can: 1. write tests for the new function 2. document the new function 3. provide better static analysis on the new function 4. reuse the new function in other locations 5. Arguably the syntax of the lambda gets in the way and obfuscates the meaning of the function. 
&gt; What's the alternative? Well given that `'str1' + 'str2'` works, it should be the case that `sum (['str1','str2'])` works. But it doesn't. 
Oh, true, I forgot about pip user installs. Hopefully that becomes the default soon.
I almost always want a newline, and when I don't I either look it up or remember it. `print(blah, end='')` A language is all about compromises, and in this case since it makes the default case easy and the edge case possible it's a good choice imo
I'm not sure how to define functions with variable arguments in Haskell. I never use those kind of functions anyways. I know it looks confusing at first glance and I get that the explicitness of the python way is nice, but the way Haskell does this is very nice after getting to know it a bit.
Yes, but there's other reasons for the 2 either
&gt; for mobile applications https://en.wikipedia.org/wiki/Python_for_S60 &gt; multi processor import multiprocessing
**Python for S60** The Python for S60 also called PyS60 (Unix name), was Nokia‚Äôs port of the general Python programming language to its S60 software platform, originally based on Python 2.2.2 from 2002. The latest final version, PyS60-2.0.0, released on 11 February 2010 updated the python core to version 2.5.4. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I am not a mac user but you can check http://www.keyboardmaestro.com/main/ out. I have found it while searching for autohotkey alternative for macOS. You can bind your script to a key combination with this program.
Your best bet is probably to use something akin to autohotkey. I haven't tried any of these suggestions but they're worth looming into https://apple.stackexchange.com/questions/153930/autohotkey-equivalent-for-os-x
Not a Pythonic way but look into BetterTouchTool
I've been using [pew](https://github.com/berdario/pew) for some time now. It seems that pipenv is based on it. If you just want a simple venv management tool and don't need everything pipenv offers, then pew is an excellent option.
&gt; Do you have a language as an example? Because i don't think it is as easy as you think it is. Go: i := 42 Nim: var i = 42 D and C++: auto i = 42; Rust: let i = 42; C#: var i = 42; More languages supporting it are mentioned in the second paragraph here: https://en.wikipedia.org/wiki/Type_inference 
Why can't I make multi line comprehensions?
Tests can only demonstrate the presence of bugs, not absence. Static typing can prove absence of certain types of bugs.
You can call any instance method as a class method explicitly passing the instance as the first argument
I can't believe that `sum()` doesn't work. `'a' + 'b'` does, so `sum` should too.
Not a rhetorical question: What's wrong with multiprocessing?
&gt; Because people keep pushing 2, even to the new python devs, while it's better to start learning with version 3... Part of the reason 2 is still here today is because we have comments like this. It has very little to do with a lack of desire in upgrading and far more to do with a lack of actually addressing the pain points in upgrading.
Why are tuples even a thing? They're like arrays, but with less functionality, and they make brackets ambiguous. I'm always hesitant to use brackets to clarify a long expression, lest I accidentally create a tuple of length 1.
To make a deep copy of an object you need to use import copy b = copy.deepcopy(a) You should be able to just to b = copy (a) for any object.
How do people feel about a syntax like this? I've considered writing a PEP for this, but never got around to just asking first... def init(self.a, self.b, self.c, ...): pass 
I'd like something that better solves the circular import problem.
True, though I still think it was inconsistent to put it in str given that all the other iterable methods (all, any, enumerate, min, max, etc) are standalone functions. At least they didn't make enumerate a function on ints: `start.enumerate(iterable)` ;-)
&gt; if you're packaging data with your application, you might have design issues. The data are things like English dictionary, language models or other static files. If you want to distribute them separately, you will often find that internet is not always reliable.
Sure, though personally I think Rust has done it all better. Good cross-compiling, no dependencies *and* no runtime. Neither though is yet as generally useful or mature in as many domains as Python.
I always mix up the two...
I have taken into account your comments. Now you can ask for a specific level of variance. In case of more than two components for the PCA, there will not be any contour plot figure. I do not know how to do it, I do not even know if it is feasible? Averaging along all other axis? Anyway, thank you again for looking at my code :)
It's not really viable to launch 10k processes to handle 10k concurrent requests to your application, for example. Or threads.
I've done a lot of Threading and Multiprocessing with Python, as well as event loops including the new asyncio, and they each have drawbacks that don't exist in other modern languages. My biggest pinch point is that it's not possible to have concurrent processing without the need to serialize data between them. (As anything with traditional threading without a GIL would allow). So now you either have to have slower processing (Threading / eventloop) or slower data transforms that are limited in capacity. 
When you go to pip install a package that includes some C code, and requires compiling. But you haven't installed the proper C tools/libraries, so the pip install fails with a C compiler error that is not helpful in any way whatsoever! Example: $ pip install mysql-python ... raise EnvironmentError("%s not found" % (mysql_config.path,)) EnvironmentError: mysql_config not found ---------------------------------------- Command python setup.py egg_info failed with error code 1 Storing complete log in /home/zjm1126/.pip/pip.log The solution is to install libmysqlclient-dev, e.g: sudo apt-get install libmysqlclient-dev By the way, good luck if you are in an environment where you don't have root. You'll have permission to pip install into your venv, but not to apt install the library! So these packages are off-limits to you unless you get the administrator to install the libraries for you. What pip should do is check to see if you have the library first, before attempting to compile. Then it should see what kind of OS you have, and give you a helpful suggestion. e.g: Sorry, you can't pip install mysql-python because we couldn't find libmysqlclient-dev. You are on Debian, so we suggest: sudo apt-get install libmysqlclient-dev
Partly, yes, but new devs shouldn't be pointed to Py2 either, or am I wrong? 
As someone from CS, ^ is xor and anything else would confuse me. 
Good point. Properties can be confusing. In this case, if it is meant to be immutable, I would use a tuple. If it is meant to be mutable, I would use something like this: def __init__(self): self._a_property = [1,2,3,4] @property def a_property(self): return self._a_property
One problem with multiprocessing is that in order to do inter-process communication you have to serialize messages and pass them along a queue and then deserialize them at the other end. That opens up a whole can of worms.
&gt;Neither though is yet as generally useful or mature in as many domains as Python. Agreed, library maturity takes time and adoption. Also, Python works quite well for lots of cases Rust and Go don't handle very well e.g. small one-off scripts.
Time zones in the stdlib. Maybe someone can set me straight, though. My perception has been that they kinda-sorta exist in the stdlib, but using any one other than GMT will be bad / wrong. I'll need to use pytz (a third-party lib) to do it right. It just feels like it's clearly at-odds with the "batteries included" nature.
Due to the refcounting there's no way to share memory, even for structures never written to. For example, import some modules, then fork and each process serves web requests. The reference count of each function will change when it's executed, causing the OS to copy that area of memory. Similarly for Django or jinja2 templates etc 
Yes, I agree that the treatment of times and dates are very different, and I am a very heavy user of time features. BUT it did not take me very long to figure out the difference between them and to figure out which I want to use. I LIKE the differences because they offer so many options. My programs will often import two of them, side by side. When I described the experience as seamless I meant that the top of your program can import pandas, numpy, seaborn, etc. and it is very easy to blend them interchangeably so that they complement each other. Another good example is visualization. In a Jupyter Notebook program I have imported MatPlotLib, Seaborn, and Bokeh and use all three. Seaborn is made to be blended with the conservative mpl and brightens it up and Bokeh allows the user to create dynamic visualizations. This is one of the reasons that Python is beginning to dominate programming, especially at the educational level. You don't have to choose application or library, you can use them all together. And its easy to learn and now that we have Jupyter, easy to teach.
For what it's worth, you can do `sum('', ['str1', 'str2'])`
I'll have to do more research into cython
I'll have to look into typing
Take my upvote and relish it. 
For those of us not versed in Go (or the others) could you elaborate on Go's the approach? I.e.: what makes concurrency a "breeze" in Go?
Note that by 3.6.2 it also learned to have default arguments and you can use custom `__str__` etc methods.
I am a complete noob, but I have a board game that I've been working on with paper/pencil that has gotten too complex to calculate by hand. I decided to try to get the computer to keep track of all the numbers for me, but data structures have been kicking my ass. I know how I want the pieces to act, but I'm having trouble translating that from words to code. I know I'm not as hardcore as most people here, but I am happy to be working on something and wanted to share my humbling experience of being a complete beginner.
Thought I could give my 2c on a couple of your ideas. (I'm in a similar place education wise but use Python for data analysis/computation) Reddit: As I see it you have 2 options here: 1. you can scrape the HTML of the front page using something like requests and BeautifulSoup then simply find the number of comments and sum them up. This would be quite simple but sometimes manipulating the HTML can be a pain 2. Use the reddit API (https://www.reddit.com/dev/api/) to connect to the front page and access the comments through that. I read a post relatively recently where someone had made something similar and it looked pretty easy too! Weather texts: - My suggestion here would be to go and look for an API for a weather service (https://openweathermap.org/api from a quick google). Once you can successfully get the data you want from it you could set up a little Flask (a lightweight web framework) application which could be set to get the data every few hours. Texting it to yourself I'm not so sure about but I think you would be able to find an online text service which you could interact with. (I am terrible at comment formatting)
I read a book called python for data analysis and it literally changed everything. I didn't know python at all before that, but then I installed pandas and played around with it. Now I'm basically a 'data engineer' who works on automating ETL processes, maintaining a data warehouse, setting up visualizations etc. It's the coolest thing ever. I went from someone in operations and quality to being a data guy through and through. Work is so much fun.

Hm so do people prefer actual books versus ebooks on an iPad Pro?
As a rule, scraping is not theft nor illegal, but it could be in violation of terms of service. Also, as a rule, rate limiting your requests is common decency.
* Lack of decent recursion and pattern matching. Sometimes I just wanna traverse a nested list, though I guess pattern matching doesn't make as much sense in Python... * A million ways to print formatted strings. * Poor planning by developers *and* users leading to the botched Py3K transition. * Reliance on the CPython API and implementation details. This makes it tough to experiment with different Python implementations that might fix some of CPython's shortcomings, because your library compatibility is automatically bad. Look at all the effort required to get NumPy on PyPy running.
I don't really know Go, but I have worked with Ada: having language primitives to synchronize and wait tasks is like a fresh breeze in a hot summer day
Should be, depending on how fastidious you are with your permissions management. Sometimes I ain't got time for all that and have to sudo my way through...
PyQt has been pretty‚Äã okay for me, provided you're not making anything too fancy
It would be more for beginners teaching them the basic without throwing an IDE in front of them and say start writing. With a GUI that is appealing more people would be interested in learning to code I'm sure. Have you heard of Screeps? It's an always running JavaScript game where you build a base and have to fight surrounding opponents. It's always running so you have to program defense, attack, gathering resources, and a lot more. 
Ha, what the hell? That's so strange. If addition works, why isn't `sum` just a bunch of additions?
Packaging applications. Yes, I suppose I could run them all in a virtualenv, but if I want to avoid dropping into the venv and manually activating it before usage, or even to use it system-wide, I better hope that all my dependencies will play nice with each other.
In a nutshell: goroutines and channels. It's extremely easy to create a new goroutine (green thread) and communicate with it via channels. The Haskell concurrency story is very similar, only that you have strong types on top. Contrast this with, say Java, where there is tremendous ceremony involved in using threads, and thread pools. Furthermore, those are traditionally OS threads, for which it can be tricky to decide how many to create, depending on the type of workflow you're engaged in. In Haskell, you can just start a million threads with a simple function and pass a value through them all in a loop, completing one spin in about a second on stock hardware. All scheduling is left to the runtime, which does a fantastic job.
So it is an instance method, not a class method. The syntax does not change the semantic. When I said... &gt; A class method would be perfect for this. ... I really meant, with the semantic meaning of *class method*. :)
Please do write a PEP for it!
Please do write a PEP for it!
Welcome to using Electron apps 
Writing concurrent code in synchronous manner. Beautiful communication mechanism (channels). "Go routines" which are not threads (managed by Go runtime) and therefore are very fast and given much less than 4K of memory at start enabling spawning millions of them on generic hardware. And these videos are recommended: https://www.youtube.com/watch?v=KyuFeiG3Y60 https://www.youtube.com/watch?v=cN_DpYBzKso
What about Stackless Python?
This sounds awesome. Having a project you care about and getting your butt kicked early on will be great teaching tools. Good luck!
Can you give an example of the difference in practice between using str.join and what class method semantics you'd want?
My guess: Because python is used as script language more than coding language mostly, and people looking for multithreading, performance, etc. are better off with java/c# At least I assume the original comment is about multithreading - I don't know most of those python *objects* mentioned, albeit I did quite a lot of stuff in python. 
My least favorite thing about Python is that it‚Äôs not more popular than JavaScript and that it can‚Äôt be used natively in the browser.
Dynamic types and garbage performance. 
If you can access it already why does how you access it matters? 
What you propose works, as of Python 3.5 (IIRC). 
You might want to look into mocking the services. Unit testing anything complex always seems painful. I'm not disagreeing, I'm hoping it gets less painful with time. I tend to lean more on integration tests too because I don't like mocking and haven't figured out how to do it well with `py.test` (not that I've looked hard)
My only complaint about PyQt is that you can't exploit some features from Qt, like its decent threading and concurrency stuff, due to inadequate python support for the same features. So, if you want to do something like create non-blocking UIs, where work is being done in the background, you need to create subprocesses if you want to use multiple cores. Yuck. Sucks when you're creating a game ui or something, only to find that you can't offload simple tasks to other cores. I mean, I guess you can use a second process to handle playing your music, but for sound effects you need to be in the main process if you don't want IPC related lag. 
Generally speaking: If you are using conda, it is because you are using pandas/numpy/scipy and the like. In which case it is VERY LIKELY that you will be working with data sets of a non-trivial size (ie not smaller than 1GB). At that point you really do need 64bit.
Also check out [Kivy](https://kivy.org)
Answering a question. I love python without rose goggles. And if your beef is with my emphasis on forced, that's my point. For an example of optional use of whitespace as syntax, check out Haskell. So we know it has been done. 
LinkedIn is trying to sue people that web scrape their site: https://techcrunch.com/2016/08/15/linkedin-sues-scrapers/ I think they would loose in a court case, but look for more of this as social media platforms become more monopolistic in their behavior.
good point. I realised after I posted this that the module I am currently hung up on would most likely use large data sets and thus require the 64bit python engine. I guess I'm really getting stuck up on how to best compile my own libraries in conda to get a 32bit module into my current setup.
In my experience (which may be uncommon, I don't know) Docker results in fewer layers, not more.
You might want to look at the Hypothesis library to get with fuzz testing. 
I don't give a fuck
If you pm me I can give you some tips in a few hours (in a meeting right now). I manage a number of packages that are built against 32 and 64 bit on Windows and have worked through a number of issues related to the architecture. 
Have you considered using a Python implementation that doesn't _have_ a GIL?
What I especially hate about the indent style is it makes refactoring a lot harder. The IDE can't automatically figure how what level belongs where. 
There's a lot more than just that. configtest.py discovery processing, fixtures magically appearing as params. assert magical traceback magic doesn't work if called in helper/factory function (vs directly in test function) [this is a symptom of magic, rather than magic itself. Still damn confusing until you find the place it is mentioned in docs]
Keeping track of whether I'm passing a reference to an object or making a copy.
Version fragmentation.
Are you sure? They have a [language reference](https://docs.python.org/3/reference/), and several different implementations. 
IFs and FORs don't have a scope. Seems to be a consequence of no variable declaration. Python's locality is subroutine granular. 
All the ones I use have been ported.
IANAL, but there certainly seems to be a gulf between what's ethical, and what can land you in seriously legal jeopardy. What happens to you in the gulf seems to be up to the capriciousness and vindictiveness of the people whose terms of use you might violate. See Aaron Swartz. Personally though, I think /u/TheBB is on point.
The best solution (and this is true in 3.5+, as well as in older versions) is probably to make _facebook_signin_btn a named tuple, and call setValue with dict unpacking: self._facebook_signin_btn = Button(MobileBy.ACCESSIBILITY_ID, 'Facebook') setValue(value=value, **self._facebook_signin_btn._asdict()) In six months you aren't going to remember what information this button stores, or whether 'value' is the first or third parameter to setValue. Named tuples solve the first problem, and named arguments solve the second. 
How would that work with named arguments?
If you use `sys.stdout.write` instead of `print`, you don't get the automatic newline. However I would recommend instead using the `end` keyword argument for print. You may want some kind of curses library if you're doing ascii graphics on the terminal. Otherwise I don't see why you wouldn't build the output as a string and just print that once when it's done.
Which is a split.
Exceptions are also quite badly documented. Sometimes there's some unexpected exception and I'm like "Oh, that library can do that?"
You realise that's exactly what modern computers are, don't you? Layer upon layer upon layer, from the silicon up through the architectures to the OS to the languages and their libraries and all the stuff we as programmers build on top. It is precisely this layering which enables us to have computers do such awesome stuff. Yes, it's incredibly costly in terms of performance, etc., but this huge stack of abstraction basically gives us superpowers such as the fact that I can be typing this, then use my trackpad to hit the "save" button and soon enough you'll see this reply, and be able to reply just as easily - etc. Layers are the shit.
It really is.
Yeah true that's definitely annoying as fuck. I've been using the threading module to supplement that. It works up until a point, but pushing it too far causes the GUI to crash
Currently, the `str.join` method is an instance method, that means it applies on a living string instance, which in the actual use case of the `str.join` method is the separator. Under the hood, it implemented somewhat like: class str: def join(self, iterable): ... That means you are force to provide string separator as a first parameter. str.join('', iterable) # Is semantically equivalent to ''.join(iterable) If `str.join` is implemented as a class method of `str`, it would be somewhat implemented like: class str: @classmethod def join(cls, iterable, separator='') ... This implementation allows you to define an empty string as a default parameter. It leads to a clearer syntax if you do not need to specify a custom separator. str.join(['a', 'b']) # --&gt; 'ab' str.join(['a', 'b'], '+') # --&gt; 'a+b' Besides, the semantics is clearer too: you want to retrieve a new string made from an iterable. On the opposite, when you use a instance method, you would expect (even if a string is immutable) to work on the string instance itself.
Can't you do it with a decorator and attrs/\*args trickery /magic? 
Pycharm gets it right. Maybe you're not using a python ide? If you have code at indent level Y, when you paste it into level Z, it will change Y to Z+0. i.e. you place the cursor where you want the block to be, and paste it, and it just works. I admit you can deliberately break code by dedenting to lose structure, but you have to pretty bad to do that.
Like the top comment says, distribution. If python made a self-contained executable like Go, it would instantly become my favorite language end to end. I also would prefer strict typing. It feels a little bit overwhelming at times to work on a stack that's too large to see all at once, and *not* know the types at a glance. It's not like changing the type of a variable during runtime is a good idea anyway, so strict typing would only enforce good habits that should already be used. At the cost of slightly more verbosity.
Because tons of people use Python for web work and concurrency/GIL concerns there are nearly non existent. You're realistically always waiting for IO either from a connection or the DB so the GIL just doesn't come into it much. Sure, there's exceptions, but for the vast majority of web services, particularly starting out, it just doesn't matter.
What's the purpose of introducing python? What's a new dev? What's the goal of learning python? Where will python be used? What environment is Python running on? Who will be maintaining the code? What does the current team look like? How is the code being deployed and tested? If you can answer all of those and still come out with Python X on top, then it makes sense to use Python X. 
You're probably mixing tabs and spaces in the code. Most Python specific editors will insert multiple spaces when you press the tab key, and most Python code will use spaces. I use Pycharm which will autodetect, and offer to convert. edit: Idiomatic code in curly brace langs also requires indentation.
&gt; Because tons of people use Python for web work and concurrency/GIL concerns there are nearly non existent. You find the use-case edges of concurrency even in web development - especially at scale. Developing a small app with a small user base, you won't hit these problems. But if you have a big app, and you're at the start of a development cycle, you might immediately reject python due to its performance warts. By choosing a different language (e.g golang), you'll get more legroom on a single node (vm, ec2, docker, cpu, etc.), and that ultimately means lower bills.
There is kivy and bee for android/ios. It is pretty bad on mobile but "cant" is a strong word. You can. It's not very nice.
Any example I'll show will have a followup of "well, don't write like that". When you start nesting expressions in a functional style (think Haskell), confirming to pep8 becomes a final boss challenge, and results look needlesly ugly. This seems to be done on purpose to confirm to mandate of simple expressions, thus resulting in temporary variables. This does have one objective advantage of making debugging easier, but it does limit coding style. 
I've used PyQt and TKinter before to make GUIs for macOS apps and I much prefer using Objective-C/Swift to create the app, though that's also because I can use a visual editor to design (drag/drop) visual components as well
You mean Jython? Last time I checked it only supported 2.7, it seemed unmaintained. I would also have problems with C extensions. 
C++ is also nice when you really only need the STL.
A good number of people would say that python is just another of those layers...
I wish it was faster and ubiquitous like PHP. It would be great if it was running most of the websites on the internet. It's not that I dislike PHP. I actually love PHP. Unfortunately, the negative publicity has turned it into a leper even though PHP7 is here. Hence, why I wish I could just do everything in a language that most people seem to love. I don't really love trying to justify the programming languages I use to people who think they know it all. Having said that, I don't know enough about what makes a great back-end programming language to say if we would be any better off. Honestly think people just like to complain about whatever they have to use.
+1 for this. I'd say quite a few large libraries and tutorials are written for Python 2 (usually 2.6 or 2.7), and the differences in the language version are enough to crash/be a hassle to fix 
After more than a year of working on it, I just released a new version of my site designed to help people learn programming using Python (or Javascript) [http://reeborg.ca/reeborg.html] ... **AND** announced an accompanying book: Reeborg's World: a Teacher's Guide (https://aroberge.gitbooks.io/reeborg-s-world-advanced-world-creation/content/) published online. The book is still very much in draft form and not yet complete. I hope to have a first version completed in time for the new school year.
Tuples are immutable which is a significant behavioral difference from lists. To create a length 1 tuple you would need a trailing comma. Is the problem commas or brackets? :-)
&gt; They have a language reference, and several different implementations. That language reference is incomplete to the point that alternative implementations need to look at the CPython code to fill in the gaps (ask the PyPy guys if you don't believe me). The end result is that absolutely all the alternative Python implementations are partially incompatible with CPython. Just because fucking Guido did not see the point in defining the language through a reference instead of an implementation... Compare this with the Scheme ecosystem where the reference comes first and the implementations just need to implement a certain version in order to be compatible between themselves. 
I'm just doing some stuff with python, and i thought that i should publicize my foundings. So it is true that you can not unpack tuple with lambda... but you can unpack arguments as tuple. SO: &gt; a = lambda *x: x # works &gt; sum = lambda *x: x if len(x) == 1 else sum(x) # summs any number that is given to it. works for 2.7 and 3.5 python version In short, you can do a lot of things with lambda. I was surprised. I personally don't care if option is pythonic or not, as long as inner heap logic is valid, speed is not bound by specific rules (and every rule has its Exception :D :P aahaha, joke... Exception ). But after saying that, i personally ( it is my fault ) wrote that function on top of my head with no regards to the speed or need for one liners and etc. I was just curious if you considered using functional programing. Nevertheless, this discussion is (as i see it ) over, i feel that we've all said what was necessary, but of course any other thought exchange is welcome. 
Indentation.
The data interchanging is fine but why a wrapper of JSON Schema? I don't see any advantages over using jsonschema.
I use version 3 exclusively. Boy, it's annoying when I have to choose not to use a good library because it only supports version 2.
What language does not have whitespace as syntax? the only ones I can think of are fixed format Fortan, and brainfuck.
https://bitbucket.org/stackless-dev/stackless/wiki/FAQ : &gt; Not all extensions are implemented in a friendly manner, and because of this may be unstable or unusable when combined with Stackless Python. This is especially the case with Stackless Versions released before commit 949c518c67c75a1. Since Stackless 2.7.7 most compatibility problems are gone. &gt;The greenlet extension module was extracted from Stackless Python, and provides a portion of the functionality that Stackless does. Because of this, using it with Stackless is an odd choice, and will not be supported in any way by the Stackless developers.
I've switched to using the venv package in Python3 since it's included and seems to be the same as virtualenv. Since I have the choice of developing in Python3 only, it's a nice luxury to not have a dependency beyond what is provided by the OS.
Allow me to be the guy against it, hehe. Nothing personal. It goes against something that was a super good design choice in python, which allowed for lots of nice things that could conflict with this new syntax: the idea that methods are just normal functions (they are curried when the instance is created, to avoid the requirement of the self parameter being passed). This new syntax would create a clear division between normal functions and methods, making them "incompatible" in some use cases, for no good reason (as it could be implemented without new syntax, or at least new syntax that doesn't create a division between functions and methods).
&gt; The end result is that absolutely all the alternative Python implementations are partially incompatible with CPython This is true, and is why cpython isn't really a reference implementation. :-) It's also true that Python isn't as rigorously defined as some other languages. The other day I noticed some deviant behavior in Jython that was breaking some of my code.
I discovered this trick, which solves this problem a little more elegantly: b = [lambda x,i=i: x[i] for i in range(3)]
We need a pythonesque static language so badly!!
Being new to Python (coming from Perl), I don't like that it doesn't check the syntax of code until it tries to execute it.
This. ``` for (key, val) in a_dict: ``` ~~is~~ would be simply **the** intuitive behaviour. 
&gt; You find the use-case edges of concurrency even in web development - especially at scale. Developing a small app with a small user base, you won't hit these problems. Virtually zero web development is done at scale. Everyone thinks they need to plan for super huge scale, but that's a pipe dream 95% of the time. This is why Python does so well in the web development space: it's straight forward, easy, comes with tons of batteries and you won't need the performance optimizations, most likely. I've run sites that service millions of users on a half a dozen servers with a Django app. I've also worked at places that service tens of millions of users with Java and it's taken HUNDREDS and hundreds of servers. At some point, organizational, algorithmic, and planning concerns are more important even than language. But in reality, MOST people won't even get a few million consistent users. Sure, if you're going to make a huge, huge site you could do a bit better with a different language performance wise, but if you get to the problem where you have so many users on a web service that performance becomes an issue, then either you're making money and it won't matter that much or you're not and you're screwed either way. Avoiding Python as a web service language because of the GIL, or performance in general, is a premature optimization problem, almost guaranteed.
&gt;&gt; The end result is that absolutely all the alternative Python implementations are partially incompatible with CPython &gt; This is true, and is why cpython isn't really a reference implementation. :-) Non sequitur. The logical conclusion is that Python is defined by whatever CPython does.
Literally every other month IT changes their blacklist, or the name of the https proxy, or the requirement to log in with/without password. I have seen also coworkers pluggin their mobile phones to the pc in order to install something over their data plan. In the end I pip built the wheels for my project dependencies and put it all together in the private repository so I just install without internet.
You should look into the official swift APIs to do system wide hotkeys. 
Haskell has outstanding types inference. Haskell isn't comparable to python at all, in general, but shows how far type inference can go. 
Counterpoint: Many of the ones I use have not been ported. Seems like most of the bioinformatics tools are written in V2. I don't have time to port other people's tools, it's much easier for me to write Python 2 code.
Have you tried? returns are ignored inside [] or () or {}
I want to be able to use a parent object to build a child object. Child(Parent): ..def \_\_init\_\_(self, var1,var2,parent) ....parent =Parent(parent) ....var1 = var1 Terrible formatting, on phone.
Yeah, I'd have to agree with you. I keep trying to like asyncio, but I've spent more time trying to learn that one package that it took me to get started on the entire language many years back. There needs to be a 'dive into async python' or something - a very straightforward user story for getting started with asynchronous work. At the same time, I understand how hard this is, because it affects *everything*. I can't just swap out a synchronous web app for an asynchronous one without my webserver undergoing fundamental changes, replacing WSGI with some other api, sourcing asynchronous DB access libraries and so on. I love Python, and do nearly all my work in it, but it's weird that something I could do in Node five years ago after reading a tutorial for 30 minutes I still struggle to do in Python today.
...you can, it's called a for loop.
&gt; in ssh &gt; talking to machines with no Internet access Teach me... EDIT: I just realized you probably meant that they're on your local network, but can't call out. I'm dumb. 
&gt;The distribution model. Things like pip, virtualenv, and pyenv have made it easier, but at the end of the day your user has to either have Python installed and at least a minimal ability to run a command line tool to even get your code, or you must either write a full installer (tedious) or use a freezing tool like PyInstaller, which is brittle and ludicrously inefficient. This. I'm a noob and this is my greatest frustration. I would prefer to be able to just download a folder and put it where it needs to be than use pip and command line. 
no one tell him about npm install leftpad
I don't think I necessarily hate anything about Python. I always hated the idea that it didn't enforce a type statement, but it's not a big deal. Or that you could mix types in lists/dictionaries: myList = ["you", 3, ["myList", 2] ] I guess the only thing I REALLY hate is when I was learning Python and they always wanted to piss around in REPL at the start. They would devote dozens of pages to this nonsense before finally coming to their senses with, "Wait, nobody is ever going to use this shit. OK guys and gals, grab your text editor of choice..." Of course it's not a fault of the language itself, but it's annoying. Oh, and having to declare self in classes. I would think this is a given (like it is in many other languages), but apparently it's not. As you can see, my complaints are quite minor. I loved to hate Python when I was learning, and while it's not my favorite language, I've grown to appreciate it more and more. At least it's not Java.
Yup. I work in VFX (Iron Man, Transformers, those sort of things) and the studios *really* don't like the Internet. No worries, it sounds weird when I say it too. Also it's not local in the normal sense... I could be touching a machine in Beijing from LA or London, through a VPN that drops every half hour +/- random minutes to try and bypass the Great Firewall... you have no idea how much it sucks to know just how many inches a nanosecond is at light speed.
Use two variables instead of the first tuple 
I'm sorry for my somewhat curt tone in my previous response, I was in a rush and didn't review as closely as I should have. Thanks for digging into the lambdas, I didn't know about that expansion either.
Used it, quite nice... my problem is that it's necessary way more than it would be in a static language.
I wrote this over the weekend after doing quite a bit of research into how blockchain ledgers work. I know there is some grumbling about what a blockchain is and is not, which is why the following statement is made in the project: &gt; This implementation focuses only on the hashed ledger concept. It specifically does not include any concept of mining or any other form of distributed consensus. It also abstracts the concept of a transaction to that of a message in general. The concept of a header and payload in messages and blocks is adapted from Bitcoin. The focus here is on understanding how the ledger itself works. In other words it focuses on the **static semantics of a blockchain** instead of dynamic semantics as a means of distributed consensus. Distributed consensus is out of scope, though I would be interested in exploring a mechanism for distributed consensus of a shared blockchain. But for now it is out of scope. Includes a few unit tests. Any feedback appreciated.
Yep. In the long run learning the command line is a HUGELY important skill, but it shouldn't be the first entry point into the pool.
The class var would have to be the same name as the named argument
Except you don't need the parens 
So far, my answer to every concurrency problem I've ever met in Python has been 'multiprocessing'. I use `ThreadPoolExecutor` occasionally, but generally I use uWSGI workers to manage my processes.
Whatever you mean by iso. 
Would they have to be incompatible? If the function wasn't part of a class, it would simply set a 'self' object in the function scope.
Well that's a different fight than the one I'm accustomed to - best of luck!
``types.SimpleNamespace`` is in many case worth considering: from types import SimpleNamespace class Foo(SimpleNamespace): ... foo = Foo(a=0, b=1,...) though there's always cases that don't fit that also...
I think kotlin has got you covered. Im a big python fan. but I think kotlin is better than python. its awesome
Cython. 
I don't mind want I am about to say, but it is painful not to have an inheritance view level descriptor. Public Private Protected Instead of __var 
Have you seen the Joblib library? Makes list comprehension using multiple cores a one-liner.
None of these languages comes even close to the flexebility of python. What you just showed is a list of languages with a compiler that can search and replace a keyword with the actual type befor compiling, because thats what ' auto' or 'var' is, a placeholder. auto x = 90.0; x = "Hallo" ; wont work in c++, but it works just fine in python. 
eo J. Computational NeuroScientist and Machine Learning expert 2d I took an interview few days back and the candidate chose Python to code on white board. Now, I personally like Python and in an interview at Google, there should not be any problem with it specially given the fact that Python was developed majorly at Google itself. But, I strongly recommend that you must know either C, C++ or Java. We, at Google, definitely use Python a lot internally. In fact, we use Python where we can and C++ where we must. But, I really do not understand that if I want to see your memory management skills, how am I supposed to do that if you code in Python. So, for low level logics, please use C/C++/Java and for high level logics, Python is Ok. And when a candidate tells me that he/she just knows Python, well, it implies automatically that I cannot ask low level memory manegement problems or any such problem which uses the concept of MM. I know, I have plenty of things to ask even if you code just in Python but there are few skills I need in my team and MM is one of them. If I hire for ML roles, Python is MUST but still you need to know one of C/C++/Java because I really do not give a damn to ML Scientists who cannot manage memory well. And really, if learning a vanilla language like Java is not easy for you, you do not qualify even as an intern for my team. 256 Likes 35 Comments
Laern the basics on your own until you can submit push requests to other people's githubs. The world is your oyster.
I know many people like to use django with some frontend javascript framework so I started working on a boilerplate project that uses django as the backend and react and redux as the frontend. I already configured the signup, login and logout functionality. Code is available at https://github.com/mtusman/django-react-redux. Feel free to contribute. The boilerplate is just meant to be simple so the user can get it set up quickly and configure to his/her own liking 
I don't really have a problem with that as a pragmatic decision. Cpython's behaviour is enormously important. However I don't consider it true myself; you would advertise for Python developers with _ interpreter experience, and not for _ programmers. Seems silly argue over though. If you believe cpython is reference, there's enough people that will be OK with it to let it stand.
It's not what you asked for but maybe it's what you want: are you looking for https://docs.python.org/3.6/library/functools.html#functools.partial - pass two of the arguments now and the third later?
Still it's different behavior between functions and methods: in one case pointing to an external existing object, in the other to an object inside the scope of the function and that has to be created (and of which type? etc). That could mess a lot with libs that take advantage of the "methods are functions" fact.
Hi, I've listened to this and it's good. :) I just discovered your podcast a few weeks ago and I just wanted to say that I am a fan of your work. I learned a lot about Python and I realized that there's a ton of things out there that I still don't know. Again, thanks! Awesome! &lt;exits&gt;
I think the way sum is implemented it starts with an implicit 0 to handle the case of an empty iterable, which makes it fail for str.
Are you confusing dynamic typing and type inference?
Guys, guys... GUYS. HOLD THERE A MINUTE. Just want to throw in that writing out abbreviations once might help bystanders a lot. Ty, sorry, please go on. 
Just curious, do you mostly use print without the newline? In my use case I would become extremely annoyed if there wasn't one.
The thing that annoys me most often is when I forget the colon after an if clause or function def line. You know what I meant, interpreter! Sometimes I miss Ruby-style blocks. Generally Python seems to fit my brain better than Ruby though. The fact that being a Pythonista sort of herds you toward back-end and scripting rather than front-end, mobile, games, or whatever. The right tool for the right job, but nothing inherent to the language itself makes it worse for front-end than JavaScript or worse for games than C++, just the fact that the tooling isn't there yet. 2 vs 3 is probably a whole 'nother rant. I was only supposed to pick one thing, wasn't I? It's still the best language.
No, my point is, that type inference doesn't replace the dynamic typing. I Asked for examples of statically typed languages that are as flexible as python is, not for a list of languages with type inference, because that is just a fancy feature that you even could add to C. (Could have phrased it better, but english is not my first language) Type interfence doesn't actually add flexebility at all, sometimes it makes everythnig even more complex because you have to guess the type. 
Isn't that a bit of a code smell? Passing a bunch of discreet values into an initializer, just to store them inside the object, seem a bit of an anti-pattern. Also, you will have the exact same problems in other languages, just hidden away inside an array, structure or some other container type. You could easily pass a tuple in as a singe initializer argument. Make it a namedtuple, and you would have something workable.
It's a grey area but I think there are two separate issues. The first is the actual act of scraping - requesting multiple web pages from the server quicker than a 'regular' user. As u/TheBB mentioned, if done courteously this impact is minimised. The second is the structured collection of data in order to be used for another purpose; this feels like the more contentious part depending on usage. In your example, the website allows you to export the data in a structured format which you could already access on their site by spending the time viewing and copy-pasting. I'd view the payment here as convenience for the average user and avoiding this cost by scraping is just being efficient. However, if you are scraping data that a company has spend time and resource on obtaining, and then using that to be monetised in some way, it's like piggy-backing on their investment for your own profit and that could be seen as less ethical.
&gt; No, my point is, that type inference doesn't replace the dynamic typing. It's not supposed to. &gt; I Asked for examples of statically typed languages that are as flexible as python is No, you didn't. You're just moving the goalpost. &gt; Type interfence doesn't actually add flexebility at all, sometimes it makes everythnig even more complex because you have to guess the type. So you never used it, did you? 
Absolutely. Python's docs are WALL OF TEXT CRITS YOU FOR 50000
I'm doing a Masters Project that is in Python. I was planning on doing it alone, but would love to have a team help me with it. It's an Open Source project. If you're interested, PM me and we can discuss details and see if you're interested. 
That's not really a complaint about instance methods exactly, it's more about wanting default arguments for joining. Which is totally reasonable. 
how about this: class MyClass(obj): def __init__(self, a, b, c, **kwargs): super(MyClass, self).__init__(**kwargs) self.__dict__.update({k: v for k, v in locals().items() if k != 'self'}) 
MatLab already has half the solution http://www.mathworks.com/help/matlab/matlab-engine-for-python.html?requestedDomain=www.mathworks.com One could easily make it go both ways. 
Sometimes code just can't feasibly be unit tested. We have this issue with old PHP code and it's just very poorly written with no organization. Several applications would be much easier to go back to the business, get new requirements, and write from scratch (following best practices) than it would be to even get reasonable unit tests in place, let alone trying to refactor that mess of spaghetti. 
Would condaforge help? Edit: NVM, doesn't have deltasigma.
Eh, there are some issues with that. And there are ways to run A from B and vice versa. But I mean a transpiler to turn .m code into a Python function allowing you to not have to open Matlab (or have a license).
it's hard to build fault tolerant multiprocessing based app in python, each process can die or hang and making sure the parent aware of such incidents can be tricky. comparing to erlang `link` which is built in and without any exceptions. 
It's the MapReduce age, Guido. Support actual functional programming, not this "just use comprehensions" garbage. 
Ah... there actually is a project that does that. I'm trying to remember what it was. We actually did an analysis at work to see if there were alternatives to MATLAB. We found the project and it has potential, but is lacking. We actually came to the conclusion that using Python straight up would be best.... assuming you could convince the MATLAB engineers it was worth it. Edit: I found an SO question about it https://stackoverflow.com/a/17535694
I don't think you would've gotten down voted if you'd explained what you were complaining about. Instead it just look like you don't know how to do it properly and you're blaming Python for your mistake. At least that's my guess.
For built in types I've generally found that methods that mutate the structure will most often return None, unless it really makes sense to return a value (i.e. list.pop)
Unnecessary commas, in sentences.
well its not running in python 2.7 but running in 3.4 .
no doubts thNKS
&gt;ultimately you can improve things a lot by using pypy, The funny thing is I actually wrote a small prototype for a molecular simulation code in Python and PyPy ran slower than vanilla python did for it. 
I was going to say no ++ operator, but reading through this thread my new answer is "the stupid little indent added to the beginning of each comment on this subreddit".
Huh. Well, considering how much people might want to get access to those assets, I can understand a little paranoia, but that seems excessive. Sorry that your working conditions suck, buddy! And thank you for working on some awesome fun movies! 
Also looks like an ugly hack imo.
I bought the oreilly python pocket handbook, and it spends more time talking about the difference between 2.7 and 3.5 than it does talking about features.
Does the distinction matter though?
Everyone else that answerd my question understood it that way, except of you. I said you can't have the best of both worlds, you said yes you can, and i asked for an example. You are the one that came with type interfence, not i, i was always talking about 'statically typed', its even in my first response. Im still waiting for an example of a language that hast the flexibility of python while beeing statically typed. Imo thats impossible, and that was my statement from the beginning. And no, i don't use it, if its not clear what the type of something is from just looking at the code. I Would not use it here: &gt; auto msg = nam.post(request, data); But i'd use it here. &gt; auto nam = new QNetworkAccessManage(); 
Yeah, your mileage definitely varies, but the majority of pure Python code runs noticeably faster.
As long as there's still an explicit `self` as the first parameter then there's nothing external or magical about it. You just have one regular local var for the first parameter, and then automagically generate stores pointing back to the `self` for each subsequent reference. I'm not in love with the proposed syntax but it's not incompatible with the current design.
Have you looked into Conda? It maintains a pkg directory with all versions of packages that you are using and these are just hard linked into environments that need them.
As long as it's public you are free to do whatever you want (as long as you don't outright ddos the server). If you log in it's a different issue since logging in is in my opinion is right exchange. The data behind login wall is no longer public. However ToS should not be threated as law and you cannot copyright information (for the most part). So I don't like that some corporations can take people to court for breaking Terms of Service, that's ridiculous and abusive. TL;DR: anything public is ok at decent rates, behind logins/credentials the servers should have the right to deny you content but no legal action.
It seems excessive until you realize that the companies I have worked for have routinely been the target of nation-states. Disrupting a major blockbuster these days could have billion-dollar consequences across multiple economies. Turns out though it's far easier to just influence elections.
Yeah, I think having the default newline makes sense given prints normal use case. I think you can also use sys.stdout for direct writing. Print just exists as a function for the convenience.
&gt; Everyone thinks they need to plan for super huge scale, but that's a pipe dream 95% of the time *shrug* _You shouldn't throw out statistics - it just makes your argument look ridiculous._ I have about 150 million simultaneous "users" (embedded devices) I take care of, and we're growing.
The women who keep throwing themselves at me because I'm on 3.6. Not just a piece of meat here, ladies.
How does Rust have no run time? Doesn't the language provide a stack (and require a calling convention)? I thought one of the selling points for Rust was lifetime management of objects?
Do any "good" libraries still lack 3 support nowadays?
What are the issues it has with robustness? Is it stuff that can be solved by just unit testing the duck out of it?
It is. But it is a bunch of additions with an implicit 0 at the beginning, othewise `sum([])` wouldn't work. So `sum(['a', 'b'])` tries to do `0+'a'` and fails.
yes, an explicit self would make it a lot better, agree (my opinions were about the whole idea, including the self parameter removal)
Inability to `await` if function is not `async`. It again crates code divide just like py3 and is a good idea only on paper due to async creep.
I find the `print()` function in Python 3 with the `sep` keyword-arg works exactly how I'd want `join()` to work. So, when I have to do a bunch of joins, I usually find myself writing something like this: def join(*args, sep=' '): return sep.join(args) So assignment and output become basically interchangeable: print(var1, var2, var3, sep=', ') x = join(var1, var2, var3, sep=', ') I see people suggesting some similar things below, but I don't think anyone did this exactly.
https://twitter.com/dualcoremusic/status/875920011071635457
 &gt;&gt;&gt; functools.reduce(operator.add, ['1', '2', '3']) '123' &gt;&gt;&gt; functools.reduce("{},{}".format, ['1', '2', '3']) '1,2,3' (‚åê‚ñ†_‚ñ†) Edit: please don't use it, especially with long sequences.
What kind of things are people using Excel for that they should be programming? 
Sorry for not being a native english speaker. I shall never write another word online again. 
I hate the whitespaces too since I mainly script from the command line and use vim. I don't always have the python plugins installed, so it can be frustrating. For what it is, though, pycharm is amazing in my book.
Off-topic grammar burns on a social media site frequented by a substantial number of mobile users.
*sneaks away in shame and gratitude*
ISO 8601 obviously, what else it could be?
&gt; Edit: thing: the whole concept of virtual environments kind of sucks. It's awesome that I can keep my environments separate, but there's no built-in support for global stuff (i.e CLI apps) apart from "stick it in the system directories", which doesn't play nice with system package managers. pipsi is probably one of the most useful Python tools I've found - why isn't it in pip? If you're installing something system wide, I'd just go through the real package manager. Unless it's not in their repos (For me it's usually either there or in the AUR), in which case I can just make a package and install that. I'd love for pip to be able to use the system package manager to actually handle tracking the files and such. So it automatically downloads all the files, then creates a system package for every dependency (and marks dependencies as such so they can be cleaned automatically), then installs them.
It's a big standard. "2017" is ISO8601 for example 
And problem is? In what? Can you create datetime with year only in python? Whatever, it doesn't even matter.
I wrote a decorator for this purpose: https://stackoverflow.com/a/43946725/4955183
Your example lacks digits to be the most detailed format in ISO8601 :P
Thanks!
There was an effort to port it to python 3, and presumably it went well, but it *only* supported 3, it didn't support both 2 and 3, so it was rejected. 
Does Coconut substantively help with concurrency? (I'm spending most of my time playing around with Elixir/Erlang these days; what I've read/heard of Coconut is intriguing, but I'm not yet clear on how deep a difference it makes in Python programming.) edit: (keeping in mind that it compiles to Python; I know it's another language)
I mainly use print() to output log messages, where 99.9% of the time I *do* want a newline.
os.stat, probably? The return value closely matches the result of the C stat function, so people who write C don't need to try to convert what they know.
It *does* mean in some cases you need to use `pass`, though. Since there's no other way to represent an empty block like there is in languages that use braces.
Due to the refcounting there's no way to share memory, even for structures never written to. For example, import some modules, then fork and each process serves web requests. The reference count of each function will change when it's executed, causing the OS to copy that area of memory. Similarly for Django or jinja2 templates etc 
&gt; Python whitespace is also not consistent because if I use tabs and render it as 4 spaces in my IDE you might render it as two spaces. So now if we copy/paste code between each other that subtle (invisible whitespace) difference might actually have a functional side-effect. Pretty sure python complains if you have ambiguity based on indentation. In any case, just use spaces. 
wrt point 3, PEP 8 says to put spaces around the equals when there's an annotation, which makes it look slightly less crap: &gt; When combining an argument annotation with a default value, use spaces around the = sign (but only for those arguments that have both an annotation and a default). &gt; &gt; def munge(sep: AnyStr = None): ... &gt; def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ... Still looks weird, though.
Whatever. The key point is: it does not work "as expected" and you need items. I think it's the biggest omissions of the 2-&gt;3 incompatibility transition. EDIT: it could even be ``` for {key: val} in a_dict: ``` and it would be still better... 
I think it was a directory walk.
&gt; 1 line of code that should 10 lines of code. Come on! What about return time_lookup[bisect.bisect(map(itemgetter(0), time_lookup), datetime.datetime.now())][1] Is not obvious? 
Braces? Seriously? (and they are proud to point out semicolons are optional...)
It almost does, you just need to give an empty string as the second argument.
&gt; experience testing SPAs using Angular Yes. For the most part, don't worry about the technology. It shouldn't matter. It's a web interface and some RESTful APIs. Maybe a DB connection. Your concerns are going to be how to interact with the system by it's exposed interfaces. You'll want to verify the interface between microservices with api tests. You could look at [Pact](https://github.com/pact-foundation/pact-python). You have already stated how you intend to test through the UI. Do you clean the DB between tests, test suites, or do you just let test runs pollute the environment? Are you fiscally bound? Building and maintaining your own selenium grid is time consuming, it may be easier (and potentially cheaper when you consider man-hours) to use a third-party grid like [Browser stack](http://www.browserstack.com) so you can just shoot your tests off to them without maintenance hassles.
It does...? $ cat bad_code.py print("Hello, world!") print("" &lt;-- invalid syntax) $ python3 bad_code.py File "bad_code.py", line 2 print("" &lt;-- invalid syntax) ^ SyntaxError: invalid syntax Even if the syntax error is inside a method it still fails: $ cat bad_code.py print("Hello, world!") class BadClass: def moo(): THIS IS NOT VALID PYTHON $ python3 bad_code.py File "bad_code.py", line 5 THIS IS NOT VALID PYTHON ^ SyntaxError: invalid syntax
I agree 100%. It annoys me, and I fuck it up at least once a week. 
Personally, I'd like it if there was proper tail call optimization. I understand the given reasons to not do it, but I think it's easily overcomable for a somewhat significant performance gain.
I was sick of doing this and then, Wrote this : www.github.com/xssChauhan/Lego 
I rate limit, honor robots.txt/rel nofollow/noindex, and only keep non copyrightable information.
Multiprocessing is fine when you're just looking for a "map reduce" but if you need coordination among processes it becomes a chore... and starts to fall apart. One chore is properly managing shared data versus thread local storage of which all threads get a copy. It starts to fall apart if you need to share nested data structures. 
&gt; I just install without internet. This is really the right thing to do! I've never seen PyPI go down, but if it ever would, having a private cache is essential. Also it's the courteous thing to do to save bandwidth for PyPI.
Common man, that could easily be a lambda. You've just added 100+ bytes to my local namespace memory overhead, and slowed my variable lookup times by over a nanosecond. I'd have much preferred you'd wasted that nanosecond and memory on initializing and name-mangling a lambda object.
That means you're part of the % that does get a huge user base. 
&gt; You shouldn't throw out statistics - it just makes your argument look ridiculous. A report in the last few years found that effective failure rate of start ups funded by VC money was nearly 95%. Most businesses that reach tens of millions of users don't fail because the language they use is taking, say, 30% more resources, they fail for a variety of other reasons. So most VC funded startups fail but *most people beginning web projects aren't even VC funded* meaning that if they do get to really big scale... well, that's a real minor miracle. It's great that you have a lot of users, that's awesome, but the reality is that the *vast* majority of people won't have the same kind of problems you run into with millions of active users when they begin a web project and it's *not reasonable to assume you will.* Python is just fine (TM) :)
Please don't apologize, to me there is no need. Internet is a was place with a lot of people with different characters. I digged into lambdas on my own accord of my own laziness , and I just wanted to share. 
just kill me now. 
This is true. Usually I can find a way around that, but not 100% of the time.
It's not about Python _per se_, but... The fanboyz. On Reddit, and elsewhere, questions and comments are more likely to quickly escalate into name-calling than useful technical interchanges. More so than any other language I've dealt with. In other languages deficiencies are discussed in ways that bring to light other methods which might make the language better, but in Python it tends to become a religious issue very quickly.
AFAIK, coconut's parallel map uses threads, so it does not help. 
One of the main reasons to use a lambda in the first place is to avoid giving something a name that doesn't need a name.
I swear I've run into this before, but I must have mis-interpreted a run-time error as a syntax error. Thanks for the clarification!
Having done this many times ... the worms oh god the worms ... to be fair, if you want concurrency to spread across servers and survive reboots, you kinda have to take this approach, but most times you don't. Worms indeed.
I'm having trouble finding documentation for this approach. Is it officially supported, or is it just a fragile abuse of undocumented interfaces? EDIT: Parent didn't mention that this is new. No mention of it in the python 3.5 docs, but it appears in version 3.6.
Oh yeah, that's not an obvious return value. Doing what stat does and making an object that acts like a tuple, but also can be queried in a smarter way would work. Other than that, it's mainly just hoping your text editor has a good help function to see the return value.
Hahaha that's what I've been doing at work. Used my own cell data plan to download some packages. 
Because lots of people use Python for things that don't absolutely *require* concurrency, and you can get by surprisingly well without it even if you are doing something that would benefit. With that said, the concurrency issue is something that simply prohibits me using or recommending Python for things that substantially benefit from (or require) concurrency. So I just work on things that are OK with GIL. Problem solved. :)
That would be dangerous. You cannot play with time like that. Saving nanoseconds might change the behaviour of this function. And this function passed unittests: def is_it_true(bool_var): time_lookup = [ (datetime.datetime.now() + datetime.timedelta(seconds=0), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=1), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=2), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=3), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=4), 'No'), (datetime.datetime.now() + datetime.timedelta(seconds=5), 'Yes'), (datetime.datetime.now() + datetime.timedelta(seconds=6), 'No'), ] time.sleep(len(str(bool_var))) return time_lookup[bisect.bisect(map(itemgetter(0), time_lookup), datetime.datetime.now())][1]
Assuming the data is intended to be public, at least. If you find yourself enumerating values in a field to scrape everything available in a service, you could land yourself in trouble depending on where you live https://www.wired.com/2013/03/att-hacker-gets-3-years/
Agreed on the bad recursion. I want tail call optimization.
Huh, this looks pretty cool. I'll check it out, thanks!
&gt; Print as a function? Fine. Print automatically adding newlines and requiring me to use the "end" argument to suppress obnoxious-by-default behavior? Bleh! Why? I rarely find myself wanting to suppress the newline. But if you find yourself writing `end=' '` a bunch, there are ways to avoid that tedium. Using `sys.stdout.write` directly is one, but if that's still too tedious (I mean, c'mon, *two* dotted lookups to print? This isn't Java..), you could always use a partial. from functools import partial echo = partial(print, end=' ') echo("Hello world!") 
Agreed. The only scary thing is that 2\^5 is valid code that doesn't do what OP instinctively thinks it does.
Had to add some extra parentheses to get b2 to work: b2 = [(lambda y:(lambda x:x[y]))(i) for i in range(3)] Otherwise I was getting "TypeError: 'int' object is not subscriptable"
This is really lame, but requiring parentheses for print() is something I still can't get around. I've just written too much code without. More of a hassle is this business with encodings and making things match up between various libraries and web calls. I spend so much time tinkering with asinine little details that should "just work." I even took the time to actually learn how encodings work and how to work with them, but holy shit this is a pain. GIL. So annoying to have this be the single issue that rules out an otherwise perfectly capable language. Sure, you *can* work around it, but the development and complexity cost compared to other languages makes this dealbreaker more commonly than I like to think about.
Is this a toy example, or something that has actually bitten you?
I'm legitimately terrified, this code is so perfectly bad I'm having a panic attack.
As someone else mentioned, tuples are immutable. Also, one should have a mild allergy to creating containing values of different types, whereas tuples are designed for that.
well, don't write like that
You can do it, but it ain't worth much: In [1]: sum('', ['str1', 'str2']) Out[1]: ['str1', 'str2'] 
Just started working on a simple metronome program but having troubles with the audio playing at equal intervals, going to look at other metronome programs out there and learn from them!
Thank you. I tried my best.
"Hard to justify building anything real" is pretty harsh. Not every "real" piece of software requires concurrency.
It's [possible](https://github.com/baruchel/tco) to get it, though it's ugly and kind of defeats the purpose. Guido doesn't [want TCO](http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html) though, so practically it's not going to happen.
Not great, but a start. One of the most important thing rules is Don't Repeat Yourself (DRY). Almost all your code is repetitive.
I like that in PHP the programming language is also the templating language. I suspect that would be harder with an indentation-based language.
Wdym I repeat?
***K I L L T H E G I L***
Well, you ask for the operation to perform, and then almost everything is the same. I can tell you're just getting started, and good work so far, but a lot of code is being copy-pasted that doesn't need to be.
Whatever anyone here is saying, you need to do these two things (at the minimum). Read the Ts&amp;Cs Check the robots.txt file In your case if the website is selling the data, I'd be hugely surprised if the Ts&amp;Cs don't explicitly state that scraping and reuse of their data is prohibited. Normally its only if you are planning to do so for financial gain but occasionally not. The general rule is obey robots (which may tell you what is available for scraping and how long to delay requests, or not even exist) and obey the Ts&amp;Cs. If you do that, you are making the grey issue more black and white. 
Oh, absolutely. Fortunately in most of my use cases shared state is held in Postgres, which is simply fantastic at handling concurrent transactional access. 
Thank you for your valuable input, also your formatting is beautiful. (at least on my phone app it is) 
Disable the PyLint error or install [pylint](https://www.pylint.org/). If installation doesn't work your Pythons are probably all fucked up.
Which is way better than the Python 2 `.pyc` approach.
It hasn't *bitten* me, but it would have if a coworker and I didn't test (a similar example of) it first.
I maintain a command line utility written in Python that is packaged for several Linux distros. Postgres is overkill - I don't need to persist data across invocations, I just want to exploit all cores for complex work. Multiprocessing isn't good enough. Asyncio requires me to rewrite. 
That's not very relevant to OP's question. 
&gt; That's seems cleanest to me. My choice would be by, locator = self._facebook_signin_btn setValue(by, locator, value)
[unittest](https://docs.python.org/2/library/unittest.html) is part of the standard library. It has setUp() and tearDown() methods that run before and after each test. There is also [pytest](https://docs.pytest.org/en/latest/) and [nose](http://nose.readthedocs.io/en/latest/). and [nose2](http://nose2.readthedocs.io/en/latest/usage.html) apparently. Use [mock](https://pypi.python.org/pypi/mock) for mocking and everything related to mocking. 
Are you aware that a great deal of robust large scale software has been written in Python, including the platform you just posted your message on? Robust software requires good engineering, the language itself is secondary.
This argument is usually based on subjuctive readability, which is a function of experience. At some point lowest common denominator becomes a hinderance. I am not advocating for a change, just answering a question of what's bothering me. 
I find nim to be a pretty good statically compiled python.
Learn Flask: https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world 
You need to organise code in a way "small parts" then "bigger parts". If you read "Clean Code" you know what I mean. Robert C Martin suggests to write code like that: def send_email(): r=get_recipient() s=get_subject() c=get_content() send(r,s,c) def get_recipient(): #code to get recpient def get_subject(): #code to get subject ... So first you define main logic, then you define helper functions used in it. In Python this will end with error that send_email() doesn't know get_recipient() Or maybe it is possible to achive? Any suggestions?
I've already manually installed Pylint, and it hasn't changed anything. I'm pretty sure it has something to do with the paths for Python 3 vs python 2 (I used "pip3 install pylint" in the terminal, but VScode keeps trying "pip install pylint"), but I don't have the context to figure out how to fix it myself, and the internet has been *staggeringly* unhelpful.
GUI development is... Let's say it leaves room for improvement. 
I usually do this by making a function that operates on one row of a pandas dataframe. "lookup" takes one row from a table that has an "address" column and returns one row that has address, longitude, latitude. dataframe.apply(fun, axis=1) runs a function on every row and makes a new dataframe from the results def lookup(row): h = geocoder.arcgis(row['address']) row['latitude'] = h.lat row['longitude'] = h.lon return row df = pd.read_excel(inputfile) df = df.apply(lookup, axis=1) df.to_excel(outfile) 
Any particular reason you're wanting to use vscode? PyCharm is probably the best ide out there, is very straightforward to use and is packed with features that make life easier. 
1. /r/learnpython per the sidebar 2. pandas is probably better suited to this than openpyxl
I wish there was a SELECT CASE system for branching.
Honestly? At this point, mostly stubbornness. I'm really bad a giving up. I'll check out PyCharm and probably use that from now on (as long as it's free or the free version isn't missing 90% of the features), but I've spent the last 4 hours trying to get VScode to do exactly what it said it could do, and god damn it I'm not gonna give up now. &amp;nbsp; ^(Unless it turns out to be totally unsolvable in which case fuck it)
You can try: $python3 -m pip install pylint If that doesn't work you'll need to figure our how python was installed and the path env variables associated with it.
Braces are not that bad. I used to hate it but I can live with it its not a deal breaker for me. 
You can just disable the pylint error, it won't affect your code or app in any way. Although not being able to install pylint could be a symptom of a larger issue with your environment.
Well, that's because the iterable comes first, then the base case. However python explicitly checks for strings and tells you not to do it. In [1]: sum(['str1', 'str2'], '') --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-1-e0714aa7e662&gt; in &lt;module&gt;() ----&gt; 1 sum(['str1', 'str2'], '') TypeError: sum() can't sum strings [use ''.join(seq) instead]
What about this? def isetattr(self, loc): [setattr(self, k, v) for k, v in loc.items() if k != 'self'] class C: def __init__(self, a, b, c): isetattr(self, locals()) 
`%autocall` almost does what you want in `ipython`.
&gt;symptom of a larger issue I've said this above; I really just think it's some setting in VScode that I haven't found yet. I'm probably missing something totally obvious. I think it's probably trying to use Python 2.6 and relevant modules, because I can install Pylint just fine with the pip3 terminal command, but I never bothered to even check if I had pip for anything older than 3. I'm pretty sure the in-built python that comes with OS X doesn't come with pip. To clarify, when I (succesfully) installed pylint manually, I used: pip3 install pylint But when VScode tries to do it, it's using: -m pip install pylint Wherever Pylint is installed, that's not where VScode is looking.
This is so true. Just because Python can do anything, doesn't mean it should do everything every time. Right tool for the right job. If that's Python... great!! If not, don't force a square peg in a circular hole.
&gt; information on iPad owners that had been exposed by a security hole in AT&amp;T‚Äôs web site. Yes, if you screen scrape through a security breach then you'll get in trouble, but if you legitimately have access to the data you can likely screen scrape it. ToS hardly applies if it's a public website, and if its a private website then you'll be in contractual breach not a ToS issue. Contract breaches are simpler to deal with as the solution is to make the other party whole---likely by paying the cost for the bulk data export service that they offered.
Is there a place where I can see the code of each command? Like the code of move()?
Try going into the settings in vscode and changing the value of "python.pythonPath" to "python3".
I think that worked! I kept finding answers that were *similar* to that, they all had to do with changing path variables and whatnot, but nothing that simple. Thanks!
This is sound advice. &gt; If you do that, you are making the grey issue more black and white. I'd agree with this. With the caveat that it is unclear whether violated robots.txt or terms and conditions is in anyway illegal (civilly or criminally). And a caveat to that statement that you might prefer not to be the test case.
The Python definition for `move()` is found at https://github.com/aroberge/reeborg/blob/master/src/python/reeborg_en.py#L126 This is not very helpful. Read the short section explaining how to use `help_js` at https://aroberge.gitbooks.io/reeborg-s-world-advanced-world-creation/content/exploring-and-getting-help.html You need to select Javascript as your programming mode (the back-end is using mostly Javascript). After looking at the output for `help_js(move)`, you should be able to guess that the next step would be to run `help_js(RUR.control.move)` ... and you will see most of the relevant code there. (The output of `help_js(move)` and `help_js(RUR._move_)` is the same.) --- In case you are wondering why I did it this way: I need to have a common "root" function for any command using Python or Javascript, in either English or French (the only two languages supported right now). [In French, `move` is `avance`.]
A couple of clarifications that I feel are important. &gt; you cannot copyright information (for the most part). Alas in many countries one can. See "database rights". The rule is something like you can't copy a substantial amount of information that they have spent effort obtaining. I don't know about direct price information... since this has a lot of public value. 
I hear pytest is the rage among the kiddos. Im checking it out right now, but it still seems to be a bit convoluted to do what I need. Edit: i need to write paramaterized tests, for testing a specific action across a range of values.
As I'm transitioning from PowerShell to Python I'm focusing a lot of learning the basic syntax. I'm also trying to find the limits of the standard library so I'll know when and where to lean on other modules. Right now I'm brainstorming projects to get my feet wet and I think posts like this will breath some inspiration for me!
As far as I understand it: y[np.array([0,2,4])] means: select row 0, 2 and 4. Then after the comma you can specify which columns (`1:3` means columns 1 and 2). y[np.array([0,2,4]), 1:3] This is equivalent to: y[np.array([0,2,4]), np.array([[1],[2]])] So you cannot say the 1:3 slice is always equivalent to ` np.array([[1,2]])`, it depends on the context. 
This rules comes quite close to saying "never scrape".
Vague question linked to stackoverflow telling you it's a vague question....
Noob's still-doesn't-work Sudoku solver.
Distribution Gui Indentation - if i lost track, program fails miserably. I am much happier with braces and then let tools do indent/gofmt/rustfmt.
&gt; type-hinting I never had an issue with pythons typing and I don't like type-hinting. So can you provide an example of where pythons typing failed you?
Throwing in a few datapoints. In many, industries scraping is endemic (price scraping / etc). See "database rights" regarding whole scale copying of data. You should be aware that there is the concept of an unreasonable contract and a judge may rewrite a contract should a case go to trial. In contract law you get principles like "quid pro quo" etc that can limit damages. As others have mentioned the US is a bit crazy about what constitutes hacking. C.f aaron schwartz and weev. There was also an interesting case involving ryan air in europe. Case law is limited. As a personal pet argument I would argue that the use of a browser is in some way "scraping". The technology of the web involves using programs to automatically fetch data using an open standard. In this context saying I have to use one browser rather than another is a bit strange. Judges, however, specialise in answering impossible questions, which has an unfortunate side effect that they can apply such techniques to simple questions to reach quite strange results.
In that situation one of three things is the case: * your function is too big and does too much * you're handling your data wrong * you have to type this out *somewhere* anyway, so it might as well be there (like defaults for a basic function)
I still scrape millions of pages so I'd say never is a harsh word...
I bet they are all boring though :P
&gt; However, if you are scraping data that a company has spend time and resource on obtaining, and then using that to be monetised in some way, it's like piggy-backing on their investment for your own profit and that could be seen as less ethical. However note that this kind of "data curation" is explicitly exempted from copyright protection.
Not in the US (and who care about the rest anyway amirite?)
Python 2.x has old-style classes and new-style classes. Python 3.x only has new-style classes: https://wiki.python.org/moin/NewClassVsClassicClass
Pythons memory management and garbage collection. I would like to be able to unload modules. :(
If you read "ethics" courses for medicine / other careers. They often consist of things that you can get in trouble for together with the things that professional bodies think you should do in a situation. Under this interpretation of ethics it's kind of relevant.
Have you tried, you know, not being a dick?
&gt; Oh, and having to declare self in classes. I would think this is a given (like it is in many other languages), but apparently it's not. I prefer this. For multiple-level subclassing with lots of inherited member variables in C++ (not sure about other languages), I find it very difficult to see whether or not a variable is method local, a direct class member, or inherited two levels up. `self.x = x` is also an improvement over `foo(mat &amp;x_) : x(x_) ...` especially when mixing how you assign things.
O(N^2 )...
The "math library" being separate from the core language doesn't bother me anymore, since that's how it is more most languages. I also think MATLAB is terrible for anything other than math, and 1-based indexing is a sin, but those are just opinions. If you don't know about it already, using `np.matrix` rather than `np.ndarray` will cause `A * B` to do what you expect, rather than `np.dot(A, B)`. However, `A / B` does _not_ still...
&gt; In Python this will end with error that send_email() doesn't know get_recipient() &gt; &gt; Or maybe it is possible to achive? Any suggestions? Can you show an example?
Going nuts when it ignores white-space until I realize that some WS is spaces and the other, visually identical one, is tabs...
The problem is writing code like this in the first place; it's basically unreadable, especially `b2`. Maybe it's because they're syntactically crippled, but I wouldn't use a Python lambda for anything other than extracting a single hard-coded key or index. I'd also recommend using the object-oriented interface for mpl rather than the MATLAB-style one, it's a little bit less state-machine like.
You've written this program chronologically, instead of just *logically*.
I *really* liked the look of Kotlin when I looked at it a year or so ago, but there was on thing that just made it a no: how to create most sequence types: `hashMapOf`, `arrayOf`, `intArrayOf`, it's all *plain wrong!* You actually have companion types, for literally (I mean literally) this purpose, so it could've been `HashMap.of()` or such, but *no*, they have to mess it up with global scope functions. I mean Ã¢wÃ≤Ã±Ã≠Ã∞ÕéÃ∞ÕïhÃ¶ÃûÃØyÃ∞Ã£ ÕÅÃ†ÃñdÃ°ÃòoÃ¥ÃóÃ≥ÃÆÃ•ÕÖÃ™Õô ÃßÃºÃôÕÖyÃ£ÃºÃüÃ™Ã†oÕÖÃñuÃ®ÃñÃ£ ÕùÃ∞hÃúÃñÃ¶Ã©ÃüaÕòÃñÃ£Ã¨Ã≥vÃïÃùÃØÃ≤eÕòÕçÃ¨Ã§ÃπÃ©ÃºÃò ÃòÃ©ÕïÃ†tÕöÃñÃùoÃ¥ÕïÃ§Ã†ÃùÃ¶Ã± ÕÅÃóÃ≠ÕìÕïÕödÕúÕáÃ¨ÃπÃ©ÃóoÕìÃ≤Ã£ Õ¢Ã±Ã§tÕâhÃµÕàÃÆÕïÃüÕçiÕòÕçÕïÃºÃüÃ±sÕÅÕçÕâÃºÃ™Ãª.Õö Õ†ÕáÃ£Ã≠Ã£ÕîÃûTÕÄhÃ§eÃ∑rÃ∫Ã£ÃòÃóÃ§ÃúeÕùÕöÃüÃπÃ¶ÕÖÃ• ÕòÃØÃπÃúÃ†ÃòÃòÕàiÕ°ÕïÃùÃúÃùÃ§Ã±sÃ∏Ã†Ã∞Ã¶ÃûÕÖ Ã∏cÃµÃºÃùÃ´ÕÖÃ•Ã†Ã•lÕÅÃôeÕöÕìaÕÅrlÕúÃóÃùÃòÕçÃ´ÕéÃ∫yÕÄÃùÕéÕì aÕèÃ≠Ãò ÕúÃñÕöÕábÕÄÕâÕÖÕée“âÃ∞tÃïÃ´Ã§Ã≥ÕñteÕ°ÕéÃúÕñrÃ¥ ÕÅÃ≤ÃùÕïÃ™Ã≥wÃºÃØaÕïÃòÃ≥ÕïÃ†ÕÖÃñyÕüÃÆÃ¶Ã≥ÕçÕïÕî.Ã¥Ã≥ÃôÃúÃ∫Ã¨Ãü Ã≠ÃüÃ†ÃòÕéÃÆKÕèÕïÃùÃØÃüÃºoÕîÃ≤Ã∫t“âÕîÕàÕçlÕïÃ≤ÕñÃ≠ÃºÃ•i“âÕàÕàÃ™ÃôÃ•ÃônÃ™ÃûÃ¨ÕáÕöÃü ÕéÕîÃùÃ≠Ã©wÕ†ÕñÃ∫Ã¨aÕùÃûÕöÕîsÃ∂ Ã£Ã≤tÕúÃ©ÕöÕôÃ£ÕïhÃïeÕüÃùÃ±Ã∞ÕçÃ≠ ÃùÃ•ÕîpÃûÃ•Ã±ÃªÃ£Ã≤Ã∞eÃïÕáÕöÃ¨ÕárÃ∂Ã©fÕüÃóeÃ∑Ã≥Ã•Ã¨cÕéÃ∫ÃªÃ£ÕìÃ≤tÃïÕï ÕùÃ¶ÕôÕöÃ£ÃóoÃ°ÕöpÕÅÃúÃ©Ã≠Ã´Ã™pÃ°ÕÖÃ™ÕáÕéÕïÃ†Ã†oÕûrÃõÃÆÃùÕïÃúÃ´tÃ∂Ã¶uÕàÕôÕâÕÖÃúÕînÃ°i“âtÃ°ÕìyÃ®Ã™Ã¨Ã†Ã©ÕéÕà “âÕöfÃúÃûÃ¨Ã¶ÕÖÃÆoÃµÃ∫ÃªÕáÕàrÃÆ ÃªÃ™Ã≠ÃóÕçaÃ∫ÕÖÃ©Ã§ ÕÅÃ¨Ã†ÃüÕâÕöÕìlÃ∑Ã≠ÕáÃ≥ÕéÕâoÃóÕîÕïÕÖÃûÃØÃÆvÕòÃ≠ÃñeÃ∏ÃüÕçÃóÃ±Ã¨lÃ∂ÕâÃ£Ã¨ÃØyÕùÃ´Ã© Ã∞Ã§ÃñÃ•Ã≥JÕ°ÃñÃ∫Ã≠VÃºMÃûÃ©Ã´ÕçÃºÕÖ Õ¢ÕçÕöÃ†lÕñÃ¶aÕáÃñnÃ®ÕàÃ†gÃµÕàuÃßÕçÃºÕñaÃõÃ•ÃüÃ¨Ã∞Ã∞ÕñgÃ©Ã≥ÕàeÕìÃ±ÕâÕáÕïÃ≠,Ã∑Ã¶ÃóÃ§ÕáÃ´ Ã°Ã†aÕéÃúÕìÃ¨ÕñnÕ¢ÕçÃúÃôÃ•ÕöÃ±dÕ† Ã∞Ã∞ÕáÃóyÃ¥ÕçoÃ¨ÕöÃúÕéuÕûÃ•ÃúÕç ÕüÃ†ÕîÃ±ÕìÃüÃºÃürÃôÃ£uÃ∂Ã¶ÃÆÕâÃ£Ã∫Ã≠ÃóiÃ™ÃØÃ™Ã∞nÃ∂ÕìedÕïÃ™Ã¨ÕáÃªÃ• Ã°Ã¶ÕñÃ∞iÃ±tÃ∏Ã±,Ã∑Ã£ÃÆÃúÃØ nÃµÕàÕáÕçÃ†oÕàÃ∫Ãü, ÃúzÕçÃÆÃùÃÆÕôÃóaÕûÃºÃùL“âÃûÃúÕáÕáÃπGÃ©Ã§ÕìÃ≥Ã¨ÕöoÕ°Ã©ÃºÃ¶ÕìÕñÃôÕà?ÕûÃóÃ¶Ã§ÃûÃ≥Õî ÕàÃ¨Ã†Ã¶Ã´Ã†IÃªtÃ∞ÕçÃüÃ∫ÕáÃ™Õï ÕÄÕôÕÖÃØÕáwaÃõÃûÃñÕìsÃ°ÕîÕìyÃºÃ≥Ã¨ÕîyoÕüÃ≥ÃôÃúÃ•Ã•ÃØuÃï?ÃßÃ∫ ÕùÕàÕàNÕòÃ≥ÕÖÃ´oÃºÃüÃ£Ã™ÃºÃ´tÕâÃüÃñÕàÃ≥ ÃµÃØÃ†ÃπÃ∞Ã©Ã¨Ã†TÃ¢Ã∞Ã∞ÃñhÕïEÃùÃªÃú “âÃ∞ÃôÃ¨Ã≥pÕüÃ´OÃØÃ±Ã≥NÕ¢ÃπÃôÃûÃ∫Ã©ÕìÃ™YÃßÕôÕñÃ™, Ã¶ÃôÕéÃªTÃ®ÃóÃπÕàÕîÃóHÕòÃúÃüÃóEÕçÃª Ã∏Ã¨Ã†ÃôÕöÃ≠ÕâPOÕçÃ§ÃùÃ∞ÕáÃπnÕèÃ£ÕöÃØyÃ∂ÕáÕàÃ∞Ã§Ã∞ÃñÃ∫,Ã∫ÕâÃ£Ã±ÕçÃ∫ Ã∑ÕéÃ£ÃüÕàhÃ∫Ã§ÃÆÃûÃ¨ÃòeÃ©Ã≥Ãô,Ã¢ÃπÕï ÕàÃ´Ã•Ã≥ÃüÕéhÃ∞ÕçÃñEÃ∑Ã¶ÃºLÕùÃ¶ÃºÃ£ÃòÃúÃ∞Ã∫PÃßÃØÃ§ÕÖ hÃïÃπÕáÕéÃ≠ÕîeÃ∑Ã≠Ãú Ã¥Ã∞Ã£ÃπÃ¶ÃòÃ¨Ã•CÕòÕñÕéÃ≥Ã†OÕìÃ¨ÕéÃòÃ©ÕÖÃ≠mÕûÃ§Ã≠ÃÆÃòÕçeÃ∫ÕàÃØÕáÃüÃòÃØsÃõÕéÃùÃóÃóÕâÃ¶Ãò Ã§IÃ≠ÕáÃ±rÕ°ÕìÃûÕâÃªkÃÆÕîÃ©Ã™nÕéÃóÃØÃÆoÕÄÕàÃºÕéÕÖÃ¶ÃºÃ•wÕ¢ÕâÃØÕôÃñÃóÃñÃú NÃßÕôÕéOÃ†Ã©ÕìÕïÃÆWÃµÃØÃ´Ã≥ÃºÃÆÕö Õ¢ÕïÃ∫ÕéÃ´Ã¨WHÕÄÃüÃ±ÃòÕïÃôhÃ•Ã©Ã¶ÕôÃ≠dÕúÃ≠ÃπÃπÃ•ÕâÃØÃπfÃ¨ÕîÃ±Ã±ÕîÕáhÕúÃùÃ§ÃñÃ¶Ã¶ÃñeÃ´Ã™Ã¨ÃºÃ©ldÃ†ÕÖÕöÕìÕçiÕ°ÃúdÕöuÃ≠ÃüÃ•ÃüÃ©ÕöiÕÄÃ©ÃóÕâÃ£ÃºÃ≠tÕÅÃ©ÃóÃªÃ≥Ã©Ã¨dÃ∑ÃóÃ†ÃôÃùÃ†Õì
The one thing I miss is call signature-based function overloading, so I guess built-in multiple dispatch. Can't do it because of how namespaces and lookup work. But, I'd rather have monkey patching and "function pointers" rather than C-style function pointers, so meh.
Languages are tools. You can build nice things, even large things, with subpar tools. I don't want to, but sure, you (and others) can.
From vs code terminal type: $which python $which python3 $which pip $which pip3 Then do the same from a system terminal. Do the values match? EDIT: Looks like you got an answer!
Sometimes I do this: class Foo(): def __init__(self,*args,**kwargs): properties = { 'foo':0, 'bar':['this is a pain'], 'baz':'NODEFAULT', } for i, (name,default) in enumerate(properties.items()): try: setattr(self,name,args[i]) except IndexError: assert (default != 'NODEFAULT' ) or (name in kwargs ): 'Value not provided for {}'.format(name) setattr(self,name,kwargs.get(name,default)) Because... that's way...simpler?
 &gt;&gt;print(type(())) &lt;type 'tuple'&gt; &gt;&gt;print(type((1))) &lt;type 'int'&gt; &gt;&gt;print(type((1,2))) &lt;type 'tuple'&gt; 
Also long compilation times for some packages (that don't provide wheels for your platform). E.g. `pip install dlib` takes minutes to complete.
PyCharm and VSCode serve different purposes, (PyCharm for big, multi-file projects, VSC for individual files). They're both great Python tools.
Or C# (designed by the Delphi guy, not coincidentally). Though IMO Delphi was actually better back then.
Not mostly, but it does come up every now and then.
"Not a professional" == "I don't think I'm good at it, and nobody's paying me to do it." That's all.
https://docs.scipy.org/doc/numpy/user/basics.indexing.html#combining-index-arrays-with-slices "In effect, the slice is converted to an index array np.array([[1,2]]) (shape (1,2)) that is broadcast with the index array to produce a resultant array of shape (3,2)." 
Sticknman, Thanks for the help. I'm running your script and I'm receiving the following error: File "C:\Python27\lib\site-packages\pandas\io\excel.py", line 749, in write_cells from openpyxl.utils import get_column_letter ImportError: cannot import name get_column_letter this was throwing the error because it was looking for openpyxl.cells import get... but I changed this to utils and i'm still getting the error. The get_column_letter also exists under openpyxl.cell.cell.get_column_letter If you have any experience with this error please let me know how you resolved it. Thank you. 
You do not need so many attributes to begin with. Imagine the difficulty to use such API, to retain the order and what each attribute corresponds to...
Dependency management. * pip not having a requirements file and a lock file. When I install a package that has its own dependencies and pip freeze, it all ends up in there and accumulates. When I drop the original dependency it's hard to tell what's not being used anymore. * Native dependencies. `apt-get install libsomething` completely breaks the Python flow, relies on os-specific package managers, makes it hell to find the right version, sometimes you have to compile it yourself from source...
Well, in the strictest sense no language higher than Assembly completely lacks a runtime; like C, Rust does a small amount of initialization at startup, but it doesn't have a garbage collector, and most language features that require more initialization are opt-in-on-use, rather than bundled into every binary. It's part of why it's seen as more appropriate for traditional kernel-level systems programming than, for instance, Go.
 a = [1, 2, 3] b = a[:] b[0] = 4 print(b) # outputs [4, 2, 3] print(a) # outputs [1, 2, 3]
In your vscode settings look for the python interpreter path. IIRC by default it's the path to the python 2 interpreter (something like /usr/bin/python). Change it to your python3 interpreter's path (/usr/bin/python3). Then make sure you have pip3 installed and it should be able to install and find pylint by itself
I automated the process of opening tickets with our vendor. Its been really helpful. A process that once took 40 minutes down to 1 minute. Its a beautiful thing.
It looks like there have been some changes to the openpyxl module names. my guess is you need to upgrade to the latest pandas and that will probably upgrade openpyxl and import the correct names. 
It is. I should probably add a disclaimer.
I'm sorry, could explain what "enumerating the values" means?
How can I find the robots.txt file for a website? Thank you very much for this advice, this is the sort of thing I was looking for.
Cefpython is a lifesaver. The package size is rather large, but making a great guilty in html is trivial and cefpython makes binding ui elements to the back end super easy. 
To clarify, what I mean by "cython compilable" is what's called "pure python mode", where you keep your python files as .py extension, but add a .pxd file of matching name. If you maintain a certain degree of discipline (essentially respecting cython's shortcomings), then you can run interpreted, and you can compile and run compiled. It's definitely a bit of an exercise, but it pays off for hot code. For instance, I have a cython implemented binary search which performs about x3 as compared to the numpy.searchsorted function. (This makes sense because searchsorted is very fast and the overhead of checking for broadcasting etc can easily outweight the actual O(log n) performance of the search itself).
Party like it's 1999! Seriously, I love python, but GUIs and distribution kill my buzz.
With Flask, I find it simpler to just have my program run on localhost in a browser. The browser is already cross-platform GUI and simple Jinja templates make this process relatively simple. Minimal effort on your part.
Say this web page gives you a list of documents and each URL contains the document's ID: 23489, 23493, 23502, etc. You notice that these numbers are pretty close together and, even though you don't know document 23490 exists (because it isn't accessible by clicking links in your browser), it's likely that new documents just get an ID that's the last ID + 1 and therefore there is a good chance document 23490 exists. You can continue the enumerating part by checking with your scraper whether documents 1-23488 exist, or can continue even further and check if there are newer documents. Since this website never actually told you those hidden documents exist, some would consider it unethical (and AT&amp;T, illegal) to guess at document IDs you were never explicitly given access to. In theory, the website should have access controls that prevent you from accessing documents you *shouldn't* have access to, but it doesn't always happen.
www.google.com/robots.txt Just the root of the website /robots.txt It either exists or it doesn't! 
Meh, a simple change of the default `end` argument doesn't seem like much to ask then. I guess it could be an annoying change when in many languages the equivalent print statement does not include a newline.
This is one of my favorite new python patterns. You can even have instance methods, so it is just like any other immutible class, but lower boilerplate
See the "formatting help" link below for hints on getting programs to format properly on the screen (spoiler: put four spaces in front of every line for code blocks). Here's a modest improvement to your program, formatted properly, with less repetition and some error checking. You don't need to define functions for the operations, because it makes it *harder* to read and understand. On top of that, you shouldn't normally define a function in an if statement: def input_num(prompt): num = None while num is None: inp = input(prompt) try: num = float(input) except ValueError: print 'Please enter a valid number.' return num while True: option = input('would you like to add, multiply, subract or divide, Q to quit') if option and option.strip().lower()[0] == 'q': break num1 = input_num('enter first number:') num2 = input_num('enter second number:') opt = option.strip().lower() if opt == 'add': print num1 + num2 elif opt == 'subtract': print num1 - num2 elif opt == 'multiply': print num1 * num2 elif opt == 'divide': print num1 + num2 Can you see how you might make a function to get the operator and make sure it is one of the allowed ones? Hope that helps.
 from copy import deepcopy Or if you're really annoyed by having to type so much everytime you need to make copies (which is pretty low for me personally, though YMMV): from copy import deepcopy as copy Though this is may be a bit more confusing for someone else looking at your code.
That was a great explanation. Thank you very much.
Yes! This is definitely annoying.
Thank you! Can I assume to be (at least somewhat) safe if the robots.txt does not exist?
Generally, there are huge advantages to static-typing in terms of catching errors before you ever even run the program, for instance: def foo(d, k): return d.get(k) def bar(): return foo(False, {}) Now, imagine that, like everyone, you're too busy to wrote unit tests, and it turns out bar is only called in very rare conditions, the sort of thing that happens but once every ten thousand years. 9999.99 years from now your memory will be cursed by people bitten by an error a compiler in a static-typed language would never have allowed to compile. Now, practically speaking, the main place where dynamic typing truly fails is in the IDE and specifically code completion... even the best Python IDE can only take a guess that you mean to type in some known name as the argument to that fancy new lib's core class that you've been dying to try... it can't know that the first argument must be, for instance, an Exception, and reduce the hinting it provides you accordingly. PyCharm feels pretty slick, right up until you try Visual Studio Code with TypeScript, then you suddenly realize that you've brought a wet noodle to a gunfight.
You should use pytest. 
This works for functions. But I think you are referring to classes. In [7]: class Mail: ...: r=Recipient() ...: --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-7-4a09aff187ce&gt; in &lt;module&gt;() ----&gt; 1 class Mail: 2 r=Recipient() 3 &lt;ipython-input-7-4a09aff187ce&gt; in Mail() 1 class Mail: ----&gt; 2 r=Recipient() 3 NameError: name 'Recipient' is not defined 
You need a better IT department. Every single IT guy who carries on about securing the network by employing nonsense policies that block things like installing a python package via pip, as just one example, almost always has some hole somewhere in the network through which I can drive a Mack truck. But, they'll argue their position saying that are reducing the attack surface. Fine, but I can still drive my Mack truck. Congratulations on wasted effort.
Well, yes, to a point... *if* you've got a test suite that tries all conceivable permutations of inputs, have avoided passing mutable types entirely, and can somehow guarantee that the yutz using your code never does a **reload**.
I know a bunion named mb 
Right, but correct me if I am wrong, I don't see any work around other than class method to implement it and keeping the `str.join` syntax :)
Lambdas can only be single-line.
If you download Anaconda, it'll come with a bunch of packages preinstalled. Useful if you want, them, but they have a separate download for Miniconda which is really just the `conda` environment manager, python, and a couple of dependencies - the idea being that you only install what you need.
I agree with you. but my usecase for kotlin is for android development. so it basically just boils down to kotlin or java? i'll take kotlin anyday over java. its the closest thing to python that is now a recognized language in the android environment. 
 print(('Hello', person))
How is go ORM story as of today? Something comparable to Sqlalchemy is available?
I can usually get around it using other slower methods, but it is annoying. Especially since it varies from machine to machine, even when the http_proxy and https_proxy system environment variables are set! 
Worse: super(MyOwnClass, self).__init__(self, *args, **kwargs)
I fucking hate that everything in the world comes back as an iterable in python 3. I would be much happier if you got lists when it made sense to get lists, and asked for iterators when you needed an iterator. I haven't hated a programmatic phrase like list(iterable) since public static void main ([] int args) (...or whatever). 
As a workaround, `from copy import deepcopy as copy`
It annoys me all these people who defend his by going "yeah well it can be run on any platform/device in the internet", yeah only because it's got the interpreter in a browser, if we put a python interpreter in the browser it would run everywhere as well!
&gt; val data = mapOf(1 to "one", 2 to "two") wat &gt; String Interpolation by default ugh, that's gonna be a headache some day And what's with the "val bla: type" in function definitions? What does val do? 
Sounds like a school question the way it's asked on SO. Obviously the asker is newbish for even asking what is "best." 
They would lose. But good grief that would be an expensive fight. 
Use [moto](https://github.com/spulec/moto) to mock boto3. 
How it deals with OOP. Atrocious. Single line looping is odd to me.
Some say it goes too far...
TL;DR: &gt; Python 3.5.4 is the last "bugfix" release of 3.5. The Python 3.5 branch has now entered "security fixes only" mode; going forward, the only improvements made in the 3.5 branch will be security fixes.
There are so many things that I hate more, but I think this is funny so I'll leave it here: http://turnoff.us/geek/python-private-methods/ 
If it's in the cloud, your files are not private. But wait... you can't install any software on your machine, but you think they'd be ok with you delivering their IP up to some cloud ide? Make sure the old resume is up to date. 
I'm just enjoying the fact that we talk about if python can scale as a web language on one of the biggest web sites on the net - which is running mostly on python.
If you give the lambda a name, what is the point of it over a function? Its basically becomes a case of trying to save a couple of lines at the expense of readability, testability and harder to debug for no good reason at all.
For me, the code smell was always writing self.a=a for most properties except the few I wanted to do something more with. Especially so when I forgot one.