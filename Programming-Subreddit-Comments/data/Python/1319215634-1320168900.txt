just made a plugin for py.test to implement the pep: http://pypi.python.org/pypi/pytest-rage
I like the idea of bottle a lot. I have a few suggestions: - I think the no-dependency approach (other than the standard lib) is a good idea, and desirable in many cases. However, no dependency should not be the same as 1-file-no-dependency. I'd remove the 1-file thingy. I think it limits your framework's progress. - Drop the thread local thingy. I've tinkered with a framework myself. Eventually, I concluded this thread local business was rather ugly. (Maybe I didn't do it right, but I did study Bottle and Flask extensively). - Incorporate more SQLite into the framework. SQLite came with Python, it's part of the standard lib; it fits the no-dependency agenda. And if you want to do something nontrivial, you will have to touch the database. I know Bottle has the SQLite plugin, but I think it should be dressed up more and made standard. 
Nice, I was looking to package an application of mine. But I don't see the dependencies issue referenced anywhere, for example, my application needs python 3 and pyqt installed. Am I able to specify dependencies and preferred version with this?
Google is sending this header: X-Frame-Options: SAMEORIGIN
Ah ha. Of course, I didn't think to look at the source of the site. Looks like they just embed the code.google.com content via an iframe, which now fails because of this header. Guess they should just switch to a redirect or proxy instead.
http://docs.python.org/library/functions.html#__import__ It's machinery used by the import statement, but it's a function, so you can use it to import modules whose names you don't know. It can be used for things like plugin systems, where you want to register modules by name and have the base program import them. Except it shouldn't be, really. You should use [importlib](http://pypi.python.org/pypi/importlib) (shipped w/ 3.1) for this type of thing instead.
That's pretty cool. My first Python program was formatting CSV files for work. It wasn't the coolest program, but I was proud of it.
Is there an easy to way to identify what kind of model features django would have problems with? * tables without primary keys? * primary keys that aren't named a certain way? * primary keys that are composite natural keys? * table names? * view names? * ? because certain problems (like col names) are easily fixed with views.
Because they all do everything equally well and evaluating a framework is like evaluating a painting - almost totally subjective? Or because you'll be happier in the long run if you first spend 6 months implementing your solution ten times before deciding which one to keep?
ok so that is how big shops with bad management work. Yep bad management is bad for everything.
well, how about uuids as primary keys instead of ints. composite primary keys(foreign keys). That's 2 things I recall being a little sketchy with djangos orm the last time i tried to use it. and if the django model now supports that, cool, but do all the delicious apps do that too including admin(which is really the value sell I was replying to)? I'm not bashing django by the way, if you already have your rant ready. The fact is that sometimes, your beloved tool is not the right tool for the job for everyone. sometimes it might make things harder than they need to be. this was my point. you shouldn't cry about someone being contrary to your world view. 
Came in to post this. This book is excellent.
Indeed but it was really a quick exercice to try websockets and for a colleague who didn't have access to the server
Nice. I just made one for Nose: https://github.com/wizzardx/nose-rage
Ouch, awful? I don't think it is as bad as make it sound. 
These are really good examples. Thanks for showing more optimal ways of writing the pure Python code (outside of vectorizing with numpy).
Thanks. This rocks!
Nice idea, but namespace package? staticmethods? this is kind of terribly implemented
There are lots of cases where python just doesn't fit the bill. For instance: installing/setting up dependencies in a cross (linux) platform way. How about quickly starting up other applications in a certain environment? Like setting up a jail? Or if you have data spread out over files? Running a batch job and want to commit to your local every 30 minutes? Yes I agree that bash is probably overused, but I don't think that it's as over used as you imply. 
i'm 28 and am trying to edit code that was given to me to suit my needs better. any chance you want to take out whatever the bug is, because i really have no idea what i am doing.
Not sure if Guido has them, but this happens a lot to people with allergies, and it's damn near impossible to avoid when your immune system is going nuts.
http://www.reddit.com/r/Python/comments/liaxt/alphaenumerate/c2t185n that reply is cleaner than my solution. I would suggest using izip though, as zip will create a full list copy in memory instead of just using generator syntax. Fixing it up would result in something like this (after importing itertools and string). def alpha_enum(iterable, string_list=string.ascii_uppercase): def alphagen(string_list): for i in itertools.count(1): for j in itertools.product(string_list, repeat=i): yield "".join(j) for i,j in itertools.izip(alphagen(string_list), iterable): yield i,j 
Guido var Rossum on designing a better programming language for users by sacrificing performance: &gt; Most code only gets run once, and then you find a bug and you fix it. [...] Sometimes you're successful and you run it on a thousand servers in parallel [but] most code doesn't get to that state... We can profile and optimize it later if we really have to, but most of the time it'll actually be fine. 
You don't actually need choice as a function parameter because raw_input accepts a choice from standard input. Try defining your menuChoice function without it def menuChoice(): ...etc. and also don't pass it any arguments when you call it.
Usually you will have `main` read the input, then pass that input to a series of functions to do the actual work, then write the output. You've got the important logic of validating the choice inside the `main` instead of inside `menuChoice`. Here's how I would write it: http://paste.pocoo.org/show/496389/ 
Yeah I played around with that a bit and got errors like this: Traceback (most recent call last): File ". . .lab7.py", line 124, in &lt;module&gt; main() File ". . .lab7.py", line 56, in main choice = menuChoice("Select an option (a, n, s, or o) ") TypeError: menuChoice() takes no arguments (1 given) 
Right. You've defined it as taking no arguments, but then you are providing it a single string argument of &gt;"Select an option (a, n, s, or o) " That line should be choice = menuChoice()
Guido on the reduce function: http://www.youtube.com/watch?feature=player_embedded&amp;v=ugqu10JV7dk#t=4766s &gt; The only purpose of reduce is to write really obfuscated cool code that shows how cool you are. Yeah, I'm just not that cool. 
LOL I was gonna go but I figured this would be on the Internetz. Here I am.
`choice.lower()` by itself doesn't change the existing value of `choice`. (Strings in Python are "immutable," meaning they always stay the same.) Instead it returns a value that you can use. What you want to do is `choice = choice.lower()`. It's like how if you did: x = 10 x / 2 Nothing would happen. You need to write `x = x / 2` to change the value of `x`. Same thing with `.lower()` on a string.
Good fixes. One more suggestion is to rename `menuChoice` to something more descriptive. I would write `normalize_input` or `validate_input` instead.
This is amazing so far...thank you so much 
Thanks for posting. This was genuinely very interesting and Guido seems like a classy guy especially when he started talking about the Perl guys.
A quick capsule summary of what contiguous ranges are and what the use cases for them are would be very handy.
It does help! Thanks AeroNotix :D I have to say that is how i feel. I do feel that i need to work on the basic's a bit more. I've burnt out many times in so many things so i now feel a little ashamed for doing it again lol Python is a great language and i actually get home after all day at work and want to spend a couple of hours reading/coding. Also BF3 is out soon so i know i'll have plenty of time and a good reason to chill out and take it a day at a time. Seriously dude, just what i wanted to read :D Thanks a million.
Thanks dude, I've been reading up on Django and Pyramid. Also on CherryPy and web2py. I picked web2py because it was one i can start playing with quickly and the documentation is awesome from what I've seen so far and doesn't feel like it has the learning curve that Django does. I'm still reading up on it all. It's just for prototyping for now. I did find Django amazing but it feels like it's not what i need just yet, like i might be adding complexity and the high learning curve isn't suited for just getting a site online and adding to it bit by bit. The class thing makes a lot of sense. It's just one of the things i've never needed to use personally so i was ignorant and never made an effort to learn. Thanks for all the advice dude. The explanation make it seem so obvious now. How easy and flexible it would make writing code :) 
Most likely a floating window that has no borders or a type of HUD?
No problem. When you crack a specific facet of the language it opens up so much more to you. I highly recommend *Learning Python* by Mark Lutz, *Learn Python The Hard Way* (free) and *Rapid GUI programming with Python and Qt* by Mark Summerfield (if you're interested in GUI programming).
maybe he smokes like a chimney ?
A common response to stress like public speaking is an adrenaline dump. One of the side effects of an adrenaline dump is a runny nose. Hence, throat clearing. 
Instead of : if choice == 's' or choice == 'n' or choice == 'o' or choice == 'a': print "valid menu choice" use: if choice in ('s','n','o','a'): print "valid menu choice" much nicer :)
Ahh I gotcha. I ended up finishing it up as well. I am trying as much as possible to refrain from changing the main program and simply define the functions. For example I have to write the next function. Parameters: String - the prompt to be displayed Returns: True if the user enters ‘yes’, otherwise returns False def confirm() Here's my main program without function. http://paste.pocoo.org/show/496389/
Python is for girls!
This doesn't seem like a good solution to me.. postdef funcs = [def(i) for i in range(10)] def make_incrementor(i): return lambda x: x + i Reading that, I see no connection at all between "funcs" and "incriminator". It took me a while to realise that the `def(i)` referred to the next function definition. Since there is no obvious link between the two, can I shove more lines after the `postdef` statement? Either that is a syntax error, or I could do something stupid like: postdef funcs = [def(i) for i in range(10)] print("This could be a few thousand lines of code") an_incrementor = funcs[0] an_incrementor(2) # Error, or.. something? def make_incrementor(i): return lambda x: x + i Regardless, I don't see how this is any better than the arguably slightly backwards: def make_incrementor(i): return lambda x: x + i funcs = [make_incrementor(i) for i in range(10)] I kind of like [PEP-3150](http://www.python.org/dev/peps/pep-3150/), it at least makes the connection between "using the callback" and defining it: sorted_list = sorted(original, key=sort_key) given: def sort_key(item): return item.attr1, item.attr2 In fact, the PEP directly addresses this: &gt; the only addition they have to make is to give the sorting criteria a name so that the usage can be linked up to the subsequent definition, also 
Ahh I gotcha. I ended up finishing it up as well. I am trying as much as possible to refrain from changing the main program and simply define the functions. For example I have to write the next function. Parameters: String - the prompt to be displayed Returns: True if the user enters ‘yes’, otherwise returns False def confirm() Here's my main program without function. http://paste.pocoo.org/show/496389/
interesting. . . Thank you!
Okay, so when you define the function, you need to specify a variable name for the parameter: def confirm(foobar): Where *foobar* should be the prompt to be displayed. Then inside of your function definition, you use that *foobar* as your raw_input prompt. I didn't want to write it all out because I think you'll get it on your own.
I've used different languages before but always given up before becoming proficient. Bash/shell is the exception but only because i spend 5 days a week in a terminal. Yet with Python i find it amazingly easy to write a working script with an actual use and not just following a tutorial. I do feel like i rushed a bit too much though. :D Thanks. I'm building up a reading list. I'll add they 3 you recommended and i'm sure they'll help. I tried to use Tkinter on windows but after a day with python, i didn't know how to use it correctly and have since moved on. I'll be sure to give it another look soon as i need a gui interface for one of my scripts. Does Qt run on windows? :/ 
Qt runs on everything. I generally find it a lot simpler to code with than Tkinter, and also Tkinter is quite an old tool and just looks kludgy alien half the time.
Thanks very much, jmoiron! 
You haven't stated what the problem is in your original post. If you got an error, tell us the error. If you got the wrong behavior, tell us what it does, what you expected it to do, and what you've tried (so we know how you're thinking). If it works but you don't understand why, give us some guidance so we don't have to explain functions from scratch.
Strange, for me it’s the exact opposite. `reduce` always does the same thing, so it’s really easy to understand. The same can not be said about a `for` loop. Maybe he suggested something else, YouTube didn’t skip to the right place for me I think.
Ok dude cool :) Thanks for the tips. It's now on my very long python task list lol :D Any other general recommendations? 
Fine, I'll rename to Guido and say it as if I was him, since he gets away with it, unlike me :)
What IDE are you using?
I think he is really thinking of scientific code -for which Python is an excellent choice by the way-. There are some other cases that don't fit the description such as big games or desktop software.
The current issue I'm having is writing a function to end a string with a period. I have a main() code that I can't change below. print str1 = "This is a sentence without a period at the end" str2 = "This is a sentence with a period at the end." str1 = endWithPeriod (str1) str2 = endWithPeriod (str2) print "The next two lines should be identical" print str1 print str2 A function named endWithPeriod(). This function returns a string that ends with a period. If the argument ends with a period return the argument from the function. If it doesn’t end with a period, return the argument with a period appended to the argument. The string returned from the function MUST end with a slash. Parameters: String to be evaluated Returns: The original string, guaranteed to end with a slash My main problem is understanding what to put in for parameters and how to get the function to work correctly. 
It gets better after a while.
thanks!
No worries! Hope you're getting as much out of it as I am.
Oh god, I have a midterm for this class Monday. Constraint programming is going to kill me. The tree stuff and algorithmic efficiency stuff is awesome, though. 
Relevant: [History of Python Blog](http://python-history.blogspot.com/)
Perfect! Thanks for the help. I'm working on my next function and still can't wrap my head around parameters. I cannot figure out how to add a period onto the end of a string if it is not there already. Here's my function so far. def endWithPeriod(x): if not x.endswith('.'): x = x.join(".") return The main program I don't want to change is here: str1 = "This is a sentence without a period at the end" str2 = "This is a sentence with a period at the end." str1 = endWithPeriod (str1) str2 = endWithPeriod (str2) print "The next two lines should be identical" print str1 print str2 
I just use notepad++ and vim depending on the desktop i'm on. IDLE if i need to test a bit of code quickly. Any tips?
1. Your `endWithPeriod` function doesn't return anything. It should return the new string with a period. 2. You also need to deal with the case that nothing changes. In that case, just return the same string back again.
I updated the blog post with some of feedback provided here. I provided credit to dalke for these examples. Let me know if I misrepresented any information. Or just general disgust :)
Can someone share a link to the paper one questioner was talking about, saying that "Python should not be used for large projects?" [Here's the link in the video where he says that.](https://www.youtube.com/watch?v=ugqu10JV7dk#t=1h43m46s) It sounds like Guido says the author's name is something like "Anthony B", but I'm not able to find it by googling.
Got it to work! One more for ya! I have a function a function named getIntWithinRange that only accepts a number between a min and max value. Parameters – A String (the prompt) and two Integers, the minimum and maximum value that will be accepted Returns – The value (between min and max inclusive) entered from the keyboard Here's what I have, but I don't know what to return back to the program. def getIntWithinRange(a, b): if a &lt; 40 or a &gt; 119: return a, b if a or b == 40: return And here's my program I don't wanna change: minVal = 40 maxVal = 119 print "the getIntWithinRange function will execute until the user enters a value between the min and max value.\nThe program will continue to accept integers until the user enters the min value,\nthen it will move on to the next function." while True: userEntered = input("Enter an integer between " + str(minVal) + " and " + str(maxVal) + ": ") value = getIntWithinRange(minVal, maxVal) if value &lt; minVal or value &gt; maxVal: print "getIntWithinRange isn't working - it accepted ", value if value == minVal: break 
You're somewhat confused. Try this general form: def get_something_within_bounds(prompt1, minimum, maximum): while True: v = input(prompt1) if v in range(minimum, maximum): return v print "Sorry, value not allowed" Later in the rest of the code: v = get_something_within_bounds("Please enter a value between 1 and 3", 1, 3) 
The variables in the function can come from three places. They can be global (or non-local), which is when the variable name is referring to a variable from outside the function. Global variables are one way of making some data available to your entire program. x = 3 def foo(): print(x) foo() # prints 3 print(x) # also prints 3 They can be local, which is when the variable exists only inside the function. This is used for temporary values. def foo(): x = 3 print(x) foo() # prints 3 print(x) # error, no variable named "x" Or they can be parameters, which are local variables that get their value from the caller of the function. def foo(x): print(x) foo(3) # prints 3 print(x) # error, no variable named "x" Generally, unless there's good reason to make something global, parameters are the preferred way to pass information into a function. and return values are the way to get information back out. It looks like you already got help on this problem, so I won't go into detail on a solution here. But I just want to say that you have a clear statement of the problem, and in fact you've already said what the parameter(s) should be. (BTW, if you ever need to assign to a global variable from inside a function in Python, make sure to read up on the "global" statement or you'll get the wrong result.)
I'd like to caution you that the way you're asking for help isn't the most productive way to understand the material. You've told us what the requirements are, and you've given us some code you tried, but you should talk more about why you think what you wrote should or should not work. That said, it looks like there's some disagreement between the problem statement and the part of the program you're given that calls the `getIntWithinRange` function. You said it takes in three parameters, but it's only defined with two, `a` and `b`, and it's only called with two (`minVal` and `maxVal`). You also said that `getIntWithinRange` takes in a value from the keyboard (using `input`) but this looks like it's already done outside the function, by the `userEntered = ...` line. In any case, `getIntWithinRange` should not refer to the values "40" or "119", because it should work no matter what min and max the caller wants to use. It should get the values that it uses in its logic from `a` and `b` instead.
I'm sorry, like I said I'm doing my best to start out here and I really do appreciate your help. I see what you're saying about the function asking for three parameters. and I guess that is my main problem. Defining the function. I corrected the main program and it is supposed to read like this: minVal = 40 maxVal = 119 print "the getIntWithinRange function will execute until the user enters a value between the min and max value. The program will continue to accept integers until the user enters the min value,\nthen it will move on to the next function." while True: value = getIntWithinRange("Enter an integer between " + str(minVal) + " and " + str(maxVal), minVal, maxVal) if value &lt; minVal or value &gt; maxVal: print "getIntWithinRange isn't working - it accepted ", value if value == minVal: break Now that I have my function written as def getIntWithinRange(prompt, minVal, maxVal): while True: v = input(prompt) if v in range(minVal, maxVal): return v 
That main program looks better now. And the function too. Note that `range(minVal, maxVal)` goes up to `maxVal - 1`, so if you want to include `maxVal` it should be `range(minVal, maxVal + 1)`. The parameters are correct, both where you're calling the function and in the function definition. The return is correct too. Without actually testing the code myself, this looks fine. It can be a little hard to conceptualize what a function does for a toy problem like this, but it gets easier when you see more examples. Basically, just remember that a function is supposed to encapsulate some frequently used piece of code, so that it can do the same thing in slightly different ways depending on what the parameters are and possibly when it is called. In this case, what you have done is provided a function that's able to request input from the user, and repeatedly nag them for better input if it's not within the given range. Everything else, the stuff in the main section like that other While loop, are just there to test whether you've provided this service correctly.
 This function isn't well defined. What is supposed to happen if the string is out of bounds? Should it return some default value? Should it throw an exception (I'm guessing you haven't been taught about that yet)? Putting that aside for now, just look at the parameters list: "A String (the prompt) and two Integers, the minimum and maximum value that will be accepted." If you're told that, then your function declaration needs to be something like def getIntWithinRange(thePrompt, minVal, maxVal): You're also told it returns "The value (between min and max inclusive) entered from the keyboard." So, you need to have something like `return value` somewhere in your function. But as I wrote above, that cannot be the only possible return value, since you also need to deal with the case that the value is out of range. If I had to put my finger on why the concept of functions seems difficult for you, I would say it's that so far all the functions you've been asked to make have been a waste of time. They aren't going to be reused and they could easily be put in line with the program as is. So, you find yourself thinking, "What is a function and why do I even need to use one here?" The core point of a function is to take one set of values and transform them into another. So, for example, Python comes with two built in ways to do exponents. You can write `5 ** 2` for five squared, or you can write `pow(5, 2)`. But what if Python didn't have a built in way of doing exponents? Let's start by thinking about how we'd do squared. Let's say I already have `x = 5`. Then next I'd want to write `x = x * x` and that would give me x squared. That's fine for squaring, because squaring is pretty simple, but what about more complicated operations? For cubed, I need to write `x = x * x * x`. A bit more of a pain. And going past the fourth power it's going to be hard to just eyeball the code and see if it's right or not. OK, here is a great place for a function! def square(n): n_squared = n * n return n_squared Now, I can reuse this multiple times: x = 5 x_squared = square(x) y = 11 y_squared = square(y) z = 103 z_squared = square(z) OK, let's think about the more general use case. What if I want to be able to not just square, but do any integral exponent? My requirements will be something like: Parameters: number to multiply and number of times to multiply it Returns: number to the power of the other number I can whip up a quick function to do this. def power(x, n): result = 1 for _ in range(n): #using _ as a variable name because I don't care about it result = result * x return result And test it out on the interactive prompt: &gt;&gt;&gt; power(5, 2) #Five squared 25 &gt;&gt;&gt; power(10, 1) #Ten to the first 10 &gt;&gt;&gt; power(100, 0) #One hundred to the zeroth 1 &gt;&gt;&gt; power(10, 3) #Ten to the third 1000 Of course, this program isn't perfect. It has buggy responses to floating point numbers and negative numbers: &gt;&gt;&gt; power(2, -1) #Should be 1/2 1 But it is a useful and reusable way of dealing with numbers. If I had a bunch of numbers and I wanted to get different powers for each of them, I would only have to write `power(one_number, the_other)` to get it done. I wouldn't have to write 5 loops to solve 5 problems. I have the one function and I call it 5 times. To give another example, in math class you learn how to solve a quadratic equation. The formula is ax^2 + bx + c = 0 means -b +/- squareroot(b^2 - 4ac ) / 2a. Here we have a case with three inputs and potentially two outputs. Let's make a function for it. (Note that `x **.5` can be used for square rooting in Python.) Parameters: a, b, and c Returns: the two quadratic roots def quadratic(a, b, c): inside_square = (b * b) - 4 * a * c positive_result = (-b + inside_square ** .5)/ (2 * a) negative_result = (-b - inside_square ** .5)/ (2 * a) return positive_result, negative_result And test it interactively: &gt;&gt;&gt; quadratic(1, -2, 1) (1.0, 1.0) &gt;&gt;&gt; quadratic(2, 0, -4) (1.4142135623730951, -1.4142135623730951) &gt;&gt;&gt; quadratic(4, 0, -4) (1.0, -1.0) &gt;&gt;&gt; quadratic(9, 6, -3) (0.3333333333333333, -1.0) &gt;&gt;&gt; quadratic(1, 0, -1) (1.0, -1.0) So, using this I can easily tell that x^2 -2x + 1 is equal to (x - 1)^2, etc., etc. without having to rewrite the whole logic of my function over and over again. It was tricky enough to get right once! That's the point of functions: to take some task you're going to do repeatedly and break it down into expected inputs and outputs. Using functions for these kinds of fake restaurant menus makes for easy class assignments, but it sort of obscures the whole point of why you would ever want to write function. It's to have easily reusable logic.
You're only passing in the min and max val into "getIntWithinRange", so you really can't return the value. One thing that would work would be to take in the minVal, maxVal, and valueEntered. Then do something like: def getIntWithinRange(minVal, maxVal, userEntered): # if the value is too small, return minimum. if userEntered &lt; minVal: return minVal # if the value is too big, return the maximum. if userEntered &gt; maxVal: return maxVal # Otherwise, we are in range - just return the user's value. return userEntered This returns the value if it's within range, or a value closest to it that is. Some more general advice, you generally want to make variables and method names separated by underscores - like "get_int_within_range" instead of camelCase like you're doing. 
Yeah it's a whole learning process, as I'm sure you know. But I think I get the general idea now, programmers don't like to repeat things and functions are an efficient way to solve that problem. Thank your for your help and patience! 
Guido has been [on the record against `reduce`](http://www.artima.com/weblogs/viewpost.jsp?thread=98196) for a while: &gt; So now reduce(). This is actually the one I've always hated most, because, apart from a few examples involving + or *, almost every time I see a reduce() call with a non-trivial function argument, I need to grab pen and paper to diagram what's actually being fed into that function before I understand what the reduce() is supposed to do. So in my mind, the applicability of reduce() is pretty much limited to associative operators, and in all other cases it's better to write out the accumulation loop explicitly. So, his view can be summarized as "`sum` is OK, but other uses for `reduce` are too confusing to read." I tend to agree.
Even most big game software only gets run a couple times… _during the development cycle_. I think that's what he's talking about. All the alphas and betas are only going to be used a couple times for testing, so it's more important to be able to get the next incremental improvement ready than it is to be blazing fast at every stage of development.
I think the same thing can be accomplished by using the select module. As a bonus it doesn't require any sort of polling. 
To the best of my knowledge, on windows you have to invoke the interpreter explicitly. l.e., python ex12.py first 2nd 3rd Also /r/learnpython is a better venue for these types of questions.
I tried doing that too, but it ended up just saying another error, for whatever reason. python: can't open file 'ex12.py': [Errno 2] No such file or directory. However, when I just type "ex12.py first 2nd 3rd", it opens. Also, sorry, didn't think about posting this there.
You might want to double check your path variable. "C:\Python27/ex12.py" has a backslash and forward slash, so maybe you have a wrong slash in there.
Thanks for pointing that out. I just fixed that, but I'm still getting the same error. :\
No, you don't have to. The Python installer sets the file associations so you can run the scripts just as you would do with executables.
Sounds like this is a problem regarding the environment variables and the file associations. I'd recommend you uninstall everything and install it back again. The installer should set up everything to work out of the box.
The standard install associates a Python.File type with .py files. It's configured to run the interpreter and pass the command-line arguments (check `ftype Python.File`). So one can open a console by running `cmd`, navigate to the script directory, and run the file directly, e.g. by entering `ex12.py 1st 2nd 3rd`.
Sounds like you also have 3 installed Put the following in a new test script : import sys print (sys.version) And run it
Updated description. Thanks guys. :)
From the sounds of things you are in the wrong directory. Open CMD &gt; cd c:\python27 &gt; python ex12.py What happens when you do that? Another thing to try would be to open CMD, and just type "python". It should launch and tell you what version you are running.
Set a value in the Worker class and then use it: def create(self): self.worker.setTask(CREATE); self.worker.start() (Define `setTask` inside Worker however you feel like it.) Depending how many tasks you think you'll fire off, you may even want to make a producer/consumer setup where you stick Task objects in a queue and the Workers pull them out and processes them.
Thanks, this worked as well. I actually ended up doing a similar thing, defining a task variable in the __init__ f parameter, and then figuring out what it was. 
There's a lot of code out there that isn't scientific and isn't games. Eg websites, dropbox client, maintenance scripts, and much more. I wonder if someone has an infographic with statistics on this....
Just being curious, is distribute better than pip? I mean i can do that with pip too, pip install -r requirements.txt.
Well, TIL that Zed was the guy behind Mongrel. I always thought it was a part of RoR. Now I understand where he is coming from
The license is actually called the **GNU** GPL. It's the license of the GNU project. As the author of something it is *your right* to chose it for *your code*. But that doesn't forbid others to comment on that choice. Especially if the primary goal of the license is to constrain the licensing choice for code that is *not yours*.
Fuck. I agree with Zed.
Every post that's by or about Zed Shaw, there are Redditors basically saying "fucking Zed Shaw, what a jerk". What's the backstory here?
Haters gonna hate, probably
RMS strikes again! He's like the crazy weirdo sooth sayer that no one seems to believe and yet he keeps getting it right...maybe we should pay more attention to the guy.
He's argumentative, loud, brash, arrogant and very clever. The first four of these tend to annoy people and lead them to ignore the fifth. 
Exactly. There's a big difference between: "I FORBID you in the name of all the powers of the universe" and "You do know you're being a jerk asking for that?".
Well, depending on your proficiency with Vim I wouldn't have much to say. Notepad++ is good when you get it setup with the Pyton install, rather than just using it as an editor, you can get a 'push to run' button and other small niceties. I recommend PyScripter for a nice all-in-one IDE, though.
As someone who recently started a VC-backed startup building software using open source technologies, I feel insulted. I am incredibly grateful for those that built the technologies we used and licensed them in such a way that we can use them. We make no attempt to hide the tech we use. He seems to be under the impression that if the company doesn't directly give back (which you will only rarely see from a VC-backed startup), then there is no give back to open-source. That is absurd. Once my company is done I will continue developing. I will most certainly start open source projects / contribute to open source. I have had so many positive experiences with open source that I personally want to give back. I'll just avoid GPL like the plague.
If you look at the most successive open source projects, a lot of them are MIT or BSD. The problem with most open source projects is not that people take advantage of it commercially, but that no one gives a shit about it and it is never used. When you slap GPL on something, basically you're saying, please let me give your project a huge liability when you use it. Mongrel made Zed famous, lamson, no one ever fucking uses or heard of. I think he proved his own point. I got mad respect for Zed Shaw though. 
As a Zed hater, I am relieved to say I disagree with this article. :-) It seems to me that his main point is, "You work really hard on a project in order to become famous, but without GPL you won't get credit for your work." This is wrong on two counts. First, people who really care aren't busting their asses for fame. They are busting ass in order to make the world a better place through their work. Fame, if it comes at all, should be just a side effect. Second, GPL or not makes little difference to whether you get fame. Talent will out with or without it.
&gt; Mongrel made Zed famous, lamson, no one ever fucking uses or heard of. I think he proved his own point. Yep. I'd never heard of Lamson before this article, either. And Zed's approach in this article is doing nothing but turning people off. I understand why he's angry, but the name-calling and lumping everyone together into the same bucket is a mistake, and just makes him look like an ass. :(
My software, it's in X, Y, Z. That's why you should employ me.
Because all people who rant about themselves using the GPL are RMS.
GNU/GPL
How come these releases aren't published on their website?
He calls everyone names and he's mostly right.
See? His point exactly. You probably missed the whole [Rails is a ghetto](http://web.archive.org/web/20080103072111/http://www.zedshaw.com/rants/rails_is_a_ghetto.html) fun.
Does it actually work for you, or are you theorizing on what should work for people who work on open source projects?
To be fair, I came to the Rails party fairly recently and only because my currently employer uses it. For what it's worth, I'm meant to be teaching myself Ruby for work but keep on coming back to Python and Django. The language agrees with me more :)
I guess people didn't see the shirt Guido was wearing then...
The article is at least [831 days old](http://news.ycombinator.com/item?id=703086). Both Lamson and Mongrel2 are now BSD licensed.
Problem is no one wants to hire raging assholes, no matter how smart they are. That's why you need to make up bullshit about licensing.
That's not really what I got out of it at all. What exactly did he say that made you think this was about being famous?
When I realized I agreed with Richard Stallman, I didn't know what I was getting in to: Suddenly I was expected to defend all the crazy batshit insane coming out of, and going in to that guys mouth.
How about [Bottle](http://bottlepy.org/docs/dev/)? It runs with Python 2.5+ and 3.x (using 2to3).
Why is this not the top comment?
There could be some advantages for using Distribute. For example, your app becomes a Python package, though web applications have not to be Python packages in most cases. In our case: - The main logic/model modules are packaged with Distribute. It can be `import`ed and used independently from web application. (For example, you can `import` some persistence data types in the batch job.) It is deployed to multiple instances using `setup.py sdist`. - There are several other modules for monitor/maintenance jobs. These modules are depends on the above package. These dependencies can be specified by `install_requires` or requirements.txt as well. Anyway the important thing is that the module packaged by `distutils`/Distribute can be specified as a dependency by another Python packages. Conclusion: use the right tool that is comfortable for you.
har! I thought the article was so spot-on too :(
Web programming with Python 3.0 seems still painful. It could disappoint you, but read [Armin Ronacher’s article][1] about it. [1]: http://lucumr.pocoo.org/2010/5/25/wsgi-on-python-3/
My only complaint is that it's not made for python 3, but after learning a lot of the differences I've been able to adapt.
Zed. I agree 100%.
Using range in this case is hopelessly inefficient. All you need are two comparisons.
I think it's because they are in the process of migrating and probably missed that one.
Reading the Python documentation on these functions will probably be helpful: * open() * len() * split()
I tried for a long time to learn RoR, but I don't like the syntax. I prefer python
I took the opposite away from the article. I'd never heard of Lamson before, but it looks badass. I'd try it out myself if the source download webpage didn't crash on me ;)
CherryPy works on Python3 out of the box. http://cherrypy.org/
I got bored reading this article (again; I read it when he wrote it). I don't really 'get' this obsession with someone knowing who wrote Mongrel. I guess on a personal basis it's a big deal to him and his employability, though to be honest if I'd gone into my last job interview and could say "I wrote the webserver for Ruby on Rails" I'd have been offered the job on the spot. Personally, I use the GPL because of my beliefs. I don't think I've produced anything interesting enough for anyone to care what license I use, but one day, when I do, it will still be GPL, and no amount of whining from other people will change my opinion. I simply don't care that corporate entities find it scary. Ultimately I agree with Zed in a very big way on the first part of his essay; it's the developer's choice, and I don't think anyone has the right to complain that the license makes things awkward for them. Don't use it. Or remove your invented restrictions. Before I'm criticised for my lack of pragmatism, I should probably point out that I do work and have worked at large IT companies and still have no fucking sympathy for this corporate selfishness.
The GPL is easy to comply with, if you modify the source publish it. How hard is it to host a repo with all the code you use? You get to use the software and then you release the source. It is the dickholes that want to use the code modify it and not release the source code that create any liabilities. As for the GPL I would say it was instrumental in the commercialization and adoption of the Linux Kernel because you could invest in contributing to the Kernel as well as all competitors, you can benefit from their code and vise versa in the process the Kernel as a whole gets more and more contributions. 
* Mongrel2 is BSD https://github.com/zedshaw/mongrel2/blob/master/LICENSE * Lamson is dual-licensed https://github.com/zedshaw/lamson/blob/master/LICENSE
Just "return sum(pos), sum(neg)". sum is a builtin function that returns the sum of all items in a sequence, roughly the same as: def sum(squence, start=0): s = start for i in sequence: s += i return s But why don't you just store two variables and add them: pos, neg = 0, 0 for i in accontlst: if i &gt; 0: pos += i else: neg += i return pos, neg Or you can try another ways, this one-liner iterates two times but looks good: (sum(i for i in accountlst if i &gt; 0), sum(i for i in accountlist if i &lt; 0)) Or, this iterates the list one time, but a little longer: tuple(sum(i[1]) for i in itertools.groupby(sorted(accounts, reverse=True), key=lambda i: i&lt;0)) 
[Tornado](http://www.tornadoweb.org/) is mostly Python-3-compatible now, and it is very lightweight (inspired by WebPy). I love it, but it has a learning curve which can be attributed to its asynchronous layout.
Also, it rocks!
I love honest trolls. 
&gt; If you look at the most successive(sic) open source projects, a lot of them are MIT or BSD. O RLY? gcc? The Linux kernel? Emacs? libreadline? All incredibly minor projects that nobody uses. I typically slap a BSD license on anything I write but saying this is true of a majority of the "most successful" open source projects is simply asinine.
&gt; x = x.join(".") I do a lot of lab supervision in programming courses. I have many students like you, and I have only one advice: Learn to use documentation! It doesn't work to just write something and tweak it until it works. Everything is clearly defined and designed in a way that you can understand how it all fits together as a concept. Read and gain understanding and your programming skills ans productivity will go upp by two orders of magnitude.
He has a pretty nice job right now. It's worth noting that he used to work in investment banking when he was in NYC so he picks his jobs based more on how interesting they are than anything else. He's one of the nicest people I know. Don't mistake the internet persona for how he is to work with.
Why *not* go GPL? Exhibit A: MySQL. The GPL gives the copyright holder more rights than everyone else. When development is mostly funded by a single entity who retains all of the copyright (so that they can sell non-GPL licenses to others, as Zed advocates in this article), and then they get bought by Oracle... well, that sucks. Also, in order to operate that dual-licensing business model, you must require volunteer contributors to assign their copyright to the company (so that the company can sell the non-GPL license). I think the GPL has had a mostly positive effect on the world, but now that I am being paid to write free software (: a recent development for me :) I am very glad that our code is MIT licensed. It doesn't matter who ends up owning the copyright on my code in the future, because I have licensed it to myself and the world under a completely non-restrictive license. I am glad to see that after Zed wrote this, he changed his mind and BSD licensed his code. Is there a blog post where he explains his rationale for that?
Zed basically trolled reddit a while back. He wrote a blog post on it but I can't find it.
yeah no joke huh, not very friendly here
***@Py3K_update*** *Twitter Profile:* &gt;***Python 3000 updates*** &gt;[*wilsonericn.wordpress.com*](http://wilsonericn.wordpress.com 'url unshortened via longurlplease.com, images rehosted by imgur.com') &gt; &gt;User since: *2011/08/11* &gt; &gt;Location: *No location set.* &gt; &gt;*Sends updates regarding Python libraries that are Python 3 compatible. Data comes from [python3wos.appspot.com](http://python3wos.appspot.com/ 'url unshortened via longurlplease.com, images rehosted by imgur.com').* &gt; &gt;Friends: **1** Followers: **21** Listed: **0** Tweets: **6** *Last tweet/conversation (at time of this comment):* ***Py3K_update***: &gt;&amp;#91;2011/10/17&amp;#93;&amp;#91;09:15:29&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|Beaker now supports Python 3 'google translate this tweet'): Beaker now supports Python 3 [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/Python/comments/lmh9r\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
I'm guessing that's Anthony Baxter, I haven't watched the video though.
Actually, this bug is kind of a show stopper for me: http://www.cherrypy.org/ticket/1087 tl;dr CherryPy does not conform to the Python 3 WSGI specification (PEP-3333) yet.
I haven't actually used either of these, but looking at the numpy docs it appears the genfromtxt() function could be used instead. It has a both skip_header and skip_footer parameters you can set. Hope this helps.. http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
hatchlings suggestion is far better, but you could also just set up a loop set to terminate before the last line. Not the best form, but it would work. I used to do it for getting data out of protein data bank files all the time (which have a pretty similar format, from the sound of it). Ninja Edit: Grammar.
&gt; The GPL is easy to comply with, if you modify the source publish it. That's pretty much the only requirement for the **L**GPL, but not the GPL. For GPL, if you distribute anything that *links* to GPL-licensed code, then you have to release all parts of the program as GPL-licensed code (or compatible license). 
I find it comical that of 24,682 subscribers, the only comment is from a bot.
Semi-related: the bot is written in py3k :)
Aaaaand, we come full-circle. `[pypy_logo.jpg]`
The comment you quoted wasn't made by me. That said, there are workarounds, i.e. I've heard of people writing a (GPLed) wrapper that exposes a socket interface listening only on localhost, then communicating with the library (in a separate process) through the socket. The other "workaround" is to offer the author(s) money to license their copyright under different terms. Personally, I don't know why people see this as different to licensing clips from a movie, chapters from a book or samples from the song: just because the necessary material is "out there" doesn't mean you're entitled to do whatever you want with it without the author's consent.
&gt; How hard is it to host a repo with all the code you use? It can be a substantial intellectual property hit if 1% of your codebase derives from GPL code and that forces the other 99% to be released. That said, if that 1% is so important, I agree with Zed: fucking pay for it. &gt; As for the GPL I would say it was instrumental in the commercialization and adoption of the Linux Kernel because you could invest in contributing to the Kernel as well as all competitors, you can benefit from their code and vise versa in the process the Kernel as a whole gets more and more contributions. Except there have been countless cases of people being exposed as using the kernel in non-compliance with the GPL, and probably thousands more such unreported cases.
I was vaguely alluding to the fact that Zed should've listened to RMS in the first place. I am well aware that Zed != RMS.
 def getChoice(prompt): foobar = raw_input(prompt).lower() if not foobar in ('a', 'n', 's', 'o'): print "Invalid choice [%s]" % foobar return getChoice(prompt) # ask again return foobar You don't need to pass choice to your function if you're going to be assigning it, then returning it. usage of my function: ni = getChoice("Enter a menu item: ") if the choice is invalid, it should ask again until it is, then it'll return the valid choice. I didn't try running this, but you can also do a while loop if it doesn't recurse like I think it will (Way to lazy to IDLE this.) def getChoice(prompt): ch = raw_input(prompt).lower() # get lowercase input while ch is not in ('a', 'n', 's', 'o'): # this won't run if choice is valid. print "Invalid choice [%s]" % ch # let 'em know that their choice was invalid. ch = raw_input(prompt).lower # Keep on askin' return ch 
Oops. Anyway, I'm not commenting on whether it's good or bad, I just wanted to make sure that people know what it really takes to comply with the GPL. 
iirc the only two ways you can make a global in Python are: x = 3 def foo(): global x print x # 2.x style _________________________________ and X = 3 def foo(): print X which may be unpythonic but I use this over the former option. 
I use 3k mostly, but I doubt the rule is different in 2.x. You only need the global declaration in the function if you're assigning to the global (i.e. overwriting its binding) within the function. It doesn't matter if you have previously read from the variable earlier in the function. The fact that you're assigning ordinarily makes Python interpret it as a local variable, and a `global` prior to its first assignment is needed to say otherwise.
&gt; The GPL is easy to comply with, if you modify the source publish it. I think that's incorrect. If you modify the source, *and you distribute your modified version*, then you must publish the source. But if you modify GPL'd software, and use it, and not re-distribute it, there's no need to share your changes. 
Zed, why did you change Lamson's licence from GPLv3 to dual-licensed BSD/GPLv3? 
depending on how you need this to work, I would suggest something like itertools.compress(text, itertools.cycle([1,1,0,0])) I think it makes what you are doing much clearer. You can treat that object the same way that you treat a list, so `''.join(...)` will work fine to produce your output. While the above answer looks fine, you end up putting a lot of logic in to a small space. To me, the response reads: &gt; Skipping every four elements until the end of the list, append the first two of the set to your temporary variable. whereas I think my response, once you look up what compress and cycle do, &gt; reads keep every other pair. It looks like the completion times are close locally: //python3.1 -m timeit -s "from itertools import compress, cycle" -s "line_2 = '480045004C005000' * 1000" "''.join(compress(line_2, cycle([1,1,0,0])))" 1000 loops, best of 3: 1.14 msec per loop //python3.1 -m timeit -s "line_2 = '480045004C005000' * 1000" "''.join([line_2[i:i+2] for i in range(0,len(line_2),4)])" 1000 loops, best of 3: 1.52 msec per loop
Yep. I am looking forward to Pyramid in Python 3. Looks like it will be ready soon.
I stand corrected, and learnt :)
checkout "Web micro-framework battle - Richard Jones " http://www.youtube.com/watch?v=AYjPIMe0BhA
An excellent TL;DR of his article as well: &gt; Lamson is licensed BSD or GPLv3, whichever you want. This basically means you shitheads who like using software without giving credit can go on being leeches on the world and tell everyone that you're fucking brilliant and invented all the gear running your shitty little company when really you just borrowed shit from real creators like me. Fuck you very much.
I hate to be so negative, but reading directly from disk (i.e. opening the source code file directly from disk) is typically not considered quine behavior. Allowing a program to read it's own source code from disk results in a trivial solution (in fact, your code is that solution). I encourage you to first try to write a python program that is a real quine without reading itself from disk. Then try to tackle making it work in general, if it can be done ;)
You are correct. This is not typically considered quine behavior and does not fit the spirit of the definition, or intent, of a quine.
&gt; Why not go GPL? Exhibit A: MySQL. How is this solved by BSD? &gt; The GPL gives the copyright holder more rights than everyone else. When development is mostly funded by a single entity who retains all of the copyright (so that they can sell non-GPL licenses to others, as Zed advocates in this article), and then they get bought by Oracle... well, that sucks. Do you think somehow by using a BSD-license code you own the copyright? The copyright still belong to the original author. They merely licensed you it to you implicitly. Do you understand the difference between copyright and license?
Ask Linus and Theo where they are working at now. Companies hire talented people regardless of their ego/attitude.
Those are older projects and I'm thankful that they exist. For newer projects such as Jquery, Rails, and Django the modern developer has moved towards a more open mindset rather than a defensive mindset.
Hmm, I guess it would have to be the &lt;h2&gt; that contained "I Don’t Want To Be Ignored Again." ;-) Look what he says under that, &gt;Sadly, none of Mongrel’s success mattered for me. Even though everyone was using my software, the vast majority of firms using Mongrel were startups. The last thing a startup wants to admit is that they don’t own their intellectual property. They want everyone, especially the VCs and investors, to believe that they’re all geniuses who “innovated” everything they run. &gt; &gt; When I looked around, companies had no problem admitting they used Ruby on Rails, hell that probably got them their funding. What I didn’t see was them saying they used anything else, which meant that when I would try to get work, it was impossible for me to explain the magnitude of Mongrel’s impact. To them it was just some simple web server that their system administrator had to use, “RoR” was the real money maker. He's bitching that people used his software but don't kiss his ass about it. It's incredibly petty of him, and it shows that his focus is in the wrong place. A great engineer gets a feeling of reward from being invisible—being so good no one notices that you're even doing anything. &gt; After Mongrel I almost need companies to have to admit they use my software. I would actually rather nobody use my software than be in a situation where everyone is using my gear and nobody is admitting it. That's the exact opposite of the right attitude. Do you think Jonny Ive is losing sleep at night because people think Steve Jobs designed the iPod and not him? Of course, I'm just some jerk on the internet making snide comments, but I really do think that a less egotistical person would have reservations about posting something as self-centered as that.
You could do it the crafty way, using a list comprehension and Python's handy negative indexes... f = open('whateverfile.txt', 'r') data = [float(line.split(",")) for line in f.readlines()[1:-1]] # assuming the columns are comma-delimited data = numpy.array(data) 
Because many of us asked for that license change. I could not use Lamson before that and ultimately I think it's in the interest of the developer that his software is used.
&gt; How is this solved by BSD? By not giving the copyright holder special rights. &gt; Do you think somehow by using a BSD-license code you own the copyright? Nobody said that, but in regards to practical use of the license everybody is equal. There is not a lot I can do as a copyright holder that I cannot do as anyone else with a BSD licensed project.
&gt; By not giving the copyright holder special rights. What the fuck? Copyright holder for a BSD project still have special rights. They are call copyright. Do you even understand what copyright is? Every single source code has copyright. It means you cannot reproduce, manipulated, distribute the source code without the explicit permission from the author. Licences like GPL and BSD, MIT, Creative Commons gives you *permission* to *modify* and *distribute*. The differences GPL and BSD lies in the conditions of the licences. If you violate those conditions, you can be taken to court on copyright infringement. &gt; everybody is equal. There is not a lot I can do as a copyright holder that I cannot do as anyone else with a BSD licensed project. I think you seriously live in imagination land. Go and do some research about copyright and licences to clear your terrible misconception about BSD being more "equal". 
&gt; What the fuck? Copyright holder for a BSD project still have special rights. They are call copyright. Do you even understand what copyright is? Yes. As I said, the copyright holder is not special in regards to what the license says. The three clause BSD license restricts the following things from a person using the licensed content: * do not remove the license * do not remove the copyrights * put the license text into the documentation for binary distributions * do not use the copyright holders for endorsements The only right that the copyright holder has that you do not have is a) changing the license in a way that is BSD incompatible, b) removing the copyright information, c) not putting the license text into the documentation, d) using the copyright holders names for endorsements. All of which are quite benign unlike the restrictions that the GPL adds. So if MySQL for instance was BSD and not GPL nothing would have changed for people no longer employed by Oracle in regards to what they can do with MySQL. They would still be able to extend it in any way possible by giving their clients as much or as little possibility with regards to plugins, further restricting the license etc. Since however MySQL is GPL licensed they current maintainers of forks are entirely unable to monetize this project by selling commercial extensions. That is not possible unless they are the copyright holders. Also it now means that they are unable to let users use their databases in commercial projects that cannot use the GPL due to the fact that their client code is GPL as well. Drizzle started a whole new client library based on an old BSD version of the mysql client library because of this.
I would just ignore any line that doesn't look like 2 columns of floats. That way it doesn't matter if you have headers, footers, comments or nuffin! for line in open('example.txt'): try: f1, f2 = map(float, line.split()) print f1, f2 except ValueError: pass 
Also look at [the fileinput module](http://docs.python.org/library/fileinput.html), it makes reading many files a little simpler.
I believe that [Aspen](http://aspen.io/) runs on Python 3. Also, it is a hoot to work with.
One thing is it is actually generally discouraged to inherit from QThread. Yes some Qt versions require it but they see that as a design mistake. http://labs.qt.nokia.com/2010/06/17/youre-doing-it-wrong/ For compatibility reason I keep one class around that inherits from QThread. https://github.com/epage/PythonUtils/blob/master/util/qore_utils.py I really like the solution I created for this. It works by creating a thread and using a signal to the background thread to have it run a function and a signal to the UI thread to do the clean up processing. Besides making it easy to call functions in a different thread it allows you to mix UI thread pre-processing / post-processing without breaking your logic up across callbacks. For an example https://github.com/epage/PythonUtils/blob/master/qt_error_display.py _on_background queues up a task to be run. _call_into_background runs all logic in the UI thread but whatever it yields (function call, positional arguments, keyword arguments) is run in the background thread. I use this in a Google Voice application so that all of my session logic / network traffic happens in a background thread while keeping the calling logic very simple.
Working on it... sit tight.
Yayy! After seeing those downvotes i had actually lost my hope. But you made my day! Thanks a lot in advance!
I'm doing it in html/javascript... I hope that's ok.
Of course!
Ok, it's done. Let me upload it somewhere.
[here you go](http://jsfiddle.net/q8VFs/2/) Every 20 clicks it switches between 0.1 second delay and no delay (starting with now delay). In all cases, it shows the flash for 200ms then shows the next ellipse. You can play with things in jsfiddle and click run again if you want it to behave differently. It works best in chrome. It looks like there's a jsfiddle bug that prevents it from working in firefox (raphael.js the svg library isn't loaded). It works in safari, but it doesn't fill the whole part of the jsfiddle window. Be sure to [resize the jsfiddle windows](http://i.imgur.com/3G6Tt.png) then press run again for more space. If you PM me your email I can email you the files (and then it will work in all the browsers and you can have it take the full browser window).
Yay, can wait!
I've used something similar, and it doesn't seem like the best tool for finding bottlenecks IMO. I'm still waiting for someone who understands these statistics to make something like [Devel::NYTProf](http://search.cpan.org/~timb/Devel-NYTProf-4.06/lib/Devel/NYTProf.pm) for python.
Aww yeah, THANKS A LOT!! I actually always use google chrome so it works wonderful. Thank you again! I'm glad that there are people like you in the world! 
What sort of time commitment are you looking for on the part of the mentor? Just code review and stuff? Emails about broader philosophies? Real-time conversations? Do you have work in mind (and just need someone to review it), or are you looking for things to do? Can you provide some examples of the stuff you've done, and/or things that you've seen others do that made you realize you weren't up to the skill level you desire? I'm no expert, but I am comfortable with the language and generally know the Pythonic way to do things. Depending on your answers to the above questions, I'd be willing to do this.
I don't know Devel::NYTProf. Why is it so great?
Glad I could help. It really wasn't too much work. I'd be happy to make some changes to it as well if you can think it could be better. I like it [like this](http://jsfiddle.net/q8VFs/3/) a little bit better (bigger, circles instead of ellipses, flash for less time). Does it work, by the way? After clicking 40 times do you feel like it is flashing before you are clicking?
Check out an [example output](https://www.me.com/ix/tim.bunce/Public/perl/nytprof/nytprof-perlcritic-demo/index.html) (click around a bit too). It provides line-level detail of execution times, execution times based on a function/method caller, and total execution vs cost per execution. The "top offenders" listed at the top provide great insight on where to start looking for optimization. You can also get call-graph dot files (similar to the one you've made), although admittedly I haven't used it. The [treemap](https://www.me.com/ix/tim.bunce/Public/perl/nytprof/nytprof-perlcritic-demo/subs-treemap-excl.html) is also helpful.
Wow this one version is actually just damn PERFECT. And yes, it actually feel like it happens just before i click it, although it feels really slightly. And, well maybe it could even get better if the the number of clicks between changes was something like 50. I found that number in the program, but im pretty retarded when it comes to programming so i just didnt know how to save the changes.. haha, silly me. And thanks again man, i asked my friend to make this program before, but he said it would take him a loong time to make a program like that and you made it in just few minutes. You're great!
&gt;What sort of time commitment are you looking for on the part of the mentor? Just code review and stuff? Emails about broader philosophies? Real-time conversations? Proper coding techniques, design patterns, real-time conversations on the piece of code I wrote, and Code review. I think at my level intro to broader philosophies will suffice. &gt;Do you have work in mind (and just need someone to review it), or are you looking for things to do? I'm looking to work on actual projects. I have lots of projects of mine I'm working on, but I'd rather work on a project where someone knows where they're doing and can guide me the right way. I think if I was using or suggesting my own project that I'll be the lead. I'm looking to be mentored and not lead in any way. &gt;Can you provide some examples of the stuff you've done, and/or things that you've seen others do that made you realize you weren't up to the skill level you desire? Other than setting up the basic models, templates, and views on Django, this is something I do quiet frequently in numerical analysis using numpy. I can email or pm you if you want to see some code samples. &gt;I'm no expert, but I am comfortable with the language and generally know the Pythonic way to do things. Depending on your answers to the above questions, I'd be willing to do this. 
&gt;As I get heavier into numpy, RPy and django, I'm discovering a lack of advanced coding style and mechanism. Just to clear up some confusion in my head; you're discovering the lack of advanced style in your use of them or as in the actual behind-the-scenes code?
I'm a civil engineer and I do some analysis using python. This analysis involves calculations using numpy and R. For the most part it's limited to creating simple functions in a file and one main type function to calculate all my data. One example would be aggregate data from badly formatted csv files, reformat them, and do some analysis on them. For the most part I didn't use any objects (OOP) or anything beyond the simple function and solve. I struggle with doing anything more advanced than that to create portable maintainable code. On the other hand, some of the stuff I do can and will be able to help other civil engineers especially since most don't have a good programming background. Being able to provide these tools as web apps using django for example is highly desirable 
Where do you live?
Aha, I see. So you want to learn how to leverage these packages better and also learn their inner workings. Unfortunately I'm just changing jobs at the moment and it's a bit hectic otherwise I would help out; if you haven't found anyone in 2 or 3 months - give me a shout. Your best bet is looking at the internal codebase of those projects *while* using them; that's by far the quickest way I learn without talking to anyone. I learnt a hell load of Python from just reading the Django codebase (and admittedly picked up some bad habits due to that but it's a lot better now).
For Python profile treemaps check out [RunSnakeRun](http://pypi.python.org/pypi/RunSnakeRun). I've a general vague dissatisfaction with Python's profiling tool support, but I haven't personally used anything better.
Canada
I've been using pyprof2calltree: http://pypi.python.org/pypi/pyprof2calltree/ Then using kcachegrind to view the output. I've been having some issues with the data it reports (sometimes loops generate &gt;100% incl. time which doesn't make any sense) but it's generally been fairly useful.
My recommendation is don't work for free.
I'm looking to be mentored. I already have a well paying full time job. So I'm looking to learn most of this on the side
Read pep8 and learn to use pyflakes. Don't overestimate how much knowledge you need to contribute coding-wise to an open source project. Sure, don't go adding large new features, but there are plenty of bugs around that are there just because nobody has had the time to do it yet. Further to that, 80% of the time to fix a bug or implement a new feature is in the process (i.e. write a simple test, run the tests, check it works, write documentation, etc).
Forgot the “to” in the title :(
Read pep8 and learn to use pyflakes. Don't overestimate how much knowledge you need to contribute coding-wise to an open source project. Sure, don't go adding large new features, but there are plenty of bugs around that are there just because nobody has had the time to do it yet. Further to that, 80% of the time to fix a bug or implement a new feature is in the process (i.e. write a simple test, run the tests, check it works, write documentation, etc).
Well, actually it doesn't do this. My program isn't a quine by itself, it produces quines. It takes another program, and makes THAT program a quine. Granted though, the resulting program is somewhat cheating. It doesn't actually read its own source code at any point, but it has much of it stored as a list of strings in a variable. Anyway, at no point does a program that I call a quine read its own source code from disk, you might just have misunderstood what this script does. Or I might be understanding you wrong, do you consider storing some code in a string cheating? Because most quines I've seen do this in some way.
Well, viruses for example often benefit from copying or even modifying their own source code, which is similar to what quines are all about... but mostly, they're just a neat result of computability theory :D
[Here it is](http://jsfiddle.net/q8VFs/5/) with 50 clicks between switching. In jsfiddle, you can change something in the code (like setting the 20 to 50), and then press "run". One of the nice things about programming for the web is that things like this are not too difficult (raphael.js did most of the hard work anyway). It would have taken me much longer to do the same thing in C and OpenGL (or even in python with pyglet). It was fun, so don't worry about it. This is somewhat similar to what made me want to program in the first place. It was a video I saw in my biology class in high school about an evolution simulation program at caltech. It was these blocky 3d animals with various body shapes and movement mechanisms. They did simple physics simulations to figure out which were the fastest and "mated" them to produce the next generation. I thought it was awesome, so I took computer science 101 when I started college.
The script doesn't open itself at any point. The script I wrote isn't a quine, either. It takes other python scripts, and makes a quine out of them. This resulting script never reads its own source code off disk, although it has most of it stored as a string in its source code, but most quines I've seen do this. 
Try participating on the python tutor mailing list. http://mail.python.org/mailman/listinfo/tutor 
&gt; Yes. As I said, the copyright holder is not special in regards to what the license says. Neither is the copyright holder of a GPL project. If you are arguing about the rights of the licensee not the licensor then it's a different topic. &gt; The only right that the copyright holder has that you do not have is a) changing the license in a way that is BSD incompatible, b) removing the copyright information, c) not putting the license text into the documentation, d) using the copyright holders names for endorsements How is this different from GPL? Only a copyright holder for GPL can: a) change the license b) remove the license text d) use his own name in the GPL text for endorsement. &gt; they would still be able to extend it in any way possible by giving their clients as much or as little possibility with regards to plugins, further restricting the license etc. Are you saying MySQL cannot be extended via forking? &gt; Since however MySQL is GPL licensed they current maintainers of forks are entirely unable to monetize this project by selling commercial extensions. Why not? open-source the extension as well. Who said you cannot sell something along with the source? MySQL and RedHat and D-Link has being doing this for YEARS. Nevertheless, this has **NOTHING** to do with the right of the copyright holder. All you are arguing so far is about the right of the licensee, which are different. The right of the copyright holder is the same for both GPL and BSD. 
You should consider contributing to an open-source project. You will spend time looking at other people's code, get decent review of your own code, and can have IRC conversations if you're comfortable with that. Believe me, most project maintainers would be over the moon to get 4-10 hours of additional manpower. I mean, you're using Django - they have a great process for mentoring people and give good feedback when patches are submitted. In addition, there are tons of projects building on top of Django, such as Pinax and Satchmo. If you'd rather be doing numerical integration, there are plenty of projects there, too, like matplotlib or SAGE where dropping an email to the list would probably result in you being overwhelmed with offers of help to bring you up to par.
The first thing you're going to want to learn how to do is create clear abstractions. The code that reads in your input, and gets it into a friendly format should be separate from the code that processes it. Think of it this way: You are processing data from ugly CSV files. Now what if someone gives you an XML file that has data you want to incorporate into the same process? Make up a simple format like this. Or JSON; it doesn't matter. If you have to, for the sake of practice, make up a new format. Now figure out a format that will make the data easy to work with. Make a class that works with this format for each record. We'll call it DataObject (think of a better name than that). It can just be a data class for now, meaning it has attributes and no methods. Then create a function to convert from your ugly CSV format to a list of DataObjects. Then create another function to convert from your new XML format to DataObjects. Now write a function to process the data. This function should know nothing about the input processing. It should never care about the CSV files, the XML files, or have anything to do with reading or writing files. It should only care about your data class, and how to process that information. Now if you need to process your data another way, the new process just deals with DataObjects, and doesn't have to worry about re-doing all the parsing of the ugly CSV files. DataObject is what is called an abstraction barrier between your inputs and your processing. Whatever kind of input you get, you can create a function to create a list of DataObjects from it. Some of these functions may become methods on your DataObject class. (The importers may work well as classmethods). Or they may suggest another class for dealing with groups of DataObjects. Another abstraction barrier can appear between the processing and the displaying of the data. You might want to output a CSV file, or you might want to output a web page. Try to create a structure where you don't have to change the processing to do this. This is basically the principle behind modularity and loose coupling. Different concerns are handled in different places, in ways that if one piece changes, you can limit the fallout from that change to one section of the code.
I thought they addressed all WSGI specification issues with the release of 3.2.2.
If you don't recognize that the GPL's license restrictions are a problem for many practical uses then you are right.
Agreed. Just jump into something. You might fall on your face a couple of times but you'll soon get into it. Trick is, finding the right project.
Agreeing with rlayton and jambox888 - dive into an active project (e.g. one of scipy's scikits? nltk?). Find something that's computationally intensive (I'm guessing that fits your interests) and fix some basic bugs, then ask how to contribute them back and ask for a review. You'll also get public commits which you can point at to show how you've improved and how you've helped the community (and it'll help when e.g. job hunting too).
Do you have a Github account? 
yes I do
Honestly, I think the best way to learn is to do. Build some apps with Python like a web crawler or a game. I would also check out other projects written in Python on Github.
This point: &gt; By not giving the copyright holder special rights. is different from this point: &gt; If you don't recognize that the GPL's license restrictions are a problem for many practical uses. You are confusing between: + GPL License is more restrictive than BSD. and: + GPL copyright holder has more rights than BSD copyright holder. This is patently false. In MySQL case, being BSD or GPL doesn't change anything with the source code. Everyone can still fork the MySQL before and after Oracle acquisition. The only difference I see for the licencee is that being BSD allow people to continually leech off contributions by Oracle to the code base without submitting a single change back. In addition, I would argue with your definition of *practical uses*. Plenty of GPL works despite your claim of restrictions have practical uses. Linux is the biggest example. It has been used from server, to desktop to phone and embedded devices.
This is seriously one of the most helpful Python links I've ever seen! I never knew a tutor thing like this existed. Thank you.
&gt; In addition, I would argue with your definition of practical uses. Plenty of GPL works despite your claim of restrictions have practical uses. Linux is the biggest example. Linux also lives off the GPL exception regarding linking to system libraries. If userspace applications would have to be written GPL compatible I doubt we would see a lot of Linux users.
[r/openant](http://www.reddit.com/r/openant) needs some Python love
[Pyramid](http://www.pylonsproject.org/), [Django](http://djangoproject.com), [Flask](http://flask.pocoo.org/) are my favorite frameworks. Pyramid is aimed towards people with a pretty good understanding of HTTP and web programming but it's all very thorough. Flask has great documentation that is a little more high level so it's easier to understand if you're new to web programming. Django is kind of a happy medium between the two. I would stay away from frameworks like web2py, not because they were bad frameworks but because they follow different design principles that limit the programmer to carry knowledge over to other frameworks. Hope this helps. 
Hot damn!
Reading this just makes me sad. All these machinations that obfuscate readibility and expressing the intent of the code. Why not just use Cython to create a small "fast escape" module?
Any thoughts why not using make+ssh+"other unix stuff" instead?
We're big fabric users here. Partly because we're all Python people and puppet/chef is Ruby, but also because we do deployments onto boxes where we don't have, and can't get root access. Fabric rocks.
The standard library is surprisingly easy to work with for web programming. A better question would be to cite what you need from a framework since they each have their pros/cons.
Offtopic, guy asking the question sounds like Jonah Hill.
Refactoring is a function of an IDE not the language. You can refactor python with pydev in eclipse anyway so i'm not sure what your point is?
His point is that he wants to know where he can &gt;find the Google paper that recommends against using Python for large projects? If you're not going to answer or address the question, why even bother making a snooty comment?
I really liked the *lord = ord* part. ;)
I use PyDev, but it is not as capable at refactoring as Eclipse with Java. The IDE simply can't know as much about the code as can be known about Java code, due to Python's dynamic nature vs. Java's static nature. Check out [this post](http://beust.com/weblog/2006/10/01/dynamic-language-refactoring-ide-pick-one/).
[Cuisine](https://github.com/sebastien/cuisine) looks to fill in some of the gap between fabric and puppet. Not sure how useful if not having root access, but, hey.
Fabric is a structured and conceptually simple way to quickly create scripts that automate a variety of administrative tasks on groups of remote machines. It's not a build system (python already has that in distutils/setuptools/distribute), so make isn't really applicable. It's also not monolithic; it uses ssh for remote execution, and you generally use shell commands on the remote box in your fabfile. Think of it as a way to replace or codify the description of some task ("log in to the web boxes, pull the latest nginx config from the repos, copy it over and restart nginx") where you can run the result and perform the task, `fab -g web update_nginx_config`. Because it's python and not "other unix stuff", you can do things like define the "web" group dynamically, loading hostnames/ips from some roles database, or off AWS via boto, etc, with relative ease.
Seriously. The notion of just writing it in C is addressed at the end, and quickly dismissed for making it too hard to maintain. I don't know about you, but if I saw that horrible mess of optimized python my immediate reaction would be "what the fuck is this shit and why are there two versions that do the same thing being called depending on what locale the user has selected?!?" At that point you have pretty much sacrificed any claim on maintainability -- which is fine, sometimes you need to do that. But don't use it as an excuse to dismiss other solutions that are likely much faster still. 
How do you get a changelog ?
Yup. In Cython he could have used the first version pretty much and get much greater improvements. Cython is awesome.
Then use Aptana or PyDev to get all of the nice Eclipse refactoring tools for Python.
...click the link?
Forking Paramiko is good news, the original author have not touched the github page since spring, I hope the new guy would give it more care. By the way, are there any plans to refactor it into a proper explicit state machine? Running an ssh server is Serious Business, and the ad-hoc way in which paramiko controls the flow makes me uneasy!
&gt; Unfortunately, there’s no way to get the entire matched range from a Python match object. So we’re forced to call the group method– and function calls are slow! At least you can get rid of the group in the expression and call `.group(0)`.
you got it.
works for me. Screenshot [here]( http://www.diigo.com/item/image/1wcyz/x6mt)
Cython would not cut if you don't add types. Also, Cython is not Python and that's a bit annoying, don't you think?
Nicely done. This is very good advertisement for some of the nicer features of Python, and it didn't get preachy.
I don't understand "Tuples are not read-only lists"... Why not?
this is what I get: http://imgur.com/zGF7h A bunch of other people down here in Florida too. DNS poisoning? I'm using a server with DNSSEC... 75.75.75.75 and 75.75.76.76 I guess that doesn't keep comcast from fucking up DNS entries on their side though does it...except my colleagues on Verizon FiOS are seeing the same thing... I went to network-tools.com and used their ping tool to check cherrypy.org, and I'm getting the same IP address as they are... http://network-tools.com/default.asp?prog=ping&amp;host=cherrypy.org 67.15.104.78
The "paper" is an internal document at Google, not a published paper. I don't have a copy.
Lists are used if you have a lot of the same thing, such as a list of names: ['bob', 'alice', ...] Tuples are used to group different pieces of data, such as a name and an age: ('bob', 30)
Do you know who the "individual" is/was?
That's a nice idea, though I'm sure you know ['bob', 30] Works fine. "Tuple" unpacking works well too...
I think it's important to point out that there is no inherent limitation that says lists must be homogenous -- either type can hold heterogeneous collections of objects. It's just that, typically, when you are dealing with something that could possibly be extended (and therefore require a list) it tends to be a list of all the same kind of things, whereas when you have a list of values that you don't expect to extend, it's more likely that it's being used in a context like (key, value) or (name, age) where there's only ever going to be those two things.
I'm very unhappy about advertisements of using map/zip/other stuff as "pythonic". This all comes from "this is slower on python" attitude and actually hurts (or does not improve more these days) performance on PyPy and certainly does not make things more readable.
map/reduce/lambda are the evils. Zip is fine.
Or even better purchase PyCharm. It's free for a month if you just want to give it a try. If you're going the IDE route it's one of the best. And I think best at refactoring. If you have any experience with Resharper in Visual Studio or IntelliJ you'll feel right at home.
This is a valid question - as with most anything unix/linux, there's more than one way to do something. Personally, I like the SSH integration aspect of Fabric the most - while you can certainly do everything via shared keys in ssh, it's nice that fabric keeps the socket persistent and you don't have to create multiple connections to accomplish a single task.
&gt; Why not? Indeed, why not? It's perfectly fine use of tuples. If you have no intention of writing to a list, better make it a tuple to make your intention clear. However, tuples are more than read-only list. For one thing, they are useful to return more than one value from a function: def vicking(spam): # some code return bacon, eggs a, b = vicking(spam) Tuples are defined more strongly by the comma than the parens and in the above example, they are the conduits that lets you return more than one value and assign to more than one variable. They can also be used as dictionary keys. Many people when they want to represent say a gameboard will use lists of lists which is just plain wrong. Better do something like that: board[(2, 4)] = {'piece': 'king', 'color': 'white'} This way, you can iterate only on the pieces that are actually on the board rather than loop through empty space.
And the article doesn't actually mention map, reduce, or lambda - only zip. So it shouldn't be a problem.
I was always under the impression that iteration variables leaking to the external namespace were an accident? It seems that they shouldn't work like that, to be honest.
That is not Alexis Ohanian.
I think this shouldn't be abused. It's clearer to have {'name': 'bob', 'age': 30}.
I don't think that this looks like python, that is just ugly: def htmlB(s): # … non_whitelisted = RE_FIND_NON_WHITELISTED.findall(s) if len(non_whitelisted) &gt; .6 * len(s): escaped = RE_FIND_NON_WHITELISTED.sub( lambda m: CACHE_HTML_ESCAPES.get(m.group(1)) \ or CACHE_HTML_ESCAPES.setdefault(m.group(1), "&amp;#" + str(ord(m.group(1)))) + ";", s) else: lWHITELIST2 = WHITELIST2 escaped = "".join([ c if c in lWHITELIST2 else CACHE_HTML_ESCAPES.get(c) or CACHE_HTML_ESCAPES.setdefault(c, "&amp;#" + str(ord(c)) + ";") for c in s]) Adding types and changing a few details is what I meant with "pretty much".
A good tip I learned from a pycon presentation is that you should use a tuple if you can replace it by a namedtuple or use a list otherwise. If you can give an name to each indice of the elements then it is a tuple. If you can't it should be a list. E.g if you have: goog, Google; aap, Apple; gm, General Motors; Each row is a tuple because each indice has a meaning. The first indice is the ticker symbol and the second is the company name. However the set containing each row will be a list because there is no difference in meaning between the elements. So we have [(goog, Google), (aap, Apple), ...]
Which of his examples makes use of that?
I upvoted this because it's well thought and well written. Last, but not least, it's also sound advice, in my opinion.
Where he says "You need counters rarely, and iterators only occasionally" itrL = iter(L) for item in itrL: do_something(item) if is_some_condition(item): break for item in itrL: # continues where previous loop left off do_something_else(item) EDIT: Just realised he's not using a bare For Each loop he's using an iterable on it, which is *supposed* to preserve state. Disregard everything, I suck cock.
Or maybe [namedtuple](http://docs.python.org/dev/library/collections.html#collections.namedtuple). &gt;&gt;&gt; from collections import namedtuple &gt;&gt;&gt; Person = namedtuple('Person', 'name, age') &gt;&gt;&gt; p = Person(name='bob', age=30) &gt;&gt;&gt; p Person(name='bob', age=30) &gt;&gt;&gt; p.name 'bob' &gt;&gt;&gt; p.age 30 The good thing about namedtuple is that it has performance characteristic of a tuple while giving you a nice syntax of class attributes. % python -mtimeit -s"import collections;Person=collections.namedtuple('Person', 'name, age');d=Person('bob', 30)" 100000000 loops, best of 3: 0.0168 usec per loop % python -mtimeit -s"d={'name':'bob', 'age':30}" 100000000 loops, best of 3: 0.018 usec per loop 
I totally forgot about those, thanks. Time to re-read the Collections documentation!
TIL about properties. 
Ah, also with a bit of additional research I find that A) *He's* male and B) He's one of the founders of the website on which I'm posting this. Nice. I'll correct it shortly, i.e. when I can get to that server. Thanks for pointing it out.
There is a difference between learning and being taught. Learning is for those without access to proven techniques for self improvement. Teaching is the opposite, and should be employed when available.
I unapologetically use maps and reduce - albeit occasionally. I view map, filter, etc as functionally describing what I want to do: filter(is_odd, lst). [x for x in lst if is_odd(x)] is the same, but my mind requires more neurons to parse it. As for readability, that's the flaw of Python's syntax. Other languages make stuff like map, reduce, etc quite readable - especially when you're chaining a bunch of them together. 
Because that's an implementation detail. Their purpose in CS is to act as very lightweight struct, indexed positionally rather than by name. `namedtuple` makes a good hint: if you would use it, were it overhead free (and you didn't have to think up name), you've got a candidate for a tuple. You can use tuples as read-only list, in Python they're basically the same thing. But you should not, it's bad for your mind and it's bad for those you interact with.
&gt; I was always under the impression that iteration variables leaking to the external namespace were an accident? In list comprehensions it is. In `for` loops (and others), it's not really an accident, it's a direct and logical consequence of Python only having function-level scopes.
I read that as "Tuples are not (**only**) read-only lists". Best discussion about the topic I've found: [here](http://mail.python.org/pipermail/python-dev/2003-March/034029.html).
And what's the reason for it? I can't seem to think of a time I would need to iterate over the a collection and *then* use the last item in it for something else and if I were to need such an ability, I'd find a better way to do it than something that's not entirely explicit in the code.
&gt; ## http://cafepy.com/article/be_pythonic/ &gt; Wrong: &gt; &gt; i = 0 &gt; while i&lt;len(L): &gt; do_something(L[i]) &gt; i += 1 &gt; Pythonic: &gt; for item in L: &gt; do_something(item) OP forgot one: Kill It With Fire for i in range(len(L)): do_something(i, L[i]) yes: for i, item in enumerate(L): do_something(i, item)
Would you care to expand on the evilness of map? As BeetleB, I tend to use map without remorse, albeit sparingly, and I would like to know what "the other side" thinks.
&gt; And what's the reason for it? I gave you the reason: Python creates lexical scopes through functions, not arbitrary blocks. &gt; I can't seem to think of a time I would need to iterate over the a collection and then use the last item in it Really, you've never looked through a collection to find the first item matching a predicate? &gt; and if I were to need such an ability, I'd find a better way to do it You'd pre-declare the variable and fill it in the loop, for languages in the same "class" as Python (statements-based). Leading to the same result except more verbose. &gt; than something that's not entirely explicit in the code. What's more explicit than *the core semantics of the language*, pray tell?
Indeed, I usually find that all(), any(), filter(), apply(), map(), etc., better express my intentions, and with less code, than the equivalent list comprehensions or for loops.
Which module in Paramiko makes you uneasy? Or specifically, which part of Paramiko's source do you think should be refactored into a state machine? 
A list, or a sequence or however you call it is an entity (I don't want to use the term object in the context of object oriented languages) which contains other entities. These entities are ordered in some way (insertion order or whatever you need) and all entities share a common interface. This interface can be more or less explicit, this depends on the language. Statically typed languages like Haskell or Java require you to write it down explicitly, Python allows you to have it implicitly. The important part about a list as a list is however: You don't care about the length too much. You might require some minimum length and do something special once you reach that minimum length, however, if you have enough elements, you have enough elements. That's all you care about. Processing 10 elements is the same as processing 1000 elements is the same as processing a million elements, disregarding time. Given that, in python, you will usually process lists with some sort of iteration, a for loop, itertools, comprehensions. These will access all the elements according to the (implicit) interface and do something, which naturally doesn't care about the number of elements too much. Tuples on the other hand are usually poor mans light-weight objects or structured datatypes. Taking the example from another comment, ('bob', 30), meaning (name, age). The important part here is that you associate a specific semantic with each element of the tuple. Even more in contrast, if you use tuples in such a way, you usually want your tuples to have precisely 2 elements. Not 1 (then your access crashes), not 3 (what does the third one mean?). Exactly 2. Given that, you will usually access tuples by index. "Congratulations %s for your %d birthday".format(tuple[1], tuple[2]). start, end = interval (hidden by syntax sugar, but indeed accessed by position)
Or use a class. Classes are cheap after all, and something like name + age certainly sounds like it could grow.
As far as I know `map` was never faster than list comprehensions, you must be confused. `map(int, s.split())` is more readable than `[int(item) for item in s.split()]` for me, that's why I use it. If PyPy is having problems with optimizing the former, it's a PyPy's own problem, and a transient as such, if I may hope.
I'm talking of the way that the regular for each loops leak variables. Not the way that iter-objects 'leak' variables. With for-each loops, no, I've never needed a time when I *always* need the variable to leak outside the loop's scope. x = range(10) for num in x: print num print num Output: 0 1 2 3 4 5 6 7 8 9 9 Why is this good? Try the code again but this time, assign 10 to num prior to running the loop. It changes num. Is that good? Now consider this: In a large program with many people working on a project, is this behaviour useful? Is this behaviour optimal? Wouldn't you *prefer* that each for each loop has it's own namespace?
map itself is not an issue, but people using a mess of itertools with various strange combinations that are harder to optimize. But indeed, the problem is temporary, it's just that you have to consider many many ways how people can write loops.
&gt; I'm talking of the way that the regular for each loops leak variables. What the hell makes you think I misunderstood this? &gt; Why is this good? That's a different question with *no relation whatsoever* to the one you've been asking so far. &gt; Try the code again but this time, assign 10 to num prior to running the loop. It changes num. Is that good? See above. And I've got one even better: assign a completely different variable within the loop and try to access it after the loop. &gt; Now consider this: In a large program with many people working on a project, is this behaviour useful? Is this behaviour optimal? Frankly? If you're relying on the same name being different bindings in nested blocks you deserve to be shot either way. &gt; Wouldn't you prefer that each for each loop has it's own namespace? There are a great number of things I'd prefer in Python alone. On its own, this precise change ranks nowhere on the list.
I was making sure we were on the same page, friend. It is the same thing I was talking about all the way through, I was talking, and started talking about *the way in which for each loops leak their iteration variable*. Wouldn't it be better to have something like the below: for x in collection: somecode(x) if something: break x someothercode(x) So that it's entirely *explicit* that you're leaking that variable, if you omit the variable name from the break statement, then it would leak *nothing*. It's just a simple annoyance of the language that's all, friend.
Nice article! The lack of editorial made it feel informative without being pushy. I wish he used PEP 8 conventions uniformly, however. The variable naming scheme is weirdly mixed throughout.
Classes are not nearly as cheap as namedtuples, especially with regards to memory. Each instance has to carry around an instance dictionary and a bunch of other bookkeeping.
&gt; Wouldn't it be better to have something like the below: No, that's absolutely dreadful. 1. Now I have to hunt down for a keyword three blocks down the stack to know *what* is leaking out of the loop 2. How do I get this feature outside of loops? `try:`, `except:`, `finally:`, `if:`, `else:`, `elif:`, `with:` blocks have the exact same scoping (because it's Python's scoping semantics), do we extend `break` to be usable in all blocks? Only named breaks or all breaks? 3. If `break` is extended, how do you decide *which* scope you want to exit from? In your example, why would `break x` exit the `for:` block and not just `if:`? What if you have two nested `if:`? And a `with:`? 4. What about arbitrary expressions, can you only `break` names, or arbitrary stuff? Why? And it's not like I tried hard. I think you get the point?
&gt; As far as I know `map` was never faster than list comprehensions The short answer is: it depends on weather or not you're using a lambda (although the cost of creating the anonymous function is invariant). The difference in speed between the two is significant for small data sets. Source: http://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map
&gt; This article originally appeared at http://shalabh.infogami.com/Be_Pythonic2 ಠ_ಠ
i've started porting all our deploy tools (currently in a mix of bash, perl, and python) to fabric (or really, fabric running on an internal web.py app) mainly for ease of use (so producers can update qa without needing to open a command line, ssh to some server, etc) and maintainability (we're a 99% python shop, so having all our deploy code in python means other people than me can work on it!) i had planned on overhauling the whole system (which is currently a bunch of disparate scripts, that i run in between various other shell commands) into one unified tool, and fabric seemed like a good way to organize it.
Teaching can be expensive. That's why classes aren't free, and it takes time to explain things. Learning on your own should be a skill that every engineer should try to improve. If you want a leap start, buy a book or attend a class. Obviously, that will cost you money.
[Here's Guido's blog post](http://www.artima.com/weblogs/viewpost.jsp?thread=98196). Mainly because list/generator comprehensions are more readable. Same thing goes to lambda vs def.
While learning on one's own is definitely a valuable skill, for the express purpose of learning things, it's extremely inefficient, since it's very difficulty to assess what's important when one is incompetent in a field. There are a lot of examples of this, the one immediately coming to mind is how to properly train as a cyclist (strength is less valuable than cadence, which was realized only by Armstrong). If one wants to learn something, one should seek out people who are more experienced. (That said, doing stuff still has a proper place.)
So there's often going to be a huge stack of things you're iterating through that make it *more* difficult to see what's leaking out? What's the point in having said idea in those scopes? There's no reason to use it for that because it's not got a need for a separate scope. Try/Except clauses already deal with the scope that they're in, finally, too. If/Else, uhh, why would they *ever* need some way to break out of it? You've already got a method to break out of it (if) and you've already got an exit scope (else/elif I'm finally realising you're probably just a troll and more just about trying to ensure your opinion is heard. But if not, come back and speak when you've had a nap or something, bro. The idea I had above would need some tweaking, but still, it *could* be useful. Why wouldn't you want to extend the language so that you've got more power over simplistic stuff like break?
The builtin documentation generator for python is `pydoc`, but Sphinx is the standard. There's also epydoc which is similar to pydoc and sorta similar to doxygen as well. I do not like automatic documentation generation in the sense that you run something on your code and it spits out html; I think the quality of output they produce is very low and are barely any more user-friendly (for the case of a library API) than just reading the code. I've used Sphinx for non-python projects ([example](http://hiidef.github.com/logd/)) and it works fine; you just don't get some of the automatic code-inclusion and docstring stuff in your documentation. *edit* fixed the link, http not https.
I have no idea what you're trying to ~~say~~ argue. I'm saying it's inefficient for someone to put off work and explain things to people. There is plenty of material online. If you want someone to explain something to you personally, pay for a class.
&gt; So there's often going to be a huge stack of things you're iterating through that make it more difficult to see what's leaking out? My point is that your idea is *completely broken*. The current behavior of Python is simple and straightforward: if there's a binding, it's visible from the whole function. Period. &gt; Try/Except clauses already deal with the scope that they're in, finally, too. If/Else, uhh, why would they ever need some way to break out of it? You've already got a method to break out of it (if) and you've already got an exit scope (else/elif You're not making sense here, these constructs have the *exact same issue* as `for:` or `while:`, if you create a binding within them it's visible from the whole function. Or are you making your "proposal" even worse by completely arbitrarily (and without any possible justification) deciding only `for:` and `while:` are special enough to create a lexical scope? &gt; I'm finally realising you're probably just a troll Uh? I disagree with your idea and tell you why therefore I'm a troll? You're kidding right? &gt; But if not, come back and speak when you've had a nap or something, bro. I listed issues with your "idea" and your only reply is "come back when you've taken a nap"? You do realize you're a complete asshole right? And don't "bro" me. &gt; The idea I had above would need some tweaking, but still, it could be useful. No, it's crummy, it's completely broken and it's not an improvement. &gt; Why wouldn't you want to extend the language so that you've got more power over simplistic stuff like break? Oh I would, but your proposal 1. does not add any power to the language and 2. is basically crap. I'm done here, you clearly can't accept either explanations or criticism, not going to waste my time any longer. PS: please post this on python-ideas, I'm sure it would be hilarious.
See my [other response](http://www.reddit.com/r/Python/comments/lo597/where_can_i_find_the_google_paper_that_recommends/c2u9nim?context=1) to this suggestion. Also, check out [this article](http://www.linuxjournal.com/node/1000103): &gt; Refactoring a dynamic-typed language is inherently hard for reasons that are pretty easy to understand. If you can't look at a piece of code and know exactly what type a given variable is, an IDE won't be able to either. Even if you can do so with some difficulty, IDEs are out of luck. This makes the most interesting and useful refactorings monumentally more difficult to implement. If you can't know what type a variable is or what type of object it contains, you can't tell until runtime what operations it actually supports.
I just get the feeling you're taking this *incredibly* seriously and very to heart, as noted by the 'don't bro me, bro'. I seriously recommend a nap. Other than that, leaking variables is a pain in the ass sometimes, and as much as *you* may believe it's a language feature doesn't mean it is considered any good. I just wanted to bash around some ideas but it's clear you're more interested in making sure that no amount of discussion will take place as long as you don't agree with it. Good day troll.
Also, unpacking a class into local variables does not "just work"
Plone looks interesting. Would you recommend it for very small projects as well (used by one or a just a few persons)? What is its target audience?
Another vote for PyCharm from me. As a long time Vim/Ultraedit/Eclipse+pydev user I finally settled on PyCharm.
You could call it [Dylan](http://en.wikipedia.org/wiki/Dylan_%28programming_language%29).
&gt; quality of output they produce is very low and are barely any more user-friendly (for the case of a library API) than just reading the code. That's actually one of the reasons I love Doxygen, as long as you're careful about documenting your code, the resulting generated documentation is *stellar* and highly readable for someone who just needs to use the API you've created. Then again, I've largely been using it in a mix of C/C++ and BASH, and having a single, navigable reference document for a large project with mixed code is incredibly useful. For your example, the link doesn't seem to work, and snooping around [here](http://hiidef.github.com/) I can't find links to it.
The entire server core. SSH interaction is supposed to follow a well-defined script: first a client authorizes, then the client opens a channel, then for example the client sends an `exec` command on the channel, then you and the client send data messages on the channel, then you can send the command exit status, then you both close the channel. Any deviation from this script can lead to security vulnerabilities. Paramiko uses the `transport._expected_packet` tuple to prevent the other side from doing anything before they've authorized, so that part is OK. But what if the client tries to re-authorize with different credentials in the middle of the session? He can even send a special pre-authorization message with his username and public key, but not yet signed with his private key -- which gets routed to your `Server.check_auth_publickey` method without any indication that it's not a real successful authorization attempt. Well, turns out that the default AuthHandler has a special 'authorized' flag, which when set seems to make it quietly suppress all further authorization messages. Though it took quite some grepping to find where it's being set and where it's being used and convince myself that it really works as intended. What if the client sends another `exec` request on a channel that is already used by some command? It seems that there's no special flag for this case, so Paramiko would let it through. Now, I don't see how it could lead to a security breach, but it's definitely weird enough to make me uncomfortable. Don't get me wrong, Paramiko is a very useful thing, I'm grateful for its existence, and I'm more or less sure that it's actually secure enough, especially if you are being somewhat paranoid in your part of the server code. But I'd really prefer for it to be self-evidently, obviously secure, which it isn't, regretfully.
Sphinx/reStructuredText, because I have no limitation keeping me from using it, and because I actually enjoy writing documentation with these tools.
The Pythonic version of the last example would be import operator L.sort(key = operator.itemgetter('price'))
Other examples of multi-language projects using Sphinx can be found [here](http://mark-story.com/posts/view/creating-multi-language-documentation-with-sphinx) and [here](http://wiki.bazaar.canonical.com/Documentation). As jmoiron mentioned, you just miss out on the auto-generated API docs. I assume that's what you're looking for? As of version 1.0, Sphinx supports C and C++, with a plan to "add special support for other languages as well. " **EDIT**: Apparently the functionality to support other languages in Sphinx is called [domains](http://sphinx.pocoo.org/domains.html#domains).
You aren't actually benchmarking anything there, you have the entire code in ``-s`` blocks which make it setup code: alex@alex-gaynor-laptop:~/projects/pypy$ python -mtimeit -s"import collections;Person=collections.namedtuple('Person', 'name, age');" "d=Person('bob', 30)" 1000000 loops, best of 3: 0.673 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ python -mtimeit "d={'name':'bob', 'age':30}" 1000000 loops, best of 3: 0.244 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ alex@alex-gaynor-laptop:~/projects/pypy$ alex@alex-gaynor-laptop:~/projects/pypy$ ./pypy-c -mtimeit -s"import collections;Person=collections.namedtuple('Person', 'name, age');" "d=Person('bob', 30)" 10000000 loops, best of 3: 0.0505 usec per loop alex@alex-gaynor-laptop:~/projects/pypy$ ./pypy-c -mtimeit "d={'name':'bob', 'age':30}" 10000000 loops, best of 3: 0.0639 usec per loop 
Thanks. I still consider that readability is on the eye of the beholder (and happy to read, from your link, that filter and map will stay :-D). Thanks again.
I understand the argument, but I have always heard that smalltalk had top-notch refactoring tools (before java at least), and smalltalk does not sound inherently easier to refactor than python: http://st-www.cs.illinois.edu/users/droberts/ (some links are unfortunately broken).
Thanks for the correction!
Had to find out about this one from a failed job interview :( thanks for posting it!
great article. I think whenever you optimize you always sacrifice readability and maintainability so "not so pretty" solutions may be an option as well. btw those 'interns' are already way better than some 'professionals' of the medium (not sure if I should be jealous or scared).
But that's because the IDE for smalltalk back then was itself written in smalltalk. So for complete inference the IDE just had to ask the object of it's properties, voila.
You probably can get the same functionality with native ssh: http://www.revsys.com/writings/quicktips/ssh-faster-connections.html
You put Raymer on there, nice! In our school, professors often cite "The word of God according to Raymer, chapter 5, verse 2, ..."
I've learned about them a long time ago, but I still don't know when to use it. While I'm admitting ignorance, I've also never understood \_\_metaclass\_\_ no matter how many times I read it.
&gt; ie do folks just basically match up the external parameters in the command to kargs/etc... Tkinter does just this, in a sense -- routes all calls through a simple function that formats `*args` and `**kwargs` into a string using the shell-like syntax of Tcl. Of course most Tkinter classes provide a proper Python interface, with explicitly specified parameters on each method to enable static code analysis in editors that support it. Then everything is then routed through that function.
It also requires a very special coding culture, where your objects are aware that they might be instantiated in the IDE and don't do anything important unless explicitly asked to. This is a very strong requirement, and I'm not sure that it's actually fulfillable to any significant extent. I mean, I haven't touched Smalltalk, but I know that writing WinForms components that behave properly when instantiated by the Form Designer is non-trivial to say the least, and I can't even begin to imagine how one would go about writing, say, a method that returns a File object (so that you would know what you could do with its return value) without actually opening some file. Does it have to have an explicit `if in_designer then return MockFile` guard at the start? Does every method need something like that? Are we reinventing static typing in an ad hoc, slow, incomplete and buggy manner?
We're all taken :)
Seriously though, http://jobs.github.com and stack overflow careers
haha. I KNOW. Just like all the good men. But I still want one that is good. How do we at least open that dialog with them? Our 2 python guys are awesome...
I've already posted, didn't get any bites =( http://jobs.github.com/positions/05c60ce2-f66c-11e0-9be8-914ceeeb139d
 &gt;&gt;&gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! &gt;&gt;&gt; 
Sorry, I didn't understand how to read the changelog at first. By reading the explanation on the top of the page, it's easier !
&gt; As jmoiron mentioned, you just miss out on the auto-generated API docs. I assume that's what you're looking for? Yeah, I really want the best of both worlds. I want the API docs to be generated based upon doc-string comments, but I also want the ability to have other docs that provide usage examples, history, etc. ~~Basically, the more I think about this, the more I realize that for our project Doxygen (even with the doxypy requirement) is probably the best tool.~~ *Edit*: Scratch that, in a fresh-light this morning it now seems that Sphinx would be the best tool because of the points described above.
The point is that there's a lot of things that are then supported by that object that ought not to be, such as appending. ('bob', 30) is also hashable. ['bob', 30] is not.
&gt; Say no to getter and setter methods &gt; &gt; Yes, encapsulation is important. No, getters and setters are not the only way to implement encapsulation. In Python, you can use a property to replace a member variable and completely change the implementation mechanism, with no change to any calling code. Properties have a problem: you cannot later add optional arguments to them that affect their fine-grained behaviour.
imo that ad is a little too jam-packed with "attitude" and "character" and quite light on specifics. mostly it conveys to me that appsumo is a big fan of appsumo and they need to hire someone who can write python... but they maybe won't buy him a widescreen monitor??? have you tried changing up the copy in your posts? try a slightly more formal version, with attitude as a spice rather than a main ingredient? better formatting also might help. 
What do you offer in concrete terms? Everyone has a price and I don't see an indication by the github posting.
No but we should at least test other versions. Haven't really found a great way to pull more people to apply. One consideration is promoting more to our own sumo-lings ("customers") We are bootstrapped but salary is around $100k, whatever computer stuff they want, free lunches, unicorns and usual magical stuff :)
Look for an engineer with solid experience and broad skills, not for a specific-language-bound-coder.
Not that I am interested, but I stopped reading after the 3rd line because it looked more like l33t speak than an actual job posting.
The ad it too over-the-top for me. 
The best ones will have a large open source portfolio, a lot of times on Github. Just contact them via Github messaging.
Doesn't look very serious really (and not being serious is not the same thing as being cool) ... I think you'd better focus on what you want from a potential employee and what you going to offer him (like what sort of work conditions, what sort of projects, benefits etc).
This. Being informal is fine, but that github listing just makes you seem immature and unprofessional (at least to me). It's got slang, it's got block caps, it's got a 'giggity'. If this is how you approach writing a job advert... ...I've been trying to finish that sentence for the last 10 minutes without writing "It suggests you're a massive prat and working with you would quickly get very, very annoying", but I can't find a nice way to put it. Don't take it the wrong way - I'll assume that you're actually easy to get on with, but you need to advertise in a way that conveys that. Also, I agree that you need more details - what is it likely to involve? How much might it pay? How flexible are the hours?
The reason why I recommend this book is because it explains the "why" of things. All too often, python books say x works and your should use x. This book explains x similar to that way a college class on chemistry will start with the electron. For those who wish to pick up Python as a 1st language and want to have concepts full explained this my recommendation. 
Pretty much true, we're in high demand apparently.
Did you try the monthly "Who's Hiring?" post on HN?
While this is nice, but is "Kill It With Fire" a bit of an exaggeration? It's only a marginal improvement to the first case in my opinion - and trades off a tiny syntax improvement with a surprise feature. Much more significant is the ability to toss thousands of lines of getters &amp; setters away and rely on properties when needed instead. EDIT: Didn't mean for this to sound harsh, but I personally find the value of syntax improvements that come with a learning curve questionable. I have a hard time finding experienced python programmers - and so generally need to train them. Code that is obvious to an experienced programmer who's just learning python is a plus in my book. Not that this is that huge of an offender.
It's generally considered idiom. I find it to be friendlier to look at too.
pwnd punch my dick off
I might be dumb, but why would this ever be used over a dict? Aren't dicts kind of the cleanest and simplest way to have a sequence of keys and values?
Jesus this ad is too much. What is this, an AIM chat? If you want to attract professional developers you need to post a professional job listing. Try browsing through other similar postings to get an idea of how such an ad should be written and what tone is appropriate.
This was obvious, and boring
&gt; You also: —Aren’t impressed by fancy-sounding “positions” in a company (soo stupid). ... —Can work from a laptop (no quadruple-screen-only programming divas please). This basically says to me: "You won't be respected in our company; you will be our code monkey." &gt; us fat Sumo’s Us geek's generally don't appreciate misuse of possessive 's.
You might also take a look at your interviewing processes. When I applied, I spoke to you, and your partner. Then your technical guy gave me a few questions, but didn't respond or give any feedback, and nothing in person, just a couple of emails. I don't think he even asked any serious Python related questions, even though that was what I was applying for. He did ask one javascript question. Yes, my resume was light on Python experience, but everyone I've interviewed with has been overwhelmingly positive to my grasp and command of Python, programming, design patterns and how I have performed on all actual code test/questions. Then, I heard nothing at all out of you, not a peep, so I moved on. I hope this doesn't come across as rude, but if you want honest feedback, this is what I have. Good luck to you, tons of people in Austin are hiring Python developers. I have 16 months of experience and got 4 offers. Of course, I think it helps that I do very well in the interview process.
Not hiring someone over that is idiotic. Surely that wasn't the only reason.
I'd say the two go hand in hand nicely.
[NumPy](http://numpy.scipy.org/) is a good library with some good documentation for this sort of thing.
I probably seem like a grumpy old man in this post, but for context, I'm 27 and from Chicago, and I'm reading this as if I have no idea who you are (but I kind of do). To be honest, I stopped reading the [jobs.github post](http://jobs.github.com/positions/05c60ce2-f66c-11e0-9be8-914ceeeb139d) after you went into the "let's see if you fit in with us". Of course I went back and read the whole thing in order to make this post, but here are my issues with how you went about this: &gt; What’s up my Python developer-izer friend…. I can kind of live with quirky stuff like this, but I was reminded of it as things went on. &gt; I know you’re a nerd. Admit it. They're looking for a job on Github, so this is implied. Again, I can go for some quirky stuff, but we're three lines into your job post and one of them is blank, and the other two do nothing for me. &gt; I’m a nerd too. I’m ALSO a 510 lbs Sumo wrestler who runs AppSumo.com. Are you really? If so, this is awesome. If not, it's just another quirky line. Note: so far we're three lines in and I have no idea what is going on. &gt; I’m ALSO looking for a Python developer….BUT FIRST LET’S SEE IF YOU’LL FIT IN WITH US FAT-ASS SUMO’S: Here we go, you're looking for a Python developer, and I'm a Python developer. Now we're getting into the good stuff. &gt; You preferably like: Burritos, drinking beer, working startup-style, tech stuff, armed robbery. &gt; You also: —Aren’t impressed by fancy-sounding “positions” in a company (soo stupid). —ACTUALLY know your way around a Python (giggity). I really like burritos and I like drinking beer even more, but what in the hell do you do in this company? On top of not knowing what you do in the company , I don't even know what AppSumo as a product is yet (well actually I do, but I'm playing like this is the first time coming across you/your post). &gt; —Can work from a laptop (no quadruple-screen-only programming divas please). I have an Ergotron quad-monitor stand that I've been trying to give away on Craigslist, for free, for two years now. It's all about three monitors now. I can do the laptop thing, but I have all that shit for a reason - it works for me. If what works for me doesn't work for you, that's probably an issue. (I don't actually care about this, but that's definitely the opinion some people take, which is probably where you were going with this anyway). &gt; Basically you gotta be smart and cool (oh yea….and know Python really damn well) I've been a CPython core developer for 2 years and a general user for ~7 so I think I know Python pretty well, but that doesn't help me here. Do you guys use {insert list of web frameworks}? Not only do I still not know what your whole thing is about, I don't know what specific stuff you want to know. I know, it's Python, and a good developer can learn and adapt to many tools, but what if I'm really looking for a job in $framework1 but you guys are heavy on $framework2? Hell, for me personally, I don't know any of that shit, so I'm more in the dark than anyone here. I don't even know if I have *any* relevant skills for your company other than just the language you use. &gt; Now here’s a little somethin’ about us fat Sumo’s: &gt; (snip, some of the more important guts are here) Alrighty, now we're onto something. Here's what you guys are. Daily deals place: got it. Hooking up devs with tools: cool, got it. You're growing: niceeee, got it. Google us: you might as well just put a lmgtfy link right there. Give me something I can use right in the post, otherwise you've lost me once I google you and end up with 75 tabs open of other sidetracked things I came across. At this point is the second time I stopped reading the post, but again, I kept going on for the purposes of the response. Anyways, moving on, you have 15 people: nice, pretty small place - "how many devs?" is my question when reading that. &gt; IF YOU WANNA BE PART OF THE APPSUMO TEAM: Call Noah: 510-866-6624 (the password is “Burrito”) Email: noah@appsumo.com I hate talking on the phone so I'd email you, but thanks for the password. &gt; P.S. Isn’t this ad sooo much better than that other boring crap you’ve been reading?? No, not at all. It told me almost nothing, and as I mentioned earlier, I only got this far in order to make this post. There's a difference between spicing things up and dumping the whole jar of spice on it. I left your post neither encouraged nor discouraged to apply, I just left it thinking "what?" &gt; tl;dr: Looking for Python dev in Austin, TX. We’re AppSumo.com – Daily Deals for web geeks Isn't the tl;dr usually at the beginning? Also, since I'm from Chicago, would you expect me to move down there or is remote work a possibility?
Sounds like you want something like this: http://rattle.togaware.com/ I don't think we have enough information to make a judgement on whether or not replicating this in Python is a "waste of time". The author does have Python skills though, so there's probably a good reason he chose not to use it in this case. If you were serious about ramping up your Python skills, you could make a good job of it with numpy or RPy, pyqt/pyside and something like traits/chaco, matplotlib, networkx, or similar. Maybe start something on github &amp; let other interested people join in. 
&gt; Tuples are not read-only lists. No. &gt;Tuples usually indicate a heterogenous collection No. &gt; You can think of a tuple as a row in a relational database No. Tuples can contain complex hierarchical data. This is a bad analogy. &gt; By contrast, a list of names is always a list, even though a particular function may not change it, that does not make it a tuple. No. There's no reason a tuple of names would be inappropriate if you don't intend to change the tuple. &gt; Tuple unpacking is a useful technique to extract values from a tuple. You can also do unpacking with lists. Tuples are just immutable lists. 
If your not set on python R and or matlab are the defacto data analysis tools for power users. 
&gt; Aren't dicts kind of the cleanest and simplest way to have a sequence of keys and values? Dictionaries by their nature don't have an order and aren't sequences. For example: spam = {'a':1, 'b':2, 'c':3} The "first" key in spam isn't 'a'. It isn't any of them because there is no "first" key. If you call spam.keys(), the keys are returned in an unpredictable order.
Also, look at **tile**. Tkinter is decent. http://tktable.sourceforge.net/tile/ 
From what I gather, R is way to go for this kind of stuff?
Thanks, I think Rstudio looks pretty good and Numpy stuff I'd definitely look into.. I'm tired of excel..
If you need an extensible type, roll your own class with `__get__` and `__set__` methods. The built-in property class is syntactic sugar.
Actually, Pandas: http://pandas.sourceforge.net/ It uses Numpy underneath the hood, but provides an R-style DataFrames interface. It has lots of built-in statistics and whatnot. The author is a friend of mine and is actively developing it, so if you run into features that it doesn't support, ping him via email or Twitter and I'm sure he'll be responsive.
I stopped reading at xrange. What is this, 2007?
It's not about hating change, it's that there isn't a ton of support for it from various modules and libraries. Also, Python 3 isn't really any easier to learn the Python 2.7.
It may be too obvious to say, but if you learn and use Python, you will have a tool you can use in all sorts of situations: a general purpose scripting language, with a vast community. Today data analysis, tomorrow category theory, the next day simulation...
I just meant people seem to hate change in general. But you reiterated my point...why is there no support after three years for these crucial modules and libraries? And from what I have seen, Python 3 seems easier, albeit marginally. I have been using 2.7 tutorials and just adjusting my code for Python 3 because I've not found any newb friendly Python 3 tutorials yet. Should I just give up on 3? It's frustrating because it's "supposed" to be the standard but there's little to no support for it. Should I just basically say "Screw the standard" and learn an outdated version instead? Or is there hope on the horizon that 3.0 will pick up steam at some point? EDIT: I'm getting downvoted to hell for trying to ask honest questions. Please help a newb out...I'm trying here, guys.
Most of that seemed common sense, but it's nice to see the Pythonic way of doing getters/setters.
No one wants to convert their applications/libraries to Python 3, because all the libraries they depend on are still on 2.7. This is what we call a vicious cycle. But you can use http://twitter.com/Py3K_update to keep an eye on how things are progressing. In the meantime, I would say just learn 2.7
2.7 isn't outdated. Really, there's not much of a difference, just learn one and you can do the other. For beginners, the changes aren't significant except for a few things such as "print" now being a function. If you can't find any Python 3 tutorials, just learn 2.7; you'll be fine.
Thank you.
This is the response I was looking for, thank you so much.
Okay, thanks. This is the kind of response I was looking for. :)
The incompatibility of 2 and 3 is on the machine side, not the human side. Computers can't understand that `print hello` is the same as `print(hello)`, but any programmer with a functioning human brain should be able to. Just learn both. Learn 3 first, because it is cleaner and a lot of its techniques are considered best practices in 2, then learn the two or three things you need to know to be able to program in 2 as well. Learning the little differences is not that hard compared to actually learning a language.
Sorry, Python tops out at processing 99 files. :-( You'll have to stick to Excel.
Depends on the circumstances. If you were claiming "advanced knowledge of Python" that would make me suspicious and not hire. If you were just claiming to be a beginner, it wouldn't be a problem.
I'm not blaming the failed interview on that. I just froze up and gave poor answers to questions I should've nailed. I guess I remembered the part about enumerate because it felt like one of the good things I was able to take away.
I use `map` and `filter`, but I never use `reduce`, just `sum`.
"Use 3 if you can, 2 if you need to" is a common saying. A lot of the stuff you'll find will be on 2.x - use it. You'll be on 3.x soon enough.
&gt; 2.7 isn't outdated. Yet. 3.2 and 2.7 were developed at the same time, so they share a lot of the same new features. Since both of those were released relatively recently, there hasn't been any time for them to have diverged. When 3.3 comes out in the fall of next year, that's where you'll start to see 3.x pull ahead of 2.7, and every subsequent release will pull further away.
Having tried both, I would definitely use R for stats processing over Python/NumPy if given the choice.
So learn python2 :) No shame in that, python3 is not that much different
That is wrong. A computer can understand print hello just fine. It's the human programmer's choices that matter, not the machine.
&gt;it's "supposed" to be the standard Where did you get this idea? Is it your opinion? &gt;learn an outdated version instead Again, where did you get this idea? I'm curious if you read it online, or if it's just the natural conclusion that you made from the fact that the number is smaller. Edit: Please leave a comment if you believe that 2.x is outdated or non-standard.
Hmm, true, that is a good point.
&gt;Python 3.x is the present and future of the language From Python.org "Outdated" is maybe not the correct word....but "dated" certainly is.
&gt; Why is the community so resistant to the change to Python 3? You're missing the point. It's not about resistance, it's about effort. The change to Python 3 requires entire libraries to be rewritten, some of which are written in languages other than Python (meaning that, unlike Python itself, they are very difficult to rewrite). Imagine that you are Leo Tolstoy and you've just finished an epic novel named "War and Peace" (1,475 pages in a recent paperback). Then someone arrives at your door and says, "We've just declared Russian obsolete, and you need to rewrite your novel in French." A few minutes later, as Tolstoy lies weeping on the floor, the messenger says, "Why are people so resistant to change?" As for me personally, I have a bunch of programs that require the serial communications library, and until that library becomes available in Python 3, you can count me out -- simply because my programs won't run under Python 3. Also, for various deep reasons, my favorite math program [Sage](http://www.sagemath.org), for which I have [written a tutorial](http://arachnoid.com/sage/index.html), also can't be moved onto Python 3 until the libraries on which it is based have been rewritten. It's superficially a trivial change in numbers -- 2.7 to 3. Hell, that's only 3/10 of a version number. But when one discovers what's at work in Python's underpinnings, the superficiality ends . 
that is the worst job posting i have ever seen. seriously it is bad. you neglect to mention what appsumo is. sure people should do a bit of looking into the company if their interest is peaked. requiring beforehand knowledge of the company is crazy unless you are as large as google. overall this job posting doesn't help me get interested in appsumo, if anything it has turned me off from it. drop the goofy crap and post something of substance. then maybe someone will reply.
Quoting your URL: &gt; This article has been moved to http://cafepy.com/article/59/ where you can also post comments. So it's not like shameful content stealing, just the author moving his stuff around.
 if not foobar in ('a', 'n', 's', 'o'): can be written as: if not foobar in "anso": 
If you've already read that [page](http://wiki.python.org/moin/Python2orPython3) of the wiki, you should have a decent understanding of the differences between 2 and 3 and why some libraries haven't been updated to 3.0. &gt;Most of these libraries have people working on 3.x support and it's mostly a work in progress in various stages of completion. For some libraries, it's more of a priority than others: Twisted, for example, is mostly focused on production servers, where supporting older versions of Python is important, let alone supporting a new version that includes major changes to the language. (Twisted is a prime example of a major package where porting to 3.x is far from trivial.) Edit: To clarify, the "of the present" statement about 3.0 just means that that people are already using it, it doesn't imply that 2.X is not of the present. But it is true that 2.X is not the language of the future.
&gt; the author moving his stuff around Fair enough. I suppose I should have paid more attention. 
From a purely educational point of view: No, it's not. It's worthwhile learning any new skill. From an efficiency point of view: You've already got a working system, why change it? Is it severly hindering progress? Is it in-secure? Is it slow? Inaccurate? I have to deal with changes in process in the company I work for and make sure any changes that are going through are actually for the benefit and those questions above are similar to what I have to ask.
They aren't resistant to change just because they like being obstinate or they fear progress. It's because porting a large codebase to py3k is a lot of work. Python 3 changed a ton of things. Moreover, they know that many of their users are still using 2.x, so they can't just change over their code to be py3k-compatible, because then it would lock out the majority of their users still on 2.x. So you either decide to do nothing, and support the majority at the expense of the minority, or you go through your code and either use things like `from __future__ import ...` (which BTW means you can't continue to suppose older 2.x, which is a deal breaker for some) or you invent hacks to make the code work on both versions even though they act completely differently. For some modules, finding those hacks/workarounds is going to take a long time because the changes touch a lot of their code. It's a ton of work. 
&gt; I just meant people seem to hate change in general. I'm not downvoting you, but this comes off as very accusatory at the people doing the free work to build the programming languages you love. Essentially sound like you're out guns blazing accusing these people of being ignorant and lazy. This may be why you are being downvoted. 
I would not. I work with R daily and too many times I have to work around the many inconsistencies of the language (accessing non-existing names in a vector that yields you an empty vector, for example). I use rpy2 to interface R with Python to have a much saner work environment. And where I could, I moved to Python/NumPy/SciPy entirely.
I second that statement. I recently switched part of a project to pandas and it's awesome.
Maybe http://www.knime.org/ is another option worth looking at?
wat
Try [resolver one](http://www.resolversystems.com/products/resolver-one/) Its a spreadsheet that has python embedded. It can also publish webforms i think.
Hating change does not make one ignorant nor lazy, but I apologize if that's the way this came across.
With computer languages, the creation of a new thing does not make the old thing go away. This is particularly true if the old thing is very popular. There is no real way to skip Python2. There is just too much stuff written in it that you will want to understand at some point. If you want to learn Python3 you really have to know both. Fortunately they are not wildly different.
I'd love to switch to Python3. However, until a few important libraries make the change, I'm stuck with python2.7. Thus there is no reason for me to change my code until the libraries I need do. I think it's the same for the authors of these libraries. It's the problem with the chicken and the egg.
Do you understand the difference between a copyleft license and a very permissive license? With a copyleft license like the GPL or CC-*-SA (assuming all developers assign their copyright to a central entity, unlike with Linux but like MySQL and like the OP article advocated) the copyright-holding entity is in a position to lucratively sell non-copyleft licenses to companies who want to ship binaries without source. With BSD/MIT/Apache/X11/etc everyone can do whatever they want to do, and the copyright holder doesn't hold useful exclusive rights which lots of companies might want to buy.
Happens to everyone. Well, you and I at the very least.
At our work we routinely deploy sites that use Plone that are for places that have less then 10 staff. In fact I would sometimes argue due to budgets and what not it is more appropriate in what it can do just out of the box. Be warned though there is a tad of a learning curve to the whole plone environment. From buildout (setting the thing up (although you can use the unified installer which is reportedly easier, which I can't vouch for as I never have used it properly)), to plugins, the ZMI. But honestly with the new plone.app.theming stuff, you can probably get nearly anyone with a bit html/xml/css skill to theme a site, from the usage point of view, I believe it to be decent. Its quite stable and the security is very good. From the point of view with CMSs (I am bias as only having used/developed for a few, blackboard, some small propriety one, wordpress and plone). I would say it feels quite professional/solid. The only major downside I feel with Plone is that deploying it isn't going to be as "easy" as some other solutions (i.e you have to have your own server/vps preferably).
Ah, unfortunately that seems to only emulate a selection of themes as opposed to actually using them :(
I'm ashamed now; I've been using Python very regularly for well over two years, and never knew of enumerate. I shall be fixing my code post-haste. Thank you!
&gt; Plus, I'll admit I personally prefer keeping the documentation in-line with the code, instead of splitting some of it out to files by hand You know Sphinx supports that? Look for `sphinx.ext.autodoc`.
&gt; It's only a marginal improvement to the first case in my opinion - and trades off a tiny syntax improvement with a surprise feature. It's a builtin, it looks nicer, and it clearly *expresses intent*, namely a synchronous iteration on both the list index and its content. An other nicety is that `enumerate` takes a `start` argument since 2.6. I find code iterating "manually" over lists to be far less readable than code simply taking advantage of `enumerate`, because it's harder to see what it's trying to do: is it trying to use the list elements? The list elements and their indexes? Only the indexes to iterate over a related but different collection? Something else? Essentially, `enumerate(lst, [start])` is `itertools.izip(itertoools.count([start]), lst)`
If you can afford to pay a good salary then put that on the advert.
Ok lets assume i'm someone interested: I have no idea what kind of programmer you need, do you use pyramid, pylons or django? Or maybe it's not web work, then maybe I should have gevent experience, or gui... I have completly no idea what do you guys want me to work on etc. That would be the primary reason no one applies i think. You left out all important information and the only thing that is left there is marketing... thats not going to work out pretty well.
Projects like pandas and scikits.statsmodels are aiming to fill in the gaps for doing this sort of thing in Python.
Also, most library authors want their libraries to continue support 2.x (hell, some of them still support 2.3!), which means that besides spending some initial effort on converting to 3.x in the first place, they will have to spend more effort continuously on applying all modifications to both versions of the library. The whole thing isn't made any easier by what I perceive as a gross strategic mistake: we have `2to3.py` which takes away most of the repetitive aspects of porting to 3.x, but no `3to2.py`. Which means that as long as you have two versions of your library, 2.x must remain primary if you don't want to do all synchronizing manually.
I've made several pull requests &amp; bug reports against Pandas, and I can vouch that Wes is very quick to respond - stuff is often resolved within a few hours. Pandas development moves at an impressive pace.
There's accuracy and then there's quality. The resulting documentation from auto-gens is wooden and mechanical, organized by machine based on hierarchy or lexical order. It's not particularly arranged to maximize pedagogy; to assist a user taking that 0-step towards learning your project, and to be honest that narrative does not belong in your code. There's a price to pay with systems like doxygen, javadoc, etc. because users of these systems generally end up littering code with visually noisy and vertical-space-consuming @doc @system @identifiers (i bet these 3 words are the first thing you see when you scan this paragraph). My personal preference is a succinct, prosaic docstring explaining what it does and noting any particularly non-obvious requirements, as this is both helpful to the programmer looking at the code, attractive in documentation, and not visually distracting. YMMV. You seem to like doxygen, and python supports exists; it's more important to have consistently correct documentation (and a consistent feel across your product) than for it to be using a particular tool. Since you asked in `r/Python`, I'll just add that when I find Python projects that don't use Sphinx, regardless of the quality of the documentation, it always feels a bit weird, since so many projects have followed the stdlib's lead and sphinx docs generally maintain a certain feel about them.
Specific note: PyGTK is deprecated: the replacement is the GObject introspection library, which does already work with Python 3 (it's packaged in Ubuntu as python3-gobject). Unfortunately, there aren't so many tutorials for that yet. PyQt is already Python 3 compatible, and there are definitely tutorials out there for that, if you want to do GUI work.
Yes, too many jobs try to be quirky instead of informative, they are also most of the time low on pay If the job post read: Python developer for the web- 100K salary I think the response would be better.
I would only tread carefully if you see mentions about Unicode in Python 2.7. It is a tricky thing to learn imho *and* it changes significantly in Python 3, so do not spend to much time learning the details there if you do not need to.
And in fact I'm using both. ;)
http://www.reddit.com/tb/ljknr
 def should_i_port(reward, risk): return reward &gt; risk
ugh, why voted down? he's right! it's hilarious :D
Rewritten is actually a bit of a big word. True, you can’t just run 2to3 and hope everything will work out, but most people don’t even do that… E.g I have a python3 program that requires dnspython for python3. They have a branch, for that, the 2.X branch is active. The 3.X branch requires something like a 4-character change to work, but it has been several months they haven’t replied to our messages or fixed that yet… Most of the work when porting python 2 to 3 is handling bytes correctly, but it is not that hard (although it will be a pain with BIG libs like twisted and such) ; most of the recent libs have two versions, one for 2.7 and one for 3.X, and there is very little changes between them.
Learn Py3K if you plan to write new code, learn 2.x if you need to interface with existing modules. In fact, if you're willing to be patient you could learn both, since so far the Python team has been excellent at maintaining feature parity between 2.x and 3.x releases. This is going to change with 3.3, since 2.7 is the last 2.x release. That being said, there are a few big differences to watch out for: * There are now two string types: str and bytes. Str is the 2.x Unicode type. It stores Unicode strings in whatever encoding the interpreter feels like. Bytes is a new type which represents encoded binary data. This is a really big change and will pretty much break most binary parsers, but at the same time it makes writing such things much easier as you don't have to deal with the subtle bugs involved with the old implementation. * Division always returns a floating-point value. This can be achieved in 2.6+ with the statement: from __future__ import division * Some modules were moved around or merged to be more logical. For example, the urllib/urlparse libraries are now urllib.parse/.request/.error. 2to3 can automatically adjust most imports. * print is a function, not a statement. * Int is gone, long live the new int. All integers are now bignums. * A lot of functions that used to return lists now return custom list-like objects for iteration. These functions include dict.keys, dict.items, dict.values, map, filter, range, and zip. You can read the official Python 3k [changelist](http://docs.python.org/dev/py3k/whatsnew/3.0.html) if you want to know more. Those are the biggest things I've noticed so far when coding in Py3k.
I think pyserial has a py3k module now, if it helps you at all. http://pypi.python.org/pypi/pyserial 
Even "hating change" is probably too strong there. "Appreciating gains from other activities more (than porting code to Python 3)" is more truthful.
&gt; but the fact that it ties us to Python Sphinx does support C/C++ (it's mentioned on the second paragraph on their homepage), and you can probably document others in a slightly more manual way OpenColorIO is documented with Sphinx, and is largely C++ based: https://github.com/imageworks/OpenColorIO/blob/master/export/OpenColorIO/OpenColorIO.h#L42 https://github.com/imageworks/OpenColorIO/blob/master/share/sphinx/ExtractRstFromSource.py http://opencolorio.org/developers/api/OpenColorIO.html There's maybe more elegant ways, but it works
Learn python 2.7. Many redditors push Python 3 but, from a practical standpoint, not enough people are using Python 3 in production until more 3rd party support is available. Python 3.4 is likely when python3 will become 'the standard'; this is what happened with Python 2. That's still about 3 years away. If you're in college, and you won't be in the work force for another 3 years, then learn python 3. 
I don't see how the IDE being written in smalltalk changes anything (some python IDE are written in python, after all). The problem is that for inference, you need to run code, not just parse it in the case of dynamic typing, and smalltalk is in the same boat as python there. I did not read the details, but one of the paper in the link above explicitly mentioned that they use analysis from running unit tests to know how to refactor things.
I'd suggest you decide how you want to use the Python API, with pseudo-code like example usages.. Then, work out how to map those calls onto the existing command line tools If you just try to emulate the existing command-line interfaces, you'll likely end up with an API that is unpleasant to use
Stick with 2.7.x Check out Python Osmosis (50 tutorial Vids) http://python.secsup.org/ 
&gt; they will have to spend more effort continuously on applying all modifications to both versions of the library. This shouldn't be necessary. Creating one branch per version is the hardest of all porting strategies. People have successfully had a single shared codebase for something like 2.2 through 3.2. I've only done a few 2/3 projects and they've all been able to work in the same codebase supporting 2.6+ whether they're pure Python or C extensions. &gt; but no 3to2.py [Here you go](http://pypi.python.org/pypi/3to2). This is the type of project that will get better with more use, just like 2to3 has. People need to run it and see what works, and if it doesn't work, report it so it can be included and grow to cover more use cases.
Thank you for your clear answer.
&gt;I would say just learn 2.7 You sure that's wise? He'll just have to relearn python 3 when stuff moves to it, which is inevitable
Yes about shell oddities. 'top' embeds escape char's and shell quotes. So if you try to get a string length on one of the lines, you might be in for a surprise. Most programs like top have ways around it, but if you're not on the look out for them, they can trip you up.
yes, it's definitely the correct move if you have any aspiration of using python professionally. it's not like python3 redefines key semantics, it mostly just adds on new sugar that you can always learn later.
We should ask Steve Yegge.
I prefer to have someone who loves to code and what we are doing than just getting paid well.
Yes and no. It does discourage some people but also helps filter people who will get along with our culture. I can see it worth testing to see the volume of candidates by trying a more "traditional" job post.
What's the best way to find them on github?
$100k, laptop, food, beer, fun, etc...
Nope, maybe we should.
Thanks for the feedback Josh. Seems pretty spot on. We are new to hiring so still trying to figure out the best way to make that happen...
I kinda agree but wonder if we do traditional things if we'll get a traditional developer (may not necessarily be bad).
Also, some things will probably be in 2.7 for a longgggg time. ArcGIS released version 10 a little while ago and they use 2.7 for scripting. I doubt they will change it any time soon.
This is something a bit more new and super valuable. Thanks for this feedback.
100% agree on the apostrophes. Drives my gf mad.
&gt; People have successfully had a single shared codebase for something like 2.2 through 3.2. How? First of all, it means that you can't use any of 2.x _or_ 3.x specific features directly, that you have to create a virtualization layer that isolates you from the actual language. You can't use neither print function nor print statement, you must wrap everything that returns strings into unicode-ising wrappers, and so on... That's a lot of effort, and the result is kind of weird, which brings me to the next point: If you target the lowest common denominator, be that with a single shared codebase (however you manage to pull that one out) or more traditionally, by running 2to3 and applying patches that fix the rest of the stuff, what is the incentive to use 3.x then, at all? I mean, you don't use any 3.x features, you are writing your ordinary 2.6 or 2.7, but then for some reason spend some more effort with no benefit for yourself whatsoever. It's nice to think that some carefree Eloi could use your library in 3.x, but as it happens you yourself can't, you have to toil in the darkness in your 2.x cavern. And then they would bother you with their first-world problems! S-so is any one wondering where's the motivation to switch to 3.x? &gt; People need to run it and see what works, and if it doesn't work, report it so it can be included and grow to cover more use cases. Why it's not in the official distribution, officially endorsed and promoted? Why is it never mentioned in any 2 vs 3 discussions, nor in [http://wiki.python.org/moin/PortingPythonToPy3k](http://wiki.python.org/moin/PortingPythonToPy3k)? Why do people prefer to create and promote idiotic shit like "Python 3 wall of shame" instead (yeah, that would _definitely_ work)? It's mindboggling! If someone took an effort to formulate the official 2 to 3 transition plan, like, we go and develop a 3x compatibility layer for 2x, a 3to2 converter tool that converts all new syntax into ugly 2x equivalents using this layer, and tell people to convert their codebase to 3x, develop on 3x, and provide machine-generated 2x versions, I'm sure that we would have had almost the entire ecosystem on 3x by now. As it is, it looks like GvR decided to show SPJ what "avoid success at all costs" _really_ means.
The two things aren't mutually exclusive
Even Python's creator has said that he expects Python 3 adoption to take about a decade. 
Agreed. Ideally it's all the above we want in a person but I want someone who likes us more than just wanting a job. That person wouldn't be a good fit.
.
So people aren't supporting it because others aren't supporting it?
&gt; There's accuracy and then there's quality. The resulting documentation from auto-gens is wooden and mechanical, organized by machine based on hierarchy or lexical order. It's not particularly arranged to maximize pedagogy; to assist a user taking that 0-step towards learning your project, and to be honest that narrative does not belong in your code. &gt;There's a price to pay with systems like doxygen, javadoc, etc. because users of these systems generally end up littering code with visually noisy and vertical-space-consuming @doc @system @identifiers (i bet these 3 words are the first thing you see when you scan this paragraph). My personal preference is a succinct, prosaic docstring explaining what it does and noting any particularly non-obvious requirements, as this is both helpful to the programmer looking at the code, attractive in documentation, and not visually distracting. See, for small projects with a closed team, I *completely* agree that it's generally more useful to just "read the code". But once you have a sizable project with *many* distinct modules/sub-libraries and tons of inter-dependencies then the *only* way to give that project a long life (e.g., make it highly maintainable- I have code that has been in-place, maintained and updated for 15+ years now) is to be as pedantic in documentation as I'm suggesting. Asking a new engineer to the project to just "read the code" when you have a project with thousands of lines of code and many more commits in the repo history is like asking them to read "War and Peace" and understand the context in which it was written. Quality comments and documentation not only tells *how* to use the software or API, but also the story of *how* it came to be in this state (which is generally useful to not repeat the lessons learned in the past :-) As to the accuracy vs. quality debate- I'd argue you just haven't seen auto-gen documentation done right. Most people just use it to scan their code and pick out select comments and be done with it, but if you're doing it that way you're doing it wrong. It is hard to get right, and it does take years of practice and patience writing the documentation. It's a trait that, sadly, fewer and fewer developers have these days. It's also the reason you see so much more disposable code coming from modern engineers whereas a decade or more ago people were writing code to last.... But I digress :-) &gt; YMMV. You seem to like doxygen I do, but I *really* don't think it makes sense in the Python arena mainly because of some of the points you brought up. Doxygen makes sense in C/C++ code (or, really, any languages that make use of headers) because you can put most of the "vertical-space-consuming" documentation into the headers and not have them acting as reading road-blocks in your actual code. At the same time, this extra documentation fleshes out the headers and makes them more understandable (even if you never generate them into proper documentation). In Python, in order to use it properly, your docstrings will wind up being much more massive than is necessary, IMHO. I also agree that coming across Python code that isn't using Sphinx feels "weird". Even though the team I'm working with now has previously been C#-based and, thus, they have no sense of normality with regard to Python (they are learning it), I'm not sure I'd want to train them in non-transferable ways here (which is another concern I guess I probably should have verbalized...) So, I guess what I'm going to do is use Sphinx for the Python code, perhaps a bit of the sphinx autodoc stuff for the C/C++ code we'll have... and then put in place a mandate that all other code (C#, BASH, etc.) must be small and concise so reading it to understand how to use it wont be difficult for a fresh engineer on the project. 
Yes, I did... but if that's *all* you're using it for then your documentation will wind up being (as jmoiron aptly puts it) "wooden and mechanical". And, frankly, if that's all you're using it for then Doxygen would be fine as well and I probably wouldn't have even considered switching as that's what we're already using for our older code.
It's too hard for me to take this add seriously. Plus, it could be your product....it looks like just a bunch of marketing gimmicks; not something from a 50K ft view that I would be interested in working on.
Neat! I do wonder if the most popular guys/girls just get harassed all the time. What's the best type of message you want to respond to?
Messages are interruptive — so just be honest and respectful. 
Also, I ignore a message that comes to me if it's obvious they have no idea who I am. 
That is what your interview process is there to accomplish. What we do is take our candidates out to lunch in a very casual environment and first get to know them as well as we can over and hour or so. Next, if we think they are a good mix with our core group we bring them in for a formal interview to gauge their interests (we want happy coders) and their chops. After that we move forward with a second interview if necessary and tender an offer if we think things will work out. 
you are going to piss alot of people off if you limit how they are going to work. if you are paying them a 100K, you should be able to get them a desktop with dual monitor setup ( my preference) or whatever they need. 
JCaustin. I agree with you (partially). Where we are going is pretty exciting and why we need someone to help us get there...
Neat. What I'm finding most challenging is just finding candidates I can even take out to lunch....
Oh. They can get whatever they want :)
&gt; How? First of all, it means that you can't use any of 2.x or 3.x specific features directly, that you have to create a virtualization layer that isolates you from the actual language. I can't think of any 2.x-only features, but there are several 3.x only features that you'd have to hold back from using. There are also backports of several 3.x libraries, e.g., `unittest2`. I've never created any virtualization layer that you speak of, although I would guess that's how you handle `bytes`/`unicode` differences. `bytes/unicode` isn't a problem I have to deal with, so my porting and dual-version work has been really easy. Having a dual 2/3 program isn't a life-long commitment to pain. It's a transition, and part of that transition is also moving your 2.x code as far up the 2.x line and dropping the oldest 2.x versions as early as feasibly possible. If you can drop 2.4 and have 2.5 as a minimum, you can use the `with` statement. If you can get yourself to 2.6 as a minimum, you can pick up the print function and start to use other future items. As your user base moves towards 3, you begin to pull up on 2, and eventually pull out of it entirely. &gt; what is the incentive to use 3.x then, at all? 2.x is dead. 2.x is over. 2.7 is the end of the line. Need other hints? &gt; I mean, you don't use any 3.x features, you are writing your ordinary 2.6 or 2.7, but then for some reason spend some more effort with no benefit for yourself whatsoever. This is a self-imposed deadline on the benefit. What's Python 3 going to do for you *today*? Probably nothing if you don't like it. If you're going to be around in a few years, I don't understand all of the resistance. Either you spend some effort now and grow into it, or you abruptly jump in 4 years when people are literally begging for it. Whatever works for you. &gt; Why it's not in the official distribution, officially endorsed and promoted? It's incomplete and needs to grow quicker than Python itself does. Even 2to3, while included in the standard library, grows in a sandbox for external release. 3to2 may be able to do the same thing, but I don't think you'll see the Python core team "endorse" a project that goes against their plan (3.x is the future, 2.x is dead). A lot of them, myself included, like and *personally* promote it, but it's not something you'll see on the front page of python.org or something. &gt; Why is it never mentioned in any 2 vs 3 discussions It is. It comes up in most of the discussions I've come across. &gt; nor in http://wiki.python.org/moin/PortingPythonToPy3k? That's a wiki which anyone could edit. I hate wikis so I'm not editing it, but feel free to do so yourself if you want it up there. &gt; Why do people prefer to create and promote idiotic shit like "Python 3 wall of shame" instead (yeah, that would definitely work)? This is a good question. Some of those types of sites have been informational on what's in what state, but "wall of shame" is stupid.
&gt; The 3.X branch requires something like a 4-character change to work ... In the world of computer science, these are known as famous last words. :) After making such a change, one must assess what consequences that change will have elsewhere, then retest everything. &gt; but it has been several months they haven’t replied to our messages or fixed that yet… Quite understandable, from a software maintenance and reliability perspective. For perfectly encapsulated code and strict coding guidelines, a small change is rarely a problem, but there is very little perfectly encapsulated code in the wild. I speak as someone who has been writing (and rewriting) code since the days of the Apple II. 
I like Sphinx, Mostly because A) It's plain text, even if it is reStructuredText, and not my preferred, markdown. and B) ReadTheDocs.org support with git/mercurial. (It also does include autodoc support, for things that autodoc is useful for) http://sphinx.pocoo.org/ext/autodoc.html
Real geeks don't mention they are geeks in job descriptions, they just put out a python programming puzzle to filter out incompetents. Your ad reeks of programming hipsterness which is a trend where mediocre (especially web) programmer feigns geekish interests in order to signal intelligence. On another note, I actually saw a video of AppSumo on mixergy years ago and have a fair amount of respect for the founder. Good luck on your search!
I already have resolver one, but I found that it's buggy and has slow response time. It's just a spreadsheet but I can put in python functions within cells.
each of them has there advantages and disadvantages. python is definitely a (by far) more universal tool... 
The differences aren't that big. I started with Python just after the Python 3 was released and I've never had any difficulties with learning or difficulties using different versions. It's not a new language, for the frontend user the changes are minimal. 
&gt; 2.x is dead. 2.x is over. 2.7 is the end of the line. Need other hints? I still can use 2.7, it still gets security updates, it's still being supported by any library worth using, that's not what I would call "dead", not by any measure. What's more, right now 3.x just doesn't have any interesting features that would make even a cold-turkey switch worth it. Except for a bit more sane Unicode support. Everything else is in 2.7. _If_ at some point it gains more interesting features, I might reconsider, right now there's almost nothing attractive about it, except for "being the future" but I'm too old to buy into bullshit epithets. Furthermore, if I have to support both versions, then "almost nothing" turns into plain "nothing". So as far as I'm concerned, it's 3x that was born prematurely and is still on full life support in an incubator, while 2x is as alive as ever. &gt; If you're going to be around in a few years, I don't understand all of the resistance. Either you spend some effort now and grow into it, or you abruptly jump in 4 years when people are literally begging for it. I wouldn't have to support two versions of the interpreter for 4 years. I can't "grow into" anything as long as I have to support 2.x, and then it would be better to "grow into" 3.x properly. I avoid being a guinea pig for porting tools, freshly ported libraries I want to use, Python 3.x itself, etc. `doctest` comes to mind, I think it was the last straw after which I lost all interest for 3.x. And, of course, I'm never at risk of discovering that some library doesn't even support 3.x. &gt; 3to2 may be able to do the same thing, but I don't think you'll see the Python core team "endorse" a project that goes against their plan (3.x is the future, 2.x is dead). This is totally backwards. While we have only 2to3, 2.x remains the present and 3.x will forever remain the future. To make 3.x the present and 2.x the past we need 3to2. I don't know honestly, some big projects are moving forward nonetheless, so I wouldn't bet against the possibility that in four years from now a critical mass would be achieved, by natural means, i.e. just by the raw accumulated effort. But I see absolutely no reason to participate in this, especially not when I have to invest much more effort than necessary because doing it the right way goes against the vision of the ones responsible.
I do not mean to tell people how to handle their tests, their releases, etc, but I would rather have something buggy than something that cannot even run.
My point is that explicit getters and setters allow the addition of keyword arguments that change the specific behaviour *on a call-specific basis*, whereas properties limit you to a single "get" and "set" behaviour, as does overriding `__get__` and `__set__`. Moreover, using properties means that such optional behaviour modification can't be introduced at a later date without breaking client code. There can be a lot more to modifying object state than simply returning or replacing a value, and there are occasionally very good reasons to have explicit `get_` and `set_` methods, where properties are simply not up to the task.
PyCharm...refactor away!
Yup, didn't see you guys so I posted for PyCharm as well. Love it.
Very good analogy. Though 2.7 is supposed to be abandoned eventually, I dont see it happening soon. 
There is something I still don't understand in this debacle. Why is it not possible to have both python 2.x /and/ python 3.x installed, with an interface that allows calling python 2.x libraries from python 3.x? We can call C from python 3. We can even call LabVIEW from python 3. And vice versa - you can call python from C and from LV. But we /cannot/ call python 2 from python 3?
&gt; I would rather have something buggy than something that cannot even run. Then it's just as well that software management is in other hands. Your consequences arising from buggy software are apparently slight. But the consequences elsewhere [may be horrific](http://catless.ncl.ac.uk/Risks/8.77.html#subj6). 
Python is far easier than excel macros. Also, fuck excel macros. My boss once gave me a huge data analysis file with excel macros for piecing together 3databases and analyzing about 30 columns of data. Goddamn mess. I gave up trying to figure it out and just wrote out a few handy python functions. Also, if you need help reading and piecing together excel files, pm me.
Same here. R was just too much to handle. I am not a statistician by trainig,nor a programmer, I do not want to fight the language, just develop smooth algorithms.
&gt; But I see absolutely no reason to participate in this Yeah of course, just let everyone else do it.
I wonder how you came to the conclusion that I wanted them to release something buggy. I was talking about the fucking trunk, and a guy who will take code from the trunk to put it in something critical, without testing it, is a complete moron.
An em dash is not an appropriate substitute for a bullet point. You are advertising to programmers—a group known for their anal nature with respect to punctuation—and this does not bode well.
&gt; I wonder how you came to the conclusion that I wanted them to release something buggy. I wonder how you came to the conclusion that I came to that conclusion. Maybe you could find a quote that supports this idea. 
Once you know Python, it's not all that hard for you to learn another version of it. You probably should have learned 2.x first, and then used that knowledge to quickly pick up 3.x.
Actually, Python 3 is more about cleaning up a load of leftover oddities, rather than adding anything. Things like old-style classes, input vs raw_input, range vs xrange, and so on. Perhaps the biggest selling point is that it's easier to learn, because you don't have to know about those differences.
a feature use relatorio for output to odt and then to all formats!
By location and language search. Example: location: Boston language: Python
They're both pretty similar so it won't hurt to learn 2.7 first. You could always get the Python Essential Reference. I feel the author did a good job of splitting out the differences between 2 and 3. There is also the python 3 tutorial at python.org http://docs.python.org/py3k/tutorial/ and all the other documentation on http://docs.python.org/py3k/index.html You will find if you want to use other people's libs they'll often be for python 2 only but keep in mind Python 2 isn't going to get update any more. It may be painful now but Python 3 will come out on top eventually. 
I read the report when it came out. If I remember correctly, the primary issue is that google has relatively few apps, but each has an enormous customer base. So, in their case the economics favor the fastest possible language over the fastest to develop a solution within.
&gt; Yeah of course, just let everyone else do it. Yeah, of course, "don't ask what Python can do for you, ask what you can do for Python". It is not my fault that the people who are responsible for shaping the present to produce a better future for everyone, shaped it in a way that requires other people to act irrationally if that future is to be realized. All the while it is not only possible, but not even very hard to shape it in a way that makes enlightened self-interests of the participants aligned towards the common good. I consider this approach to be ultimately destructive, and I'm not going to support it.
What are you even going on about now? In the end, it's seriously not that hard. It's a non-zero effort, but it's becoming one of those 99%/1% cliches.
&gt; hell, some of them still support 2.3 I'm one of those library authors. People still download the Windows binaries for 2.3 so I'm not going to take it away. See [downloads here](http://code.google.com/p/apsw/downloads/list) to get an idea of the popularity amongst Windows users. I can't tell from downloads of the source which Python version is used. &gt; they will have to spend more effort continuously on applying all modifications to both versions of the library While modern source control systems can make that relatively painless, most projects do not do that. It is easier most the time to support all Python versions from the same code base. &gt; which means that besides spending some initial effort on converting to 3.x in the first place, I made my code support Python 3 while it was in beta (July 2008). Do I get a gold star :-) Supporting Python 3 wasn't that much work for the main codebase. The vast majority of time I had to spend was on my test suite as I do 99.6% code coverage and check for errors everywhere meaning I had to be able to cause (or sometimes simulate) all the errors, not to mention the different syntaxes, types and quirks of the various Python versions. But not everything is due to Python - for example my test code needs 60 lines in order to delete a file because of Windows (tag alongs and deleting files while open issues). 
&gt; You can't use neither print function nor print statement, print ("this works on 2 and 3") &gt; returns strings into unicode-ising wrappers If your string is not already unicode then it isn't really a string, just a [bag of bytes](http://www.joelonsoftware.com/articles/Unicode.html). &gt; If someone took an effort to formulate the official 2 to 3 transition plan They did. The expectation was it would take 5 years. The transition is [right on plan](http://sayspy.blogspot.com/2011/01/my-semi-regular-reminder-that-python-3.html).
Yeah, it's because Guido won't do a Tail Call Optimizer. 
I added nothing to the conversation :P understandable.
Try python as an exploratory process. Read the files calculate a few numbers and see how much hair you have lost. Matlab seems to be a little more interactive. I've made some simple data analysis/gui applications before in python and it wasn't too bad.
I failed to find any other case in which you would be glad that software management is not in my hands, so I came to this conclusion. I also fail to see how making something work would be worse than having it broken.
Learn the 2 series then. There isn't that much difference to really matter.
Don't even think about 3 for a while. The cons of being an early adopter of a new language or platform usually outweigh the improvements. Yeah, I know 3's already been out for a few years but it's still relatively early. For people trying to create tangible things, it's often a lot more enticing to develop product enhancements than to fix things that don't work in 3.0, particularly if the new features in 3.0 aren't really needed.
&gt; I also fail to see how making something work would be worse than having it broken. Yes. Unfortunately this outlook has nothing in common with the topic. The present version is not broken, but updating it to Python 3.0 without appropriate attention to detail might break it. 
I recommend checking out [GitHub](http://github.com) for a bunch of projects already in process. You can jump in and help them, or start one and ask for help/advise/interest here. 
I went through the same thing. My solution was to insist on strict py3 and waste all my time converting and ploughing through it like a stubborn mule. :)
It would be nice to have a Free cross platform automotive scantool that uses the ELM/scantool.net style interface.
I really like this idea! Now how many people want to work on this? I figure step one is finding info on OBD standard. I'll see what I can find. 
I would like to see it reddit centered. Hopefully help with reddit awareness. 
What OS are you using? If it's Linux, something like puppet might be useful. The system we are using at my day job combines puppet with custom built RPMs installed into /opt. It works pretty well.
Looks like there is already a project for this. http://www.obdtester.com/pyobd Which brings me to this question. Is it best not to reinvent the wheel or see if it can be done better?
If you really want to perform a community service, and if you are a skilled, experienced programmer, volunteer to rewrite any of the many Python libraries that need to be revised to work with Python 3.0. There are many, and the unfinished work is holding back adoption of python 3. 
have a look at * https://github.com/sebastien/cuisine (a light layer atop fabric) * https://github.com/fabric/fabric
I might be interested if you have some Python experience. Shoot me a message sometime. 
I really hope that someday I can be that skilled and experienced, but at the moment I will have to stick to public projects. 
Why wouldn't these projects be public? I think lutusp's suggestion is a very good one. If you want someone to code review your patches, why not post them here before submitting them officially?
&gt; help with reddit awareness. It's one of the most popular websites on the entire internet. What awareness does it need?
Python 3 isn't a big enough improvement over Python 2 to be worth the effort of porting to an incompatible language. If I'm going to go to the effort of using a new language, I might as well wait for ECMAScript 6 - it seems to be stealing all of Python's good features anyway (and adding a few that Python ought to have).
public was a poor choice of words. I just don't think I have what it takes to get things patched over to python 3. 
Cuisine looks cool, thanks. Also take a look at [virtualenv](http://www.virtualenv.org/en/latest/index.html) - it's a really awesome way to manage packages (and specific versions of those packages).
Could always be better no?
Sure, but who cares? *It's a website.* Plus, logically, what kind of project are you going to do to raise awareness for a website? Reinvent ads? I think you should probably go with something else.
I haven't really tried anything else and Im new to python as well but virtualenv is really great. It also has a virtualenvwrapper.sh script which makes your life easier. Also, using pip is a good idea to keep track on what packages you're using in each env
Just so you know, you can read/write excel ss from python.
I was think more along the lines of a reddit community project. Not really q project to make reddit better. 
We use virtualenv, pip, south, and fabric to almost completely automate our deployment process. I can change schema, add new dependencies, or sync our production database down to any of the other environments (staying, test, or dev) with commands as simple as ”fab deploy_prod”, ” fab deploy_stage”, or ”fab pull_prod_db”. It's awesome! Ping me if you have any specific questions about our setup.
I've used python a lot for number crunching things. The basic idea is that whenever possible, you want to use functions/modules that are compiled directly from C code. In this article, the numpy implementation has a huge speed advantage because the entire numpy library is written in C and compiled to work with python. In some situations, I could not find what I was looking for in a compiled python library, so I wrote my own libraries in C for the functions that I wanted and saw similar performance improvements. If anyone is reading this and wants to know where to start, just google "python extension" and you'll find a wealth of knowledge pertaining to writing your own compiled modules. Its pretty easy once you get the hang of writing modules in C (or java if you prefer).
Screw loops! Use string slicing temp = '480045004C005000' print ''.join(i for j in zip(temp[::4],temp[1::4]) for i in j) 1 line -- BAM The operation temp[::4] keeps only every fourth element of the string. Likewise, temp[1::4] keeps every fourth element starting at position 1 instead of 0. Then all you have to do is interleave the strings with zip() and extract (in order) each element of the resulting list and join() them into a single string.
That's implied by the topic of this thread you created, but that's not what you've been replying about. Feel free to create whatever you want - I'm just confused by the whole thing now.
Maybe this is a slower way to do it, but it will make variables dynamically based on the keys of your dictionary: for key in region.keys(): exec "%s = region[\'%s\']"%(key,key)
Yup, I'm using Linux. I started on Ubuntu 10.04 and that's still what's running in my production environment. I've been shopping around to decide if I want to continue using Ubuntu or switch to another distro soon.
This looks alot like openerp, is it a fork?
I might take you up on that offer for specific questions later. Thanks for letting me know about those packages. I'm still trying to absorb the basics of everything, and find out what's out there.
Right now, virtualenv is the standard, but people are proposing to add something like it to Python 3.3: http://mail.python.org/pipermail/python-ideas/2011-October/012500.html
Yes, the descriptor protocol is meant for an attribute computed from the current state of the class/instance. I suppose you could factor the logic into a helper `set_` function that uses the current state + outside information to pre-compute a value ready for the general descriptors. While I'm not a OOP expert, I wonder though about such a design. Could you give a simple example? Maybe a more fine-grained object composition would eliminate the need for such a complex getter/setter. On the other hand, maybe it isn't worth worrying about. Sometimes people can obsess too much on the details instead of just getting the job done. 
I do something similar except there's one nuance; I create a function for each environment that does the connection. So for me, it's `fab dev deploy`. I have a helper in [my Django skeleton](https://github.com/jordanorelli/Django-Skeleton) so that for each environment I just put the conf in a file. e.g., the dev environment file would go in conf/dev/hosts.py and would contain a list of dictionaries, each one representing a machine belonging to that environment.
Jesus, kid. Suck it up and use 2.7! They are both the same language. If you want to dabble in 3.2 features run the 2to3 tool on your source. You should have better things todo than complain about this. Go write some code.
You sure know how to make a programmer feel special. Talk nerdy to me. Seriously tho, I don't know if I should feel proud or ashamed that I understood that title.
&gt; An other nicety is that enumerate takes a start argument since 2.6. TIL. Thank you very much.
Yes, it's a fork of an older version (4? Something like that). The lead developer clashed with the openerp boss-man, and left to realize his vision. I think they rewrote pretty much all of the server code (not sure about the client).
Metaclass is the class of your class. In other words, your class is an instance of its metaclass. Usually, the metaclass for things is just `type`, but you can set it do other things. Doing so affects how the class itself gets instantiated. &gt;&gt;&gt; class Meta: ... def __init__(*args): ... print("Setting up...\nArgs: {}".format(args)) ... &gt;&gt;&gt; class A(metaclass=Meta): ... pass ... Setting up... Args: (&lt;__main__.Meta object at 0x100713090&gt;, 'A', (), {'__module__': '__main__'}) &gt;&gt;&gt; type(A) &lt;class '__main__.Meta'&gt; 
Neat. I'd like to see this used by Pygments.
Python's biggest problem is it's dependencies. I contemplated trying to convert some 20 year old routines from BASIC to Python. A 90kb exe could potentially become tens of megabytes. What a disgrace.
It's probably a good way to learn about Python coding, and practices like submitting pull requests or patches. Bits of it can be tricky, but there are good resources, and plenty of people to ask if you get stuck. Just remember to have a search to see if there's already a Python 3 port of a package before you start working.
Yes, `virtualenv` is your bread and butter. It includes `pip` since version 1.4.1 i.e. no need to separately install it anymore. While `virtualenvwrapper` is not mandatory, it's something that I recommend for your workstation as it makes a lot of things a lot easier/faster. Regarding virtualenvs... note that the default behavior of creating non-isolated environments will change i.e. using `--no-site-packages` will not be necessary anymore in the future (possibly with v1.7). Here's a link to my website that might help you a bit: http://www.markus-gattol.name/ws/python.html#virtualenv_virtualenvwrapper **Bottom Line**: you use virtualenvs with fabric (and possibly cuisine) to streamline your sys admin, bootstrap, deployment tasks.
Out of interest, what libraries would those be?
Teach me your trolling secrets.
I would think that a less quirky ad leads to more applicants. In the interview process, you can find out if it is a fit. Trying to weed people out in this way in the ad cannot go well, as you will be weeding out good fits as well as bad ones.
What were you even thinking, restricting a dev to a laptop? 
The software computes the coefficients for a linear antenna pointing error model (i.e. least squares fit) used by engineers not in a development environment (i.e. Windows). If I were to update this DOS interface to 2011 using Python, I would potentially use PyQt4 for the interface and NumPy for the linear algebra routines. Including the bundled Python interpreter, you can see how this can balloon up to 20 mb. Or I could use SWIG to include the original C linear algebra routines from 1990, then bundle it into an exe which would probably be &lt; 10 mb. That's a really roundabout way though. Come at me and suggest a minimalist solution that still uses Python.
&gt; if that's all you're using it for then your documentation will wind up being (as jmoiron aptly puts it) "wooden and mechanical". Absolutely. Personally, I quite hate generated API docs, also because they are often completely trivial: getX(), documented by "gets X".
The problem with virtualenv is that you still need to do a lot of maintenance on the server to manage each custom environment. I personally prefer zc.buildout as it allows me to have exactly the same environment both locally and remotely. Saves a lot of hassle while developing on my local machine using Python2.7, running the unit tests on a Jenkins server stuck on 2.6.2 and deploying to a server running 2.6.7. The main benefit of zc.buildout is when I'm collaborating with someone. Any 3rd-party module that is required by the codebase is included in the buildout.cfg file. If I add a new library I don't need to worry about informing my collaborators since the next time they pull the code and "buildout" they'll have the new packages automatically installed. Same with deployment. This isn't really possible with virtualenv; you still have to remember to easy_install all the modules you require. Can't tell you how many headaches I had with deployment because of that! Rather than using fabric et al, my set-up is much simpler: zc.buildout + jenkins (which handles unittesting, tagging and deployment).
haha. I wasn't. Can get whatever they want.
This is actually pretty hard core. I even through in a NOT statement. Thank you mucho!
Agreed and great username
Thanks. I'm the chief sumo, founder just sounds weird. That might be a fair point. Next ad I'll try something a bit more traditional. Appreciate the feedback.
Choosing to use NumPy and PyQt4 is somehow the language's fault? Seems more like a side effect of your "update the DOS interface to 2011" plan. If you want some minimalist, size conscious deployment, you'll probably have to pick and choose better than bundling that all together as it comes off the web.
If size wasn't an issue, I'm certain those modules would be the best practice solution. 
Yep, and OpenERP is as free as Tryton (depending on your definition of free).
Well yeah but it is, and you're also (from what I can tell) planning to move from a "DOS interface" (which I'm guessing just means command line) which has zero cost in terms of binary size, to implementing a GUI. If you need a GUI, you will need to bite that bullet, but you could probably strip any GUI library in half or less to get what you need out of it. You can also strip down your Python install by removing unneeded libraries to bring your full bundle size down. Just removing the tkinter-related stuff, which you wouldn't be using if you're doing CLI or external GUI toolkit, looks to save about 7 MB based on an installer from python.org. I'm sure you could nickle and dime and remove a lot of the standard library as well.
We have a relatively new subreddit that needs some love from people like yourselves: www.reddit.com/r/collaborativepython Feel free to post any ideas for projects and the kind of people you're looking to pick up for it.
My humble suggestion, also check out /r/learnpython def getIfaces(): """ Helpful doc string. Return a sorted list of unique interfaces from /proc/net/route """ #use a context manager with open('/proc/net/route','r') as f: #skip header next(f) #grab interfaces #use set for uniqueness testing #one pass generator expression ifaces = set( x.split()[0] for x in f ) #use sorted on the set to sort return sorted(ifaces) #main block for debugging and for use as stand alone script if __name__ == "__main__": print getIfaces()
Thanks - much neater and shorter.
Well that has *a lot* to do with how well someone documents the code. The documentation skills of modern engineers seems lacking, IMHO, so I'll readily admit that I have a hard time finding good API docs (other than MSDN, sadly... the one thing they *really* excel at is writing comprehensive API documentation.) But for that- don't blame the tool that generated the docs, blame the tool that *wrote the in-line documentation*. *Edit*: BTW... GIT SUCKS! HAR HAR HAR! *(In RES I have you tagged as "git-weeny" as opposed to "hg-weeny" or "bzr-weeny", so at some point in the past I must have observed your undying love for git... So suck it, git lover! :-)*
PyGI is pretty similar to PyGTK. It took me less than an hour to port moderately complex PyGTK code to PyGI. Even simpler code can just be ported by changing import gtk to from gi.repository import Gtk as gtk Documentation is a little bit lacking, but I've found I can manage by looking at the old PyGTK documentation and the current Gtk documentation.
The python.org document on [how to port to 3.0](http://docs.python.org/py3k/howto/pyporting.html) mentions 3to2 on the first page - _before_ 2to3. I do believe that your misgivings are in some way justified but it's hard to see what else could be done. Give it time...
Bluemanshoe's suggestion is good. This is what I did (not tested since I am on Windows): def getIfaces(): with open('/proc/net/route/route') as route_file: return sorted({row.split()[0] for row in route_file if row.strip() and 'Iface' not in row}) 
I have to say that, while I agree with the concerns expressed, I think this is a bit of a tempest in a teapot. First, it's pretty clear to me that, even though the move is going slowly, there was no other course of action. And are we in a rush, anyway? Seems to me that there were only two options - keeping backward compatibility with Python 2.x forever, or not. Of the non-backward compatible changes in Python 3, there were several at least that desperately needed to be made - returning an iterator instead of a list for the various view operations springs to mind immediately, because it's _much_ more efficient if you're using large dictionaries (i.e. O(1) instead of O(n) to construct!) and allows you to have virtual "dictionaries" for things that are too big to fit into memory. So given that you are going to have to have some backward incompatibility, I can't see a way that it could have been done better. But second, the differences are small enough that you _can_ in most cases write code that will work on both 2.7 and 3.x. The big feature that's incompatible is the print statement, which has become a function as it should always have been. I was surprised to look through my Python programs and discover that I made very little use of print in my finished programs - I use write almost everywhere, I only use print for error messages, and the reason is that in my finished programs, I am generally reading and writing to streams which might be something like stdout or something like a file that the program has opened. But if you're writing to 2.7, you can easily use the new style print statement in your own modules without affecting any other 2.x-only packages - just start your files with the incantation: from __future__ import print_function Now, what about the dictionary functions being iterators? Again, I was pleasantly surprised to discover that I'd always believed they were iterators and never treated them as a list. You can write code that works for 2.x and 3.x by always casting the result of dictionary access functions to be a list (or tuple) if you need to index it or perform other list-style operations. The "byte literals" issue won't be an issue for 90% of the programs out there, because almost all 2.x Python string constants will be 3.x text literals. Other incompatibilities which you can avoid include losing relative imports (which was always a bad idea anyway) and no longer being able open files without specifying 'b' (which didn't work on Windows anyway). The canonical manual is [here](http://docs.python.org/py3k/howto/pyporting.html). In particular, I'd recommend adding all the "import future" commands that they suggest in this manual as a matter of course in all 2.7 code you write.
&gt; Well that has a lot to do with how well someone documents the code. Yes, but still, I can't count the times that I wished for a single tutorial how to use the code, instead of pages of more or less useful API docs. For me the Python-docs (even pre-Sphinx) did the proper thing: a meaningful documentation with simple examples as well as a comprehensive reference of the API. Some say PHP did it even better, though the comments are said to have atrocious example code that others mindlessly copy. I think I'm leaning towards redacted documentation. &gt; Edit: BTW... GIT SUCKS! HAR HAR HAR! Heh :-) I used both Mercurial and Bazaar, but these days it is mostly git, because it is everywhere (that said, I only contributed to Mercurial). And sometimes I think git sucks, myself. But the other systems suck in some other ways and no one has a nearly comparable community. Except for SVN, pardon the joke ;-) Maybe I should write an article about 6 years of DVCS, actually that might be a good topic.
See [Code Like a Pythonista](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html).
I would probably have made the ifaces = set( x.split()[0] for x in f ) be ifaces = set( x.split()[0] for x in f if x) to prevent possible index errors on empty lines.
&gt; a meaningful documentation with simple examples as well as a comprehensive reference of the API. And that's the *right* way to do it. Whether you're doing it in Doxygen, Sphinx or just writing it by hand. If someone is just throwing Doxygen or whatever at their stock codebase *without* properly writing up usage and other information in it then they are doing it wrong (and that seems to be the way *many* people wind up doing it). But Doxygen (as I said elsewhere) seems to make more sense if the language has header files, because then you're not mucking up your code-proper with flow-stifling prose. 
This is a great framework to watch for SSH Calls. I am just waiting for them to fix an issue with init scripts not actully running the service.
I would probably use scapy because I'm a cheater who likes to steal free code.
I know that the PyPy guys read this subreddit, so I have some quick questions, if they have a minute: - Why are generators slow? - Are there any plans to change re.sub? - Can anyone provide technical background on why This: for c in s: # s is string del c is faster than this: for c in s: # s is string pass ? Thanks in advance!
a) They aren't slow, they're slow*er* than non-generator code. We're not fighting CPython Python code here, we're fighting C code, sometimes you gotta play dirty ;) b) No, it's very application specific. c) I can explain it, but it's very very long, and very technical, do you want me to write it up?
Haha, good spot! * generators have to keep frames alive. They can be sped up, but it's more midterm than immediate. * changing re.sub - yes it can be done by lazily allocating a string only when first match is hit. in fact I'll do it just now. * the last one is a peculiarity how string optimizations propagate over loop boundaries. As I said it's generally a bug (although just makes stuff slower). EDIT: Sorry, I was wrong about the re.sub, it's something much sillier, the optimization is already there
Seems like you and fijal responded to me within 4 seconds of each other - thanks to both of you! In order: a) Hah, fair enough! b) Is this something that you see being fixed? c) If you have the time (and inclination :-P), I'd love to hear more about it. I've been following the development of PyPy for a while, and I love hearing about the technical details.
Seems like you and kingkilr both responded within about 4 seconds of each other - thanks for the explanations!
To (c): PyPy's optimizer uses an idea called virtuals to optimize the code, there's a paper we wrote about them somewhere. Essentially the idea is you want to avoid allocating values if you can prove they don't escape. One of the neat tricks is that you can do this even at the end of a loop, as http://morepypy.blogspot.com/2010/09/using-escape-analysis-across-loop.html describes. Internally the way we do this is you have a special class for different types of virtuals, so right now we have array of primtives (integers, floats, pointers), array of structs, strings, unicode, low level structs, plus a few special representations of string/unicodes (not relevant). These all inherent from a certian baseclass, and have various ways of interacting with the optimizers. This base class (technically a helper class, but that's not really germane) has a basic "what to do at the end of a loop" implementation, which by default simply allocates the object and fill it's constituents with data. These classes *can* however implement a specialized version of this API which knows how to do smart things, so it can remain virtual across loop boundaries, as the blog post describes, simply no one has done it yet, I don't even think it's particularly technically complex. So atm the ``pass`` code generates operations which look like: [112c0dfe3740] {jit-log-opt-loop # Loop 0 : loop with 16 ops [p0, p1, p2, p3, p4, p5, p6, i7, i8, p9, p10] i11 = int_ge(i7, i8) guard_false(i11, descr=&lt;Guard4&gt;) [p1, p0, p6, p9, i7, p10, p2, p3, p4, p5] i12 = strgetitem(p10, i7) i14 = int_add(i7, 1) setfield_gc(p6, i14, descr=&lt;SignedFieldDescr pypy.objspace.std.iterobject.W_AbstractSeqIterObject.inst_index 8&gt;) guard_not_invalidated(, descr=&lt;Guard5&gt;) [p1, p0, p2, p3, p4, p6, i12, None] i17 = getfield_raw(42497272, descr=&lt;SignedFieldDescr pypysig_long_struct.c_value 0&gt;) i19 = int_lt(i17, 0) guard_false(i19, descr=&lt;Guard6&gt;) [p1, p0, p2, p3, p4, p6, i12, None] p21 = newstr(1) strsetitem(p21, 0, i12) jump(p0, p1, p2, p3, p4, p21, p6, i14, i8, p9, p10, descr=&lt;Loop0&gt;) [112c0e057796] jit-log-opt-loop} You can see the ``newstr(1)`` bit at the end, whereas the ``del`` version generates: [11599036f608] {jit-log-opt-loop # Loop 0 : loop with 15 ops [p0, p1, p2, p3, p4, p5, i6, i7, p8, p9] i10 = int_ge(i6, i7) guard_false(i10, descr=&lt;Guard4&gt;) [p1, p0, p5, p8, i6, p9, p2, p3, p4] i11 = strgetitem(p9, i6) i13 = int_add(i6, 1) setfield_gc(p5, i13, descr=&lt;SignedFieldDescr pypy.objspace.std.iterobject.W_AbstractSeqIterObject.inst_index 8&gt;) guard_not_invalidated(, descr=&lt;Guard5&gt;) [p1, p0, p2, p3, p4, p5] i15 = getfield_raw(42497272, descr=&lt;SignedFieldDescr pypysig_long_struct.c_value 0&gt;) i17 = int_lt(i15, 0) guard_false(i17, descr=&lt;Guard6&gt;) [p1, p0, p2, p3, p4, p5] jump(p0, p1, p2, p3, p4, p5, i13, i7, p8, p9, descr=&lt;Loop0&gt;) [115990470b20] jit-log-opt-loop} because it doesn't need to pass the character back to the top of the loop, since the local var no longer exists. I hope that helps (but I suspect I suck too much at explaining for that). Feel free to ask more questions :)
Sure he could go about and do so. But that would leave not much room for trolling, would it?
Somebody made nice use of this to visualize the language use on twitter: http://www.flickr.com/photos/walkingsf/6276642489/
there is requirements.txt which you can use to build a complete virtualenv with all the libs you want using pip. http://www.pip-installer.org/en/latest/requirement-format.html
&gt; I still can use 2.7, it still gets security updates, it's still being supported by any library worth using, that's not what I would call "dead", not by any measure. Perhaps dead is a stretch overall, but dead from an evolutionary standpoint is correct. "not growing" is probably a more friendly term. &gt; What's more, right now 3.x just doesn't have any interesting features that would make even a cold-turkey switch worth it. Except for a bit more sane Unicode support. Everything else is in 2.7. If at some point it gains more interesting features, I might reconsider, right now there's almost nothing attractive about it, except for "being the future" but I'm too old to buy into bullshit epithets. What you and most people don't seem to realize is that 3.2 and 2.7 added pretty much the same feature sets (to an extent) because they were developed by the same people at the same time, and they were released nearly at the same time. The point where divergence between feature sets will take off is 3.3, which is coming next fall. People seem to have this "now now now" attitude with Python growth and adoption. This is a project which has to take a fairly conservative approach and releases a new minor version on something like an 18 month schedule. During the times of dual 2 and 3 development, you had to port things sometimes between 4 branches for bug fixes, and features were going in two branches of different code. It sucked. Now that there's a single branch and a single release to worry about, I think feature development will pick up, and with a lot of the PEPs which were recently approved or in discussion, 3.3 should be a good step forward.
I really, really hope they succeed. I flattr them every time I get the occasion.
good call
fork years ago, tryton have a lot of change compare with openerp. Tryton is focus to small/medium companies and very clean code
the client too, the interface its complete different, and better. Have a standalone version(neso) support sqlite/postgresql/mysql. check out!
Tryton migrates from any versions. For OpenERP, you must pay a migration fees.
I would use re.split, because the fields are separated by an arbitrary number of spaces, though it doesn't really matter because only the first field is required. And whenever I need to initialize an empty list before a for loop and then call its append method inside it, the problem is exactly what list comprehensions/generator expressions were made for. import re def get_interfaces(): with open('/proc/net/route', 'r') as route: route.readline() # skip first line result = (re.split(r'\s+', line.strip())[0] for line in route) return sorted(set(result)) 
Does Doxygen support free form documentation (like for example, a tutorial) or do I have to stick all documentation in Docstrings (or header files with special markup)?
I'd probably just port it to a more modern dialect of BASIC such as [XBasic](http://www.xbasic.org) and make a simple GUI for it (unless a CLI is preferred). Wouldn't that be the simplest solution? Here's a page that shows how to [link to a DLL](http://xbnotes.freehosting.net/dllprimer.html) in XBasic for the linear algebra functions.
Thanks for the explanation, actually. It makes a fair bit of sense - I'm not an expert on the internals of PyPy, but after some quick reading, I understand what you mean. Thanks again! 
Not without knowing: 1. The Glade development app version (i.e. the modeler) (I recommend that you get the latest version: 3.10.0). 2. The GTK version. 3. The OS. 4. The Python version. And so forth. Basically, everything. 
Here are some links: www.python.org/doc/essays/styleguide.html www.python.org/dev/peps-pep-0257
I wonder if there might be a speed advantage to using `x.split(None, 1)` instead of just `x.split()`. That way it gives up figuring out where to put the splits in as soon as it finds the first bit of whitespace. I'm on OS X, so I can't run `timeit` myself.
If you are premature optimizing partition will be faster. But this isn't the type of script/call that will get called enough to be worth optimizing. I did check my theory and got: x.split() was .76 x.split(None, 1) was .71 x.partition(' ') was .44
There was a discussion here at reddit about names and PEP 8 some days ago. Your code is readable and looks clean, however I suggest to use the PEP 8 conventions for the use of camelcase, underscores, etc.. Also, you should consider using new-style classes consistently. You should add tests and documentation (docstrings and an introduction with usage examples, etc.). As reference you can have a look at the source of [flask](https://github.com/mitsuhiko/flask) or similar highly regarded projects (sqlalchemy, pyramid, web2py (discussions! ;-)) to see how the pros are doing it.
Who cares about tens of megabytes? The average web-surfer downloads hundreds of megabytes without noticing.
Uh, the description of the project isnt very helpful.
same here. actually scares me a bit, since I am normally totally anti-IDE, but Pycharm seems to hit the sweet spot even with me.
Excellent job as always Larry. Any word on future guests?
I've never messed with terminating threads, my tasks I run on my threads are usually short enough that I don't mind. Is your background task really that big of an operation that it needs to be processed all at once in your run function? If it is individual chunks you happen to be running together I would highly recommend using signals/slots to run tasks on your background thread. Then if you wish to stop your thread, it runs to the end of the current item and doesn't execute anymore. Some code examples: https://github.com/epage/PythonUtils/blob/master/qt_producer_consumer.py https://github.com/epage/PythonUtils/blob/master/qt_error_display.py Even if it is best to not break up your task I would recommend implementing termination manually. Besides the fact you can use a non-blocking method, if your operation has side-effects you can make sure that they are cleaned up properly
Seems like a lot of effort for little payoff.
You just wanted to say "OccuPy."
thanks for you response * Glade 3.8 (downloaded yesterday. I'll get 3.10 today) * pyGTK 2.24 * OS Win7 * Python 2.6 I uploaded a picture to [IMGUR](http://imgur.com/E0qtr)
Nice!
For those not in the USA (as myself) and/or for those wondering what movement the OP is talking about: [relevant](http://www.occupywallst.org/about/).
I don't know much about PyGame (which I assume is what you're using), but no matter what the engine, you probably have to draw the score *after* rendering the asteroids for each frame. 
Numpy+SciPy+Matplotlib has practically no competitor at the moment and in any foreseeable future. What will happen after that nobody knows. Python 2.7 is the current stable Python. Python 3 broke compatibility with all Python 2. PyPy broke compatibility with all C(Cpp) extentions. 
Python 2.7 was the last release in the 2.x line that will add features. 2.x will supposedly be maintained for another 4 to 5 years, in "bugfix only" mode. OTOH, Python 3.x is fairly stable. Since 3.0 was released 3 years ago, it is rather embarrassing that several important packages have not been ported yet.
I've actually had to build numpy+scipy from source on solaris, and it was a nightmare. I'm actually interested in trying out dcournape new build system, bento. My feeling is that if the build of the damn thing can be made easier to describe and reproduce then porting to python3 will become hugely simplified. The hours of work I put into just getting the old numscons/distutils system to pass in a RUN_PATH was painful and well, just painful.
&gt; Glade 3.8 (downloaded yesterday. I'll get 3.10 today) Okay, first, when you upgrade to the latest Glade, you first need to change your project type from libGlade to GTKBuilder, if you haven't already. This step must be taken in the old Glade version and applied to your Glade XML file, before making the change to the new Glade version, which doesn't even recognize the old format. This change is made in the preference menu of Glade 3.8, then you should save the project in the new format before beginning use of the new Glade version. This also requires some coding changes in Python, but it's worth it -- it prevents instant obsolescence for your project. The classic sign that your Glade XML file has not yet been converted is that the new designer will choke on it and refuse to display it correctly, or sometimes not at all. As for the rest of your list, I can't see a reason for the anomaly, and I also can't test using it (I only run Linux). The reason might even lie outside these elements entirely, like your display configuration -- are you using 32-bit color (i.e. "Color quality: Highest (32 bit)") and other similar choices that are likely to make a difference to desktop display? I hope this helps. 
Numpy and Scipy both already run in python 3.2. There is a development branch of matplotlib for python 3.x. In windows you can even get binary installers for all of them.
Numpy and Scipy have already released versions compatible with Python 3. Matplotlib has [a branch which works on Python 3](https://github.com/matplotlib/matplotlib-py3), and intends to be compatible with Python 3 for the next significant release (probably 1.2). PyPy is trickier - all the interfaces between Python and C code would need to be rewritten from scratch for PyPy. There was a GSoC project to convert Cython code for PyPy, but it still needs more work. For the time being at least, it seems that CPython will remain the 'standard' Python, and PyPy will be for people who need the extra speed, but have relatively few dependencies.
It's spread to quite a few countries besides the USA. The one in London has been making the news quite a bit. Have a look at the map here: http://www.guardian.co.uk/news/datablog/2011/oct/17/occupy-protests-world-list-map
Isn't Sage a competitor?
Sage is on a different level. It bundles Numpy &amp; Scipy, and a load of other libraries from different languages. It bundles Python as well, so it's not something you can readily install into your main Python environment.
Under which rock do you live? They have been ported for a long time now.
Yep. The order you draw should go from background to foreground. Try background-&gt;asteroids &amp; ship-&gt;score
&gt; I have scores written in the top left and the asteroids are on top of it and can block it out. You don't say which packages you're using to program your game, so I can only offer the generic advice to pay attention to the Z axis in your layout. Elements "closer" to the viewer in the Z axis will be rendered on top of those "farther away". 
&gt; OTOH, Python 3.x is fairly stable. Since 3.0 was released 3 years ago, it is rather embarrassing that a lot of important packages, such as those you mentioned, have not been ported yet. I have some writing in progress on this, the gist of it being that while 3.x and its community following is making great progress, 3.x is only getting started. The three years since 3.0, to me, barely count against any 3.x adoption. 3.0 was developed in parallel by the same people who wrote 2.6. 3.1 and 3.2 were developed in parallel by the same people do wrote 2.7. Sure, the core changed, we know about that stuff, but the differences between something like 2.6 and 3.1 really are not that great to *most* users, while simultaneously being slightly damaging. This is exactly why the "what can 3.x do for me?" question comes up, and sometimes the answers aren't all that great. For example, the whole unicode/bytes distinction doesn't matter to me at all. I've been a numbers guy, and my text dealings are always ASCII and limited to simple options from config files. I can adapt to the breaking changes, but the benefits in my eyes are the continued growth. I'm also able to live on the bleeding edge a bit more than most as I'm writing internal tools with little sense of production, and they trust me to run whatever version I want since I'm active on the development side of CPython. I've been able to, and comfortable to, dogfood the trunk (now `default` on hg) for a while now. With 3.3 comes the first independently developed release since (I think) 2.5. This is where we will see the *real* new stuff, and I think the reasons to accelerate moving on to 3 will start becoming more apparent. There's no more "Oh they added that to 3.2? Well it's in 2.7 too!" Developers have more time to focus on one feature on one branch rather than considering how it'll work on 2 and 3. I think this is when porting really does start to matter, and I also think this is when the countdown really begins. Anyone who ported stuff by this point is really far ahead - I wouldn't call it embarrassment just yet. A decent amount of wide reaching packages are ported, a good amount are right behind them with ports in action, and a lot are starting to think about it.
It does support free-form documentation, but it's up to you *where* to put it. Generally, when you're working with a language that has headers, people wind up sticking the general documentation into docstrings in the headers. That's certainly the way I've done it. That way you get the best of both worlds: You can generate external API documentation that can be distributed widely which includes tutorials, etc.- *AND* you can have the same documentation available in the source-code for people to use who have access to and want to read it. A good practice is usually to define sections, sub-sections, etc. so you don't have a single *massive* wall of text in your headers. E.g., split the documentation in some intelligent way across the files. This way you can have text in several headers that, in turn, are glommed together by Doxygen into a single document and yet are intelligently grouped with the code they describe. I wish I had a good example of this to share, but unfortunately everywhere that I'm personally using it this way is closed-source ATM. You can *sort* of see parts of it in a fairly trivial example [here](https://bitbucket.org/criswell/daemonicpossession/src/b15b017cf79e/helper/logger.h) in an abstract logger class I've used quite a bit ... but it doesn't use the sub-section or splitting I've described (it's more a single wall of text, even if it's relatively small text :-) But, if you could imagine a less trivial example where the sub-sections were split across files, and you possibly had sub-pages as well, you should be able to get the idea. *Edit*: BTW, the code I shared above truly is trivial and overly documented for its simplicity. Bear in mind that it exists because it was part of a crash course for Linux daemon coding I had to give for Windows-centric .NET developers, so I err'd on the side of pedantry.
This is true and it's a serious obstacle to widespread adoption of Python 3. I have been working with [Sage](http://www.sagemath.org/), a math environment that's meant to do some of what Mathematica does but that is free and open-source ([my Sage tutorial](http://arachnoid.com/sage)). Sage uses Python 2.7 because of its support for the scientific libraries. If the scientific libraries aren't rewritten to support Python 3, many projects like Sage will simply never make the transition. This only shows the degree to which a legacy-breaking version change like 2.7 -&gt; 3 can have far-reaching, even game-changing, effects. 
Thanks for your help !! I encountered the builder choke already and worked around it. I never thought it may be a display config problem. I'll look into that. Thanks !!
There is a classic solution to all thread terminating problems: * Set up a flag outside the thread, meant to signal termination. * Monitor the flag from within the thread. * When it's time to terminate, reset the flag from outside the thread. * Arrange the thread's own code to periodically poll the flag, and exit when it's been reset. * But don't even think of trying to force termination of a thread from outside. 
When you encounter display problems, it's always a good idea to test on more than one system if possible. I am perpetually skeptical that a program problem is a program problem, if you follow. :) 
Try in [this mail list](https://lists.takethesquare.net/mailman/listinfo/occupy-dev)
Sage takes versions of a number of different python packages that it knows to be compatible along with other non python packages and bundles them altogether. It is actually a good way to get all numpy-scipy-ipython-matplotlib functionality, without too much version headache. One issue however is because there are so many internal dependencies, some packages can drift out of date, and won't include the newest features.
The lack of python 3.x support is not accurate for some time. There are even binary installers on windows for it. If you look at the download numbers, you will see that people download python2.x installers much more than 3.x, though. The multiple python version is indeed painful, but this is due to python not having a stable ABI (yet). As for the lack of people familiar with the core of numpy, more people are always better, but because it is in C, the barrier of entry is higher.
While you are of course free to use the new bento build in numpy/scipy, it still early enough that it has some rough edges. But it should be much easier to customize if you know your platform. Let us know how it goes on the bento ML if you tested it !
get a job, hippie (also a haircut)
I will do that soon. I found another nugget of info, in case anyone else finds this perplexing problem. If I disable (turn off Sensative option) the label, it shows up in gray on black instead of what I am guessing is black on black. Strange.
How does Sage compare with [Python(x,y)](http://code.google.com/p/pythonxy/)? 
Everyone knows the 99% uses node...
Unless you're using OpenGL, then yes it is almost certainly about order of operations. Draw things in order of back-to-front. If you or the engine you're using is rendering with OpenGL, then things get more complicated in general, but in this case, it's probably as simple as changing your "layer" or "z" coordinate to be higher. (Or depending on the projection, you may need to set it lower, but I think that would be pretty... non-standard.)
Can't be sure from the picture (and I realize that you've already started to sort it out), but are you using a custom/non-default Windows theme? That could easily be the root of the issue if Glade is using system colors and the one it's using for the background happens to be black/unassigned by your custom theme. If not, then my apologies, though I do think that it's a good rule of thumb to not design GUIs that use system look-and-feel / settings if you're not using defaults yourself.
For hit detection, your sprite can be any shape you want, but you almost always want to use a bounding square or box to do the hit detection with. In some cases a circle or sphere may be more appropriate. Once you've got a list of things that look like they *might* collide based on your bounding box or bounding sphere only THEN should you consider doing a more detailed check between those colliding pairs. You can get as specific as pixel-by-pixel or polygon-by-polygon if you need to, but only on the second pass when you now have a vague idea of which sprite is nearby with which other sprite, thanks to the first bounding box pass.
&gt; this is due to python not having a stable ABI (yet) This was added in 3.2.
Awesome, will listen to it while cooking pasta for the family tomorrow. :)
I assume that you mean Numpy+SciPy+Matplotlib has practically no **Python based** competitor. Obviously Matlab, IDL, R, and several other packages are competitors.
Edited. I live under the "I don't actually use those libraries under Python 3.x" rock...
&gt;Sure, the core changed, we know about that stuff, but the differences between something like 2.6 and 3.1 really are not that great to most users the big problem for numpy/scipy is that they aren't most users. those packages depend on a lot of C (and even more fortran) code, and the c api to python changed significantly. All three packages are significant code bases, and updating it all wasn't a trivial task.
If you're using pygame, this is a common problem. In pygame, the order of elements in a sprite group is not guaranteed. Use a pygame.sprite.OrderedUpdates group to ensure the sprites are drawn in the order they are added to the group. The other alternative is to use multiple sprite groups and update these in the z-order you want. As for collisions. Pygame only supports bounding-box collision, but you can tweak it by inflating the rectangle (it's not the actual image that collides, but the rect. Set the inflate to a value between 0 and 1, and your bounding rectangle will be smaller than the actual image. The other easy solution is to use bounding circles instead of bounding rectangles. Essentially, grab the center of each sprite and calculate the distance with Pythagorean theorem. If the distance is less than some threshold, count it as a hit. The nice thing about this approach is it is entirely divorced from the visual image, and doesn't change the collision size when images rotate (which happens with rectangle collisions.) One more answer that's sometimes convenient is to just do a point check against a color. If the center of your sprite is over some color (for example the color that indicates grass on your race track) count that as a collision. The next level of solutions is to use multiple collision areas. Build several bounding boxes around your sprite and check for collisions with each of them. This is a bit painful, but it can give good results. Best of luck to you, and write if you need more help. 
newbie here. I'd like an answer to this question too.
&gt; the c api to python changed significantly I've heard a lot of people say this, and a lot of people say the opposite. In my use case, which is much smaller than that of NumPy, I only came over some very easy obstacles like int/long distinction and only a few small areas of unicode use. Module initialization was the biggest change to me, and it's really easy to work with the 2 and 3 way via `#ifdef`s. What were the biggest changes that affected these projects? Part of the reason I ask is that I wrote a pure-Python porting guide in the past and have been meaning to cover the differences in porting via the C API.
Python will expand as long as there are good examples in the cookbook. For people like me who are non-mathematicians or computer scientists, the cookbook is where we turn to for examples on how to do things. I hope to add on to it with some of my own examples, I know I have posted a couple of examples on here. Though this cookbook example is a bit silly, it helped me tremendously to implement ODEs in Python, instead of matlab. http://www.scipy.org/Cookbook/Zombie_Apocalypse_ODEINT
OMG you are brilliant !! I have the Theme set as Windows Classic (long story, but we have to use that for other purposes). I changed the theme to the default Win7, and its ok. haha. So it looks like the widget is fine, but under Win7/Classic Theme, the out of focus tabs are hosed (black text on black background) I wish I could give you a million upvotes. :)
I see you're not concerned with text (and it's a bit off topic in this thread), but the new [flexible string representation](http://www.python.org/dev/peps/pep-0393) looks to be the biggest change in 3.3. It eliminates narrow builds (and bugs caused by surrogate pairs) and reduces the memory footprint -- apparently at a 1 to 30 percent performance penalty.
I noticed that there has been a big push on the mailing list in the last few days, to put out version 1.2. Perhaps you could make a post about what wasn't working for you, so someone could look into it? I agree it has seemed like a dead project, and I totally agree they need to push out more releases.
Here's a basic C extension [porting guide](http://python3porting.com/cextensions.html).
Well, I wouldn't exactly call the Windows Classic theme "custom", just not the default (unless of course you also changed some colors around in this theme). I meant more so for people that patch the required DLL files and install all kinds of exotic themes. However, I am glad it helped locate the root "issue".
&gt; be the biggest change in 3.3 The biggest change so far :) The closing of the new feature window happens, at least tentatively at the end of June, so we've got a good eight months for everyone to get their features in. In terms of the core language, you're probably right that 393 is the largest change. As we did with 2.7 and 3.2, the features are probably added exponentially as we get closer to June.
Oh, sorry. I haven't used the Z axis in my game. I'm using pygame and I use the 'drawText' method to draw the writing.
Oh I see. I think I've got the asteroids drawn in the same pygame.display.update() function. Should I put them in seperate ones and have the score after everything else? Like in it's own?
I'm not sure. If you post some source code it would probably help -- here: http://pastebin.com/ I'll be going to bed soon but I'm sure others would be able to give you more specific advice too.
http://www.reddit.com/r/learnprogramming
Okay, I'll just do that. Also, if you care to notice, my code is extremely similar to that of the python book shown on the sidebar of /r/gamedev. :P [here is it](http://pastebin.com/74BjxfAn)
Here's my take on it. $ cat /tmp/foo.py #!/usr/bin/env python def getIfaces(): ifaces = [] for line in open('/proc/net/route'): interface = line.split()[0] if interface not in ['Iface'] and interface not in ifaces: ifaces.append(interface) ifaces.sort() return ifaces if __name__ == '__main__': print getIfaces() $ python /tmp/foo.py ['eth0'] $ The pythonic parts are: for line in open('/proc/net/route'): If you are going to go line-by-line through a file, this is the way to do it. It's called an iterator. No need to open the file, then read it, then close it. The loop takes care of all of that for you. interface = line.split()[0] This splits the line (default by whitespace) into an array. Once you have an array you can index it right there and get the first element. if interface not in ['Iface'] and interface not in ifaces: This line does your two tests. First it makes sure the variable interface is not the string 'Iface'. Technically you could do: if interface not 'Iface' and interface not in ifaces: but what if you wanted to skip another string too? By including 'Iface' in a list of strings you want to skip (a one member list) it allows to you easily expand this code later. It also blends in with the second test which avoids duplicate interface names using the same mechanism. Once interface is added to the ifaces list, the test will fail if interface is already in there. Hopefully that last part makes sense. The only other pythonic thing is the boiler plate code: if __name__ == '__main__': You should put this in all of your modules as it allows you to have test code. The test code won't get run when you include the file from another script, so it's a form of unit testing.
Ah, yes. So what you need to do is move the drawText calls down to just below the code that draws the baddies, but before the pygame.display.update. What is actually happening here is that all the drawText and blitting calls don't actually put any data on the screen -- they just draw it in a buffer that is hidden. When you call display.update(), that buffer gets copied to the actual screen (which is a very fast operation). Then you have as much time as you want to draw the next frame to the buffer. So one way to think of it is that the display.update call is the boundary line -- it's what separates the drawing of one frame from another in your main loop.
They don't really compare. Python(x,y) is just a windows installer for various libraries and tools that are useful for doing math/science in python. Sage is a different beast - it aims to be an integrated environment for doing math/science in python. It basically gives you into a shell where most of these things have been imported for you and they are integrated in some pleasant ways. The experience is not the same as importing and using the libraries directly through the python interpreter.
Firefox thinks this site is a security risk. Part of conspiracy ? :)
Have a look at openhatch.org.
Oh okay. Cool, I'll give it a try. My code has lost all it's colours and it's messing with my way of organising it all so I'm having trouble finding what I want. :P It worked. Thank you! :) I got it to layer properly. Now I just need to learn to do collision detection without the rects but so that you can have asteroids right next to the ship. At the moment, the ship is roughly triangular but the picture is square so it can collide with nothing. :/
what's being done in that thread?
Then it's likely to be the problem. Given the description of some elements appearing over the top of others in a way you don't intend, this is an obvious cause.
Nevermind. Thanks for your help but I've fixed it. I just had the score before the enemies in my draw function and it layered it accordingly. Thanks anyway. :) *upvoted for trying to help :)
I don't know the specifics (I use swig to wrap all my c/c++ code), I'm just going off of what was discussed at scipy a couple of years ago about the plans to start porting numpy 
This. How OP came to its conclusion is beyond me. 
I tried that as well, again, for some reason it did not work. [Here's the code I have](http://pastebin.com/fDDj4rnh) I'd appreciate if someone could look at it and tell me what is it that I'm doing wrong. 
Some web scraping, a couple of loops, some parsing, etc.
Unfortunately it is. Believe me, I was against having that huge of a chunk of code as a single thread, but all to no avail. 
Well, it does sound better than OccuHaskell.
no. just shitty ssl on their end
Need to dig up a book on Forth now.
What about this screams python to you exactly? The "true" is lower-case which is javascript style. Looks like standard JS metadata to me.
The fact that they are using [beaker](http://beaker.groovie.org/) for their sessions? EDIT: I guess I should have highlighted it better, the session ID is stored in a cookie called "beaker.session.id" 
Session ID is stored in beaker.session.id, maybe they are using [beaker](http://beaker.groovie.org/)? 
That's a good reason! I agree, moar highlighting. Makes sense on a second look. I didn't know about beaker, I don't do much web dev lately. Mostly distributed stuff and other things. And when I did do web dev, it was mostly Django with some webob + SQLAlchemy.
Yeah it's easy to miss, I wouldn't had noticed had I not written websites with beaker. 
I may or may not have some inside access to EA servers running battlelog. I will see what I can find out tomorrow.
They used Python in BF2 so I would not be too surprised.
In this case it looks like `partition` is a semantic winner, a safety winner (you don't have to worry about `[0]` throwing an exception, so you can drop the `if x` at the end), and a pre-mature optimization winner. Always nice when that happens. :-)
Do you offer relocation assistance? Are you even interested in hearing from anyone not in the Austin, TX region? Your post seems to be full of the unimportant, while being skimp on the details. That being said, I also love burritos.
It's not that tricky conceptually. Let's say you do three rows: 1 1 1 1 2 1 On the first row, I indented 2 spaces, then printed 1. On the second row, I indented 1 space. On the third row, no indent. So, just take the number of rows you will print total, minus the current row number, and put in that many spaces. Voila. EDIT: This doesn't work well with 2 digit numbers. Oh well.
The following code works for me. It's not that different from what you have. import time from PySide import QtCore, QtGui class Thread(QtCore.QThread): def __init__(self, parent=None): super(Thread, self).__init__(parent) self.runs = True def run(self): self.commence_working() self.stop() # self.finished.emit() # this one is not even necessary def stop(self): self.runs = False def commence_working(self): loop = 0 while self.runs and loop &lt;= 100: print "I am processing..." time.sleep(2) # short time pause to simulate work being done loop += 1 class GUI(QtGui.QDialog): def __init__(self, parent=None): super(GUI, self).__init__(parent) self.l = QtGui.QLabel("Hello World", self) self.b = QtGui.QPushButton(self) self.b.setText("abort thread") self.sb = QtGui.QPushButton(self) self.sb.setText("start thread") self.vb = QtGui.QHBoxLayout() self.vb.addWidget(self.l) self.vb.addWidget(self.b) self.vb.addWidget(self.sb) self.setLayout(self.vb) self.b.clicked.connect(self.on_userAbort_clicked) self.sb.clicked.connect(self.start_thread_clicked) def on_userAbort_clicked(self): self.l.setText("aborting the thread...") self.thread.stop() self.thread.wait() def start_thread_clicked(self): self.thread = Thread() self.thread.finished.connect(self.thread_finished) self.l.setText("The thread is running") self.thread.start() def thread_finished(self): self.l.setText("The thread stopped") if __name__ == "__main__": import sys app = QtGui.QApplication(sys.argv) g = GUI() g.show() sys.exit(app.exec_()) 
If you look in the [QThread doc](http://doc.qt.nokia.com/latest/qthread.html#run) for run(), you see this: &gt;void QThread::run () [virtual protected] &gt; &gt;The starting point for the thread. After calling start(), the newly created thread calls this function. The default implementation simply calls exec(). &gt; &gt;You can reimplemented this function to do other useful work. Returning from this method will end the execution of the thread. So basically, I just exited from run(). And the thread is cleaned up for me.
But then you don't get that guaranteed type-safety :p
So why mine doesn't work exactly is beyond me. To add to the mistery, sometimes it works great - it aborts cleanly, the GUI doesn't freeze, and everything works. Other times it freezes completely. 
I look forward to listening to this (and the Martelli episode, too!). But please don't use fixed positioning for the footer div. It blocks the main text at the bottom of the page for people with lousy eyesight and/or smallish screens. 
http://www.tacticalgamer.com/wiki/index.php/Official_BF2_Python_Doc 
Well, how fast does your "100's of lines of code" run? If this is a long duration, then you may need to break it up into smaller units work (that still makes sense). And check for your sentinel value more often. It depends on how much your user can tolerate a slow abort I guess.
That's always tricky. You may want to do circular collision detection, which is almost as fast as rectangular, but feels more accurate for roughly round objects (like your asteroids, I guess). You can also add a little "fuzz factor", and make the collision boundary of the asteroid smaller than its image.
They use [ESN Planet](http://www.esn.me/showcase/battlelog/), a Python web framework.
Thanks! I started working on it, but I'm not yet sure where it's heading to. As the author of the uncertainties package, I would love it if you forked it from github and shared any work you might do on it (https://github.com/lebigot/uncertainties/). :)
You could calculate the number of digits in the largest number in the last row and use that as a field width (make it odd with a bitwise or). Then print each row centered on the total width of the last row: triangle = [ [ 1], [ 1, 1], [ 1, 2, 1], [ 1, 3, 3, 1], [ 1, 4, 6, 4, 1], [ 1, 5, 10, 10, 5, 1], [ 1, 6, 15, 20, 15, 6, 1], [ 1, 7, 21, 35, 35, 21, 7, 1], [ 1, 8, 28, 56, 70, 56, 28, 8, 1], [ 1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]] def print_triangle(triangle): width = len(str(max(triangle[-1]))) | 1 rows = [] for row in triangle: line = ' '.join('{0:&lt;{1}d}'.format(n, width) for n in row) rows.append(line) N = len(rows[-1]) for row in rows: print(row.center(N)) for n in 5, 9, 11: print_triangle(triangle[:n]) print('-'*42) Output: 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 ------------------------------------------ 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 ------------------------------------------ 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 1 10 45 120 210 252 210 120 45 10 1 ------------------------------------------ 
Good find! Yes looks like [Planet Framework](http://www.planetframework.com/)
Haskell is the perfect language for OWS. A lot of discussion. A lot of high level explanations. A lot of theoretical insights that are hard to understand but if implemented could create perfect system. More or less the only concrete things done are tutorials and a window manager.
https://github.com/esnme ESN is actually a very active contributor in python community. Such as: [ultrajson](https://github.com/esnme/ultrajson) Ultra fast JSON decoder and encoder written in C with Python bindings [amysql](https://github.com/esnme/amysql) Asynchronous MySQL driver written in pure C/C++ for Python with or without gevent and more.
I see these comments on unavailability of packages that actually had been already in the open for months very often...
Your post motivated me: I just ported the uncertainties package to Python 3.2! The new version is available from the Python Package Index (PyPI): http://pypi.python.org/pypi/uncertainties/
I'm actually struggling to go from R to Python/NumPy. I am quite fond of Python so thought consolidate my work in it, but when you get into NumPy you lose all the elegance of Python (NumPy introduces a number of inconsistencies, e.g., between ndarrays and their subclasses, where you can or should use tuples) and my feeling is that R's objects and functions are much better thought out for interactive data analysis. However, in its implementation it keeps copies of everything so slows everything down and hence my thought to move to NumPy, with some reluctance.
Is pandas ready to use?
Yes it is: http://www.esn.me/product/planet/
And yet their replaced it with lua for BF3. :-)
Have you looked at [Yesod](http://www.yesodweb.com/) at all?
Without giving away the architecture of the site, let's just say I do not have the access to positively confirm or deny this. Apologies.
Umm, these aren't Python threads, they're under the control of Qt. Maybe you should try using Python threads. But you really don't want to try to control your thread from within the thread, as you are doing. When you want a thread to end, do it this way: * Within the thread, monitor a flag that is external to the thread. Continue to process only as long as the thread flag is set. * Once the external flag has been reset, simply exit -- do not try to kill the thread, either from inside or outside. Let it expire on its own. * By exiting, you bring the thread down the only reliable way. FWIW, many people have tried to create self-extinguishing thread schemes over the years, and all have failed. The only safe thread termination is simply to exit the thread, by stopping and exiting, just like returning from a function. 
We can gladly help pay for relocation! I've mentioned it before but I find it works better to get people who fit our culture and attitude more so than looking for a job or money. 
An added plus would be one that is written in pure python (which makes it easier to port to different implementations, such as PyPy).
Re. PyODE: it's a bit wonky and uses an old version of ODE, but it works. I'm using it for simulating robotic snakes in my M.Sc. thesis. Not sure it's the best choice out there, but if you end up using it i'm more than happy to share my slightly sloppy code to get you started. 
Pure python would probably be too slow for non-trivial, realtime simulations.
This looks great, but... ~1200 Euro per developer per year, plus ~6000 Euro per year for the "small business" license. Even the RFPs that cross my desk looking for this scale of application usually have a clause forbidding the use of software with subscription-based licensing. We can't all work for EA, I guess. Oh well...
Sweet, it's a shame their framework appears to be closed source and licensed. The [ultracache](https://github.com/esnme/ultracache) caught my eye though...
Python wrappers for a C/C++ library would probably be best suited to our particular situation. In a Computational Modeling class, my team is recreating Karls Sims's work (http://bit.ly/ugGP0) and hopefully extending it. Python would not have been our language of choice, but part of the project is to create a case study for a python-written complexity science book. In the best case, we would be able to simulate at close to real time (or better than :P) speeds, we have somewhat limited computing resources (nothing beyond our i7-2600k @ 4.8 GHz workstation).
Interesting, perfect for EA I guess...looks like the framework was designed for a single purpose. 
For me it is, at least for the use I make (mostly bioinformatics).
^ ^ ^ What he said. Just pick your favorite C++ library and find some wrappers for it.
Thanks for posting this. I have a pygtk program that I haven't managed to package for Windows yet, but I'm going to try your way.
You declared the function but never called it. Also a and b need to be passed to the function or be declared global.
Formatted, is it suppose to look like this? def sum_a_b(): '''This function returns the sum of the values''' x = 0 for number in ([a,][b+1): x += number print x return x try def sum_a_b(): '''This function returns the sum of the values''' x = 0 for number in xrange(a,b): x += number print x return x
When you ask for help it is advised to attach the traceback ("error message") you get or a description of the observed behavior compared to the desired behavior.
I think it is because you indent the if statements. You should align them with the 'prompt_f = raw_input("Type a command: ")' and then it should be fine
Kill it with fire. That is about as unpythonic as it gets.
Yeah, that was it. Thanks!
FWIW, you (probably) are not Google, so you shouldn't worry about what Google has to worry about.
Some more things that may help you: The myapp.spec is a configuration file. You can open and edit that file to set additional options such as disabling the console (windows cmd shell in background, it will still launch two processes, but the cmd shell will be hidden) and changing the icon for the exe (that distorted butterfly). You can also use the .spec file to force pyInstaller to add files. Another very important thing to note is make sure that you use the same architecture (x86 or x64). Personally I use x86 everything(python, pyqt, ety...) on my x64 win7 and have virtually no problems with windows platform deployments. The only thing that used to happen was the Microsoft C+ redistributable (which you can get from MS), but iirc that problem went away with the newwer versions of pyInstaller. Also, the exe is actually a 'zipped' file. You can open it with winrar and view files. EDIT: I've also used the one folder option to deploy on windows, and then forced pyInstaller to ad folders with things like readme and device drivers for pyusb, so the user has acces to them all in one place. Then I create an installer (using MSI insataler for example) with that folder to get a really nice user experience for Windows users. I know it's more work, but hell, you're so deep into everything else, why not?
Global variables only need to be declared if they're rebound in the function. But using globals for anything but constants and class/function definitions is generally a bad practice.
The major issue was with it's inability to do something with opengl. I don't remember the details. I'll have to re-checkout and try again to find out.
One thing that you should also take into account with this system is that after enough room changes, you will get a RuntimeError. This is because each time you change rooms, the callstack gets higher because the calling function never exits.
That is a good idea, but I don't know how to do or even learn that. And I still have a triangular ship with a square hitbox :P
try this. def go(mapping): choices = ', '.join(mapping.keys()) choice = raw_input("Type a command (%s): " % choices) while choice not in mapping: print "Invalid choice" choice = raw_input("Type a command (%s): " % choices) return mapping.get(choice) def foyer(): print "You are in a foyer. There are two doors. You may go forward or left." print return go({ "forward": reading_room, "left": commons, }) def reading_room(): print "You are in a reading room. There are books everywhere. You may go forward or backward." print return go({ "forward": painting_room, "backward": foyer, }) def commons(): print "You have reached a dead end. You may only go backward." print return go({ "backward": foyer, }) def painting_room(): print "You are in a painting room. There's an easel in front of you but that doesn't matter. You won the game. Congratulations!" def main(): location = foyer while location: location = location() if __name__ == "__main__": main()
&gt; I would use re.split, because the fields are separated by an arbitrary number of spaces string.split already handles and arbitrary number of spaces &gt;&gt;&gt; '1 2 3 4 5'.split() ['1', '2', '3', '4', '5'] 
Your method of generating the triangle didn't work for me, so I wrote my own for fun. def pascal(rows): result = list() for r in range(1,rows+1): row = [1] for c in range(1,r): row.append(int(row[c-1] * (float(r-c)/c))) result.append(row) return result
Any suggestions? I don't want to write wrappers myself, though bullet is a very well known and powerful library...
using python to model the physics of snakes. thats so....meta. 
I played with it a little bit...this is what I got print ("Welcome to The Maze") name = input("What is your name? ") print(name + ", the Doomed") def foyer(): print("You are in a foyer. There are two doors. You may go forward or left.") print prompt_foy() def prompt_foy(): prompt_f = input("Type a command: ") if prompt_f == "forward": reading_room() elif prompt_f == "left": commons() else: print("Invalid choice.") prompt_foy() def reading_room(): print("You are in a reading room. There are books everywhere. You may go forward or backward.") print prompt_rea() def prompt_rea(): prompt_r = input("Type a command: ") if prompt_r == "forward": painting_room() elif prompt_r == "backward": foyer() else: print("Invalid choice.") prompt_rea() def commons(): print("You have reached a dead end. You may only go backward.") print prompt_com() def prompt_com(): prompt_c = input("Type a command: ") if prompt_c == "backward": foyer() else: print("Invalid choice.") prompt_com() def painting_room(): print("You are in a painting room. There's an easel in front of you but that doesn't matter. You won the game. Congratulations!") continue_game() def continue_game(): again = input("Do you wish to start over? (y/n)") if(again == "y"): foyer() elif(again == "n"): print("Thanks for playing!") else: print("Wrong input. Try again.") continue_game() foyer() 
&gt; If userspace applications would have to be written GPL compatible I doubt we would see a lot of Linux users. So what? I'm done here. Obviously you lack the capacity to realise your main point "GPL copyright holder has more rights than BSD copyright holder" has been invalidated. You now sound like a Christian defending Creationism. You're moving the goal post.
Hey there. Ok, I think I get your data. To draw it you need to loop through the last list (You've called it "indices of vertices"... I prefer "edge_descriptions"), like so: for line_eqn_index,v1,v2 in edge_descriptions: and then, if neither v1 or v2 are -1, you just need to draw a line connecting the voronoi vertices with indexes v1 and v2, the equation is not needed. You can use the python imaging library, but you may need to install it first. The command will look something like this: d.line((voronoi_verteces[v1],voronoi_verteces[v2])) if v2 is -1, this seems to mean that we've got a point and the line goes off somewhere into the positive x direction. Look up a,b,c from the line_equations list using the index. To draw the line you need to generate a point at "infinity", or just some large number (maybe the x dimension of your diagram!). Rearrange the equation for y, simple: y = (c-ax)/b, pick a large x, and now you have a new x,y coordinate, so you can draw a line from voronoi_verteces[v1] to that new point. It's similar if v1 is zero, only now it looks like the the line goes off in the negative x direction, so generate the new point by picking the lowest x coordinate you're interested in drawing. If both v1 and v2 are -1, you have to generate 2 points. If any of the lines are perfectly vertical, there'll be trouble! [edit for clarity] [edit 2: Your diagram should look something like [this](http://i.imgur.com/sMgNO.png), although this version has a bug in it – one of the points has a negative x coordinate and I haven't taken that into account, so it's off the left edge of the picture] [edit 3: I said zero instead of -1 a few times. oops. It's 1am, I blame tiredness] [edit 4: If you're unfamiliar with PIL, here are a few lines to set up your drawing, and to show it in the end:] import Image,ImageDraw size = (400,400) i = Image.new("RGB",size) d = ImageDraw.Draw(i) ... draw the image using d.line ... i.show()
By putting ``a`` and ``b`` inside lists (``[a,]`` and ``[b+1]``), you're iterating over a tuple of lists not a tuple of integers. Since your ``x`` is initialized as an integer, you're trying to add lists to integers (``0 + [a,] + [b+1]``), which is going to raise a ``TypeError``
That worked out pretty well, so now I can tweak it. I guess it was my version of 1AM here because I kept staring at the coordinates and was unable to visualize how it went together :)
Where you make location into a custom-named function [location()], is there a name for that? I didn't know you could do it. Very concise!
There's no comma separating the brackets: `([a,] [b+1])`. So it's actually trying to get index `b+1` of the list `[a,]`. 
Depending on how much of it you need to use, keep in mind that you probably don't have to write a complete wrapper. I also always shied away from "writing wrappers" until at one point I got frustrated and just started directly calling a library's functions through ctypes (which is really quite easy, all things considered). After awhile and a bit of refactoring, it ended up that I had developed a de-facto wrapper. It wasn't even remotely complete, but now I had my own working wrapper for that library that did exactly what I needed it for.
Use Bullet, and if you can't find appropriate wrappers, call it with ctypes (works in PyPy, CPython and Jython).
Hey, you're right. It's a bit counter-intuitive though, because .split()/.split(None) does something different than .split(' '). Help says it removes empty strings from the result if you don't specify a separator. Never knew this!
Not trying to sound to critical but putting your conditional statements in some kind of loop would probably help. In case the user accidentally misspelled 'left' it won't crash but rather prompt the user to type another command. Glad you found out what was wrong though!
In general, for something like this, including the stack trace (the text output from attempting, and failing, to run the program) is very useful, along with the code as presented. Is this the entirety of the code in your file, or is there extra?
I don't know if this will suit your needs, but PyODE has already been mentioned, and to my knowledge, this is created for 3d visualization pertaining to physics. * [VPython](http://vpython.org/) * [VPython applications for Teaching Physics](http://www.visualrelativity.com/vpython/) * [Demo programs from Chabay &amp; Sherwood's Matter &amp; Interactions](http://matterandinteractions.org/Content/Materials/materials.html) * [Some youtube videos](http://www.youtube.com/vpythonvideos) I haven't used it much, so I can't say whether it's good or not.
Functions are first class objects in python. That means that they can be used just like any other object: put in a list/tuple/dict, returned from a function, assigned to other variables, etc. It's not so much that the function is custom-named, it's that the go() function returns a function and each of the room functions returns the result of go() (except for painting_room), which means that the return value of each room function is the next room function that should be called.
Upvote for Karl Sims, he really did some amazing stuff. I'm trying to reimplement his procedural textures with Python. Unfortunately I don't have a spec for all the graphic functions, so I have to operate half on quesswork.
After speaking with some people who know more about the internals than I -- it's impossible to load both pyhon 2 and python 3 in the same address space, as most function names are the same for both, but the implementation is not. Therefore, you need two processes. There are some libraries that allow easy inter-process communication (rpyc, pyro4), but they don't allow communicating between py2 and py3, due to a different object model.
[pythonogre](http://www.pythonogre.com) has a wrapper for bullet.
There's already a builtin function for that: Help on built-in function sum in module __builtin__: sum(...) sum(sequence[, start]) -&gt; value Returns the sum of a sequence of numbers (NOT strings) plus the value of parameter 'start' (which defaults to 0). When the sequence is empty, returns start. So I would write your function like this: my_awesome_and_entirely_redundant_sum = sum And you can call it like so: my_awesome_and_entirely_redundant_sum((1,2,3,4,5,6,7,8,9)) my_awesome_and_entirely_redundant_sum(range(50,100)) my_awesome_and_entirely_redundant_sum([98,108,111,119,32,109,101]) 
I know your problem is fixed but, for reference, here's how I would implement this program: http://pastebin.com/shevkZv7 The most important thing to notice is how I've grouped all the rooms into a data structure instead of having separate functions for each room. Doing it this way means that you don't have to copy and paste a lot of shared functionality every time you need to add a new room. It also helps when you need to extend the game; for example if you were going to add items to your original game then you'd need to change every single room function to pass along information about what items are held where.
It always amazes me how relatively accurate bayesian inference is. What I like about debugging it is that there's always a genuine reason why it ranks a document into a particular category, and it usually means you've biased a seed set somewhere. Its really worthwhile doing analytics on your keyword rankings so you can tweak the biases. You can get a lot of value out of generating document metadata using bayesian inference, e.g. as well as ranking words, try ranking sentences to generate a document summary. This works great with MUA's to save having to read a really long-winded email in its entirety ;) 
Actually if you read the definition properly it's not `sum` at all. It's more like `lambda a, b: sum(range(a, b + 1))`.
https://launchpad.net/pybullet
Thank you! 
Each environment contains a copy of the Python binary, but the standard library is shared between all of them and the source the environments were created from. So three virtual environments for 2.7 would use the system 2.7 stdlib instead of holding their own copies. 
Its interface looks like PHP’s [SimpleXML][]. I think it’s still painful and the right solution is XPath. [SimpleXML]: http://php.net/manual/en/book.simplexml.php
No it means that a virtualenv will use the stdlib that "belongs to" the binary it was created from 
What do you suggest for xpath? lxml?
I don't like objects that have magical attributes based on data. It makes checking your code for correctness a bit of a nightmare.
Yeah, I've heard the term 'remoting' used by Java and Flash people before but never really in Python circles. I think it's something based on the Java Remote Method Invocation stuff where you get a local proxy copy of an object which you can call methods on locally and have the function execute remotely, but that's just a guess.
This is awesome, but I kind of wish they had done something funny with PEP *404*.
Worked for me. I used Python 2.7.2 and pygtk-all-in-one-2.24.0. The only thing that was non-trivial was including images inside my .exe file, but the PyInstaller manual showed how to do it.
Everybody I've asked has said "yes", so the sky's the limit really. The plan is, next month is Benjamin Peterson, and in December I hope I'll be able to work out the logistics so I can interview Martin von Lowis.
I'm not a CSS whiz; a friend did that stuff for me. I asked him about that specific problem, and he has a fix for me--now it's just waiting on me to integrate it into the site. The big problem is, I am fantastically lazy. ;)
Humor not found.
Fair enough. :-) This is kind of beside the point, but your friend's life will be easier using [HTML5](http://diveintohtml5.info/). First, tell your friend to stick `&lt;!DOCTYPE html&gt;` at the top of the page. Then use a `&lt;footer&gt;&lt;/footer&gt;` pair instead of a `&lt;div class="footer"&gt;&lt;/div&gt;` pair. (Keep in mind, `div` elements are the devil's horrid playground because they have no semantic meaning.) Then your friend needs to eliminate the `.footer { }` stuff from the CSS file. Styling for the new `footer` element is probably not even necessary, but perhaps your friend wants to fiddle with the padding or something: footer { padding: 8px 0px 16px 0px; } In any case, don't stick `position: fixed;` and `bottom: 0px;` in there. A complicated web application such as Facebook can make good use of fixed positioning for things such as toolbars. But RFP is a collection of straightforward web pages. Taking the copyright out of the flow of the document and fixing it to the bottom of the window merely announces to the world "O HAI! I CAN HAS CSS!" and makes the page layout so much less flexible under various viewing conditions. BTW, the page is [very buggy](http://validator.w3.org/check?uri=http%3A%2F%2Fradiofreepython.com%2Fepisodes%2F3%2F&amp;charset=%28detect+automatically%29&amp;doctype=Inline&amp;group=0) because it's a mishmash of HTML and XHTML, and I see there's at least one `p` element which is never closed anyway. Run the page through a validator. *CSS is maddeningly impossible on an invalid web page.* Also, your friend would do well to redo the `&lt;div class="logo-header"&gt;`, `&lt;div class="logo-subtitle"&gt;`, `&lt;div class="section-content"&gt;` elements as [semantic HTML5 elements](http://diveintohtml5.info/semantics.html). Remember, `div` has no meaning. Hope that helps. :-) 
Yes. lxml is great, especially its [html parsing mode](http://lxml.de/lxmlhtml.html) and [support for css selectors](http://lxml.de/cssselect.html). It implements a much wider set of XPath expressions than ElementTree. (I wish ElementTree implemented XPath attribute selection. A recent project needed to work on a stock Python 2.5 distribution and I ended up writing a wrapper that allowed simple attribute selection for ET when I would have much rather been able to install lxml.) The only downside to lxml is it requires building C-based libraries, which isn't always possible in some environments.
Not supporting XML namespaces is understandable but mistaken. You can get away with it for parsing RSS seeing as RSS is almost hostile to using namespaces so that few feeds make use of namespaces. And that is one of the reasons [Atom](http://www.atomenabled.org/developers/syndication/) should always be preferred as a syndication format. (That and the miserable state of date formats in RSS.) 
The marked is pretty damned good, I've never had trouble finding work, nor anyone I know.
I'm assuming you do freelance work. What's your typical hourly wage or price per job?
Very cool.
At least some of this is dependent on where you are able to work. If you can work in Boston, NYC, San Francisco, you should have no trouble finding people hiring for Python. If you are in like Phoenix, then you may do better to just learn Java or .NET.
His experience will not be your experience unless you too are a committer on several high profile Python projects (which you can be with some effort--they are all open source after all).
Yes, lxml.
Are you a committer to any notable projects, friend?
Lots of good enjoyable work. Most python projects are interesting compared to a lot of other languages... For instance .NET and PHP... Lots of work out there but most of it I wouldn't be interested in.
I once wrote this, which generates somewhat of a Pascal's Triangle. It generates the whole thing as a square with the rows expanding diagonally. grid = [[1 for col in range(21)] for row in range(21)] for a in xrange(1,21): for b in xrange(a,21): grid[a][b] = grid[a-1][b]+grid[a][b-1] grid[b][a] = grid[a-1][b]+grid[a][b-1] for a in grid: s="" for b in a: s+=str(b)+", " print(s) It was to solve this http://projecteuler.net/problem=15 output looks like this: http://pastebin.com/raw.php?i=Rn3jsVrb
I learned Python in 1996, and have had about seven jobs, all with some Python, most were mostly Python. Django is currently a hot webby Python framework, but requires more programming skills than is common among web programmers in my experience. That might be lucrative. Good luck!
In the last month or so I accepted a job for a nearly 95% pay increase, and had people after me to apply for several other jobs at places out of state. It's not bad to be a pythonista.
Doh, you're right. 
The python market in Chicago is quite good, too.
He's not trying to be a dick, he's trying to temper kingkilr's impression with some realism. Not everyone will be contributing to high profile Python projects, which would normally elevate their reputation and earning potential. Friend.
Oh, nor was I. I genuinely was curious as to what projects he's worked on.
I don't think you're going to find yourself working with great/brilliant people if you base what you want to learn on a question like that. :\ If you don't have a solid CS background or experience in Programming, getting a real job/gig hacking for somebody is going to be hard. I know because I dropped out of school and had to bootstrap my career from scratch. I had giving a shit about programming in general on my side and loved learning regardless. You seem to be fishing for a job. Programming is insanely boring and borderline agonizing if you're not into it. Reconsider your career options if that's what you're angling at.
due to "while se &lt;= len(s)". If se = len(s) then s[se] is out of range, because indices start at 0.
Okay, my bad. It's just the use of "friend" (in that manner) is generally less than colloquial where I'm from. I'll remove my downvote.
Most place I've worked don't really care what languages you know as long as you know how to code. Maybe HR and head hunters look at buzzwords but any competent workplace will straighten that out eventually.
Well, I'm completely new to programming. This is my first crack at it, honestly. I generally love learning, but I tend to be more English/History minded, so I'm slightly out of my element. I just know it's going to take some effort, and while it would be very cool to learn for the hell of it, I am a struggling college student, so knowing the a value of a skill I may potentially soon possess couldn't hurt. With that being said, any advice to a rookie such as myself?
Well, I'd say... that as you grow as a programmer you won't necessarily want to put yourself down under "one language". Once you get a few under your belt, learning new languages (at least enough to do CRUD code / bugfixes which honestly is a big chunk of development) then new languages come easy. That being said, Pythons marketshare is a bit smaller, but I've always found it excels in small little one time programs. Need to fixup some SQL data? Python script. Parse some html / xml? Python script.
Keep on learning Python. Then learn Django and get a Django job in a team! Then learn Java and do some JEE dev to learn how it's done there. If you're after "standard" jobs with standard sallary and everything standard, Java might be better suited. The market is (at least in Germany) large. But if standard is not enough for you, go with Python!
I'll run the pages through the validator after I finish making the RSS validator happy. And, don't blame "my friend" for the mishmash of HTML and XHTML; I'm sure that's all my fault. Especially the unclosed &lt;p&gt;
&gt; I am a struggling college student, so knowing the a value of a skill I may potentially soon possess couldn't hurt. The value is in programming and loving programming. Figuring out how to make a living off of it comes after. If you don't enjoy it, drop it. There is no one answer to the question you're asking anyway.
what % of python jobs are web related?
This does not directly answer your question but is an interesting , maybe relevant [survey](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html)
Nope, and I live in Phoenix. Double whammy, one might say.
[Don't call yourself a programmer](http://www.kalzumeus.com/2011/10/28/dont-call-yourself-a-programmer/).
In my experience many people don't know or care about open source projects. They're looking to hire a developer to get something done for their business. Yes, some places may have other developers who are familiar enough with Python's ecosystem to care about such things but they are in the minority. Having some code to show always helps you get hired, but you don't need to be a superstar. 
I'm not your friend, guy.
Hmmm I'm kind of experienced with Python but it seems my lack of knowledge of any web frameworks is hurting 'marketability.' I am thinking of doing a project with Django or web2py.
I'm not your buddy, pal.
I'm not your pal, jerk. C-C-C-COMBO BREAKER
I read this the other day too, and I agree with what he says as far as choice of languages goes. In my opinion, it doesn't matter too much what languages you can program so long as you're capable in more than one. If you've already gone through the process of becoming competent in one language and then adapted to a second language it's really not that tough to learn more as you go. Having said that, and with regard to OP's situation as a novice programmer, I would suggest going with a general purpose scripting language rather than, say, C or Java. I suspect there are more entry level positions this way as there are plenty of ops and web roles that involve a bit of programming but are not too demanding on that front. I recommend python or ruby over perl, as these are the *chic* languages of today. Most of the cool stuff i'm dealing with at the moment as a devops guy is python, ruby or node.js (this last one a fad, i suspect). I've picked python over ruby, but either would be a good choice for OP.
No idea, but mine certainly isn't :-) Lots of unix toolsmithing for release engineering (and svn-wrangling in particular.) The closest to "web" python I get is code that automates configuring Jenkins jobs, or updates twiki pages and jira tickets with things like "this build succeeded and these revisions closed those tickets". More often it's things like "now that we've branched, fix all of the scm pointers in these maven pom.xml files" (maven has a lot of stupid in it, but three different version control pointers *per directory*? Really?) And that ignores the "product" side where we used to have a lot of "C++ for speed, python on top for flexibility", though these days there's more "Java because we're inside lucene/solr", jython hasn't really caught on for that.
I'm not even sure what this is supposed to do. edit: TIL what string inversions are. edit again: I'm somewhat sure this is an assignment, but this sounded like fun. Here's my [implementation.](http://codepad.org/IEUWwgUL)
Why are you splitting the string into a list of the words separated by whitespace? Is the following a correct interpretation of your operation? from itertools import islice def inversions(string): count = 0 for i, char in enumerate(string): for c in islice(string, i + 1, len(string)): count += char &gt; c return count &gt;&gt;&gt; inversions('BA') 1 &gt;&gt;&gt; inversions('DCBA') # 3 + 2 + 1 6 
I disagree. Especially in Python, programming can be a means to an end. Need to do a statistical analysis and produce a graph? Easy, ask numpy and matplotlib. That's just one example. Hell, the whole mindset of programming has helped me to learn other things by thinking about problems differently. Even if you don't love it or plan on doing it as a profession, programming is an incredibly useful skill.
&gt; I have to write a function that adds all of the numbers in a range. Sounds like sum to me! And yes, I'm being deliberately facetious as I know in this classroom environment the point of the exercise is to duplicate the sum() function in order to demonstrate functions, calling functions, and dead simple algorithms so my answer blows all that away.
Yes, find a project that interests you and work on it. "Learning Python", or learning any language, for the sake of then being able to say you know it, is dull, tedious and ultimately unrewarding. You also will never understand the language until you work with it on a real project. If you can find a project that interests you, you have something to work on and work for. Once you know the basics, you will naturally learn more as you wonder "how would I go about doing &lt;x&gt;?". One great thing about Python is that is excels in many domains. Want to make a website? Sure, we got that covered. Want to make a game? Check out pygame. There are so many great libraries and projects out there already that you should have lots to choose from whether you want to create something yourself or contribute to an existing project. And, when it comes to jobs, they are going to want to see something that shows you can actually deliver. As to your original question, I live in Boston and work as a full time Python developer writing automated tests for quality control on a cloud storage application. Not a week goes by that I don't get an email or phone call from some recruiter wondering if I am looking for work, so the demand seems quite high. I'll mention this because you are a college student: if you are at all interested in scientific research, you might be able to score some kind of assistant job at one of the labs on campus. Tons of labs are in the process of converting existing code that is some horrible mishmash of MATLAB, C, Perl and Bash into Python right now. Before my current job I worked at MIT doing exactly that. Learn Numpy and SciPy, and I can guarantee there are a couple labs on campus that would be glad to have you around. One last thing. Check out Zed Shaw's [Learn Python The Hard Way](http://learnpythonthehardway.org/book/). It's free, and it goes through everything from editor setup and absolute basics to medium/advanced topics. It uses step by step exercises and will bring you up to speed in no time. Good luck!
I have front-end web development experience and Python knowledge, and I get contact, on average, once a week by head-hunters. I also know many companies looking for decent python developers.
This is amazing. Really enjoyed it, thank you. That guest was extremely intelligent.
I'm not sure of the desired behaviour, but I believe you're attempting to count the letters out of order? inversions = lambda s: len([c for e,c in enumerate(s[:-1]) if c &gt; s[e+1]]) The only problem is that either way, you're going to skip the first or the last letter - obviously because you have nothing to compare it to (either you're comparing it to the one before or the one after). # PS. If you're unsure about what you're indexing, use a `slice` object. For example, fifth_element = lambda x:x[4] Will raise an IndexError if called with, say, `fifth_element("a")`. But, if you instead do fifth_element = lambda x:x[slice(4,5)] Will return `""` if called with `fifth_element("a")` - slices are "safe".
Depends where I guess but good in UK. Changed jobs 6 months ago, had interviews with a couple of prestigious firms but ended up at a startup, which is cool. Problem is, agents are looking for skills in specific languages but you always need the systems experience to go with it. I think a lot of jobs regardless of language will require you to know how Apache works, SQL, linux etc.
Exactly, if you're going for a job with NASA then that's completely different to a regular $80k job writing some random business app.
Further afield, London (and the whole Thames valley actually) is pretty desperate for Python programmers.
I think you're both right. I think you can be either the sort of programmer who maybe works on a fairly undistinguished business product, but gets kicks and respsect out of doing everything insanely well (coding, database design, architecture, source control), or you could be a relative bodger who uses it as a tool to do something very useful. Python is flexible enough to allow both, which is one reason I like it. I'm probably the former type but I have been able chat to people like medical researchers about what they do with Python too.
There are jobs in python of course, but if you want to be a programmer, the hot languages to know are C#, php, and java. I think python is better as an extra skillset to either augment these languages, or an entirely different skillset. For example, you'll see a bit of python in the scientific community and network engineers use it alot.
I always think of Python as a nice 'rapid prototyping' language for just these reasons.
&gt; I generally love learning, but I tend to be more English/History minded, so I'm slightly out of my element. A lot of people think that learning some basic programming syntax is equivalent to knowing how to program, but it's not... just like knowing a bunch of English words doesn't turn you into a great novelist. To become a great novelist, you need to learn how to effectively communicate your ideas and concepts to the intended audience through the paradigm of your chosen natural language. To become a great programmer, you need to learn how to effectively communicate your ideas and concepts to the computer through the paradigm of your chosen programming language. Basic programming skills will benefit you as an addition to other skills that you might have, but won't necessarily land you a job by themselves. If you really want to work as a programmer, you need to learn some computer science. I would say that getting at least a minor in computer science would be a minimum to have improved chances of employment. I'm not saying this to discourage you from learning, just to keep you from having unrealistic expectations. If you don't want to or can't pursue formal classes while you're in school, then you should at least look in to following an OpenCourseware-based program, coupled with some form of visible portfolio - github projects, or accepted commits to an open source project. The more that you can show potential employers, whether academic credentials or real-world experience, the better your chances for employment.
May be try this also http://www.pythonchallenge.com/
I have a passing familiarity with Python and have considered taking a deep dive into it, but what keeps holding me from this is that it seems like all you see for it is web development stuff - I'm not interested in doing Django, Turbogears, Pylons, etc. - so I don't really know if it's worth it to bother with. Does anyone use Python for things other than web dev? (and other than making games with pygame)
Interesting thread. Was going to make a similar one soon. I know scipy and numpy. My goal is to learn some Django. I see tons of jobs listed for Django, and would be great to have a grasp of it. 
I guess I know where I'm looking for after University. Thanks!
It probably depends on the region you're looking in. In my part of the world (in the east of the Netherlands) Python jobs are really rare, but the ones that do exist are usually very interesting work in companies that take their software development seriously. Right now I'm actually pretty extatic, tomorrow I'll start my first 100% Python gig and I'm really looking forward to it :-) Before that I have had three other programming positions in which I always found small uses for Python but it was never the main thing. However, the key thing is to turn yourself into a professional, all-round programmer. Python is a great start, but knowing more languages is better. If you limit yourself to doing only the same specific thing in your career, it's going to hurt when that thing goes out of fashion.
Sure beats writing PHP or Java! edit: I don't want to imply in anyway that Java is as bad as PHP. It's not but most companies using Java are pretty boring. It just seems to go with the language.
lxml and Amara are both good at it.
I've always wondered what's the best way to encapsulate that on a resume, though? Many people put down a list of the languages they (allegedly) have experience in. Does it put one at a disadvantage to not include a similar list?
I've never put lists like that on a resume and I never will. If you can't figure out what I'm using based on the rest of my resume, you can't read and I don't want to work for you. As an employer, I've never once looked at those to gauge a candidate. If you leave that info out of your work experience or I can't easily discern what you're doing at those jobs, you're probably not who I want. Just putting Python in a list tells me nothing except the fact that you can spell Python (and people have screwed this up).
Can you elaborate? What kind of companies in particular? I know there's plenty of web development jobs around Central London, mainly requiring experience with Django.
I make a nice salary as a Python developer - enough that my wife and I can comfortably raise a family on only my income. I go to my local Python Users Group meetups on a monthly basis, and there always seem to be more people looking for potential employees than there are people looking for work. I've even gotten a couple of unsolicited offers since taking my current position. My company will probably be hiring more developers in the next couple of months. There's not a huge market for Python developers, but what market does exist seems to work in favor of the developers.
If you're looking for marketability, go for Perl and not Python. I love Python, but it's not so widespread yet.
I don't think I'd hire you simply because of how conceited you sound.
We are a Java shop that does some python and some R. Having Python on your resume (or lisp or Smalltalk) will get you on top of the pile here. Having interviewed and given the hiring recommendation for 20+ programmers in my career, I find that those who start with (or learn early on) either python or lisp, tend to be better programmers who learn our technology stack much quicker. PHP and VB tends to have the opposite effect. Java and C# tend to be neutral. And this is a shame since I've seen too may PHP and VB guys who had the math and/or finance background we need but couldn't handle any data-structure more complex than an array. The best programmer I ever worked with was a Math PHD student that taught himself Lisp, went on to Smalltalk then python during the 1.5x days before moving to Java (for threading). Brilliant guy who would inhale books while hacking out what he was learning in a way that looked effortless. 
I write small applications in Python for my company to use internally as well as our vendors. I too have noticed that if you discount web development, there's very little scope for jobs based on Python alone. I have Ruby on my resume as the other primary skillset and I have never got a call from a recruiter that did not ask about Rails. If someone knows places where I can look for opportunities in Python or Ruby, please let me know.
Ditto, I have just installed Django last night and this is exactly the reason why. Despite using Python and Ruby full time, I don't do web dev. With Django, it should be a nice recruiter magnet.
Are these positions related to Web Development? I am a Python programmer but have not worked with any Web Frameworks. I have started learning Django just for the heck of it so I meet industry "spec" resumes.
Well I don't want to be chucking names about, but all I did was stick my CV on monster and I got absolutely dozens of agents calling me. Mind you, a friend of mine is a PHP dude and he found the same thing. I'm out west of London towards Berkshire, which has a lot of tech companies.
Knowing Python would never be a negative would it? Even if you said you know COBOL, knowing additional languages is never bad. 
Exactly. I work with a lot of people who generally hate or are indifferent to programming (they're scientists, they just want results). However, being simulation scientists they definitely see a lot of value in Python and its packages, it's by far the fastest and easiest way for them to write code.
A bit off topic, but I'd love to see more details about your Jenkins and Jira workflow. The build ticket updating automation sounds nice :)
Draft
We do have some Django web applications, but for most of our applications we've built our own frameworks around Django to deal with our own common use cases more easily. Django experience would be a plus, but our application level code is different enough from standard Django that there's still a bit of a learning curve. Honestly, our hiring experience has been difficult enough that we're expecting to have to do some training once we get around to hiring. If we can find a competent Python developer, we can probably deal with a lack of Django experience.
Interesting, do you have any code assignment or something that I could take a crack and see what level of expertise you expect?
As much as you're interviewing me for the job, I'm interviewing you to see if I want to work there. As easily as I can talk my way out of a job, you can talk my way out of it as well. If I'm conceited in this context, oh well, I've been called worse, but the approach works *really well*. Hiring is a war. If you're looking for a job, you want to stay alive as long as you can through the battle. Giving me a zero-context list of your skills is like a one-shot kill. When I have 100 resumes, I'm not going to guess at the skill levels of 50 people when Python shows up in their list. It's wasted space and I'm going to move on to someone who gives me something better. (this is speaking more to people who put lists at the top of their resume, which seems to be the most common in what I've seen) If you really, really must put a list, put it at the end so I can ignore it, and make it small enough to be realistic. A much better move is to just write your job experiences to include those details, as I'm more interested in knowing what you've done with Python and where you've used it rather than just the fact that you apparently know it. Anyone can know Python - I'm more interested in people who have built great things with it.
Not at the moment. We're not actually hiring until we close the deal on our next contract, which should be soon. Until then we don't have interview materials prepared. When I interviewed they looked at my resume to see what kind of experience I had, asked some high level questions about Python and Django to make sure I wasn't just putting buzzwords on my resume, and had me write some very basic Python on a whiteboard. One thing about our company in particular is that we actually use Jython fairly extensively, so we expect people to know what aspects are implementation specific. As an example, in CPython you can generally expect that if you have ten dictionaries with the same set of keys, the keys will print out in the same order for all ten dictionaries. This assumption does not hold in Jython. There are also some differences in how garbage collection is handled.
My impression was that Arduinos have their own language, C-ish in nature. Python is a good choice for data analysis and visualization. 
Just use Arduino's own language for the embedded part. For writing a frontend for data analysis, a Python webapp framework could work nicely. You could look into [rrdtool](http://oss.oetiker.ch/rrdtool/) which is an excellent tool for collecting sensor data and displaying graphs of it.
 Re: the "very basic interface for automation", [serial communication with python](http://www.arduino.cc/playground/Interfacing/Python) is straightforward. Or you can use a terminal application like minicom, putty or picocom to talk to it directly. Arduinos are generally programmed in C++. Arduino "sketches" just add some more user-friendly abstractions, the code gets converted into C++ before it gets compiled. You can either use serial communication or ethernet to connect your arduino to a server (the language in which the server is implemented isn't important). Somebody else probably has more concrete suggestions for the server side of things. You could probably either use a python web server framework and have the arduino [send HTTP requests](http://arduino.cc/en/Tutorial/WebClient), or you could use the lower-level [modules](http://docs.python.org/library/socketserver.html). 
What gives you the idea that it's not so widely spread? It's used in fighter jets, it's used for web sites. It's used for finance, it's used for biology. Not that the same can't be said about Perl (I have no idea), but a lot of people have changed from being surprised to see where Python is being used to now being surprised to see where Python *isn't* being used.
The speed of development for Python trumps any other language I work with.
Call it, friendo.
Looks very cool. I'm actually using some Xbee's with the Arduino's and looking into how much I can do without using Arduino's. Electronics isn't my forte and I have minimal background in programming so a lot of this is about the learning experience! I'm definitely going to use one Arduino as a local brain and gateway before sending data and remote control capabilities to my server though. ninja edit: I'm also having trouble tracking down more info on this Digi automated garden project...
Do you think that it will it also be able to enable the automation algorithm construction?
Thanks for showing me rrdtool!
I was hoping to write a texted-based user interface for local control. Do I have flexibility to do that in the Arduino sketches?
[This guide talks about how to switch over to C if I want more flexibility](http://www.wikihow.com/Write-Arduino-Software-in-C)
any wrapper that uses ctypes runs on pypy fine (actually, better than on cpython). I think there is a wrapper of ODE on the repository... unfortunately it is not using ctypes right now.
It's huge in Geomatics, particularly ArcGIS. With Arc 10 Python became the dominant scripting language, and a lot of the "old hands" haven't learned it. 
You're welcome! [There are some gardening specific tutorials](http://owfs.org/index.php?page=garden) as well :)
Should be OK. I don't have any good examples of that handy, might want to x-post to /r/arduino and see if anybody has info on developing user interfaces for the arduino that are accessible via a terminal application. Something like [this](http://www.battledroids.net/downloads/avrsh.html), but much much much simpler. What you basically want is something that will read bytes from the serial input into some buffer, then when a linebreak is encountered, look at the buffer contents and "do something" based on them. I would be surprised if there's not a fairly nice library for this sort of thing floating around somewhere. good luck.
&gt; len([c for e,c in enumerate(s[:-1]) if c &gt; s[e+1]]) I prefer to write that as `sum(1 for for e,c in enumerate(s[:-1]) if c &gt; s[e+1])`. I don't know if there's actually much memory advantage to it, but the cleanliness of the solution pleases me.
Have you tried testing it with wine? Python support in wine is kindda good, and you forget about the vm.
&gt;—Can work from a laptop (no quadruple-screen-only programming divas please). LOLWTF bye 
Are you trying to get stuff done or fit in with your culture?
Getting someone like that for only 100k is probably pretty hard...
So, how does this all work with XML files that are larger than, say, RSS feeds? For pretty much any real-life XML file, you want something like pulldom, which allows incremental parsing of XML files, without the state machine nightmare.
Adding 0 and checking a condition are about on par in terms of cost. So I'd just add up the bools: sum(c &gt; s[e+1] for e, c in enumerate(s[:-1])) Also, copying the string isn't necessary, so I'd use xrange: sum(s[i] &gt; s[i+1] for i in xrange(len(s) - 1)) That said, it doesn't do what robbd7 wants. robbd7 has a nested loop that counts all of the inversions in the rest of the string compared to the current character. 
You may want to take a look at http://www.pyinstaller.org/wiki/SupportedPackages. Also twisted works fine with GTK 2.x, not GTK 3.x though, not yet anyway.
Python's a great platform for this. For windows, you can freeze executables with py2exe. For linux, there's pyInstaller, and also bbfreeze. 
Perl? I haven't even met anyone in the last five years who lists Perl in their first few languages they mention as using. Python comes up at least 1/4 of the time.
It would be wonderful if this PEP gets implemented. But I rather like to see the death of site.py and *.pth. In my dream solution python would look for a config file relative to its path. That file would have a directive to indicate the folders (preferably just one) that contains python's modules and packages. If I try to import a.b.c.d it will search these folders for: * A package at folder *a.b.c.d*. * A package or module *d* at folder *a.b.c*. * A package *c.d* at folder *a.b*. * A package *b.c.d* at folder *a*. 
Python is awesome for this. [SpiderOak](https://spideroak.com/) is built using a similar toolchain. PM me if you'd like our build scripts and toolchains for all the major platforms. 
TIL collections.namedtuple. I think I have a new favorite python function. Thanks.
&gt;robbd7 has a nested loop that counts all of the inversions in the rest of the string compared to the current character. Ah, is that the desired behaviour? inversions = lambda s: sum([sum([c &gt; k for k in s[e:]]) for e,c in enumerate(s)]) NB: I can safely use `s[e:]` because `s[e] == c` and `c` is never greater than itself - though using `e+1` will generate an `IndexError`! (and a `slice` will produce an empty string, which is also not desired in this use case). I would argue against `xrange`, it's depreciated in Py3K. I also find `len` neater than `sum` because to me, applying `len` against a list comprehensions says "*look at the conditional!*" (the conditional is the only thing that can change the length, and that's the only thing it can do). But both of those are really just personal preferences (`xrange` would be factored out by 2to3) :)
I try to avoid making large temporary data structures and copying sequences (e.g. regular slicing). As to xrange, 2to3 takes care of that. But it wraps range -- and many other 2.x functions that return lists (e.g. dict.items) -- in a list() constructor, which I generally don't want. 
Support started back in the 9.x series...
wxpython ports pretty well between Windows/Linux. I didn't have to change a line of code to get a wxpython app I made to work between both. For creating the executable, I used pyinstaller. I've used py2exe in the past but pyinstaller is so much easier to work with. I've always had to deal with missing DLLs, forcing the builder not to include a particular library so it wouldn't complain, and so forth with py2exe. pyinstaller pretty much has everything ready to go out of the box. As for a Windows installer/packager, AdvancedInstaller works pretty well. 
What is your PC platform first of all? If you're on Debian, then use apt-get install arduino That will install Sketch which you start on a Debian system by typing "arduino" from a shell. Once you open Sketch you will see there are dozens of templates you can modify. 
Another good [numpy/scipy tutorial](http://scipy-lectures.github.com/).
Any reason that it couldn't have a web interface? For DB you may want to look into Mongo (http://www.mongodb.org)
Both.
&gt; I would argue against `xrange`, it's depreciated in Py3K. ??? Other way around. `range` was removed from Py3K, and then `xrange` was renamed to `range`. That's the opposite of deprecation. 
The root cause of this problem is having too many versions of Python. This is not desirable. And some people like Zed Shaw complained about it. What should be fixed is the root cause(s) for this problem, instead of finding a work-around like virtual environments.
&gt; job market like for someone who knows Python? Same question I had until reality hits me since a year ago. Answer is a question: "How good are you going to be ?" I started self-learning about 2 years ago, on my own, job does not use/require it. I like the language and absolutely love the community. Now the reality (from my perspective) - The thing is... 1) The fact is Python job opportunity, in general, is just incomparable to Java/.Net (I knew that) 2) 90% of the Python jobs i see ask for "Expert-level" or "Lead" or "Senior" or "Top Python talents".... you get the idea. I guess it's a sign of the times, one has to be an "expert" in the respective area(s) to score that job. 3) Seems large percentage of the jobs is Web development (Django). So at this point, in this shit-awful job market, I'm rather pessimistic about getting a "Python job". Too bad this is no longer the 90's. 
&gt; for a nearly 95% pay increase WOW Were you badly underpaid at the previous job(s) ? what is your experience level ?
&gt; Need to fixup some SQL data? Python script. huh ? serious ? how about doing it with SQL while the data is *inside* its native home ?
what is your skill/experience level ? just curious.
are you trolling ? 
I could. The last thing I remember fixing had to do with date calculation. It was 100% easier to read in the columns, calculate the dates in python and create a text file of updates to run, so that I could check them before running it.
I'd like to think I'm pretty good, but I'm also an arrogant ass, so... books open on that one. I've been programming for about 4.5 years, 4 in Python.
You might want to consider rendering html/css. Why use a platform-specific UI library, html is almost everywhere. Plus, you get to run it remotely for free.
I have around 5 years of experience, no degree, and yeah I was pretty underpaid at my previous job - I worked for a state university. They can't really pay a lot. I think my new employer understood that, which is why they were willing to go for such a huge increase in pay. Yes, they knew how much I had been making previously and still gave me the amount I asked for, so I probably could have gone higher...oh well.
I thought that might work. Tried to do that with py2exe and failed miserably. I figured I'd just try the VM first. Perhaps next time I need to set it up. Probably pretty easy, winetricks will install py2.6 for you, you'd only have to install pyinstaller. Thank you!
god i hope this doesnt become a mantra. theres a lot of good stuff in that essay, hen its applied with reason, but theres nothing wrong with calling yourself a programmer, especially if you are talking to another programmer.
I used [wxPython](http://www.wxpython.org/) to make [this](https://github.com/lappet/google-storage-ui) 
PySerial can be used to communicate to the Arduino serially.
Okay. I look forward to more podcasts. 
untangle is mostly geared towards quickly getting some basic info out of a simple XML file.
Also cx_Freeze, which is cross platform (Windows, Linux, and I think OS X too).
It's not like all the code and all the libraries written for Python have 200-300 lines of code and they can be rewritten in two days. There are also many other applications which aren't written in Python, but need to work together with Python. There's still code out there which requires Python 2.4 (not newer) to work at all. With that in mind, you should really learn Python 2.6/2.7 and also learn 3 whenever you have the time.
It started off with Mongo, but I realized if I wanted to package/distribute it I'd need something that doesn't take me 20 mins to fix to make sure that Unicode support works. Had to recompile SpiderMonkey on ubuntu to get it to work. Mongo is great and I'd definitely use it if I was going to be the only person using this app. The web interface is an interesting idea, and might be easier than learning GTK in this instance.
Well for biology, that _is_ Perl's game right now. Bioinformatics. I'm sure Python is used just the same, but from what I've seen in my studies, most bioinformatic research is using Perl. Websites, on the other hand, is definitely Python's game. Fighter jets isn't the greatest example becuase I don't think that adds anything to its marketability. I'm sure Perl has a greater chunk of the finance share, because it's older. I work for a large corporation, where some teams use Python, but most teams are still using Perl. Why? Perl is older, and just like the ragged old monitors still here, corporations don't necessarily change at lightning speed unless it's necessary. Perl is still a very capable &amp; well-maintained language, so there is no necessity. Since medium -&gt; big companies are the ones hiring the most, I get the idea that Perl is probably more marketable. Then again, if you want to go after less money, but more fun, then the savvy young companies are probably using Python. Anyway, I think I got the idea from http://www.youtube.com/watch?v=oeghXnAGJV4 Be warned though, that host may irritate you.
Tail calls?
As an alternative, I implemented Scheme in Scheme at my blog [today](http://programmingpraxis.com/2011/11/01/rip-john-mccarthy/).
&gt; I'm sure Perl has a greater chunk of the finance share, because it's older. In my experience it doesn't, having worked at three finance related positions in the last 12 years and had most of my family done the same over a longer period of time, zero of these organizations used Perl in their software stacks. &gt; Perl is older, and just like the ragged old monitors still here, corporations don't necessarily change at lightning speed unless it's necessary. This second part is true, but on the first, consider that Python is almost 22 years old now, which is only a few (3, 4 IIRC) behind Perl. It's not really "new" and unable to break into new business areas. I was working at a big foreign bank in 2004 which was using Python 2.2, which was after they upgraded from a late 1.x version. From what I was told, they stuck with 2.2 until something like 2008. Even though they were stuck using an older version, they were able to get some really good people in the door. On the marketability standpoint, I guess that depends on your area and interests. I'm in Chicago, a huge financial area, and I can't remember the last time I've seen Perl on a job listing. Maybe that's a selection bias, as I don't search for Perl jobs, but I get all kinds of other jobs unrelated to my skills sent to me by spammers/recruiters. You like Perl and you think it's a better move, and I like Python and I think it's a better move. I suspect we could just go back and forth on this forever :)
Hey, hey! I never said anything about liking Perl! :D Python is the better of the two by far. I always miss 'in' &amp; 'is' when working with Perl. I just had the idea that Perl is more marketable, but I only have vague generalizations to back that up with.
I would love to get involved with this. I have had plans to do a similar type thing in the back of my mind for a while now. I have always been looking for ways to combine my programming with music since those are my two loves. I am a guitar teacher that went to the Peabody Conservatory of Music and currently a programmer for a DOD contracting company and really want to do something that brings those two passions of mine together. I havent looked at your link yet and I will in a few, but i think i could probably have a reasonable amount to offer especially with my music background. A few questions - is there any overall target of this project? What sort of things are you looking to get implemented that arent there yet? Im sure ill think of more questions later, but i guess i should go look at the thing first haha.
If you're going for a job with NASA you might want to pick up an engineering degree (Computer Science and math are good options too)and start making contacts.
just did a little looking at what you have here - will have to look more later because im at work, but there is a lot of potential for coolness here. If somebody hasnt already done it, id like to fix your scales to represent themselves correctly. All scales in sharp keys are represented accurately from the brief testing i did (very brief), but scales in flat keys are being incorrectly written - ex - F Major scale should be written as "F,G,A,Bb,C,D,E" but instead is written out as "F,G,A,A#,C,D,E". Same pitches so when played it sounds correctly, but technically when written out that way it is not a major scale. Still, good work, im excited to spend more time getting a hang of this later today
Yes, Mark Pilgrim has taken all of his sites down. Thankfully, they have been widely mirrored. I believe this is what you are looking for. http://www.diveintopython3.net/ or http://diveintopython3.ep.io/
Whatever happened to him?
Yeah of course, I just used that as an example of a high-flying job.
that's pretty Pythonic
All anyone knows is that he wrote a list of steps he needs to do to make himself a more fulfilled human. Basically it involved eventually living with as few possessions and responsibilities as possible. Very Zen like. 
No. Do yourself a favor. Learn Python the Hard Way: http://learnpythonthehardway.org/
I don't agree. It's good for the novice programmer, but it's highly redundant for those with several years' experience in other language environments and for them it doesn't represent an optimal use of time.
So he's gone and done a _why.
Responded to your PM :)
Seconded, except I will say that I often have to make tiny tiny tweaks to UI layout in going from Linux to Windows. Icons are about the only pain point left if you go this route, though. Also if you use AdvancedInstaller you can forego pyInstaller and just install Python, wxPython, etc. as dependencies to your application. I've done this once or twice for packages that didn't work well with being frozen.
For all we know he is training to be a dive instructor somewhere tropical. Drinking mohito's and shagging Swedish tourists.
&gt; What things can I do to ensure that the resulting application will be rock-solid? That's easy -- take a few minutes away from your project to solve the [Turing Halting Problem](http://en.wikipedia.org/wiki/Halting_problem). What I am saying is I think "rock-solid" might have been a bad choice of words. There are any number of ways to improve the reliability of your code -- structure, encapsulation, best OO design practices. And unit testing. But you cannot achieve "rock-solid". That's not in the realm of the possible. If high reliability were paramount in importance, you might want to consider functional languages instead of Python -- languages like Haskell. As with all functional languages, Haskell is reliable in direct proportion to the degree that it is isolated from the corporeal world (i.e. minimizes I/O). On a more practical level, maybe Python isn't the best choice for a project in which reliability has the highest priority. Python was originally meant to speed up development time at the expense of other issues like fast execution or easy analysis of source structure. To make my point, consider the fact that Python has no block tokens. This saves time when typing Python source, but the rest of the time this "feature" makes it difficult to process or analyze the source. I can't tell you how many times we see a student with a program that should work, but won't, only because a block of code has the wrong white-space indentation with respect to the blocks around it. As programs become more complex, the problem of simply scanning and interpreting source code becomes more severe. The short form -- these two statements appear to be in conflict: * I want a rock-solid program. * I chose Python. 
Not the worst way to have one. 
I've got my MS in Physics, work in the applied sciences, and I'm coding Python just about every day I'm in the office (handling data, writing desktop apps for other departments, etc.). I think I average about a call/email a week from recruiters, but echoing some of the other comments here it's always "Python + Django" or "Python + HTML/CSS/JavaScript" they're after. So I think there is a market for Python but in my experience at least you'll need some webwork to be truly marketable.
an effort to preserve his work: http://meyerweb.com/eric/thoughts/2011/10/04/searching-for-mark-pilgrim/
Didn't he do something like this a couple of years back?
I certainly have been considering the use of a functional language (though I have been leaning towards Scala instead of Haskell). A strong type system could offer significant benefits. Still, given that this is /r/python, I wonder if you're ultimate conclusion will be controversial? :)
If your project deals with a lot of inputs which may be bad (E.g., user input) provide a clear distinction between methods which validate input and methods which work on already-validated input. If appropriate, you might even write acceptance tests which validate all the possible inputs you're going to be dealing with. Write your own error classes for the app. You'll need to decide what makes the most sense, but on the one extreme is to catch all errors which could be reasonably raised and re-raise them as custom errors. Obviously you can go too far with this, so use your best judgement. Type checking certainly wouldn't hurt your chances, but you **absolutely can not** expect the compiler to make your app "rock solid"
Another idealist bites the dust.
&gt; Still, given that this is /r/python, I wonder if you're ultimate conclusion will be controversial? :) Not among those who (a) have a wide exposure to languages and (b) have used Python a lot. This is in no way meant to disparage Python, which is a very good answer to a particular need, but is not meant to answer all needs. 
&gt; I can't tell you how many times we see a student with a program that should work, but won't, only because a block of code has the wrong white-space indentation with respect to the blocks around it. This makes me question your other, otherwise seemingly valid points. I can tell you how many times I had indentation-related bugs myself or saw indentation-related bugs in other people's code: __zero__. Like, it doesn't happen "rarely", nor "extremely rarely", nor even "maybe a couple of times in my career", but __never__. And I have quite a lot of Python experience (though not with students, admittedly). At the same time I _do_ remember some block-structure related bugs I had made/seen with C++. So this point of yours is absolutely totally wrong as far as my experience is concerned: Python's use of indentation for delimiting blocks prevents bugs. (I should add that I don't use tabs, and am lucky to never have dealt with code written by misguided people who do. That might be one of the reasons. Also, as I said, I don't work with students (but then, wouldn't they fuck their block structure up even more often when using other languages?)) By the way, Haskell also uses indentation for specifying block structure, though a bit differently from Python, so your point seems even weirder.
http://docs.python.org/library/csv.html http://docs.python.org/library/os.html#os.makedirs http://docs.python.org/library/os.path.html#os.path.exists http://docs.python.org/library/os.path.html#os.path.join # pseudocode def mkdirs(root, path): path = join(root, path) makedirs(path) for subdir in ['sub1', 'sub2', 'sub3']: sub = join(path, subdir) makedirs(sub) for row in csvreader: mkdirs('/destination/folder', row['address']) 
Arduinos actually use real C or real C++. The Arduino IDE applies some super-simple transformations to your Arduino code to transform it into C++, but you can largely ignore these training wheels and just code in C or C++.