danke!
I also tried all of those horrid websites and tried to get a job normally but none of it worked. I gave up on that. I built a small consultancy which eventually led into a well paid job at a major multinational here. (It sounds like an informercial when put that way, lol.) There are no good websites to get a job worth working; there is your human network and your ability to show your skills. I made more money off of Craigslist and the ACCJ than Careercross or Daijob. If you are new at the programming game, pm me and maybe we can talk more in private. 
I made a curriculum of all the resources that helped me. https://www.coursly.com/curricula/14/
No, liability when someone gets hired and the job isn't what they were told it was.
Note that this does not require you to login and there is no tracking done. It is just for fun.
You don't. Also, you can use the 'with' statement in psycopg2 from version 2.5. Try this: #!/usr/bin/python import psycopg2 counter = 0 #Connect to DB with psycopg2.connect("dbname=testing user=postgres") as conn: with conn.cursor() as cur: while counter &lt; 1000: cur.execute("INSERT INTO test (f_name, l_name) VALUES (%s, %s)", ("Bob", "Babaluba")) counter = counter + 1
Yes I use anaconda when teaching. It sets the path for you and is completely self contained so it is really easy to uninstall. Plus you won't need administrative rights to install it. Comes with a lot of stuff including pip. Also really easy to update all your packages. Highly recommended.
Nice. This is much smarter!
Here is what I tried and I get "psycopg2.InterfaceError: cursor already closed" :( while counter &lt; 1000: cur.execute("INSERT INTO test (f_name, l_name) VALUES (%s, %s)", ("Bob", "Babaluba")) conn.commit() cur.close() counter = counter + 1 conn.close() 
Looks great. Will check it out! Thanks for your hard work. 
Ahhhhhh I see. I was closing the cursor and the connection on the first block of the code. I uncomment those out and I placed the cursor and connection close statements at the very bottom outside of the loop. Danka :D
Are you familiar with vector math? Consider building a ray tracer! You can have the output be printing characters to the terminal, so no graphics libraries required!
Of course! So in a (hopefully) less confusing description: I've got an array of time series data that start at 0, go to a value (between 99 and 233), plateau, then return to 0. At random points during the plateau the value has been contaminated with either the values 256 or 512 in addition to the value. I just want my data to go back to its original value without the 256 or 512 summation. 
i really like Click, and I'm surprised 1.0 came out so soon. however in practice I prefer [argh](https://pypi.python.org/pypi/argh) because: 1. argh generates parsers automatically based on function signature, you don't have to declare every parameter. 2. you can return/yield output and argh handles io for you. awesome for playing in interactive or writing tests or using it as modules. docopt looks pretty but things get ugly when you get parsed args.
Yeah, I just realised that: &gt; Please Note: The job board is currently undergoing a major overhaul to port it to the new python.org website system. Job postings can still be submitted, but at the moment we are only collecting them to have them displayed on the site once the new system is ready to go live. 
I love BeautifulSoup.
I've tried pygame, pyglet, cocos2d, and Kivy. I ended up writing my game to teach electronics, Electropocalypse ( http://electropocalypse.com ) using Kivy and was very satisfied. After Kivy, I think pygame would be my choice. Pyglet and Cocos2D which uses Pyglet are nicer to use, but pyglet is doesn't have a good release process (i.e. they never release) so you have to use code from the repo and that seems unstable. A big concern too is how to package your python game into a .exe or .app and code sign it when you are done. I was able to do it with Kivy after jumping through many hoops. If you get there, I might be able to help if you have trouble.
Hey thanks, I got it to work!
Bar hello world. My first program was a Rock, Paper, Scissors, Lizard, Spock game. Accepts input from the terminal and the computer chose one at random. Print out the result. Win, lose or draw. 
You might find the [/r/blenderpython](http://www.reddit.com/r/blenderpython/) subreddit useful.
Maybe it's a good opportunity to ask where the double hyphened options come from? It always puzzled me that there are special rules for single character options such as '-a' which set apart from double hyphened multi character options such as '--abc'. Is there are technical reason for this or is it a mannerism of some sort? AFAIK this convention cannot be tracked back to POSIX. 
What's intersting to you? You could build a web scraper, automation bot with Sikuli (python-based DSL running on Java), recipe book with search based on ingredients on hand, etc.
This is an awesome alternative for command line interfaces. Awesome work and a great contribution to open source software. Keep it up!
Personally I am using pySDL2, which is actively maintained and is a direct wrapper of the SDL2 library, so if you have to port to C[++] it will be rather easy. Another benefit is that you can use the official SDL2 documentation as reference. As far as I know it also runs on pypy. Either way: You should read quite a bit into OOP to understand how to properly use whichever library you decide to go with even if your own code is rather procedural. Writing your own pong, tictactoe, four wins or tetris would be a good start to get into the libraries. For collaboration I would advise you to come up with a coding standard for the project(PEP8 is mostly used as an coding standard in the python community.) and a commit message standard so that commit messages like "fixed bug" aren't committed.
&gt; things get ugly when you get parsed args. What do you mean exactly?
I like the elegance of the script, it is nice and concise. Is there a reason you didn't include the youtube-dl-playlist module in the package directly? It would forgo the subprocess call and remove the dependency on a separate package.
Conventionaly on Unix OSes, `-abc` would be 3 option, `a`, `b`, and `c` (i.e., the same as `-a -b -c`), whereas `--abc` would be 1 option, `abc`. GNU software popularized the long options (e.g., `--abc`) because they are easier to remember, but such software needed a way to distinguish long options from multiple concatenated "short" options, so `--` was used to designate long options. (Some programs defy convention, especially on some BSDs. For example, in `java`, `-version` is a single option, `version`, not 7.)
As far as I can remember it's basically just historical inertia. The original Unix commands never had long options, only single character ones, and they worked the way they did not because of a specific design but just because that's the way it had always been. Then when the GNU project started replacing core Unix tools, they added long options but left the short ones the same so as not to break compatibility with existing shell scripts etc. And thus we have two different conventions for arguments -- single character ones in the old school Unix style, and long ones in the GNU style, both of which have now been reinforced with many generations of parsing libraries that implement them.
Does this work on Windows as well?
Yes. The docs also recommend using `setuptools` for making scripts executable which will automatically give you generated .exe wrappers on windows. http://click.pocoo.org/setuptools/
&gt; It's like buying a ferarri but only driving it on sundays at 30mph. Why do you think that way? 
Off topic, but maybe nice to know when starting out: instead of counter = 0 while counter &lt; 1000: print('counter is:', counter) counter = counter + 1 try doing it the Python way: for counter in range(1000): print('counter is:', counter) (If you're using Python 2, use xrange() instead of range())
Yes, all the code would live in the same application / process. Twisted would run the whole application, and handle all the incoming requests, directing them to the Flask WSGI app or to a WebSocket handler, based on the URL. 
Hey! Thank you! I'll think about it :) What about to put the app in the kivy gallery?
Have a read of: * http://www.dabeaz.com/generators/ Parsing of Apache logs is covered in that as an example. What is it you are trying to achieve? What you are trying to do may dictate what may be better. There could even be completely different ways of doing what you want without needing to parse the log files.
Download active-python2.7 which has pip installed by default ?
If you worry about things like based on a vague posting on a subreddit, you will never find your place in this world. Good luck to you.
Exactly why I wasn't as hyped as other people by it. Sure, it easily supports specifying the most complex CLI interfaces, but then it just dumps you some stupid dict and says “there, handle it”, and you end up doing all the branching yourself.
&gt;More importantly though it breaks too easily if you use decorators. For instance the pass decorator would completely break it. Sounds like a problem in theory but it's rarely the case you need to decorate a CLI entrypoint with a decorator which changes the signature, also it won't break if you wrap functions with [decorator](https://pypi.python.org/pypi/decorator). The feature is extremely useful when you want to make a prototype easily and you can always use @click.option later. &gt;Is that really a useful feature? Click handles support for terminal encoding through the click.echo function. I decided against making click commands callable regularly as API functions because it becomes really hard to guarantee that they stay stable API as the CLI evolves. What purpose other than result/output do you have in mind for return value of command as the CLI evolves? Error code can/should be done with exceptions. API stability is user's responsibility. it basically transparently convert python function to a CLI, you don't have to wrap it with an extra layer and output via click.echo() which looks foreigner than return/yield, which provides py2/3 compatible syntax without extra API calls. It makes testing as easy as testing python functions(no need to rtfm) I'm not saying about right or wrong, they are just features I always miss when working with Click.
&gt; Sounds like a problem in theory but it's rarely the case you need to decorate a CLI entrypoint with a decorator which changes the signature Except any non trivial click application will use such decorators to pass state through: http://click.pocoo.org/api/?highlight=make_pass_decorator#click.make_pass_decorator &gt; also it won't break if you wrap functions with decorator a) it's an external library and I don't want to depend on that for no good reason, and there is no good reason because b) decorator is an insane eval() hack that I do not want to depend on in a library that should be somewhat fast on interpreter startup. &gt; What purpose other than result/output do you have in mind for return value of command as the CLI evolves? There is no return value. Not every feature needs to be used in an API. Leaving the return value up for others makes decorators more powerful as now a decorator can use the return value to do something. The obvious usecase is that a supercommand's return value could be passed to a subcommand for instance. &gt; click.echo() which looks foreigner than return/yield, which provides py2/3 compatible syntax without extra API calls Except that return can only return a single item rendering it useless for composable UIs which want to print everywhere and generators suspend execution which means that subclass need to be converted into generators too to make it work. A function call is simple and works. &gt; It makes testing as easy as testing python functions(no need to rtfm) Except in any complex application that's completely wrong because of different argument types. There is a reason this whole thing goes through a parser and does not just pass argument lists around. The idea that you can unittest a command line application by bypassing the command line parser which handles all the type conversions and more is dangerous and I do not want to encourage that.
So, if I have already found my place in the world, does that mean you're wrong? That's a rhetorical question by the way.
you are the boss. after all people who don't write complex application everyday still have argh.
I am green with envy... That game looks fantastic to me. I wish to have such creative mind. 
Instead of `A*B`, try `A.dot(B)`. ([In Python 3.5](http://legacy.python.org/dev/peps/pep-0465/), you can use `A @ B`) This is matrix multiplication you want, not element-wise multiplication.
I know of no situation where an informal discussion about a possible job at an unspecified company with unspecified requirements (beyond a need to be conversant in serveral languages) led to "personal liability". Especially in the post-Koizumi period where employer requirements are significantly relaxed. Please contact me privately if you are a lawyer who has some familiarity with Japanese contract law; I'll be happy to pay for your Reddit gold and give a contribution to the Electronic Freedom Foundation. Otherwise, it's FUD and you shouldn't be offering legal advice.
cool story bro, tell it again
Nowadays it makes no sense to use beautiful soup any more. The parsing algorithm for browsers has been standardized since HTML5 and there are standard conforming implementations for HTML5 in Python (for instance through html5lib).
some screenshots of admin interfaces will be nice
"Tcl", "defy", I'm not surprised.
Thanks for all the help! I just found out about data types, so changed my values to uint8 (thereby removing bits 9 and 10) then back to int. Seems to do what I was after! Again, thanks for all the advice!
Because your code iterates over all the elements in index. Thus, first checking ['udacity', ['http://udacity.com', 'http://npr.org']], and appending url to it, and then, over the next iteration the condition is not satisfied : ['computing', ['http://acm.org']]] keyword is 'computing' and not 'udacity' so the else statement of your function is executed. But, this is typically the case when you are better off with a dictionnary : index = { 'udacity': ['http://udacity.com', 'http://npr.org'], 'computing', ['http://acm.org'] } def add_to_index(index, keyword, url): index.setdefault(keyword, []).append(url) # this part ensure there is an array initialized for your keyword and then returns the value associated with this keyword for which you call append
I spent a lot more than ten seconds staring at your code and got a headache from the lack of formatting. If you want to fix it (code blocks should have a blank line before and after, and each line should start with 4 spaces), then I'll try to help.
Be nice, code formating is because of reddit.
You probably don't need to learn about sockets to make a bot, but you totally should anyway. 1. A socket represents a connection to a computer. It's a unique set of your ip, their ip, the port you're using and the port they're using. 2. The server tells its operating system that it wants to accept connections on a port. The client program tells its operating system that it wants to connect to an ip address and a port. The operating system makes it so with black magic. (for more, read about TCP, or put it out of your mind until you've used them a bit) 3. Yes, `socket.connect` will raise an error if it times out. (is that what you meant?) 4. I'm not sure what you mean by "banners" 5. Outgoing connections (when a computer on your network opens a connection to a computer not on your network, like `s = socket.socket(); s.connect(('google.com', 80))` and incoming connections (when a computer not on your network initiates a connection with one on your network) can be considered separately. The former probably wouldn't be blocked (`s = socket.socket(); s.connect(('google.com', 80)); s.send('GET /\n\n'); print s.recv(10000)` is how your browser downloads web pages - if the router blocked the outgoing connect, this wouldn't work), but the latter could be. It's hard to run a server locally that accepts incoming connections, and it involves things like getting a static ip and port forwarding - most people cheaply rent machines that are always on and already set up with dedicated ip addresses somewhere far away instead (linode, ec2, etc.). Fortunately, for many things you don't have to; you can initiate the connections you need to make. Some resources to look at: * https://docs.python.org/2/howto/sockets.html * http://beej.us/guide/bgnet/ * http://www.amazon.com/Foundations-Python-Network-Programming-comprehensive/dp/1430230037 
b/c there are compelling reasons to be on appengine. So if you choose to be on it, use it, dont use a framework that tries to hide the details(and fails) b/c then you wont get any of the advantages you anticipated having by choosing it in the first place. edit: as an example, list properties in datastore. at least when I looked at django-nonrel years ago, the orm abstraction did not use it and instead did very inefficient queries that were guaranteed to lead to poor performance and exceeding your quotas. thats just one example I can think of. 
I'm sorry! I tried to fix it and it didn't work. I'll try again.
Feel free to cross-post to /r/semanticweb.
&gt; it's basically just historical inertia I think it's more than that - it's also a good idea. In practice it provides long easier-to-remember commands for everything, short commands as well for the most common commands.
This thread has been linked to from elsewhere on reddit. - [/r/_test] [\[xpost-bot\] Python script to download youtube channels](http://np.reddit.com/r/_test/comments/267hup/xpostbot_python_script_to_download_youtube/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
What do you want them to call themselves? Ugly?
You should take a look at [Logstash](http://logstash.net/). It's not a python module, but you can output the parsed data in pretty much any database and/or format you want. The usual combination is parsing logs and feeding them to Elasticsearch, which makes them searchable. You can query Elasticsearch either by a REST-API (works great with the requests library and json module) or you can use a module provided by Elasticsearch itself: http://www.elasticsearch.org/guide/en/elasticsearch/client/python-api/current/index.html Here is a good webinar, which shows how Logstash can be used for server-logs: http://www.elasticsearch.org/webinars/introduction-to-logstash/
I think most Python developers eventually see ourselves more as craftsmen or artisans than developers or even computer scientists. When you spend a significant part of your time and energy designing a library, implementing it, refactoring it until you're satisfied with it and generally making it the best product you're capable of making - it doesn't feel like "just a library" anymore. It's proof of your mastery of the concept, a literal masterpiece. So, yes - I think "beautiful" is a very good word to describe the goal of such a project.
same problem here, it doesn't show what symbol to tap
Plotly seems nice enough but I have no interest in using a tool that forces me to upload all my plots/data to a third party cloud provider. I'd love to see the ability to run a local server for Plotly along the lines of the IPython notebook, that would certainly get me using it!
My checklist might be something like this: * You should be able to follow along with [Rayomd Hettinger](https://www.youtube.com/watch?v=OSGv2VnC0go) and not find anything too surprising. * You should know the commonly used standard library (os, sys, datetime, time, shutil, random ...) and built-ins (min, max, round, any, all, hasattr, getattr, dict, set ...) * You should recognized the purpose of most of the magic double underscore methods of classes. * You should be able to code at least 3 significantly different [fizzbuzz](https://en.wikipedia.org/wiki/Fizz_buzz) solutions in less than 30 minutes. Edit to add: you should know at least one other language fairly well.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Fizz buzz**](https://en.wikipedia.org/wiki/Fizz%20buzz): [](#sfw) --- &gt; &gt;__Fizz buzz__ (also known as __bizz buzz__, or simply __buzz__) is a group word game for children to teach them about [division](https://en.wikipedia.org/wiki/Division_(mathematics\)). Players take turns to count incrementally, replacing any number divisible by three with the word "fizz", and any number divisible by five with the word "buzz". &gt; --- ^Interesting: [^Pseudocode](https://en.wikipedia.org/wiki/Pseudocode) ^| [^List ^of ^drinking ^games](https://en.wikipedia.org/wiki/List_of_drinking_games) ^| [^Surface ^lure](https://en.wikipedia.org/wiki/Surface_lure) ^| [^Pin-tailed ^snipe](https://en.wikipedia.org/wiki/Pin-tailed_snipe) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+choeils) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+choeils)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Poker hand evaluator. For learning new programming languages, I always choose a project that piques my interest, is not completely trivial to implement, and has extensions which allow me to keep going if I want to.
You could have an arg called hello-world which is obviously an invalid name for a variable.
So, optional override? I don't think I'd be satisfied with using the parameter name even by default, though, as it implicitly alters your command line interface any time you refactor the function signature.
If you want something similar to Matlab, why not check out spyder (https://code.google.com/p/spyderlib/)
Could you give an example? I use docopt but I don't know what you mean by parsed args, even though I know what each word means of course. &gt;things get ugly when you get parsed args.
I am grateful for any and all work on this kind of thing, for both personal use and my job. I'm loving [plumbum](http://plumbum.readthedocs.org/en/latest/) for all this stuff right now. Here's the example Armin / mitsuhiko [posted here](http://www.reddit.com/r/Python/comments/265wab/click_10_released_the_microframework_for_command/chnxvid), plumbum style: from plumbum.cli import Application, SwitchAttr class Hello(Application): '''Simple program that greets NAME for a total of COUNT times.''' count = SwitchAttr(['count'], int, 1, argname='COUNT', help='Number of greetings.') name = SwitchAttr(['name'], argname='NAME', help='The person to greet.') def main(self): if not self.name: self.name = input('Your name: ') for x in range(self.count): print('Hello %s!' % self.name) if __name__ == '__main__': Hello.run() And here's the output when passing the `-h` flag: Simple program that greets NAME for a total of COUNT times. Usage: plumbumzample.py [SWITCHES] Meta-switches: -h, --help Prints this help message and quits -v, --version Prints the program's version and quits Switches: --count COUNT:int Number of greetings.; the default is 1 --name NAME:str The person to greet. 
I am surprised that this is a work of Armin. I am sure the codes look good, but this interface feels like an overkill of Python decoration. I think for a non-trivial command line interface, you will massacre the decorated function with decorators.
Because that's how you get most people interested in your "product"
This for instance is click vs docopt for a cat like program. Note that the docopt one has the arguments the wrong way round due to technical limitations in the docopt parser. https://gist.github.com/mitsuhiko/f315e39c9e9e1ccf483f Also the docopt example does not support binary content on Python 3 whereas the click one does.
I never noticed this. Where else have you seen it besides Beautiful Soup? (the name of which is taken from a Lewis Carroll poem, and for a HTML parser seems like a clever choice indeed). If it is catching on to use "beautiful", that's...unpleasant.
It's not easy to come up with a good design for command line parsing. I tried classes with Django style descriptors first, then I tried an explicit thing that just gives you an accessor object etc. The decorator style by far is the easiest on the eyes and to write without putting arbitrary restrictions in place. The low level interface is also available so no need to use the decorators.
/r/learnpython would be a great place for this.
I see! Thanks for the example.
The playlist script is useful on it's own. I could include the playlist script in the code, but then I would have to maintain the same code twice. A subprocess is also created each time a video is downloaded as the playlist script calls [youtube-dl](https://github.com/rg3/youtube-dl). I will make a Linux install script and/or a pip package.
I'm no Python pro but are you sure that's the right [file mode](https://docs.python.org/2/tutorial/inputoutput.html#reading-and-writing-files)? Now sure if w will append it like I assume you want or if it just writes over itself 20 times and thus you get 1 write to file. 
I'd open the file for appending ('a' instead of 'w'), or open the file outside the while loop.
I am an idiot. Thank you for pointing it out :) It works now yaaay
yeah I am an idiot :-|
I have to agree about kv. I found the kv language, combined with incomplete usage examples in the docs, to be the most frustrating part of Kivy. In the end I ditched kv to go pure Kivy python, and muddled my way through all the stuff that is only described in the docs through kv.
Just to make sure, you realize that opening the file inside isn't really pythonic and is bad even if you open it for append. (imagine if the file already exists and you want to overwrite the previous file). You should do with open('sid.txt', 'w') as outFile: LOOP end "with" is awesome, if LOOP were to bomb out, the with syntax ensures that the file is closed. To clarify, I'm suggesting this instead of outfile = open('sid.txt', 'w') LOOP outfile.close()
Yes I definitley recommend Anaconda if you're on Wondows or Mac. If you don't want to install all the packages that comes with it, there's also miniconda.
oh wow. Man Bash has taught me some very bad habits :( Thank you for the pointers. One more thing if you do not mind. I am having trouble appending a new line after variable curl is printed. I can do a new line if everything is text but when you want to add a new line after you print a variable how do you do that? I have tried many things and nothing is working :( EDIT: HA I found how to add new lines. outFile.write("\n") outFile.write("\n") 
Just an FYI, but this doesn't cover anything that's not already documented in the tutorials on the Kivy website. Also, buildozer is likely much easier for most people to use than python-for-android directly. 
How can I download ALL their uploaded videos? Including ones not in a playlist Edit: figured it out &gt;youtube-dl http://www.youtube.com/user/foobar/videos
How easy is it to integrate C code and when would you need to with pySDL2? I have a pretty good grasp on C, which is what SDL is written in.
I've considered also making games in python, but packaging (I'm on Mac) for distribution seems to be a pain point. What kind of hoops did you have to jump through?
For example if you notice for whatever reason that you want to port the engine to C, because the performance isn't sufficient. I am a turn-based game guy so it is something that I haven't given much thought, but it is always nice to have the option I guess.
That seems like a good route to take if we want to take the project past python development
So I literally only just started messing about in the tablet world, could you point me towards cool shit about this "buildozer"?
https://github.com/kivy/buildozer http://kivy.org/docs/guide/packaging-android.html http://buildozer.readthedocs.org/en/latest/ http://inclem.net/2014/01/12/kivy-crash-course/2_building_an_android_apk/
I quite like what I've heard of the overtime culture in Japan. I've integrated it into my work in England. It makes more sense here, though. We work with schools, so we have large periods of no work, and leaving early, then large periods of lots of work, and staying late.
Code is love, code is life, such is the formatting it comes in. &gt;“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.” -- Martin Fowler, "Refactoring: Improving the Design of Existing Code"
I followed the directions [here](http://kivy.org/docs/guide/packaging-android.html) for buildozer. Buildozer automatically gets all the dependencies for android (SDK, python-for-android, NDK, etc) and builds an apk. For me, at least, it seemed easier than using python-for-android directly. 
For learning Python, this is good: http://www.amazon.co.uk/Python-Programming-Absolute-Beginner-Dawson/dp/1435455002/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1400792739&amp;sr=1-1&amp;keywords=python+for+beginners
Do want this information on your own computer, or one you're talking to over the network? If you want it on another computer, that's not something a raw TCP connection supports. All that sockets let you do is send bytes to another computer. You open a connection to a port on a remote computer and you start sending it bytes and you see what it sends back. There's no telling what it is - perhaps it's someone using [netcat](http://en.wikipedia.org/wiki/Netcat), a simple socket program that accepts one connection, prints whatever is sent, and lets you type whatever you want back. Perhaps it's [Apache](http://en.wikipedia.org/wiki/Apache_HTTP_Server) listening for HTTP requests from web browsers, and sending HTML documents, images and other files back. Perhaps it's FTP, etc. There are standards: http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers shows which services are normally run on which ports.
Neat idea! My Skype ID is Jacob.lindstrom1.
Great!, my Skype ID is ricardomurillo0889
asday_
I am trying to create a service that queries logs for certain information in real time. I think logstash can fit into it, and the python client looks pretty good. I'll give it a shot. Thanks! 
This is awesome, thanks for posting :)
Just ran one of those, [looks really pretty](http://t.co/8oX3q4q1C7)
Hangouts might be a more practical alternative to Skype; it would work better for Linux using Python developers. 
I really just want to thank you for you're answers. They're really appreciated. So in the context of my question, procedurally, I need to connect to the host. Send some bytes? Then what would I do next in my program?
&gt; What am I doing wrong? /r/learnpython
oh...sowwy :(
Spyder is nice, but I would make the leap to IPython --- it's what you'll want to be using in the long run. Personally I go IDE free and use vim like your friend says, plus standard IPython shell, but for starting off I would still recommend IPython notebook. It just makes things easier. Once you've got the hang of Python you can switch to vim or Emacs plus standard IPython shell.
My boss always tests people on Python threading - know the GIL and the difference between IO bound and compute bound. 
or just freenode #python
text editor
Thanks!
it's still four or possibly five keystrokes, sadly.
[argh](https://pypi.python.org/pypi/argh) translation: import argh def hello(name='', count=1): name = name or argh.safe_input('Your name: ') for _ in range(count): print('Hello %s!' % name) if __name__ == '__main__': argh.dispatch_command(hello) help generated: usage: hello.py [-h] [-n NAME] [-c COUNT] optional arguments: -h, --help show this help message and exit -n NAME, --name NAME -c COUNT, --count COUNT 
我 (wo3) would probably be three keystrokes: two for "w" and "o", then enter/spacebar to confirm substitution into the Chinese character. This is very cool! But you know, you could get 100% Chinese if you use Chinese Python: http://reganmian.net/blog/2008/11/21/chinese-python-translating-a-programming-language/
Your friend sounds like they are in the vim / emacs camp. From my observations there are 3 different groups here: * vim / emacs * text editor (Sublime Text) * IDE (Spyder, Pycharm, etc..) There is no right answer. Just use what you think is the best tool for you. If you think that it is an IDE, then just use one. If you want to use vim then go for it. With either vim / emacs or the text editor you can add a bunch of tools and practically build your own IDE or use them simply as text editors, it is up to you. For a long time I was using Sublime Text and bouncing between editing in Sublime Text and running my code in a terminal window. However, I have joined the IDE camp and it has made my coding much more pleasant. If you want the benefits of having an IDE I also recommend you to checkout [Pycharm](http://www.jetbrains.com/pycharm/download/) (there is a free community edition available). I previously said Spyder because you mentioned Matlab but for a general Python IDE, I have been very happy with Pycharm. I do think that learning how to use vim or emacs is a good skill in case you have to remotely login to a box and edit some files. Those are free tools that have been around for a long time and likely are not going anywhere. A few extra links you may find helpful, the first is a good Pycharm review from someone that used vim for a long time: * [Pycharm from a VIM user's perspective](http://andrewbrookins.com/tech/one-year-later-an-epic-review-of-pycharm-2-7-from-a-vim-users-perspective/) * [Debugging in Pycharm](http://www.jetbrains.com/pycharm/webhelp/debugging.html) * [Debugging in Spyder](http://pythonhosted.org/spyder/debugging.html) 
I'm going to tattoo those Chinese characters on my arm.
What's a pain about it? Can't you just install pip and then django via pip?
outFile.write(os.linesep()) Be portable. 
Show him [PEP8: Tabs or Spaces?](http://legacy.python.org/dev/peps/pep-0008/#tabs-or-spaces) If you can muck with his command line, make an alias of "python" to "python -tt" and it will show tab indents as errors. :-D Or switch him to Python3: ~~tabs aren't allowed.~~ Mixing tabs and spaces isn't allowed Edit: made it sound less like I was answer the questions "which should I use?" and more like I was answering "how to tell this guy he's wrong"
In the grand scheme of things, Python is wrong (tabs are for indentation, spaces are for alignment, an indent is a single entity and should not be represented with multiple characters, space indentation can be done wrong such that there are "partial" indents, tabs favor intent over appearance, use whatever tab size you like without affecting anyone else, etc. etc.). However, tabs vs. spaces is a pointless discussion; the only thing that matters is *consistency*, and the Python community has decided, almost unanimously, that spaces should be used, so spaces are what you (and he) should be using. Just point him to your team's style guide; if you don't have one, push for one to be written and enforced; if he won't listen, idk, escalate the issue to a team meeting or sth. Consistency trumps petty concerns, and say what you want about PEP8, its most important feat is that it exists and has wide acceptance, so no matter what the details are, adhering to it is the sane way to go.
Honestly, I posted in /r/learnpython asking questions about a port scanner I was building and only recieved a single downvote and nothing else for like 5-6 hours, so I thought people didn't like these sort of questions. I'm not building a bot unfortunately, but rather trying to learn about networking and programming on a low level. http://www.reddit.com/r/learnpython/comments/265vm0/port_scanner_for_learning/ Can I ask one more? I asked some time ago and people didn't like my question so much... Why are links so deadly? I mean I hear it only takes 1 person to click a link in a workplace for an intruder to get in, and I hear stories like it all the time. From my simple understanding, links use http and I can't see how it's possible? Can links use other protocols? What is the "deadliest" think a web server can serve to a PC? Also, don't feel your time is wasted here. Whenever I ask questions like this, I usually do a write up of the solution afterwards and post it on my website. I want the question to be available in future to people with similar interests for when they search. Also, it helps me learn and research more, so thank you. 
Flask?
You shouldn't hire middle schoolers... Seriously, though, have him configure his IDE to use spaces for the tab key. if he still doesn't want to follow style guidelines, then it won't be long before he gets frustrated with things breaking from inconsistent whitespace.
I like it a lot too, but I would've preferred it'd be separated from the rest of the Plumbum library, as it currently hosts two completely unrelated features.
IIRC, Py3 allows tabs but insists on consistency. If you're forced to collaborate with this person, you could sneakily add a git pre-commit hook to his repo that replaces tabs and checks for errors resulting from the change before committing? :)
..Or frustrated by rejected pull requests. Don't accept code from people who refuse to adhere to basic code standards.
Clever, but it's a perfect example of why allowing non-ASCII identifiers in python was a bad idea.
Why is that a bad idea? Surely it is great for people who speak Mandarin.
care to elaborate?
Even though I read chinese I still wouldn't want to read code like this
That's absolutely right.
Why not just create a new IRC channel?
While its cool that it is possible, I really hope it will not become a thing. Because then we'd have a Russian and a Chinese programmer world that is incompatible (because of language barrier) from the rest.
&gt; Why is that a bad idea? I kind of agree with the guy. Programming is not different from math. It's a standard language for people to communicate and express a problem in an agreed language. Our math symbols and operations are a worldwide standard to discuss about a mathematical problem. Anyone, being him Chinese, Japanese, British or Spaniard, can understand the mathematical problem and collaborate effectively through this lingua franca. Same for programming. When you have a programming language that grants you this kind of flexibilty, you reduce the intrinsic value of that programming language as a lingua franca. That code is useless to anyone that does not speak chinese. While I might say the opposite for them (they don't understand code written in English) I also had to learn English to be a better programmer, exactly like I had to learn hindu-arabic numerals to do math.
I guess it's about what you prefer. I have done webapps with werkzeug/jinja before flask and liked flask from the first moment. Recently I have done two small projects with pyramid but I find it more complicated. I've also tried to mix things ... like added venusian decorators to flask to automaticly load blueprints. I'd suggest to give both a try ;)
It seems like it would be easy to confuse two similar characters leading to all sorts of problems. It's like 1/l/I problem but much more severe due to greater number of possible characters.
Really cool...this was more programming subject..
&gt; Anyone, being him Chinese, Japanese, British or Spaniard, can understand the mathematical problem and collaborate effectively through this lingua franca. It's effectively impossible to communicate nontrivial mathematics using only notation. My girlfriend's father (who is Chinese) can't understand my dissertation, nor can I understand his papers.
You need a bigger font size than what that site displays, of course (or at least, bigger than what it shows on my monitor). People who have training with Hanzi (e.g. Chinese, Taiwanese, Japanese) can discriminate them pretty easily. This is not a problem unique to programming. After all these characters are already used as a written language. Besides, if you use simplified Chinese it would be somewhat easier, I expect.
bullshit. just because they look the same to you doesn’t mean that people who can actually read them can’t discriminate them.
the place I work at currently has a site built on flask serving &gt;10M pages a day on Flask, and it's a complex app. There's nothing you can't do on Flask that you can't do on Pyramid or whatever else
Python3 for the win! This is exactly what I keep telling people when they grumble about py3 - with billions of people speaking non-ASCII languages (Chinese, hindi, tamil, etc) it's hugely arrogant of english prgrammers to demand they use english characters only. That said, I hope this doesn't become a norm in open-source projects :P Though on the plus side, if you use an oldschool green+black terminal REPL it looks like the Matrix!
me too. Japanese (two character) is pretty cool too: 自己 . I'm thinking using characters would be a cool way to slim down a programming language, a bit like how greek and russian characters are used in math.
I think we may be saying the same thing but interpreting it differently. In order to communicate (maths or programming) effectively between two people, you both need to know * the same notational language, and * the same actual human language. Let's introduce some people. * Joe American and Wang Chinaman both know C# but Joe does not speak Mandarin, and Wang does not speak English. They cannot cooperate. * Neil American and Li Chinaman both know Python, but Neil does not speak Mandarin and Li does not speak English. Li can write variable names in Hanzi instead of Pinyin, which is what Wang uses. Nevertheless, he cannot cooperate with Neil. * Bob American and Fang Chinaman both know C# and can speak the same language (English or Mandarin, doesn't matter). They can collaborate, if the code is written in that same language (which has to be English or Pinyin, since C# presumably does not allow Hanzi variable names). * Oscar American and Günther German both know C# and can speak the same language (English or German, doesn't matter). They can collaborate, if the code is written in that same language (which can be either English or German, since German can be largely written in ASCII). * Kevin American and Zhang Chinaman both know Python and can speak the same language. They can also collaborate, if the code is written in that same language. * Young Chen Chinaman wants to learn how to program in C#, but he can't speak English, and so he never succeeds. This has no effect on the English-speaking C#-programming Chinese community. * Young Yuan Chinaman wants to learn how to program in Python, but he can't speak English. Luckily, this is not a problem, since Python is easy to use in Chinese, and this has led to a wide range of Chinese learning materials. Yuan succeeds. This has no effect on the English-speaking Python-programming Chinese community (since Yuan is not English-speaking). I don't see any configuration where changing C# to Python (allowing Hanzi variable names) breaks collaboration or has a negative effect on the English-speaking community. Disallowing extra-ASCII characters does not force you to use English variable names, so the current situation with Python and Chinese corresponds more or less to that of any other programming language and human language that can be written (largely) in ASCII, of which there are many examples and have been for several years without causing division and mayhem. Yes, it would be harder to communicate if you used a different notation, but the number of people with whom you can communicate like this would not become smaller by adding support for a different notation. There would simply be another community that can communicate with each other, but not with you, and some people who can communicate with both. I've used ASCII as ‘very rudimentary character set’ and C# as ‘language that only allows such a character set in its variable names‘. I don't use C# so I don't know if that is actually true, but if not then substitute C# with your-language-here. I'm also aware that there are characters in ASCII that you can't use in variable names (in Python as well as C#), but in the interest of readability let's ignore that.
But on the other hand, if some characters became common use (like a single character for Self) because of a huge influx of chinese programmers, people would just come to know what the symbol meant. When you think of it, non-english users have to do exactly this when they learn: just get to know that these nonsensical letter combinations like "self" actually mean 我
I think the Python community has always valued readability and elegance of design - does what you want cleanly, simply, but with no obscure magic stuff that might break. When people feel they acheive that, they call it beautiful. It's partly what attracted me to begin with - people care about code that is understandable and elegant.
Flask is just more low-level, less is configured for you, which IMHO is better if you need to build a high-traffic scalable website. It also depends on your level of experience. If you don't know for example what a session entails, you're better off using Pyramid where sessions are implemented for you than flask where the default sessions are very basic, and you need to implement your own in memcached for example.
How do you like your legos? Old school kits where all the bricks are generic or new school ones where you have custom one-piece "car" and "castle" components
Tabs should not be used because they have different sizes on different computers and in different text editors. Any decent text editor will automatically convert indentations to spaces and select whole indent levels instead of the individual spaces.
Well, you named one reason. Others include the cross platform thing, the interoperability with your favourite python modules, and for some people that they simply prefer python. For me, a big thing is that it's fun and interesting to have my code run on a smartphone, in a wide range of situations other than the traditional 'make and release an app' model. For instance, I might throw together a gui tool in a scientific workflow (in which python is a great tool and java is not so much), and it's cool to have that run on a device if I want. Or I might want to make a specific mobile tool from some existing code but be totally uninterested in rewriting everything in java just to do so. In these cases I'm far more interested in quickly developing something for myself or a small userbase, and from the point of view of my smartphone being a full computing device it seems silly to be limited to one approved language. Of course that's just me, and I don't see any particular barrier to making 'full' apps with kivy either (people certainly do). I suppose from the opposite point of view I don't see any compelling answer to the opposite question...why should I have to or want to learn the 'native' language?
So anyone have an idea as to what it does?
Pyramid is big-ass complicated but has some very, very nifty features like [Traversal](http://docs.pylonsproject.org/projects/pyramid/en/latest/narr/traversal.html) build in. If you use Pyramid expect to spend a lot of time reading the (btw. great) documentation. Flask and Pyramid are on different ends of the spectrum. Flask itself gives you only the basics but a lot of extensions while Pyramid has more build in stuff which makes it more complex. One step further in that direction would be Django that has even the ORM build in. It just depends on how much build in you want.
Maybe write a script and attach it to a post commit hook that cleans out the tabs and replaces them with 4 spaces.
Getting your app running initially may take a little more effort with Pyramid- really not much though and they have a good tutorial to get started. After that Pyramid includes as much or as little as you want. One area that worked really well was its testing framework. As the project grows and you need to use more features they're available- adding session support halfway through was only a few lines. I honestly don't know how well Flask handles this, but one thing I ended up using quite a bit was pre/post request callbacks, lifesavers.
Just going to throw it out there that you can use Django with a non-Django ORM, or some other templating, or some other routing. Also, spare a thought for Tornado - even if you don't intend to use it's async features.
Not bullshit. I can read both с and c, but I cannot tell which one is which despite them being completely different characters. They are only distinguishable in context (one is Cyrillic, other is Latin). Same with l and I in many fonts. There are a lot of Chinese characters that look practically identical, and yes, even native speakers can confuse them. In fact, because most of Chinese characters are phono-semantic, similar characters are often pronounced similarly as well.
nice initiative. my id is: kmonsoor
Designing a right-sized framework is a tricky thing to do. The main challenge is that once you are beyond a very small set of core features, some proportion of applications will never need or benefit from the next feature you add. What's more, every new feature you add may impose some constraints on applications, whether the app uses your feature or not. Larger frameworks tend to have a feature set that supports a "typical" web application. Of course, typical is largely subjective. The degree to which your application fits the framework's archetypal view of applications determines how much it benefits from these features; the degree to which it does not is the degree to which you may find yourself fighting to break out of the framework's preconceptions. I have not worked with Pyramid. I have worked with Pylons, its precursor, but I understand the two are quite different. I've worked with Django, I've worked with Zope, I've worked with a couple different PHP frameworks. In most cases, I found myself wishing for something more minimal, because I found myself fighting the framework for control. This is the appeal of microframeworks. The downside of microframeworks is that they generally give you just enough rope to hang yourself. You're in DIY mode, and it's up to you to keep things DRY, to separate your concerns, to write robust code, to document it clearly, etcetera. If you build an app in Django, you may spend a lot of time fighting the framework, but it's relatively easy to hire a new nerd who knows how your code works and can hop in to help you fight. If you build an app in Flask, you can hire someone who knows Flask, but 80% of your app is going to be home-grown and he will need to learn how that all works. I'm just arrogant enough to believe that I can be trusted with that responsibility. People usually tell me that my code is clean and elegant, though I suppose they would not be too likely to tell me it was incoherent gibberish. Maybe you are less arrogant than I am.
I've heard that the book is worthwhile, though not really different from the website, just an easier reference. However, I've heard the videos are atrocious, and not worth the money. That said, grain of salt and all that, it's all hearsay and I've only used the website.
Seem to me at least to be an example of spec vs implementation. The ANSI C process started in 1983 specifically to stop developers from modifying the language so as to make the language users to do things in the way the developers thought things should be done. ... to stop some dominant developer group from trying a version number hijack for instance.
IMO this hit the nail on the head. Java and android was my introduction to coding. But when I happened upon python and then kivy I was pleased to say the least. Creating code that could potentially run on many major platforms without a lot of tweaking is very useful.
Aren't both Flask and Pyramid made mainly out of custome one piece Add-Ons and Extensions? I'm not sure what you are trying to say here...
Flask uses [view decorators](http://flask.pocoo.org/docs/patterns/viewdecorators/) for things like that.
Pyramid gives you a bunch of stuff that's wired together and makes a bunch of decisions for you. You can get where you want to be more quickly but it might not be exactly what you want - it's somebody else's idea of what's right.
Interesting interesting... thanks for all this detail and breakdown. So, from all the options you mentioned and from your experience,... PyCharm, vim, etc... which 'method' do you think has a debugger that would most closely be like MATLABs? You know, set a breakpoint somewhere, and step towards it. 
Well, pre-commit. A post-commit hook can't affect the code in the commit, because the commit has already been made. [Here's one](https://github.com/cbrueffer/pep8-git-hook) that doesn't go so far as to modify code into compliance, but refuses to accept a commit that violates PEP8.
Would you need to decorate every function? You can do that in pyramid, but you can also register callbacks for various points in every requests life cycle. Example of one thing I'm using it for- after a response is finalized I have a function examine the request. If I see a 'dry-run' flag I roll back the database. Can't accidentally forget to add feature to new calls, and so far its fool proof. Request and exception logging handled similarly pre-request/post-request.
Morepath has almost no plugins as of yet, but I thought I'd mention it given that it looks more like Flask but under the hood it's more like Pyramid in its approach to flexibility. And it adds some interesting bits of its own: the ability to extend flask-like apps and override things in them, and some of the benefits of Pyramid's traversal (view lookup) in a routing system. http://morepath.readthedocs.org 
Does your company participate in some open source project? 
I'm curious, why? What are the advantages over a Racket / Clojure / scheme? Those have varied REPLs and compilers that are well tested and documented. What could be the advantage of running a Lisp on top of python?
Glad someone else found this interesting. I've been thinking for a while that programming languages written in Traditional Chinese or Cyrillic characters would be an inevitability. Latin characters certianly have the critical mass and will for some time. But programming is a universal language and I think its anglo-centric days are numbered.
Django is pretty heavy weight and opinionated. And while you can plug in your own ORM, etc, you stand to lose a lot of the smaller benefits Django has to offer. Having moved from Flask to Django, I wish now that I could move back. :/
I enjoyed &amp; recommend the free book, but be aware he does not exactly teach you things to [PEP 8 style](http://legacy.python.org/dev/peps/pep-0008/), so you may have to do some relearning.
I think your comment is both well written and insightful. 
Yes, pre-commit would be better. I have my doubts about some of PEP8 so I wouldn't want to enforce a hook that ensured all code was compliant, but stripping out tabs isn't a bad plan.
I think your comment is as succinct as it is kind. 
This looks excellent! Thank you.
&gt; If you build an app in Django, you may spend a lot of time fighting the framework, but it's relatively easy to hire a new nerd who knows how your code works and can hop in to help you fight. If you build an app in Flask, you can hire someone who knows Flask, but 80% of your app is going to be home-grown and he will need to learn how that all works. Amen to that. I think we underestimate the benefits that Django's lack of flexibility bring. Having a consistent core structure allows others to jump in to your project with little difficulty. The same consistency ironically also allows for a richer, more diverse ecosystem, because plugin developers only need to target one architecture. 
&gt; any specific area where one is stronger than the other (Pyramid vs. Flask)? Pyramid has more flexible request routing. i think it is interesting that you can write a [flask like framework in pyramid](https://github.com/Pylons/groundhog/blob/master/groundhog.py) but I'm not sure you can write a pyramid like framework in flask. 
Learn Python the Hard Way is an incredible book. As an experienced programmer, the first 10-15 (very short) chapters will probably be a little tedious for you, and then the final 30-odd chapters will be very interesting. He does some subtle things with teaching recursion and other more computer science-y things later on that are fun from the angle of an experienced developer. The book I personally learned Python on was Mark Lutz's Learning Python. It's not cheap (work bought my copy back in 2005), but it's worth the price.
Reverse your [] and () to make a link
Pyramid has given us all power we needed and all freedom we wanted to build https://myjour.com/kiosk/. Application is built with pyramid and never regretted.
These are the differences I've found after working with pyramid and flask: Flask loves threads locals, and encourages you to use them via the g object or other proxies. Pyramid discourages their use, and tries to push things like request as parameters in views. Flask loves module globals. The best example is seen in tutorials using the flask app as decorator for functions. While it can be avoided, you will find things like LocalProxies (via werkzeug) and you will end up importing thing to use this magic local proxies. While per se it is not bad, it is a PITA when testing, as you will use mock.patch a lot. It might things easier to prototype: just import it. But dependencies go a bit crazy (Using the python import system as a service locator &lt;- WTF did I just wrote). Pyramid implements more things than flask. So it is more opinionated. But not much and usually test oriented. For example: - configuration is by default in .ini files and in the code it arrives as a dict. - authorization interfaces with a basic one using ACLs - authentication interfaces with a basic default ones (authNZ are two things, and it is nice). - Flask has routing, pyramid besides normal routing includes resource routing using traversal. Things I like from pyramid: - documentation - comunity - testing focus Things I like from flask: - quick prototypes - lots of plugins to save your day - Use thread locals in a nice way. Both are really good frameworks, choose the one you like more to work with.
hmm...i did your way and the opposite but no changes :( thanks for the heads up though
A few years back someone had posted a list of things they ask people about regarding python on comp.lang.python.
I just started something similar. I won't be quitting my job, but I am challenging myself. here's my challenge: http://www.jasondotstar.com/180-Day-Coding-Challenge/. I found this: https://github.com/karan/Projects, which is a list of practical project that you can solve in any language. As part of my challenge to learn, and do something worthy of my time, I'll probably start with doing these.
That's very nice. A lot of lines (for example in 設計) are just one word/symbol followed by '.' and then two words/symbols. That makes it look very tabular and clean. Unfortunately, the only thing I know about Chinese is 人.
Cool, I've been wanting one of these :) You might like these: https://github.com/aliclark/redditail https://github.com/aliclark/irctail https://github.com/aliclark/mailtail twittertail would be cool too
Reddit requires the "http://" in front of a URI to make it into a link. [Dive Into python3](http://www.diveintopython3.net) Becomes [Dive Into python3](http://www.diveintopython3.net)
Try adding http:// \[Dive Into python3\](http://www.diveintopython3.net) Turns into: [Dive Into python3](http://www.diveintopython3.net)
Maybe we just need more Latin-alphabet ligatures. Would any graphic designer like to try their hand at compressing “self” into the space of one character?
i noticed the bulk of these are using while true loops. Have you looked a the system I/O forthose that are looking at files ? We noticed an absurd amount of usage for a log scraper once using this method. 
Check out /r/learnpython/w/index and /r/learnpython/w/books If you have some basic understanding of programming and python (as you say you do) just go over official tutorial to get familiar with syntax etc and then (with help of docs, of course) start writing your own smaller projects. If you need ideas for projects to practice with check out this list: https://github.com/karan/Projects
The scripts tend to spend most of their time doing the blocking sys.stdin.readline() call, and I can rely on the fact that reddit, IRC channels and mail folders aren't updated that often, so this hasn't been an issue. I added a sleep(1) to the mailtail loop, but that's mainly out of kindness to the mail server :) At the end of the day it's just a bunch of IRC channels, reddit links and email subjects interleaved in the same terminal window, and it's slow enough that I can actually read it :)
You can use [Blueprint.after_app_request](http://flask.pocoo.org/docs/api/#flask.Blueprint.after_app_request) and register your views for which you want this functionality on the [Blueprint](http://flask.pocoo.org/docs/blueprints/). Additionally, you can use [Flask.after_request](http://flask.pocoo.org/docs/api/#flask.Flask.after_request) for global post-request logic.
If you are into web dev, give it a try to [Miguel Grinberg’s Flask Mega-Tutorial](http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world). I did it and it empowered me to develop something like [Whiskyton](http://whiskyton.herokuapp.com) in the first lessons…
it won't be one click, but getting flask/nginx working isn't too hard.
&gt; tabs are for indentation, spaces are for alignment I'd love to see this explained in practice: "Well, see, you hit the tab key to indent. But when you align your function arguments and comments and stuff, see, you gotta hold down the space bar for 30 characters, 'cause if you hit tab it'll insert a tab and you don't want that because Joe uses a tabwidth of 3 and the alignment will be all fucked up on his computer." "Wait, so I have to hold down my space bar for 30 characters?" "Yeah. It's *better* that way."
Some good discussion the last time it got posted: * https://pay.reddit.com/r/Python/comments/251jkf/a_top_10_of_the_mistakes_python_programmers_make/ * http://www.reddit.com/r/programming/comments/251it6/top_10_mistakes_python_programmers_make_advanced/ * https://news.ycombinator.com/item?id=7715349
I learned how to code Python using the free edition of Learning Python the Hard way. Loved it! His learning by doing approach is something I appreciated quite a bit. If only more programming book authors took his view on rote learning to heart. Also, another plug for CodeAcademy from me. The Python exercises are pretty basic but they well worth going through. They're a bit more convenient than LPTHW but maybe a bit more shallow. 
Why would you hold the space bar for 30 characters? Why wouldn't you just use tabs? I don't get it
You can change the color of the background and font in powershell
What's in all white? The font? Is the reason you don't like PowerShell because the font is white? Have you tried changing the color?
Sadly I see a lot of this double-standard going on: * company wants to hire devs who contribute to FOSS projects * company can't participate in FOSS for legal/willingness/greed reasons, and won't provide time to their devs to do so * people doing the hiring, including the tech screening, never contributed to FOSS So you are failing people who worked for companies like yours... 
Because, as noted above, tabs are for indentation. I haven't seen a text editor that, when the tab key is pressed, inserts tabs in one context but spaces in another context.
i want to learn your art of writing ... along with python ... :)
[IDLE](https://docs.python.org/2/library/idle.html), the light development environment that ships with Python, might fit the bill. Or, if you want to stick closer to what LPTHW is suggesting, try [cmder](http://bliker.github.io/cmder/), which gives some nice customization capabilities to the base windows shell.
PowerShell 3 or 4 is so much better than PowerShell 2, especially the ISE.
The thing is, it's annoying to have to switch between using the tab key and using the space bar (especially on the same line of code), such that no one else is going to do it and everyone working on the codebase is going to mess it up. Which is why, in the end, it's probably simpler just to use spaces.
you switch between tab and space key all the time, because you have your tab key auto convert to spaces. If what you were saying is true, then even if you're using spaces for tabs, you're still holding the space bar down for 30 characters. That defeats the point you were making
my_really_long_object.my_really_long_function_name_to_call(argument1, \s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\s\sargument2) ^ Pretty sure the point @mipadi was making is you can't expect someone to know to use spaces here instead of tabs, they'll inevitably use tabs as far as they can then use spaces - meaning it will only work on their editor - completely removing the configuration benefit of tabs.
I hated Learn Python The Hard Way. I found it seriously lacking and too snarky for its own good.
I have to be somewhat vague here - there are plenty of ways to support open source projects. One way is to contribute code another way is to help fund community activities. In general you get out of open-source what you care to put into it. 
ok thats fair. 
When I was learning Python, I never really used the console much. I used either IDLE or Sublime Text. IDLE, you've probably heard of it, is a small Python editor, it's both an editor and an interpreter. You should check it out, it's awesome if you're beginning to code (it'll fall-off later as you find its flaws) After a little while, I started using Sublime Text, it's a super powerful and customizable text editor. You can customize it to meet *all* of your needs. It has an extremely powerful plugin system. It's super easy to use out of the box, making your installation yours will take a little longer. (you'll find new features every week, I am still amazed daily by the ridiculous and amazing features I find) You can run interactive Python sessions in Sublime Text using the sublimeREPL package. You can run complete Python programs from Sublime Text, it's built-in. Running Python3 takes a small bit of configuration.
Or better yet, post specifically to [tkinter-discuss](https://mail.python.org/mailman/listinfo/tkinter-discuss). They're more likely to be able to help you.
Do you even understand the difference between indentation and alignment?
To complement what the others said, you can even do multiple insert in one command, which will only do one round trip on the server, which is quite faster; using executemany. See : http://stackoverflow.com/questions/8134602/psycopg2-insert-multiple-rows-with-one-query and http://initd.org/psycopg/docs/cursor.html#cursor.executemany
I dunno. The thing is, I could've just done this in solitude. I'm sure that many Pythonistas will find this to be uninteresting. But, I'm hoping that this community (and other subreddits) might give me ideas, help, and encouragement. 
That's a popular misconception but it's not true. Both Pyramid and Flask operate at more or less the same level of abstraction. Pyramid may offer things out of the box that Flask does not (like a permissions system; that may be the only thing now that I'm sitting here thinking about it), but there's a less difference in the "what" the two frameworks offer vs. the "how".
+1. I'm feeling pretty jerky today.
Yeah. Here's the problem. Say you have code like this: the_function() { val = function(arg1, arg2, arg3); return val; } There are a couple issues to keep in mind: 1. You need both tabs (for indentation) and spaces (for alignment). Most editors (I say "most", but I haven't found one that can handle this) don't understand context re: indentation vs. alignment, so hitting tab is going to insert a literal tab character *or* a space, but not either/or based on context. So if you actually want spaces (for alignment) you're going to have to hit the spacebar...again, and again, and again. 2. In the above, Lines 3 and 4 require both a tab (for indentation) and spaces (for alignment) on the *same line*. Fact is, it's going to be hard to get all contributors to the the *right thing every time*. It's a lot easier to just tell people to use spaces and be done with it, and using spaces instead of tabs don't really have any drawbacks.
So, how do you have your tab key insert a literal tab (for indentation) or a space (for alignment) based on context?
I've been wondering why you would want to deploy with Gunicorn rather than to just having Nginx forward requests to the port your app is listening on? Sorry if this is the wrong place to ask.
Obviously, that should be: the_function() { val = function( arg1, arg2, arg3); return val; } (Tongue-in-cheek in case you haven't noticed). Anyway, I like to avoid alignment as much as possible, among other things for this reason - I find both your version and mine highly unpleasant, from an aesthetics point of view. And frankly, I don't see the point of aligning in 99% of its use cases - after all, code in most languages is written in one dimension, newlines and indentation only serve to illustrate the structure, and that structure is generally a tree, and indentation is all you need to encode tree structure - down a level, up x levels, same level, that's all there is to it really. Also, stuff like this is completely ridiculous IMO: foo = "bar" frabber = "boink" never_gonna = "give you up" The sane way to write this is: foo = "bar" frabber = "boink" never_gonna = "give you up" There are a few cases where aligning makes sense, e.g. in javadoc/phpdoc/doxygen style doc comment blocks: /** * A nice description here. Note that there is a single alignment * space character at the start of this line, right before the *, but * after any indentation. */ Or when you include ascii-art tables in comments (but then, this is kind of silly). One way or another, the cases where alignment makes sense are practically never source code in the strict sense, but things like comments, string literals, or EDSL constructs of some sort. &gt; Fact is, it's going to be hard to get all contributors to the the right thing every time. It's a lot easier to just tell people to use spaces and be done with it, and using spaces instead of tabs don't really have any drawbacks. Yes. That's why I call it the pragmatic solution. 
PyCharm is what I use to do Python. You can get the community edition free. http://www.jetbrains.com/pycharm/
Nice! But I am afraid that - in the wrong hands - this could significantly increase the amount of spam being send ;)
I just picked up Learn Python The Hard Way, installed Slackware and using Vi. Learning as I go. 
How have I never seen this? https://github.com/Psycojoker/feedstail/blob/master/feedstail/utils.py
Thanks, I've installed it and am using it now. Hope it works (it is analyzing the code I believe, has been for the past 30mins or so- it's a pretty big package) And yes, I agree. But that was not the case. Our mistake. We know better now haha.
you can't, so thats +1 for spaces
I learned a lot while doing the missions in http://checkio.org it is fun, and it challenges to thing more practical. Once solved a task you can see how others solved it and improve your knowledge. Sorry for the wrong link
Honestly, I now prefer PowerShell and notepad++ for python. It's really just a preference. You can also change the colors in PowerShell
No need to go look quite that far... Pretty much all non-english language are outside of ASCII. French, German, Greek...
[Codecademy is pretty awesome.](http://www.codecademy.com/tracks/python)
[Working Link](http://www.checkio.org/)
Have you tried cygwin? I don't have experience with it myself as I don't use Windows for coding, but I've heard it's a pretty good Unix-like environment for Windows.
No reason you can't use "s" instead of "self" in python other then convention.
Wife used this and learned python in a few weeks. Six months later she was being paid at her management job to write python programs. It's a pretty good starter. There are a few times that you do have the right answer, just it's picky (wrong) in how it wants to verify it. Don't be afraid to click the little help form link in the corner. 
┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
┬─┬ ︵ヽ(ಠ_ಠ)ﾉ︵ ┬─┬
Quit using CentOS? also no upstart on centos only clunky crappy supervisor BOO!
More important question - why the hell would you ever want to? Pretty much no one uses UML.
Try VIM. It's easier to use and allows for addons/syntax highlighting/etc...
Yeah, get Linux ;)
JWZ did a good job surveying this one: http://www.jwz.org/doc/tabs-vs-spaces.html A good read. I highly recommend it.
Try anaconda!
I found the link I was looking for - [topics for a python interview](https://groups.google.com/d/msg/comp.lang.python/rhW_rIYY5HM/WDOqW02UbRcJ).
Auto generated diagrams are very useful when you're dealing with some particularly insane legacy code. I've had to deal with code I couldn't understand at all until I saw the diagrams. Then I realized that it wasn't overly complex, just terrible.
Pretty often. Yah gotta diagram something. Doesn't have to be full UML, as it's pretty restricting, but it's good to organize your entities, their relations, find patterns, hierarchies, etc. Otherwise, it's like trying to build a building with no architecture. Then again, some people have very organic approaches. Technically a pure Agile methodology would preclude it, though maybe that's why I hate starting projects with Agile.
It's know as "Big Design Up Front", I've never actually seen anyone use it. http://en.wikipedia.org/wiki/Big_Design_Up_Front The problem is usually that any non-trivial diagram is too complex to execute in your head, and design flaws won't be apparent until you actually start writing code.
You'll receive a better response if you make self posts and don't post any links to your blog. Otherwise, your other posts will likely end up like this one.
I wrote it to built [a quick site](http://jason.sperske.com/wad/). Here are some interesting/noteworthy levels: - [DOOM1.WAD](http://jason.sperske.com/wad/DOOM1.WAD/) (the shareware doom wad file) - [CLEIM10.WAD](http://jason.sperske.com/wad/CLEIM10.WAD/) (a super detailed replacement for episode 2) - [hexendm.wad](http://jason.sperske.com/wad/hexendm.wad/) (Deathmatch levels for Hexen)
I agree, the Unified Manager's Language is not very useful for programmers
I agree with this comment. I bought both Learn Python the Hard Way and Learning Python, with LPTHW being read first. Both are probably the goto resources for people new to Python. The only other series I could recommend more is the Invent with Python series, by Al Sweigart. Which are great for newcomers to programming, really interesting. 
&gt; Pretty much no one uses UML. Sure... and I'm assistant teacher said no one used c++... guess my work didn't get the memo. UML or other diagrams CAN be useful if applied with caution. The problem comes when you think of it as a rulebook and produce a lot of it unnecesarily only to realize you're breaking the DRY principle. and as /u/wmil said... using tools to try to make sense of legacy code could save you some time... although it's still gets unwieldy depending on the project.
Obligatory http://xkcd.com/378/
[Image](http://imgs.xkcd.com/comics/real_programmers.png) **Title:** Real Programmers **Title-text:** Real programmers set the universal constants at the start such that the universe evolves to contain the disk with the data they want. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=378#Explanation) **Stats:** This comic has been referenced 114 time(s), representing 0.5433% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
This is a useful project if you want to work from inside windows http://mikelev.in/ux/
I'll give it a whirl. 
I've corrected it to "Mixing tabs and spaces isn't allowed"
http://ProgramArcadeGames.com This has videos, but you can read the text instead. Lots of quizzes, worksheets and labs.
Awesome. Really fun to look through.
This is in blatant violation of the twitter terms of service for automated tweeting applications as described here: https://support.twitter.com/articles/76915 &gt;The @reply and Mention functions are intended to make communication between users easier, and automating these processes in order to reach many users is considered an abuse of the feature. If you are automatically sending @reply messages or Mentions to many users, the recipients must request or approve this action in advance. For example, sending automated @replies based on keyword searches is not permitted. When people write shit like this, Twitter cracks down and it makes it harder for the rest of us who want to write applications with the twitter API for legitimate research or business purposes to use the services we need.
Out of curiousity, what's the site? I always hear about Django-based sites (Pinterest, Instagram, etc.), but never about Flask ones.
I believe that Stani's Python editor can do this for you. http://sourceforge.net/projects/spe/
Pycharm perhaps? http://blog.jetbrains.com/pycharm/2013/08/working-with-uml-class-diagrams/ 
If you are a Matplotlib user, you should contribute to the John Hunter memorial fund: http://numfocus.org/johnhunter.html
Sorry, I assumed you were trying to build a Reddit bot because of your username and because that's what I think of when I hear the word "bot" on Reddit. If you're building a port scanner, I'd start trying to connect to a server (say www.reddit.com) on lots of different ports, and see on which ones you could connect. If you can connect to one, you should "greet" it in a bunch of protocols. If it responds to "GET /\n\n" an HTTP response (web page plus headers) then it's something that speaks HTTP. If it says `220 smtp.example.com ESMTP Postfix` to you without you having to send anything to it, then it's an SMTP server. If you receive bytes like `NOTICE AUTH :*** Looking up your hostname...` then you've found an irc server, etc. Definitely take a shot at building this - the first iteration doesn't have to be more complicated that a loop over ip addresses and another inner loop over ports to find a list of ports that are accepting TCP connections. As for "Why are links so deadly?" I don't have a good understanding of this, and I'd love to hear from a security person what the most dangerous thing to send a browser is. Perhaps the link is to a web site that will run some JavaScript code (what makes clicky buttons do interesting things on web pages) that is dangerous - browsers try very hard to isolate web pages from the rest of your computer and each other, but this JavaScript could do interesting things like turn on your webcam and spy on you, or calculate hashes to mine bitcoins or calculate pi, or steal network bandwidth by downloading things from one place and uploading them to another. Perhaps it's a site that looks just like your bank, but isn't. Perhaps it's a site that very convincingly tells you to buy snake oil, or opens a bunch of annoying popups. Maybe the linked page succeeds in convincing you to install malicious software on your computer. *A goal of browser writers is to allow you to visit any site without anything bad happening.* But since browsers are so complicated and do so many things (like use display so many file formats, and run really complicated scripts) this goal is hard to achieve. Via plugins, whole different programs can be triggered to run from a webpage, like Java, ActiveX, Flash, or SilverLight. This programs have similar security goals, but figuring out how to prevent anything bad from happening while running code from a website is a similarly difficult problem - sometimes they have security vulnerabilities. Sometimes these get updated quickly, but sometimes they don't. Given the rate security bugs are found in such software, there are certainly more to be found. Just visiting a page could put a cookie on your computer that could identify you - this could be a little dangerous. How links get opened depends on your operating system and web browser, but links can be [lots of things](http://en.wikipedia.org/wiki/Application_protocol) besides HTTP. Here's an https one: [this technically different than http](https://www.google.com/) And here's an ftp one: [download some cool Mozilla stuff here!](ftp://ftp.mozilla.org/pub/mozilla.org/)
Just updated a bunch, sorry had the edit window open for a long time. BTW, I had never heard the word "banner" before - for anyone else curious, here's the wikipedia link: http://en.wikipedia.org/wiki/Banner_grabbing Wow, and it uses exactly the same examples I do; HTTP, FTP, SMTP
Thanks for everything. If you're interest: http://www.reddit.com/r/javascript/comments/243w0y/what_are_the_evil_things_that_can_be_done_with/ I asked this over in /r/JavaScript and it seemed like for the most part JavaScript is safe aside from its applications in XSS attacks.
http://inventwithpython.com/chapters Free book for complete beginners to learn programming in Python.
you think? well I don't like relatively large files I prefer to keep them within a same topic but having said that, I'm considering wrapping everything into a class so I can persist the settings and such. thanks for the review!
I do it. In the real world, too. When developing with third parties- commercial or in house - knowing with out doubt what the code is supposed do, and how other code will react to it, is pretty important. So yeah, I know, I was being a bit harsh- but it's True, and a lesson learned the hard way. 
lol hence why you write a bot that only runs a couple of times per day or randomly
Oh yea it is. Check this video out. I linked to the appropriate part: http://www.youtube.com/watch?v=qB52xwRlDsk&amp;t=14m38s This is basically how that is done. Most users don't change the default settings on their routers, including the default ip address, which means you can create a webpage that requests the logo off of the router login page and if there is an error, you know they're not using that router. He then goes into detail about how you can eventually load firmware onto the router. 
&gt;Of course that's just me, and I don't see any particular barrier to making 'full' apps with kivy either (people certainly do). What barriers are you referring to?
Flask has twice as many 'officially endorsed plugins', not extensions in general. If you just looked at django.contrib you might conclude it has a smaller ecosystem than everything else, a clear mistake. They both have good integration with SQLAlchemy, that's all that matters, everything else is a matter of taste, in my experience Flask apps and the Flask community seem to like improved Django-like things (WTForms, Jinja2, Flask-Login), which is reasonable since the Django people are awesome API designers (modulo the ORM), more than Pyramid.
hi, i just started learning python (and coding all together) and I just jumped into using code academy. I want to become pretty proficient in the language. what would you recommend after completion of the code academy course? going through the LPTHW book? or maybe another route? im new to this just trying to get the most effective learning route. 
Try [Babun](http://babun.github.io/), it's a new pre-configured Cygwin that looks pretty cool. I haven't tried it as I'm using Linux.
Programmer Competency Matrix Checklist : http://competency-checklist.appspot.com/
These may be helpful: - https://github.com/audreyr/cookiecutter-pypackage - https://github.com/github/gitignore/blob/master/Python.gitignore - http://conda.pydata.org/docs/build.html
If the python examples are similar to the C examples, they don't all clean up objects that fall off the screen. Here's the C code for getting rid of objects that fall off the screen. http://stackoverflow.com/questions/2255571/chipmunk-how-to-delete-a-body As to the second part of your question, do you have ps output or similar? Perhaps your process had been paging, and the system might have been paging some other things in after the process had been killed?
I import g or any other LocalProxy (&lt;-- nice way to use thread locals), and I use them in a function. Therefore that function depends on g or the other LocalProxy. If I just want to test the function in isolation, instead of just calling it with the new Dummy/Stub dependency, I need to work that a bit more: - I can mock.patch the test. So the g or the LocalProxy used, it is now a mock an can behave as I want. - I can use the Flask testing helpers. For example : create a Flask app and use app.test_request_context and set up what I need, or assert later that something is setup in g. The job can be done, it is just 1 or 2 lines of code. Although I believe this shows that dependencies are not injected directly but using indirect ways (flask test helpers) or brute force (patch). For small applications small/isolated/&lt;insert_fancy_word&gt; tests might not be needed (IMHO I just use the test_client and test). **Trigger warning** - You might want to swear at me. My experience with flask apps (wow, 2 apps, hell of a experience, I know) tells me that they start small, using high level tests, and when they grow, they continue using these high level tests without adding smaller tests due to flask dependencies here and there: deep into the layers someone is importing g to get a "per request" whatever_helper. This is why I think flask encourages applications (a little bit) to use the python import system as a service locator to access their ready to use dependencies. What is a service locator? A singleton utility that has registered all common dependencies used and ready to use. Example: "hey service locator!, give me a repository to access that mongo collection". It allows you to depend on anything, without declaring those dependencies in parameters/attributes. Note: I'm talking about ready to use objects, not types. Did I wrote too much again? sorry :/ 
&gt; If I just want to test the function in isolation, instead of just calling it with the new Dummy/Stub dependency, I need to work that a bit more: You need to do exactly the same. Imagine the `g` object would be passed in instead of being a proxy. You would need to do exactly the same logic as before, the only difference is this: From this code: with app.app_context(): foo() You would go to: app_ctx = app.app_context() foo(app_ctx.get_globals()) The latter is pseudo code as that's not actually how it works. But there is literally no difference. The idea that you can mock test individual bits is very dangerous and in my mind counterproductive as you now all the sudden have your tests running with different behavior than the actual app. This whole idea of mocking out god and the world should never have become popular in my opinion.
doesn't work on windows, while most similar tools do, why?
Based on the title and the size of your code, I did not expect much in terms of output. I am very impressed by the examples you have posted! (Plus... it brings back good memories. :)
I've had clients demand UML diagrams as a part of the documentation when I turn over code.
I said I *don't* see any particular barrier.
Promoting isso when it's not working is kinda bad. I fixed it now, thanks for the info! Why do you think that SQLite isn't the right choice? If you really do not want to use a database at all, there's also the [pelican-comment-system](https://github.com/getpelican/pelican-plugins/tree/master/pelican_comment_system) that stores comments in plain textfiles.
Well even if you have a low volume a traffic sqlite is not meant for multiple simultaneous writes due to its whole table lock. So while it will preform fine for smallest traffic blogs it will fall on its face quickly. Also its not possible to modify or delete columns from tables making changes to the table take more effort. It works well as an embedded DB in Firefox because you have one user trying to preform operations at a time. And while it can use several threads to do multiple reads, isso is single threaded. [They have a great page on their wiki outlining use cases.]( http://www.sqlite.org/whentouse.html) however I would take it with a grain of salt. I don't know many people who would trust even 100 users/day to an embedded db. Not that sqlite is unreliable but rather it will have to be replaced eventually. I am currently looking at redis to back the system I am pondering building. I know redis has some issues when it comes to crashing and loss of data but its a two second window (by default) and IMO its unlikely enough of an even that if i lose a handful of comments then no big deal. Also redis like SQLIte is entirety in memory and is a key:value/document store rather than an RDB. That last part is important because of how I conceptualize how the comment system should fetch its comments for a page (with a key value lookup). Also a flexible schema could be of use. I even thought about forking isso but decided not to because I was uncertain about the decision of the author (who also writes maintains a static site gen of his own with an admittedly atrocious name) to use werzkug directly instead of flask as I am not experienced with either. 
A regexp-based parser would be even worse, but I'm not sold on having a custom parser either. Is the alternative syntax really better than python? I get that it's kind of nice to use the pipe character instead of nested functions since the latter puts the function names in the wrong order, but I don't feel that's enough to offset that you're no longer writing real python.
try to not see it as enhanced python but as enhanced shell. he conveyed his intention in the pycon talk, just give him 10 minutes of your time to convince you :-)
You had a fairly clueless teaching assistant then, probably without any actual work experience. You'd be amazed at how many software engineering professors / teaching assistants / graduate students have never worked a single day of their lives writing production code with real deadlines and constraints (I know this from personal experience after spending seven years of my life in academic hell doing a masters and phd in software engineering). Yet somehow they keep coming up with ideas for how software should be developed in industry. To me, that was the biggest disconnect between academia and practice when it came to software engineering. Heck, I attended the Models Conference in NZ in 2011 (formerly the UML conference series) and one of the keynote speakers conducted a study of the top 50 software development companies (don't ask me how they ranked them) and concluded that the very best programmers across the board did not use UML at all. Instead they relied on informal Q/A whiteboard sessions between developers trying to understand a problem, system, etc. Funny enough, the same conference in 2012 brought in yet another keynote speaker who argued that UML was a terrible idea for most projects because it consumes development time producing artifacts that are irrelevant to most customers, will probably become stale and require frequent revisions as requirements change, and ultimately may even fail to properly capture the system itself. Personally, I have not found UML models to be useful on anything but toy problems. As with anything else, these diagrams get complex and monumental fairly quickly. At best, they maybe help grasp the structure or hierarchy of a program, but that is about it. Behavior? No way, especially with "legacy" code that in principle just behaves differently from higher level code. More than likely legacy code will be making heavy use of globals, static variables, system calls, direct memory manipulation, and so forth.
I'd say do the CodeAcademy exercises and then LPTHW because LPTHW teaches you some pretty useful things as well. After that you should have all the basic stuff sorted out but bear in mind that a lot of the more advanced subjects of software engineering are not specific to Python (algorithms, architectures etc.). One of the elite Python elders lurking Reddit would be of more use to you with regards to the advanced stuff than a lowly systems engineer like myself :) After that the challenge is to find a use for your Python skills because you won't retain the knowledge otherwise. It's like that foreign language you had in school - you'll never be fluent in it if you don't put the hours in and actually use it. Some don't like Zed Shaw's attitude but I think the man makes some pretty good points when it comes to learning. His talk at the 2012 Öredev Conferene *(in Sweden, close to where I live)* about learning how to program was fascinating. It's well worth a watch and can be found [here](http://vimeo.com/53062800). 
So you can "with out a doubt" know what code is supposed to do, and how other code will react to it, from UML diagrams? Fuck man, you the UML Jesus.
And lest we forget, requirements _will_ change. From there onwards, either the diagrams will gradually become stale, useless, and downright misleading, or developers will need to invest considerable time and resources to update them frequently.
Forgot to mention the #python channel on [freenode.net](http://webchat.freenode.net). It's a great place to get help if you're stuck with a Python problem. The nice people on there saved my hide more than a few times.
Even when considering that it's aimed at beginners? I agree that his tone is irritating but I thought it covered the bases pretty well for a book aimed at novices.
&gt; You had a fairly clueless teaching assistant then, Oh... no doubts, we had to compile with borland c++ builder for him, for whatever reason (even though it didn't end up mattering since I only run it from my notebook to showcase the code). I used premake4 and supported g++, mingw32-g++, msvcx and, painfully (some arcane warnings I had to consider) borland-builder. &gt; You'd be amazed at how many software engineering professors / teaching assistants / graduate students have never worked a single day of their lives writing production code with real deadlines and constraints I have a co-student who was never to good or well practiced and he is part of the assistant staff so... It surprises me less and less as time goes on. as for the rest, fair enough although I tend to be careful with tools and not dismiss them completely since there use can eventually find cases where they're a proper mean of communication. OP's UML class diagram needs might be niche or maybe even useless but there's also other types that are not directly related to code like activity or use case diagrams or more related but still interesting to try and inform someone or understand a particular problem: sequence diagrams. My point overall, was to avoid dismissing a tool (and providing help for it's usage) just because it didn't play an important role (maybe an optional/exceptional one) in most people's workflows. 
Apples and oranges. The Doom levels are single player where the map's aim is to provide an expansive and interesting route for the player to progress through. The player enjoys the level by exploring the map. The Hexen levels are multi-player deathmatch where the map's aim is to make it easy for people to find and shoot each other. The player enjoys the Hexen levels by finding and killing other players, which the map's simplicity makes it easy to do. If you tried play playing deathmatch on the Doom levels it wouldn't be fun as most of your time would be spent trying to find the other players through the more complex geography.
I think there's an error in answer to q1 on exam2: the integration constant can be any number who belongs to a superset of the real numbers, for e.g a complex one like 1+i 
I would highly recommend cygwin or gitbash over powershell. It is great to know the commands especially if you have a server running some form of Linux.
 &gt;Disclaimer: I wrote Isso I can tell from your user name :-) I checked out your static site gen also but ended up on Pelican for now. &gt;If you think of Isso as a replacement for Disqus serving for hundreds of thousand websites, you're wrong. Glad I'm not wrong then ;-P I just have my personal site I want to serve (for now at least) however I don't like disqus at all for several reasons but that's a different convo. &gt; Isso is for small-to-medium scale websites where you expect that most peoply just read and only a small percentage will actually comment Why yes, this is the typical usage model if you expect little discussion. I want to encourage more discussion so I am hoping for more writes. &gt;(btw, on my dev machine Isso handles ~40-50 concurrent writes per second with SQLite). How certain are you the writes are concurrently running the and not just handling the requests syncronysly? From the sqlite docs I can't seem to find anything that would suggest otherwise. &gt;Isso is not single-threaded, not even with the default webserver. Assuming we are looking at isso from the perspective that it is a wsgi python app, how is it not single threaded exactly? I didn't see you running any pooled jobs in your code when I glanced at it. Maybe I missed it? Are you running everything with gunicorn+gevent (with monkey patching)? That certainly would add green threads but we lack an async driver for the db making your dbaccess syncronus and blocking. In fact I don't know of any "production ready" async db drivers for python. &gt;FYI: Flask uses werkzeug, so if you're using Flask, you have problably used a few of werkzeug's functions. Well that's the thing. I haven't used either and I know they are developed by the same group of devs but that flask is higher level because it brings views (and more?) to the table. However I don't know enough about either project to decide if I like that you skipped over flask and went straight to werzkug. Not that its bad, I just don't know that I agree for this kind of project because I would love an admin interface to moderate comments so it seems to me more plumbing would have to be done to read jinja2 or something similar. If you could help me (as I have yet to really be able to fully understand myself) how exactly flask and werzkug differ and why I might want one or the other I would love it! &gt;&amp;gt; if i lose a handful of comments then no big deal. &gt;Why not use MongoDB instead? I tried mongo out for another project and just didn't really like it. Also have heard to many bad things about how it doesn't actually scale up or out. Also its not in memory like redis or SQLite so I doubt it would beat either in a simple key value lookup (excluding indexes). Finally redis is being used as a cache by a lot of people. So if I decide the whole 2 second window is too dangerous I can add a queu and "real" db for archived data. In addition, nodejs's async by default model is intreaguing me. I don't have any good uses for it at work so I am thinking about building everything with express 4 (if only koa and es6/harmony were ready!) and a few packages. Plus fully async db drivers! So good questions and comments and great work on isso! Look forward to hearing back :-)
If you need a shell for windows [ConEmu](https://code.google.com/p/conemu-maximus5/) is definitely the best one.
If people insisted on the rule "tabs for indentation etc" then programmer's editors would very quickly be programmed to follow that rule. My editor of choice is smart enough to automatically indent when I end a line with a colon, and can indent with either spaces or a tab. It wouldn't be that difficult to have it insert tabs to bring the indentation to the right level, and then spaces for the alignment.
Um, this is a Python subreddit. Why are you giving sample code in a foreign language? :-P Editors don't follow the rule to insert tabs for indentation and spaces for alignment because there is insufficient demand for it. (But I bet that there's an Emacs mode for it :-) Reality is that the spaces camp won the war, even though *logically* the rule makes good sense, there's insufficient benefit to it to justify fixing all those broken programs that can't cope with tabs.
It isn't hard to demonstrate code breakage from mixed tabs and spaces. def example(): [ TAB ]for i in range(3): [ TAB ][ TAB ]print "Inside loop" [SP][SP][SP][SP][ TAB ]print i In the interactive interpreter, running that prints "Inside loop" three times and 2 only once, after the loop has completed, but it looks like the second print is indented inside the loop. Give this guy the job of debugging a few of these tricky indentation errors, and if he still mixes tabs and spaces, show him the door, because he's beyond help. 
Technically yes, but complex numbers aren't taught in the VCE subject (which I've based these questions off) so anything involving complex numbers is hidden from students.
&gt; I checked out your static site gen also but ended up on Pelican for now. That's totally fine. FWIW I removed the link to my older project (this part is two years old) so people don't have to worry that I enforce a certain engine etc. &gt; how is it not single threaded exactly? Werkzeug's default webserver is just the std lib server + a threading mixin, which means that one request may block due to concurrent writes, but another (read) request can still be processed. Furthermore, Isso supports gevent (and its ugly monkey patching) and real processes (utilized by Gunicorn, uWSGI and Apache's FastCGI/WSGI). Concurrent writes to the database are indeed the bottleneck, but they would not affect read-only requests. &gt; [... Flask] I just like to avoid unnecessary dependencies. Flask is a framework, whereas werkzeug is just a WSGI library and I prefer plain WSGI for simple web APIs. The lack of an admin interface is not automagically fixed by using Flask and Jinja2 (I'd rather use the REST API like the rest of Isso to keep it simple (for the project)). But nothing is written in stone, if someone contributes an admin interface using Flask, I can still merge it without rewriting the whole application that uses werkzeug. &gt; [... MongoDB etc] While I still think that SQLite fits perfectly (for my website as well as the demo site and a few other users), there are plans to use a db abstraction layer (not necessarily ORM) to support PostgreSQL and MySQL for moar webscale ;)
Nice little tutorial. Tried it out myself as part of a challenge I'm doing. http://www.jasondotstar.com/Day-1-Tweepybot/. Like you said, this could be dangerous in the wrong hands, but it's cool to see how Twitter's API works.
'has this figured out' implying it's even difficult, trust me, any spammer worth his salt looks at twitter and goes 'pfft' 
I suggest torrenting down LPTHW and see if you like the presentation. If you do, support Zed. The videos from what I saw are just supplemental (reenforcement) aids to support the online materials. I suggest getting the following books. **Introductory Texts (at least one of them)** http://corepython.com/ http://www.amazon.com/Quick-Python-Book-Second/dp/193518220x www.amazon.com/Programming-Python-Complete-Introduction-Language/dp/0321680561/ **Python Essential Reference** www.amazon.com/Python-Essential-Reference-David-Beazley/dp/0672329786/ **Python Standard Library** http://www.amazon.com/Python-Standard-Library-Example-Developers/dp/0321767349 **VIDEOS** *Python Osmosis (FREE)* https://www.youtube.com/playlist?list=PL4B416E115B44D973 *Infinite Skills (PAID)* http://www.infiniteskills.com/python/ 
So, from an [educational game developer POV](http://platipy.readthedocs.org/en/latest/index.html), I'd like this to have an interface for me to programatically request problems of varying content and difficulty. For example: &gt;&gt;&gt; mathexams.get_problem("fraction_division", "hard") "3/5 / 7/3" &gt;&gt;&gt; mathexams.get_problem("integer_addition", "easy") "2+2" And I'd be fine if "difficulty" was determined by guessing at first (although it'd be nice if you consulted some people in Math Education, since they probably have data on this!), but it'd be very useful if you could have projects to collect data on what people struggle with. That way you could get a clear idea of "debugging tips" for this; feedback is the biggest key to teaching. It'd also be nice if you could align that with some standards, maybe the Common Core. It's pretty dangerous to give beginning educational game developers a way to quickly generate math problems, because every newbie in the field makes a math game, and every time it's basically a multiple choice test with colorful animations. The kind of thing that pretty much kills [Kurt Squire](http://platipy.readthedocs.org/en/latest/research/squire2006.html). But I still think this has potential as being a valuable tool for more interesting games.
This looks really cool, just about to sit my math exam in two weeks. My only suggestion would be to improve the distribution. I know many of my teachers wouldn't even know what the command line was let alone find it and use it. Maybe a single .exe to install ( on windows ) and a GUI to generate pdf files. 
You code w/o a design? You must be some kind of coding genius. Well defined designs combined with TDD make development easier. A lot easier. Writing a web app that interfaces with third party services and other internally developed or commercial products is impossible without design work. Code becomes a nightmare, time is wasted refactoring. TDD + Pep8 + proper design makes coding fast and accurate. There are always bugs, but none are worse than the kind created by poor planning. 
Coming from someone who did mapping in goldsrc: nope. In goldsrc, wads were basically texture containers. The maps themselves were actually contained in completely different files.
I want to hire whoever produced this video.
That's some clean code.
Just wondering....why? I don't see any use for this.
As someone unfamiliar with the inner workings of Doom, what is this?
It's something I will take with me. But, ach, camel case! I take it all back.
As someone new to Python, can somebody explain to me what this is?
You should also check out [pawk](https://github.com/alecthomas/pawk); which is basically the same as awk but you can write the code in Python.
The lead developer works Sony Pictures. I imagine he has pretty good connections for such things.
I know! Do they think we're in C# or something!? Mad bastards
Who's doing the propaganda? Yes, there are python2 exclusive libraries. There's also python3 exclusive libraries. I should know because I write some when I can't be bothered with 2.x. Almost all the "large" libraries are 3.x compatible. Almost all the high quality code is 3.x compatible. We're at a point where it's no longer the libraries but people like you who are holding Python 3 back. "I heard Python 3 is not there yet so I won't make any effort". For fucks sake, writing python 2+3 compatible code is not hard. Use print(). Once in a blue moon, use try/except import blocks. All this blog post is doing is "Write compatible code". This attitude you have is such bullshit. Edit: [I have a feeling you're just a giant troll](https://pay.reddit.com/r/Python/comments/1ybliw/pypi_has_3800_packages_with_python_3_support/cfjc51b?context=3). Edit2: Linked post has now been deleted. Was a post by same commenter about how wonderful Python 3 is, how he ported all his apps to Python 3 and how he's never going back. 
thanks! im using windows, so no ps unfortunately
&gt; authorization interfaces with a basic one using ACLs I'd just like to make mention that you can subclass SQLAlchemy's default Query class and build your own ACL system if need be. It's not easy, but it's entirely possible.
Ok. I'll give a bit of general advice. I'm no expert in Python. * Most important, I'd break this down into separate functions. You could have a get_system_warning, get_list_direction, and print_update function. Without this, your code will get more and more difficult to follow (for instance, if you want to have a little window instead of printing to the terminal). * count_up/count_down can be combined into a single conseuctive_count variable with positive and negative values. * Why not reuse the output variable? You define it and then print the same thing. * Constants in any language should have UPPER_CASE naming. I'd extract the system_warning strings to constants and put them all together. It will be easier to make the changes all in one place. * Generally speaking, you want to have a consistent code style. Python tends to have spaces between things, making it easier to read. So c=1 or c= 1 would become c = 1. Following this style makes things easier for you or other programmers to read. * I'd use Python's % printing style, which makes strings easier to interpret. So your outputs would become: "High: %d Low: %d Bid: %d Ask: %d" % (tick['high'], tick['low'], tick['bid'], tick['ask']) * Doing this means that you don't need to cast str(), and it makes formatting very easy - padding zeroes, for instance. * Finally, you might consider what the consecutive ticks mean to you. It's almost pointless since you're fetching at an arbitrary interval and you don't know what happened between fetches. What if the ticks go down by 10 over 2 seconds and then consecutively up by 1x 5 times? The net is still down 5 over that period. Is there a better way to represent fast movement? You could store an array of values from the past 10 retrievals and then see if the price has changed X amount over the past 20 seconds. I think it would be an interesting exercise.
Whoops, I read those parenthesis as "people certainly do [see barriers to making full apps with Kivy]" rather than "people certainly do [make full apps with Kivy]." My bad.
This is nice. At least it makes deploying django more accessible. I am already using DO for some static sites, and want to leave Heroku for django apps, as it can get really expensive once you need more. Looks like DO is best to replace Heroku. 
Just to let you know that most of the popular python libraries already support Python 3. See this graph http://py3readiness.org/
a quick refactor: from __future__ import print_function import json import os import time import urllib def ticker(): return json.loads(urllib.urlopen('https://www.bitstamp.net/api/ticker/').read()) class Ticker(object): def __init__(self): self.count_up = 0 self.count_down = 0 self.last_direction = ' --' self.tick = ticker() self.last = self.tick['ask'] def update(self): self.tick = ticker() self.update_ticker() self.update_direction() self.alarm() self.debug() self.last = self.tick['ask'] def update_ticker(self): header = "Hurray Bitcoins!\n" output = "High:", str(self.tick['high']), "Low:", self.tick['low'], "Bid:", self.tick['bid'], "Ask:", self.last, os.system('cls') print(" " * (len(str(output)) / 2 - (len(header))) + header) print("High:", str(self.tick['high']), "Low:", self.tick['low'], "Bid:", self.tick['bid'], "Ask:", self.last, end=' ') def update_direction(self): if self.tick['ask'] &gt; self.last: self.count_down = 0 self.count_up += 1 self.last_direction = " ^^" print(self.last_direction) elif self.tick['ask'] &lt; self.last: self.count_up = 0 self.count_down += 1 self.last_direction = " vv" print(self.last_direction) else: print(self.last_direction) def alarm(self): if self.count_up == 5: system_warning = "PRICE GOING UP!" elif self.count_down == 5: system_warning = "PRICE GOING DOWN!" else: system_warning = '' print("\n" + system_warning) def debug(self): print("up: " + str(self.count_up), "down: " + str(self.count_down)) def main(): t = Ticker() while True: t.update() time.sleep(2) if __name__ == '__main__': main() 
Use real arrows ⬆⬇
system_warning is never cleared. it starts off empty, then gets set when there's a strong movement, but then never gets cleared. this kind of bug is common because you have have variables that are being set to "save" information. in general, that's not a great idea, but it's hard to avoid. one way to avoid having a variable would be to save the last five ticker entries and work out each time round the loop if you want a warning, but that's a lot of work in this case. another way, which would be better here, is to test count_down and count_up, and then print something if one is &gt; 5, but not to save anything in a variable. in general, the fewer variables you have saving information, the better the code.
`lookAtMeMyScriptIsASpecialSnowflake()`
This is basically a manual for spamming. Don't do this.
Particularly useful if you're taking over a codebase from a java coder who got forced into using python. Holy inheritance Batman.
Your "refactoring" is much more verbose, and complex than the original for no apparent benefit. No, not everything has to be a method ;-( I think it's **worse** than then the original code
Or even a web-based interface; teachers don't want to download anything.
I think he was joking a little with the from __future__ import print_function In Python 3.x, print "words" has been replaced with print("words") so syntactically it's more like a function. I expect invl is a Python 3.x user so he's more used to using print with the 3.x format as opposed to the 2.7 format. With regards to calling things from self, you'll notice that he's created a class named Ticker. In Python, when you call a method from an instance of a class an argument is automatically passed to the method containing the instance of the object, notice that all the methods in ticker take the argument "self", ie. def method(self): By then referencing self, you are interacting with that instance of the class alone, accessing it's local variables and methods, as opposed to global variables like you were. This is something you should be trying to do when programming in object-oriented languages such as Python. Organising data structures by using classes and such makes it much easier to expand upon your program later and keeps everything much more organised, say for example you wanted to slightly modify the Ticker class so that when you initialise a Ticker you can pass an argument to tell it which json url to listen to, then you could have one program with multiple Tickers in working simultaneously.
1. move print last_direction out of if/elif/else: if tick['ask']&gt;last: count_down=0 count_up+=1 last_direction=" ^^" elif tick['ask']&lt;last: count_up=0 count_down+=1 last_direction=" vv" print last_direction 2. reuse "output" for printing print output or print " ".join(output) 
Not everything has to be a method, but part of the point of methods is that they separate code in to smaller chunks that make it clearer which lines are directly associated with which, increasing readability. On your comment on it being worse than the original code, readability is paramount, and it's certainly more readable than the original. The use of classes gives a data structure that is more easy to work with when expanding upon the program than the original. I much prefer invl's refactoring to OP's code.
Very cool :)
http://flask.pocoo.org/docs/quickstart/#file-uploads It's even part of the QuickStart guide.
Thank you &lt;3
Some time ago, I was terribly excited about the ability to produce Plone archetype stub code *from* UML models. Then, we realized that round trip was infeasible, and, had we not been concerned with impressive diagrams containing gradients and stick gfigures, we could have iteratively reached a comparable solution with less tool dependency... YMMV http://modeling-languages.com/uml-tools/#python [EDIT] http://www.agilemodeling.com/
``__future__`` has existed for at least 10 years, very likely quite a bit longer. It is a way to introduce new features that can be tested and are likely going to become incorporated in future Python versions. So, you may find yourself using it in your Python 3.x program if you find that you'd like something that is going to be officially incorporated in the 3.(x+1) version!
It would be nice to know what the down votes are for. * Is it for my unorthodox approach to getting quickly up to speed with an unfamiliar code base using the profiler and runsnakerun. If so, it may be unusual but I find it to be easiest and by far the fastest approach I'm aware of. * Or is it for saying auto-generated UML diagrams are not well crafted. * Or is it just some anti-UML nuts that will just down vote any mention of UML actually being useful. If this is the case all I can say is that I personally don't like more than 95% of the UML diagrams I come across but I don't completely write off the value of UML. I believe there is value to having a standard syntax of creating graphical diagrams to express design and for this reason alone I have to give UML some credit even if I don't agree with the principles that drove the creation of UML. Sometimes a diagram is just the best way to express a design and if your going to create a diagram it's better that we all use the same syntax.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**UWIN**](https://en.wikipedia.org/wiki/UWIN): [](#sfw) --- &gt; &gt;__UWIN__ is a [computer](https://en.wikipedia.org/wiki/Computer) [software](https://en.wikipedia.org/wiki/Computer_software) package created by [David Korn](https://en.wikipedia.org/wiki/David_Korn_(computer_scientist\)) which allows [programs](https://en.wikipedia.org/wiki/Computer_program) written for the [operating system](https://en.wikipedia.org/wiki/Operating_system) [Unix](https://en.wikipedia.org/wiki/Unix) be built and run on [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) with few, if any, changes. Some of the software development was subcontracted to [Wipro](https://en.wikipedia.org/wiki/Wipro), India. References, correct or not, to the software as U/Win and AT&amp;T Unix for Windows can be found in some cases, especially from the early days of its existence. &gt;UWIN source and binaries are available under the [Open Source](https://en.wikipedia.org/wiki/Open_Source) [Eclipse Public License](https://en.wikipedia.org/wiki/Eclipse_Public_License) 1.0 at [AT&amp;T](https://en.wikipedia.org/wiki/AT%26T) AST/UWIN open source downloads. &gt; --- ^Interesting: [^Cyril ^Uwins](https://en.wikipedia.org/wiki/Cyril_Uwins) ^| [^Thomas ^Uwins](https://en.wikipedia.org/wiki/Thomas_Uwins) ^| [^David ^Uwins](https://en.wikipedia.org/wiki/David_Uwins) ^| [^Cygwin](https://en.wikipedia.org/wiki/Cygwin) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chq8it2) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chq8it2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
What was the use with flappy bird?
What's the standard Python convention?
Being a long-time user and fan of Unix, I/O redirection, pipes, etc., and also a Pythonista, I had written a series of posts (*) about various Unix pipe-like tools that are in and for Python, a while ago. Inspired by them, I had also created an experimental Python tool called pipe_controller, which, while not in the same category as these pipe-like tools, tries to apply the pipeline concept, but within a single process. (*) The entire series of posts can be read, starting from the last one (or so) in the chain, here (each post links to the previous one): Swapping pipe components at runtime with pipe_controller: http://jugad2.blogspot.in/2012/10/swapping-pipe-components-at-runtime.html Some of the Python tools that provide pipe-like functionality, that are mentioned in the posts, are pyp, Plumbum, osh (the object shell), etc. And here is another post (the 2nd last in the series) which may be of interest: Using PipeController to run a pipe incrementally: http://jugad2.blogspot.in/2012/09/using-pipecontroller-to-run-pipe.html pipe_controller is available here: https://bitbucket.org/vasudevram/pipe_controller 
The wad files are basically the level packs. 
Good example. That shows that the extra work is usually one or two lines. Nothing for me to cry about. :) It is true, that the idea of mocking bits of an application is dangerous. My approach over time has changed to something like Augie Fackler and Nathaniel Manista explain in this video: (minute 15 more or less) https://www.youtube.com/watch?v=Xu5EhKVZdV8 A set of "official mocks/stubs". In my case they're usually mocks for commands and stubs for queries http://blog.ploeh.dk/2013/10/23/mocks-for-commands-stubs-for-queries/ More info about test doubles naming (just in case someone is asking) http://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs
doom1.wad not found All are not found.
While working on pipe_controller, I also got the idea for fmap, a kind of inverse of the built-in Python map function: http://code.activestate.com/recipes/578281-fmap-a-kind-of-inverse-of-the-built-in-python-map-/ And the post about fmap on my blog had a good comment by someone who wrote a function to compose functions in Python, called compose: http://jugad2.blogspot.in/2012/10/fmap-inverse-of-python-map-function.html 
[lower_case_with_underscores](http://legacy.python.org/dev/peps/pep-0008/#id28)
Thank you
And what's contained in the level pack? Sprites, maps, textures? Seriously, I've played doom maybe 3-4 times in my life.
No reason you cant use snuffleuffagus either.
That was one slick code demonstration video.
pyd pyper
For sure ;). The project is not ready for that stage yet - there is still a massive amount of content that would need to be written - I have only coded a small number of questions. Once it gets closer to that, a web interface would be the ideal way to distribute content.
&gt; readability is paramount Yep. In other news: kittens are good and nazis are bad ;-) a. readability is *heavily* affected by verbosity b. readability is *somewhat* subjective c. readability requirements are quite context sensitive (what's good in one-off script may be bad in a long lived system) d. overdesign is as big of a problem as an underdesign e. YAGNI. I want to stress (e). All the invl's code structure is wasted code and time if won't ever be reused. Worse, it's very likely wasted time even with reuse (because you don't really know what you need reuse-wise until you have at least another use case)... 
I think this is a pretty common experience. You're actually pretty lucky, I suspect. IMO, it's a pretty good idea for folks with, say, &lt; 1.5 yrs of web development experience to use a more opinionated framework, because they can be productive without needing to make decisions that they might not be comfortable making (or have the experience to make). But once they get, say, more than 2 yrs or so of web dev experience to branch out and try other things. This is why I like the idea of a less opinionated framework being your "second and last" web framework. However, usually often when a developer picks a first framework, they'll use it forever, because they are not very curious and they perceive disusing what they already know as a cost they can't bear. But since you used Flask first, you now understand the tradeoff and you'll be more likely to use it on an upcoming project where it makes more sense than a larger framework. That's actually a tactical advantage, so good job!
**Don't** use urllib for HTTPS. It doesn't validate the certificate, so unless you manually do so, it's not secure. Use the `requests` library for HTTPS.
I maintain about 300K-500K lines of code that is Py2/Py3 cross-compatible. While, as you say, it's not rocket science to do this, it does suck, because the subset language you must develop in is obviously worse than either Python 2 or Python 3. And that's a problem because I just have no idea when I'll be able to program in a better language. Both "camps" I support have good reasons why my libraries should be compatible with either Py2 or Py3 and neither is willing to give in entirely. So in effect I'm forced to program in a language I really don't like all that much, at least when I do open source work, and I have no idea when this will not be true anymore.
Not looking to make a twitter bot, but is there a good twitter library for python 3?
Depends on what you are trying to do. I've found them to improve readability most of the time. The ones with multiple ranges can get a bit hairy to read though.
I just started working with python and will only be using python3. You're welcome. :p
I find that they works the best for "simple stuff", when you need to only apply a one liner to a whole array, or filter out some elements from an array with a single condition. for example, I find this more readable from pathlib import Path p = Path('.') files = [file for file in p.iterdir() if file.is_file()] than from pathlib import Path p = Path('.') files = [] for file in files: if file.is_dir(): files.append(file) But it starts to get quite unreadable once you add stuff, for example files = [file.stem.replace(' ', '\ ').strip() for file in p.iterdir() if file.is_file() and file.suffix is '.py'] (Still kinda readable, throw in a .match() and a regex) I also don't particularly enjoy list comprehension that operate on more than a single list. But again, it really depends on the list, "easy stuff" is usually more readable in comprehension mode than the "normal" mode. Anyway, since it's your code, do as you prefer. Just don't force either, when you feel a list comprehension is the right way to go, go for it. When you feel that a normal for instead is more readable, use it.
really? I find odds = [n for n in numbers if n % 2 ==1] to be far easier to read than odds = [] for n in numbers: if n % 2 == 1: odds.append(n) Do you have an example where the comprehension is more difficult to read?
You can use the os.system() command and use the find command. This only works on Linux tought because its a bash command. In this article you can see some usages of the find command. http://javarevisited.blogspot.be/2011/03/10-find-command-in-unix-examples-basic.html Good luck!
Run Linux in a Virtual Machine; I use [VirtualBox](https://www.virtualbox.org/), it's free and easy and will run on all platforms. Install your favorite distro http://distrowatch.com/ and hack the shit out of it. Don't have a fav distro? Try them all, creating and destroying VMs is easy. It would be a great learning experience plus you don't have to mess around with your host machine, except for installing virtualbox.
You can't do this in python or any other language easily, but it's almost impossible in python. It looks like you want to actually directly read the hard drive, for which you need to write your own raw filesystem implementation for.
Look at http://www.reddit.com/r/learnpython/comments/265193/brute_force_help/chnpl0h and compare with the original code put in the question; which is more readable? (And, I note that someone later correctly mentioned that generators rather than lists would have been more appropriate - but it was still with essentially the same syntax.) To me, list comprehension are clearer **if** they are relatively simple i.e something like [something for x in range(n) if condition] (So, the last one in the example I gave is bordering on being too complex.)
Thanks!. I'll check that out. Im hoping to find something to use in windows but will head the Linux route if needed. I did a little python scripting in Unix for a class and found that Windows is a little lacking with the modules. 
Were I you, I'd go through the code of some recovery program. My favorite happens to be [testdisk](http://www.cgsecurity.org/wiki/TestDisk_Download). Grab the source and figure out how it works. I'm sure that you can re-implement the algorithms in Python, the question is the difficulty of the thing. Edit: Also, [this](http://carlo17.home.xs4all.nl/howto/undelete_ext3.html) appears to be a good source of info. It explains how files are stored in the EXT3 system, and how you'd go about recovering them.
Oh I almost forgot. If you install cygwin or mingw you can use Bash functions in windows. Little note for clarity. This is only for searching existing files. Deleted files are not going to work with this
I am glad you brought that up. Your point is true, each tool does have a niche where it is useful. I just wish software engineering courses at universities would focus less on modeling crap and more on good design decisions. That is what the vast majority of software engineers will need to know in practice.
I decided to start with Learn Python the Hard Way. It has an appendix that covers the command line. I learned some basic things like copying a file, going to different directories, paging through a file, etc. but did not learn how to set environmental variables. Do I need to learn more before progressing to Python? I am using a laptop with Windows 8 so I am using powershell.
Why pastebin.com appear is not found in my brower?
PyPy3 2.1 Beta is available for download from [their site](http://pypy.org/download.html). It can't be that far off. The author mentions Python3 as "the culmination of a bunch of little improvements led to a much more pleasant programming experience.", and that's why I switched. I like having print as a function, division that produces floats, errors when comparing unorderable types, cleaner namespaces, having to think about bytes and encodings, asyncio (i know there is a port for 2 under another name, I also like `yield from`), and all of the other improvements that come with 3. There are too many to list, and I don't even know all of them by heart. Python 2 made me love Python, but Python 3 made me love it even more. My current web host supports it, so I can run my little Django app using Python 3. The latest Kubuntu version uses Python 3.4 as the default `python3`, so I have all of the 3.4 improvements at my disposal. So far for my needs I haven't found a reason to NOT use it.
If you only handle them as strings, yes. But certain APIs expect or return bytes instead of strings, so you must encode/decode them or get an error.
It does suck for larger projects. And the situation isn't at all that great; I don't think anyone is saying "everything is peachy and awesome and Python 2 is dead". The real problem is the people flat out refusing to port to python 3, or refusing to acknowledge that it is gaining traction. Python 3 is getting installed by default on more and more Linux distributions, which imo is what is going to be the driving force behind all of this. With both Ubuntu and Fedora working on this and actively investing time into ports, the uptake can only increase from there.
Okay, so the only difference is implicit-conversion is no longer allowed, which isn't really all that big a difference, so what I said is still right. (The minor change to how literals work doesn't change what the types do, how they work.)
In Python 2, they would expect "strings", and disallow "unicodes". In Python 3, they would expect "bytes", and disallow "strings". So like I said, the two types are the same, just named a bit better.
maybe port it to dogecoin
If you don't know the answer, please don't phrase your opinions or guesses as facts. You can look at the raw device (/dev/rdisk etc) and look at the blocks directly. Still need to understand file systems but don't need a driver. Could even dd off the device and copy to another machine entirely. IIRC there are "recover deleted images from SD cards" programs out there. Which might be an ok place to start conceptually, though I imagine they rely on FAT32 being simplistic. One possible assumption is that deleted files are missing from the FS entries, so you can walk the deleted blocks to find the headers of recognizable files. See the magic numbers file that goes with /bin/file on unices. Not sure how you recover the rest of the file if it is not continuous. I seem to remember something about direct and indirect block lists working differently.
Poster doesn't know what he is talking about.
I agree that there is some momentum, and it's a matter of time. However, that's kind of the problem. Realistically I think the point at which I can stop developing in the subset language is going to be about 10 years. And the subset language is poor enough that if some compelling alternative language emerges that doesn't appear to have the same sort of unsatisfying bw compat policy, I'm going to be seriously tempted to move to it. And I think that's going to be true of a lot of developers, which is a horrifying thought.
Almost always.
I think your list comp's problem is that it's a one liner. Break it up into multiple lines and it looks a lot cleaner. files = [ file.stem.replace(' ', '\ ').strip() for file in p.iterdir() if file.is_file() and file.suffix is '.py' ]
not an easy thing to do, though... Think about it. You have a couple of months at most to introduce people to X amount of concepts and evaluate them and need some self-contained example as a project or problem so that it can be done in that period of time. real life either takes much more time (full time job), has different constraints, it's not evaluated in the same way since all that matters might be just the end result, has teams of people with a different focus and commitment and varying amounts of experience, etc. Some are really bad but some really do try to do what you say and end up falling short to the inclemency of fast paced university schedules. 
Edit: there's open source utility written in C that can recover files: http://www.cgsecurity.org/wiki/TestDisk &gt; but I'd also like to try and locate deleted files. You need to figure out what happens when whatever OS and file system you are using deletes a file as well as how these files on the specified file system are stored on the disk. Probably starting with FAT FS would be the easiest way, but this is low level stuff. A "short" and probably confusing example on how you **might** recover a file: The disk is divided into sectors (clusters?) that usually hold 512 bytes of data or the multiples of it. The partitions of the drive (the info such as file system type, starting and ending sectors of any partition) are stored in the Master Boot Record (I won't get into GPT on the newer PCs). Then the starting sectors/the beginning of whatever partition you are interested in (say, FAT FS) probably hold some kind of structured data (you will need technical docs for this, [something like this .doc from MS](http://msdn.microsoft.com/en-us/library/gg463080.aspx)). For example, this structured data could be some kind of linked list that has all the info about all the files stored on the partition. This might include info such as file names and a sector number where the file starts. This starting sector in turn might include the number of the next sector of this file on top of file's data. It's either that or all the involved sectors might be kept in the same "structured data". So now you need to know what a particular OS/FS driver does when it deletes a file. FAT FS driver could just delete the first letter of the file name, mark the sectors that were used by the file as "free" and be done with it. It doesn't replace or fill anything else with zero for performance reasons. There's just no need to. So your program would scan this "structured data", find where the names are missing the first letter and provide this info to the user. The user would provide the first letter. The info regarding what sectors were used by the file could be still there. So your program could recover a file. Of course, it gets trickier if the "freed" sectors were already used by new files, meaning that you probably won't be able to fully restore the file.
I'm working on a larger project that involves this, so I was just stubbing out some code I am currently working on. I posted this at a really early state because [John Carmak](https://twitter.com/ID_AA_Carmack) re-tweeted a link to it (I'm enjoying a little nerd stardom at the moment)
I'm more of a [Java programmer](http://stackoverflow.com/users/16959/jason-sperske?tab=tags), Python is still a new language to me, but I am [loving it](http://xkcd.com/353/).
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=353#Explanation) **Stats:** This comic has been referenced 45 time(s), representing 0.2134% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
Always good to learn convention, thanks for the links :)
A PWAD would commonly contain levels (on some rare occasions it would include graphics and music, but there were some limitations as to what it could overwrite). IWADs were total replacements of all assets.
Do you have control over the file contents? Is there a delimiter (comma, space, any character really), between all of the values? The mode determines how python interacts with the file. There are a variety of them, including read, write, and append. Like many functions in python, open() does have parameters you can manually set. If you don't set them, they remain default values. What specifically are you confused with about that?
For distribution I PyInstaller and it works for Windows and Mac. I tried Freeze before that but never got it to work. It took a few hours to finesse the PyInstaller .spec file to work. Although there is a feature to generate a .spec file automatically, it didn't work and I had to write one manually. Then I had trouble code signing the app for both Windows and Mac. On Windows, the code signing manifest was complaining about the Microsoft.VC90.MFC file. Altering a version number in the manifest made it work. On Mac, the code signer would complain about all sorts of files in Electropocalypse.app/Contents/MacOS which is where PyInstaller puts everything. But the Mac code signer expects just binaries in the MacOS folder. Moving all the files to another folder and writing a one line shell script to run from the other folder fixed this, but it took me days to figure it out.
I'm not sure how experienced you are with Python so forgive me if I am being presumptuous. I feel that in most cases, list comprehensions helps readability a lot (you can overdo anything of course). I used to feel the same way about them as you do now but it got much better the more I understand the language. I feel like it's common that people new to the language get confused by them. 
You need to show the code that you use for both tests if you want anyone to believe it.
your understanding is pretty close to correct. Here's a quick summary of the modes: - `"r"` is read mode - you can guess what that's for, and it's the default. - `"w"` is write mode. Importantly, opening a file in write mode will erase whatever's there at the time. - `"a"` is append mode. In this, you can write to the end of the file without deleting the whole thing. The mode switch is necessary because it gives the interpreter information about your intention for the file. If you're only going to read the file, it will do something completely different than if you open it in write mode. With that said, you'll probably want to do something like this: with open('textfile.txt', 'r') as f: # opening the file in read mode! lines = f.read().split() # assign lines as the individual `\n` separated lines in the file After that, you can do whatever you want with the list of lines. Remember that `lines[-1]` will get you the last line. Note: in the future, you should give a little more context about the *task* you're trying to achieve rather than the method you're trying to use to get there. There are tons of smart people here (and also check out /r/learnpython) who may be able to give you a better answer, or suggest you try an easier alternative if they know what you're trying to do.
While of course in practice the Python 3 standards create far better code, my point is that everyone who still uses Python 2, but complains about the Python 3 string system, doesn't understand Python 3, because it is essentially no different -- just easier to see your mistakes. So really we're just mutually agreeing we're both right :)
I know this is just an example, but &gt;`file.suffix is '.py'` made me wince a little.
No, you don't need a driver since you need to write it. In order to pull this off you need to understand the filesystem's specific on-disk format and write your code to use it, which is basically writing a driver for the filesystem. Given how low level it is to do filesystem work on the raw disk, as opposed to something like curlftpfs, this is definitely something I wouldn't use python for.
The hard part is writing the driver that controls the hardware. You do not need to write a driver, because you are not controlling hardware. Reading structured data like a filesystem is no harder than any other (extremely complicated) file format such as MS Office files or packet dumps or whatever. Use Construct or something like that. Documented filesystems aren't THAT hard. FAT32 or ext3 is probably a long weekend to get something reasonable done. NTFS probably much harder. That said, what some other filesystem driver does when unlinking structures is implementation defined so probably involves some serious sleuthing. 
:D
2.7 still works and I know it is going to be installed. I also learned vim because I know it will be installed. It doesn't matter how amazing 3.x (whatever its current api is) is, I know 2.x will work. The *only* advantage 3.x seems to have is unicode and it really doesn't seem to do that well. So if I need unicode support I'll just use golang because it handles it far better than python 3.x.
I'm sorry, I fail to see how that's different from Python 3. Changing from bytes to string and back requires explicit encoding/decoding. No assumptions are made.
&gt; I don't fully understand the open concept or why it needs a mode? You either read or write to a file. The computer doesn't know what you want to do. &gt; my understanding i can leave the mode blank, and it will automatically enter read mode? Yes because it's a default argument. Every piece of Python code I've seen puts "r" when they're opening a text file. It's more clear, but it's not required. &gt; How would i go about searching a file, finding xx Your example is confusing. It depends on how your file is formatted. Can xx be on 2 lines? Can it be on the same line twice? Do you only what the xx if yy is 10? Is the file 1 line?
The change to **print** is substantially more than just adding parentheses. **print** is now a function, with all that implies. You can assign **print** to a variable or assign a new function (or anything else!) to the **print** variable itself.
I personally have the following rules: 1. Use traditional `for` statement when there’s no result of each function call, or they are not needed e.g.: for el in elements: do_something(el) 2. Use `map()` function when the expression is a simple function call e.g.: results = map(int, el) 3. Use generator expressions when the result is used for an only argument of a function call which take an iterable e.g.: result_set = frozenset(do_somethin(int(el)) for el in elements) 4. Use list comprehensions when the result should be a `list` e.g.: result_list = [do_somethin(int(el)) for el in elements] result_list.insert(i, value)
Awesome, was looking for something like this for months.
piep is a similar tool, inspired by pyp but addresses a bunch of shortcomings. It seemed to work much more like I'd expect (e.g I was surprised pyp buffered the entire input before operating, instead of being line-based) http://gfxmonk.net/2012/03/28/why-piep.html
With regard to importing libraries, I think the pyp authors could make things easier by adding a mini, command-line dsl. Here's an excerpt from python-oneliner's documentation that demonstrates this idea: Importing Modules: The '-m' option imports modules into the global namespace of each evaluated expression or statement. The '-m' option can be specified multiple times. For example: -m os,sys,re,pickle =&gt; import os, sys, re, pickle -m os -m sys -m re =&gt; import os, sys, re -m os sys re pickle =&gt; import os, sys, re, pickle -m os.path.[*] =&gt; from os.path import * -m subprocess=sub =&gt; import subprocess as sub -m os.path.[join,exists] =&gt; from os.path import join, exists -m datetime.[datetime=dt] =&gt; from datetime import datetime as dt The os, sys and re modules are included by default. The '-i' flag will attempt to import all top-level module names found in an expression or statement. In the following example the 'time' module will be imported automatically: yes | pyl -j -line '(time.time(), line)' For more info on oneliner, see the [docs](http://python-oneliner.readthedocs.org/en/latest/) and the [source](https://github.com/gvalkov/python-oneliner). It tries to mimic the Perl/Ruby way of writing oneliners (i.e. the -nlpe flags). 
This is an excellent set of rules. I may have to borrow/steal this list to include in a tutorial I am planning to write.
Tab characters were initially added to replicate a feature found in typewriters where one could insert mechanical "tabs" which were use to stop at a particular location. These mechanical devices were adjusted by hand and consecutive tab stops were not necessarily of the same length. On a typewriter, tabs were used for **alignment**: they made the work of producing tabular data well lined up on a page much, much easier. The one exception (if one can call it that) was that usually the first tab stop was set to "indent" the first word of a given paraghraph. However, this was still to ensure that such first words were aligned on a given page. For languages that do not use indentation as a meaningful feature, programmers use tabs/spaces to **align** blocks of code so that the logical structure can be better seen. Just like on a mechanical typewriters, it is found that pressing the tab key speeds up the alignment process. When memory space was precious, it was considered good practice to use tab characters instead of a number of space characters. Programmers thus started using tabs for indentation. Today, there is little reason NOT to immediately convert tab key presses into spaces (and shift-tab into deletion of a set number of spaces, or up to a pre-defined point) while editing and to prevent the insertion of the tab character into source code. 
 endpoint = "%slive/geo/v3/?limit=1000&amp;apikey=%s&amp;host=" % (options.chartbeat_url, options.API) geo_sites = [''.join([endpoint, site]) for site in options.sites] responses = yield [http_client.fetch(site) for site in geo_sites] [...] [[key[0], key[1], value] for key, value in res.items() if value &gt; population_threshold] IDK this looks a little confusing to me, but something I just wrote recently. In the second example the key is actually a dictionary of (lat,long). 
Perfect! Thanks. I had some idea about this but need to figure out how to get the program to access this part of the disk. I'll read up on the sources.
I find it interesting Python 3's implementation of range() is slower than 2.7's range() and xrange(), and by a fairly significant margin. Can someone explain why this is true?
I forget where I first found this, but you can also set the dictionary's `__dict__` to itself: class dictobj(dict): def __init__(self, *args, **kwargs): super(dictobj, self).__init__(*args, **kwargs) self.__dict__ = self x = dictobj() x.y = 10 print x['y'] 
Oh my god that's brilliant.
As well as allowing for things like `map(print, sequence)`.
Also, the positional argument `sep`, allowing for things like: &gt;&gt;&gt; some_list = [1, 10, 100] &gt;&gt;&gt; print(*some_list, sep=', ') 1, 10, 100
Hi - **[Real Python](http://www.realpython)**'s third course, *Advanced Web Development with Django 1.6*, which will soon be 1.7, takes a Django project built in version 1.5 with Python 2.7.6 and converts it to Django 1.6 and Python 3. You then work with that project throughout the course as you build a Star Wars - themed social network/ecommerce site. We have three total course. 1. Part 1: Introduction to Python 2. Part 2: Web Development with Python 3. Part 3: Advanced Web Development with Django 1.6 (I am the co-founder/co-author). Best!
You can unpack the lat/long to make it cleaner [[lat, long, value] for (lat, long), value in a.items() ...] 
Great idea!
I use it for: * research * development * testing * notes * blogging * presentations
As a guy relatively new to Python and programming in general, I would say yes. But thanks to this feed I have been able to understand them a little more clearly. :-)
Except that in Python 3, `map` returns a generator and you have to force evaluation by wrapping it with something like `tuple` or `list`.
Certain functions also return a generator in Python 3.x as opposed to a list in Python 2.7.x Can't remember exactly which though.
It's just Python 2 vs 3, Python 3 is a little bit slower...I will add a note in this section later :) 
I don't suppose you would be willing to provide an /r/learnpython version of what you just said would you? I'm drinking milk.
This is pretty stubborn by not reading changelogs and blogs and then making a comment here Python3 is offering no advantage. 
Thanks, you are absolutely right! also I added a note that the print statement in Python 2 will produce a tuple if you have multiple objects inside the parantheses. Python 2.7.6 [GCC 4.0.1 (Apple Inc. build 5493)] on darwin Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; print('a') a &gt;&gt;&gt; print('a','b') ('a', 'b')
that's insane and awesome
[This](http://learnpythonthehardway.org/book/) is a pretty great resource for learning Python. He goes over a lot of stuff that I learned in my Intro to OOP classes. Definitely do all the exercises, note-taking, and "homework" he assigns, it helps solidify the knowledge.
Thank you :)
[Coursera](https://www.coursera.org/courses?orderby=upcoming&amp;search=Python) has some free courses for learning Python. It's not offered till September, but the "Introduction to Interactive Programming in Python" course was fantastic for a beginner.
Damn. And you don't want a list or a tuple, because `print` returns `None`, making the return value irrelevant.
There's nothing that says you _have_ to assign the result to anything, but yes, in general, I think most people would just say "use a for loop" at that stage.
If you're worried about computational complexity, you can create a zero-length deque: `collections.deque(map(print, xs), maxlen=0)`. That's `O(n)`. `list(map(print, xs))` is worst-case `O(n^2)`.
More about a lack of elegance, honestly. ;)
Please always look on the right hand side as it has a plethora of resources to start with.
I've just finished this course and must say it dedicated to those who don't have programming experience. It only scratches the surface of OOP. But anyway it was fun to learn programming and Python by creating games.
It was my first experience with programming (since messing around with BASIC as a kid), so it was the perfect level for me. It looks like they're offering a [more advanced course](https://www.coursera.org/course/principlescomputing) starting soon.
obviously, I'm pretty new to decorators as a whole and I like the concept of doing that. Its very clean.
I really recommend - http://www.checkio.org/ It may seem difficult at first but it gives you a good understanding and practice of standard Python library. 
There's a class with the same name and the same attributes in the web2py web app framework. 
It seems you got it the wrong way around. It's Python 2 that makes *bad assumptions* about text encoding. You don't *have to* decode byte strings in python 2 explicitly. Simply concatenating a byte string with a Unicode string will make python 2 happily convert the byte string to a Unicode string and *assume* ASCII encoding for it (which, of course, might raise an error). In Python 3 that concatenation would raise a TypeError. There you *have to* decode the byte string explicitly ;-) It's true that Python 3 doesn't support the full string API on byte strings. E.g. Some people don't like that it doesn't have a .format() method on byte strings. If Python 3 would allow that, it would again have to make a *bad assumption* about the byte strings encoding (like interpreting it as ACSII).
Can anyone tell me what this opens up that Cx_freeze didn't already do? (Not being snarky, actually wondering.)
Well, as far as I can remember (I haven't used it in a long time, because it wasn't compatible with Python 3): * Py2exe can make a single exe with everything zipped inside it (cx_Freeze refuses to do so) * It can make Windows Services * It is Windows only (cx_Freeze is cross-platform)
To make tab completion work: def __dir__(self): return self.keys() + self.__dict__.keys() 
I don't read every changelog but I do read blogs (and obviously /r/python) about python so I'm not sure why you would say that I don't.
Yes but it really depends on so many factors here. In most applications the difference is really tiny
Last time I checked only 32bit binaries were affected. I'm quite sure that is false positive. Sadly it trigger on two very popular (and bad) AV programs. **EDIT:** Downvote me as much you want but that will not change facts. Detection rate of Windows one is low and Avast have one of the biggest false positive rate if we talking about generic file detection.
I've been using py2exe for awhile and it does this with a lot of different antivirus programs. It's probably because of the lack of publisher data in the .exe that makes it seem "suspicious". Rather than the actual content of the program.
Only if there was proper way to sign py2exe output without corrupting it...
I find list comprehensions anything but "really awful" in terms of readability. I find them *more* readable. I think it is because the initial creation of the list and the specifics of its creation are all done in one line (or one code block if it is there is much to do, though that's rare), and so my brain sees that as one mental "step" or one mental "unit", whereas if you generate the list in a for loop, you have to first create the empty list (step one), then do the loop action (step 2) then do the append (step 3). I know all of that is going on within the list comprehension, too, but it *feels* like it is all atomized into one event. It also makes your code shorter by several lines, and that counts towards readability (in this case, in my view). 
http://www.reddit.com/r/learnpython/wiki/index
Thanks for mentioning `caniusepython3`, didn't know that tool yet :) $ caniusepython3 -r requirements.txt Finding and checking dependencies ... You need 3 projects to transition to Python 3. Of those 3 projects, 3 have no direct dependencies blocking their transition: boto django-localeurl django-storages :(
Upvote for Python just being awesome sometimes
I agree. He nearly lost me when recommending only python 2 and made it seem as if python 3 was ignorable. Plus I found the exercises too dry and slow. 
&gt; It seems you got it the wrong way around. It's Python 2 that makes bad assumptions about text encoding. Not at all. Python 2 makes the correct assumptions. Namely that it can't reliably guess the encoding, and the text may not need decoding anyway. &gt; You don't have to decode byte strings in python 2 explicitly You do if you want your code to work when someone hands it non-ASCII text. &gt; If Python 3 would allow that, it would again have to make a bad assumption about the byte strings encoding (like interpreting it as ACSII Indeed. Because it makes the fundamentally wrong assumption that all text data can and should be decoded to Unicode. 
I found the New Boston videos to be helpful. They are short and easy to understand. Sorry on mobile or I would link you
Assumptions *are* made. Python 3 automatically tries to encode/decode IO like CLI arguments and stdin/stdout (and it has to get an encoding from somewhere), while Python 2 leaves that up to you. This is broken behaviour on Linux where filenames are explicitly bytes, not text, and scripts called from `cron` are run with the C locale (i.e. ASCII), causing Python 3 programs to blow up when they try to decode input with the wrong encoding. The `cron` problem is especially annoying, as your program runs just dandy from your own shell, but fails miserably when run from `cron`. It's hard to work around this behaviour. In Python 2, you can just pass the encoded text straight to `os.path` etc. and it will work. You still have to worry about encoding if you want to print/log the string, but that's a much simpler problem to solve and far less insidious. What's more, if you pass a Unicode string to `os.listdir` etc., and it encounters a filename it can't decode, it will silently ignore the file. This is in violation of the Zen of Python: &gt; Errors should never pass silently. &gt; Unless explicitly silenced. &gt; In the face of ambiguity, refuse the temptation to guess. The docs recommend that you pass `bytes` to filesystem functions on systems whose filenames are bytes (i.e. Linux), but Py 3 has already wrangled that filename passed as a command-line argument into Unicode (or choked on it)… So it's not just an implementation matter: the whole idea is broken. 
Aww. No one answered yet. I have a same problem.
This self-reference means that reference counting will not work and reclamation depends entirely on the cycle gc. 
There is also a handy-dandy online site to check your packages / requirements.txt https://caniusepython3.com/ Also, [Invoke](http://github.com/pyinvoke/invoke) is currently the spiritual successor to Fabric, by the same author, and py3 compatible.
I find the greatest factor in terms of readability is having good variable names. I understanding using single letters to represent numbers, but not for things which should have variable names.
Hm.... do you have (or otherwise know of) some sample code that I can look at?
I thought the way he wrote it was hilarious. That book helped me out more than any other tutorial I've read
Holy shit, this is nice. I make DOOM WADs, this will be really nice for my site. Thanks a lot for this!
Check out Boto3 and botocore, documentation (and examples) isn't great, but it's working for the most part. 
edX has a free course coming up in a couple of months. https://www.edx.org/course/mitx/mitx-6-00-1x-introduction-computer-1841
The original version was just [a single script](http://code.activestate.com/recipes/576704-python-code-minifier/) on ActiveState. Just before I was ready to release 2.0 I asked around, "this can obfuscate Python code in kind of an extreme way, should I release it?" and at the time (four years ago) the resounding response was, "No!" and, "It's too dangerous!" Well, here we are four years later and there already exists several Python code obfuscators out in the wild. Consulting with some friends and random strangers on IRC the response now is, "you might as well", "that bus left the station" and, "the world is ready." I haven't changed the code much at all since the initial 2.0 version four years ago. I've just gone through and removed old comments and updated the docstrings to work better with Sphinx. Sitting on something like this for four years is *not* easy. On many occasions I was tempted to unleash it but I held back. All I can do is hope that others may learn from it and that it is never used for evil.
It depends on the file system you are reading and what OS you are on. The best resource I have found on file systems is [File System Forensic Analysis](http://www.amazon.com/System-Forensic-Analysis-Brian-Carrier/dp/0321268172/) by Brian Carrier. It does an amazing job of explaining data structures for many file systems. It is the book I used when writing two scripts that you might find useful: [A Master Boot Record parser](https://bitbucket.org/aaronhampton/mbr/src/) [A Master File Table record parser in Python 3](https://bitbucket.org/aaronhampton/mftpy/src/) [A Master File Table record parser in Python2.7](https://bitbucket.org/aaronhampton/mftpy/src/) All three of those programs refer to File System Forensic Analysis, including page and chart numbers. From my understanding, The Master File Table holds all of the info you are looking for on NTFS, including where on the hard drive the actual data is stored, and through the MFT, you should be able to recover deleted files (my code does not do this and I have never really tried or succeeded in doing so). More info on the Master File Table can be found here: [Master File Table](http://en.wikipedia.org/wiki/Master_File_Table#Internals) **Disclaimer:** I haven't used any of this code in years and I no longer maintain it. But, I'm happy to help answer any questions you have if you PM me. 
You probably don’t mean to offend, but please do NOT use the term “Chinaman”, it is highly derogatory.
&gt; Assumptions are made. Python 3 automatically tries to encode/decode IO like CLI arguments and stdin/stdout (and it has to get an encoding from somewhere), while Python 2 leaves that up to you. The assumptions made are no different to the assumptions made in Python 2 - Py2 assumed ASCII encoding. Py3 assumes UTF-8 which is backwards-compatible with ASCII as an encoding. What _has_ changed is text data is now unicode, and unicode must be encoded/decoded when crossing into a bytes API (such as I/O boundaries). In Python 3, these demarcations are clear, in Python 2 they are unclear and also haphazardly implemented. Python 2 let lazy programmers get away with not taking the necessary encode() &amp; decode() steps, which "works" when solely dealing with ASCII text data as the implicit str == bytes assumption is mostly true, so the Python 2 documentation on unicode could be ignored and bad code runs okay, most of the time. Note its still against the documentation of Python 2, but would run without throwing exceptions. Python 3 broke the bad code by not permitting a bytes == unicode implicit mapping without specifying the encoding of the text, throwing an exception. This closed that loophole in Python 2, but of course annoyed bad programmers who now need to go fix their code and also embarrassed them by exposing the general public to their bad design/implementation. Some of them chose the rational response of fixing their code. Some chose the irrational response of railing against Python 3. &gt; The docs recommend that you pass bytes to filesystem functions on systems whose filenames are bytes (i.e. Linux), but Py 3 has already wrangled that filename passed as a command-line argument into Unicode (or choked on it)… Your text string of the filename is unicode, not bytes. Hence you need to tell open() which encoding you are using (with the 'encoding' parameter) so it can understand your filename. There's over 100 supported encodings, so its not like it can guess, but will of course assume UTF-8 if you don't tell it otherwise, which may not be correct for your text string. https://docs.python.org/3/howto/unicode.html You have to get out of the mindset that "hello.txt" is a 9-byte char array - this is exactly the bad thinking that let people mess up Python 2. 
Another vote for codecademy.com!
`os.system()` is generally not recommended. the `subprocess` module (particularly `call()`) does everything it can do and more, in a much safer way.
Regarding file type ID, I suggest you look into how the Unix utility [`file`](http://darwinsys.com/file/) works. The database of 'magics' that it uses provides information on how to identify a vast array of file types. The data used to compile the database is browsable [here](https://github.com/file/file/tree/master/magic/Magdir) -- for example here's the magic definitions for [images](https://github.com/file/file/blob/master/magic/Magdir/images). Some reference to the man page 'magic' may be required.
Ditto. LPTHW is overrated in my opinion. If you already know how to code, buy the O'Reilly book. 
&gt;and our theoretical time complexity has been brought down to O(2). Um, that's not how complexity works.
I understand Unicode and text encoding perfectly well, which is why I don't have problems with it in Python 2. The problem with Python 3 isn't that *I* don't get it, it's that Python 3 decodes/tries to decode things it shouldn't. Please stop trying to teach me bytes/Unicode (yeah, I get it) and explain how to avoid the problem I've described, i.e. how do you stop Python 3 choking on a filename passed in as an argument that is of an indeterminate encoding (Linux filenames are `bytes`, remember)? &gt; The assumptions made are no different to the assumptions made in Python 2 - Py2 assumed ASCII encoding. Py3 assumes UTF-8 which is backwards-compatible with ASCII as an encoding If that were all, it wouldn't be a problem. The problem is that Python 3 **also decodes** input into Unicode, whereas Python 2 leaves that up to you. &gt; Your text string of the filename is unicode, not bytes. And that's exactly the problem. Linux filenames are bytes, not UTF-8-encoded strings. They should not be decoded (because you have literally no way of knowing the encoding for sure), but Python 3 does. As Python 3 gets its default encoding from its environment, anything launched by `cron`/`upstart` will use ASCII, which makes your Py3 program every bit as dumb as the naïvest Py2 code, but now it's *waaay* harder to fix because it's Python that's broken, not your code. 
[Armin Ronacher's blog](http://lucumr.pocoo.org/) has some great articles on why Python 3's all-text-is-Unicode approach just doesn't jive with the way things are in the real world and he describes specific, real-world cases. They usually end up in this subreddit, too, though the discussions always play out in a very similar way, with the Py3 crowd claiming the Py2 crowd simply "doesn't get" Unicode and the Py2 crowd (including Armin) saying, yes, they understand it just fine; it's the Py3 crowd that doesn't understand that all-text-is-Unicode is a bad assumption that makes things extremely hard in the cases where it isn't. 
The part about libevent is no longer true on gevent 1.0; it now uses libev and includes libev source with the gevent source code, so now there's nothing extra required to compile and install gevent.
Man, fuck antivirus software. If you care about that shit, though, file a bug with the antivirus company.
The length of your code is quite irrelevant. What is relevant is, that I don't see that you are using any Python idioms. From what I could see is that you basically transfered your knowledge of C++ syntax to the Python program. While this of course works, it is a bit akward. Learn about iterators and how to use them, for example your first while loop can and should be written in terms of range. If you follow the pythonic way, you get better (in terms of performance and memory usage) and more concise code which is far more readable.
vote for codeacademy.com then checkio.org 
iterators are a new concept to me. What is the main reason I should use an iterator instead of a while loop in that situation?
interesting, i hadn't considered that. I'll read more python code and try to adapt to writing my code that way 
It's so expensive! 
FTR, the supervisor master at https://github.com/Supervisor/supervisor/ is Python 3 compatible.
Actually its come down, they used to ask over $300 and its currently $199 on Steam (for the full commercial use version). That's probably to remain competitive with PyCharm and similar $$$ IDE's. I've never actually used it, but everyone who has seems to swear by it, and having a first-class-citizen Python IDE on Steam is awesome IMO; being able to introduce a whole new generation to Python programming via their Steam console is an excellent opportunity. 
No, this contains an unnecessary implementation of zip. Better way would be sum(a == b for a, b in zip(user_input, answer))
Hope you don't mind if I make some comments. In general it looks good, but if I was doing a code review on it there's a few things I'd pick out. 1. [Old style classes](https://docs.python.org/2/reference/datamodel.html#new-style-and-classic-classes). You're in Python 2 (The print gives it away), so get used to inheriting from object when you declare a class. The syntax you're using invokes the old mechanisms for object creation. New style classes bring lots of features that you'll find useful as you go on (e.g. [properties](https://docs.python.org/2/library/functions.html#property)) class Map: --becomes--&gt; class Map(object): 2. You don't need to put everything in a class. Wad.split() is just a function. It's not Wad specific, and it's not even used inside the Wad class. Make it a function, although maybe with a less generic name than split(). Any time you write '@staticmethod' think 'Am I just being a habitual Java programmer?' 3. I would say Wad and Line don't need to be classes at all. Wad only has a constructor, and Line has a constructor and a repr. If you don't need object methods, you don't need a class. Wad's constructor would become a function called load_maps(wadfile) which returns the list of Maps, and Line becomes a [namedtuple](https://docs.python.org/2/library/collections.html#collections.namedtuple). Ok, namedtuple defines a new class under the hood, but it comes with a lot of freebies and is an understood convention for this type of thing. 4. "Private" methods and variables. You can't really hide anything from anyone in Python. The leading underscore on names is just a convention and nothing more. Often it's not worth worrying about. If we ever need to change the workings of the class, things like @property allow us to preserve the external view of class members in a much more flexible way than in Java or C++. Hence data hiding through private makes a lot more sense in other languages. Finally a few tiny points: * The plural of vertex is 'vertices', not 'verticies' * Read PEP-8 for naming conventions. Simple things like only using Capital for Classes, and not for variables makes things easier to read. * The white-space guidelines in PEP-8 are also worth a read (e.g. spaces around commas / operators. Lines between top level items.) * Avoid names of built-ins for variables (e.g. min and max. I normally just use minimum &amp; maximum). * Docstrings. Come on.... Python basically nicked them from Java. ;-) * I'd prefer string formatting over repeated str()+str()+str() return '('+str(self.A)+','+str(self.B)+')' return '(%d,%d)' % (self.a, self.b) * Grab a linter. I really like pylint, but some find it too finicky. Many like pyflakes. * The [pass statement](https://docs.python.org/2/reference/simple_stmts.html#the-pass-statement) is useful to stub stuff out. Otherwise, nice code, and I really like the output.
There's one major difference, notably explicitness of the code - with the g object you can automatically and transparently access it everywhere - views, context processors, functions called from views, functions called from functions called from views etc., which makes for poor readability and adds confusion as far as I'm concerned because you need to read the actual code to learn that the dependencies are there in the first place.
As opposed to what exactly? That's in no way different to any other framework. Flask, unlike other frameworks, does not hide that system from you and tells you: this is how it works, use it to your advantage. Django hides lots of state from you (think database transactions for instance). Do you read django's database layer to learn about the dependencies?
If you just want to *write* programs in Python, then `while` and `for` are fine. If you want to *learn* Python, then you must do things the Pythonic way.
We're not playing golf. This refactoring, while more verbose, is very easy to comprehend and more importantly easier to extend in the future.
To expand on the "pythonic" thing a bit, most of the idioms exist to make code look cleaner and reduce the possibility of bugs. If you use a for loop with range (or xrange if you are using python &lt; 3.0), instead of a while loop with x += 1 at the bottom, you will never accidentally forget the incrementor, so you won't create an infinite loop. You also keep the logic for the loop in the loop declaration itself, which increases readability. Good: for x in xrange(10): print x Bad: x=0 # You have to look outside the loop to understand the loop. while x &lt; 10: print x x += 1 # This is easy to forget Obviously, this are not huge issues. With a while loop, you know to look before the loop for the initializer, but if you have multiple loops that use the same incrementing variable, did you remember to reset it after the first loop? An infinite loop will be found pretty quickly, but waiting for your script to complete when you forget can be frustrating. The idioms will smooth out the development process when you get used to them. 
Thanks for the breakdown. I had while loops tossed in my code despite knowing what iterators were just because of habit, and also I figured it didn't matter too much. But if iterators are such a big deal in python then I'll definitely start learning to use them as much as I can. It'll be a good mental exercise to ask myself how I can turn while loop logic into iterator logic.
Great job on the refactoring!
I've rewritten it in a more idiomatic way [here](http://bpaste.net/show/QpOLIerjEcSH6JcZRLbz/). I've included comments explaining the changes I made (and some changes I didn't make but thought you might want to.). The most serious thing is that `y &lt; range(4)` definitely doesn't do what you think. You may have wanted `y &lt; 4` or `y in range(4)` instead. Having longer code than others is not important right now, but it will be when you get into more complex programs. Less lines of code == less potential bugs (regardless of language, of course). HTH.
Python 3's slowdown is one of the reasons the mercurial people are not porting hg.
Check out this [video]( http://youtu.be/iTT85DOwEXY) . I think it is tailored for people coming from C family of languages. It will go over examples of looping with iterators.
&gt; for i, x in enumerate(answer): &gt; # it is now x = answer[i] I've been using Python for years, and I'm just now learning of enumerate()? All this time I've been doing zip(count(), iterable), which works but needs to import itertools. You've changed my life! :D
You should have closed the file after reading, or use the ``with`` construct.
Building the whole thing in CMake is probably wise.. Easier to debug, and aimed at doing exactly this kind of thing.. Loses the nice `pip install blah`, but.. you wont spent hours trying to trace through distutils' clunky code trying to work out what is going on. Wasn't sure if I just had an unusually bad experience debugging distutil-stuff, but then I just [came across this](http://stackoverflow.com/a/21196195/745) :/
I know this is debatable, but I find these super-compounded statements unreadable. If that method was written over a few lines it would perform exactly the same and be more readable and extensible.
It's a bit old, but [Code Like a Pythonista: Idiomatic Python](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html) is always a good read. As others have said, every language has its own idioms, and when you violate them, you make experienced programmers wonder why you did that. Doing it for no particular reason just causes everybody involved (including you, when you come back to it after you are more familiar with Python) to waste cycles trying to figure out why you didn't do it the "right" way.
&gt; If you bother to read the manual page I linked, which you clearly haven't, you would know that you can pass the path as bytes to os.listdir() and it'll return bytes instead of unicode filenames. Yes, I have RTFM. If *you'd* bothered to read my post instead of just assuming I don't understand Python 3/Unicode, you'd know I'm talking about Python 3 erroneously converting filenames (which are `bytes`) passed as command line arguments into (potentially invalid) Unicode when it should just leave them alone so I can pass them as-is (as bytes) straight into `os.listdir`. If Py3 can't decode `sys.argv`, it adds a bunch of surrogate escapes, giving you a pseudo-Unicode string that can now easily enough be turned back into the original `bytes` with `os.fsencode`, but is not actually valid Unicode. So now you have to check whether or not the Unicode Py3 hands you is valid because if it isn't, your program will die in flames when you try to print/write the string unless you encode then decode it first with the 'ignore' or 'replace' method. And there are quite a few APIs that will hand you invalid, surrogate-escaped Unicode (e.g. `os.environ`, `os.listdir`, `email`, `subprocess`) and still others (WSGI/HTTP) that will give you a different flavour of fucked-up "Unicode". So instead of Python 2's `str` and `unicode`, Py3 has `bytes`, valid Unicode plus two flavours of broken Unicode to work around the parts where Unicode isn't appropriate and shouldn't have been used. 
I guess I see all these python modules able to install what seems like large C++ applications. I have a C++ application that I am using as a dependency to my python module. This C++ application uses Cmake to build and install. Is there no way to "python setup.py install" and compile this C++ application?
ORMs are there for making the developers job a bit simpler. It prevents simple mistakes leading to SQL injection but also optimizes the queries for you. Another advantage of it is that it's database agnostic, meaning you don't need to change your queries if you decide to change your database. For the majority of queries it's easier and more readable to write it using something like Pony, but if you feel something would be better wrote in SQL then you can just do that.
After a few times, you will find it much more natural than explicit loops and it should be less of an exercise. 
Then I would recommend checking out the Pycharm community edition. It is free and has the debugging features you are looking for. I wouldn't say anyone in here is wrong - there are many ways to get into coding Python and many tools out there to help you.
&gt; Simply concatenating a byte string with a Unicode string will make python 2 happily convert the byte string to a Unicode string and assume ASCII encoding for it Yes, *that* is what was fixed correctly in Python 3. Unfortunately, the developers decided to go further, automagically decoding IO, instead of leaving that to the developer. Worse, Python 3 makes bad assumptions while doing that (e.g. using the locale to determine how to decode/encode data that might have been piped). If the developer is doing things right in Python 2 (manually encoding/decoding at the right points), Python 2 is the superior language because is doesn't assume *anything*. What I really want is Python without implicit unicode-str conversions, but also without Python guessing what it should do on input/output. Unfortunately, that's not a combination that exists.
Something like that is reasonable (though for little benefit unless the argument is used infrequently, since you'll get an error when you try to use it anyway). Most of the distaste for type-checking comes from using `isinstance()` to check for a *specific* type, because that excludes passing types which implement the required interface without inheriting from that type (i.e. duck-typing).
range and xrange both work in python 2.x. The latter is a generator.
So since it'll raise an exception anyway, there is little benefit to doing it yourself?
Pretty much. It could be useful if the error will be mis-caught or be confusing to the caller of the function, or only actually manifest itself in a rare but important situation, but most of the time this is not the case
Print is still not something that is slowing down porting at all. It's honestly not worth complaining about.
Hmm yeah that makes a lot of sense to me.
There is benefit if the exception you raise is more useful than the one that would be raised otherwise. For example, if you can tell the caller that things go wrong because the `fn` argument is supposed to be callable, then that's more useful than bailing with a generic exception that tells the user that something somewhere inside `walk_dataset` tried to call something as a function that is something else.
The alternative is dealing with those warts that built up. This is a necessary evil! 
Rule of thumb, always use a for loop unless a while loop is better. 
sys.argv members are strings (not bytes, as you incorrectly assert), this is documented. Strings, in Python 3, are represented in Unicode - this too is documented. So to say Python behaving as documented is "erroneous" is certainly pointing out an error - only its not in Python. If you are not correctly specifying your data's encoding then you really do need to go back and read Python's unicode documentation, and cease stating you understand Python's unicode handling when you don't. WSGI has its own problems, stemming from the fact bytes didn't exist in Python when the spec was written, so you need to do an encoding dance. Resolution is the same for surrogateescapes, which is the encoding error handling routine. Or, of course, do what you do and blindly ignore errors then blame Python. /u/mitsuhiko has a (hopefully) useful guide for you over here: http://lucumr.pocoo.org/2013/7/2/the-updated-guide-to-unicode/ 
&gt; sys.argv members are strings (not bytes, as you incorrectly assert), this is documented. Strings, in Python 3, are represented in Unicode - this too is documented. That's what the original poster said. The strings in `sys.argv` are not normal strings, they contained bytes as surrogate escapes. The only sane way to deal with them is to encode them through the surrogate error handler back into bytes. I gave up handling this in Python 3 however. Click for instance just fails on Python 3 for legitimate bytes in the arguments.
Python 3 is the playground of the cpython developers which seem incredibly disconnected from the real world by now. A lot of the APIs on Python 3 are just bizarre and badly reviewed or completely miss real world solutions for the same problems that people made before. This goes well beyond the bytes and unicode issue even though that will continue to be a huge problem until someone replaces Python 3 as some of the bad decisions in it's design are now so engraved in the API that they will never go away.
I've made projects with that level of complexity, no big problems. Stuff like select(a for a in A if a.b.c.d == 'hello') is nice, Pony will do all the joins needed on the database.
In the time it took to write that article he could have ported a hundreds of lines of python 2 to python 3. If people spent as much time upgrading as they spent time complaining about having to upgrade we would have made a lot of progress. Is creating a third version of python that is worse than the current one but can use old libraries a good way or is working on moving forward and developing the newest versions of our language the best way.
Good read. Thank you. 
...except ignore the "no hard tabs" part ;)
Your C++ feelings about while are totally wrong if you bring them to Python. There is no optimizing compiler, and types are runtime types, so every time you encounter this in the loop: `i += 1` The interpreter will look up the local `i`, lookup its method called `__iadd__`, and then call it.. Every iteration.
amen 
*chuckle*
Importlib for me is a prime example of a project that lost all direction. It's driven by one or two people and they are developing it without any real world experience with it. I pretty much gave up supporting any of that stuff because with every Python 3 version it changed in new ways and at this point it has lost all portability for me as I need to support from 2.x to 3.4. Another good example is the general stream interface. While you could argue that the streams are byte/unicode problems they in themselves are an API problem more than a unicode problem. I waste enormous amounts of time trying to make streams work well but the new API is just inherently more complex than before for very little benefit. For the user the new streams are definitely more complicated than the old ones. While not Python 3 related, but there is a whole new packaging infrastructure project going on in distlib which is used by nobody (with the exception of pip which uses the semantic version parsing of it) besides the original creator and maybe a handful of other people. asyncio thankfully had Glyph overseeing it, but even with asyncio there are not enough users for the library to go into the interpreter. We're already at the point where there is going to be an updated version uploaded to PyPI which raises the question why it's built-in in 3.4 in the first place, if it's going to change in 3.5 again. This iterative development worked in Python 2 because of two reasons: a) stdlib packages came from outside the stdlib and were iterated there and b) they were developed out of a specific need and people used it. I don't see this happening for anything in Python 3.
Thanks for letting me know. Just checked, it compatible :)
This syntax is similar to C#'s LINQ. One of the awesome things about LINQ is that the syntax works on regular objects *and* databases. For example, select(c for c in Customer if sum(c.orders.price) &gt; 1000) works if `Customer` is a PonyORM db object, a regular list, or some other iterable. Python can't quite use the same syntax for both (AFAIK), but the generator itself does for regular iterables what the generator + select method does for SQL databases.
&gt; I am not using Python 3. All my Python 3 experience is coming from porting libraries for a barely existing user base. I'm pretty sure that's quite enough :)
I have zero interest in investing more time into Python 3. I do not believe Python 3 is something that can be repaired in a way to surpass Python 2 in enjoyability for me.
I'm surprised you bother with Python 3 at all. It's basically dead at the moment and so many other important contributors have simply moved on to other languages. 
Everybody does work across an IO boundary. Python 3 had the idea to hide the boundary from you but that trick did not work, now they added escape hatches in through surrogate escapes and other things and made everything worse in the process. Most people just produce broken code in Python 3 now because if you don't touch it too much, it seems to work. Just getting command line arguments is boundary code.
 vals = {} for k,v in vals.iteritems(): # this is pretty great, too. 
I may have agreed with this a year or two ago. Not now though. The situation is way better than it used to be, and only improving. Developing a new module to run on both Python 2 and Python 3 is also much less of a pain than it used to be. Particularly if you follow the advice on (http://lucumr.pocoo.org/2013/5/21/porting-to-python-3-redux/). It does make your code less beautiful than a pure Python 3 code base, but that is the price you pay for compatibility. My biggest porting headache was adding Python 3 support to PyFilesystem. It was tricky because this library is an abstraction layer for files, which work quite differently in Python 3, and we didn't want to have to write everything from scratch. I have ported another, much larger project, in a day. It was tedious work, but no major issues. But these problems only effect library developers. If you're building an application, just use Python 3. Most libraries have Python 3 support, and most of the ones that don't are probably not actively maintained any more.
If you're building a *new* application...
Check out the forensics chapter of Violent Python, you should find what you need for your course.
&gt; return [random.choice(selection) for i in range(5)] return random.sample(selection, 5) Guarantees no repeats.
Then why does Python support those features?
If it's an app you *probably* aren't concerned about it running on both Python 2 and Python 3.
This makes sense. What I like about your code is how clean and simple the abstractions are. You weren't trying to be too clever, but you organized it in a very forward way. It's been my observation that only relative novices and rather experienced programmers tend towards this straightforwardness.
If people would stop committing crimes, we could save a lot of money on police. 
It's an OS issue. CLI arguments and file names are always UTF-16 text on Windows and some unregulated binary stuff on UNIX that may or may not be some text in a system-wide locale that may have been changed by another application through `setlocale`. Naturally, choosing one approach somewhat breaks the other.
No, it doesn't matter, and don't be misled into believing that it does. As long as the code that _you_ write does the job that _you_ want it to do, then it's fine. Python has a strong culture of "only one right way to do it", and you'll get told like you're getting told here that if you don't do it the right way, then you're wrong. The fact is, Python supports for and while loops, and if it is so wrong to use them, then they should be removed from the language altogether. Otherwise, people should leave others to make their own decisions on syntax. Let me expand on this a bit... you speak English, and you understand the difference between saying "can not" and "can't" and "do not" and "don't", etc. You understand that they mean the same thing, and can be used interchangeably, and you may prefer one construct over the other, but you would not / wouldn't tell somebody that using one or the other was "speaking like other language", or not using English correctly. You wouldn't even tell people that they weren't using idiomatic English... you would simply let them use the words that they prefer to use, because that's their choice. So it is with python syntax... use what you prefer to use.
How is that related to Python at all? I mean, you're opening a text file without explicitly specifying an encoding. The only reason you *think* it "works" on 2 is because it doesn't actually open files in text mode. (In fact, is that even possible without using the backported `io` module or writing a custom wrapper?)
No. That's because POSIX demands that the locale is set to C and that implies ASCII. However the locale only controls messages, it should not define anything about filesystem encodings. I wrote about this recently: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/
I understand why this is painful for library writers. But if you're just writing an app, why would it matter if you froze on a particular version? 2.7 being out of development and under maintenance seems ideal. 
I assume you have no idea what you are talking about. &gt; I mean, you're opening a text file without explicitly specifying an encoding. The only reason you think it "works" on 2 is because it doesn't actually open files in text mode. (In fact, is that even possible without using the backported io module or writing a custom wrapper?) If you open a file in text mode in Python 2 you open it to return bytes. If you open a file in text mode in Python 3 the interpreter will ask the environment what the encoding is. Which it turns out, is a pretty terrible idea. You should be explicit. Unfortunately there are cases now in Python 3 where you *cannot be explicit* because the interpreter already "solved" the problem for you. Incorrectly.
Definitely not on Python 2. I use Python 2 on a daily basis and I continue writing new stuff for it.
You should in general at least use itertools.izip() instead of zip (unless you have other reasons for doing so). Zip produces a full list of the results while izip produces an iterator so if you have long lists that you are operating over it is more efficient.
&gt;If you open a file in text mode in Python 2 you open it to return bytes. That makes no sense. If it returns bytes, then it's in binary mode. If it were in text mode, it'd return `unicode` objects. (And please don't say that the difference between "text" and "binary" is solely whether the CRLF-to-LF conversion is enabled or not.) &gt;Unfortunately there are cases now in Python 3 where you cannot be explicit `open` has a keyword argument `encoding`. You can always be explicit.
Sometimes they can be useful, and as you just saw, they can facilitate someone who learned another language to use Python since while and for loops are fairly universal
Perhaps it is time for us -- the community -- to bypass and route around you, then, as sad as that would be.
&gt; That makes no sense. That does not change that this is how the default API in Python 2 works. It's by far not the only API to open files in 2.x. That however was not the point. &gt; open has a keyword argument encoding. You can always be explicit. a) people are not. b) not every api supports that. Case in point: filenames, environment variables and argv.
If you believe that is going to help the adoption of Python 3 … I have my doubts. Sure, you can just categorically declare that my opinion is not worth anything if that makes you happier.
I personally never use python 3 in production environments. But it would be sad if we all stuck with python 2 for foreseeable future. I guess I should start getting into python 3 now.
I was simply trying to illustrate the method. Also, I've been using python 3 quite a lot recently, in which zip is always the iterated version.
Most notably, `while` allows for infinite loops or loops where it is not known in advance when the condition will be met. When iterating over all element in a {set, list, tuple, Iterable object....} however `for` is better. A major issue with python and `while` is that assignments are not allowed in the `while` condition which renders a lot of idiomatic C/C++ code more verbose then needed.
There will always be more than one way to do things in any programming language, but that doesn't mean they're all the *best* way.
It's not like there are alternatives. Don't even mention Golang - it's a piece of dried up crap with arbitrary limitations (error handling from the 90ties, no ability to implement datastructures with native api, no operator overloading). Might as well use Pascal ... It seems to me that just few bratty library developers (shamed by their users into fixing their shit to support Python 3) are the main detractors. Now start downvoting ... cause we all love Armin and his unconstructive bitching.
I use a dynamically created module often (pyVmomi) and would love to see this kind of issue resolved. 
In your code, you have the following construct at the end: while y &lt; range(4) .... This doesn't do what you want.... &gt;&gt;&gt; y = 100000000000 &gt;&gt;&gt; y &lt; range(4) True `range(4)` returns a list (in python 2) and a list is "greater" then an integer: &gt;&gt;&gt; range(4) [0, 1, 2, 3] &gt;&gt;&gt; y &lt; [] True Finally, you want to use `xrange` in python 2.x since it returns an iterable which doesn't require a full list of all possible values to be built in memory: &gt;&gt;&gt; range(10000000000000000) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; MemoryError &gt;&gt;&gt; xrange(10000000000000000) xrange(10000000000000000) EDIT: In Python 3.x, `range()` is basically `xrange()` from Python 2.x since they could break backwards compatibility.
For what it's worth, distlib is just an external library and isn't going to get added to the stdlib any time soon (if at all).
http://xkcd.com/927/
[Image](http://imgs.xkcd.com/comics/standards.png) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 488 time(s), representing 2.2974% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
I assume most of your code writing is a solo endeavor? 
If `en_EN.UTF-8` is not installed on the system, then it falls back to the `C` locale so it goes back to ASCII.
You're welcome. Also LPTHW is [freely available](http://learnpythonthehardway.org/book/) online if you're strapped for cash. 
Armin is far from alone in this feeling. All my libraries support Python3, I even port random other third party stuff to Python3. But that's only because I don't know any other concrete action to end this drain on our community, if I knew how to stop this long community nightmare some other (e.g. ending the Python3 experiment), I would do that.
So write your code to be compatible with 2 and 3. In most cases, this is very easy, and the right way to go. Many open source projects do it that way (mine included). Also, if maintaining a Py3 version *doubles* your work, you are doing it wrong. Running your tests in a different interpreter should in no way *double* your work.
by the way, one neat trick to understanding python idioms is to write an extension in C or C++ without using a code generator (cython, pyrex, swig, etc). you'll look at all of the methods that get exposed and how they work (like next()) and that will very quickly translate into understanding python in general. or rather it did for me. here's some docs - [extending python 2](https://docs.python.org/2/extending/extending.html) or [extending python 3](https://docs.python.org/3/extending/extending.html) - to get you started. that said once you do it by hand, i suggest using a code generator for future ones - much faster and easier to maintain. 
Guess I'm doing it wrong then.
Dead languages are less fun to work with, and you don't get access to new language features or any new libraries that are Python 3 only. Applications live on.
Some of the things that are cheap to do in C/C++ actually carry a lot of computational overhead in Python.
It took a lot of time and gentle urging to even get him to that point. Maybe you're right and I should just quit while I'm ahead.
Thanks, the jump from 2.x to 3.x usually breaks my code and I just stick to 2.x unless the project requires otherwise
Make friends with [six](https://pythonhosted.org/six/). It works wonders. 
I used to hand edit Wolf3D textures in XTree Gold's hex viewer (the images were stored in [PBM](http://en.wikipedia.org/wiki/Netpbm_format) format so you could actually see them in ASCII. Seeing the level SVG code work for the first time was the fulfillment of something I've dreamed of doing for years but always assumed was beyond me.
this article is bad and misleading. &gt; Python 3 has some tiny, incremental improvements over Python 2 wrong, it now has multiple hugely useful stdlib libraries that aren’t in python 2 (enums, asyncio, multiple dispatch, …), many performance improvements, better internal string representation minimizing memory footprint, has fixed the broken string handling of python 2 that permitted many errors to propagate unnoticed. &gt; Yes, a lot of libraries have been ported, but ten times as many have not [citation needed]. i highly doubt this. e.g. [the wall of superpowers](http://python3wos.appspot.com/) and PyPI indicate this is no longer true: * [4281 python 2 packages](https://pypi.python.org/pypi?:action=browse&amp;c=527) * [4801 python 3 packages](https://pypi.python.org/pypi?:action=browse&amp;c=533) &gt; [Writing Python 3 applications] is obviously not popular, because if it was, we’d have a lot of Python 3 apps in production, and much of the long tail of Python 2 libraries would be ported. Neither of those things is true. People either continue to write software in Python 2 or they pick another language that did not shoot itself in the face. false: people *do* write python 3 applications, and don’t port their python 2 ones, because they are applications, not libraries, and don’t need porting to be useful for everyone. &gt; You might as well ask someone to port their entire codebase to Ruby. Except, that would be cheaper. Now, if you are going to have to rewrite your software either way, would you choose Python 3? No. the author totally pulled that out of his ass: why the fuck would it be cheaper? also ruby is less popular than python outside of webdev, therefore has less libraries than python, so that perceived problem of the author would be even bigger. &gt; simpler FFI like [CFFI](https://cffi.readthedocs.org/en/release-0.8/) (which is supported on python 2 and 3)? &gt; One solution is to fork Python 2.7 then fucking do it instead of being the 300th person suggesting it. do it, and have fun being ignored. or maybe not, who knows? &gt; reviving Python 2 is so obviously the correct thing to do no, the obvious solution is of course to stop whining, roll up your sleeves and port shit. i’d do it if i’d have ever perveived that problem, but mysteriously i don’t miss any libraries on python 3. &gt; The community will, by that time, have shrunk dramatically, and lost its former glory. See: Perl perl 6 is a community driven project alongside the continued, centralized development of perl 5. the developers of python 2 have stopped developing it years ago and moved on to python 3. totally different situation. --- bottom line: what did that guy smoke to get to those totally unrealistic conclusions?
The business case here is that languages which cannot keep b/w compatibility at reasonable level should not be used for any future projects... Existing projects are either to be mothballed or rewritten in another language.. Welcome to the real world. 
Because it's too slow :)
If there is any implementation of the python standard that supports 2.x and in addition could add 3.x features producing a python 2.8, it would by PyPy, perhaps more efforts should go towards supporting them.
jup. bilangual python is less fun than python 3, but less work than maintaining two forks.
Py3 has a number of warts of it's own.
&gt; if you want to make something quack, then check if it can quack, not if it is a duck. Mind if I use this for a Python class I'm teaching?
true! you totally may go nuts with asyncio, enums, pathlib, and all the goodies!
&gt; Most notably, ``while`` allows for infinite loops or loops where it is not known in advance when the condition will be met. So would ``for i in itertools.count():``. There are always while and for equivalents of the same loop. 
&gt; That's a pretty pointless argument for a variety of reasons. The biggest one is that there is no reason to upgrade because Python 3 does not have a business benefit for lots of people. &gt; I would argue that if those people (lots? who are they?) don't have a business reason to upgrade to Python 3, they don't have a business reason to complain about it, either.
&gt; Look at that syntax and how visually appealing and easy to write it is. This is only a persuasive argument to people who spend most of their programming time writing new code. For me, it's a pretty big *DANGER* sign.
Only if you don't care if they pass. :)
While you're at it, you could replace commas with ',\\\n' - that'd certainly make eyes bleed. Or add arbitrary whitespace after the \n in the above to be even more evil :D
The problem is that it violates a principle of object oriented programming (as understood by smalltalk, not c++), the "tell, don't ask." If you write code like this one: def a_func(x): if isinstance(x, Blah): x.do_blah() elif isinstance(x, Foo): x.do_foo() elif isinstance(x, Bar): x.do_bar() Then you have a problem. Whenever you want to extend a-func functionality to receive a new class, you have to modify that function (and probably many others with the same circumstances). Instead, the function shouldn't be worried about the type of argument it receives, it must simply delegate the work to them: def a_func(x): x.do_your_thing() So, you don't care about the type, you care about the functionality arguments must provide. Of course, in the above case, you must be able to add do_your_thing to Blah, Foo, Bar and any other class a_func could receive. In smalltalk, that is always possible. In python, it could require monkey patching, which is not seem as a good practice for all programmers.
Find a problem you face and solve it with the language you're learning. Following uninteresting or impersonal project examples is going to leave you bored and unfocused.
&gt; I'll be honest, I'm not a fluent python programmer (I've worked with other people's code and hacked some small things together, but my strengths are in other languages). Currently the discussions about 2 vs 3 are scaring me away from investing time into actually learning the language in depth. This is my decision as well. Although I have a ton of python experience and have used it on and off since 2.2. Luckily most of my work lies in the web development space so there's no problem finding alternatives and python 2.7 is still great.
How did you reach for that conclusion? A stable language is extremely refreshing to me. This also had the side effect of letting PyPy catch up. You wouldn't say that C or Common Lisp are dead, would you?
Your co-worker is being extremely reasonable and it's very obvious that he's a much more experienced python programmers than you are. The only real benefit of porting to Python 3 is if 2.7 is abandoned and stops getting bug fixes security updates (good luck on that happening in your life time. 2020 will soon enough turn into 2025). The only reason for writing Python 3 compatible code is to hedge your bets against exactly that scenario.
My solution has been video games. I've written, or rewritten, three different games and they've improved my abilities every time.
Go ahead, be my guest. Not that I'm a huge fan of duck typing myself, mind you, but it's the Python way.
I agree almost all libraries are developing support for python 3. It is true that you will have some problems with old scripts where there are xrange, parenthesis for exceptions and print, and urllib2 is all over the place. If you start new I would do python 3. If you are converting it is kind of a hassle that might take about a day or more to fix all the differences.
Still waiting for OpenCV to support python 3x :(
For me the best place to learn python is Stackoverflow. I look up what I want to do and not learn extra things. Just browse around the discussions.
I liked the way you rewrote it. But are you saying that it would be better to have a bunch of presorted lists rather than the way you wrote it? Wouldn't that be more inefficient?
Compiled maps were in [.BSP](http://en.wikipedia.org/wiki/BSP_%28file_format%29), I think maps for editing for [.MAP](https://developer.valvesoftware.com/wiki/MAP_file_format)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**BSP (file format)**](https://en.wikipedia.org/wiki/BSP%20%28file%20format%29): [](#sfw) --- &gt;__.BSP__ is a map [file extension](https://en.wikipedia.org/wiki/File_extension) used in games such as the *[Quake series](https://en.wikipedia.org/wiki/Quake_(series\))*, and games that use the Source engine, such as the [*Half-Life* series](https://en.wikipedia.org/wiki/Half-Life_(series\)) and the [Portal series](https://en.wikipedia.org/wiki/Portal_(series\)). .BSP files use [binary space partitioning](https://en.wikipedia.org/wiki/Binary_space_partitioning) to generate levels that can be rendered quickly while minimizing the number of polygons that need to be redrawn every time the screen refreshes. One of the biggest problems with the .BSP [file format](https://en.wikipedia.org/wiki/File_format) is that large open areas do not work well due to the nature of the partitioning algorithm used. &gt; --- ^Interesting: [^Binary ^space ^partitioning](https://en.wikipedia.org/wiki/Binary_space_partitioning) ^| [^List ^of ^file ^formats](https://en.wikipedia.org/wiki/List_of_file_formats) ^| [^Source ^SDK](https://en.wikipedia.org/wiki/Source_SDK) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chrmhlr) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chrmhlr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
examples?
This doesn't discredit your comment in any way, but I usually check for the existence of methods so that I can give a better error message to the user. It also allows me to back out of the current method but not kill the program, if that is desired. That being said, I only do this when I writing something with an external API.
As an aside: I'm not sure why Golang is getting the hate here. Sounds like you've never needed to write systems software. Golang is *great* for that. It's not shorter; but not much longer, either. It does a number of things very, very right. I suspect just nothing that you have ever needed to do, though. Complaining Go doesn't have operator overloading is like complaining Python doesn't have type annotations--it isn't written for a use case where they're particularly useful.
go isn't a drop-in replacement for python, but its a well designed, easy-to-read statically typed language with good well-written libraries. It serves a different purpose. (Granted obviously python has many more libraries having a 10+ year head start). Go misses some nice features (e.g., generics, operator overloading), but granted go was publicly released ~3 years ago -- give it time (python 2.0 didn't have bools, sets, new-style (`object` derived) classes, decorators, generators and iterators, `with` statement, nested scopes (beyond two nestings), automatic casting of 32-bit int to arbitrary sized int, etc). Once you get used to it, I really like the panic / recover and explicitness checking for errors. It's a different mindset, but actually works really nice. Not sure what your "no ability to implement data-structures". Are you talking about how `make` only works on `slice`, `map`, `chan`? This isn't really a limitation, you can easily build on top of those structures; e.g., [create a set out of map (go's equivalent to a dict) with values that are zero-byte struct](https://github.com/fatih/set). Yes, python has an underlying C API that you are encouraged to use as python2 would otherwise be unusably slow. As go doesn't have that huge speed difference it would be a bad idea to encourage writing things in a C API on top of go. Granted there still is the `cgo` if you need to call C library/function from within go, and IMO it is much easier to deal with than python C API (by nature of go being statically typed).
Python 3.4 ships with pip more or less.
The new Unicode issues in Python 3 are a non-starter for my work - if there was a definitive guide to sorting those issues out I'd seriously consider it, but judging from the low quality answers to Armin Ronacher's posts about Unicode in Python 3, it won't be any time soon. That being said, this article is hilariously unproductive. The idea of forking Python 2 and just "taking Python 3 out back" makes no sense at all... smoothing the transition from 2 to 3, or adding killer features to 3 is the way to go. We could do with less articles like this.
the community is divided on this matter and I challenge you to get more support with this arrogance. most people that support Py3 do it because they were told that it was for the best by the people who are supposed to know best, so far it's been a great disappointment. maybe it's time the community routes around *you* instead, like the article suggests.
Stuff like this makes me wish that we had an easy way to declare interfaces, and what objects implement them.
I agree: we use Python3 for new applications all the time. We never have any complaints and everyone is happy with the features of Python3. The tone of this article is histrionic enough to be dismissed, not to mention that examples are missing for claims such as the following: "A lot of libraries have been ported, but ten times as many have not, and are not trivial to port."
Most people have already commented with plenty of help, but I myself found that a few things only "clicked" after having watched a few pycon videos. [There was a thread a while ago about "must watch" videos](http://www.reddit.com/r/Python/comments/1rs7ub/what_are_some_mustwatch_python_videos/) that I highly recommend. Especially "[Idiomatic python](http://pyvideo.org/video/1780/transforming-code-into-beautiful-idiomatic-pytho)" and "[Iterators and Generators](http://pyvideo.org/video/1758/loop-like-a-native-while-for-iterators-genera)" considering your C++ background.
I guess so.
I use python3 for (almost) all new projects at work. We usually write django apps with a REST API for a javascript (angular) frontend.
that's my ignorance then, I believe i used 3.2 or 3.1 and didn't even know about pip at the time. for me it was manually downloading the files and placing them in site-packages, much ignorance back then :/
Yeah, let us all create an entire new branch in the tree just because people are lazy and don't want to migrate. It can’t do any harm, right COBOL?
Why?
The most important part isn't "to be pythonic", it's actually that the python way is better. You're less likely to: - iterate incorrectly over a structure (for example, in C++ you can use != or &lt; interchangeably on std::vector, but not on any other type. != is always the correct choice to use, but &lt; "works" properly). - walk off the end of the container you are iterating, for example via an off-by-one bug. By giving you the element that you should be looking for at this stage of the container walk, we've avoided a potential addressing bug. - They also show that you should not be modifying the container under iteration. This is a common source of bugs in C++, where people don't correctly deal with iterator rules and restrictions (when they become invalid) while walking through the structure. Ultimately, a lot of python idioms are idioms because they are the correct way to write the code to begin with (as in: the way you would likely write the code if you were just writing pseudo-code on a whiteboard or in a notebook). You would not write: for (std::map&lt;std::pair&lt;std::string, int&gt;, std::list&lt;std::map&lt;int, float&gt; &gt;::iterator it = foo.begin(); it != foo.end(); ++it) { // stuff } on a whiteboard. You would write one of the two following: foreach (it in foo) { // stuff } or just: for it in foo: # stuff I've found after writing a lot of python that python has informed the way I write C and C++ code--python idioms to enhance readability of code have crossed back as much as is possible.
I usually develop in 2.7 targeting 2.6-3.4 (with lots of testing in test suites), seems easier to make allowances for going forward than it is to write code 'in' python 3 targeting python 2.
Fun projects I like to do is network stuff write a simple echo server, then try pulling down some json and parsing it out. maybe try writing a multithreaded echo server. another fun exercise is to learn to use a 3rd party library if your looking for network related projects learn requests. I agree that finding a problem and then working on a solution is a good idea, but sometimes the problems you face everyday are already solved and while most people will say "Don`t re-invent the wheel" you goal should be to "Re-invent the wheel, re-design the wheel, break the wheel and build the wheel" you may get alot of inspiration from browsing the python stdlibs, i had an idea to write a Zip Filesystem browser in python just after reading the gzip library docs.
http://i.imgur.com/C4Oao7G.png
But even then, you shouldn't check first, but catch the inner exception and raise your own, more semantically appropriate one in the catch block. The problem with that is error clarity: If the exception isn't caught, the stacktrace will say that "During the handling of exception A, exception B occurred". In Python 3, this can be avoided using a raise-from construct. If the inner exception is relevant to the user (such as a network error preventing an operation), pass it to the `from`, if it's not (such as a `TypeError` raised within a module), use `from None`.
poor equality/value semantics, incoherent concurrency story, poor module system, overcomplicated object model, actively harmful stdlib (`pickle`, `asyncore`, `xml.dom.minidom`, etc)
Try implementing something that you will actually use. Start small and work your way onto harder projects. 
See my reply to Alex's comment. Even if I shared your opinion of Python 3, I would still think that the time to be constantly turning out hit pieces on it is long past.
I agree with this as well I used to be a 4chan guy and i wrote "many" image thread downloaders because downthemall was a Firefox only extension and at the time I was jumping between chrome, firefox and opera for web dev purposes. eventually I just decided I needed something that would work outside the browser and starting playing with beautifulsoup (before 4chan released its api) and I use it just about everytime i find a good thread (not so much these days, that place is...well you know) https://github.com/lethemfindus/4chandl/blob/master/4chandl.py if anyone is interested in it, its pretty small and one of my most used projects, imo a good example of solving a problem.
This article is total bullshit. Seriously this article is INCREDIBLY naive. We needed Python 3 to not be backwards compatibility because Python 2 was suffocating the core devs. There were serious innate problems in the language that made it impossible to make the real important changes we need. And third party lib support? Python 3 has everything except the libraries that need bytestrings and with python 3.5 we have the support we need for them to move forward as well so that argument is ENTIRELY bogus. DO NOT upvote this article. It's written by someone who doesn't understand the situation, who doesn't care to understand it, and is just whining about some extra sys-admin stuff they have to do as a result of a change that will ultimately make python a much better language than ever before. There were arguments against Python 3 in the past but seriously learn to read the PEPs. All the real issues are being addressed and all the crap this article mentioned were arguments from 2-3 years ago. Get up to date, educate yourself on what's going on in the language now-a-days. Python 3 has become a hundred times better than Python 2 ever was. Things like async-io, bytes % formatting, etc are moving us forward in the language not back. Python 2 is no longer a modern language and while there's nothing wrong with using it for the next couple years to ease migration efforts IT IS A DEAD LANGUAGE. There are no longer any arguments supporting it, and the community has moved on. You should too. 
I'm not very creative or good with games or graphics but I was given the task to make a game in PyGame so I made Snake. I'd appreciate if you guys could show me some improvements I can make in code or just any tips or techniques. Thanks in advance! https://github.com/robottom/Snake-Revamped
I think one of the few instances were isinstance is appropriate is checking for strings to distinguish them from other sequence types.
It's not hard to understand why these things were done that way: idealism and lack of practical experience. I don't know if you ever looked at Python 3.0 but it was a ridiculously broken language and it took three more releases to get it to annacceptable level. Python 3 is better now than it was before but i would still not trust it to run my stuff as well as 2.x did. Especially because pypy compatibility is more important for me than the nonlocal keyword. I'm not saying killing 3.x is the only solution but i hope you agree that the roof is on fire. We're all spending lots of time and effort to keep our libraries compatible with python 3 but there are barely any users. What's worse is that Python 3 has lots of new Python users whereas lots of experienced are in the 2.x campt which causes friction. What do you want me to do? Close my eyes and lie to myself that everything is going to be okay? Lots of people did that and that did not help.
Surrogate escapes are a terrible wart. Way worse than bytes vs unicode in python 2. There is still no good way to deal with surrogate escapes as far as i know.
How about providing the name of the company or website so we can have a chance of judging how meaningful your use of Python3 is. So far I have only come across a few small startups and a few individuals using Python 3 in production and in all cases they were very trivial apps to build and most had none to just a couple of dependencies on 3rd party libraries.
No, but `variable += 1 if condition else -1` would.
https://docs.python.org/2/library/dis.html https://docs.python.org/2/howto/functional.html#iterators https://docs.python.org/2/tutorial/classes.html#iterators
Ah. I assumed it would need `variable - 1` since it's techically `variable = variable + 1 if condition else variable - 1`
&gt; sys.argv members are strings (not bytes, as you incorrectly assert) Yeah, `sys.argv` members are Unicode strings. That's the problem: they shouldn't be because Linux passed Python bytes, not text. Documenting dumbass behaviour doesn't make it okay or correct (see PHP/JavaScript/MySQL). &gt; If you are not correctly specifying your data's encoding then you really do need to go back and read Python's unicode documentation, and cease stating you understand Python's unicode handling when you don't. And your evidence that I don't get Unicode, in the face of my explaining how to coerce it back to bytes and deal with the broken Unicode that Py3 often provides, is what exactly? Blithe, baseless assertions? &gt; Resolution is the same for surrogateescapes, which is the encoding error handling routine. Or, of course, do what you do and blindly ignore errors then blame Python. It seems you're willfully ignoring what I've written. I *know* what the "error handling routine" is. I *know* what Python 3 does when it can't decode input. I explained both pretty clearly in the previous post. &gt; WSGI has its own problems, stemming from the fact bytes didn't exist in Python when the spec was written So why does Python 3 pretend it's Unicode? It isn't! Best of all, you point me to an article (which I read long ago—I actually took the examples from that article) that shits all over Python 3's handling of Unicode and yet you use it as a basis to claim that it's somehow still all good and I'm totally wrong, despite the article making *exactly* the points I've been trying to make in the face of your bull-headed refusal to hear them. Armin himself (the author) has even jumped in and backed me up. Read my fucking posts, dude. Address the points I make, instead of baselessly continuing to accuse me of not getting it. I get it. Apparently better than you because I'm actually addressing the points you make with valid counterpoints rather than treating you like some fuckwit who simply hasn't read the docs. 
Are you honestly saying there are not alternatives to python? Also just because you don't like Go doesn't mean that 'it's a piece of dried up crap'. I am writing Go at work and loving it, but I am doing my side project in python. They are different tools, one of which is made for writing extremely reliable fast servers and one is really fun to write.
https://en.wikipedia.org/wiki/Duck_typing
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duck typing**](https://en.wikipedia.org/wiki/Duck%20typing): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) with [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) [programming languages](https://en.wikipedia.org/wiki/Programming_language), __duck typing__ is a style of [typing](https://en.wikipedia.org/wiki/Type_system) in which an object's *[methods](https://en.wikipedia.org/wiki/Method_(computer_programming\)) and properties* determine the valid semantics, rather than its [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming\)) from a particular class or implementation of an explicit interface. The name of the concept refers to the [duck test](https://en.wikipedia.org/wiki/Duck_test), attributed to [James Whitcomb Riley](https://en.wikipedia.org/wiki/James_Whitcomb_Riley) (see history below), which may be phrased as follows: &gt;&gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. &gt;In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. For example, in a non-duck-typed language, one would create a function that requires that the object passed into it be of type Duck, in order to ensure that that function can then use the object's walk and quack methods. In a duck-typed language, the function would take an object of any type and simply call its walk and quack methods, producing a run-time error if they are not defined. Instead of specifying types formally, duck typing practices rely on documentation, clear code, and testing to ensure correct use. &gt; --- ^Interesting: [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Groovy ^\(programming ^language)](https://en.wikipedia.org/wiki/Groovy_\(programming_language\)) ^| [^Alex ^Martelli](https://en.wikipedia.org/wiki/Alex_Martelli) ^| [^Python ^\(programming ^language)](https://en.wikipedia.org/wiki/Python_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chrohne) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chrohne)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
well that's true, but I was referring to your average starting out programmer who just wants to bang out some code from an example article/blog and see "hello world" show up. he will more then likely if not guided by someone choose the latest.
Buying an IDE in steam sounds dangerous.... I'd never get any work done.
Where are you going with this? Am I supposed to read this as people using py3 don't do meaningful things?
No it's variable = variable + (1 if condition else -1) `x if conditions else y` is an expression on its own and can be used without an assignment, for example as an index: a[1 if condition else 2]
you don't have to make your python code look like haskell but please don't try to write python code entirely relying on your C/C++ habits be pythonic, it's the golden mean when in doubt, fire a python prompt, type "import this" and see if your code fits into those rules. that's the best lightweight lint :)
More like variable = variable + (whatever was on the right hand side of +=) i.e. variable = variable + (1 if cond else -1) If your version was how it worked, then you would be able to write things that are completely nonsensical. For example, if `x += 1 if cond else y` sometimes meant `x = x + 1` and other times meant `x = y` then you would sometimes be performing addition and other times performing simple assignment. But `+=` means that you're always doing addition, regardless of what's on the right hand side, so this is contradictory. Hence, it doesn't work like that. 
scratch a personal itch write a solution for a real problem that bothers you i have found that a good approach is to find software that i consider useful but is written in a language i don't know, hence i can't hack sometimes i attempt to write a clone in python if i can't find one already written by someone else. most times i fail, the main reason being that i'm so lazy, but when it works, it feels good and i get a tiny useful tool for personal use
Excellent, thanks.
Interfaces in dynamic languages like Python and Ruby are simply implicit instead of explicit.
You can do this somewhat with the [abc](https://docs.python.org/2.7/library/abc.html#module-abc) module, which provides convenient abstract base classes. Namely, it prevents you from instantiating a subclass of an ABC unless all abstract methods have been overridden. I don't see it used much in the wild, but nevertheless, it's there.
I find those cases valid in public API methods/functions. Similarly to how `yaml.load` can take either a file object or a string.
CherryPy is the most underrated thing (not just webapp) in the Python world. Very few things have surpassed it in the web framework sphere. I love it because I can download it and just start working... it's so intuitive and easy to use and well documented and great support in the google group.
If a 3rd partuy library doesn't have not even an experimental/partial Python 3 support, it is IMO by definition, abandoned by maintainers.
Absolutely this. - UTF-8 as default source file encoding: win. - Throwing an error when mixing `unicode` and `str`: win. - Other Unicode handling-related "enhancements": fail. I just don't have encoding/decoding problems in Python 2 because I understand the difference between `str` and `unicode`. All you have to do is test your code with non-ASCII data and you'll flush out any errors (well, kinda). With Python 3, thanks to its Unicode "magic", it's a whole lot more insidious. If the environment changes, it's suddenly feeding you invalid Unicode data, so now you have to check all "Unicode" coming from the system to see if it's valid. At least with Python 2 that was all fairly explicit. IMO, they should have made Py3 throw an error if you combined `unicode` and `str` and left it at that. What's more, they haven't even gone the whole hog with Unicode and normalised strings, so you'll still have bugs when comparing Unicode strings that are theoretically equal, but normalised differently (Python source is, AFAIK, NFC-normalised, while filesystem calls on OS X return NFD-normalised Unicode). 
Personally, I wouldn't do either. Instead, I would give 4 a name and use that name everywhere. Looking at the code snippet, I have no idea why you are adding 4 to the difficulty. From the original code, I am guessing that 4 is the maximum number of tries. So something like available_words = [word for word in words if len(word) == difficulty + max_attempts] 
But if you are picking up python as a first language and start with Python 3, the syntax will not bother you.
If you have nested loops, the while loop will execute much faster than the for loop because a new range iterator has to be allocated and initialized on every iteration. While loops don't result in new allocations when nested. But then again, if you care about performance, you probably should be using python to begin with.
Here is a [comment](https://tech.dropbox.com/2014/04/introducing-pyston-an-upcoming-jit-based-python-implementation/#comment-1322386582) I made 2 months ago when I did an analysis of the top 200 Python libraries according to the [Python 3 Wall of Superpowers](http://python3wos.appspot.com/). In this analysis I show that support for Python 3 drops off rather quickly as you move down the list. Note: I don't fully trust the data on Python 3 WOS but since supporters of Python 3 love to point to it, the analysis in the linked comment was made against it. The reason why I'm skeptical of that web site is that it always says it has recently been updated but yet I'm aware of quite a few projects that should be on that list which is missing. For instance the cffi module which is very popular and has be downloaded nearly 2 million times is not on the list.
Ah I didn't even consider that, I guess my "print" example doesn't fit that use case. and after doing a bit more research it seems a lot of the 3rd party libs are just about ported to python 3 at this point. However I still don't see any real benefit with python3 over 2 but perhaps that's just my ignorance again. all I do know is, unless forced to switch to 3 ill stick with 2.7 and not lose any sleep over it.
Most people don't complain about it or give a fuck about Python 3. I care about Python 3 as much as I care about Perl 6.
Downvotes? Really? What part of what I said isn't true?
Why all dissing of the python developers? Only because you are disagreeing with them? Seriously, what have they done to you to make sentences as &gt; cpython developers which seem incredibly disconnected from the real world by now. or &gt; It's driven by one or two people and they are developing it without any real world experience with it. ? They are mostly volunteers, cut them some slack. &gt; 
After doing some research I do agree with this comment. This article seems to be about 2 years late.
The standard lib still needs a huge overhaul. subprocess.Popen still does silly things on windows like turning --foo="bar, baz" into "--foo=\"bar, baz\""
It's named Pony. No.
I used to be a big fan of CherryPy, but for my needs Tornado was a better fit. 
I keep hearing so many complaints about generics in go, but interface{} types serve that need pretty well for most cases. For a tree you could have: type Node struct { Left *Node Right *Node Data interface{} }
There is also ruby which is the most obvious replacement competitor.
Sadly this is right. Many people see python 2 as the end of the line and python 3 as a different language. The port from python 2 to 3 cannot be automated (who are you kidding!) you must really understand the details of the code to port it without mistakes. This is too expensive. If people must understand code to port it they may as well consider porting it to other languages. Breaking backward compatibility is ok when it does not result in change of behavior. print-&gt;print() is fine, except to except/as is pointless but tolerable, but swapping str/unicode for bytes/str is diabolic.
haha thanks. that was actually what i was going to ask you but i figured i could dl it somewhere
Those downvotes on my post you see were actually "no hard tabs" adherents accidentally slapping the down arrow key rather than the spacebar the eleventy times required by their philosophy. Also their mean IQ is like 50. And they can suck it.
There should be minimal cost from initializing a range iterator object. On Python 3, there is a range object (4 pointers, no other allocations) and an iterator object. The iterator object is either a specialized case when iterating over numbers that can be expressed within a C long or a generalized case that works for any size. It won't be a bottleneck.
Exactly. I always wondered what the purpose of interfaces was in PHP, thought I was missing something.
I think the bytes/str change is wonderful. Trying to figure out the mess created by implicit conversion in python2 was hell.
And python-modernize which transforms your code. 
For people reading back, using sum on a comparison only works because True and False are 1 and 0 when used with arithmetic. It's kind of a Python wart from when there was no separate bool type, but a handy one.
That is both disappointing and a bit depressing. I don't keep up with Python (mostly because my work keeps me in JS or non-Python backends 100% of the time, so far), so I wasn't clear on the reasons why Python 3 is generally looked down upon. I should really look at the debate a bit more closely so I can at least understand where the language is going...
What is unsafe about it? You you still need to have type assertions before you can actually use interface{} object as an actual data type and the type assertions give you the type safety. It is not any less safe than a python equivalent if that is where you are coming from.
 Such breakage is tolerable for a language which is just starting. It's a suicidal mistake for a language with massive deployed code base. Two more observations. A. it's not a binary choice, breaking changes could have been introduced with deprecations/future imports/etc which would have been slower (but then it might still be faster than what we've got with python3 ;-) B. given that the cost of b/w compatibility breakage is so high, it only should be broken for *clear* improvements. Python 3 does not meet this requirement IMHO: B1. print function vs print statement. A wash. B2. unicode by default. A mess. (as in: it has broken about as many things as it has fixed) B3. dictionary interface changes. (.keys() is now an iterator). A minor improvement etc, etc, etc 
Perl 6 has some interesting stuff I hear. Also it no longer pretends to be the successor to anything.
Let's say you've done a lot of data analysis using Python, but haven't used Python for much else. You could say something like, &gt;Experienced in using Python for data analysis. or &gt;Experienced in doing data analysis using Python. The order just depends on which you want to emphasize. Either should get across, "I'm pretty handy with Python in this area, but please don't ask me to make a videogame for you." 
http://docs.zope.org/zope.interface/
python is pretty bad for maintainability/debuggability in several ways, yes. No need to make it worse though.
interfaces are informal in Python. however, you can use the [Inspect Module](https://docs.python.org/2/library/inspect.html) to interact with classes more formally if you want. an example: this will get you all the functions bound to an instance of a class &gt;&gt;&gt; import inspect &gt;&gt;&gt; inspect.getmembers(my_object, inspect.ismethod) this will get you all the data member attributes bound to an instance of a class &gt;&gt;&gt; inspect.getmembers(my_object, inspect.isdatadescriptor) 
&gt; Rails still dominates the web framework landscape I stopped reading there.
There's the same thing wrong with 2.7 that's wrong with XP... it's going to be unsupported sooner rather than later. Anything you write in 2.7 is going to be either frozen in time or migrated someday. Why increase your future workload? 
pypy has exactly the same problem as python3: a ton of cpython2.7 code doesn't work in pypy.
&gt;That is both disappointing and a bit depressing. It also isn't true. It's an extraordinary claim that this random person on the Internet has better insight into the proper evolution of Python than its own creator. Of course, they offer no evidence to back up this assertion. All this is is people who are simply resistant to change. In the Delphi world its corporate maintainer wants to introduce memory management, zero-based immutable strings and other modern developments to both attract new users and make developing for mobile devices easier. People began complaining, and over and over again they claimed that this was going to be done "for no reason at all". This was in spite of a massive white paper being produced that explained why they wanted to make the changes. These same people claimed that Java had these features "for no reason" and it took all of 10 seconds to find a Java white paper also explaining all the reasons these features exist in the language. It's the same thing with the Python holdouts. "They broke everyone's code - and for bad [unspecified] reasons" is patently untrue. Guido and others painstakingly explained those reasons and the claimant isn't offering any rebuttal. &gt;so I wasn't clear on the reasons why Python 3 is generally looked down upon. Inertia. People just don't want to have to do anything to port code. No language has ever been as accomodating as Guido has been and they still want Python 2.8, 2.9, 2.999995, etc. 
Says the guy using a language named after a British comedy group.
Wing IDE is great and all but i can get Pycharm for the same price, which is IMO much better, and has most of the JetBrains ecosystem plugins already avaiable.
&gt;Might as well use Pascal ... Oh now you've done it... now you're going to hear it from the Delphi developers.... &gt;It seems to me that just few bratty library developers (shamed by their users into &gt;fixing their shit to support Python 3) are the main detractors. That's not the most diplomatic way of putting it, but it's fairly accurate. One Python library maintainer once said "Why should we ever port to 3 when Python 2's going to be supported FOREVER?" It's just inertia at this point. 
Unfortunately your definition does not correspond to reality. It would be nice if it did.
the truth hurts
It has to work the other way, however, too. Armin, in particular, has created some farily detailed criticisms of how Python 3 is structurally broken with respect to IO boundaries. They might have been delivered more kindly, as it can be grating to have someone pound on your work over and over in semiblue language. But regardless, the issues do exist, and these aren't things that can be just kinda bugfixed or something; a real solution would require bw incompatible changes and buy-in from lots of people. And if there are folks ignoring the rationales coming from Guido, there are just as many effectively ignoring (or at least minimizing) the rationales coming out of the folks doing the criticisms of Python 3. There are of course good reasons to do this; to make yet another very-bw-incompat release of Python would be very costly, and very might kill the language faster than leaving the structural deficiencies in. But that doesn't mean the issues don't exist, and that such a bw-incompat release might not be the right thing to do.
Most recently? The MKL optimizations from continuum don't work with python3 on osx. More generally? Everyone I work with is writing python2.7. All of my code is in python2.7. Nothing in python3 is compelling enough to warrant the pain of switching. If someone made a python2.8 that backported new things from 3.x to 2.x in a backwards compatible way I'd be all over it, but I agree with the article in the OP. Python3 asks an awful lot and doesn't bring much to the table.
http://www.diveintopython3.net/ is for Python 3, which you should learn instead of Python 2. There isn't much difference and if you know one you pretty much know the other, but as a beginner you should definitely start with the newest iteration since you have nothing to hold you back. My personal note is read this, try codecademy.com and read up on some other books(depending on what you want to do) one of the essentials is (http://www.jeffknupp.com/writing-idiomatic-python-ebook/) and some python pocketbooks/cookbooks can teach you a lot. Don't be afraid to buy the books, there are a lot of really good free resources but from my experience buying a book that covers the subject is more pleasant experience and saves you a lot of time. Also read the docs and get a IDE such as PyCharm which will save you a lot of effort and help you avoid bad practice. Have fun!
code sculptor is a huge deal breaker, not to mention the fact it runs python 2 and bunch of their own weird packages that won't be used anywhere outside the course ever, by anyone.
Whole book on this subject which I do recommend http://www.jeffknupp.com/writing-idiomatic-python-ebook/
Python 2.7 will be around and supported until at least 2020. While I agree that it will be nice when OpenCV gets Python 3 support, I don't see why the lack of support currently would make you wait to try it out.
Why have static types in a language where you need runtime checks to replace all but the simplest uses for a type system. Even java learned this lesson.
&gt; it now has multiple hugely useful stdlib libraries that aren’t in python 2 (enums, asyncio, **multiple dispatch**, …), Wait, what?
No it's not. LINQ is just static methods with a bit of syntax sugar (extension methods). You're right that Pony (probably) won't work with non-db objects, which is why I said it's a generator + the select method. For example, Customer = myponything print list(select(c for c in Customer if sum(c.orders.price) &gt; 1000)) vs customers = [Customer(), Customer()] print list(c for c in customers if sum(c.orders.price) &gt; 1000) All that changes is removing the "select" method. If it's not yet a feature of Pony, I doubt it would be very difficult to implement bypassing the decompile step if `Customer` is not a Pony db wrapper. P.S. LINQ does exactly the same thing that Pony does. If it's a plain object, it uses the IEnumerable/IEnumerator to do the work, while for LINQ to SQL it uses an [IQueryProvider](http://blogs.msdn.com/b/mattwar/archive/2007/07/30/linq-building-an-iqueryable-provider-part-i.aspx) to decompile the LINQ and generate SQL.
Nothing wrong with it either. Rails is popular for the same reason python 2 is more popular than python 3 - inertia. There's far too many books, gems, tutorials, etc. for the rails majority to just start porting their stuff to python.
I work with cherrypy every day. Love it.
In that case, it's both disappointing and a bit depressing that there's so much strife in the community and FUD being spread about upgrading to 3.\*. The responses to my first reply in this context have been evidence enough of that... Python is a decent enough language. I really wish the community and lead devs would unify behind *something*, though, whatever it happens to be. The divergence is just more overhead to have to understand before spinning up this new project that I'm sure I'm going to inherit somehow. Thanks for the longer response. Any chance you have those white papers bookmarked?
Rails is pretty popular and so is Node.js nowadays. can't say who "dominates" but it'll be fatally naïve to ignore their presence.
&gt; Python 2.7 is pretty much wart-free compared to every other language out there. If the warts were worse than the cost of going to 3.x, everyone would be on 3.x. This simply isn't true. Inertia is a huge factor - people justify what they currently do but ultimately the real reason they do it is because that is their habit. Habits are more powerful than cost-benefit analyses, as a rule. Python 3 would need to be **outstandingly and unmistakably** better than Python 2 to get the kind of traction you speak of. But Python 3 is *merely* better. 
&gt; it's a monoculture, they don't look outside. hmmmm, let's see. out of the box, I can use coffescript and sass for css and javascript respectively and the framework takes care of concatenation and minification etc... when I deploy (rake assets:precompile) every major js framework has gems that work with this tooling making it super easy to get a prototype of a single page app up and running pretty easily. on the django side, (we'll compare apples to apples), there's a few half assed plugins that you could, with enough effort getting something similar going, but it's not as nice, out of the box as rails is. So, I don't see how rails is a monoculture. 
those are complementary tools for different projects and most are inspired on Rails or Ruby in some way. they don't have many web frameworks, there's Rails and at a very far second place Sinatra which is micro. point is they don't care about Django's popularity or anyone else's.
&gt; point is they don't care about Django's popularity probably b/c they are too busy getting cool shit working rather than spending hours asking ?'s on this subreddit about which libs to use, or how to deploy it. they are free to actually accomplish something. 
Just curious, how much Python code base is related to web development? The reason I ask, it seems these type of arguments I see seem to center around Python being used among web developers. But Python is being used in so many different domains. So it may be true Python 3 may not be used a lot in production in the web development world, but in the scientific and data analysis world, Python 3 is being used widely. I don't have numbers to back it up, but at my Fortune 500 company, we use Python for data or statistical analysis. The Python 3 [code](http://nbviewer.ipython.org/gist/pybokeh/1165a8b29cb140cc6577) we use, use the full scientific stack (et. el. numpy, scipy, matplotlib) without problems. We are using Python 3 for making critical business decisions, which include whether or not our company will issue million+ dollar recalls. So basically I am trying to say that we should remind ourselves that Python is being used in other domains besides web development.
No, they're both web app frameworks. I re-implememted a cherrypy app in tornado recently. For what *I* needed, there was feature overlap. Your mileage may vary though. 
https://gist.github.com/anonymous/76a6321bfdda24b7ac0d I rewrote my code. I tried to do it without looking at yours, but I got stuck at a couple points and had to peek. I realized I needed to add a couple conditions, mainly to account for if the user word matches all of the answer word but the user word is longer than the answer word. It basically looks like a copy of the code you rewrote lol so I think I did everything right? It was super fun though, I look forward to playing with python some more.
I am unsure how familiar you are with SQLAlchemy... Assuming that you know how to setup a declarative mapper... Essentially, you will need to only select the object Article and not the tags. [SqlAlchemy Declarative tutorial](http://docs.sqlalchemy.org/en/rel_0_9/orm/extensions/declarative.html) Session.query(Article).join(ArticleTag).filter(ArticleTag.name == 'news', ArticleTag.name == 'funny').distinct().all() This should do the trick.
This is great! Thanks. I've read some of Carrier's other works and am always happy to read more from him. These three sources will be very useful in one way or another whether its for this project or anything else I decide I want to do at some point. Thanks again. I'll take you up on your offer if I come into any troubles. 
Thanks. I've had this book for a while and have never even opened it due to getting busy with random things. I didn't even know there was a forensics chapter. 
I work with web and computer games. Everybody i know uses Python 2. I have yet to see a company of significance using Python 3. In fact: i don't know of a single company using Python 3 I think.
My favorite part is how he thinks Guido is an idiot. Guido explains very simply why python 3 had to happen. Why do people without basic language theory comprehension think they know better?
It's looking quite good now :) I see you closed off a few corner cases (eg. word is entered in wrong case, try count should start at 1). My only remaining comment is on this: def PrintResult(count, answer, y): if y == 4: print("You lose!") elif count &lt; len(answer): print("%d out of %d correct" % (count, len(answer) ) ) elif count == -1: print("%d out of %d correct" % (count, len(answer) ) ) print("Entered word is too long!") else: print("You win!") You can reduce the amount of code here, while also clarifying it, by refactoring it like this: def PrintResult(count, answer, y): if y == 4: print("You lose!") elif count &lt; len(answer): print("%d out of %d correct" % (count, len(answer) ) ) if count == -1: print("Entered word is too long!") else: print("You win!") Hope to see some more code from you in the future. Are you aware of /r/learnpython ? It's a good place to ask if you have general questions about how to use Python.
I use Flask frequently. What are the reasons why I would want to use CherryPy instead?
I would recommend updating your `README.md`. This is the first thing people see when viewing your repo, so it's always good to start people off with a good impression and give more information about the project. Otherwise you are thrown in with no context.
Unfortunately even a measly $100 is going to prevent a lot of people from trying it out, particularly in the face of the more dominant SQLAlchemy. ORMs typically require a lot of contributions since they offer an abstraction across a wide array of databases. I like the syntax, and I agree that in general it's more pythonic than SQLAlchemy or the Django ORM, but I don't think it's robust enough for application code. It could be, however, very useful in ad hoc scripting and consoles like the iPython notebook. I just don't think you'll see many open source contributors are likely to contribute to a package that someone else is charging people to use. The author would likely make more money (admittedly over a reasonably long time frame) asking for gittips and relicensing rather than continuing with the dual license. Oh well. 
Since you only generate the list of candidate words once in this script, that would almost certainly be slower than the list comprehension. It might be more worthwhile if the game was a bit larger in scope -- handled a series of words to guess at, rather than just one, and the source dictionary was quite large. Otherwise it would just be a mistaken anti-optimization.
I can confirm PyCharm (or at least the Python plugin for IntelliJ) is wonderful :)
I agree it is a better language (with some caveats). The issues are not technical, they are social. The features added are not worth the cost. At least not yet.
MIT Open Courseware is probably the closest it comes to what you desire. Courses are modeled exactly like a class room environment and offers lectures, assignments as well as exams. I would also love due dates to help keep me on tract but I been unable to find such a program either. Edit- in reality the only thing to keep students on track and doing homework and exams on time is the chances of failure or bad grades. Being a free resource there is nothing to keep you on track but your own motivation to learn.
Thanks for your reply, I was looking into that MIT course. It really should be no problem for me to stay on track, but due dates would be wonderful, haha. 
I always think of something else after I post. Lol Maybe a good motivation is to have someone else attend the course at the same time. I would be interested in this.. I'm wanting to learn as well. Think I'm in the same boat you are in.
That is also why handling unstructured Json objects with in languages like Java is a huge pain. 
I used to abuse Python as a faster, more flexible bash, and only recently have begun using it to its full potential. Looking back there were a lot of things I wrote in bash or awk that would have made far more sense in Python (and which would have been more readable for others). Seemed in my ignorance I always asked if I could do something in bash, never if I actually should. Coming from HPC and architecture stuff, OOP was not exactly my forte, but now I've been learning Python to use as something more than the default shell on many of my favorite applications, and I am actually using it to create true software systems in the form of GUI tools that are robust enough to share. It has also been nice fully transitioning away from DSLs for numerical analysis and embracing Python's growing expertise in it. Numpy and Scipy were at Python 3.0 more or less from day one of its release. I chose to learn Python from the ground up in earnest a couple of years ago completely ignoring Python 2 and writing in Python 3 from day one. My reasoning was that it was the number in its name was bigger, and I it turned out that I liked the print function better... that was about it. I did not know the politics behind this or why narcissists post "[insert contrarian statement here]" on Medium and end up all over Hacker News. In my experience, there has been nothing I have found I could not do with Python 3 libraries. My needs are not especially pressing, but I feel as though we have the bases covered already. If anything, we need more systems to move by Python 3 as a default. In the Linux world, often the libraries are already there, but they are simply waiting to be *packaged*. I think the main thing standing between Python 3 and wider adoption is the minutia of the final stages of deployment, and yes, probably a health dose of developer inertia, too. Some of my old scripts from before I started really trying my hand at Python would get hung up on something like how I was invoking urllib2 to get a file. Others needed a single extra line to the effect of var_str = str(var, encoding = 'utf-8'). Furthermore, in the process I learned why libraries like urllib were changed the way they were. If anything I have found that the organization of stdlib objects is more consistent now. My two cents.
For me personally, it was a matter of taste. I like the structure of my code more in CherryPy than in Flask, I like the concept of configs. Plus, CherryPy has a strong conceptual basis (Google for Zen of CherryPy, very interesting talk), and I like that. On a more practical side, CherryPy has been supporting Python 3 for a very long time (before it was cool, I guess), whereas Armin did not put any effort in this direction up until recently on purpose.
Java is more verbose than necessary. For example in Scala there's https://github.com/mandubian/play-json-zipper this for example. But how is it more painful than Go? Json is a very simple type to represent, after all. Whatever Go has can be emulated by pre generics java. After all, their type systems would be equivalent modulo structural typing.
I loved monty python before I was a developer.
So have you had issues with Eclipse trashing your workspace or configuration files for downloads. It really bothers me because I could like Eclipse if it wasn't for its tendency to trash everything on me. By the way this has happened on machines at work and at home PC and Mac. Sucks. 
ah, you're right, I should've seen that. I only knew of learnprogramming when I have newbie questions, but i'll try using learnpython next time.
If it's wrong to have something be an int/float/string and you're dealing with reading the user's data that's prone to errors, type check it. If you're operating on the assumption that your user has a semi-functioning brain, don't type check it. I wrote a file IO code where there are integers, floats, and ASCII strings. The main types of floats follow the form the boring floats 1.0 and 1.; note floats must have one period. Scientific notation follows the form: 1.0E+5, 1.0D+5, and 1+5 (no period here). Those values are all the same number (though the D indicates double precision as opposed to single precision). Values can be any combination of int, float, string (also strings can't have spaces or start with numbers/punctuation), or blank. Finally, there's CSV format, tab delimited, fixed 8 character width format and 16 character width formats. To speed up IO and to prevent easy to mess up and confusing formatting errors, you'd better believe I make use of types.
Yes, I was considering the case where this function gets called multiple times. As long as the function gets called only once per invocation of the script, you're right that it's an unnecessary optimization. (I still wouldn't call it an anti-optimization, though, because you pay only an insignificant amount of effort for doing this right while you're reading the words from the file.)
[this one](https://docs.python.org/3.4/library/functools.html#functools.singledispatch)
sure, they do produce a lot. perhaps not the highest quality but they're always working on the latest thing out there.
&gt; for (std::map&lt;std::pair&lt;std::string, int&gt;, std::list&lt;std::map&lt;int, float&gt; &gt;::iterator it = foo.begin(); it != foo.end(); ++it) { } To be fair, you often don't have to vomit templates in C++ any more. &gt; for (auto it = foo.begin(); it != foo.end(); ++it) { } 
Except of course you've added the parens to make C look good while it in fact is just as easy to screw up as pythons variant :P
Think about it from this perspective: If someone is doing client work, and is charging say $100 / hr, it only takes a tiny bit of a productivity increase (less hours billed) for it to be worth it to the client. The two creators of Pony seem very dedicated and opinionated about the right way to do things, which I like, they are under now obligation to accept code / features they don't agree with. It's hard to know which model would make more money, do you have any examples of projects making decent money with gittips etc? I thought of one example of alternative funding: The corporate sponsorship of Redis development.
Never tried it with PyPy, but for what it's worth, used sensibly it has never been a bottleneck. When you're doing a select statement, and are only interested in one attribute of a model, you can do: select(a.name for a in A)[:] and you'll get a regular list of strings, no object creation. Of course, making a huge list is often the wrong move, you'd want to iterate through the query, but I'm sure you see my point :)
Ftr, supervisor master is py3 compat
&gt; I don't see why the lack of support currently would make you wait to try it out. Perhaps because chchan is using Python 3, and would rather not fragment his codebase?
Very interesting; it reminds me of the plotting command style used by IDL. I'm not a huge fan of it myself, but I can see the advantages for the ex-IDL community!
The idea is cute, but I wouldn't call it "obfuscated". It's just incompatible with the default specification. "Proprietary python interpreter" maybe...
Thank you for so much effort put into the post. Looking into the resources now.
This looks like something I have been looking for, great job!
I somewhat disagree. While micro-optimizations are only valuable for hot-spots, I think caring about good algorithms is almost always worthwhile.
Python 4 should have inline tests, contracts and optional static typing. Cobra is an excellent example of what Python should be trying, albiet without the annoying C#/Java "everything must be a class, even your main function" thing. Python 4 should also use a JIT and take advantage of static typing where it's specified. It need not be PyPy, although if they tidy up their build process to not take hours and 4GB+ of RAM they'll be doing pretty well as a serious contender. A nice killer feature would be to finally target Arm/Android/FFOS in the official distros..ideally with premade bindings to android/firefox API. Python missed the mobile boat and should be scrambling to catch up. Not by relying on the Android Scripting Layer but by providing a near-native way to run python on handsets, whether as 'Apps' or in a terminal emulator/adb. Finally, making the core distro more portable would be nice, so devs don't need clients to install Python to use code. Think how love2d.org does things: you can cat a script to the end of the binary to make a standalone executable!
I never seen python dying... Am I missing something here?
Me neither... As far as I'm aware, the language is not exactly degrading over time... Lol
Both articles talk of Perl and Python like they are some dinosaur, shitty, outcast language...... They're not even close. I'm sorry, but most of these languages are great. I'm pretty sure it's what you do with the code that matters, not the code itself. The code itself makes a small difference to creativity and usefulness.
Yes, you're missing reading the first line of the article…
My argument is not that it isn't worth it, but that other developers are much less likely to contribute to a project that will make *someone else* money. I do not have any examples of projects making money with gittip but many projects like this tend to open the door for consulting opportunities, which can be particularly lucrative as you pointed out. 
How is CherryPy different from Django or Symfony? Is it worth investing the time to learn it?
It's not dead yet, but it used to be the "cool, hip, fresh language that gets so many things right". Nowadays it's an established language with a lot of cruft. It's not exciting and new anymore, and what's more important, things that made Python stand out in the past are now considered standard. At the same time, Python isn't perfect, but many of it's flaws (e.g. the GIL, or the slow execution speed) could be overlooked in the past because it was better than many alternative languages. But new languages have caught up to Python and are still improving, while Python never managed to get rid of it's flaws. Of course, it's not the most important thing to be hip, but Python used to be the language that many people levitated towards. Nowadays it's the language people move away from. It's not dead by a long shot of course. It's just a bit stagnating.
I'd love to move to Python 3, but it won't be available for production use in my firm until late 2014 / early 2015. Mainly because for what it costs to make it available, it doesn't offer enough extra value over every other project the team who own it are working on. And if I'm stuck on 2.7 at work, I may as well keep using that for my personal projects too ...
Type annotations, including interfaces, would still be useful in python for code analysis tools. It would be opt-in static typing without run-time enforcement. It would be in the same useful gray area as the dynamic type in C# that let's you opt-out of static type checking at compile-time.
This is actually something Ive been looking for. Have really hated thr matplotlib plotting API. Thanks for doing this!!
Perl is a write-only language in a world of code longevity. Its a dinosaur. Not a dinosaur like cobalt, but still a dinosaur. 
So, Python 4 should be the best case scenario everyone hopes for Pyston. Cool. Contribute. https://github.com/dropbox/pyston
Except that *optional* static type checks are only marginally more useful than duck typing with unit tests. If you really want to reap the benefits, you have to enforce them everywhere (and because of this, even C#'s static type checks are only partially useful - they catch some errors, but they still don't give you a lot of compile-time guarantees).
I know everyone likes to blog opinions about what they feel like Python should look like in 10 years but honestly I dont think theyre helping the community at all. For example, no one disagrees that the GIL needs to go, OP can say that til hes blue in the face but he's preaching the the choir there. The question is HOW do you do that? We need ideas on how to implement changes not wishlists. We need PEPs, not blogs. This isnt C++ where we make wishes to a council of elders, GET INVOLVED. 
the drama, don't even try to catch up...
CherryPy is a bare web framework. It provides simple patterns to build an application but let you decide if you want to use them or not. It doesn't provide any templating, nor database support. It's a great framework when you design an app which doesn't fit the classic "user content oriented" model.
Yes it is true that PyPy does not support many extensions that rely on CPython's CAPI but at least it offers some major benefits such as increase speed and smaller GC pauses that for a number of projects make the cost benefit analysis favorable to switching to PyPy. Now I know a significant number of Python developers and I have yet to know one that is deploying Python 3 apps yet I know 40-60 who are deploying PyPy. There are far more libraries that are compatible with Python 3 than PyPy but yet PyPy's adoption is taking off and Python 3 is going no where. If Python 3 offered benefits that developers were interested in than Python 3 would see it's adoption taking off. I would like to see the down load number for the various versions of Python 3 vs Python 2. I suspect Python 3 is down loaded less than 5% of Python 2. I would also like to see the down load numbers of say the top 800 packages in pypi and how they break down not in terms of whether or not the package is compatible with Python 3 but to see which version of Python including PyPy they are installed under. Not sure if that would be possible as I don't know if pip and company provide the Python version that is used to execute the install commands. This would provide the hard evidence we all need to see the true story of Python 3's adoption rate. 
Gread read. I'm learning python now. 
&gt;To be fair, you often don't have to vomit templates in C++ any more. This is true, but if you're using C++11 you should also have something like for (auto it : foo) { } Which is a "foreach" style.
Could you provide more information about what your are trying to achieve? Can't you just increase the timeout when you create the socket?
This is one of the best write-ups for a Python script I'd ever seen. The problem is real-world and easily understandable, and the code uses slightly more advanced concepts to solve it, but do so in a very simple and logical way. A great reference for me, and hopefully lots of beginners too.
Cute, but unfortunately also a very good way to get 100% CPU usage, which makes the entire thing pretty unresponsive....
Maybe it's just me, but I find that there is no real explicit description of the 3rd argument of your EasyPlot() function. It's almost totally implicit over the whole ReadMe. This might be pretty obvious for someone using matplotlib, but given that this is a "*matplotlib looks complex*" lib, it should be written obviously somewhere, instead of assuming the user knows the matplotlib syntax.
Still worth watching it. Having used CherryPy for years, it relates well to how the project was thought-out.
I totally agree. It's one of those videos that covers a topic that never gets old and is really universal. CherryPy totally deserves more love from the community, hope this video will draw some attention to it.
Thank you friend for all the info! 
 import future jk
As someone who just started with Python thank you for posting this, looks great. 
Yeah I agree, [I haven't heard of anyone](http://nodejs.org/industry/) that actually uses nodejs in production. I mean, it's not even in 1.0! 
Hi there. Thanks for your note. Are you referring to the `'r-o'` type argument that follows the x, y arguments? This is standard Matlab/Matplotlib abbreviated format for specifying line color, spec and marker type in one string. I agree that this does look cryptic to someone unfamiliar with Matplotlib/Matlab and I'll be sure to update the documentation to include this. For now, this link should help explain that argument: http://matplotlib.org/1.3.1/api/pyplot_api.html#matplotlib.pyplot.plot
Thanks, I wasn't aware of the similarity with IDL. I can see how the command style can not be everyone's cup of tea, especially those who prefer the OO style and the added control it enables. I like the native style some of the times, but most of the times when I am looking to generate quick, annotated plots or analyze a bunch of similar datasets, I find `EasyPlot` to be a big help and it helps me keep my code uncluttered and focused on the data analysis. Hopefully others will too :-)
Thanks! If you do use it, I'd certainly appreciate any feedback, bug reports and/or feature requests.
I do hope You guys know that Mitsuhiko is developer of the popular web microframework Flask... 
&gt;if you want to make something quack, then check if it can quack, not if it is a duck Isn't this exactly what an interface in Java does?
Definitely. I was trying to figure out a way to turn that while loop into a for loop and couldn't think of one. I didn't know you could use range that way. By the way, there's no way to combine that for loop with the if statement, is there? So this wouldn't work: for i in range(1, 5) if count == len(answer) and count == -1:
Very cool! But it made me a little sad when I read that it took you and hour to put the entire thing together! Wouldn't it be neat if you could actually interface with a watering timer directly via Python? I'm sure you could do a lot of cool algorithmic stuff including pulling in weather forecasts and adjusting watering accordingly.
Not a huge fan of this code for a few reasons: * Global variable... named "temp_dic" * Use of two threads seems silly when you could run both functions on a single thread (if sleeping was made smarter) * Actually it could probably live in a single function and reduce some code repetition * I'd make use of 'email' library in conjunction with SMTPlib, instead of manually constructing emails * There's a few 'magic strings' littered throughout the code, they'd be better off as globals (or configurarable options/command-line args) - particularly things like email server/port, email subjects etc. Overall I don't think the code is 'bad', it's probably much the same as what I'd hack up for personal use. But I think a few revisions could make it much nicer :) 
Where python needs to be careful is to make sure they are actually listening to what the general users wants; not the hard core user. Preaching to the choir is easy. Expanding your flock is not. 
I did something similar with an arduino. I use it to water my outdoor plants twice a day during the hot months. I should really move it over to the rPi or Beaglebone
That doesn't change anything. A doubling of work implies that you're effectively got two completely independent code flows. If that is the case, you're doing it wrong, whether you're guido, mitsuhiko, Awful coder #4,003 or anyone else.
What i mean is he built a successful web framework that supports both py2 and py3 , are you sure he is doing it wrong?
I don't think so. I prefer the current structure, anyway, because `count` only really has a meaningful value after the loop body. With this structure, you don't need to set it to a dummy value outside of the loop.
Use something like tkinter to draw a sudoku puzzle on the screen and solve it.
Since the differences are relatively slight between the two versions, why the hell do people make such a fuss about converting their modules from 2 to 3? Is the string encoding thing the only big issue? I just don't see how it takes a big project like Django 5 years (!!) to port to Python 3.
I'm very interested in this. From what I understand, all the timer does is send an on or off signal to the zone controller. I'm game for a Raspberry Pi or similar project if someone else can figure out the electrical wiring. 
Do you have a writeup of what you've done? I'm interested. 
I agree. Also your code looks a little messy. Maybe add some line breaks or such in there.
Yes, exactly my point! It took me 1-2min before actually remembering what this syntax eventually means. Someone just looking for an easy plot lib might indeed not be aware of that. Thanks!
If you use env PYTHON_EGG_CACHE=/usr/local/LX/.python-eggs/ inside `script` section it runs the program `env` but doesn't change the environment. Put the line before the `script` section.
&gt; Or PyPy could mature enough to replace it (there should be only one). I think the *there should be only one* argument is compelling. While alternative implementations will always exist to serve niche communities (like Jython), there should only be *one* Python implementation that the vast majority of users use. I don't think it will be PyPy as if it were going to happen, I think it would have already. I think the translation step for PyPy and RPython language is a huge barrier that prevented core CPython devs from helping out more. Hopefully Pyston will be more successful and could be adopted as the mainline CPython like Unladen Swallow was always meant to be. Frankly, I think any one of the 5 improvements the author sites would be enough to get people excited about Py3+. Broken string APIs and chained exceptions weren't really anything to convince people to switch.
Thanks for the observation. I have corrected this! Now I no longer have EGG_CACHE write permission issues. I wish I had more upvotes for you! 
[COBOL](http://en.wikipedia.org/wiki/COBOL)
Sockets can be very tricky. In your scenario, NO, the socket does not .close() right away, but it is no longer available in many cases (Windows.) https://docs.python.org/3/library/socket.html &gt;Sockets are automatically closed when they are garbage-collected, but it is recommended to close() them explicitly, or to use a with statement around them. Note close() releases the resource associated with a connection but does not necessarily close the connection immediately. If you want to close the connection in a timely fashion, call shutdown() before close(). For instance try this and take a look at the exception when you try to reconnect: import socket import time s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(5) try: s.connect(('www.google.com', 800)) except socket.timeout: print('I timed out.') s.connect(('www.google.com', 800)) But if you explicitly add a .close() in there, the exception is different : import socket import time s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(5) try: s.connect(('www.google.com', 800)) except socket.timeout: print('I timed out.') s.close() s.connect(('www.google.com', 800)) EDIT: I have no idea why this is the case.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**COBOL**](https://en.wikipedia.org/wiki/COBOL): [](#sfw) --- &gt; &gt;__COBOL__ (/ˈkoʊbɒl/) is a [compiled](https://en.wikipedia.org/wiki/Compiled) [computer programming language](https://en.wikipedia.org/wiki/Computer_programming_language) designed for business use. It is [imperative](https://en.wikipedia.org/wiki/Imperative_programming), [procedural](https://en.wikipedia.org/wiki/Procedural_programming) and, since 2002, [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming). It was designed in 1959 by the [Conference on Data Systems Languages](https://en.wikipedia.org/wiki/Conference_on_Data_Systems_Languages) (CODASYL) and was largely based on previous programming language design work by [Grace Hopper](https://en.wikipedia.org/wiki/Grace_Hopper). COBOL stands for __CO__mmon __B__usiness-__O__riented __L__anguage. &gt;COBOL is primarily used in business, finance, and administrative systems for companies and governments. In 1997, [Gartner Group](https://en.wikipedia.org/wiki/Gartner_Group) estimated that there were a total of 200 billion lines of COBOL in existence which ran 80% of all business programs. &gt;COBOL was one of the first programming languages to be [standardised](https://en.wikipedia.org/wiki/Standardised): the first COBOL standard was issued by [ANSI](https://en.wikipedia.org/wiki/ANSI) in 1968. The standard has been revised three times since then, with [ISO](https://en.wikipedia.org/wiki/ISO) publishing the latest standard as *ISO/[IEC](https://en.wikipedia.org/wiki/International_Electrotechnical_Commission) 1989:2002*. &gt; --- ^Interesting: [^GNU ^Cobol](https://en.wikipedia.org/wiki/GNU_Cobol) ^| [^BLIS/COBOL](https://en.wikipedia.org/wiki/BLIS/COBOL) ^| [^COBOL ^ReSource](https://en.wikipedia.org/wiki/COBOL_ReSource) ^| [^IBM ^COBOL](https://en.wikipedia.org/wiki/IBM_COBOL) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chsd7ga) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chsd7ga)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Not to start an argument on "systems" of measurement, but couldn't you just look at the rank of sales on Amazon.com of the top 10 Python programming books? Go to "Amazon.com" and search for "python programming," then on the left hand side select "Books &gt; Python Programming." You should see "Related Searches: java programming, python, python web programming." above the first book. Just select PYTHON and they will be listed by sales rank from #1 on down.
Actually, you can. If you have a Raspberry Pi, you can hook it up to the [OpenSprinkler Pi](http://rayshobby.net/?page_id=5816). It has also been ported to Python [here](https://github.com/Dan-in-CA/OSPi). I've been using it to control a hydroponic system.
See? Its so old I dont even know how its spelled lol. 
&gt; We need PEPs, not blogs. This isnt C++ where we make wishes to a council of elders, GET INVOLVED. This. 
Thanks for reiterating that. There seems to be a big disconnect here in the community because the majority of complaints I hear about the language are things that EVERYONE wants but are incredibly technically difficult and the GIL is a great example. No one wants the GIL but no one knows how to remove it. But people love to say the GIL is killing Python as if its a design decision to leave it in. I just get frustrated when people complain about the language implementation while they sit back and tell the core devs to suck less. People need to know they can help too!!
I see it as another episode of internet bandwagon hate. &gt; No one wants the GIL but no one knows how to remove it. And no one wants to learn enough about it to remove it. On it's face knowing what we know now it's a bad idea. At the time it was invented it was most likely the most reasonable decision. It's easier to complain than to do anything.
Who is "they"? You know that ANYONE can write PEPs or contribute right? There is no they. Only Us. This statement doesnt even make sense. 
I love CherryPy, a great framework. I've been so glad not use a framework that is tied to a templating library or database framework. My needs have changed as projects have developed and it's been easy to gradually migrate from one system to another. I'm sure there are more "batteries-included" functions in CherryPy that I haven't made full use of yet - despite using it for years. I'm not satisfied with any templating libraries that I've used. Mako is the best I've used, but it's clumsy for anything advanced and it's awful if you make a mistake and get a hard to interpret traceback. Any recommendations?
Personally I wouldn't equate marketability (sales) with usefulness/quality.
The book says [] which is what confused me. How would you write print 'Michigan has: ", cities[states['Michigan']] edit: Carefully looking at it decided that I might actually be retarded.
Sorry if this sounds annoying, but I'm not going to point out the mistake since it goes against Zed's main principle of the book: &gt; By going through this book, and copying each example exactly, you will be training your brain to focus on the details of what you are doing, as you are doing it. &gt; A very important skill--that most programmers develop over time--is the ability to visually notice differences between things. An experienced programmer can take two pieces of code that are slightly different and immediately start pointing out the differences. Programmers have invented tools to make this even easier, but we won't be using any of these. You first have to train your brain the hard way, then you can use the tools. So instead a few tips on how to become better at debugging (that's what most of the time in programming is actually spent on! ): * If it's difficult to find a bug, just delete half of the code! Does the error still occur? If yes, delete more, if no, undo the last delete and try taking out a smaller portion. Eventually you will get very close to the actual problem part. * Errors are often reported a few characters or lines *after* the actual location. The parser is going through each symbol in turn, and deciding if it still makes sense at each step. But if an earlier mistake caused the parser to think that "here starts construct A", and then something else appears, it doesn't know where the error was. It highlights the first part *that doesn't fit with the previous code*, even if that part was what you meant but something earlier was not.
Hrmm had a crack and doesn't seem to produce the results I was looking for. I get 0 results for that. I'm not sure how to explain it, but my guess would be that it applies the first filter then the second. First pass would only leave articles with tag 'news', then it will try to filter those results with articles with tags 'funny'. I've tried an or_ filter but it gives me any articles that contain news or funny, but I'd rather much have something that only gives me results that have news and funny tags.
&gt; STRING APIs ARE FIXED. There's no need to yell. I'm already getting downvoted to hell. :) I would also argue they're not "fixed." Sure Python 3 renamed "unicode" to "str" so now it has "unicode strings by default." But that's just a data type that doesn't mean much until you look at how APIs use that. Instead of re-listing all of the problems with how Python 3 "fixed" strings here, I'll simply point you to u/mitsuhiko's post: http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/ &gt; Quora uses a custom interpreter, and CCP uses Stackless, but neither of those should be mainstream. That's what I meant by "alternative implementations will always exist to service niche communities." For the vast majority of Python users there's only a single implementation: CPython 2.x. Users will always have the freedom to choose; I'm not suggesting we somehow try to restrict choice. What I'm suggesting is that users usually don't *want* to choose. They want to use Python, the language, and not worry that some blog post they read or package they use doesn't actually work on the implementation they chose. For the majority of users, implementation "choice" isn't a feature, it's a bug.
&gt; For example, no one disagrees that the GIL needs to go Guido himself has said "no" to patches that would remove the GIL and decrease single threaded performance. This is a complex issue not just technically, but socially as well. (Where the "social" aspect is giving more weight to single threaded performance than parallelism.) 
Python 2.7: pretty yawn, if you ask me. And powered by a patent heavy company of NSA apologists. Sorry, but I prefer community efforts like PyPy and CPython, even if they need serious work.
You're very welcome! I'd love to get any feedback if you end up using this library.
You mismatched the quotes. Look at the line you posted here. Starts with single quote, ends with double. These kinds of errors are easily caught by looking at the syntax highlighting. You'll notice that most of the text after that line is colored as a string, since the string 'Michigan has: was never closed.
It also adds another layer of billing, because it is billed per-server. So even if I sell the client my work for fixed amount $x, they then have to keep the licenses in mind: every time they add a server they need make sure they still have enough Pony licenses. Especially if you run on a virtual environment and want to simply be able to scale out, that is annoying to keep track of. 
I think most people that make frameworks are pragmatists and know that if they make it hard to write code for money they won't do so well.
The main reason is that the GPL would require any project based on that framework [edit: and which is distributed, i.e. you build a CMS and publish that] to be licensed under the GPL as well. Typically, for a library, you'd rather use something more permissive. LGPL would be an option, but the freeer MIT/BSD licenses are often chosen. Of course, it doesn't really matter in the end. If someone doesn't want to give back, they won't give back, GPL or no GPL.
:) I find the same thing inevitably happens to me as soon as I breakdown and ask for help.
The #Pyramid community has been considerate, patient, and helpful. They're passionate about their programming craft and sharing their knowledge. I know this because I took the time to get to know them. Had I gone with my gut feeling, I wouldn't have opened the cage and gotten in with them. 
&gt; I'm not satisfied with any templating libraries that I've used. Mako is the best I've used, but it's clumsy for anything advanced and it's awful if you make a mistake and get a hard to interpret traceback. Any recommendations? Yes, I use [meld3](http://www.plope.com/software/meld3) for templating. I recommend you avoid mako and other pull-style templating systems. Read Terence Parr's seminal article on push-style versus pull-style templating that I link to in [my survey of push-style templating systems](http://www.perlmonks.org/?node_id=674225). I could never go back to things like mako, jinja, cheetah, etc. 
I wrote [a comparison of cherrypy and webpy](https://groups.google.com/forum/#!topic/cherrypy-users/KDsFLscSiaA) long ago. 
That's just not true either though. I'm not saying that it's not REALLY REALLY hard. Or that it's not an extremely complex computer science problem. But the fact is there is a solution out there. And someone will come up with a solution, which means, if you are THAT GOOD, you can fix it. But it also means that if we as a community are that good, we can fix it. Your comment just has the connotation of "Average people shouldn't even try, leave that shit to Guido and his peers" and that's just not a good attitude. Not sure if that's what you were actually going for there. 
That is why I always ask for cited sources. It's hard to evaluate all of the data when I don't write much Python myself yet, but it seems that the community dislikes 3.\* and the language devs work predominantly on 3.\*. I suppose part of the reason I was initially opposed to my coworker's logic is his adamance when the only supporting claims he could make were "some big library authors don't like it", which isn't exactly a great argument and certainly not enough to warrant the level of confidence he was showing. His phrasing and argument were weak enough to make me question the underlying logic, which spawned this whole discussion. It seems that, in the end, he was right, but at least now I can support that argument with more data than he did. It seems the path of least resistance for us here is 2.7 anyway so it looks like that's the path we'll be taking.
Well, at least that was appropriately filed under "Rants" on the author's website.
I loved that it played an appropriate tune when one scrolls through the list of pages from *what's new in Python 3*. I usually don't appreciate auto-playing music, but the way it was done here was great.
GPL is always a no no for me. The only thing I've seen it do is *prevent* others from using my code. This is in direct opposition to my goal.
&gt; everyone who still uses Python 2, but complains about the Python 3 string system, doesn't understand Python 3, because it is essentially no different -- just easier to see your mistakes. Sorry, but that is very wrong. The people complaining about Python 3's Unicode handling are typically the ones who know most about it because they're the ones who know their text encoding/decoding very well (and thus didn't have a problem with it on Py2) and can see clearly how Python 3 is broken in that respect. It would have been splendid if all Py3 had changed was disallowing the mixing of `bytes` and `str` (or `str` and `unicode` in Py2 parlance). But Py3 goes too far and insists on decoding data to Unicode that it literally can't correctly decode (e.g. command line arguments on Linux, HTTP/WSGI input). The result is that it can give you invalid Unicode (full of surrogate escapes) that can be turned back into the original `bytes` easily enough in most cases (within Python), but will cause your program to explode if you try to print it or otherwise encode it (e.g. to write it to a file) because it's not valid Unicode. Dogmatically enforcing the all-text-is-Unicode mantra and returning broken, invalid Unicode as a means to that end is not a sound solution. Instead of having to be careful not to mix `str` and `unicode`, as on Py2, you now have to check the Unicode Py3 hands you to see if it's actually valid Unicode. On top of that, Py3 doesn't even make using valid Unicode transparent: it doesn't normalise Unicode strings/input, so you can create a file with a name taken from, say, a JSON file (which will likely be NFC-normalised), and find that Python considers the same filename returned from `os.listdir` to be different on OS X because that will be NFD-normalised. 
Isn't that only for GPL3 and not GPL2? I forget or get confused or both.
What are your "go to" resources for CherryPy? Examples, docs etc.?
Ah, okay, I misunderstood everyone's complaints by assuming they were complaining that the types worked differently. Instead, what I gather from you and the blog post someone linked is that many things that should be bytes in the stdlib are instead strings, even when they can't be assumed to be unicode... hmm.
Couldn't agree more, I maintain multiple scientific software packages with a combined total of ~20k lines. Last week we decided to make the jump from 2 to 3. Within about a day we managed to port two of our projects with backwards compatibility. The third party libraries are there, 2to3 ported something like 80% of codebase correctly and the rest was trivial to fix. I feel for people who are stuck with large Python 2 codebases but if your employer can't, over the span of 5 years, devote some man-hours to make your system future proof, then blame them not Guido or the volunteers who have made the wonder that is Python in the first place.
You assume everyone who has not ported over to Python 3 is lazy and i'll assume everyone who makes that statement is naive and can't be taken seriously.
I couldn't agree more and I am glad to see an appropriate response to that other poorly argued piece.
Or they have no incentive to upgrade. That's not laziness.
A PEP? Which I suspect I have to fill out canonically. Or how about somebody out in internet land forks 2.7, calls it 2.8, fully backwards compatible, puts in unicode properly, and then ends up with the defacto version. Sounds better than going with a begging bowl to a bunch of insiders who are probably lining their pockets giving talks and doing consulting gigs as the gods of Python. 
We're programmers. We're all lazy, by necessity. Automate all teh things!
Can someone explain to me the difference between this and Pyglet? To my knowledge they are both just small OpenGL wrappers and much more low level than something like pygame.
Does Go have scientific libraries on the same scale as Python? (Numpy, scipy, pandas, ...)
[This is probably what you want.](https://www.coursera.org/course/interactivepython) 
`for` and `while` can be pythonic too :) OP was referring to C–like “incrementing `i`” loops. I'm not sure whether your 2 years of use is in a C–like way or a Pythonic way, so forgive me if I’m about to preach to the choir. So the distinction here is using them in a “C–like” way or not. The classic `for` loop with an incrementing `i` variable isn't the Python way to iterate over something. You just say for item in items: mangle(item) If your `items` doesn't know how to work like this, you only need to define `__iter__` on it. The other observation is that in a lot of cases, a C–like `for` can be entirely replaced with a list comprehension. The classic example is a list of squares: squares = [x**2 for x in range(10)] If you desperately need the increment variable, you can use `enumerate`. This is typically a sign of parallel lists which can be better handled using `zip` and unpacking, e.g. knots = ("windsor", "half-windsor", "pratt") difficulties = (3, 2, 1) for knot, difficulty in zip(knots, difficulties): print("{} has difficulty {} of 3".format(knot, difficulty)) The `itertools` module has a lot of ways to do more complex iterations and without necessarily having to represent entire sequences in memory at once.
Coming up: "Python 3 is." "Python 3? idk"
oh, i should mention I am a buyer not a seller of these services and was asking the question from that perspective
GIL, before someone else mentions it. &gt; I've heard good things about AMQP and RabbitMQ but am unsure about its viability. not sure? what would the alternatives be? mqseries?($$$) msmq?(LOL) of course they are viable. why wouldn't they?
To get a deeper understanding, I think Learning Python is probably going to be the best you can obtain. The physical book is huge. Dive Into Python is also good, but doesn't quite cover as much as Learning Python. These 2 books will provide a deeper coverage of the Python language than most other books I can think of. Of course, the official Python API docs are where you would go if you want to explore the standard libraries.
"What Python 3 is" "What Python 3 isn't" With that we'll cover a good amount of ground
If your application needs to be realtime in the strict sense of the word for some part of that, you wouldn't want that to be python. If the application is mostly IO-bound (e.g CPU processing time of the application parts hardly matters, mostly network latency times of message traffic dominates busy-time of overall throughput), then python would be fine, using any of the IO loop libraries written for it or even asyncio in Python 3.4. It's not hard to write C extensions for python, but ctypes or cffi also allows easy interpretation of custom network messages, if they are not in a standard format. You haven't described enough of the overall architecture for me to have any solid thoughts on what message passing should be going on. I'd leap to 0mq first, but that may barking up the right or wrong tree.
This rant pretty much applies to any open source project that people get upset about. 
Technically you just hosting your own server that answers HTTP requests isn't considered distributing your server's code. So GPL should be fine in that simple case (if your goal is to not have to share your project's source code). The [AGPL](https://en.wikipedia.org/wiki/Affero_General_Public_License) even specifically exists as a variant to specify that the above case *does* get considered as distribution, for its purposes.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Affero General Public License**](https://en.wikipedia.org/wiki/Affero%20General%20Public%20License): [](#sfw) --- &gt; &gt;The __Affero General Public License__, often abbreviated as __Affero GPL__ and __AGPL__ (and sometimes informally called the __Affero License__), refers to two distinct, though historically related, [free software licenses](https://en.wikipedia.org/wiki/Free_software_licenses): &gt;Both versions of the AGPL were designed to close a perceived [application service provider](https://en.wikipedia.org/wiki/Application_service_provider) "loophole" (the "ASP loophole") in the ordinary GPL, where, by using but not distributing the software, the [copyleft](https://en.wikipedia.org/wiki/Copyleft) provisions are not triggered. Each version differs from the version of the GNU GPL on which it is based in having an additional provision addressing use of software over a [computer network](https://en.wikipedia.org/wiki/Computer_networking). The additional provision requires that the complete source code be made available to any network user of the AGPL-licensed work, typically a [Web application](https://en.wikipedia.org/wiki/Web_application). &gt;The [Free Software Foundation](https://en.wikipedia.org/wiki/Free_Software_Foundation) has recommended that the GNU AGPLv3 be considered for any software that will commonly be run over a network. The [Open Source Initiative](https://en.wikipedia.org/wiki/Open_Source_Initiative) approved the GNU AGPLv3 as an [open source](https://en.wikipedia.org/wiki/Open_source) license in March 2008 after [Funambol](https://en.wikipedia.org/wiki/Funambol) submitted it for consideration. &gt;==== &gt;[**Image**](https://i.imgur.com/vU7dX5K.png) [^(i)](https://commons.wikimedia.org/wiki/File:AGPLv3_Logo.svg) --- ^Interesting: [^GNU ^General ^Public ^License](https://en.wikipedia.org/wiki/GNU_General_Public_License) ^| [^GNU ^Lesser ^General ^Public ^License](https://en.wikipedia.org/wiki/GNU_Lesser_General_Public_License) ^| [^Launchpad ^\(website)](https://en.wikipedia.org/wiki/Launchpad_\(website\)) ^| [^Free ^Software ^Foundation](https://en.wikipedia.org/wiki/Free_Software_Foundation) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chssvit) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chssvit)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; The main reason is that the GPL would require any project based on that framework (i.e. your website) to be licensed under the GPL as well. The GPL only requires licensing derivative works if the code of the derivative work is distributed. People don't frequently do this with websites (this is why the AGPL was created). Google, for example, uses plenty of GPL code for their search engine (...presumably) but doesn't have to publish the code powering their search engine under the GPL... because they don't publish their search engine code. It is just used internally at the company.
Coming up: "Python 4 is killing Python"
If you have to keep convincing yourself that its fine, well good for you. Despite what it may seem like, I want python 3 to win. But since I'm a programmer, I can move to golang, or objective c, or java, or pretty much any language without much trouble. edit: the real elephant in the room is that python3 should have either been a new language, or it should have been an iteration. It is neither and has suffered.
From the docs: [Using csvkit as a library](http://csvkit.readthedocs.org/en/0.7.3/index.html#using-as-a-library) Edit: oops, I guess that doesn't encompass all the functionality, sorry. Edit2: looks like you could import a utility, look at the way it's called from the command line and call that class directly from your code.
LPTHW would not really be on that list, as it is free(for the most part.)
I'm glad this was posted in response to "python 3 is killing python". We've just decided to move our simulation software to Python 3 and the previous article had me a bit worried about Python's fate. So it's good to hear a robust defense of Python 3, but there's also a bit of attitude in this post that I don't like: the idea that Python 3 is just the product of a bunch of volunteers coders having fun, why should they care about you and your problems with Python 2/3? You do what you want to do (including forking Python 2 if that floats your boat); let the Python devs do whatever floats their boat. But this attitude is actually not ok. Python is not just a fun experiment; it is a successful language as the Python.org website is eager to illustrate in the "Success Stories" section. Many businesses depend on it, a lot of money and innovation rides on it. And evidently, the python community thinks that's a good thing, it's maybe even a bit smug about it. So it's not acceptable to say that Python's devs can just hack away in a bubble of self interest. While Python 3 is hopefully not actually killing Python, ignoring the concerns of everyday Python users will kill Python. According to this author, that's ok because the Python devs are just volunteers having fun. But I don't think those devs would say that's ok. Python's success is a big part of what makes all their work relevant. So even if resistance to Python 3 is misguided, it is somewhat pervasive, and the Python community ought to have a good (i.e. not merely dismissive and patronizing) answer to those concerns.
"Python 3 can guarantee full employment for mediocre tech bloggers"
&gt; That's what the original poster said. No, he said sys.argv was bytes. Easily disproven with a Python interpreter. &gt;&gt;&gt; import sys &gt;&gt;&gt; type(sys.argv[0]) &lt;'str'&gt; QED. You are correct about the sane way to deal with it, this is how errors are normally dealt with in programming for a very long time. If you _choose_ to "give up" on error handling, feel free to just write bug-ridden filth. After all, that's what's left of Python 2 recalcitrants. 
Signed up and will give it a try!
I was actually forced to switch to CherrPy recently as it was the only thing supporting a proper in-python SSL server on Python 3. Flask's just bugs out in its SSL code.
That's the dumbest thing I've ever heard for so many reasons.
yep; this /r/circlejerk approach to the issue (oh, I work in python 3, and so do all my friends, its great!) is really the problem. I think its particularly telling that Guido himself works primarily in python 2 at Dropbox, and unsurprisingly we now have support for the 2.7 line in security patches to 2020. At least a few of the core developers must be awake. The OP raises a valid point. It *is* an open source project. If you want change, you have to actually get involved, not just complain. ...that said, is encouraging the complainers to fork and start 2.8 really a good idea? (no, it's not; its a flat out terrible idea. It'll divide the community *even more*). Making python 3 compellingly better than the 2.x line is really the path forward.
&gt; A PEP? Which I suspect I have to fill out canonically. Just write a document in rst, put it in a repo somewhere, note whats included in other modern PEPs and format similarly, then post it to python-dev ML and ask what's missing. If you're afraid of the boogyman then you ain't never gonna contribute anyway. &gt; Or how about somebody out in internet land forks 2.7, calls it 2.8, fully backwards compatible, puts in unicode properly, and then ends up with the defacto version. Which is easy enough: hit the fork button on bitbucket or github, checkout the 2.7 branch, port some low-hanging-fruit from python 3, add a tag called 2.8dev, and then blog about it. Which begs the question, why has noone done so yet? My answer is that in their heads they have an inkling that the orginal developers decided to write a BC break with a new major version for bloody good reason. Writing new stuff and fixing behaviour while keeping backwards compat is no longer a simple thing in Python 2. It's not a fresh and fun codebase to work with. Ask one person after another if they want to pony up for the pain and take up the rains, for free, and they'll shy away. All the while continuing to yell on blogs that someone should be doing it anyway.
*Easier maintainability* Less KLOC is better for maintenance. If there are tests, they should all be passing; with coverage. *Parsing Messages* Java has strong support for XML. Python has some XML support in the standard library. External XML modules are largely written in C. *Multithreading* In Python -- as with most languages -- it is much easier to debug and develop multiprocess applications; which, by design, are more easily distributable. There are threading primitives, but the GIL remains the limiting factor for threaded Python applications. * Twisted has been around for awhile, but not everyone groks callbacks. * Asyncio is new in Python 3.4. * http://www.reddit.com/r/Python/comments/21liyy/design_flaws_in_task_queue_frameworks_wichert/cgerv5l There are lots of Python libraries for various standard protocols and interfaces. *Message Brokers* * https://github.com/celery/kombu * https://github.com/saltstack/salt/blob/develop/salt/transport/__init__.py * RabbitMQ is built on the Erlang/OTP (telecom) platform. * https://stackoverflow.com/questions/12634965/differences-between-amqp-and-zeromq : &gt; AMQP is a protocol. ZeroMQ is a messaging library. &gt; &gt; AMQP offers flow control and reliable delivery. *Enterprise Python* * http://docs.spring.io/spring-python/1.2.x/sphinx/html/ (XML configuration is decidedly un-pythonic) * https://github.com/openstack (http://www.openstack.org/foundation/companies/) * There are lots of great testing tools for Python: http://www.reddit.com/r/Python/comments/1drv59/getting_started_with_automated_testing/ * Instrumentation tools make it very easy to identify hotspots that could/should be (carefully) rewritten in C * http://www.reddit.com/r/Python/comments/1ohpyt/how_and_why_bank_of_america_decided_to_rebuild/ *Java -&gt; Python* * http://docs.zope.org/zope.interface/ * https://westurner.github.io/redditlog/#comment/ca4e8qd [Edit] 
To be fair, Java would also not be a good choice for realtime requirements. At least you can turn off GC in Python when it would be disadvantageous.
Also, free books will have much lower sales numbers.
This is link bait, pure and simple, designed to get people to click links to affiliate-linked amazon products. Many of these books are terribly outdated, dangerously so in some places. For example, on the list is the decrepit Django book as well as the 1999 edition of Essential Python. On the other hand, the attention this is receiving leads me to think the creators of this page are on to something. :P
... * http://json-ld.org/ * http://www.w3.org/TR/ld-glossary/#x5-star-linked-open-data
It works, but only because there are a lot of hacks to get it all to work: http://ncoghlan-devs-python-notes.readthedocs.org/en/latest/python_concepts/import_traps.html http://lucumr.pocoo.org/2012/6/22/hate-hate-hate-everywhere/
No, there's no need for three books. What "Learning Python" needs is for an editor to go through with a pair of scissors and remove at least half of the content. 800 pages would be more than enough to comprehensively cover the language features with decent examples to the same depth that it currently does - it just requires better writing/editing. It also makes the mistake of trying to be both an introduction for people who know absolutely nothing about programming and a completely comprehensive language reference book at the same time. "Learn Python The Hard Way" does a (much) better job at the former, and the official docs do a better job at the latter. It's a throwback to the days when programming books were written like encyclopedias with no concern given to how people actually learn. 
It is an iteration. The version number iterated from two to three. I'm not sure what you mean.
&gt; boat(row) :D
In 2020 when python2 is at EOL, it may make sense to fork to keep the python2 line with security patches (not to add new features) or add python support/binaries for some new OS/architecture that didn't exist in 2014. Not to encourage new projects/work in it, but just for people who need to maintain legacy python2 programs. (E.g., need to re-run the old unmodified code in a long running experiment). There's absolutely no need to do it now, and while someone could try -- I doubt anyone would gain any traction doing so. Granted then again, things like trollius that backport specific features from python3 into python2 seem like worthwhile endeavors if you are currently using python2 and want asyncio, but can't/don't want to go python3 yet. These projects are the result of forking and renaming the project. Granted it won't be python2.8, it will be python3's blah feature implemented as a library.
You might want to have a look at https://zato.io/
I agree completely. I thought it was a wonderfully sarcastic way to get the point across :)
In 2008 I started a [Python 3-only project](https://github.com/brechtm/rinohtype). Now, as the project is finally maturing, I feel the need for it to run also on Python 2, as I'd like to reach an audience that is as large as possible. Note that next to CPython 2, there's also Jython and IronPython that both seem to be stuck in Python 2.x land (but PyPy3 is in fairly good shape, it seems). I did manage to backport the code to Python 2 some time ago, making sure the same codebase still runs on Python 3. Unfortunately, there are some things that make this unpleasant at the least. For example, metaclass definitions need to be specified in different ways in 2/3. It would be great if Python 2 would also support the Python 3 syntax. Similar to the re-addition of the unicode literal u"" to Python 3 and "from __future__ import unicode_literals" in Python 2, this would be a minor change that could greatly simplify having a unified 2/3 codebase. Also, the Py2 str / Py3 unicode thing is very tricky to get right, but I'm not sure how this could be simplified. There are also some Python 3 features that are not present in Python 2 which cannot be remedied by a third-party library. This stops me from adopting these Python 3 features. One example is Python 3's function annotation capability (which I'd like to use for type checking). Again, having support for these in Python 2 (even if they are simply parsed and ignored) would be great. I think that the move to the (backward-incompatible) Python 3 was a good one, but in hindsight, perhaps more thought/effort should have been put into making the upgrade path as smooth as possible. Some tools have been given to the Python developer over the years (from __future__ import &lt;py3_thing&gt;, u"") to help with this, but I think they should have been available from the start (yes, easy to say now). Something to remember for Python 4 or 5?
By 2020 hopefully we'll have tools to convert any language to any other language, so we won't have to worry about all these divisions - programming will be universal. :-)
I know this is just one man's opinion but in my experience people fight much harder against change than they do for change.
I've found this useful in many of my projects so instead of copying a file around which doesn't belong to the project and that I'm unsure of putting in version control I decided to make it into a package so I could just install it using pip. Hopefully someone else might find it useful.
doesn't work or simply I don't have clue how to do it correctly. I followed this thread https://mail.python.org/pipermail/soap/2011-May/000453.html but seems it doesn't really help them as well. Badly need this to work..arggh.
My numpy/scipy/scikit-learn stuff works fine on Python3.
PyOpenGL is "just" a ctypes wrapper around OpenGL (and EGL, AGL, WGL, GLU, GLUT). "just" because it also handles python and numpy types transparently for your convenience. Pyglet, pygame, pyqt et al. are toolkits, they provide an abstraction above the windowing systems (opening windows, handling events). Some of them (e.g. pyglet) also provide opengl bindings, but you can also use PyOpenGL with Pyglet. In short: - opening windows, handling events: GLUT, PyQt, Pyglet, Pygame ... - doing opengl: PyOpenGL, Pyglet ... - higher level graphic API (e.g. 2D): Pygame, ... 
I'm not sure I understand the question, but the sh module is a decent abstraction over subprocess: https://pypi.python.org/pypi/sh
take a look a Julia. It is still not on par with python, but it'll catch up pretty soon.
The distribution system is independent of the Python version, and is being fixed. Attempts have been ongoing since before Python 3. It's a difficult issue.
The point of Python 3 is to fix problems in the language itself. That's also what causes the problems. New libraries are not a problem and not a solution. :-)
Not the only reason. Some depends on libraries that are hard to make support Python 3.
Internet explorer 6 works for pretty much everything my colleagues do. Yet they have upgraded to new versions of firefox/chrome. You want to future proof your codebase. Python 2 has 5.5 years of support left and is not developing as a language, python 3 will be continued for decades and is evolving and improving.
See, you're expecting volunteers to make a powerful free language which businesses use commercially, and then when they want to change it, you expect them to do it in a way that is commercially viable and easy for those businesses? Why don't you expect the businesses that make money using *free* and *open source* software to donate money and always make sure to steadily port their code to newer versions of python? Because it's too expensive? Because it's cheaper to let the community of volunteers do it for them for free? I think that's ridiculous. And when their code becomes old and unmaintanable because they didn't want to spend money earlier, they complain that it's the communities fault for their problems? Why should the volunteers care? They make what they want to use, they aren't employed by the businesses. Should they hold back their ideas and their project because it's too expensive for some business? 
Just email the author.
I did not really want to bother him but I will give it a shot
For those reading this section in the future: There is [a rebuttal](http://sealedabstract.com/rants/python-3-is-fine/) published two days later. ([reddit link](http://www.reddit.com/r/Python/comments/26n0kd/python_3_is_fine_sealed_abstract/))
&gt; One of the great strengths of Python 2 is the long tail of 3rd party libraries to do, well, just about anything. It is true that the "tail" is shorter, because loads of these long tail of Python 2 libraries are unmaintained, so nobody is updating them to support Python 3. But if you use them, maybe you could take over a few libraries and maintain them? If everyone did that, then this problem would be solved in a month. &gt; Python 3 doesn’t have this. Yes, a lot of libraries have been ported, but ten times as many have not, and are not trivial to port. That's not true. There are libraries that are not trivial to update, this is definitely true. I was an unofficial de-facto maintainer for one library until I tried supporting Python 3 with it, and realized I needed to completely change the API for it. That made me a bit exasperated, so I lost heart, and somebody else later took it over. Some libraries and frameworks are simply BIG. Zope and Plone has so much code, and some of it is so old, quirky and weird (because it was written in the 90's) that I can't see it EVER supporting Python 3. The Plone community simply doesn't have the manpower or incentive to do that. And some libraries are hard to get onto Python 3 because what they do is hard. But this is NOT the majority of libraries. The majority of libraries that doesn't support Python 3 do not support Python 3 because the libraries either are unmaintained, or because the maintainer hasn't tried yet. &gt; There is a good chance that a parser has already been written for X in Python 2 and has not been ported to Python 3. Additionally, given the fundamental differences between Python 2's byte string (str) and Python 3's byte string (bytes), it will not be easy to port, in fact, it will be difficult to port and will require quite a bit of trickery to port it in such a way as to maintain Python 2 and Python 3 compatibility. If it's badly written, so that it constantly relies on implicit coercing between unciode and ascii, then yes, that will take a lot of work. Or if it uses dunder str, (how do you make inline code in this markup?) in which case you need to fix the API. Otherwise, no. &gt; port the library (and all its dependencies) which will take ten times as long No it won't. FUD. &gt; Choice #2 is obviously not popular Because of FUD. &gt; Popular libraries that support Python 2 and 3 are almost all written in a subset of the languages that runs on both platforms. SQLAlchemy, one of my favorite Python libraries, does this well. Django does this, too, but not so well. This subset language, which I will call Python X, is not fun to use, requires weird hacks, and generally is less powerful than either Python 2 or Python 3. Well, if it's fun or not is a matter of taste, the weird hack to use is called "six". But it isn't hard to use this "subset". In fact, when I wrote Hovercraft and the svg.path library I needed for it, I wrote this in that subset more or less automatically. I fact, Hovercraft was intentionally written to be Python 3 only. But the only reason it doesn't run on Python 2 is because I don't WANT it to run on Python 2. Fixing it seems to be mostly a matter of requiring an extra module under Python 2 that is included in the stdlib under Python 3. But I haven't fixed it, because I don't want to have to run the tests under multiple versions when I develop. &gt; How fun is it to port existing Python 2 libraries to Python X? Not fun at all which is sad because fun used to be what made Python so great. It's SHITLOADS of fun. Unless you have doctests. Then it's a horrorshow. &gt; One solution is to fork Python 2.7, and continue developing the language, adding features in a backwards compatible way What features, exactly? &gt; Features from Python 3 that can be backported to Python 2 should be And those features are...? The rest is just silly hyperbole, so I'll ignore it. 
I need to make it clear that the Medium article is not mine. I simply read it, got interested what the community would say about it, and posted it here. Please, have that in mind, in case you downvote or write your criticism. Please, do not target it at me. Thank you!
maybe, only because the made interop with python possible.
The internet can shut the fuck up.
Of course. You can't rewrite every single python library in just a few years.
Yeah, but compare that strategy with PyPy and Python3.
There are JVM's out there that allow for realtime Java. There is even a Real Time Specification for Java. 
Sadly, mostly trough personal network, which is currently small. Someone I had worked with before knows someone else who might benefit from my service. So yeah, I am interested in where should I "be" to find interesting work :)
I don't agree with that - if there was a concerted effort it would get fixed.
Example of bugs? I've never had any issues with numpy moving to python3.
What python3 strategy? python3 is just as slow as python2. And pypy is a very nice idea, but it also requires porting and rewriting every library that's written in c and also has that annoyin GIL... Don't get me wrong, I really like python, just not for technical computing.
Off the top of my head, crashes in the masked array module, crashes in the scipy optimization functions, going to and from pandas / numpy loss of precision (our unit tests failing).
&gt; partly because that would lessen the incentive to move to Python 3. Well, they are shooting themselves in the foot if that's what they are thinking. Python is a platform, which means that it derives its value not directly from the applications to which it gives value, but through libraries. Which makes migration pretty awkward, since libraries must support both versions for quite a while until most applications have migrated. Which, in turn, results in a counter-intuitive need for Python3 compatibility in Python2 (on the language level, as libraries, as `3to2.py`) as a requirement for smooth migration to Python3. Because you want people's libraries to be written in Python3 and backported to Python2, not remaining a Python2 codebase on which 2to3.py and a bunch of custom patches is run once a month. On the other hand, when the time comes, nobody will say "I can't be bothered to install Python3 in order to remove all those `from future import`'s and compatibility libraries and stuff _that I added to be compatible with Python3_, I'm just fine with awkwardly using Python3 features in Python2". That's a complete non-concern compared to the very real hurdles that delay Python3 adoption.
I'd say there's discontent with GPL in programming community in general. GPL talks loudly about freedom, while actually restricting it and going through Orwellian contortions in redefining what freedom is. If you want the most people to be able to use your code, go with a sensible permissive license, and don't fantasize about evil companies stealing your brilliance.
&gt; Well, they are shooting themselves in the foot if that's what they are thinking. A lot of people do claim they stay on Python 2 because Python 3 doesn't offer any incentive to move, so that's why they are thinking like that, I'd guess. &gt; Python is a platform, which means that it derives its value not directly from the applications to which it gives value, but through libraries. Which makes migration pretty awkward, since libraries must support both versions for quite a while until most applications have migrated. Right. And having more new features in Python 2 is not going to change that. &gt; Because you want people's libraries to be written in Python3 and backported to Python2, not remaining a Python2 codebase on which 2to3.py and a bunch of custom patches is run once a month. That's really only relevant if you still want to support Python 2.5. Otherwise you don't use 2to3 anymore, but use a common codebase. Yes, if you want Python 2 support, then you can't use the Python 3 only features. But that is only a problem for people who are already mainly using Python 3, and then afterwards discover that Python 2 might be nice as well. And that is currently a very small group of people. &gt; I can't be bothered to install Python3 in order to remove all those from future import's and compatibility libraries and stuff that I added to be compatible with Python3, I'm just fine with awkwardly using Python3 features in Python2. Huh? I'm sorry, that makes no sense. 1. You don't need to remove the things you added to be compatible with Python 3. I'm not sure what you are trying to say with that. 2. If you added things to be compatible with Python 3, you presumably installed Python 3. How else would you know that you are compatible? 
If your SOAP library is well behaved, it would either have a local copy of that DTD or will request it once then cache it. Check if there has been a newer release or if there is a patch you can apply. Also, if possible, try your script on a server with internet access and see if it caches it, then replicate that on your original server. If not, then the quickest solution is probably to add www.w3.org to /etc/hosts and provide a local version of that DTD.
No it's an admission of lack of backwards compatibility, which never was a promised feature in the first place and is an issue which affects community and business driven projects alike. Blaming others for a decision, which was announced well ahead of time with an incredibly long grace period is a sign you're too slow to change rather than faulty decision making by the contributors.
&gt; i'll assume everyone who makes that statement is naive and can't be taken seriously. ie: hobbyist, picked up programming last month, wrote a web scraper and now fancies themselves an expert. :P 
I would love to start using python 3, but there's no argument I could make that would convince my employer to let me convert our code base. We develop against the RHEL supported python version, which currently means 2.6. We sell our software to our clients, who run a mix of our core software and custom software, some they developed and some we developed. There's no way we could force our clients to upgrade, so we would need to support two and three simultaneously. Presently, none of our clients are even faintly interested in python 3, even if our own developers are. To move to python 3, we'd have to port at least a hundred thousand lines of code to maintain compatibility with Python 2 and 3. Maybe we can do that in a week, but developer time is awfully expensive to spend a week on something our customers aren't paying for. Since we have to support python 2 side by side, we can really take advantage of the new python 3 features in much of our code anyway. We use a bunch of third party libraries. I'm sure most of them support python 3 by now, but a few won't, which will mean porting them ourselves. We have pretty good test coverage, but it's not perfect, and frankly I'd be shocked if we could do this conversion without a few bugs slipping through to production. So then we've got clients calling about quality issues because we made a change they see zero benefit to. From a business management perspective, I see a time consuming task with minimal benefit and quite a few risks. Until we have a contract with someone who wants python 3 and is willing to pay a premium for it, there's no way to convince the bean counters it's a good idea. The way things are going at work, we're implementing more and more application logic in javascript on the browser, as it enables a more seamless user experience. Our python server applications are getting thinner, just doing data persistence and validation, and less of the work flow and presentation. I imagine that this trend will continue, and wouldn't be surprised if we start working in node.js for the server side, leaving python for a handful of legacy application that will slowly be superceded. It won't be a planned move from one language to another, rather a slow obsolescence. Understand, I like python 3. I have a few projects on github that are 2 and 3 compatible, so I know it's not that hard to do. For personal projects, I tend to write python 3 without worrying about python 2 compatibility (which is really the only way to get the benefit of python 3).