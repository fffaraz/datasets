I'm going to wait until I have a more complete game. I posted here for people to look at the code (yet I think I may have been a little premature on that too).
[edit: disregard, had my python v2 hat on.] You should probably use *raw_input* instead of *input*. *input* expects a valid python expression, so you'll have to surround your Xs and Os in quotes while running the program, like "X". *raw_input* returns the text as you've entered it instead of trying to interpret it as python. This will let you just type X or O without quotes. edit: your guide seems to suggest otherwise. Maybe that changed since it was written? Maybe my system is just weird.
The original article was really helpful and I'm sure this one will be too. Although I never used the full setup you described it did give me a nice "menu" to select useful ideas / plugins from. Thanks for putting it here. 
&gt;Now ~~all~~ it needs is a good text editor I also find the speed to be irritating. Although it's no longer outright slow it still is slower than _______. Software is the opposite of outrunning bears: you've got to be the fastest, "not slowest" isn't good enough. edit: formatting.
Also you have a bug in the isBoardFull function; the last line should be unindented by one, i.e.: def isBoardFull(board): #is true is all spaces, taken, otherwise false for i in range(1, 10): if isSpaceFree(board, i): return False return True instead of def isBoardFull(board): #is true is all spaces, taken, otherwise false for i in range(1, 10): if isSpaceFree(board, i): return False return True Your version checks the first square only before returning, the correct version checks all squares.
I recall when I started the project I renamed all the classes to follow PEP8, I've clearly backslid when adding new ones or altering existing ones, I'll get that fixed. The force close window is because I'm not sure what the quit commands for a Windows or Linux box should be, currently it's only tested on OSX. The spawning of enemies and placement of towers is nothing like what I plan for it to be when completed. I'm using it at the moment to test pathfinding, animation, targeting and shooting etc. No I didn't benchmark that assertion, I should have. I always understood that a hash-map lookup is faster than a select/elseif statement. I also doubt the performance there matters much either, the main slowdown will almost certainly be graphically related I'd expect.
I've been using pyplot a lot lately, and I think overall its great. Beautiful graphs (unlike R, unless I'm missing something...), decent documentation, good interface, decent amount of examples online. I ran into a couple limitations which I had to hack around and even resort to MS paint to get, like, labels and illustrative lines and such and so the way I wanted them, but nevertheless. I especially like the options you get with a graph on the window output.... you can save in multiple formats, but more to the point you can move and zoom your graph. Very useful.
Why not contribute to jokosher instead?
It's on "crazy fast" speed to allow me to test stuff faster. I didn't know there was a quit event, I'll add that.
The graphics are indeed messed up there, did my reversi game look okay to you? I'll work on that quit thing, didn't know there was a quit event (figured I needed to hard code that part). I posted it to Python hoping for (and getting) feedback on the coding itself, I'll be posting it again when it's complete. I'll edit the readme and code for the 80 character width. *.pyc is already in my git ignore (done via a GUI so it may not be doing it correctly). Thanks for all the feedback :)
yeah. planning to learn a web framework. So fordeployment, i might try them :)
You can always use scipy to take the fourier transform of both arrays, multiply them together, then take the inverse fft. Bam, your arrays are convolved and its fairly fast.
Because I knew I would get raged on coming into /python and saying that. :)
Why wont NLTK support easy-installing? They depend on PyYaml, but dont declare it in their setup.py, so it has to be manually installed before even attempting to install. Last time I checked (a day or so ago?) they had even messed up with the linking to their files: $ easy_install nltk Searching for nltk Reading http://pypi.python.org/simple/nltk/ Reading http://nltk.sf.net/ Reading http://www.nltk.org/ Reading http://nltk.org/ Reading http://www.nltk.org/download Best match: nltk 2.01rc1 Downloading http://nltk.googlecode.com/files/nltk-2.01rc1.tar.gz error: Can't download http://nltk.googlecode.com/files/nltk-2.01rc1.tar.gz: 404 Not Found Don't get me wrong, I like the project and all, but trying to deploy something using it is horrible and requires workarounds all over the place.
I think this may have fixed my problem, since now the program runs fine. However, now when i run the program, only one player is allowed to input x's or o's and he can fill the whole board without the programming stopping him from either winning or filling the board. Like so http://pastebin.com/tfM2Uq2J. *sigh*, i guess i'll have to take a second look. Thanks! 
Kdevelop has support for python and for vim controls I believe. Didn't try either though...
No problem! You can try approaching that problem by considering: * how does the program decide whose turn it is? When should it swap between the two players? * When the first player picks X or O, how does the second player's symbol get decided? Assigned? Stored? Have fun!
Also, their mouse-oriented nature. There are lots of nice feature in Eclipse, but having to make multiple clicks for them is killing me.
You are probably using Python 2. He's using Python 3.1. In Python 3 "input" IS the old "raw_input".
Like the turtle they used to have for the bbc micro
I'm using vim for so much these days I try using the hjkl keys to navigate comment boxes.. and emails, and everything else. So sometimes i'll send an email with random vi letters in there without knowing it.
I can play the name game too 0) Linux kernel uses git 1) Pylons uses git 2) Reddit uses git 3) Rails uses git 4) Android uses git 5) Majority of open source projects are hosted on Github, which is centralized around ~~hg~~ **git**. Why not use hg? Hg is distributed thus making it superior to svn, cvs, or visual sourcesafe (lol?) but hg is too clunky. Repos are unnecessarily large in the background and not to mention hg's bugs out when you have large files. Not useful when teams want to put a database dump on source control.
It mostly boils down to refactorings, but people rarely use those. IDE's get to have some awareness of the whole project that you are working. So you also get fancy and debuggers, profilers and any other tool that are automatically configured.
ahh right, that explains that, I don't know much about python 3. Interesting that that's the only issue that popped up executing python 3 code on 2.7.1 was fixed with input=raw_input
So you like a little abuse, eh?
Python has a nice simple, lightweight nature to it, while Eclipse is huge and burdensome. I'll stick with Emacs or Geany any day.
no fun without it. ;)
[Vimium](https://chrome.google.com/webstore/detail/dbepggeogbaibhgnhhndojpepiihcmeb) for Chrome or Vimperator for Firefox :)
Thanks, I will try this. When I multiply the transformed arrays, I multiply element by element, right? I don't do a matrix multiplication
There are plenty of exceptions to this philosophy though (like Emacs). Or perhaps it's wrong to think of Emacs as being Unix-y. 
With a good vim interface those features could be mapped to key combos or ex commands
&gt; I can play the name game too You demonstrate that you can not, as you utterly failed to comprehend my comment. 
Now you're just hating on me.
actually the new hotness is [scrypt](http://www.tarsnap.com/scrypt.html).
is there a fugitive alternative for mercurial?
This is super helpful, especially since I've been trying to make Vim my primary text editor for a while now, with mixed success. I thought gVim would help the transition, but I found it made some things even harder, like OS clipboard integration. 
http://www.vim.org/script.php?script_id=90 Works for others too.
Reddit Extended Suite has good keyboard shortcuts specifically for reddit.
&gt; The graphics are indeed messed up there, did my reversi game look okay to you? Yeah, Reversi looked fine (nice job on that one). &gt; I'll edit the readme and code for the 80 character width. Thanks! It's much more readable. &gt; *.pyc is already in my git ignore (done via a GUI so it may not be doing it correctly). Strange, because I didn't see a file named `.gitignore` in your root directory. Make sure it's not just your IDE ignoring those files, but git itself.
Oh, I like scrypt a lot. Just the concept of memory-hard functions is cool. I just don't feel comfortable advocating scrypt yet - I'm still trying to make sure I understand it fully, and that it doesn't have any major flaws. It has some parts which seem oddly complex / obfuscated to me; i'm still trying to figure out if i'm missing something or just not fully understanding the design requirements yet. Also, the choice of the Salsa20 core seems rather odd to me - not sure why he didn't use a standard and tested primitive like SHA256/512 - that would have also helped portability, instead of having to trust the builtin &amp; modified implementation of a non-standard hash. Almost motivates me to design a memory-hard function that can be implemented more portably, and with a cleaner reference spec. Another thing that would be useful is scrypt was buildable as a shared library - it's not exactly, just some linkable .c files oriented around a command-line utility for encrypting files. And even that code doesn't officially expose the primitives needed to use it's kdf properly, it just exposes the bits used by the command line tool - and that isn't quite appropriate for password hashing. And there's a bit of a jump between the design in the PDF and the code. All in all, it makes it feel like scrypt wasn't designed to hash passwords, even though I know it *can*. Hence my hesistancy :) --- edit: referring to Salsa20/8 as "non standard" I mainly meant not NIST-approved or similar, or supported by openssl, my two personal touchstones :) also, according to wikipedia, Salsa20 seems to be falling to attack faster than SHA512.
Vim is just as extensible as Emacs. However, I will greatly disagree with you about Eclipse being "fast". Eclipse is dog slow, especially on my Mac. 
I think his #3 is the turning point. I don't know that I agree with the point *but* Jython is free to choose whatever they want.
Great article. One question: I sometimes try to use VIM for things other than Python work. A lot of these plugins and configurations aren't really useful for things other than Python. Is there a way to load a different configuration depending on filetype?
Yeah only #3 is valid to me. However, it's more fun when you can make someone nerd rage and name call over a silly comment. =]
You're a programming tourist. Like all tourists, you expect someone to roll out the magic red carpet, so you can avoid all the problematic trouble you're clearly too good for. Obviously, someone of your taste, sophistication, and juvenile age deserves to ride roughshod over the knuckle-dragging "grey-faced drones" anytime he likes, except when he needs their help with something.
or vim.
You ought to give mutt a try then, it uses vi-style key bindings.
http://www.vim.org/scripts/script.php?script_id=3472 Hg specific, mostly does "read" stuff (st, log, diff...)
Yes, vim too would be a good lightweight solution to doing python compared to Eclipse. I think the real issue boils down to the fact that writing Java, C, C#, etc can be quite burdensome and having the fat IDE can be beneficial, but in python, it's just not nearly as big of a problem as writing python is clean and simple. Vim isn't bad, it's just not my thing, I don't like moded editing. That's why I said "I'll stick with", I was only specifying personal preference. 
I would argue it is wrong. ITS-y perhaps?
Not to be a debbie downer, but this application is pretty much a good example of what python's NOT good at, due to the realtime requirement, and potentially rather heavy math required. (At CD quality you're at 44, 100 samples per second * no of tracks * 2 for stereo. Recording with simultaneous playback in software is very tricky due to latency, and basically impossible with typical consumer sound cards (that includes Creative, built-in, etc, basically anything not intended explicitly for recording). The latency can be quite significant due to the buffering on that card.... 100ms is probably about the lowest you'd be able to achieve stably, and 200-300ms wouldn't be surprising. At 250ms, that's a 16th note at 120bpm. 
I've been using ipdb for years to do this. It works in the same way as this, except there is some nose integration out there (--ipdb --ipdb-failures, checkout nose-ipdb) and its interface is the same as the standard lib pdb, which I think is probably a good thing; looks less foreign to pdb users, and it's simple to set multiple traces. http://pypi.python.org/pypi/ipdb EDIT: Not for years it seems; I was using a coworker's code to do this until ipdb was released and I started using it widely.
So, as an aside, it looks like [gunicorn can be used via paster](http://gunicorn.org/run.html#gunicorn-paster). I will still update the docs, but its definitely worth looking at--especially since the alternative is implementing it in code.
So, I'm adding an additional reply because I decided to look into this, and here's the answer to your question: http://stackoverflow.com/questions/1167903/middleware-for-both-django-and-pylons The first answer indicates that you *can* use it in Django if you're launching it as a middleware application. In that sense, linesman (which is WSGI middleware) works. What you CAN'T do is use it as "Django middleware." I'm currently looking to see if I can't provide both sides.
He has everything listed except a debugger. 
For me its the debugger. I've found the PyDev debugger much easier to use than pdb, but if it wasn't for that, I'd probably be using the OP's setup right now.
I don't know about python audio, but nyquist has powerful audio features, including compression and audio editing routines. I think it is used inside the Audacity application. It runs with LISP commands, and I am not aware of any python interface. It sounds like you might have some hardware challenges to ensure that multiple playback is synchronized with record--you'll have to experiment. If you have troubles, you could merge the multiple playback into one file then play the one file. As for the GUI, you can do that last and use the GUI to call the command-line routines. http://www.cs.cmu.edu/~music/music.software.html http://www.cs.cmu.edu/~music/nyquist/index.html
I guess it's time again to praise the great [jVi Netbeans plugin](http://jvi.sourceforge.net/) that's being constantly improved. 
The differences between this and reversi are that the background is dynamically drawn and the active objects are sprites (the latter I suspect may have something to do with it). I'm using .png images but I did that with reversi. Any idea what else it could do it? Glad you liked the reversi game :)
Emacs is a highly opinionated product, but it subscribes to different philosophy—particularly that everything is a macro (LISP all the way down). 
KDevelop is a fine IDE, as well. However I would rather have a DE-agnostic environment, even if that means living with whatever behaviour that cannot be fixed by installing an integration-plugin. Maybe there's a way to unify the plugin API between different IDEs? That'd be even better, though perhaps not in the near future. 
IDE is about integration. To really appreciate Eclipse, I think you need first to learn all of these tools, that you have mentioned, and only then you *grow into* the harmony that a modern IDE provides. As an experiment, if you're using bzr (or if not, you can just use bzr-git to play with it), you should try the q-commands. Doing everything from command line is fine, and often much faster, but try using qcommit instead of commit, or qdiff instead of diff from time to time… you'll be hooked in couple of days. Now, of course launching GUI from command line may be a bit awkward, but bear in mind, that it will not be so, with the real IDE. And soon you'll discover, that using a keyboard-shortcut (Ctrl+Alt+...) is just as fast as switching to command line. The reason people get discouraged to IDE is, in my opinion, that they always think of them as some sort of children-version of their favourite tools. It's, in fact, the opposite, so make sure you know everything your IDE can offer you first, and don't learn new (or your first) IDE on a deadline. Just like with learning VIM, you'll get the benefits only after you're fluent.
slows you down so that you can code more deliberately
&gt; I will greatly disagree with you about Eclipse being "fast". Eclipse is dog slow, especially on my Mac. You need 2G+ of memory to work comfortable, I'll grant you that. But once you're of out swap, I haven't noticed Eclipse being “dog slow.” Perhaps, you should make sure that you're using the most recent version (Eclipe 3.6 ‘Helios’) and most recent version of JRE (desktop edition).
Even if it is, as you claim, I'm still going to place my bets on supporting Eclipse and making it the fastest and bestest free development-environment ever, rather than instead succumbing into writing for archaic platform, that has become a platform, in the first place, only because of its killer “plugin” (ex-mode). That said, I've been successful in comfortably using Eclipse on a cheap netbook, so I'm not entirely convinced of the things you claim. 
What do you mean by "DE-antagonistic environment"? I don' really know what that means. I mentioned KDevelop just because I use it for a C project at the moment and it's a nice IDE. I didn't really work with anything else (just tried some for few hours) so I can't compare. And I've never written (to) any big project in python, so vim (without any plugins) was just fine.
The problem is, for Android development, Eclipse 3.5 is still required. But even 3.6 is pretty slow. 
DE stands for “Desktop Environment.” KDevelop is heavily relaying on KDE libraries. I know, that this is only superficial, but it'd be an unnecessary burden for an IDE to overcome. If, on the other hand, your IDE makes no assumption about the platform (like Eclipse doesn't make) it can embrace, much like Firefox, the heterogeneity of the platforms. That said, I'm just talking here about placing bets, supporting what I think, has the best chance of success and will be most beneficial to all kind of developers. If you're, however, doing mostly C/C++ you should probably stick to KDevelop, since it's, indisputably, one of the best free IDEs for that family of languages. 
I do that all the time:wq
Excuse me, but who in his right mind is putting database dumps in source control?
 au FileType &lt;filetype&gt; ... stuff here
It was just an example. You'll see surprised to see what people put in source control. A database dump was just an example. EDIT: Regardless of what it is. My points are still valid.
I don't think that will happen anytime soon. [Flask](http://flask.pocoo.org/) depends on werkzeug and Jinja2 and that is a good thing. [Bottle](http://bottlepy.org/) has a strict "no dependencies" policy and that is a good thing, too. Both frameworks have their right to exist. But fear not, I am working on a plugin for Bottle that adds support for werkzeugs Request/Response objects and exceptions and integrates the interactive debugger. Jinja2 is supported anyway, so, with that plugin, you could turn Bottle into Flask quite easily. Edit: I am Marcel :)
A quick check says that it is indeed being excluded on mine, here's a copy of .git/info/exclude # git ls-files --others --exclude-from=.git/info/exclude # Lines that start with '#' are comments. # For a project mostly in C, the following would be a good set of # exclude patterns (uncomment them if you want to use them): # *.[oa] # *~ .DS_Store *.pyc *.graffle
What are the "q-commands" you refer to? Too lazy to google this early in the morning, sorry :-). &gt; Just like with learning VIM, you'll get the benefits only after you're fluent. This is a valid point, but I find it a bit off-putting to be honest. All of the tools I listed above have relevance outside coding and I use them every day, even when not programming. Putting a similar amount of effort into learning a tool that's not so useful for general text munging, data recovery, system administration, using in a shell script feels like a bit of a waste.
Take a look at the [examples](https://bitbucket.org/birkenfeld/karnickel/src/365f66d722e7/example/)
And what does `cat .gitignore` say? What about `git status`? Here's what I get: $ cat .gitignore cat: .gitignore: No such file or directory $ git status # On branch master # Untracked files: # (use "git add &lt;file&gt;..." to include in what will be committed) # # engine/__init__.pyc # engine/engine.pyc # game/__init__.pyc # game/classes.pyc # game/rune.pyc nothing added to commit but untracked files present (use "git add" to track) Then again, on my copy: $ cat .git/info/exclude # git-ls-files --others --exclude-from=.git/info/exclude # Lines that start with '#' are comments. # For a project mostly in C, the following would be a good set of # exclude patterns (uncomment them if you want to use them): # *.[oa] # *~ Remember that changes to your `.git` directory that don't go through `git` itself aren't checked in, as far as I know. I modified `.git/info/exclude` manually, and while the `*.pyc` files disappeared from `git status`, `.git/info/exclude` didn't show up as changed. Your best bet: actually modify `.gitignore`, as that is the standard means of ignoring files with `git`.
&gt; KDevelop is heavily relaying on KDE libraries. I know and sympathise with your pain, but I've since got over it. I guess this is another example of unix philosophy being thrown out the window: every desktop environment now consists of a whole suite of applications that share the same libraries and interoperate best with their own cousins, so the easiest path is to use a homogeneous environment, with the WM effectively dictating which file manager, web browser, terminal, mail client, media player (.....) you use. But I'm sick of that. And disk space is cheap now. If I happen to like nautilus, kmail, urxvt and lxde by god I'll install them all and cry softly to myself at night about the wasted RAM from all these unshared libraries and poor integration.
&gt; Vim is just as extensible as Emacs Vim user here but I'll heavily dispute that. Vimscript is an unholy abomination and the various vim-(language) versions are like sowing the front of a chicken onto the back of a motorbike. Elisp isn't without its problems but at least it's a language. And for all the plugins vim has, emacs does things like w3m, org-mode, inferior-lisp, gnus. They don't call it an operating system (that needs a decent text editor) for nothing.
Yeah, good idea - then we can merge everything into Django. We don't need all these frameworks. 
I like mutt for that but I think it needs a cheat sheet like the OP with a heavily customised .mutt/ + .muttrc to make it a bit less awkward to deal with "modern" email.
&gt; It mostly boils down to refactorings, but people rarely use those. Doesn't sound like a compelling point if people rarely use them :-). Also, refactoring is structured text editing, right? Yeah that's what I do with vim. On all different kinds of structured text. Your other points are valid I just felt like picking a nit.
&gt; What are the “q-commands” you refer to? Too lazy to google this early in the morning, sorry :-). It launches various modules of [Bazaar Explorer](http://doc.bazaar.canonical.com/explorer/en/index.html) independently in the context of your current repository. You can quickly see how useful a well-crafted (and unintrusive) GUI can be, in certain situations. &gt; All of the tools I listed above have relevance outside coding and I use them every day, even when not programming. A good IDE, like Eclipse, builds on your knowledge of these tools. What you need to get fluent in, is the *project-oriented* workflow, that is unique to an integrated environment. This is quite different to the filesystem-oriented workflow, to which you're probably accustomed. EDIT: Typo.
Oh you know, I love KDE and the integration it offers is absolutely phenomenal. The problem with professional software, like Eclipse or Libreoffice, is that the effort to reinvent it for particular platform outweighs the benefits. With products like that, a different approach is needed—it should be made as modular as possible, and then seamless integration into a rich platform, like KDE, can be achieved using plugins or by providing alternative frontend. We can have the cake and eat the cake, but in the meantime let's make sure the bakery is up and running. 
These look like tests, not really examples beyond what is immediately obvious. I was more interested in seeing how easy (or not) it is to use to write something that you'd see in an average LISP program.
So should I add a .gitignore file? I'm still very new to git and CVS' in general.
import pdb; pdb.set_trace() is a debugger! Thats all I ever use. There is vimpdb but I haven't ever seen the need.
I think now that I'm using pathogen + git submodules it'll be much easier to replicate across systems.
you so silly
Yep, element by element. In python, as long as they are arrays, just do array1*array2. 
result = real(abs(ifft2(fft2(image)*fft2(wave)))) Here is the line of code that I use to do this in my research. image and wave are 2D arrays about the size of a camera photo. You might have to insert an fftshift() in there somewhere if the output looks wonky.
thanks. please and if you have time write a tutorial on writing your own lightweight python web framework.
well refactoring tends to imply some-sort of context awareness. For instance: A simple function re-name in eclipse also looks into files that refer to that function and changes their name too. It may sound silly but LOTS of bugs are introduced through people underestimating the difficulty of a refactoring. I really do think that it's the only thing that makes an IDE different than a text editor. 
which should be poured into the other?
Exactly: $ echo '*.pyc' &gt; .gitignore I doubt most people do this, but you can check out the `gitignore(5)` manpage if you have it installed: $ man gitignore 5 Here's a good guide (I didn't know about `.git/info/exclude`): [http://help.github.com/git-ignore/](http://help.github.com/git-ignore/). I would say excluding `*.pyc` goes into `.gitignore` because it's something everyone who runs your application will generate automatically. Meanwhile, [ignoring `.DS_Store` can go into your *global* ignores](http://augustl.com/blog/2009/global_gitignores), since that's specific to your environment, you won't check that in, and you don't expect everyone who runs your application to generate such files. (I'm learning a lot about git ignores from this, too!)
I'm still a little uneasy with relying on an IDE to completely understand the source language in order to perform such refactorings reliably. Given how quickly some languages introduce new syntax and constructs, and the sheer difficulty of correctly parsing some languages, it just makes me uncomfortable.
&gt; rather than instead succumbing into writing for archaic platform, that has become a platform, in the first place, only because of its killer “plugin” (ex-mode). Vim isn't "archaic." Its scriptability is one of the main reasons I use it over an IDE like Eclipse. What you're saying is like, "People only use Linux because of its killer command line environment." Well, yeah, it's *one* of its selling points. &gt; That said, I've been successful in comfortably using Eclipse on a cheap netbook, so I'm not entirely convinced of the things you claim. The nature of the argument is between things like Eclipse and Vim/Emacs. In general, Eclipse is going to be slower. This shouldn't be a surprise to you. Perhaps that slowness isn't a problem, but surely, it is slower. The point is whether Eclipse using those resources is worth it or not. I generally find it to not be worth it. However, I do find the Android mode for Eclipse particularly useful.
&gt; Python has a nice simple, lightweight nature to it Perhaps I am misunderstanding, but are you claiming that Python is *lightweight*? o_0
Thank you very much!!! This worked very well!! If I don't get the FFT multiplication method working (which is supposed to be faster), I'll keep doing it this way. 
I've been doing it with iPython. I have a debug_shell function I can drop in anywhere.
Yes, I see your argument, but compare python with C++ or Java *as a language*. As a language, it has a sense of minimalism about it.
The refactoring tools provided by eclipse are quite mature. I've seen studies where bugs were introduced that wouldn't have happened if the refactoring had been done by eclipse. But lots of people just don't trust them or really take the time to learn them. C'est la vie :)
SimpleTemplate rulz
That's a great idea, I had never heard about that. Thanks for the tip. Do open source projects such as these allow you to use it to make websites on your own domain name? I'm new to the open source process so I'm not sure if things like licensing are an obstacle.
First, let me improve your appalling metaphor, I'm not a tourist, I'm a migrant: I just moved to mac - do you see the title up there? I'm looking for someone who can help me overcome the cultural differences and get on with being a productive individual. The grey-faced drones I refer to are people like you, though I don't extend to the term to everyone on reddit. I may be arrogant, but I'm not boring. The worst thing about you is that you're not even bright enough to realise that your little napoleonic tirade just makes you look pathetic and deperate - like you didn't end up with the life you were expecting. Maybe nobody bothers with you because you're so obviously talentless and lame. So in compensation for these short-comings you hop on reddit occasionally to squish a few bugs. You can't hide the fact that some great sphinx has eaten up all your brains and imagination. I hope you find a piece of it again - otherwise the time from now until you're boxed up at last is going to be pretty fucking dreary. 
Does it really sync everything? My understanding is that Dropbox MD5s everything before syncing, and if it finds the MD5 already up on the server then it won't bother to upload it again. This makes it much faster to deal with minor changes like moving directories around.
When you talk about the number crunching, do you mean the wave functions of the sound processing itself? I'm unclear as to what you mean. I'm a math major, so I'm excited about learning that side of programming.
You are a brave man to go public with such a request. A lot of people would just write their own framework in this situation (to be read as "one more web framework") :-)
[A related post.](http://lucumr.pocoo.org/2011/1/22/python-the-web-and-little-things/#variety)
`C-c pdb` in my emacs drops a one-liner that trips ipdb and rehooks stdout in case it's in a nose runner.
Glad to see more and more gnome application can be extended with python
&gt; Vim isn't "archaic." Its scriptability is one of the main reasons I use it over an IDE like Eclipse. Maybe calling it ‘archaic’ was an exaggeration. I don't see, however, VIM as a growing ecosystem. The fact that its core part—the text editor—automatically excludes more than half of the potential users doesn't help. This is, of course, non-optional, since, as I've mentioned before, VIM is not an IDE—it's a text editor with scripting support. &gt; What you're saying is like, "People only use Linux because of its killer command line environment." Well, yeah, it's one of its selling points. This is invalid because Linux didn't start as a ‘command line environment’ from which it'd have supposedly grown into an operating system. &gt; The nature of the argument is between things like Eclipse and Vim/Emacs. No, I wouldn't group them like that at all. Eclipse and Emacs should be in the same category, while VIM's analogues include Notepad++, Kate and Textmate. Emacs is the original IDE. It's *built on* the premise of extendibility, and its text-editing facilities are only a part of the picture (it even has a VIM mode). It originates, however, much like VIM, in the pre-GUI era. And of course, LISP hasn't exactly enjoyed quite the popularity and adaptation, that has been expected. Which is why my support is for Eclipse, rather than Emacs. &gt; In general, Eclipse is going to be slower. This shouldn't be a surprise to you. No, that's not obvious. There's no rational reason why it must be any slower than VIM or Emacs supporting the same set of functionality. &gt; Perhaps that slowness isn't a problem, but surely, it is slower. In my *subjective* opinion, Eclipse does not suffer from any speed related issues, that could hurt my productivity. I'm sure though, that there is a room for improvements and I'm positive that these opportunities will be exploited, given sufficient time and resources. On the other hand, if you're going to say “*surely*, it is slower” you must present objective evidence, for this claim to have any value. &gt; The point is whether Eclipse using those resources is worth it or not. I generally find it to not be worth it. Unless you're working via a terminal connected to a mainframe, there's no point in that argument. &gt; However, I do find the Android mode for Eclipse particularly useful. I'm glad you enjoyed it. You should also check out other modules available for Eclipse. I find PyDev 2.0 to be particularly noteworthy. 
NumPy allows you to work much faster than pure Python in the case of arrays of fixed data types such as int16 and float64. That said, peted27_'s suggestion is a better idea. jokosher leverages the power of [GStreamer](http://en.wikipedia.org/wiki/GStreamer) and [LADSPA](http://en.wikipedia.org/wiki/LADSPA) effects. For the GUI, it uses [PyGTK](http://en.wikipedia.org/wiki/Pygtk). What do you mean by "make websites"? Is this for distributing the code and documentation? Or are you planning to make a webapp like Aviary's [Myna](http://www.aviary.com/tools/audio-editor) audio editor?
For the lazy: Armin says that Marcel doesn't want any dependencies for Bottle whereas Flask tries to use some dependencies to make the framework more flexible. A merger simply isn't possible due to the different approaches.
I'm sorry I was drunk yesterday...
Another imrprovement is to choose numbers as representation for players. If you choose 1 and 4 for example, you could just sum-up the rows and cols. 3 inidcates that player1 has won, 12 counts for player 2.
I love gedit to bits... but have been forced to use Geany because of a feature I deem ABSOLUTELY necessary for development; indentation guides. Is there any way someone might point me in the direction of creating these? Or is there a plugin available that I don't know about?
http://www.reddit.com/r/Python/comments/h44tv/python_33_to_drop_support_for_os2_windows_2000/
&gt; ... "use PyGObject bindings for GLib, GObject, Gio, and GTK. This is the replacement for PyGTK." This looks great. Anyone know of any overviews or tutorials just on PyGObject in general? 
Upboat for honesty :p
I got hooked up so bad on mouse gesture that I can no longer live without them. :) I wish there was a system wide availability for something like this. 
It's a consistent cross-platform development platform. 
Hi. Interesting project. You may be interesting in [pyfilesystem](http://code.google.com/p/pyfilesystem/) which has a little overlap with your module. Regarding the __eq__ method. Comparing the hashes is not a sure fire way of checking they have the same contents. It is possibly, albiet highly unlikely that two different files have the same hash. The only way to be absolutely certain is to check them byte for byte. It's also worth returning False if the file sizes don't match. Since you can get that from the filesystem without actually reading the file.
&gt; ("Karnickel" is German for "rabbit", and there's a vicious killer rabbit in "Monty Python and the Holy Grail" that is best left alone...) There is a reason that subtle hint is there ;) The project is an experiment and generally there doesn't seem to be an obvious opinion on the usage of ast. That being said, if you want the abstraction power lisp macros give you: use lisp. Seriously you cannot even get close to that in python. Karnickel provides something closer to C-like macros which work on the AST.
Thanks for this. However, I need to convolve a CCD image with a kernel which is much smaller in size than the image, so I don't think this will work since I can't multiply the ffts of 2 arrays of different sizes
&gt; drops &gt; trips Your meaning is less than clear.
You might check out Sublime Text if you haven't already. It's much like Gedit (fast, lightweight, has the same sort of feel) but has some key features that Gedit is missing. I'm running the v2 Alpha (link: http://www.sublimetext.com/blog/articles/sublime-text-2-public-alpha) on Ubuntu and it's been great so far.
As I noticed, if you chmod everything, Dropbox starts working like crazy. I think it updates metadata (file permissions) for all the files. Since the contents of the files didn't change, that part is not uploaded of course. But if you have lots of small files like in my case, updating metadata can be expensive too.
Does anyone know a security person who might be interested in this? The implementation is new and I'd really appreciate a code review / sanity check.
You could try Geremy Condra, I know he does research on security and is also a Python person, no idea if this is really his area of security though.
&gt;drops inserts &gt;trips ...tripping the debugger and injecting context/stack frames.
Had you thought about not inheriting from `dict` and instead inherit from `collections.MutableMapping`? Instead of storing things in `self[key]` for instance, you'd store it in `self._dict[key]`. This way, calling `dict(mysecuredict)` won't work. It seems like this would be relatively easy since you're already overriding most, if not all, of `dict`'s methods.
My (not very good) rationale for subclassing `dict` is so that programs that expect `dict`s and do `isinstance(..., dict)` continue to work in most cases. How would using `MutableMapping` prevent `dict(mysecuredict)` from "working", though? If the object implements `keys`, `dict(...)` will call its `keys` and construct a dict. I don't think the implementation could tell the difference between a call to `.keys()` and CPython's `dict` constructor calling `.keys()`.
Ha! I have stolen your code and will now make millions selling it as an iPhone app. Your code looks fine, but I don't have much gamedev exp so I can't comment too much.
My way of doing this is not pretty, but it works and it also requires no additional imports. Where I want to get a debug prompt, I just type: fail That's not a Python keyword. It's probably not a defined variable. So it'll crash, which starts ipdb because I always run things in IPython.
Speaking of isinstance - you should use it too (instead of type(bla) == foo). It's faster and more reliable.
Not what I was expecting. I know `yum remove python` also removes yum, thus uninstalling python means you can't reinstall it, or anything else later.
I really like this idea. However, I am curious as to how it handles UDP traffic. If I was creating a secure tunnel, I'd like to ensure that my DNS requests went through the vpn. I am aware that if you only want to do http proxying via ssh you can use the -D flag and tell you web browser to do the dns query though the socks proxy.
The problem is in how you're generating your POST data. This line: data = urllib.urlencode({"termcode" : "11A", "alltermcode" : "'11A', '11U', '11S'", "collcode" : "", "day1" : "M", "day1" : "T", "day1" : "W", "day1" : "H", "day1" : "F", "timeselect" : "any", "bok" : "", "deliverymode" : "", "keyword" : ""}) The problem is that you're generating a dictionary and then passing it to urlencode. Urlencode can handle duplicates (the multiple day1 entries) but {} can't (A dictionary has to have one value for each key, that's just how dictionaries work). So Python is merging all those day1 key/value pairs into one key/value, then urllib.urlencode is generating a search string that's only searching on one day of the week (Friday, I'd guess) So what you need to do is switch to [the alternate mode of urllib.urlencode](http://docs.python.org/library/urllib.html#urllib.urlencode). Instead of a dict, pass a sequence of two-element tuples, and pass True for the doseq argument. Like this: fields=( ("termcode" , "11A"), ("alltermcode" , "'11A', '11U', '11S'"), ("collcode" , ""), ("day1" , "M"), ("day1" , "T"), ("day1" , "W"), ("day1" , "H"), ("day1" , "F"), ("timeselect" , "any"), ("bok" , ""), ("deliverymode" , ""), ("keyword", "") ) data = urllib.urlencode(fields,doseq=True) 
Does anyone else not care about Python 3 at all? I have zero motivation or desire to port my code. Even if there was perfect library support for it, I wouldn't. Why should I care? I don't like this big shift.
Do you mean the general case (I agree), or the use of `type()` in `_securehash_hasher`? I used `type()` there to avoid hashing subclasses of those built-in types. (There's no guarantee that that would work correctly.)
pentadactyl is a fork of vimperator with most of the original developers (i'm not involved at all). while largely the same on the surface, it seems to work much more how i would expect it than pentadactyl with little things or annoyances. you can also turn on keyboard shortcuts in gmail and it uses some shared shortcuts.
Thanks for your feedback... I have been playing around with pyfilesystem lately and its nice... but a complete file system abstraction is a quite different undertaking than a little file object convenience wrapper ;) ... what i was missing in pyfilesystem was the ability to write to zip based filesystems... Regarding the __eq__ method it was stupid to use the md5 hash not just because of possible hash collision (i think chances are 1+2^128 ;.) but also performance wise... I made an update to py7file that uses the stdlib filecmp module and also compares with file objects and strings that reference files... 
I'm a bit confused by the implementation of `_securehash_hasher`. Specifically: https://github.com/ludios/Securetypes/blob/master/securetypes.py#L29 : elif t == bool: h = sha1('\x00') # "number" if obj: h.update("1") else: h.update("0") * Why treat bools like numbers? https://github.com/ludios/Securetypes/blob/master/securetypes.py#L35 : elif t == float: h = sha1('\x00') # "number" rep = repr(obj) if rep in ("-0.0", "nan"): h.update("0") elif rep == "inf": h.update("314159") elif rep == "-inf": h.update("-271828") elif rep.endswith(".0"): h.update(rep[:-2]) else: h.update(rep) * Why use `0` for `nan`? * Why use `314159` for `inf`? 
Excellent. Works perfectly pulling all classes. This makes total sense too. Thank you so much for the help and the knowledge. This is definitely something I'll be carrying throughout the project as we have several other URLs to get data from that will require POST data. Who's awesome? You're awesome.
Check out ZipFS :-) http://packages.python.org/fs/zipfs.html#module-fs.zipfs
Wait, we can do that now? What happened to UserDict?
Yes, in _securehash_hasher. Why wouldn't they work correctly ?
The typo in your subject is a good example of why reddit isn't the best place to ask for technical support. Tried irc?
[Since Python 2.6](http://docs.python.org/whatsnew/2.6.html#pep-3119-abstract-base-classes)
&gt; My (not very good) rationale for subclassing dict is so that programs that expect dicts and do isinstance(..., dict) continue to work in most cases. FYI, you can still do that using [*class*.\_\_instacecheck\_\_](http://docs.python.org/py3k/reference/datamodel.html?highlight=instancecheck#class.__instancecheck__) and [*class*.\_\_subclasscheck\_\_](http://docs.python.org/py3k/reference/datamodel.html?highlight=instancecheck#class.__subclasscheck__) &gt;&gt;&gt; collections.MutableMapping.__subclasscheck__(dict) True
[shrugs] When a common description of Python is "is comes with batteries included," I find it difficult to associate the term "lightweight" with it. But yes yes, it's all relative and you emphasized the word "language." I'm still finding it difficult getting on board... Python has comprehensions, decorators, meta-classes, magic functions, etc... (Don't get me wrong, Python is one of the funnest languages to program with.) Now a language like Lua is lightweight. It only has one data structuring mechanism!
lol i give this 2/5 stars Here's a nickel, kid. Get yourself a real computer.
So what is this problem you are using your amazingly interesting talents to solve?
iPhone autocorrect. But on irc, haven't tried asking for help there before. Will do, thanks.
&gt; I don't see, however, VIM as a growing ecosystem. I see new plugins all the time... &gt; The fact that its core part—the text editor—automatically excludes more than half of the potential users doesn't help. It does? How? &gt; This is, of course, non-optional, since, as I've mentioned before, VIM is not an IDE—it's a text editor with scripting support. Was someone disputing this? o_0 &gt; This is invalid because Linux didn't start as a ‘command line environment’ from which it'd have supposedly grown into an operating system. That it didn't "start" with it does not make it invalid... &gt; No, I wouldn't group them like that at all. Eclipse and Emacs should be in the same category, while VIM's analogues include Notepad++, Kate and Textmate. If you want to reframe the debate, that's fine. I was remarking upon the current discussion. &gt; No, that's not obvious. There's no rational reason why it must be any slower than VIM or Emacs supporting the same set of functionality. Yes, it is obvious. Fire up the default eclipse and fire up the default vim. Look at which one uses more resources. I didn't say Eclipse *must* be slower. I said it *is* slower. &gt; On the other hand, if you're going to say “surely, it is slower” you must present objective evidence, for this claim to have any value. You're mistaking the reality of speed and the value of speed. I never claimed that Eclipse suffered speed related issues for anyone. I even stated, "Perhaps that slowness isn't a problem." If you need objective evidence that Eclipse is generally slower than Vim, then I don't really see any point in conversing with you. Are there cases when Vim can be slower than Eclipse? Of course! Is it generally the case that Vim is faster than Eclipse? Of course! Like I was trying to say, this slowness may not be a problem, especially if you have a sufficiently powerful machine. Even if you didn't, the slowness may be a meager price to pay for Eclipse's other benefits. (When I say "slowness" I don't mean some objective notion of "slow"---I mean that it is slower than Vim.) &gt; Unless you're working via a terminal connected to a mainframe, there's no point in that argument. Uh huh. So you know how I prefer to use my computing resources? Lol. &gt; I'm glad you enjoyed it. You should also check out other modules available for Eclipse. I find PyDev 2.0 to be particularly noteworthy. I have. I work more efficiently in Vim. (I do not use Vim because it is leaner on resources. I use it because I perceive it to be a more efficient workflow for my tastes---and I highly enjoy its scriptability.) I'm not copping out either. I've completed several projects with PyDev, and I agree, it is quite nice! I likely have not seen the last of Eclipse---especially if I do any more programming for Android.
Downboat for being a karma pirate.
Or you could just use a real text editor. ;)
I think we can agree that in the end it just comes down to subjective preferences. It seems also that I was arguing against a point that you don't seem to be pursuing—that VIM is an acceptable substitute as a developer *platform*. Since my main objections was against that, I'm glad we don't disagree on that note. Let me just clarify some meta-points: &gt; That it didn't "start" with it does not make it invalid... It does because you've presented it as an 1:1 analogy. The fact that it isn't quite 1:1 turns it into a straw-man fallacy. It may be a valid argument on its own, but not in the aforementioned context. &gt; Yes, it is obvious. Fire up the default eclipse and fire up the default vim. Look at which one uses more resources. Using X amount of resources *is not the same* as being slow. These are hardly even correlated. Other than that, please note the context in which I've mentioned it in the first place: &gt; No, that's not obvious. There's no rational reason why it must be any slower than VIM or Emacs *supporting the same set of functionality*. As to: &gt; I do not use Vim because it is leaner on resources. I use it because I perceive it to be a more efficient workflow for my tastes---and I highly enjoy its scriptability. This is the filesystem-oriented vs project-oriented workflow. This is why I believe it ultimately comes down to one's subjective preferences. &gt; I'm not copping out either. I've completed several projects with PyDev, and I agree, it is quite nice! I likely have not seen the last of Eclipse---especially if I do any more programming for Android. I still believe that turning VIM into an IDE is suboptimal to just porting VIM for Eclipse, but I'm glad that, you too, see Eclipse as a worthy candidate for free and modern developer platform of the future.
You're a fucking moron man.
&gt; Why treat bools like numbers? In Python `True == 1`, so `hash(True)` must equal `hash(1)`. Same for the 0/False case. `securedict` needs a hash function that does the same. You can't have both a `True` and `1` key in your dict/securedict, for example. &gt; Why use 0 for nan? No good reason and it'll be fixed to use `id(nanObj)` soon. &gt; Why use 314159 for inf? I'm doing what Python does, just in case someone relies on `hash(float('inf')) == hash(314159)`. (There will soon be a public `securehash`) Thanks for taking a look. I might add comments to clarify some of those cases.
I'm calling `repr`/`str` on the object, and if someone has subclassed one of those built-in types, there is no guarantee that `__repr__` returns a unique representation for the value. For example, `__repr__` here ignores the `hi` attribute: &gt;&gt;&gt; class myfloat(float): pass ... &gt;&gt;&gt; f = myfloat(3.45) &gt;&gt;&gt; f.hi = 3 &gt;&gt;&gt; repr(f) '3.45' Threre's an issue open for using any object with a `__securehash__` as a securedict key, so it will eventually be possible to use more objects (including subclasses such as these) as keys. Edit: fixed example
Ah, very interesting! Thanks.
Yep, but sadly ABCs (and `__subclasscheck__`) are Python 2.6+ only. I need this to work the same everywhere in Python 2.4 and above.
When you store that `securetuple(…)` as a key in dict, the dict calls `hash()` on it anyway. You should probably be aware of it. If all you want is to generate secure hashes, this is how I think it'd be better implemented: 1. Use context manager (consult stdlib's `decimal` module to see how to implement one) to store the salt etc. settings. Then you can just: with SecureContext(salt=…): sec_dict = SecureDictionary() 2. Instead of using `dict.__setitem__(secure_key)`, [influence](http://docs.python.org/reference/datamodel.html#object.__hash__) how hashes are generated: class SecureHashWrapper: def __hash__(self): securecontext = securedict.getcontext() return secure_hash(self, securecontext.salt) and then in your `SecureDictionary.__setitem__()`: class SecureDictionary(collections.MutableMapping): def __setitem__(self, key, value): wrappedobj = SecureHashWrapper(key) self.__dict[wrappedobj] = value Well as I said, I'm no security expert, but I believe this puts you implementation-wise closer to what you wanted to do. Though, if you want to do it correctly, then you will have to do it on the implementation level—as a CPython module, since the `__hash__` result is limited to a long integer and that *isn't quite enough for the 160bit sha1 message in the first place*, so you could be using any ordinary salt then [anyway](http://stackoverflow.com/questions/4865325/counting-collisions-in-a-python-dictionary/4867536#4867536). Or you can reimplement `dict` in pure Python. 
This is why I love python. &gt; There should be one-- and preferably only one --obvious way to do it. s/one/one per point release/.
&gt; that VIM is an acceptable substitute as a developer platform. Well, it is for *me*... &gt; It does because you've presented it as an 1:1 analogy. The fact that it isn't quite 1:1 turns it into a straw-man fallacy. It may be a valid argument on its own, but not in the aforementioned context. You would be correct if your original argument relied upon such a thing. Namely, "writing for archaic platform, that has become a platform, in the first place, only because of its killer “plugin” (ex-mode)." Nowhere does your criticism rely on the fact that the "plugin" mode was there from the start. (I have now re-read your original quote, and you say "in the first place." Perhaps "from the start" is what you meant. If so, I'll concede the point. I'm sure there is another analogy in waiting, but I cannot find it at the moment...) Analogies are supposed to be different in some respects---the key is that they are the same in the respects that matter in the current context. &gt; Using X amount of resources is not the same as being slow. These are hardly even correlated. Using more RAM and more CPU is going to cause a process to run more slowly than a process than needs less RAM and CPU when resources are scarce, ceteris paribus. &gt; This is the filesystem-oriented vs project-oriented workflow. Sure. I enjoy both kinds of workflow. I like that Vim can adapt to either workflow rather easily. &gt; This is why I believe it ultimately comes down to one's subjective preferences. Sure, but that goes without saying when discussing reasonable tools. &gt; I still believe that turning VIM into an IDE is suboptimal to just porting VIM for Eclipse I think I have yet to make that determination. Lately I've been working on a lot of small projects related to course software (testing student submissions and what not), so that kind of work is heavily biased towards Vim.
&gt; s/one/one per point release/. Actually, I'd argue *per release*, since 2.6–2.7 was introduced precisely to ease transition to Python 3. Your ‘pure’ Python 2 is still in the UserDict/basestring land. And even Python 2.7 still has UserDict: Python 2.7.1 (r271:86832, Apr 12 2011, 16:15:16) [GCC 4.6.0 20110331 (Red Hat 4.6.0-2)] on linux2 &gt;&gt;&gt; __import__('UserDict') &lt;module 'UserDict' from '/usr/lib64/python2.7/UserDict.pyc'&gt; 
Good to know, thanks.
Could you translate what this means for a newb?
Will check that out!
Yeah sorry, "point" was my cynicism coming on a bit too strong. UserDict was one of my favourites as well, as it broke ''isinstance'' and dict-likes are particularly poor candidates for duck typing.
Yeah sorry, "point" was my cynicism coming on a bit too strong. UserDict was one of my favourites as well, as it broke ''isinstance'' and dict-likes are particularly poor candidates for duck typing.
&gt; dict calls hash() on it anyway. You should probably be aware of it. I'm definitely aware. I don't have a proof that `hash(("marker", "sha1bytes", "key"))` is secure, though. Perhaps it's possible to attack it by making a special key that completely "overrides" sha1bytes, regardless of what they are. (But this is very unlikely.) Re: #1, why would I want to use a ContextManager? Applications need to be able to instantiate `securedict`s just like they instantiate `dict`s. Re: #2, I'll think about it. I don't see the advantage of using a `SecureHashWrapper`, other than some code clarity. Re: the last paragraph, is this really more secure than I'm already doing? I know that \_\_hash\_\_ is limited to 2\*\*32 or 2\*\*64, and my intent was to make the \_\_hash\_\_ of the key wrapper unpredictable. The current implementation probably achieves this. Note that if I used a secret/salt without the sha1, it would be easy to attack the securedict.
If you use zshell instead of bash you can write: setopt RM_STAR_WAIT in a file called *.zshrc* located in your home directory. Next time you type the command *rm* followed by anything, followed by *, instead of deleting everything the command line will show you a dialog and give you 10 seconds to cancel. Usually it takes less than a second to realize your mistake, and in the rare cases when you really want to delete everything the 10 second wait is negligible.
Wait a minit! I just realized, if I typed rm rf- /Library/ the command would only be complete if I added the asterisk...? Right? What difference does it make?
I don't claim to be security expert, so these were just things I thought maybe would be worth to point out. &gt; Re: #1, why would I want to use a ContextManager? Applications need to be able to instantiate securedicts just like they instantiate dicts. You can set up the implementation details (hash function, salt, etc) without making your code aware of that. So for example I could import someone's library, that makes use of your module, and decide that I have support for sha9000 on my platform and would rather use that. I can then just wrap it in my context and that's it, no need to contaminate the API, I don't have to rely that the module's author will implement necessary hooks etc. And again, *decimal* module is a good example of how to implement that design pattern. &gt; Re: #2 (…) Re: (…) Note: (…) I don't really see how hash+sha1 is more secure than hash+salt if you're ending up with in the same space anyway. Also doesn't it all come down to how CPython creates buckets for keys anyway? You're making huge assumptions about the implementation and I think the existence of hash() doesn't really help it. I can't help, but think, that any kind of collision prevention belongs in the underlying implementation and it's a bit naïve to think that you could influence that in any great manner by just passing differently-randomized hash in the same value space. Also, just to reiterate that your code is very implementation dependant, consider that Jython's dict is based on ConcurrentHashMap and has none of the issues your library tries to address (it resizes on collision).
&gt; And again, decimal module is a good example of how to implement that design pattern. Thanks. I'll take a look at it. &gt; I don't really see how hash+sha1 is more secure than hash+salt if you're ending up with in the same space anyway. If I use something like `hash((key, salt))` with a per-securedict salt, the adversary can still create collisions. The salt doesn't really do anything, even if secret. My first attempt was flawed in exactly this way. (See my earlier commits.) The problem is with `hash` itself; it's too easy to find colliding keys. Thanks for the info about Jython. I don't see how `securedict` is implementation-dependent though, as `dict` is *de facto* easy to slow to a halt. Anything better is a bonus that you can't really rely on. `securedict` is useful on at least CPython and PyPy (which hashes almost exactly like CPython). And as long as the Python implementation's `hash()` does just about *anything at all*, it's far better to have it also hash over a sha1 of the key. Of course it might just be a waste of CPU in Jython and other implementations, so I agree that it's not ideal.
It detects faces, not chins.
What is what you need exactly? You say you need help but I see no question being asked.
I'm going to guess that you are having errors where password is referenced before it is assigned. You should say: password = input("password:") while password == "pa55word": print("welcome in, "+user_input) 
Next question: How do you recognize whose face it is? (Edit: Not that I'm not satisfied with his work so far. It's done in surprisingly few lines)
 print("Halt!") user_input = input("who goes there?") print("what is the password?, " + user_input) password = "" while password != "pa55word": password = input ("password:") print("welcome in", user_input)
Here's a script i've worked on 5 months ago. Acts as a command line utility and a thin wrapper for OpenCV. https://bitbucket.org/dekomote/pyfacedetect/src/bd81f138633e/pyfacedetect.py
Next you can use a classification algorithm like a neural network
If it's going to end up costing more than EC2 (which the majority of threads in the Google App Engine Group seem to indicate), then I'm just going to switch over to Amazon. It's beginning to seem like this was all a huge marketing mistake, or else Google's truly considering alienating the long-tail of App Engine's developer user base. Also, what the hell happened to upgrading the Python version?
I understand where Google is coming from - AppEngine costs money. My app that uses the task queues burts up to ~200mb of memory (20 instances @ 10mb per instance) and I am paying nothing. However I think their current model is a mistake and will alienate users. Will it cost more than Amazon? Possibly, but they are different services. AppEngine has a lot of advantages over EC2 (The datastore, users api etc).
A few things are not quite compliant yet, ctypes support and the python C api is not complete, so quite a few libraries will not work.
 print("Halt!") user_name = input("Who goes there? ").replace('\r', '') print("What is the password, " + user_name + "?") while True: if input("Password: ").replace('\r', '') == "pa55word": break print("Welcome in, " + user_name + ".") There's a bug in my version of Python on Windows that leaves the carriage return character ('\r') in the string. A couple points about your code: 1. while password = "pa55word": This is a syntax error since you can't assign a variable in the expression of a while statement. The operator to test equality is a double equals (==). Moreover, what you want is to loop `while password != "pa55word"` (i.e. not equal). Also, it was already mentioned that password has to be assigned before you can reference it. 2. print("welcome in", + user_input) This is an error since it's attempting to apply the unary operator + to user_input. The comma needs to be in the string, such as the following: `"welcome in, " + user_input`. The latter + is a binary operator that concatenates the two strings. 
http://pypy.org/compat.html says that ctypes does work. Concerning the python C api, I'm clueless.
&gt;However I think their current model is a mistake and will alienate users. What exactly do you mean? It seems like essentially the same model, except with increased pricing (which I suppose is likely to alienate somebody, maybe me too) But I also understand that products usually have to make money to continue to exist.
numpy still isn't there
Once it supports the numpy/scipy stack (which won't happen via cpyext) I'm fine with this. Those are my current blockers. But for a lot of stuff outside of the numeric and scientific realms, this would likely be an improvement.
Very cool, useful app. Thanks! Since Group page serves as an overview of all the sites a user wants to monitor, it might be a good idea to have individual charts appear smaller by default, and tiled to fill the width of the page. Otherwise, you have to scroll up and down to get an idea of what's up (no pun intended). You could expand graphs on click, in a whitebox or some sort of gallery.
In the data generally used to train the haar cascade, chins are included.
Does Pypy support all the CPU/OS combos that CPython does?
Is there any way you could rewrite your programs to adhere by their quotas?
&gt; Concerning the python C api, I'm clueless. Well then, let's just go ahead and bless PyPy anyway then!
Here are the slides [as posted by Danny](http://www.slideshare.net/pydanny/python-worst-practices).
I &lt;3 pypy, I really want to use stuff like gtk with it, I'm not sure it's possible yet (also the new pygi bindings are for python 3). So, probably I'll need to wait for the next pypy. Pypy is awesome though.
Yes, you could write them to be as memory efficient as possible and perhaps save a few datastore calls, but in the end it all depends on the volume of traffic you receive. If you only get 50,000 DataStore operations per day then you can only serve under 50,000 requests (Assuming each request makes a datastore call). The new quotas slash the email count to 100 for free apps, which is a damn shame. Oh well :(
I'll add to that: 1. Not having a setup.py 2. Having a setup.py that requires setuptools/distribute 3. Calling your test package "test" or "tests" instead of "project.test" 4. Not installing your unit tests. 5. Not laying out your project like this: http://as.ynchrono.us/2007/12/filesystem-structure-of-python-project_21.html 6. Using sys.setdefaultencoding (ugh) 7. Assuming filenames are bytestrings (they should be Unicode on Windows) 8. Having unnecessary global state: http://glyf.livejournal.com/70684.html
They were too busy adding Go support I suspect.
Are you using Pydev? It isn't Python doing the "\r" as far as I know. I hit that when using the Pydev extension with eclipse.
I can see two major problems and one minor problem. First of all, you have a name error in the very first line. Under no circumstances should you capitalize function names (the function is called `print`, not `Print`). You also have a syntax error in line 4 (you probably meant `while password != "pa55word":`). Single equals signs are for assignment (the value on the right is bound to the name on the left), double equals signs are for equality, `!=` is for inequality (it's derived from the ASCII representation of a struck-out equals sign). Finally, you should rename `user_input` into something more descriptive. Apparently you're looking for a `name` or `user_name`.
I think they're trying to get more money out of it but no one wants to pay and tbh I don't blame them. App Engine isn't a problem as such when I use it but I just don't really trust it'll be there in a year and it's no like the code and just be plonked on another server. Sure you can reuse a lot of code but this whole idea of hosting that isn't totally portable is lame. I'll stick with Linode for now. Appengine is for playing and I'm not going to pay for a toy service.
The team responsible for the Go runtime is probably a different one. Python 2.7 is coming "soon"; no ETA but they say they are working on it.
Thats my point, it was nice because it was a toy service that could scale up to hundreds of requests per second easily. Now the bar between the "free" and "paid" versions has been lowered it will require an almost instant injection of money if your app has even moderate traffic. Also fuck Linode.
With Python being new to me, I've run tried all the variants suggested here, and I always end up with NameError: Name 'X' is not defined.
They are changing the free service from "Anyone can write webapps" to "Demo of our managed hosting". This is very understandable, it is just a major tone shift from the launch of appengine and has gone on mostly in the background.
and thoughts on a boolean defaultdict? it was suggested to me by a much better programmer to replace sets in my code and has made it much faster. i haven't done many set operations with it, though. i guess using a dictionary requires that your items be hashable, but i think that is also required for sets (i could be wrong on that though). from collections import defaultdict d=defaultdict(bool) d[name]=True ... if d[name]: #name in d else: #name not in d edit: formatting
It will never, ever be the standard Python without the C API. That's how important it is.
I agree with everything, but having a wiki instead of using "readthedocs" is a bad practice? Hm. That went a bit out of scope, or am I missing something?
Why the linode hate?
yay for developing on closed platforms!
Just like they reduced the free accounts on google apps. I guess it went like that a few month back: Larry: Hey Eric, how do we make money with gmail? Eric: Ads? Larry: mmok.. How do we make money with android? Eric: Ads? But we're mostly doing it so we can stick it to Steve. Larry: And chrome? Eric: Yeah, that. You know the guy from mozilla who tried to steal my girlfriend? I don't like him. Plus it pisses Microsoft to no end which is fun. Larry: Ok ok. but what about our enterprise stuff? like, hm, the search appliance and google apps premier, google analytics, the map API, our cloud stuff, that jquery CDN and all that shit. We give away for free? Eric: Ad.... Well we don't have ads on those really... Larry: So we have paying customers right? Eric: Yeah about that... We kinda have a 'demo' version you know for small site like 20 millions request per day. I mean... I originally I checked our analytics on google.com and I divided by 3 to make it fair. Help out small fish ya know. Larry: But we make money with it? Eric: In way the world is getting richer so somehow we should benefit yes. Positive externalities or something. Larry: .... Eric: .... Larry: Eric? Eric: Larry? Larry: I think I will become CEO. Eric: yeah... 
Yeah. Also someone may think that using getters and setters isn't good. Well, it isn't good for everything, but it's still good (because you can get or set with some parameters which you obviously can't do with properties).
&gt;**were never intended to make any money** Money has to get generated somewhere. Have you compared the incremental costs? If you burst to 20+ instances for a minute or two every hour, then you will consume what, 40 instance hours a day? Is that really much money? Compare the education you get there to what you got from college and then look at the respective expense. An alternative would be to focus your ideas on such things that have the potential to generate money. That means they have some value to someone instead of no value to anyone.
You are the first person that I've seen diss Linode. Have a story?
&gt;An alternative would be to focus your ideas on such things that have the potential to generate money. That means they have some value to someone instead of no value to anyone. That's a disappointing sentence in at lot of ways. For one, there are many things that are valuable in currencies other than money. 
Constant downtime, crappy service. Ended up starting my own VPS company.
Hi, I am the author of pymodbus and I thought I would comment on the current state of the python 3 branch. Right now all the code is passing the 2to3 conversion test, however, the problems that have already been stated are pyserial and twisted. I just checked and pyserial claims to be supported in python 3, however, the twisted port is only at 50% (and I expect it to be there for a while). All is not lost though, you can still use pymodbus without twisted as there is a synchronous implementation that uses the native python socket programming tools (socketserver, etc) and should run just fine. I haven't tested any of the code in python 3 so your mileage may vary, however, if you have an errors, enter tickets on the google code site and they will be fixed as fast as I can get around to them.
Any special reason? I've really never heard this from anyone. I've had 0 downtime myself for years now. Also, I queried about a distributed high availability system based on Ubuntu Server and was practically walked through it, with an associated [Linode Library article](http://library.linode.com/linux-ha/highly-available-file-database-server-ubuntu-10.04) created. Have you ever logged into their IRC channel? That is where I go if I want instruction. 
The only time I've had to downtime is because I restarted my instance just to restart it.
I guess it is that time in your life when you should ask yourself what the point of money is? If you are a farmer and you breed ants, will you get upset when no one wants to buy your ants and you slowly starve? You can either lobby for ant-farming subsidies or you can do something that is appreciated.
The bug shows up in Python 3.2 input() while running the interpreter in just a plain command prompt. It's an issue related to opening [stdin in binary mode](http://bugs.python.org/issue11272#msg128981).
The only major one we don't support is Windows 64 (because of the `sizeof(long)` vs `sizeof(void *)` thing). I'm sure there are obscure platforms that are untested which may or may not work (e.g. I have no idea what Open Indiana is, I know CPython has a buildbot for it).
pyexiv2 seemed fairly nice when I poked at it lightly.
You are right, and the PyPy guys agree. Python C API compatibility is in progress.
If he breeds ants has a hobby and has another day job for that, theres no reason to stop breeding the ants. If they impose a tax on ant breeding hed just stop and his awesome ants would be lost. In the future when his employer started investigating getting into the ant business he might say nah....tried that...bee breeding is cheaper. Hearts and minds generally preceed adoption and profits.
Yeah, it is called R&amp;D.
Do you know if there's any work being done on Windows 64, or if there's a good description of what the problem is specifically wrt pypy? My google-fu was failing me, mainly pulling up release notes. For what it's worth, OpenIndiana is basically Solaris.
And disadvantages such as not allowing table joins.
When you get down to it, the GSA, AdWords, licensed use of the mapping, etc. all cost serious money for the bigger customers. Frankly, I'm happy they're doing that because a commercial world supported by ads gets sort of incestuous at some point. And yes, I really did just compare advertising to sexual relations and I think I can defend that to the last little metaphorical nit.
Certainly there are many things in life that are priceless and beyond the crass considerations of commercialism. But, unless you've figured out how to eat good will and gratitude directly, use them for shelter, and use them to educate, feed, and shelter your children; you will at some point be reduced to accepting money for your priceless services anyway. Unless.... do you take chickens? Barter FTW! /s
linux was not company-invested r&amp;d. it was a hobby. python...hobby. ruby...hobby. perl...hobby. *now* there is profit and corporate backing around these tools. but if there was a significant financial barrier to entry for working on these hobbies, none of them would exist today. if google is looking for critical mass on it's app engine framework, they need to encourage a community around it. google is obviously aware of this....google search, gmail, android, calender, etc, etc, all free for the common use cases. they already know you can't create web services like this without encouraging non-business users to use it. not that i specifically have anything against their changes to appengine, but it is an important thing to note with a product like this what kinds of changes cause casual users to leave.
that wasn't really my point my point wasn't that sedaak was wrong either my point was that if this pricing structure change kills a bunch of hobbyist, entry level, or just non-profitable apps, it will be disappointing, and that a thing being non-profitable monetarily does not necessarily mean it has no value to anyone. If this has to be another instance where money talks and all else walks, then so be it, it happens every day -- but that won't stop myself from being disappointed. I had hoped that the platform could be profitable for Google as well as profitable for those with popular apps, while still remaining a viable, affordable option for those of us who don't have a popular, profitable app. (and perhaps it still may)
Just a nitpick, but this does not do what you think it does: True = False False = True # This is a no-op! He probably meant this: True, False = False, True
I don't agree that App Engine is dissimilar enough from web application programming that it requires a critical mass of "app engine engineers" in order to achieve commercial success. Also, hobby is what individuals tend to call R&amp;D. A lack of focus doesn't make it less so.
So why not have it modify the results to expand the box's dimensions by a percentage of their original dimensions?
Well, the bottom line here is that: - Even a hobbyist/beginner/charity has money to spend on their projects and if they want to use resources like this, they should expect to have some outlay for it. That doesn't automatically put it beyond the reach of smaller players, but it does mean they'll have to think rather more carefully about constructing apps to avoid waste. - If those customers do get a price break, it will be at the expense of someone else; probably on the dime of Google's premium customers. That's not necessarily a bad thing in my eyes, but it segues to my next point... I know Google's motto seems to be "don't be evil", but in the end, they're still just another public company with the same corporate dictates that drive every other for-profit entity. I wouldn't expect them to act like a charity, though of course I still expect public good to come from their continued existence, just as is expected from any other public company; else, why allow them the investment benefits associated with that status, but I digress a bit.
I was messing around with Tornado - it mostly works but pycurl does not seem to work with pypy 1.5
It's strange. My instance has been up and running for a year now. I haven't needed much service but all my emails have been answered within an hour at the top. Pretty much everyone seems to only have praise to say about Linode which is why I picked them and so far so good. You mention starting your own VPS company yet you can't afford pay hosting at google site / you're not even using your own VPS company to host your sites? I apologize in advance but this story is so incoherent it's hard to believe.
&gt; Having a setup.py that requires setuptools/distribute Buhu. There is a lot of stuff that does not work without distutils and many Python systems require distribute/setuptools. I know I require it for all of my projects. &gt; Calling your test package "test" or "tests" instead of "project.test" And why is that? &gt; Not installing your unit tests. What's the point of installing the unittests? &gt; Having unnecessary global state: http://glyf.livejournal.com/70684.html Yes, yes, a million times yes.
I've been using [EXIF.py](http://sourceforge.net/projects/exif-py/) for some of my image-related scripts and it works good, too.
I doubt that's the case. The Python C API is incredible crappy, it was just for a long time the only thing that made sense. I don't think anyone *wants* to write Python C extensions.
VPS's don't have huge margins and we are not a huge company. I could afford to pay for it, but the point is I wouldn't want to, those apps are nothing but toys with no chance of making the money back. I also thought about spinning up a VPS and using that, but I wanted to use GAE because its a lot easier and all the systems are in place (Memcache, the DataStore, the rather cool TaskQueue API, the Users API etc). I might well spin up a VPS for this kind of thing in the future, I must admit it is nice to use a relational database once in a while.
&gt;I don't agree that App Engine is dissimilar enough from web application programming that it requires a critical mass of "app engine engineers" in order to achieve commercial success. id say it falls in the boat as ruby-on-rails. i the end it's just a particular use-case of ruby in general, yet focused user communities help spread interest and company adoption of solutions based around it. &gt;Also, hobby is what individuals tend to call R&amp;D. A lack of focus doesn't make it less so. sorry if i misread you, seemed like you were suggesting company r&amp;d was a realistic replacement for non-financially-motivated work people do in their free time.
I'll try that, last time I tried to use R in RStudio (which is cool) directly but was defeated by the R syntax.
Use the latest version of Tornado, it no longer has a pycurl dependency (and in benchmarking tornado I've seen it's generally 2x faster under PyPy, and I think we can do better even).
I think someone might be working on it, but I'm not sure, I think this thread has many of the details: http://codespeak.net/pipermail/pypy-dev/2011q1/006747.html
That's not why it's important -- it's important because there are entire swaths of packages that would need to be rewritten, and Guido has stated that he doesn't want to ever seriously break compatibility. But yes, I agree that it's crappy for several reasons.
&gt; It's important because there are entire swaths of packages that would need to be rewritten Same needs to be done for Python 3 or the stable ABI. So either way C extensions have to be adapted and I would argue that the minimal extra amount of work that is needed to expose these things via ctypes instead of the C API currently is worth the extra work.
use a list
You just want to store the content of the variable 'user'? array_of_usernames = [] &lt;your code here&gt; array_of_usernames.append(user)
read a fucking book. this place is for interesting things happening in the python world, not learning the first principles of programming.
&gt; hosting that isn't totally portable Actually, http://appscale.cs.ucsb.edu/
There is a clone. Maybe more. Don't know what state they are in but they exist. Problem is that it only "works" on small scales. You just don't have the resources AppEngine can provide you.
http://docs.python.org/tutorial/datastructures.html# Link to the docs about lists.
Google? Hobby. Apple? Yep. Hobby.
thanks, but I thought he was new only to Python, not to Google search :-) 
really you need to do this homework yourself, it isn't hard and there are lots of resources available online.
If you need a single letters of the name just use the `list(name)`. &gt;&gt;&gt; name = input("Please enter your name: ") Please enter your name: reddit &gt;&gt;&gt; list(name) ['r', 'e', 'd', 'd', 'i', 't']
Show us your apps!
Python is the language. CPython and PyPy are both implementations. You are free to choose whatever you'd like.
Obligatory response: Also try out [PyCharm](http://www.jetbrains.com/pycharm/). It's a really awesome Python IDE from the IntelliJ guys.
The big disadvantage I see to this pricing structure is the introduction of a fixed cost, where all costs were previously marginal costs. With the old pricing structure, if X users brought in $Y, and $Y was enough to cover the marginal costs associated with serving X users, then 2X users should bring in roughly $2Y, which should be enough to cover the marginal cost associated with serving 2X users. I see this is as very comfortable for a developer. If they're making money with X users they'll probably be making more money with 2X users. If they're losing money with X users they should probably get out now, as it will only get worse with time. With the new pricing structure, there's the $9/month jump between free and paid. It may be the the case where X users brings in $Y, where X and Y are both small enough to stay in the free quota, so everything is fine. But it may be the case that with 2X users, the $9 fixed cost plus the marginal costs is less than $2Y, making the app a money hole for the developer. By the time you get to 3X users, $3Y may be enough to cover the fixed costs plus the marginal costs for 3X users. This is far less comfortable for a developer. When you enter that unprofitable zone, it's hard to guess how long it will take to grow out of it, or even if you'll ever be able to grow out of it. Personally, I'd be more comfortable if it had a steeper marginal cost. It might make my app less profitable in the long run, but I'd have the confidence to actually start it, knowing it would either make money or I could abandon it, and there wouldn't really be a time where it was unprofitable with hopes of improvement.
I'm not really familiar with the idea. Any idea what would make it faster? I can certainly see doing this being cheaper than building a list then converting the list to a set, but I'm not sure why it would be any better than building a set in the same manner.
i looked for a long time for exactly this about a year ago. i am so glad that you have spent the time to share. i can't get it to install for 2.6.5, anyone have any ideas? the website states &gt;=2.6
Digikam is open source and has face detection and recognition, so that might be a good place to look for facial recognition code.
This should have been posted in [learnpython](http://www.reddit.com/r/learnpython). An array in Python (to be specific, it's in the standard library) has a fixed data type, selected from a limited set of basic types such as char, int, float, and double. String objects are not supported in arrays. What you want is a list, a mutable sequence of Python objects. 
Sounds interesting..
The equivalent interface for PyPy would look very different: more like an FFI than an interface to the language. The python C API basically lets you get into the guts of anything from anywhere, which just plain isn't compatible with the optimizations PyPy likes to make. The changes needed to port to Python 3, however, are more like minor tweaks. But anyway, I agree that something like ctypes is the right direction (it's essentially an FFI). But note that ctypes code can't call back into Python the way real extensions can.
I agree. I am still bitter about PIL's lack of Python 3 support. Mind you I haven't evaluated the various EXIF libraries for Python 3 support either, it's just the principle of the thing.
Very impressive. Can you pickle objects between PyPy and CPython?
Sorry, no idea. I just rely on Debian packaging for my python module needs.
Why, out of interest, are there assumptions about the size of those 2 types?
That a very interesting question. if it is possible, one could send data from one process in CPython to Pypy and back. the CPYthon process would be the gui stuff and the Pypy, the heavy worker with numpy&amp;co.
I know it is not flask but django, however you might get some idea from this tutorial: http://showmedo.com/videotutorials/video?name=1100020&amp;fromSeriesID=110
What should I be doing? from x import * does seem like the right thing to do sometimes.
 SELECT Bookmarks.url FROM Bookmarks, Tags, TagMap WHERE Tags.tag = (?) AND Tags.id = TagMap.tag_id AND Bookmarks.id = TagMap.bookmark_id
I've been working on an open source delicious clone so I've been figuring out some bookmark-&gt;tag issues. The filtering of bookmarks by a series of tags was a bit interesting. I'm doing it in SqlAlchemy and it works across the databases (sqlite, mysql, postgres) but you might find it useful. It's a bunch of subqueries which so far seems reasonable on the main test data I've got of 16k bookmarks and a bit over 7k tags. https://github.com/mitechie/Bookie/blob/master/bookie/models/__init__.py#L401 I don't bother with the id on the TagMap table, just bookmark_id, tag_id You can test it out on a smaller live set of data at: http://rick.bmark.us/ The filter tags input at the top of the page is using the query linked in the github link above. Feel free to drop by #bookie in freenode if you need a hand with what any of it is doing. Edit: Added raw sql of an example of the query linked in the python source -- tables are bmarks, tags, and bmark_tags SELECT tags.tid AS tags_tid, tags.name AS tags_name, bmarks.bid AS bmarks_bid, bmarks.stored AS bmarks_stored, bmarks.tag_str AS bmarks_tag_str FROM bmarks JOIN bmark_tags AS bmark_tags_1 ON bmarks.bid = bmark_tags_1.bmark_id JOIN tags ON tags.tid = bmark_tags_1.tag_id JOIN ( SELECT bmark_tags.bmark_id AS good_bmark_id FROM bmark_tags JOIN tags ON tags.name IN ('virtualbox', 'ubuntu') AND bmark_tags.tag_id = tags.tid JOIN bmarks ON bmarks.bid = bmark_tags.bmark_id GROUP BY bmark_tags.bmark_id, bmarks.stored HAVING count(bmark_tags.tag_id) = 2 ORDER BY bmarks.stored DESC LIMIT 50 OFFSET 0 ) AS bids ON bmarks.bid = good_bmark_id
`import x` and then use the qualified name. Or `import x.y.z as foo` in some cases.
i could be wildly wrong (probably am) but i think they're both constant in access while a dictionary is cheaper for adding a new item. so they are both the same as far as construction and lookup, but modifying it is quicker with the defaultdict. with this approach, to 'remove' something from the boolean dict, you just have to set it to False and the same if d[name] to test membership will then return no. this does have one problem: if you do a crazy amount of membership testing. a defaultdict, if you are not familiar with it, is (in my mind) the equivalent of doing each time: if name not in d: d[name]=default_value or a try-except catch when trying d[name]. so when you use a defaultdict and query a key not presently in it, you will end up with a dictionary with an additional key. if you do this with a few million unique keys, you start to suffer performance issues because your dictionary now has a few million items. you can do nested defaultdicts: defaultdict(lambda:defaultdict(bool)) or delete entries not in the defaultdict, as they will return False anyway the next time you ask it: if d[name]: #do something else: del d[name] #do something when i switched from sets to defaultdicts for that project, it brought the runtime down from days to hours, but i didn't set out to do real benchmarking or profiling, just ran it on some data.
I'd complain more about transaction restrictions because table joins are generally abused.
Thanks for posting this! I didn't even know about this talk.
Because we store pointers in variables declared as longs, I think.
he works at Google ? (he has a @google.com address)
In web2py: db=DAL('sqlite://storage.sqlite') # or db=DAL('mysql://username:password@localhost/database') db.define_table('bookmark',Field('url',requires=IS_URL())) db.define_table('tag',Field('name',notnull=True,unique=True)) db.define_table('tagmap',Field('bookmark_id',db.bookmark),Field('tag_id',db.tag)) This will create the DB, tables, a web based administrative interface and forms (with validation) to embed in your apps. Now the logic: def search_by_tags_and(tags): (b, t, bt) = (db.bookmark, db.tag, db.tagmap) query = (bt.tag_id==t.id)&amp;(t.name.belongs(tags))&amp;(b.id==bt.bookmark_id) return db(query).select(b.url,groupby=b.id,having=b.id.count()==len(tags)) def search_by_tags_or(tags): (b, t, bt) = (db.bookmark, db.tag, db.tagmap) query = (bt.tag_id==t.id)&amp;(t.name.belongs(tags))&amp;(b.id==bt.bookmark_id) return db(query).select(b.url,groupby=b.id) You can do the other as exercise. This code will work with any of the web2py supported database backend (sqlite, mysql, postgresql, oracle, db2, informix, mssql, sybase, ...) EDIT: web2py DAL works with Flask. 
He is talking about the reference (=default) implementation I guess. But perhaps you are right and the OP did not know the difference...
That's backwards, right? Pypy doesn't support numpy yet I thought.
Use `from x import ThingIWant`. Using `import *` destroys readability.
Take a look at execnet, it's built for doing exactly things like that.
noob question here about the "only docs are docstrings" page. was that meant to show that your docstrings should describe what something does as opposed to what it is?
Yes, I take it you're speaking about Python's creator? You'd be surprised some of the very top named people they have working there. 
thank you, it looks interesting.
No, it isn't. Numpy support seems quite close but gtk or the obscure lib you use may take much longer. I can imagine numpy working in the next months but I don't see how the pypy team could test all the libs in the package index.
what make s you guess I was referring to Guido ?
saving this for later
If you plan to add features to this, how about editing and deleting sites from groups?
I took it to mean that you should have additional documentation in addition to your docstrings. 
9 Importing a module shouldn't have side-effects. It shouldn't modify sys.path, monkey-patch sys.excepthook or modify sys.argv like PyGTK does. Use an init or install function instead.
but isn't convention to write good docstrings and that becomes the baseline documentation?
me too
I was a little disappointed in this talk - it was very much a Python evangelism talk and didn't really go into detail about how they used Python at Google. Sure, they mentioned what services used Python, but I wanted to hear more specifics and details on the day-to-day.
Tweets tell very little. Why is this significant? What makes this a Good Thing?
I don't mind not having table joins, if I get some actual reward for doing things in the new way rather than being penalized with additional development time AND cost
Plenty of people want to pay. The issue is that the new structure pricing is not competitive and prices a lot of current apps (as well as apps which would otherwise be started/tried) out of existence. Since they can't easily just port over to an other service
Who uses this in production? What would be the point of using it for a new project, if App Engine's pricing structure is permanently out of whack?
Let's assume that the clone is compatible and vaguely usable on its own terms, for the sake of discussion. Is there ANY point to coding against App Engine APIs if you do not have any interest in using the actual App Engine service? (Let's say for new products, there is an obvious reason to try to rescue existing apps already put on App Engine without foreknowledge of where it would go)
Why do this?
&gt; What we need is a version of vim that takes 30 seconds to start FTFY. &gt; VIM is a great text editor, and it should stay that way. It does stay that way. If you don't use vim, why do you care what other people put in .vimrc? &gt; why not stand on the shoulders of the giants? That's my question. Unix already offers a great, proven combination of tools for development, of which vim is one well-integrated component. Eclipse reinvents much of the shell and development environment in verbose and bloated Java. As a bonus we get a novel and insanely cluttered interface which makes it really hard to find anything and usually winds up forcing you to memorize paths through hundreds of pulldown menus. Also, we get insane rat piles of XML distributed in deep directory structures instead of straightforward configuration files. Hooray! There are lots of great tools for writing Java, for that purpose Eclipse is great. The only reason I can see for someone to replace the entire fast, modular, marvelously expressive Unix ecosystem is that they never bothered to learn it and actually need a rat pile of menus not to feel scared. If someone wants a listing of Python classes in their editor there is nothing wrong with that, and it's still many times as fast as Eclipse
I hear vim has a good vim interface, and it can be used to launch whatever scripts you don't want to run from a terminal.
Just a guess, but if you assign a function to a class attribute, it automatically becomes an unbound method in 2.x -- I'm guessing 3.x just sidesteps that mess altogether by treating unbound methods as regular functions. I have an inkling that this makes static methods harder to identify from the console, though -- they are just regular functions, except they are never turned into bound methods.
Heh, Eclipse isn't the fastest *anything*. It is going to take a long time to write anything that is feature-comparable to Vim, and most products that come close are not Open Source. You're welcome to do it (why not?), but the only purpose will be personal taste. Vim is already an insanely extensible editor which can be used with almost any other tool, with little effort, so it is valuable to people who need specific efficient behavior out of their editor that has not already been prepackaged. But if you feel that it will save you time to rewrite everything in Java, by all means enjoy yourself.
Unix provides a pretty good developer platform. If "platform" means "way to edit files efficiently and launch external tools" (and does not require a rat pile of bloated Java and XML) then Vim is a good developer platform as well.
Give it 20 years. (Maybe by then it will be finished restarting after changing workspaces. *rimshot*)
I didn't say there is any point in starting with this. I'm just saying that you can move out of GAE with your application.
&gt; Is there ANY point to coding against App Engine APIs if you do not have any interest in using the actual App Engine service? I guess not. At least not now when there are no other hosting options. Side question: Are there any other python app hosting services? I know there are some for ruby but don't know about python.
What is the difference between refactoring and cross-file search-and-replace? Having used the refactoring tools in Eclipse before, they are just fine, but it isn't as exciting to me as the terminology might suggest it should be.
&gt; a rat pile of bloated Java and XML Do you actually have some criteria by which you differentiate ‘bloated’ Java and, I guess, ‘regular’ Java, or do you just spew FUD randomly? In Eclipse, there's also no XML, with which you'd have to directly interact, whatsoever. And I have written about why [XML is a good thing](http://www.reddit.com/r/programming/comments/h0chx/need_more_enterprise_introducing_jsonx_an_ibm/c1rqiaf) before. 
I find that Vim makes it really easy to integrate any external tools I personally want to use, in the exact ways which work for me personally, with remarkable ease. The difference is that Eclipse does integration in the Eclipse way, which is also nicely pre-packaged (and why I happiily recommend PyDev to people who want a Python IDE thing and aren't specific on their needs or tastes). I simply did not find that the Eclipse way was efficient enough, for my purposes, to justify doing everything the Eclipse way. And it did not provide me much scope to do things my way, so out it went. Doubtless many people have the same story about Vim (with the exception that they just didn't bother to make Vim do what they wanted) and that's fine. The reason I was "discouraged" from Eclipse was not that I was somehow deficient or unaware of keyboard shortcuts. It always took aeons to load, made trivial configuration changes ridiculously complex (I either have to fill in a form or edit an obscure XML file even for things many editors make trivial), force-marched me through endless inefficient dialogs and menus, and could not compete with Vim's easy access to documentation. Since Eclipse has so many features and they all must be in menus or trees somewhere, finding things is often a needle-and-haystack problem. I'd much rather just name what I want and bind it to a key or add it to a menu myself depending on what is more efficient. Also, the tools readily available for Vim have suited my purposes a lot better than the Eclipse tools did. It is partly a matter of style, but largely just that I don't want to do the things that Eclipse people want to do. That's just how it goes.
Makes sense. Never understood the point of distinguishing between unbound methods, functions and static methods. Class methods and bound methods, are special, that makes sense. But the rest... Good riddance.
Why? What does it have that PyDev lacks and is worth supporting commercial platform? 
&gt; Vimscript is an unholy abomination Elisp is really no better unless you are already permanently in love with Lisp. And you can also script Vim in Python, Perl, Ruby
VIM's editing mode is not *that* complex and have been successfully implemented for various platforms before. Kate, Netbeans and VisualStudio all have excellent VI-mode support, it's just Eclipse that have been somewhat left behind in that area. 
You failed to provide the best tip for PyDev users: don't install all of Eclipse, just install the Eclipse Platform Runtime Binary and then install PyDev directly on top of that. You save a significant amount of memory and startup time. So much so that I keep PyDev-Eclipse separate from Java-Eclipse. It's still pretty slow, but it improves a lot, if you like Eclipse.
Vimium kind of sucks, though, because Chrome snarfs so many of the keys
Better yet, :help ftplugin. If you create ~/.vim/ftplugin and drop in a file called python.vim, that stuff will only be sourced when the filetype is python. This requires no additional autocommands or changes to .vimrc (assuming your system vimrc or your vimrc run 'filetype on' 
I am sure you already know about "+y and "+p. Also, in recent builds of Vim 7.3, you can set an option called 'unnamedplus' which makes the anonymous register ("") and the system clipboard ("+) into the same thing, which streamlines things a bit if you are not married to Vim's unique style of clipboard handling ;) Sadly, this is not out in the distro packages yet AFAIK, so you would have to build from source to get it.
I hate to say this again (no, wait, actually I enjoy it) but a lot of people find Eclipse dreadful. And I think that PyCharm is faster and it seems to have some innovative ideas. But since I am a vim partisan and do not see the point in paying for anything else, I haven't been motivated to learn it properly
If you type: rm -rf /Library/ you will delete the Library folder and everything inside of it. But if you were to type: rm -rf /Library/* you would delete everything inside the Library folder but leave the actual folder. Since you were using -r (recursive) and -f (force), RM_STAR_WAIT would not have stopped your mistake. Some users will alias rm to mv to create a "trash" that can be emptied later. I don't suggest doing that though because you won't have that safety net on any other machine. Any time you type rm you need to check and recheck what you typed. I learned that the hard way by wiping out a production machine and having to spend my Friday night restoring from tape.
Google video used to let you download videos, it is missed for videos like this. How can I download this?
Oh jesus, from tape? Ok, -r is recursive, -f is force, and my library really is gone, though for some reason all the folders seem to still be there when I check it from the finder. Yet the fonts are still wonky, so something must be wrong. I haven't actually tried anything to fix this yet, but I think I'll go with the repair function on the installation disk.
maybe I'm missing something, but this does the same thing: import string js = """ var a = function( obj ) { for ( var name in obj ) { return false; } return true; }; """ print string.translate(js, None, string.whitespace) 
No argument here, but if you're choosing to stick with a LTS version then you shouldn't complain about not having the latest and greatest. Regardless of what release you have, all my suggestions are valid. One more; if you don't /want/need/can't have/ the base python to include certain modules then you can use virtualenv to pull them in on a per-project basis, useful if the sysadmin is paranoid about messing with system-wide software. 
It did come across as a bit of a plug for "readthedocs", however IMO the wiki site was barely readable. Also, the wiki site will require using various wiki code workarounds to get things to display propery, e.g. you're stuck using &lt;pre&gt;&lt;/pre&gt; wrapping all your code (or &lt;nowiki&gt;&lt;/nowiki&gt;) otherwise the wiki will start interpreting stuff in there wrongly. Also, a true wiki site will allow any random stranger to edit it, meaning they can modify correct statements with wrong ones and then confuse/mislead unwitting readers. I believe the premise is that "readthedocs" is simply providing the python documentation as generated by building python / running pydoc. If people want to expand on that documentation, it should be done in the official python repository so everyone can benefit, not on some obscure wiki site. So in this sense I agree, though I also agree that along with some of the other points he argues, it could have been stated a lot better. Mind you, we're looking at slides and not listening to any audio accompanyment which may have explained each slide better. 
It produces: vara=function(obj){for(varnameinobj){returnfalse;}returntrue;}; which is not a valid JavaScript anymore. During minification semantics should be preserved and output should be a valid JavaScript.
VLC Media Player will do that for you...
On the other hand in stdlib's `collections` module all imports are [explicitly marked as private](http://hg.python.org/cpython/file/ac14158462cf/Lib/collections.py), like that: import module as _module from xyz import dependency as _dependency from foo.bar import ( baz as _baz, qux as _qux ) Thoughts? I like the result (promoting really neat, uncluttered API), but maybe we need some syntactic sugar to make it more popular? Though I couldn't myself think of anything that is more clear and simple as qualifying using the `as` keyword. Or maybe `__all__` behaviour should be changed, so it actually defines the module's public API. Because it seems this is how it's being used in *[every](http://hg.python.org/cpython/file/ac14158462cf/Lib/multiprocessing/__init__.py) [other](http://hg.python.org/cpython/file/ac14158462cf/Lib/io.py)* [new](http://hg.python.org/cpython/file/ac14158462cf/Lib/heapq.py) [library](http://hg.python.org/cpython/file/ac14158462cf/Lib/fractions.py) in standard distribution. 
Do a google search for jdownloader. It will let you download Youtube videos at varying quality levels or just the audio if you're so inclined. It also has Firefox integration via plugin.
Different docs serve different purposes. Docstrings are useful as an API reference, but (for any non-tiny software) you also want to at least provide your users with a real manual (including overview and tutorial), and then possibly also an examples doc (cookbook) and maybe a quick-reference/cheat-sheet. Use either [reST](http://docutils.sourceforge.net/rst.html) (with [Sphinx](http://sphinx.pocoo.org/)) or [Markdown](http://daringfireball.net/projects/markdown/) (with [Pandoc](http://johnmacfarlane.net/pandoc/)) for writing your documentation. 
Regarding documenting your modules, just package them up, upload them to [the Cheeseshop](http://cheeseshop.python.org), and then upload your zipped-up html docs to the [Cheeseshop packages docs area](http://packages.python.org). ([more info about hosting your docs there](http://wiki.python.org/moin/PyPiHostingDocumentation)) 
Well, it didn't delete everything because you didn't run the command with sudo. Had you typed: sudo rm -rf /Library/ you wouldn't have seen the permission errors and everything would be gone. Apparently you did have permission to delete some things which is why your fonts are messed up. I've never done it but the repair function on the DVD is the way to go. Keep in mind that anything that copied to the Library folder after you got the computer won't be restored. Also backup your files before you attempt to repair your computer!
It's hilarious that this got downvoted so far when it's fairly obvious that you were asking about **the person named in the title of the thread who was also the presenter**...
youtube-dl: http://rg3.github.com/youtube-dl/
Unfortunately the core Vim code is a bit of a clusterfuck, mostly because it has to support a bunch of esoteric platforms (amiga?) and a lot of it was written decades ago. That makes it a bit hard to hack on. Also, I *hate* the vimscript language, though luckily these days you can do most things via Python or something else. It's notoriously difficult to embed in another platform like Eclipse, Visual Studio, etc. As far as putting more IDE-like features in to Vim, that's also difficult for some things since there's no simple API to launch background threads, so more complex code analysis plugins are difficult to implement.
You can use any of the following: from x import some_function from x import SomeModule.some_function as some_function import x func1, func2, func3 = x.SomeModule.func1, x.SomeModule.func2, x.SomeModule.func3 It doesn't matter too much which one you prefer. They're all understandable. The problem is, if you say: from x import * from y import * z = f*g Did f and g come from x or y, or both? What if f was defined in x, and was also defined in y? This is really annoying. To find out where f and g were defined, I need to separately import x and y somewhere else, find out what they define, and make sure that I'm understanding where things came from in your module. That's a major pain in the ass. If you do it just once, it's not ideal, but it's not going to kill me either. I can assume that anything that wasn't defined in your module was defined by your use of import *. It will be frustrating, but not to the point of making me want to jab myself in the eye with a pen. Once you've got more than one of those, it will begin to become maddening. That's especially true if you're importing non-standard modules. If you say from math import *, from time import *, I could probably guess where most things came from. If you do that with your own modules, I have no idea, so I need to go and look up all of them. One further problem is that it gets rid of encapsulation. If you call dir (your_module) and get back a list of 3,000 classes, functions and variables, it's going to be useless. You won't even know where to begin looking through such a long list. If you're using IDLE, you will not even be able to handle a list like that without it slowing to a crawl any time you look at it.
pretty cool and it runs on linux-kvm too 
That means in Python3, you don't need to use the @staticmethod decorator for class methods. Methods (without "self") are automatically static. In python 2, invoking these methods (undecorated with @staticmethod) yields an "unbound method" error. So this is a bit more convenient.
Well. Do sshfs. 
 _I _do _not _like _too _many _unnecessary _underscores. One __all__ is more elegant. and I think __exports__ looks more reasonable.
From TFA: &gt; After tinkering with other apps, Riedener concluded a CRM system is “just a well-formatted database with some formulas and reports” and Django is “perfect” for this kind of application. So, we've got a one man show and the one man has "tinkered" with CRM and come to the conclusion that it's a database with "formulas" and "reports". My response, from the "if you can't say anything nice, don't say anything at all department": 
So, the type of method depends of the name of the first argument? If I mistype self I get different behavior? Edit after testing: apparently not, and I think it has nothing to do with the name of the first method argument. Edit2: [staticmethod](http://docs.python.org/dev/library/functions#staticmethod) still exists in Python3.
hmm, will this still allow the Python2 way of introducing new methods by just assigning functions to attributes of objects?
As I understand it this means that in Python 3, Class.method is a function, and not an unbound method. This means this works: class Foo(object): def bar(self): self.val = 2 return self class O(object): pass Foo.bar(O()).val # returns 2 Whereas in Python 2 the last line complains: `unbound method bar() must be called with Foo instance as first argument (got O instance instead)`. In Python 3 Foo.bar is just a function. 
MoinMoin2 is using Flask: http://moinmo.in/MoinMoin2.0 &gt; **Framework / Libs / Python** &gt; Already done: &gt; we require Python 2.6 now, so no need to test with older pythons any more We use Flask now as the framework. &gt; * restful URLs * werkzeug for WSGI stuff (since moin 1.9, will get even more and better used in moin2) * jinja2 for templating * using flask-themes for themes * flatland (+ j2 macros) for forms generation / validation of entered data * use flask-babel, babel, pytz for i18n/l10n * using flask-script for scripts * using flask-cache for caching * use sqlalchemy (by default with sqlite backend) for some indexing / selection / speedup &gt;
Not on Windows, where PyCharm also works.
Dont use windows. Problem solved. Duh. 
I've been a bit skeptical of PyPy. Incredibly cool idea, but seems way too complex to pull off, and the project has been at the «almost works but not really» level for like two or three years. But I must admit that it seems to be making huge strides as of late. If they can get the common modules working so that Django and a few other web frameworks are fully up and working, including all common DB2 implementations, etc. then PyPy will basically be a turn key solution for making thousands of web apps run significantly faster. Which is, you know, insanely useful.
A bit too much going on for a single app I think: https://github.com/scaphilo/koalixcrm/blob/master/crm/models.py Everything from customer, to contact, to quote, to purchase order in there. I'd much prefer to see those broken into smaller more focussed apps if I was to use this in any way.
The last year it has more looked like PyPy is hampered by the mess that CPython sometimes is. And PyPy seems to be a more compliant and sane implementation of Python. Of course, it would not have existed without CPython..
&gt; Methods (without "self") are automatically static. Wrong. They just are static when accessed through the class, but they still become bound on instance access. Personally I think getting rid of unbounds method was a terrible move for too many reasons (pickling and everything related). //EDIT: if you downvote, please at least explain your reasoning.
Woah, I was going to download and try it out, but you saved me the effort.
&gt; Never understood the point of distinguishing between unbound methods, functions and static methods. Documentation tools had good use for this information.
Why didn't you post the project page? How did they write an entire article about this one conglomerapp?
If you like this please consider subscribing to lwn.net. They're the only net service I spend money on directly. Jonathan Corbet runs a tight ship and if you're interested in linux at all it's a worthy site.
downvotes for a saving comment? classy.
I suppose if you are good enough with regex's there isn't much. Eclipse can do analysis to make sure that when you rename 'x' that not ALL x's are replaced, just the ones that refer to the same variable, in the same namespace... etc. It can also go further and look into other project related like *.XML config files and do the renaming there too. That type of analysis is something that a vim plugin could do, but since it's actually pretty expensive (performance wise) it doesn't fit into the vim philosophy very well.
PyPy really seems to be the future of python. I'm already planning on testing some of my more computationally intensive scripts to see how fast they go. 
ive ran pyramid with postgresql drivers + sqlalchemy just fine. So you can already do webdev on pypy
This seems to make a lot of sense from a ducktyping perspective. 
yes when I saw the download I was like "huh ????"
somehow the dv are crazy in this thread and only today is Friday 13th.....
&gt; django hasn't even been ported to python 3 much less pypy. What are you talking about? Pypy aims to implement Python, as long as Pypy implements Python correctly and Django does not rely on implementation details of CPython (such as taking liberties with releasing and relying on the refcounting GC), there is *nothing* to port. And in fact, some fixes were committed to both during 2010 (mostly to Django) and Django runs on pypy just fine *right now*. I'm not sure there's even one Django-required DB adaptor it does not support yet: cx_Oracle, MySQLdb, Psycopg2 and sqlite3 (obviously) all work. &gt; Pypy is Turing complete, but well supported it is not. Pypy is a Python 2 implementation, and any correct piece of Python 2 it fails to run is considered a bug. Are C there third-party packages missing for now? Well yeah, if you need PIL or SciPy CPyExt may not be there yet (though it's quite far along already), but that's it.
&gt; If they can get the common modules working so that Django Django already runs on Pypy (as do, I am sure, many other stacks. Tornado runs as well for instance). And this summer, Alex Gaynor interns at Quora to help migrate it to Pypy, and then tune the whole thing (both Quora's codebase and Pypy's)
Scheme's not any more insane than Python, as a language. It just has different rules. If they're not teaching you Scheme by teaching you how to _implement_ Scheme, they're probably doing it wrong. Here's a good book to read on that topic: http://www.eopl3.com/ (NB: I write Python code for a living. :)
Here's a couple recommendations: * [ClipNabber](http://clipnabber.com/clipnabber_classic.php) (classic only, they seem to be hawking a free download plugin now) let's you put in a URL of a video web site and gives you download links for the files. They also have a bookmarklet as well. * [Easy YouTube Video Downloader for Firefox](https://addons.mozilla.org/en-us/firefox/addon/easy-youtube-video-downl-10137/) - my preferred method for YouTube, adds the a download button to YouTube GreaseMonkey-style. **EDIT**: I also use [Miro Video Converter](http://www.mirovideoconverter.com/) to quickly convert any FLVs to iPhone/iPad/Roku-formatted MPEG-4s.
Scheme is a very powerful language even though the syntax can be difficult to get used to. maps and lambda functions are pretty cool. Also overloading can be fun. Oh yea and tail calls if I remember correctly are implemented correctly in scheme(someone correct me if i'm wrong)
How much more crazy is (func arg arg) than func(arg, arg)? Is it not crazier that we privilege some functions as infix but not others, and that there's no way to specify fixity of your own functions in Python?
I must say I love lisps. They are so much fun and cool to work with. There is a very good reason for why Scheme uses prefix notation for everything. Give it a chance. It is really, really cool. (Cooler then Python imo).
Here's the video from Pycon: http://pycon.blip.tv/file/4883162/ 
Thanks, especially since 90% of that horrible examville website failed to load. Instead, it gives me links to screenshots of internet explorer(!) settings it wants me to change. 
I just wrote my own... in Python, of course. It's not in a sharable state, though -- i.e. there's no error checking, exception handling, or documentation; it's just a hack. It takes a video ID and a format code, and it can also list the available formats. It updates the download progress on a single line, showing bytes downloaded out of the total, plus the current speed in kbps. I love Python. In C++, I'd still be writing/debugging code.
Plus the Python is the kind of horrible non-PEP8-y stuff I keep complaining about at work.
A "figure" contains "axes" as children. The subplot command creates a new axes as a child of figure and sets the axes position. 
I'm not completely familiar with matplotlib's internals, but I can venture a guess. When you call plt.figure(), you're getting a reference to a Figure object from within the matplotlib.pyplot module. When you call plt.show(), that module remembers (by storing the object in the module's global namespace or remembering it in some other way) that the figure object you're currently working on is fig and renders it. 
[Here's the original upload](http://www.slideshare.net/doughellmann/hidden-treasures-of-the-python-standard-library) by the author. This is at least the second time joejoe500 has posted the scraper version of a popular talk. EDIT: turns out this person does that quite often.
plt is the package. It also keeps track of all figures. With calling plt.show() it renders all figures. And your figure contain the axes.
The lambda available in python is pretty crippled compared to the one in scheme or common lisp. That's not to say lambda in python doesn't have its place, it's still useful.
in the scheme example, think of the '+' not as an operator, but as a function named '+' The difference between add(2, 2) and (add 2 2) is what the parent poster was trying to get at. 
i dont want to live in your world. the information you seem to be absorbing is not correct. I think you are making shit up.
That's a banker's round (half to even). If you continue with CS, you will find there are lots of ways to round a number, all of which serve different purposes. http://en.wikipedia.org/wiki/Rounding#Round_half_to_even
I think matplotlib was designed to be a clone of the Matlab graphing system. That's why it seems a little odd at first.
I highly recommend installing everything with the exception of maybe python-dev through pip instead of the Ubuntu repository. It will make it much easier to update or change versions in the future, and it's easier to use with tools like virtualenv.
Scheme is a beautiful language and I highly encourage you to pour yourself into it. It makes you think about functions and data in a whole new way and in the end it will make you a superior Python programmer.
prefix notation isn't much weirder than infix notation, and there are certain advantages to prefix and postfix notation over infix. Just because you grew up learning infix doesn't mean you should be put off learning other concepts. Just like how we use binary and hexadecimal when it suits us over the decimal notation we grew up with. One of the wonderful things about learning computer science is finding new ways of thinking.
I don't get how Pypy is faster when it has 3 times as much cache misses. I thought memory access was the primary bottleneck on most systems. Also, how restricted is Pypy? Can I still do ducktyping? Since it sort of compiles Python code, is it possible to get some proper typechecking going on? I'm sort of disappointed with the amount of coverage pychecker does.
There are two interfaces to matplotlib, the true OO one, and a 'global state' one more similar to Matlab and more convenient for interactive use. Above you are mixing the two (which is fine). Plt.show() calls show on the currently open figures. Alternatively you can call the show method of the figure directly: f.show(), but if it is already open f.canvas.draw() also works (I am a little confused about the difference between the two but usually use canvas.draw now). 
Yes, Guido referred to it as "ducktyping self"
You dont have to install it: Use the demo instead.
Also, it kills the ability of PyFlakes and some other source code analyzers to catch name issues.
yeah well if your development world ends up on django then i pity you and your skills ;-)
&gt; I don't get how Pypy is faster when it has 3 times as much cache misses. Could the sys calls be more overhead?
Much of python is VSO as well. That's how function calls work. operator.add(4, 5). The rationale for scheme doing prefix notation is to keep the syntax dead simple. Too many hideous languages have been created by making the mistaken assumption that the best programming language is the one that best maps to natural language.
Thanks guys, I got it. 
How lists are treated and the prefix notation for operators are closely linked. One of the strengths of Lisps is that code and data are nearly identical: lists. Manipulating code is as easy as manipulating data in Lisp, and this is one of the reasons it is so prevalent in the field of AI. If the operators could come in between arguments it would be much harder to parse.
&gt; I don't get how Pypy is faster when it has 3 times as much cache misses. Because it still does less stuff overall (or more precisely the same stuff in less cycles) &gt; I thought memory access was the primary bottleneck on most systems. I would expect Python to still be CPU-bound (why would it be memory-bound in the first place?). Python's interpreter (and refcounting) likely have pretty good locality, but the execution itself is still slow. Pypy uses a JIT and a more advanced GC (they may not have done much work on cache locality yet) leading to a greater number of misses, but as the working itself is more efficient once stuff gets to the CPU it still wins in the end. &gt; Also, how restricted is Pypy? ctypes is not complete and the CPython C API emulator is in its early stages. As far as Python code goes, it should not have any restriction, any code running on CPython which fails to run on Pypy means there's a bug (although the bug may not be in Pypy). &gt; Can I still do ducktyping? If it could not, it would not be a Python implementation. &gt; Since it sort of compiles Python code It's a [JIT compiler](http://en.wikipedia.org/wiki/JIT_compiler), not a static compiler. It does not rely on static analysis to generate machine code, but on actual code execution and codepaths taken. &gt; is it possible to get some proper typechecking going on? Not via Pypy no, that's not the point of the project.
Being a full-time django developer does not necessarily translate into being a moron. That's just an unlucky (for Django's reputation) coincidence.
Re Scheme: you cannot really comment on Scheme until you *understand* why it is the way it is. I recommend McCarthy's original Lisp paper[1] and the Wikipedia article on Lisp[2]. If that piques your interest, read *Land of Lisp*. *Land of Lisp* is probably *the* best programming book I have ever had the pleasure of reading. [1] http://www-formal.stanford.edu/jmc/recursive.html [2] http://en.wikipedia.org/wiki/Lisp_%28programming_language%29
Since you're gonna make a living writing software, you'll need to realize that you don't often choose what programming language. I'm looking forward to the day you'll have to write C++ or COBOL. I don't understand how you seriously can complain about all this stuff. It's just a paradigm change. Scheme is a great language. Next time you go bashing please google some proper critique first.
Why? Why should it matter to you if a function happens to be an unbound method. Even if it's a plain function, you can still bind it as a method if you want to. Or as a class method.Document what the function _does_ instead of trying to restrict what it's supposed to be useful for. 
yeah i know, i just meant his ignorance. I know some pretty awesome django guys, but personally i dislike the framework.
Definitely, I also sub and consider it well worth the few $. Some of the article series that they've put together on linux systems have been quite brain expanding.
Actually, I just had to something similar to what you're describing. The result which does not use 'pyplot' is here: https://gist.github.com/971186
Alright, after a bit of digging: (Note: I thought this would be explained by having the plt object keep a reference to figure before returning it with the figure() function, but it's way more fun than that!) This line is present in the matplotlib.pyplot module: from matplotlib.backends import pylab_setup new_figure_manager, draw_if_interactive, show = pylab_setup() So, the plt.show() function is returned by the pylab_setup() function from matplotlib.backends module. In pylab_setup(): show = getattr(backend_mod, 'show', do_nothing_show) [getattr](http://docs.python.org/library/functions.html#getattr)() is like backend_mod.show, except you can specify a default to return if that attribute is not found (eliminates the need for a try, except block) Ok, then what the heck is backend_mod? backend_mod = __import__(backend_name, globals(),locals(),[backend_name]) [Import](http://docs.python.org/library/functions.html#__import__) is a built in function which allows you to do an import at runtime, when the name of the module being imported is unknown at compile. backend_name is defined earlier in the function, based on this line in the matplotlib.backends module: backend = matplotlib.get_backend() Remember, when a module is imported, the module is executed. So: from matplotlib.backends import pylab_setup in matplotlib.pyplot Simply means "Execute matplotlib.backends, and put pylab_setup in the local context". It is syntactic sugar (shortcut) meaning the same as: import matplotlib.backends pylab_setup = matplotlib.backends.pylab_setup Ok, so looking at a bit of code I have running in the interpreter, the backend selected for me by matplotlib.get_backend() was 'TkAgg'. Here's the massaging that happends just before __import__: backend_name = 'backend_'+backend backend_name = backend_name.lower() # until we banish mixed case backend_name = 'matplotlib.backends.%s'%backend_name.lower() backend_mod = __import__(backend_name, globals(),locals(),[backend_name]) So, import matplotlib.backends.backend_tkagg, and from it, get it's show() method. Still with me? Here's the show method in matplotlib.backends.backend_tkagg: def show(): """ Show all figures. """ for manager in Gcf.get_all_fig_managers(): manager.show() Tk.mainloop() Aha! What's Gcf? It's imported in the matplotlib.backends.backend_tkagg module: from matplotlib._pylab_helpers import Gcf Gcf is a class which "consists of two class attributes". one of which is a dictionary called figs. get_all_fig_managers() is simply a wrapper for: Gcf.figs.values() So, what's happened so far? When you call .show() on plt (our 'local' name for matplotlib.pyplot), it's actually calling the .show() method on matplotlib.backends.backend_tkagg (or the backend selected by matplotlib.get_backend() on your particular machine). The show() method iterates through the managers in figs in Gcf, which lives in the matplotlib._pylab_helpers module. Whew! But wait, how does plt.figure() tie into this? See my comment below. 
Pyplot is sneaky: its made to emulate matlab's style of "type commands in this console and watch stuff happen because we assume its all related," so its laden with assumptions about your usage, and one of them is that you will be creating one or more figures and then doing something with them. When you call plt.figure(), it doesn't just return a figure, it also modifies some module level state in plt: it has side-effects. When you call fig.add_subplot(...) it doesn't just return a new object, it also modifies fig with some information about the new object which it will then return. When you call plt.show(), plt looks up its stored information about fig which in turn knows about ax1, et al.
thanks, that's some good advice. i get the whole point about separating user docs from api docs. i was just having difficulty trying to understand the basic point the OP was making in that slideshow. i think i see what the OP was getting at, maybe the brevity of the wording threw me off. also aren't the docstrings well integrated to tools like Sphinx and whatnot? 
In the source of plt.figure(): figManager = _pylab_helpers.Gcf.get_fig_manager(num) if figManager is None: figManager = new_figure_manager(num, ...) _pylab_helpers.Gcf.set_active(figManager) The important thing here are the calls to _pylab_helpers.Gcf.get_fig_manager(), new_figure_manager() and _pylab_helpers.Gcf.set_active() print inspect.getsource(matplotlib._pylab_helpers.Gcf.get_fig_manager) @staticmethod def get_fig_manager(num): """ If figure manager *num* exists, make it the active figure and return the manager; otherwise return *None*. """ manager = Gcf.figs.get(num, None) if manager is not None: Gcf.set_active(manager) return manager So, it gets the figure from figs in Gcf (which plt can access when calling show(), as discussed above) However, this is not the case in your code (you are creating a new manager, not referencing an old one using the optional num parameter). So, the new manager is created using new_figure_manager(), and then... _pylab_helpers.Gcf.set_active(figManager) print inspect.getsource(matplotlib._pylab_helpers.Gcf.set_active) @staticmethod def set_active(manager): """ Make the figure corresponding to *manager* the active one. """ oldQue = Gcf._activeQue[:] Gcf._activeQue = [] for m in oldQue: if m != manager: Gcf._activeQue.append(m) Gcf._activeQue.append(manager) Gcf.figs[manager.num] = manager Boom! It adds the manager to figs in Gcf. SO! What have we learned? 1. Modules can store state information (references to objects, etc). 2. That state information can be buried pretty deeply, through many references to imported modules in other imported modules. 3. Sometimes, hand-waving and saying 'it's magic' is a good-enough answer. Hope that explains that there isn't anything special going on with namespaces or inheritance that you didn't know about before. It's just that imports can make things confusing sometimes. 
Guido had a bit to [say](http://www.youtube.com/watch?v=KKQS8EDG1P4#t=54m18s) about that during Google IO. Boiled down to when users start wanting it more than cpython and they're both feature complete, they may focus development on pypy maybe.
Much more succinct than my [answer](http://www.reddit.com/r/Python/comments/halzh/confused_with_matplotlib_maybe_inheritance_andor/c1tx8gn) and absolutely correct. :D
I think the posters point was that 6.5 was rounded down, but 7.5 was rounded up.
*reads your answer* EPIC RESPONSE, +1!!!
Why, I've never heard of this. . .
Exactly.
I second this. I'd also recommend looking into SICP and The Little Schemer
Because bankers rounding goes half to even, 6.5 goes to 6 because 6 is even and 7.5 goes to 8 because 8 is even, just think of bankers as lazy. If you want real madness, there's a bug in the BigDecimal library for Ruby right now that causes .5 to always round down regardless of the first number.
Haha, you picked the wrong language to rag on here. That said, in the future, your skill as a programmer will be measured by your ability to be told about a system such as a programming language and asked to use it to solve a problem, such as writing a program. The farther you go in your career the more all programming languages will look basically the same, like different interfaces to the underlying state machine whose gears are turning to produce an answer. I suggest you try and view this as the first step at increasing your understanding and power rather than some bs you need to get through in order to never use again. Scheme really is a beautiful language when you compare it to something like C++ or Ruby. If you successfully learn how programming with it "works," you'll have a huge advantage over your peers.
&gt; (+ 2 2) instead of 2+2? WHY? It makes the grammar more globally consistent, and thus also makes writing the interpreter/compiler drastically simpler. Ultimately, though, the choice is pretty arbitrary and its value depends on preferences. Fundamentally, one person thinks that this is elegant, and another person likes being able to express arithmetic in English
&gt; I'm looking forward to the day you'll have to write C++ or COBOL. Almost certainly nobody is going to hire you to do COBOL if you don't have chops with COBOL.
Right, you can move out, if you don't mind an application which was formerly ready for production now not being ready for production, due to no changes on your part. Lame.
Níl fadhb ar bith agam le VSO.
See also Doug Hellmann's [Python Module of the Week](http://www.doughellmann.com/PyMOTW/contents.html).
&gt; The farther you go in your career the more all programming languages will look basically the same, like different interfaces to the underlying state machine whose gears are turning to produce an answer That's true within the imperative paradigm. Haskell, Agda, Coq aren't just new interfaces around the same old concepts.
Infix notation isn't English.
If they aren't faster (or perhaps aren't faster enough :)) please let us know, we have tons of benchmarks we're faster on, finding one's we are slow on is still valuable!
I wrote a longer post, but reddit ate it. But from that I would just like to say that I don't think you "GET IT." You can probably read it, but you don't "GET IT." It bleeds through in your other comments and the comment you made about lists in Scheme. Lisp is an acquired taste and not everyone will get it, but it is probably the most powerful and beautiful programming language ever devised. That said, I still enjoy Python and other programming languages. I even use other programming languages more then I use any Lisp. Lisp is more a hobby for me, and I'm not even particularly good at it. But the small part I have learned has brought so much more into my programming then anything before it. 
If you enjoyed Land of Lisp and the original paper you should read Let Over Lambda. It changed my whole view of programming.
I don't quite understand the idea behind PyPy, could someone help me out here? All I ever hear is that it is "The Python runtime, written in Python." Does this mean that the PyPy interpreter itself is actually running through a CPython interpreter? Because my simple mind simply can't comprehend how more overhead == faster. And if I'm just completely missing how PyPy works then I guess I don't quite see the point of another interpreter. 
Well you are missing something, but that's ok it's really not-obvious. Here are two good explanations someone put together: http://www.reddit.com/r/programming/comments/h0zck/pypy_15_released/c1rrvq4 . The important takeaway is that what you get at the end of the day is a binary, like the `python` on your system today, that's just faster. Everything else is implementation detail for the people who write PyPy.
Stop. a) Don't use `easy_install`, b) Don't install your packages globally, use `virtualenv`.
&gt; Why? Because if you only have a reference to the result of `getattr(x, y)`you can no longer find x. This is a huge problem for things like pickle and still a problem for documentation tools that now need to change their logic for looking up stuff.
@airshiplamp: i understand where you're coming from and your disappointment. believe me when i say i *tried* to get more detail. it's one thing chatting with people to tell me stuff and another to get their legal and product team to OK me to talk about their work! i also didn't want to lose the beginners -- based on our surveys taken prior to I/O, it appears that most developers were more familiar with Java over Python -- so that's why there was more language advocacy and Python use cases over Google specifics. all this in 45 minutes! when i signed on to do this talk, i thought it would be easy... instead, it turned out to be nearly the opposite and practically impossible to please *everyone*! if you do want more technical details, check these links: http://www.slideshare.net/didip/super-sizing-youtube-with-python http://panela.blog-city.com/python_at_google_greg_stein__sdforum.htm http://postneo.com/2005/03/25/pycon-day-3-greg-stein-keynote
It keeps numbers from drifting up on average.
Of course they are: you can't run Haskell on a Turing machine? Paradigms are styles of interface.
I've been running PyPy for everything I can now. There are still some growing pains, like no lxml support and having to patch python-mysql, but other than that, it seems to have no downsides. I think the high cache miss count shows that they is still lots of room for PyPy to improve. It's exciting. 
That's great to hear! We definitely have tons of room for improvement, if you ask any of the PyPy developers I'm sure we can all list 5 things that we'd love to improve, if only we had more hours in a day.
hahahahaha yeah, that's how it works...
Well, you picked the wrong language to bash while complimenting python, but that's ok. You do have things very easy with python, and learning more languages will teach you all about that.
Perhaps someone can explain if this has an advantage for web applications. I don't think so because: * most of the time is not spent in the interpreter, it's spent doing I/O operations * the JIT compiler consumes more memory than CPython, you could be using that memory for database caching instead
&gt; most of the time is not spent in the interpreter, it's spent doing I/O operations Maybe. Enough people complain about the speed of the Django template language to tell me that some portion of some people's requests are CPU bound. It's going to be very application dependent. First measure! (Let's put it this way, there's a reason Quora is bringing me on this summer to work on getting their app running on PyPy, they think there can be valuable wins achieved) &gt; the JIT compiler consumes more memory than CPython, you could be using that memory for database caching instead Perhaps, but our objects are smaller, so often programs on PyPy can use less memory. Again, it's very application dependent as to which will use more memory.
I hear that and definitely will be benchmarking on real-world data sets and usage scenarios (the one true way to measure performance) to see if PyPy can benefit my clients.
Execution power equivalence does not mean these languages look the same or are different interfaces to the same thing. Having a powerful type system that can encode any proposition and allow you to prove it at compile time is a radically different notion from what you find in Python. 
Sounds like a hassle having to do that, but I'd definitely say it's worth it to reduce the number of too similar concepts in Python. Static methods need to die. Look at the concept reuse in e.g. Lua. Tables (Luas equivalent to a dict or list) also function as Luas equivalent to a namespace. With some clever syntactic sugar and a feature called metatables that kind of resembles Javascripts prototypes, tables are also made into the Lua equivalent of types and objects. The number of key concepts in Lua is microscopic, but the actual expressive power is almost comparable to Python. From a language design point of view, it is an amazing language.
Unfortunately, with the new pricing change, I've all but abandoned GAE. I would understand a bit stricter limits, but basically killing your app at the end of the day if it goes over one instance during it, and then charging at least $9 per app to fix that has made it really unattractive for me. I host various really low-traffic sites and apps there, and it was an amazing offer before the change, but now it's just not worth it.
Bottom line: you've found something that you like - use it! Eventually, you'll feel bored and that boredom will serve as motivation to try learning something else that you like less. - a happy Python amateur who is a bit bored and is considering to start learning some Haskell
Won't *someone* just write a fucking *webpage* instead of all this embedded document-viewer rubbish? (I mean, sure, use some little javascript hooks to make it look like a slideshow if you must ...)
&gt; most of the time is not spent in the interpreter, it's spent doing I/O operations I may find it effective to trade I/O wait for CPU-time. Let's say I have a 3-teir architecture, with caching on each app-server for data. Now two things could make me want to use PyPy. 1. At this point, my app-servers are running off memory and the CPU is maxed creating intermediate results or putting the data into a template for the end-user. I can't cache this data because its throw-away, or unique per user. PyPy makes python faster so my servers take less time per request. 2. I can literally cache everything--including data about to be sent to a user. For a while it is faster to pull from cache than it is to regenerate the data, but soon my app-servers become sluggish because they're waiting on I/O from network sources since I'm say... using distributed memcached, or a Redis cluster. I could decide at that point it would be faster to regenerate results and not suffer I/O wait.
&gt; Static methods need to die. What? Static methods are not on the list of features that can even go away in Python. The removing of unbound methods did not reduce the need for `staticmethod` or `classmethod`. Don't make that mistake. &gt; but I'd definitely say it's worth it to reduce the number of too similar concepts in Python Python has just one concept for things you can call: you can call it. There are tons of different callable concepts that are more of a practical problem than an unbound method (for instance the difference between builtin function and function). There is only one reason that unbound methods are gone in Python3: that you can patch a method from a class to a class from a different inheritance tree.
I'm not sure if this is an oversight or intended. If it was intended, its awesome, given the context.
Just because you can't discern the usefulness right away doesn't make it silly. It is a rounding commonly used by bankers because it evens out in the long run (more or less; odd numbers are slightly more common in financial transactions for various reasons). When dealing with large datasets, statistical scientists will use stochastic rounding because it has no bias in the long run. If you use "half round up" over a few million floating point numbers, your geometric mean will be higher than with the unrounded data. With smaller sets, the bias might not be significant. Banks and brokerages that process millions of small transactions a day count the difference in the thousands of dollars, however.
Yeah it does. Any Haskell program can be written in Python and vice vrrsa. They're nothing more than interfaces to the hardware's implementation of a Turing machine. edit: I didn't say they look the same. I mean that's part of my point. They are radically different interfaces to an implementation of a Turing machine, and unless you think Haskell isn't Turing complete, they're just CSS over a state machine and a tape. 
May I ask how exactly you do this? Is this with python-mode.el? 
&gt; Yeah it does. Any Haskell program can be written in Python and vice vrrsa. They're nothing more than interfaces to the hardware's implementation of a Turing machine That's a narrow view. Programming languages allow doing, and doing is important. They can all do the same things, but there's more to programming languages than doing. For example, Haskell types can represent theorems, and values can represent proofs. Python's types cannot. When using a stronger type system, the emphasis moves from doing to proving. As for Turing Completeness, Haskell is Turing Complete because it allows general recursion. There are very interesting languages such as Agda and Coq which are not Turing Complete, because they require programs to encode a proof of termination (and a Turing machine may never halt). Experience shows that every interesting problem which was tackled had a solution despite this apparent limitation -- but it is yet further proof that the world of programming languages may be more diverse than you might figure after swimming around in the imperative world. 
Once Matplotlib gets updated, I'll have no reason not to use Python 3!
Cool! I wrote a minimal/toy-ish breakout game in Haskell a little while ago: https://github.com/Peaker/breakout/blob/master/src/breakout.hs May be interesting to compare them.
If you really want to have fun, play with this library, http://pyode.sourceforge.net/
I've been waiting for this for... like, years.
You can name 'self' whatever you want. An instance method has a `__self__` attribute that references the instance. This is the first argument when the method is called. However, it's bad form to not use the name 'self'. The function object gets bound to the `__func__` attribute of the method. Also, in 2.x an unbound method has an `im_func` attribute that references the function object. You can invoke either directly. Unless otherwise requested, a user-defined function in the class will be bound as an instance method. If you don't want the function to be bound to instances, you need to decorate it as a `staticmethod`. There's also `classmethod` if you want it bound to the class. There the preferred name of the first argument is 'cls'. 
You can always assign a function to an attribute of an object. If you want the function to act as a bound method of instance objects, you need to assign it to the class. That still works as before.
Here's a function that should help to identify static methods of a class: def find_static(cls): import inspect ca = inspect.classify_class_attrs(cls) static = {a.name: a.object for a in ca if a.kind == 'static method'} return static static = find_static(TheClass) funcs = {name:method.__func__ for name, method in static.items()} Though it's probably better to use class methods instead.
Rounding to even is used as general rule all over the place. It's also used in Python 3.x: &gt;&gt;&gt; round(6.5) 6 &gt;&gt;&gt; round(7.5) 8 
This is awesome :)
Awesome, I'm so glad there are dedicated people working on this project. NumPy + SciPy + Matplotlib has become my one-stop-shop for scientific computing; I use it every day now, and it's helping me get through my degree. My thanks go out to those responsible for these awesome packages!
Maybe the whole project is already in a virtualized environment. Make environment, configure with apps etc.... deployyyyyyyy Its useful for more than just Python.
I knew my apps were missing something. Now I know: it was a rotating cube.
I can't think of any python-specific ones off the top of my head at the moment, but there are plenty of CS lectures around. You could start here: http://academicearth.org/subjects/computer-science 
[pyaudio?](http://people.csail.mit.edu/hubert/pyaudio/)
[Changes](http://groups.google.com/group/webpy/browse_thread/thread/153e05abe9a90e1d)
&gt; Numpy support seems quite close Oh good god no it isn't. And it will always be playing catchup to the reference NumPy implementation.
Do anyone have a good book recommendation in NumPy + SciPy?, i develop python full time but not scientific stuff, I use PyQt or Django usually and i read every day about how great are this libraries, still i don't know what can i do with them, maybe they are only important for scientific stuff that i don't use?
why on earth would you link to the tarball? 
PyAudio is nice but it doesn't mess with the Windows mixer. It has to be done with WinMM.dll, either via C or with ctypes. MS has [some simple APIs](http://support.microsoft.com/kb/139098) for this, but a complete interface will have to delve a [bit deeper](http://msdn.microsoft.com/en-us/library/dd756706.aspx).
I asked the same question to myself after submitting.
Their probably most common use case is when operating on large matrices. 
Looks like everything you need to build a minecraft client.
well that explains why i have not used this libs, i don't use matrices, anyway maybe if i read a book about them i find any good uses for something i am doing manually in code.
Thank you. I will take a look at your code.
Not a video lecture but there is: [Data Structures and Algorithms with Object-Oriented Design Patterns in Python](http://www.brpreiss.com/books/opus7/) Also, [Python Algorithms: Mastering Basic Algorithms in the Python Language](http://www.amazon.com/Python-Algorithms-Mastering-Language-Experts/dp/1430232374/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1305457763&amp;sr=8-1)
Thank you guys :)
http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html
s/matrices/arrays/ NumPy is good on anything numeric, which typically involves arrays/vectors, not necessarily matrices. SciPy has numerous widely-used functions, from Fourier transform to optimizations
Many people are very sceptical about video tutorials. Books and docs are better. When you are getting stuck with particular problems, ask in forums, chats. The biggest problem with videos is they are giving you a false sense of feedback when there's no feedback at all.
Numpy is a rather elegant library to handle large data. I use it almost exlusively to analyse basic web app statistics (request time distribution, etc...). Handling million of data points is quite simple, and you can easily visualize them.
I've got to say, working with python on a daily basis at work brings to light many of it's advantages. One key advantage is definitely it's readability. It's really easy to see what's going on, it forces indentation, and if everyone's sticking to the PEP8 standard, any text editor you open the code in will show it in the same fashion. if x is not None: # Do something is just plain sexy. 
Books and Docs are my first choice but I occasionally watch videos on a subject for pleasure (assuming the person doing the talk can..well talk).
Well, [the documentation is free](http://docs.scipy.org/doc/) and should give oyu the best overview of what numpy and scipy do.
I believe there are one or two books on Amazon about scientific Python. There's also a pretty good one on Matplotlib.
http://stackoverflow.com/questions/3262603/accessing-cpu-temperature-in-python edit: didn't try it. You may need to enable APCI in BIOS.
I've been googling for hours. I've already seen this one, APCI is enabled too. Doesn't work. Thanks anyway though.
I tried it out myself and I'm getting an empty list. I assume your results are similar. Try running this script and see if you get any results: http://www.activexperts.com/admin/scripts/wmi/python/0366/ Apparently there are many issues involved with this including BIOS and drivers. I also checked the WMI docs about the TemperatureProbe_CurrentReading (if that's what you were using) and it states it doesn't really support that. Dunno why. Edit: running that script returns nothing for me, but it didn't throw any exceptions either.
Yeah, seems the script returns fine. I really would like to be able to do this. It seems that *nix systems can do this with ease via Python..
And a solution from someone who sounds like they may have really wanted to do it as well: &gt;It is impossible to only use VB to get CPU temperature. You must implement Monitor chip driver by C language. If mother-board manufacturers implement WMI in their drivers, you can get CPU temperature from WMI. So far as I know; no mother-board manufacturers implement WMI. &gt;First, you need know what monitor chip on your mother-board. You may look your mother-board. If you see LM75, LM78, Winbond ...etc trademark on your chip, download the datasheet of your chip according to your number of chip. The datasheet will show you how to access the chip. &gt;This web site contains some source code about CPU temperature. The author implemented monitor chip driver of W83697HF and W83627EHF which have Hardware Monitor function. http://temperature.myweb.hinet.net/index_en.htm The source code maybe help you. Obviously, many programs do CPU temp monitoring. An elegant solution in Python may not be in the cards. I believe you may use a CoreTemp DLL as a solution: http://www.alcpu.com/CoreTemp/developers.html
I've seen that thread that mentions finding your CPU temp chip, I can't seem to find the temperature chip Part # on my board. I wouldn't know where to start as to coding for it either. The use of the CoreTemp DLL sounds amazing if I am understanding it right, I just 'link' the DLL and I can call those variables to get the temperature? EDIT: So, ok.. I'm way over my head here to be honest. I'm a lowly uC C writer. I've got the DLL loaded, and I've called the function, but it just prints. funcPtr object at 'some memory address' How do I go about reading what's at that address?
Yes this is what i will do for now, thanks.
Windows: CPUz has an sdk you can use (C++), if you only need Win7 than check the sensors api in the win7.1 sdk. *nix: check lm-sensors python bindings
Scheme is a great classroom language, because it is very easy to lex and parse, and straightforward (if not always easy) to interpret. Enjoy it while you can--and, as someone else said, be glad you are not learning C++ (yet) or Java.
You mean by assigning functions to attributes of _classes_? Or do you mean _creating bound methods from functions_ and then assigning those bound methods to attributes of objects? Either way, I believe the answer is yes. Unless the function is expressly marked as static, it will become a bound method (class methods are already bound to the class). The difference seems to be that in 2.x assigning the function to a class attribute would automagically convert it into an unbound method of the class. This step is simply skipped in 3.x. I guess the biggest advantage is that it removes the following absurdity from 2.x: &gt;&gt;&gt; class Foo(object): pass ... &gt;&gt;&gt; def bar(self): pass ... &gt;&gt;&gt; bar &lt;function bar at 0x...&gt; &gt;&gt;&gt; Foo.bar = bar &gt;&gt;&gt; Foo.bar &lt;unbound method Foo.bar&gt; &gt;&gt;&gt; Foo.bar == bar False &gt;&gt;&gt; Foo.bar == type(Foo.bar)(bar, None, Foo) True 
How about [pyMedia](http://pymedia.org/)? Anyway... I found these searching for any bare wrapping code, watch out the licencing, check the top level projects they might fit what you need: http://code.google.com/p/py4d/source/browse/trunk/py4d/open4d.py http://turnip-town.googlecode.com/svn/trunk/groovewalrus/main_thirdp/soundmixer.py 
yes, sorry, I meant assigning functions from outside class definitions to classes later on. No idea why I wrote "objects" - maybe doing too much JavaScript lately.
I'm on Windows at the moment and I don't feel like running a VM for these functions. Thanks though. It seems as if the CPUz SDK is a paid only thing?
Yep, with python-mode. It's installed by default in emacs23 and runs automatically when you open up a .py file.
[Python by Osmosis](http://www.youtube.com/user/ryanmshea)
I don't know anything about Scheme, but the '+ 2 2' notation is called [Polish notation](https://secure.wikimedia.org/wikipedia/en/wiki/Polish_notation). It's useful in that it makes operator precedence unambiguous (i.e. you don't need to use parentheses to make ordering explicit). E.g. in standard notation, without any foreknowledge, this expression is ambiguous: 2 + 2 * 2 Do you do the addition first or the multiplication? You don't know unless you appeal to some kind of order of operations standard (or parentheses) In Polish notation, this would be written either... * + 2 2 ...or... + * 2 2 ...indicating whether you apply the addition first or the multiplication. It's also a familiar construct in mathematics, where (if an expression has some structure to it) you supply (for example) the [summation symbol](https://secure.wikimedia.org/wikipedia/en/wiki/Summation) and then the expression to be summed over. So it's also a convenience thing. You could write: 2 - 3 - 4 - 5 - 6 - 1 Or you could save yourself some time and just write: - 2 3 4 5 6 1
[Python Design Patterns](http://code.google.com/edu/languages/index.html#_python_patterns) from Google Code University is good. Try the Python Internals on that same page...good technical stuff.
it is printing that because it is a function, call it.
That is suitably awesome. I just wish there was something like this for OpenMQ.
Whoops. I was sleeping that day. For some reason I got Facebook and Twitter mixed up. It's easy since they look and do the same thing, don't y'know? :(
Could you enable SNMP and then use a Python SNMP library to monitor the CPU temperature?
A discussion on the python-dev mailing list inspired this post and has more details, examples, and discussion on alternative behaviors: http://mail.python.org/pipermail/python-dev/2011-May/111278.html
Sad but true: the hard part is that the i2c interfaces to fans and thermistors are poorly standardized. Most boards have them, but the wacky ACPI features like SMBIOS, DSDT are pretty inconsistent. Python support is mostly immaterial -- just finding out which sensors are available for your device and what they're supposed to be measuring is a real challenge. I'd recommend trying to boot a linux livecd/liveusb and looking in `sysfs`. If it works there, you can at least be confident that all of the necessary hardware bits are working and configured correctly. grep . $(find /sys -name '*temp*' )
That is a lot of work! 
The Win 7 Sensors API is only for GPS and ambient light sensors AFAICT.
Maybe... I have to admit I used a long long tome ago, maybe they have changed the license. Sorry.
As a matter of fact, it's the writing of the article that inspired the python-dev discussion. I was trying to make sure my understanding of the topic is complete. As you can see there, many other core devs think that the current error isn't satisfactory. Hopefully we'll fix this for future releases.
I'll need to look in win7.1 sdk manuals, I remember reading about the temperature but I could be wrong. EDIT: &amp;#3232;\_&amp;#3232; thermometer sensors, not CPU.
A lot of work once, though, rather than per server installation.
How?
That's correct. The key take away (which I failed to communicate in the article) is that this is reproducible.
Again why I love python: at first it seems all simple, clean and wonderful .. but then you meet odd corner cases like this that require a deep understanding of the VM's mechanics to see why they happen, at which point the unholy mess rears its head and you begin to wish Guido had [read SICP before he started](http://www.reddit.com/r/programming/comments/8lgp0/guido_van_rossum_somebody_mailed_me_a_copy/).
Cool. I got very confused for a second, thinking what would happen if you incremented an integer and then created a second integer that had the same value as the first did initially, then I realised that incrementing the first integer would make it point to another PyIntObject in the small integers block (assuming it's still small) rather than increment the PyIntObject.
`some_func()()` where the output of `some_func()` prints out the above.
Would you care to be a little more in-depth, you're dealing with a nooby here... Sorry guiz...
sucks
IMHO this is a very shallow explanation, focusing on how the memory for integers is managed, rather than on their implementation. It would be much more interesting to see how integers are "promoted" to longs when required, and how longs (arbitrary-precision arithmetic) are implemented. Python uses some clever algorithms in there.
[c-types tutorial](http://donaldkenney.110mb.com/CTYPES.HTM)
Thanks for the response! I may try it again with python3 on my own time just to see how well it works, but for now I just decided to write it in python2.7.
Thanks for this. I'm at work at the moment so I'll try it out. I hadn't actually found this document and there seems to be some simpler methods throughout. Thanks!
[Here are the slides as originally posted](http://www.slideshare.net/pydanny/django-worst-practices) ([via](http://www.reddit.com/r/django/comments/guwm4/django_worst_practices/))
Any chance of you stopping spamming these terrible examville submissions of poorly presented stolen content
I don't see how it's shallow, it seems limited to me, and quickly readable. Maybe the title is misleading however, and should perhaps be "How integer objects are managed by Python internally", which coincidentally is the first line of the page. For what it sets out to do, it does well I think. Well written, for it's limited topic.
Hmm, you could use subprocess module to call sensors (of lm_sensors)? 
Might want to give [ctypes](http://docs.python.org/library/ctypes.html) a try. Must warn you though, that if not used properly, you could segfault python, making debugging a bit difficult. 
cython and swig are the fastest way to do it if you have a compiler with you. ctypes library in python if you are dealing with dynamic library and needs cross implementation 
How does one deal with synchronization?
Not on a windows machine...
I haven't used it yet (I may try to wrap parts of the MIT kerberos library with ctypes in the future if it's needed) but this may help with the segfaults: http://pypi.python.org/pypi/faulthandler/.
`pip install pypy`
Just as a note, though... Even if the dll provides the function, you still need board level support to make a CPU temperature read possible unless the CPU has an internal register for temp (eg: intels are more likely to throttle their cores if the temperature is too high, but only some of their chips have the register). Some of the boards provide an external interface to a chips temperature pin (again not all chips have this). And some boards just have their own temperature sensor somewhere on the board near the CPU. So there are a number of different configurations possible. And generally you need to have the board manufacturer provide that interface in some dll/driver. In general: if you have a working example of c code which implements the functionality you desire, then you should be able to use win32 or ctypes to access the internals. Ideally you will also have a header file for the dll so you are not guessing blind what the function call should be. That said it is also possible to build the interface in python manually even if you don't actually have the header file.. though I am not sure how you would know what to make the interface. I would read up on extending python with c/c++. You should be able to google it and find some tutorials. I ended up doing that last bit when I needed an interface to a hardware bus and importing the DLL directly wasn't giving me what I needed.
And the manual method is in the documentation under extending python using c/c++. If you are doing it for the first time and you can afford to spend the time to gain understanding, I would definitely force myself to try the manual method for at least a couple functions. Once I did that the first time I had a really clear understanding of how to extend and utilize shared libraries effectively
Well, so far I've managed to load the DLL and call the single function that's in the DLL. I presume that my system will be able to give me the desired values since Core Temp itself (and many other programs) can give me the temperature of the CPU. The Core Temp dll comes with the header file and I know which function to call, I'm just hitting a few snags actually getting the function to run correctly. 
Wrapping C is easy and there are a bazillion tutorials. Using C on the other hand....
You'd need some kind of locking. In his example the second process is read-only so that's not really required, with the caveat that your reads will not necessarily be atomic.
Try pyrex as well.
`ctypes` is awesome, and is usually the simplest solution for "I just want to call this function". Go for it.
kisielk is precisely correct. Sadly I don't think Python's stdlib allows easy access to POSIX semaphores, but this appears to be a nice package for accessing common POSIX IPC functions like semaphores: http://semanchuk.com/philip/posix_ipc/#semaphore For my eventual goal of exposing metrics I'll avoid locking by only having 1 writer and have double buffers for each metric. Double buffering means there's a read buffer, write buffer, and buffer pointer for each metric. When writing a metric you check the buffer flag to determine where the write buffer is located, update the write buffer and switch the read/write buffer pointer. Readers check the buffer pointer and read from the active read buffer. The buffer pointer must be a single byte to avoid race conditions when updating it, so it can only contain a relative offset instead of an absolute memory address.
I just did a project with SWIG. It's a little bit heavy and for anything outside of plain vanilla code it can be hairy, but for simple projects it works quite well. They also have the advantage of having been around for a while.
cython is made for when you "can call it from pure C" and know what the prototypes of the functions are. Load it up and call into it, making sure that you set up the parameter types correctly (by default it accepts and returns ints so you've gotta cast them correctly). You can even do pointer stuff with ctypes. cython is good also if you want to wrap a C module with the python extension framework so it can be loaded directly into python. If you're using pure C maybe cython is a bit much.
Have you thought about using something like a SQLite database on a tmpfs instead? You could then use transactions to make database updates atomic, and SQLite allows a writer to lock a database for writes whilst still allowing concurrent reads.
My god...what have you done?! lol **Edit:** Very nice btw, look forward to some more info. 
Skimmed the documentation, really like what I see. I'm going to be checking this out ASAP. Read the Quick Start tutorial: http://getcolony.com/docs/colony/documentation_how_to_expand_your_colony_in_10_minutes_or_less.html I wish they were a little more in-depth with the security side of things (logging-in, CSRF, etc). They opted to simplify things at the end and allow any user to send a GET request to delete an item. Perhaps that stuff would better fit into a larger guide.
Single biggest reason why the projects at my work can't (yet) switch: psycopg2
Thanks for this! These all look very interesting and I'll be sure to try them out. :)
Looks like this product is based on their work as a web consultancy, and they're already "eating their own dog food": http://hive.pt/products If anything, getting your in-house framework turned into a popular open-source community is a huge benefit. They can land bigger clients with the publicity and benefit from the volunteers who will contribute back modules, patches, and documentation. I wouldn't be surprised to see if this wasn't just an amazing way to promote their upcoming cloud computing software-as-a-service platform. Looking forward to whatever they come out with.
Highly agreed. The C interface for Python is remarkably good. I've tried SWIG before and honestly it takes almost as much time to work around the bugaboos as it does to just use the native API, if you are already proficient with C. SWIG seems to be most useful if you have to wrap a rather large C/C++ library.
I ported psycopg2 to PyPy! It requires you to translate yourself however, would making 32- and 64-bit linux binaries available be helpful?
Since when did they change logo? The new one looks great. A snake eating itself is an indicator of touring completeness?
Python 3 support. I filled it in in the survey but if pypy supported 3.2 I'd switch the binaries out tomorrow. We use a lot of perl and I'm slowly evangelizing python as a replacement; since it's green field and we don't have many dependencies (yet) I'm starting with 3.2 and skipping the whole legacy code transition entirely. So far we've been able to do everything with only pure-python libs so pypy would be a drop-in. 
I tried pypy on a pure python UDP proxy that takes all incoming packets from 1 port and sends it to another IP. It used 50% more memory and ran 33% slower than Cpython.
&gt; I have a C library which does some Stat functions Statistics functions? Like the ones you'd find in `numpy` or `scipy`?
if you want it to quit on win import sys at the top and call sys.exit() in the win() function.
add return before all Room[1-6]() calls, instead of just calling the function. Like so. def Room6(): global visits6 visits6 = visits6 + 1 print() print('You are in Room 6.') #South goes to Room4, West goes to Room 3. print('You can go South or West.') print('Which direction do you go?') direction = input() if direction == 'South': return Room4() if direction == 'West': return Room3() Its printing winning statement 3 times because, it is returning back to the spot where you called, and continuing from there. 
I'm really only looking for a simple key-value store, so something like bsddb or TokyoCabinet would be far lighter weight than SQLite and meet my needs. However, I'd like to be able to comfortably alter dozens or more values in the course of a web request with a minimal effect on latency (sub-ms). If nothing else this is a fun experiment to see if doing it the hard way is worth it. :)
I think your problem is happening when the functions reach the end. When you hit the end of a function, it doesn't stop the program: it returns to the function that called it. So after Win() is called for the first time, it returns to Room5(). Room5() then finishes, and returns to the function that called it. That function returns, and gives control back to an earlier invocation of Room5(). That invocation of Room5 notices that visits5 is &gt;3, so it exits the loop and calls Win() again. That's why you get "You win the game." three times. Why do you get "That is not an invalid direction" at the end? Check out the code here: if direction != 'North' or direction != 'East' or direction != 'West': Those "or"s should be "and"s. After all, no matter what direction you get, it's going to be not-North OR not-East OR not-West. Anyways, it's a nifty beginning program. And welcome to python!
After a function has run out of instructions it will return to where it was called from. This is why the program keeps going. Eventually you might want to refactor (modify) your code so that you have a single room class that you instantiate to separate room objects. Also a main() function is usually nice to have where variables/objects are set up which can be returned to from function/method calls.
I think (I don't have Python 3 installed, or else I'd check it) that the issue lies in your while statement. Short answer, use: if visits5 &lt; 3: ... else Win() import sys #Python 2, assuming it's the same with 3 sys.exit() #ends the program. Think about what happens with the function calls as you have it now. When you enter Room5(), you start a while loop that is waiting until such time as visits5 &gt;= 3. You then exit the function to run either the Room2() or Room3() function, leaving Room5() waiting for a return from either one of those function. You then start a new Room5() function when you enter it the second time, and a third when you enter the third time. At that point, the while conditional is met for all 3 Room5() functions that are sitting on the stack. Each one finally gets out of the while loop, and each executes the Win() function. I believe it goes back to room 1 because Win() returns to Room5(), and program execution continues through the file, eventually re-running Room1(). I'm certain I'm missing something here, so others will likely jump on my answer with better information. All that being said, there are much, much better ways to do this program. Try using one main function to call to each of the room functions, and have each room function return the room that the player moved into, and go from there. You won't need the globals, as you can keep track of the visits in your main(), and you can execute the Win() from there.
you don't need sys I believe. exit() Both options work in python 2 and 3.
You can do visits6 += 1 instead of visits6 = visits6 + 1
Kewl
It nearly worked for me (python 2.7), I did a few changes to the [base code](http://codepad.org/1ygwFSAf). I have a few general advices though. - you don't have to use global. If you want to use globals, define it outside a function then (I did that with "visited". fyi, it's a comprehension list) - if you want to increment a variable, you can write it like that: a+= 1 - if you want to print a new line, you can use "\n" instead of using an empty print. - if you have multiple related "if" test, you can use elif (else if), and a final "else" to avoid the triple test you did in room1. - start counting at 0, not 1. it's easier to use array that way because array index starts at 0, that's why I renamed your rooms and used the array "visited". Or... you can use a dict. - but the biggest problem in your program is the recursive aspect (calling function in function in function). Try to travel a few rooms then press CTRL+C, you'll see the call stack. You should try to use function parameter and return value to reduce global I rewrote a little bit your code with a dict, an no recursive functions. http://codepad.org/tABiE6sK I also use the keyword 'in' to test if a key is in my dict. And finally, I recommend you to read [DiveIntoPython](http://diveintopython3.org/), there are a lot of good advices and explanations about standard stuff, like the comprehension list or dict. Good luck :)
Heh, you're faster than me. I redid it with classes and dicts, see it here: [http://codepad.org/LR5r0uEa](http://codepad.org/LR5r0uEa)
I will also try them for sure.
Some unrelated tips: - rather than using an empty print(), you can add '\n' to your strings - it's the code for a new line. - look at each of your functions, see how a lot of them are the same. Try to think how you could make another function that does the repeated work. Much of programming is trying to be lazy and avoid repeating yourself. As a puzzle, can you think of a way that you could use a single function that took parameters for all 6 rooms? - a lot of programmers are touchy about syntax. It's because reading code is hard work, and strange syntax makes it harder. That's why you'll see flame wars about insignificant things like spaces, or capitalisation. In general, in python, functions start with lowercase letters. Google PEP8 for more rules than you'll care about. Hope these help, keep at it!
Cool, will have to try these.
The install isn't hard at all — you should give it a try. And, while I understand you wanting it to maybe be simpler, PyPy isn't a Python package (which is what the majority of people use `pip` for — an `easy_install` replacement).
Might need to use this for a class I am taking next semester. 
It seems that a lot of effort was put on this, but I don't get exactly what it is, or to be more precise, what concepts/models it follows. Can anybody make a parallel with similar projects in Python or other languages?
Somehow I can't help and read "getcolonoscopy.com" every single time.
Interesting. This is a good start for a game like [Hunt The Wumpus](http://en.wikipedia.org/wiki/Hunt_the_Wumpus). Maybe try recreating the game, and then writing an AI/solver to solve it (it's used as a toy example when discussing logic based AI agents).
nice xml config file :S
Huh? No, it's because it's a Python implementation written in Python. Eating it's own tail, see?
Agreed. SWIG is fine for prototyping if you want to quickly setup a C library under Python but for anything in production you probably want to head for either ctypes or cook it yourself. Programming a C extension for Python is not as difficult as it may seem, there are good examples to start from.
Ziggurattt, think about what would happen if the user enters something you're not expecting. For instance, if they're in Room 2, what happens if they go South? If you put all of the checking into Room2 as you have put into Room1, you will start to see a pattern. PeterBraden's suggestion is the trick of the real programmers. Try to be lazy. Whenever you see a pattern like this, there's an opportunity to be lazy. If you think "lazy" is an anti-virtue, wait until you're dealing with a bigger program, it actually requires a lot of effort to be as lazy as is required. If that sounded like a contradiction, welcome to programming :-)
Re-doing the code isn't going to teach Ziggurattt anything. He needs to learn what patterns to look out for, and what other patterns he can replace them with. No better way to learn these important points than by being guided to figure them out yourself. You've both demonstrated you're clever, but does that really help Ziggurattt learn?
Really? You want to push classes on him now?
Here's an exact answer to your questions. Both issues you're running into are related to each other. First: &gt; it repeats: new line, "You win the game!" (three times) This is because you're calling a function inside a function inside a function inside ... etc. You're probably thinking of **GOTO** or jump-style commands: "leave here and go do &lt;this bit of code&gt; now". Functions are not like that. Functions work like the movie Inception. When a function (say, Room1) calls another function (say, Room2) - you've started a deeper level of code that, once it finishes (the dream ends / code stops), you return back to the higher level where you were before. So if I was running your code and walked like this: Room1, Room2, Room5, Room2, Room5, Room2, Room5 -&gt; Win ... the actual depth you've reached is like this: Running Room1 code ... [deeper] Running Room2 code ... [deeper] Running Room5 code ... [deeper] Running Room2 code ... [deeper] Running Room5 code ... [deeper] Running Room2 code ... [deeper] Running Room5 code ... [deeper] "Win" Now that we've won, the deepest Room5 function *completes running* - so it winds back up to the next level up (Room 2) which has nothing left to do, so it completes and runs back up ... etc. The reason you see the "You win the game!" message 3 times is because in order to get to a winning state, you have to have visited room 5 a total of 3 times ... and the way your code is structured, that means there are a total of 3 "room5" levels in your stack. The deepest one is where you "won" - but as your code winds itself back up the levels as each one completes, whenever it runs into an earlier "room5" level - *the message prints again*, because now each of those levels can exit "while visits5 &lt; 3" (because you're using globals - each level sees the same visits5 value) and each of them gets to "win" / print the message. ---- &gt; and then "that is not a valid direction" and then takes you back to Room 1 This is for the exact same reason. The shallowest level of your game is always the Room1 code - so when you win, you always, eventually, wind your way back up to it. Combined with the issues listed above, the real problem here is the last line of your Room1 code isn't doing what you think it is. You're using "or" when you meant "and". Because you used "or", if **any** of the three comparisons are True then the error message triggers. Example: Say you entered "North". With your line of code: if direction != 'North' or direction != 'East' or direction != 'West': Translates roughly, when evaluated, into: if (False) or (True) or (True): ... which means that because 'North' did not equal 'East' (and also did not equal 'West'), the code *still* executed. All it takes is one part of an "or" statement to be True for the whole thing to be true. You wanted "and", like: if (direction != 'North') and (direction != 'East') and (direction != 'West'): This requires that all 3 of the comparisons be True for the code to execute (namely that direction is not North, East, or West). Also, consider using this code instead: if direction not in ['North', 'East', 'West']: 
Kinda interesting, but caused a flash-back to my 1990s java days... def load_plugin(self): colony.base.plugin_system.Plugin.load_plugin(self) global hello_world_mvc import hello_world_mvc.mvc.hello_world_mvc_system self.hello_world_mvc = hello_world_mvc.mvc.hello_world_mvc_system.HelloWorldMvc(self) That's a lot of keystrokes :)
GPL v3. . . . NOOOOOOOOOOOO. Someone needs to kill setuptools somehow . . .
.... TIL...
Be aware of some chapters; especially the ''USing SQL''-chapter presents some non idiomatic examples. The author uses normal string format methods instead of special, DB-API2 related stuff, which inhibits SQL-Injection. The choice of using Postgres is imho another mistake. For these little demonstration sqlite should be sufficient. As there is a module in the standard lib and no server needed it is much easier for beginners to follow the execise.
Can someone explain to me what this is? I don't get it.
I did not understand.
Cython has superseded its granddaddy Pyrex with more releases, [more features, and Python 3 comptability](http://docs.cython.org/src/userguide/pyrex_differences.html).
The documentation is receiving a major overhaul and will be nice and shiny soon enough ;)
lots of work on that documentation already, looks awesome :)
&gt; I ported psycopg2 to PyPy! Yes I've seen that, however... &gt; It requires you to translate yourself however, That's what kept me from considering this for our production systems since the deployment is (at least currently) based on pip requirement files. &gt; would making 32- and 64-bit linux binaries available be helpful? If they were pip installable: YES, please!
Why did I not know about this a couple of months ago... I was trying to get a flask application going with gunicorn and nginx, but it was a massive pain to start it every time. Now I know what to do later
Check this video it kinda shows some of the ideas behind the framework http://www.youtube.com/watch?v=ATgSv8uUqe0
pip doesn't install binaries. It uses source files only.
Take a look at OSGi: http://en.wikipedia.org/wiki/OSGi . I guess you can say this thing is supposed to work like OSGi, but without all the overhead.
It is so weird when pythonistas have the reaction "Oh noes, XML, run!" at first sight of **any** XML.
&gt;Really? You want to push classes on him now? Absolutely, this thing just screams for classes! He's written essentially the same code 6 times. If he wants to make more rooms, he's going to have to write way more code, and alter more of them. class Room(): #OP: Classes are just nice containers for functions and methods. #OP: They have instances, which is like "my dog Rex", and classes, which is like "dogs in general". #OP: A 'method' is just a function that belongs to a class/instance #OP: Methods have the same syntax as functions, only you put "self" as the first argument in the definition. #OP: "self" is implicitly included when calling the instance (eg, myinstance.method(arg) -&gt; method(myinstance, arg) def __init__(self, room_number, north=None, east=None, south=None, west=None): #OP: __init__ is the special method where an instance is customised #OP: eg, where I make give "Rex" his "Rex"-iness that the other dogs dont have. self.Number = room_number self.North = north self.East = east self.South = south self.West = west self.Visits = 0 # Link neighbours to self; if hasattr(self.North, "South"): self.North.South = self if hasattr(self.South, "North"): self.South.North = self if hasattr(self.East, "West"): self.East.West = self if hasattr(self.West, "East") self.West.East = self def GenericRoom(self): # method to run for a generic room. Done as its own method so that __call__ can be easily overwritten by subclasses self.Visits += 1 print("You are in room number {0}".format(self.Number)) valid_directions = [] # make a list of valid directions for room in (self.North, self.South, self.East, self.West): if isinstance(room, self.__class__): #self.__class__ and not Room because it hasn't finished being defined - long, long story! valid_directions.append(room) direction = "" while direction not in valid_directions: if valid_directions: if len(valid_directions) &lt;= 2 print("You can go {0}".format("or".join(valid_directions))) else: print("You can go {0} or {1}".format(", ".join(valid_directions[:-1]), valid_directions[-1]) else: raise Exception("Game is broken, the room is a one-way trap!) direction = input("Which direction do you choose?:\n" ) return getattr(self, direction) # return the new Room def __call__(self): # OP: __call__ is a special method to makes classes callable like functions return self.GenericRoom() class SpecialRoom(Room): # OP: SpecialRoom is a sub-class of Room # OP: Eg, like a labrador is a sub-class of Dog (Labrador is not *a* dog, but it's a *sort of* dog) # OP: Anything defined in a subclass overrides the super-class # OP: Anything not defined in a subclass inherits from the super-class def Win(self): print("You are Winner!") return "Winner!!" def __call__(self): if self.Visits &lt; 3: return self.GenericRoom() else: return self.Win() Room1 = Room(1) # Create first room, no links because no other rooms exist yet! Room2 = Room(2, west=Room1) Room3 = Room(3, south=Room1) Room4 = Room(4, east=Room1) Room5 = SpecialRoom(5, south=Room2, east=Room3) Room6 = Room(6, south=Room4, west=Room3) current_room = Room1 while True: # launch game new_room = current_room() if new_room != "Winner!!": break else: current_room = new_room OP: You're doing fairly well for a beginner, but you unfortunately picked an exercise that is almost tailor-made for an object-oriented approach. You have lots of little, nearly-identical things - and a good piece of coding advice is *Don't Repeat Yourself*! Python's OO is nice, but almost every tutorial doesn't cover it until later because it takes a lot of explaining (eg, "*what the hell is self*" - it's a variable assigned to the current instance, so you can "talk about yourself", kind of like the word "me" for the english language).
This is exactly the book I have been dreaming of since I started learning Python 2 months ago. Thank you!
&gt;I'm just trying to learn programming on my own I think using globals like that is generally a bad idea.
I would consider it bad practice to return the result of the function when in fact the function does not produce a result (other than the default None, of course). Better: Room4() return
Classes are not the only answer to handle reuse of code, especially in Python. Edit: also, just think about the learning curve. For an absolute beginner, is is perfectly fine to not use classes for a while but concentrate on basic things like function calls, loops, recursion, ...
setuptools can install binaries. :) 
It's nice of you to step in and contribute to Reddit by commenting. I do feel your comment is rather strict. These guys did make an effort to show how they would approach the OP's problem. If Ziggurattt will take the time to read their solutions, he will probably learn from it. Maybe you could attribute some credit to the commenter next time, making your critique more balanced. Then it is more likely the commenter will learn from your remark.
Maybe this thing screams for classes, but I do not think the OP speaks "classes" yet... I agree with fas2.
I have to admit, i thought this was going to be a joke thread and the code would be something like "sssssssss"
I hope Python 3.2 works out for you, oftentimes you would need something that is only available for Python 2.x.
But an easy way to install pypy binaries would be very beneficial. sudo apt-get install python-pypy or something like this. Installers for Windows/OSX if they don't exist yet.
I hope Python 3.2 works out for you, oftentimes you would need something that is only available for Python 2.x.
http://en.wikipedia.org/wiki/Ouroboros
I found it awfully annoying. I'm a java guy, I'm familiar with all the java stuff, I found myself looking through the docs and all it basically said was, in paragraph after paragraph: "modularity is good... this makes modular... modularity is good... this makes modular.. "arrghh. What does it actually fucking do and how?!?! 
Did you really read what I wrote? I improved a little bit his script first and gave some advices about what he did and how he can improve it. Then I wrote an easy script to understand with some mandatory stuff to understand in python (like a dict). Your comment was less useful than ours...
Ah, accidental recursion. I teach intro programming to high school students, and I see this kind of thing fairly often.
&gt; Functions work like the movie Inception. I am so totally stealing this for the next time I teach functions.
Looks like an awesome amount of work and quite clever. Unfortunately it doesn't appear to solve any problem I've ever encountered? What exactly are the aims? hot-loading plugins into a site/app just doesn't seem to fit into any kind of design-cycle I've ever used (where changes are made and tested on a local instance and later pushed live)? *trying not to be negative; genuinely asking why I should take a look at it, or what it solves so when one-day I do have the problem I'll know to come back*
I've used CTypes, Swig, and Cython. I strongly recommend Cython. Example projects I have used it with are [libfreenect](https://github.com/OpenKinect/libfreenect/tree/unstable/wrappers/python) and [hadoopy](https://github.com/bwhite/hadoopy). * It generates the .c source for a python module, this gives it a very limited footprint into your project. * If you distribute a .py file using Ctypes, I promise you most of the problems your users will face is finding the .so file. Nothing does a good job, if you run the script from a different directory than the .so you need to use LD_LIBRARY_PATH and it sets the bar pretty high for all of your users. With Cython you get a python module which has a much more standardized place on your system. * The code it generates is fairly efficient (I've had 100X improvements going from Python to Cython); however, this requires understanding how it works and at first it is possible to lose speed in degenerate cases. For a wrapper this matters because it adds very little overhead to your code and has a simple path from your python call, to a python module (written in cython, which can you see the .c source for), to your .c code. * Swig is even more complicated than Cython and it can be a real pain in the ass to get working. I recommend you stay away from it if possible. It is good if you have an extremely large c++ library that wouldn't be practical to individually wrap in CTypes or Cython; however, it gives you little control over the finer aspects of your interface.
Inception!
Unfortunately not. It's a package that estimates the parameters of a [Stable distribution](http://en.wikipedia.org/wiki/Stable_distribution) given some noise. It can also compute the PDF and CDF of Stable distributions given the parameters.
Like these? [CDF](http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.cdf.html#scipy.stats.rv_continuous.cdf) and [PDF](http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.pdf.html#scipy.stats.rv_continuous.pdf) and [levy-stable](http://www.scipy.org/doc/api_docs/SciPy.stats.distributions.levy_gen.html)?
Isn't there a distinction between CS and programming in English? Because IMO this is "just" a book on programming.
Globals make your code hard to test. In small programs like this one that really doesn't matter. However, it is a bad habit to get into so I'd avoid them all together.
Here's the [link](http://www.robustanalysis.com/). It's similar to those, but I mostly need the parameter estimation function.
Here's something to get you started: for z in xrange(60): filename = 'data{0}'.format(z) with open(filename, 'w') as f: f.write('some text')
The file name you pass to open doesn't need to be a literal string - you can build a string and use that as the argument to open. for z in range(60): # calculate your data for this run, then... outfile = open('data%s' % z, 'w') outfile.write(data) outfile.close() The % operator will substitute a value for a placeholder in a string. The expression 'data%s' % 3 will give the string 'data3'. If you're using a recent version of Python (2.6 or above), you could also use 'data{0}'.format(z). 
Ooh, good call on the with statement. OP, that guarantees that the file is closed when execution leaves the with statement, even if code in there returns or raises an exception. 
Yes, Python is like that.
Me too 
and still...the oh mighty django framework isn't compatible with Python 3. what a shame.
Can you post the source? Maybe some pypy dev can take a look
I think as more and more shops use Python to write Really Large Disparate Applications this kind of thing will become more relevant. For example: say you run a hosting provider and you have a lot of python code running all sorts of areas -- elastic provisioning, monitoring etc, etc. At the center of all of this activity is billing so you can get paid for what all of these different bits are doing and recording on your clients' activity...one way you can tie things together is using a modular system so that if, say, Brenda from marketing throws a requirement on your desk to run a promotion for a certain class of customer you can code to a service 'interface' and plug it in when you are done without a general redeploy of your whole billing infrastructure and without worrying about how it might affect everything else. Your filter ensures that this particular group of clients is affected and this particular group only and if anyone else needs similar billing your module is ignored because it doesn't 'fit' and another suitable service is requested. TL;DR Modules = greater encapsulation.
Ah, right I thought I knew that. /edit: Actually now that I think about it I usually cheat there and have psycopg2 and PIL already installed through the distro's packaging system (apt usually). So I can get by without having a compiler on the production system.
In Python 2.x, new-style classes will inherit a [`__hash__`](http://docs.python.org/reference/datamodel.html#object.__hash__) from object, which is based on `id &gt;&gt; 4`. If you override `__eq__`, then you also need to implement `__hash__`, since equal objects should have the same hash value. To ensure that a mutable object has no hash (and thus is not usable for a set or dict key), set `__hash__` to None in the class definition: class A(object): __hash__ = None def __eq__(self, other): return True In Python 3.x this is done automatically. See [issue 2235](http://bugs.python.org/issue2235) for further discussion.
No I can't post it because of work. It is not that hard to make, I just don't have the time or motivation to remake it or reduce it right now.
As "p1r4nh4" correctly pointed out below my first reply pip only installs source... So after thinking about it for a moment in the long run it would be nice to have pip install be able to build pypy-psycopg2 (without having to compile the whole of pypy - as seems to be necessary atm). But as a short term solution I think (static maybe) binaries may be the easiest way for now. (Of course it would be awesome to have distro packages, e.g. a PPA for ubuntu)
There is supposed to be a distinction. In practicality, there is no difference between "Intro to CS" and "Intro to Programming".
Saved. Going to peruse this later...
Hmm, I can't seem to find the proper change log for this release. The changelog on the page links to an old Misc/NEWS file in the 3.2 svn tree...
Just glancing over this book, there is quite a bit of it I take issue with. The code is all very non-Pythonic and downright ugly. It is also often extremely wasteful. Tuples are mentioned once and never used. Scoping isn't discussed until Chapter 9. Modules and what import does is not mentioned until Chapter 15. The introductions to classes is absolutely awful, and starts out by using class variables instead of instance variables for storing information which should be associated with an instance. Actually, as far as I can see, it never fixes itself to use instance variables anywhere. There is a chapter on Excel macros in the middle of the book for no reason. In Chapter 17, they just start calling lists "arrays". This "book" is garbage.
Its a simple case of Pavlovian conditioning: Hear/see XML -&gt; expect pain
Also highly regarded (and it's free): http://learnpythonthehardway.org/
Good luck! A long, long time ago, I wrote my first ever real program -- a number of rooms that you could walk through that looked very very much like your program :-) (only in C64 BASIC and with gotos) Since then I've learned dozens of other languages, got a CS MSc and have worked as a code monkey for like a decade, so be careful...
There is some silly thing in the style guide http://getcolony.com/docs/colony/documentation_colony_style_guide.html * Do not use the from statement when importing modules * Avoid using named arguments don't understand why
This book has some CS topics; searching and sorting stood out to me. Maybe there are others.
Actually, this is well documented in `__eq__` and `__hash__` function docs http://docs.python.org/reference/datamodel.html?highlight=__eq__#object.__eq__ http://docs.python.org/reference/datamodel.html?highlight=__eq__#object.__hash__ so, reading the docs can help. Btw, in Java the same advice applies… 
Whatever... he's obviously bright enough to tackle learning programming on his own. Classes are just another few minutes to someone like that.
The RC was cut from the release manager's personal clone, which is the only place the 3.2.1 tag currently exists until it gets pushed back in...so there's a bit of a problem with that right now. Still working out the kinks of releasing from `hg` instead of `svn`.
&gt; ...does that really help Ziggurattt learn? Yes, yes it does. I can try to hammer out a dent in a car fender for days, finally getting to a point where I can sand and paint it, only to put it back on the car and have things not quite line up. The car drives, looks ok, but it's somehow 'wrong'. An experienced auto-body mechanic can show me how he does it, without removing it from the car, and how it looks better, works better, and takes less time. The next time I need to un-dent a fender, I at least know where to start, and what tools I should have on hand. &gt; He needs to learn what patterns to look out for, and what other patterns he can replace them with. What the hell do you think I (and Syl) just did? We took a program Ziggurattt had written, and re-wrote it in a manner that is much easier to read and debug, is more extensible, and is closer to 'the right way'. When I first learned how to program, I would have killed for that sort of response. Especially in a non-critical, welcoming forum that encourages follow-up questions like this one. Being able to compare my first stab at it to what a more experienced programmer came up with would have shown me the patterns to look for. It would have taught me that the right way to do it is to use the tools available in the language. It would have given me insight into 'what else' I could do. That 'what else' is how you really learn to program, when you look at the next problem and say, "I'll bet I can write a solution to this." The forth or fifth time you answer that question with working code, you've become a programmer. &gt; You've both demonstrated you're clever... You are clearly missing the point of our replies. If I felt the need to demonstrate my superiority, my comments would have been much more akin to your posts on the matter, holding the concept of classes up to be some nigh-unattainable concept that no mere mortal can grasp. I re-wrote the 'game' because I thought it would be fun, and I though that Ziggurattt might benefit from seeing exactly what he wanted to do done by someone with a bit more experience. I was trying to be the auto-body mechanic.
You may also (ab)use the logging module to do this for you. Set up a http://docs.python.org/library/logging.handlers.html#logging.handlers.RotatingFileHandler and manually call doRollover() on each loop.
ala "finally" or "end" elsewhere.
I came here knowing how to do this, now i know how to do it better. Thank you all.
How is the code in the example http://getcolony.com/docs/colony/documentation_how_to_expand_your_colony_in_10_minutes_or_less.html any different than this (complete web2py code) db.define_table('task',Field('info')) def index(): form = crud.create(db.task) page=request.vars.page or 0 tasks = db(db.task).select(limitby=(10*page,10*page+10)) return locals() except that it is about 20x longer and looks like Java, not Python? They do have a fantastic web design but they need a better job at explaining how it is better/different than a regular python web framework.
The coffee is wearing off, so forgive me if I'm misunderstanding what you're asking, but I think you could do this with selects: cursor.execute("select router_name,router_model,ip,count(*) as count from routers group by router_name") routers = cursor.fetchall() for line in routers: router_name = line[0] router_model = line[1] router_ip = line[2] count = line[3] if int(count) &gt; 1: cursor.execute("select ip from routers where router_name = %s", (router_name)) ips = cursor.fetchall() for ip in ips: router_ip = "%s %s" % (router_ip,ip) print "%s,%s,%s" % (router_name,router_model,router_ip) looking back over your description, I think I missed a few attributes, but you should get the idea.
Came here to post just this. It's always annoying when people consider documented behaviour to be a "bug"
I see! Also, the link has now been fixed. Studying it as we speak: I wanted to find out if the trailing "\r" problem with input() was fixed. It seems it is.
Not to mention old-style classes, mixing of cases and different indentation styles everywhere. People attempting to learn python should steer clear of this piece of shit.
Hate to sound like a wet blanket, but I wished they could show more code or examples instead of being centered around one large image.
This is a really fun project. I hacked together a [stupid AI of my own](https://github.com/chromakode/dmanai/blob/master/chroma/x.py). It's a great feeling to see your AI face off against other opponents and strategize about how to improve it.
in big codebases, from imports are bad form, since you can quickly run into conflicts. avoiding functions with a variable number of arguments, in general, has to do with playing well with other languages and RPC protocols that do not support them.
If you're using mysql, just use the [GROUP_CONCAT](http://dev.mysql.com/doc/refman/5.0/en/group-by-functions.html#function_group-concat) function. Or [string_agg](http://developer.postgresql.org/pgdocs/postgres/functions-aggregate.html) (I think) on postgres. ...Or you can just loop through the results, print the line if the hostname changes otherwise append the address to the "working" hostname data...
[lasso](http://scikit-learn.sourceforge.net/auto_examples/glm/lasso_path_with_crossvalidation.html)?
Thank you for the help, kind sir/ma'am!!! 
Hey, I was using it to write a fits file with python 2.5, and your first method worked great, thank you!
This seems interesting, I gotta read up more on the logging handlers to see what they can do for me in the future, thank you!
Thank you for taking the time to post these comments. As a new python user, I wouldn't have even noticed all these issues. I really appreciate it!
I second GROUP_CONCAT. There doesn't seem to be any merit to be doing the grouping after retrieving the data from the db.
Lots of companies actually use it in production. They had a whole section of the sandbox for them. See Guido's tweet for one: http://twitter.com/#!/gvanrossum/status/46740553890660352 I actually spoke to the guy who set up the new pricing at I/O, and one of the reasons he stated for doing it was that people consider it a toy. I don't remember any of the others really, but the overall feeling is that they intend to make it a serious service instead of a playground.
You can also use the [format specification mini-language](http://docs.python.org/library/string.html#format-specification-mini-language) to zero pad the index: for index in range(60): filename = 'data{index:0{width}}'.format(index=index, width=2) 
&gt; several thousand members and potentially hundreds of thousands of posts. sqlite is great for development and even low volume single server deployments, but I think you'll want mysql and here is why: * sqlite cannot work as client/server so you can only have single server deployments. You'll probably want a dedicated DB box eventually. * sqlite can only support a single writer at a time. Think myisam but the entire DB is that way (multiple readers, single writer) * Sounds like you want to build a web2py app not learn the ins and outs of another DB, so stick to what you know. All that said sqlite is a really great embedded database and there is no harm in using it for development. You could even use it in production as long as the app remains the size you are thinking. I think will guess that hundreds of uses and hundreds of thousands of posts might be pushing sqlite, but maybe not. Depends on how well you structure your database and app I suppose. I think I would start with a small mysql database and grow with that. HTH
&gt;I'm writing (what will eventually be) a large blog/forum/wiki web app using web2py. If your app is write intensive (which appears to be), you do not want sqlite. Every write blocks the app. If your app is light on writes, sqlite is great. If you use the DAL of web2py, you won't touch sql queries at all, so it doesn't matter much between postgres or mysql.
&gt;They just are static when accessed through the class, but they still become bound on instance access. You are right.
Is it supposed to be?
This is much better done in SQL as cag_ii pointed out, but you did explicitly come here for Python help, and suggesting that you could do it in AWK implies it's just a fluency issue. &gt; I've also tried setting a "lastname = thisname" variable and then checking to see if they match, This is actually pretty easy to fuck up, as you can't emit a line until you've seen its successor. lastline = None for line in cursor.fetchall(): if line[0] != lastline[0]: print ",".join(lastline) else: lastline[-1] += ' ' + line[-1] lastline = line print ",".join(line) A simpler but more memory-hungry approach would just load them all into a dictionary: rtrs = dict() for line in routers: if rtr.has_key(line[0]): rtr[line[0]][-1] += ' '+line[-1] else: rtr[line[0]] = line for line rtr.values: print ",".join(line) Neither of these examples has been tested, but they should help clear whatever blockage you're experiencing.
This makes a lot of sense, thanks. The issues with size is, I'm going to use it for my own personal site but I also plan on releasing to to the public as a phpBB style web app so the size of the database is completely dependent on the communities that decide to pick it up. There needs to be room for expansion without any significant modification of the code. The way I understand web2py it wouldn't be too much of a task to change database types between installations but I want to be sure I know what the requirements are going to be in the end.
I will be using the DAL, and if I understand it correctly, it's a fairly trivial task changing the database type between app installations isn't it?
I tried GROUP_CONCAT earlier in the day, and on a small/test query it worked well, but on my real query, which uses a number of LEFT JOINS and such, it went haywire and essentially stuck the IP addresses from each host onto the first host. I also tinkered with adding a DISTINCT option.
Agreed. I tested this earlier and it didn't pan out as I had hoped. See my comment up above.
Yes, but you will have to reinsert the existing data into the new database. This is, of course, done with the DAL, you don't have to (and shouldn't) manipulate raw sql queries.
The datasource creator is an OpenSource application called RackTables. It's excellent for managing a datacenters physical objects. My MySQL query looks like this: SELECT DISTINCT(RackObject.name) AS NAME, Rack.name AS RACK, TagTree.tag AS TAG, RackObject.label AS LABEL, RackObject.asset_no AS ASSET_TAG, AttributeValue.string_value AS SERIAL, Dictionary.dict_value AS TYPE, dictmodel.dict_value AS MODEL, RackObject.comment AS COMMENT, INET_NTOA(ipv4.ip) AS IPv4addr FROM RackObject LEFT JOIN RackSpace ON RackSpace.object_id = RackObject.id LEFT JOIN Rack ON RackSpace.rack_id = Rack.id LEFT JOIN TagStorage ON (TagStorage.entity_id = RackObject.id AND TagStorage.entity_realm = 'object') LEFT JOIN TagTree ON TagStorage.tag_id = TagTree.id LEFT JOIN AttributeValue ON (AttributeValue.object_id = RackObject.id AND AttributeValue.attr_id = 1) LEFT JOIN Dictionary ON Dictionary.dict_key = RackObject.objtype_id LEFT JOIN AttributeValue AS avmodel ON (avmodel.object_id = RackObject.id AND avmodel.attr_id = 2) LEFT JOIN Dictionary AS dictmodel ON dictmodel.dict_key = avmodel.uint_value LEFT JOIN IPv4Allocation AS ipv4 ON ipv4.object_id = RackObject.id WHERE RackObject.objtype_id != 50004;
Even under AWK, I'd need to do some research on how to accomplish what I'm looking to do. I mentioned awk as it's well recommended for text based wizardry. Even though it may not appear so, I'm more comfortable with Python, as code examples and such fit my brain a bit better. AWK examples often end up looking like spaghetti code to me. That said. I like your dictionary approach. Even as we fill up the database more and more, it's still not going to be *that* much data to hold and parse through.
This is *very* close to what I'm already doing, but without the extra execute and iteration over that data. It's a good logical flow, and easy to follow. I think I may give this a shot first as it will fit into the existing code quite easily - I think. :) Thanks!
That's what I thought, thanks. Think I'll just use SQLite for development, then when actually deploying it I can just switch the defined database to MySQL and let the DAL create a fresh database.
Interesting. Thanks
When I go to the appengine match page I often get "This Google App Engine application is temporarily over its serving quota. Please try again later." :( You're too popular!
Eventually it will be. Is it *supposed* to be? That is up to the developers and not chrisledet.
The only way I've found to do it is to use Curses..and the only way to do that on a windows box is using the [Unicurses](http://roguebasin.roguelikedevelopment.org/index.php?title=UniCurses_for_Python) wrapper with pdcurses library... On a linux / Mac box, curses is part of the standard library Or you could get into more advanced stuff like tkInter or qtPython..but then you're not really talking about the console anymore. I'll be watching this thread to see if any other answers pop up.
don't you just switch it in the menu like you showed me?
Get a copy of Console. Here's a quick example of what it can do: import Console con = Console.getconsole() for i in range(30): zz = con.text(i * 2, 5, '*', i) That should get you started. Cheers! (Edit: formatting)
Yep, that was fixed pretty early on thanks to Victor Stinner.
thanks for the update, i upped my quota and it should go into effect in the next 30 mins or so
Check out [colorama](http://pypi.python.org/pypi/colorama).
Windows or Linux? What terminal type? The code is different for both and you want to configure the terminal correctly.
Cool :) I keep getting this error that it's not finding a "yaml" module. I installed pygtk. I'm also on windows if that makes any difference. Do I need to install http://pyyaml.org/ or something? Edit: yes, installing that fixed the error. Maybe put a link to http://pyyaml.org/wiki/PyYAML in your "dependencies" section of the project page
thats for cmd only and its a local setting not stored in a python file.
wait! there are exe's for linux? (excluding wine)
oh, how do you do in python then?
... that's what this whole thread is about
no-one answered your question yet?
&gt; I realize the choice between MySQL and Postgresql boils down to a matter of taste No, the preference of one wine to another is a matter of taste: there are qualities that are difficult to measure and physiological differences between individuals influence which will be preferred. The difference between MySQL and Postgresql is far less subtle, and is mostly driven by general database experience.
thanks, i updated the page with pyyaml as a dep and moved the import statement so its only needed when posting to app engine.
Denimboy is right SQLite is not you. MySQL has the advantages that you can use the pysqldb driver that comes with web2py but I prefer PostgreSQL. This is because PostgreSQL does what you expect 100% of the times, MySQL has a lot of "exceptons". For example text fields in mysql have a max sizeof 64kb. If you write blogs it may be a problem. String fields also have a max size and it depends on the version. That causes problems. The most annoying feature is that you cannot alter more than one table in the same transactions. Web2py does automatic migrations and that means it alters tables for you when you edit models (unless you turn it down) but mysql requires a commit after each alter table and that results in a small probability that one transaction succeeds, one fails, and you end up having to rebuild the dal metadata. The dal code contains no exceptions to deal with postgresql but a number of exceptions to deal with mysql. Anyway, I know many people who use mysql with web2py and are happy with it.
it's open source. anyone can step up and contribute to help port it over. why don't you just go away.
No, Python can be ran both on Linux, Windows, Mac, etc. platforms. What's your target platform?
If you want cross-platform, this looks to be the answer. If you're on a standard terminal, however, the solution is even simpler: print("\033[22;32m" + "all my green text goes here")
I think you forgot the link, dude.
Did it work? A better description is that you're using a group by in the SQL to get each router, then using a separate select *only* on the ones with more than 1 IP address. This shouldn't be a problem unless you have several billions of routers with more than 1 IP.
This looks great, and I love this type of game. My main suggestion is to make it more accessible to get started. I don't mean to dumb it down, but more like to have a web-based IDE or GUI that you can access and see/edit scripts etc. without having to download source and bang against the command-line. I hope you keep working on this one and continue to share!
Maybe this is a really meta joke. There's no impedance mismatch because there's nothing there.
Well, it does cost $100 a year for the privilege of being an iPhone developer...at the $1.99 price point, he might be barely breaking even. Just saying...
The code isn't actually that bad. I've seen people write a *lot* worse, and get paid for it. I'm quite partial to using a dictionary of function pointers (erp I've been doing a lot of C lately... so.. whatever python calls them, I forget) as the alternative to a switch, as opposed to the 50 if statements. Many younger programmers tend to shit bricks when faced with that though, so I think it's probably a personal preference thing. You didn't go on a class or inheritance rampage, which many Java programmers tend to foam at the mouth over, so chalk it up as a win. edit: a list comprehension never goes astray :-) edit2: and lambdas... in nested list comprehensions... I'm a bad man
You just stepped a bit outside my scope of understanding. One question though. How do blogs like Wordpress which use MySQL deal with 64kb+ blog posts? If this is going to be a limitation, or if it will just be simpler to use PostgreSQL then I have no problem going that way since using web2py would be I would be doing little to zero direct interaction with the database myself. The idea of the blog function of my app will be for news, guides, game walkthoughs, etc. so it will most definitely step outside 64kb at times.
are you saying that there is no magic? :(
No.. What?
Reminds me of fun times when I was kid with [robot battle](http://robotbattle.com/) I'll have to check it out later!
You should test with MySQL ans Postgresql backends before deploying/releaseing. You see - sqlite is resiliant to data type errors. You can essencially write string to integer field and sqlite would not even cough. Postgres demands strict type integrity, so do MySQL.
Very cool! I need to get a handle on pygame. 
Ok but you are not writingjava, to avoid namespace conflict, you can use the as statement, and of course never import *. For the default value in argument list, why just pass the default value in the rpc call. In java there is no default value but people write many methods with the same name and each one call the one which have the more arguments and got the implementation to fix it. Hope i am clear.
Protip: don't bother including .pyc and .pyw. Just include .py. You can ignore those files with a .gitignore file.
Thank you, I'll look into that :) I'm still very new to git.
Convincing Debian that PyPy is production ready would boost usage. There was a package in 2009 which was removed because of bugs and low interest http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=538858
&gt; I'm quite partial to using a dictionary of function pointers I'm stealing this for myself. Thank you :)
... So does the maintainer of the pygame site :( (Example: Under documentation, try the 1st link (ReadMe)). As nice a library as it is, the documentation and layout of the site has always felt perpetually unimpressive. I can't help but think that if he only reached out to the webdev community, that he could increase the interest in the project 10x fold.
The named arguments "rule" is simple to justify, it violates integration with other languages, (keep in mind) colony is meant to be language independent and distributed. If one tried to call a remote method with a named argument and the target colony instance runs on a platform without support for named arguments that would create a problem as the target environment would be unable to correctly resolve the call. The documentation contains an error for this "rule" as one could use named arguments for the non facade files of the plugin as we do in almost all the plugins. As for the from statement, for the facade part of the plugin it would violate the generic design of the plugin, for the back end part it's a bit more flexible and you could easily use from x import y if that best fits you. We don't like from x import y (specially from x import *) as other python coders don't, we think that for a large codebase it's not the best choice as it promotes symbol overlapping. Keep in mind that some of the statements in the doc are not rules but rather our choices for the way we code. The statement clearly declares "Even though they are obviously not mandatory...". Hope this helps understanding both guidelines.
There's no XML config files for any of the base facilities of the colony framework. The specification file for the plugins may be written in any description language, currently most of the plugins use JSON for it. It's up to each plugin to choose what kind of resources they want to use, and of course XML may be an option.
I've been using that for anything past 4-5 if-else statements, makes the code much neater from my perspective.
The documentation reads like a very elaborate form of yak shaving where the yak is a plugin.
I agree that those 6 lines of code represent the core functionality for a similar (not the same) web app. But I've created a "simple" application from the web2py administration interface and it generated 63 files with hundreds of lines of code. If you focus on the core functionality you can also create a colony plugin with a dozen of code lines. I would also like to point out that colony is not another web framework for python, it's a language independent specification for modularity (with a python implementation). Hope this helps in understanding the differences between both.
Second that, code looks not bad. 
1. Use argparse library for parsing command-line 2. Make all initialization of an object in the constructor, e.g. lines game.py:28-31 should be game = Editor(sound=sound_on, filename = sys.argv[i+1], tiles = load_level(sys.argv[i+1])) 3. You can use if game.state in ('menu', 'level_select'): 4. Make the Game/Editor handle the events themselves, e.g. use game.keydown(event) 5. Use dynamic dispatch instead of the big if-else in game.py:49-60 handler = getattr(game, event.type, None) if handler: handler(event) See explanation of this technique http://diveintopython.org/power_of_introspection/getattr.html 6. Instead of using magic numbers, use constants 7. Divide Tile.is_blocked into smaller methods, e.g. is_right_of, etc. There are more, but I trust that you can do the rest yourself :)
I appreciate your response. There are a lot of things I did which were poor decisions and largely on account of laziness. It seems like a lot of times I'll have an idea or way of doing something that will need to completely be remodeled when "that one thing I didn't think of" comes up, and instead of fixing it the Right Way (tm) I just hack it in. This builds up over and over again and it gets to the point to where I'm disgusted with the code. That said, the things you mentioned aren't really this. 1. I will DEFINITELY be using this library. I didn't even know about it :] 2. Agree, not doing this was just a result of laziness and putting too much emphasis on 'making it work' than 'doing it right.' 3. That code really shouldn't be the way it is anyway, but you're right. I should start thinking more in lists/hashmaps. It's python bread and butter :) 4. Yep, should've instead of a mangled mess of if's. Definitely laziness. 5. Sweet. I'm going to look at this :) Thank you -- and! 1. Yay. I was pretty inconsistent with my tone and phrasing in the docstrings. I used them more as comments than proper documentation. 2. Agree. Laziness :/ (bane of programmers maybe?) 3. This is one of those things I would have done if I had ever needed to use it in that fashion. Since I only ever use it all at once, I never modularized it. It seems like a lot of my refactoring happens this way: 'Oh shit, I need this sub-component of that function... hm...' Thank you for spending time with the code. A lot of good pointers here! I much appreciate it. &lt;3
What a sad little man. Nobody is going to step on the Django core devs toes. Could you coordinate with them? Certainly. Is that going to happen? Probably not. Are there plans to move it to P3? Yes.
&gt;the specification file for the plugins may be written in any description language but you can't do Django-style `settings.py` afaict yes?
no, i understand that, i said i intended to compile it into an exe so i was surprised there was a question about target platform
Learn by practising: One good online resource: http://pyschools.com
You could in fact use a python file for the specification of a plugin although that would not be the best decision taking into account that the colony specification layer should be language independent.
[So, what's my main option for a GUI Toolkit?](https://bitbucket.org/pypy/compatibility/wiki/Home#!gui-library-bindings)
Yeah, I've noticed the documentation was pretty poor when I tried to get a friend interested in Python gaming. Did you go through the functions library and simply try everything out?
.pyw should be included. As those in windows default to launching the app without the dosbox. 
DAE not like struct? I use it all the time at work for interfacing with embedded platforms but it seems kind of cumbersome and not very clear even compared to just writing C code.
If you click on the tree link in the commit envelope [(link to image)](http://i.imgur.com/wf6In.png), you'll get links to the current commit instead of the master links. Click on a line number in a given file, and the link updates to that line number. Then you can link directly to the version and section of the code being discussed, such as [game.py#L52-88](https://github.com/josephbleau/pygame-vanessa-mahjong/blob/14f709893628f2388bf5953de4db0949992e7e87/game.py#L52).
Neat! I had to change line 69 in game.py to get it to run on my Mac. pygame.mixer.music.play(loops=-1) This line gave me a keyword error, had to be changed to: pygame.mixer.music.play(-1) Thanks for posting your code!
This is really cool! Prepare to have your best AI defeated &gt;:D
ORM "Magic" has fucked me enough times already. SQL was never so hard or inconvenient that it needed to be or should have been abstracted away.
This seems like another Elixir (http://elixir.ematia.de/trac/wiki), but not as good. edit: I still think this stuff is awesome. I love magic. The "magic" source code is pretty small and simple too.
Sounds like going back to the stone age. SQLAlchemy is a top tier ORM capable of falling back to SQL where necessary. Don't throw the baby out with the bathwater because it's not the right solution 100.00% of the time!
Is *anyone* unsatisfied with SQLAlchemy?
I think the point was probably to show off some new SQLAlchemy goodies. "Magic" is just a demo built with those goodies.
They use the struct module, while I'd prefer something along the lines of [hachoir](https://bitbucket.org/haypo/hachoir/wiki/Home). It's less verbose, and definitely worth checking out if you work with binary file formats in Python.
&gt; This seems like another Elixir It's SQLAlchemy, which has been beating other Python ORMs hands down for longer than Elixir has existed.
I'd hope so, since Elixir is built on SQLAlchemy. ;)
Durrrr. Ignore me. :P
You misunderstand what ORM does for you. ORMs (especially SQLAlchemy) are used, because SQL is basically string, and cannot be manipulated (of course, exactly you can manipulate a _string_, but there’s no operations that really manipulate a _query_), and doesn’t have _multiple futures_, not because it is hard or inconvenient. For example, compare the following code using ORM: query = session.query(User) if gender: query = query.filter_by(gender=gender) if name: query = query.filter(User.name.contains(name)) sort = sort if hasattr(User, sort) else 'created_at' query = query.order_by(getattr(User, sort)) and another one without ORM: condition = 'true' bind_params = {} if gender: condition = 'gender = :gender' bind_params['gender'] = gender if name: condition += ' AND name LIKE :name' bind_params['name'] = '%{0}%'.format(name) sort = sort if sort in ('id', 'name', 'gender', 'dob', 'created_at') else 'created_at' sql = 'SELECT * FROM user WHERE {0} ORDER BY {1}'.format(condition, sort) I really hate include SQLs in string literals.
The docs could be better. Many of the examples are 'toys' that do not reflect best practice for setting up real systems. But this is not enough of a deficiency to make me unsatisfied with SQLAlchemy.
i can't wait to see it :-D feel free to PM me or ping me on IRC with any questions or comments
I think he just got caught up in the "console" chatter...and forgot that part. 
&gt;But I've created a "simple" application from the web2py administration interface and it generated 63 files with hundreds of lines of code. Just to be clear, the 63 files generated were simply a copy of the scaffolding app, all of which could be deleted for simple functionality like the program above (in fact, most of the files are just language translation files, generic views, and static CSS, JS, and images).
Looks almost exactly like the ORM included with Django.
I didn't say the codebase was poor. I said the official site was poor - and even suggested that the author look for free help elsewhere. I did not offer help myself as I'm definitely not artistically inclined or a pro (or even amateur) web dev. 
I downloaded from the example games (the links that worked) and browsed through their code to see how they did things.
I had much more problems debugging queries built by SQLAlchemy then debugging queries built the old fashioned string based way. I could usually find the problem in the generated SQL pretty quickly, but I had problems translating the fix back into the python code.
By the way, do you know any nice FAQ/cookbooks about AppEngine? I'm yet lacking intuitions about the Right Way to do stuff, and it bothers me immensely that I might be doing something very stupid, or wasting my time trying to do something that is impossible by design. Reading sample applications kinda helps, but is not enough. For instance, is there a way to have application-wide settings or the ability to restart instances, or forcibly invalidate a certain memcached entry, or I should stop worrying and just reload settings from the datastore for every request? I mean, for things like switching off certain parts of functionality or something... Or: it turns out that updating an entity with a lot of fields is slooow, so how should I go about storing statistics: normalize out fast changing fields (counters)? And is there a way to avoid wrapping modifications in transactions?
We used it for a project about two years ago, and it was a disaster. What sunk the project was a combination of the fact that the SqlAlchemy driver for Oracle was buggy, our project manager didn't do a good enough job on limiting customer feature creep, our DB designer went a bit nuts and made the design far too abstract, and SqlAlchemy sometimes generates retarded queries. End result: Even after significant amounts of optimization and simplification work, some pages took several minutes to render, and even the faster ones took several seconds. SqlAlchemy is a cool product if one makes damn sure to avoid using too many DB views, and to always keep track of how many joins any query can contain in the worst case. 
 this is actually my first app engine app, so i don't know the 'Right Way', but it looks like you can run web2py or django on app engine, so if you follow their app engine guidelines, i'm sure things will work well. i don't know any nice FAQs, but their python documentation was pretty good. i am just using the default frameworks included with their code (django templates, webapp, app engine datastore). regarding settings, i store my settings in a module (settings.py), and the settings are available in all instances. however, modifications to settings don't get back propagated to other instances and i reload the settings module for every request. personally, i think memcache is fine for storing volatile settings as long as the fallback (memcache key gets deleted) is less feature-full. re: statistics, google app engine recommends [sharded counters](http://code.google.com/appengine/articles/sharding_counters.html) the majority of the work I did for app engine was a) porting the code to be python 2.5 compatible and b) run in a smaller memory footprint, app engine has a 250 - 300MB RAM upper limit 
interesting. So, "unsatisfied" that SQLAlchemy...generated the joins that you and/or your DB designer told it to ? It never generates a single join without being instructed in some way. Using an ORM is not an excuse for entirely disregarding how you're interacting with your database. That's the *opposite* of SQLAlchemy's philosophy, which wants you to really, really, understand what it's doing and please tell it the best way to handle your particular schema. Products which pretend this isn't necessary are just naive. Also technology products can't correct organizational issues, not sure what your expectation was there ! The Oracle dialect was cleaned up massively in 0.6 and is rock solid in production environments now. Oracle remains a difficult platform to work with in any case.
But with big amount of joins and stuff the actual fault is not SQLAlchemy but rather DB design. Or if sql generated by SQLA was too bad, couldn't you resort to a lower level and instead of using ORM just use it's SQL queries like `select(...)`, etc?
Um. No, no it doesn't. They seem to have in common that they both start with a class definition, and that's about it.
Agree, but the same can be said about colony. Most of the code in the example may be removed if simplicity is the key point. Note: We're a currently changing the example to shrink the code ;)
It's a pretty steep learning curve compared to Django ORM, especially with available documentation. At least last time I tried
This is why I wrote this: http://solovyov.net/en/2011/04/23/basic-sqlalchemy/
Reminds me of [Mindrover](http://en.wikipedia.org/wiki/MindRover)
Yes, for the most part it works, but I'm running into what's probably a very basic issue with: router_ip = "%s %s" % (router_ip,ip) It ends up printing the first IP twice and then fills in the rest like so: Host with just one IP: hostname,192.168.90.98 ('192.168.90.98',) Host with multiple IP's: hostname2,172.24.193.81 ('172.24.193.81',) ('172.24.193.82',) ('172.24.193.83',)
Will save this thread in case.
Oh, shit, sorry... in that case, ip would have been a tuple. Change it to this: router_ip = "" for ip in ips: ip = ip[0] router_ip = "%s %s" % (router_ip,ip) That's totally my bad, haha, told you the coffee was wearing off! :-P
The great thing with mysql is that it has a lot of different storage engines which are optimized for different use cases. The bad part about mysql is that it has all these different storage engines which act differently in the same situation. Humor aside, mysql has a lot of issues. It often silently ignores error situations which other databases like postgres would complain about. For example, lets say you create a table with an name column and make it a varchar(10). If someone inserts a value which is longer than 10 chars, mysql will accept the value, truncate it, save the truncated version and move along with non fatal warning. It does the same thing with integers, truncating the bits it cannot save. This is again part of the charm and curse of mysql. It is a bit of an %80 solution. It is quite easy to setup and throw together a quick schema and even scale with replication, but once you start to really care about your data you get burned by more and more of these annoyances. However, since you are trying to build a community system and not benchmark various database systems I recommend you stick with what you know for the time being and just get things done. web2py has a very good ORM which will mitigate the differences between postgres, mysql or even sqlite. If you get to the point where you have thousands of users and you have reached some pinching point with your database then congratulations! You can solve it then. Dont bother solving the database scaling issue before you have written a line of code. BTW, if you need to store more data in a field than a VARCHAR will allow, you use TEXT. If you need to store more than TEXT can handle you use CLOB. If most of your posts fit into a VARCHAR then keep them in a VARCHAR but have an overflow table where longer posts get stored in TEXT. Maybe you allow these overflow records to chain. Going from VARCHAR to TEXT costs you in functionality and CLOBS can be even more challenging.
Bingo! Thank you ever so much for your help! 20 thousand upvotes for you. :)
Hooray! Glad it worked :)
What you are talking about is a Data Access Layer (DAL), not an ORM (which includes a DAL). I find often that a DAL is more than sufficient.
can you elaborate on the dictionary of function pointers. I'm intrigued and want to make sure that I am looking the right thing up. Right now it looks like `func_map` is what you would be doing....
Inception!
Maybe this will help: http://codepad.org/4XqRFZYc I'm pretty sure this is the concept he meant. :)
THAT'S GENIUS! thanks!
Wow, that's a lot to take in. Seems like every time I have a concern it turns out that I'm just over thinking it. Definitely going to bookmark this post for later. I'm just going to start using SQLite and move on to Postgresql later. The more I learn about the differences between MySQL and Postgresql, the more I'm leaning away from MySQL. I can see where the flexibility could be useful, but I don't think that's so great for a learning environment where every error is a chance to learn something.
That was a lot of ridiculous gibberish.
I am a noob and what is this? I gather it is a pythonic way to use with SQL data? Is this mostly for websites?
Could have been an ambiguous abbreviation for "executable"...
Maintainability. Python scripts remain legible long after you've forgotten what they were for. Come back to it 6 months later and it is easily understood. Perl scripts take more effort to re-read and comprehend. They remain similar in performance and abilities, so use what you're comfortable with. *(But Python is obviously superior, of course)* 
I use them both. Perl is fantastic for simple text editing. It's native implementation of regexp operators makes life simple once you learn it. Python definitely has readability going for it. I honestly think Python has more math/science libraries ported to it, but as far as sysadmin stuff they're probably both on the same level. 
Python has a much less painful learning curve, in my experience.
I personally have SDL experience in C/C++ and am familiar with the concepts already (since pygame is mostly an SDL wrapper for python), I just looked for the equivalents of what I already knew. To me, the documentation was pretty helpful. It doesn't tell you what to do to make a game, but it does do a good job when you just need to know what x is called in this implementation, or the order of arguments in some function. There are a ton of pygame tutorials out there though!
They're like a couple of good Scotch single malt whiskies; so similar that you can debate the small differences for hours :-) They're so close in abilities that it's purely a matter of taste, if you're good enough in both to produce neat readable code. It comes down to needing some library or other. With Perl it takes a bit more experience to reach the point of writing neat readable code, I think. On the other hand, for system administration, Perl has some builtin syntax for stuff like checking to see if a file exists that is nice to use. Python doesn't have special syntax for specific problem domains. Personally I am fluent in both, but still prefer to use Python, because it feels cleaner to me. I think that is probably from working with colleagues who tried their best to write PHP in Perl, and I've always written my Python just for myself. So, just my personal preference.
Thanks for actually downloading it and trying it out! Weird that there's that small difference between versions, but great that it only took one line change to make it work on your platform :) I need to get a mac to test things on.
I love you. I've been stumbling around git like a buffoon the past week, somehow managing to make it work, albeit very clumsily.
shamelessly stolen from hackernews: http://news.ycombinator.com/item?id=2560514
They are equal, but Python is also named after Monty Python, which gives it the edge.
I have used Perl for years. That being said, I haven't written a new perl script in about 4 years because of my more frequent use of Python these days. I don't know if I'd say Python is "better" than Perl, but it has become my go-to scripting language. The big change for me was how much time it took to mentally parse the code I have previously written. I am forever tweaking scripts and libraries that are part of my standard sysadmin tool chain. When I compare reading perl code with its dollar signs, curly braces, semicolons, and dash-greater-than arrows with the equivalent python code using whitespace, colons and periods, my mind just parses it easier. It may seem trivial, but I never realized how much mental space that all took up until I started using python everyday. I feel like I think about code less and more about what I'm trying to do. That means I get done quicker, so I can be lazy again, which is the proper motivation for all sysadmin work.
No problemo... def foo(): print "foo" def bar(): print "bar" magic = { "foo": foo, "bar": bar } magic["foo"]() edit: Looks like Ninwa beat me to it.
You didn't hear it from me... but [OSx86](http://www.osx86project.org/)
It's contrary to the point of version control. You end up having 2 files that are the same thing, but now have different (if only slightly) histories. It's just plain silly. Live with the command prompt that opens up. If the author wants to hide it, he should package it in binary form/some other form that hides the box. Such niceties as hiding the box don't warrant a duplicate copy of the same file in version control.
Use the one that fits your brain better.
Oh yeah, well Perl is named after Monty Perl.
Wasn't that 1998's flamewar?
If you care for job security, use Perl. Python is way too readable ;-) edit: PERL --&gt; Perl
Yeah, I'm definitely not saying SQLAlchemy was to blame for all the problems in the project. But the power of SQLAlchemy, in that it allows you to gradually build up extremely complex queries by passing around semi-constructed query objects invites over-design and over-generalization. I'm not saying they are bad features, I'm convinced it is the right way to go, but one needs to be careful when designing the schema. On the other hand, some of the SQL code generated was definitely not a fast or sane way to achieve the specified results. I remember that a bunch of weird casts removed Oracles ability to use various indices which killed performance, for example. It was a long time ago though, so some of the details escape me. BTW, I wasn't involved in the project from the start, I was called in to try magically make the system fast once it was clear that things where too slow. Managed to improve performance by several orders of magnitude, but in the end it still wasn't deemed enough, and the project was failed.
We did a bunch of custom SQL. We used temporary tables in order to cache a bunch of intermediate data. We updated various aspects of the schema to improve the performance. We moved some calculations to the web side in cases where the DB did something stupid. But there is only so much you can do with a broken DB schema and a customer who won't let you drop any features. So in the end the project was a failiure. :-(
That's what people mean when they say Python is very readable. Less character noise.
upvoted for &gt; the proper motivation for all sysadmin work which is why I use Python when I can
I feel your pain, I have similar situation. Project is definitely not failed, but not because of guys who designed DB and wrote application for sure. SQLAlchemy was abused in early days and that is sad. :(
Thats an appropriate Monty Pythonesque reply.
I use Perl because CPAN is better than every other language library put together. Period.
As someone who has been writing perl scripts for around 11 years and been a System Admin for 13 (and only recently learned Python a couple of years ago), I still use Perl for 99% of my work. Every time I tell myself I will write something in Python, I start out and then realize I can do the same thing in perl in half as many lines and 3x as fast. It helps that a large portion of what I write uses regular expressions which are just so much more convenient and easy to use in Perl, and I also end up using a lot of the built in Perl file operators. Between the two of those and how frequently I use them, I find myself just sticking with Perl the vast majority of the time.
Monty Pythonista?
Cross posts? http://www.reddit.com/r/perl/comments/heej9/why_is_perl_better_than_python/
You can export and reimport it in few lines: db=DAL('mysql://....') db.export_to_csv_file(open('filename','wb')) db1=DAL('postgres://....') db1.import_from_csv_file(open('filename','rb')) The rest of code does not need to change.
Ok, I think I have it. Thank you for the info.
I use python when I have a choice about what system my script will run on, and especially when I'm running the script on my own work/home system. I use perl when the script is intended to be supported across multiple systems or the script will be used and maintained for a long time by people who are not me. The reason: python tends to be more of a moving target, whereas the most popular perl modules and the perl standard environment are pretty static, provided we're talking perl 5. Of course these are rules of thumb, and if I had a choice about what language to work with predominantly python would be the one because I like working with the python interpreter, I prefer how python implements name space, and because of 'the python way' the scripts tend to be easier to read.
I've been doing sysadmin and perl for a little longer than you have and I agree on most points. I think for things closer to the OS perl makes more sense, especially in situations where you will end up porting certain things over to C when you really need the performance gain. It's probably a preference or experience thing when it comes to how long it takes to write code in each language. I'm quite serious about writing readable code, but I think after these years the things people throw together in perl is still fairly readable to me. When it comes to speed and startup time, perl seems a lot faster to me.
I think this is the primary bar for SQLAlchemy. The secondary is Django.
yes... I really thought we had gotten past that point.
The 90's called. They want their flamewar back. Note that Python isn't better than Perl in the same way Spanish isn't better than Hebrew.
perl is the sys admins language of choice. Python is for writing non trivial software.
Have you ever looked at Hebrew? It's repulsive. _Clearly_ Spanish is better than Hebrew. Not just that -- writing from right to left means as a right-hander you'll smudge your writing all the time. On second thought, I find the similarities between Spanish vs Hebrew and Python vs Perl quite shocking.
&gt; I start out and then realize I can do the same thing in perl in half as many lines and 3x as fast. Can you give me an example? Except for one-liners where Perl is definitely better, I've never seen a perl program being twice as short as equivalent Python program. In fact, in my experience, most longer-than-100-lines programs end up being slightly shorter in python. 
oh boy, aren't you a perl monk.
Funny, we've got three levels of mission critical software here that have back end parsing engines written in perl. 
&gt; I remember that a bunch of weird casts removed Oracles ability to use various indices which killed performance, for example. It was a long time ago though, so some of the details escape me. The only big caveat with Oracle is that when you try to use limit or offset, a subquery approach must be used. In 0.5 and before, this used window functions (i.e. ROW NUMBER OVER). As of 0.6 we changed to an approach from the Oracle site. Interestingly there is one user who gets much better performance with the old way, so for him we gave him a recipe that restores the window function approach. There's not too much going on with CAST unless you were using the "polymorphic_union" function with concrete inheritance which is not a common use case.
What's the mission?
Every time i've looked at Perl code I get brain melt. Today I was looking to advance mspgcc4 to use gcc&gt;4.4 but found out all the build scripts are in Perl. I looked at [one file](http://mspgcc4.git.sourceforge.net/git/gitweb.cgi?p=mspgcc4/mspgcc4;a=blob;f=buildgcc.pl;h=51255fab92358b9ad2e2be409a7df650078787c7;hb=HEAD) and couldn't be arsed.
Definitely going to put out where I work on reddit. An even better idea would be to tell you what mission it is. Yup, great idea.
Ah I didn't look at the file, I would imagine if it were mine I would do something like #/usr/bin/python import mygame if __name__=='__main__': mygame.mainloop() :w game.pyw
Yuck, it uses strings to reference classes. At least the Django ORM uses actual classes. I would take the Django way out of these two any day. I'm not sure about SQL-Alchemy, I've never used it. Magic: class Album(Entity): artist = many_to_many("Musician", "musician_id") Django: class Album(models.Model): artist = models.ManyToManyField(Musician)
A good fortran programmer can write fortran code in any language. I find that the differences between programmers is larger than the difference between programming languages. And it is just as easy to write convoluted hard to maintain python code as it is to do it in perl. I find that the core perl community is more interested in testing and documentation than the python community. 
They are not "better" or "worse" if you don't specify the task you want to achieve with them. I am a computer programmer, but I also have to perform sysadmin-ish tasks daily. I also love Python, and use it as my language of choice (closely followed by ruby). However, I'd say that for sysadmin tasks Perl is the right choice 90% of the time. Let's be clear: I don't like Perl, I like programming and developing systems, and I find perl to be really "ugly" compared to python as far as it's syntax is concerned. BUT there's no denying that for scripting tasks Perl will more often than not be the one capable of delivering working scripts with less lines of code. Good luck trying to maintain a large system written in Perl tho. TL;DR: I love Python as a programming language and use ir for day to day scripting, but I think perl is more often than not the right answer for sysadmin tasks.
SciPy is pretty cool, and it is often nice to have one right way of doing things, but, like rails, it becomes painful to do things in Python that the library devs didn't think about.
&gt; I looked at [1] one file and couldn't be arsed. That's not because it's Perl. That's because that file is a terrible scrap heap. It's Perl written by someone who thinks in an entirely different language.
At one point he had them in bash files. For some reason he decided to skip convention.
That explains a lot. Honestly though, he did the right thing. With Perl at least it can be refactored into something readable if someone with skill puts some time in.
I just added a TL;DR since I think people are not getting this.
Use whichever better fits the tool. For sysadmin stuff, Perl almost always fits the job better, simply because CPAN has already done it for you. (also, please ignore the 'it's unreadable lulz' arguments; you can write ugly code in any language, Perl just doesn't stop you.)
I've got a pair of quotes in my rotating .signature file: Linux Journals Development tool of the year 2000: Python Reason: Hell is other peoples Perl. And There are several things that perl allows the programmer to do more easily than python does. "Write maintainable code" just isn't one of them. -- Me 
The strings are there so you can handle circular references. You can use the class object instead if you prefer. I'm sure Django does the same thing.
Yes, yes it does.
I'm probably biased, but the common hate against Perl (and not only Perl) is what mostly drives me away from Python.
 &gt;&gt;&gt; import this Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. .... Why so much magic and cuteness in python libraries today? It only hurts maintainability and leaves the programmer wrestling with dark corners of the language when the octamaroon runs out.
What about Django?
I prefer python for the simple matter of readability, but it's really a personal preference.
I just hate the word `my`. That is all.
so people telling you the language you use is not all that good makes you not want to learn another language that could be better for yourself?
For once I'm not arguing with you. Postgresql is chock full of awesome. I've used it in a modest system with some tables approaching 100 million rows. It was nice and snappy.
Well, if those are the contents then yes, that would be something reasonable. To be frank I don't really use .pyw files for anything, because I use the bash shell provided by msysgit. My roommate doesn't use it either; he just double-clicks the .py files AFAIK.
Perl is worse than Python because people wanted it worse. -Larry Wall, 14 Oct 1998
Laziness is of chief concern. Which is why I will probably stick to perl. It translates better from shell scripting and is more logical from a operations sysadmin point of view in my opinion. I think that SAs may be split into 2 categories. Those that transitioned from a development house and lean more towards programming aspects of the job. And also those that have done SA their entire career and are focused purely on operations and getting the job done quickly, though not as elegantly as the former. I've been an SA my whole career and I think perl just fits me better. Great discussion though. Thanks for the replies. Interesting that the mirror perl discussion linked below has more upvotes but less discussion so far. Wonder what that says.
Oh boy, then, I'm in trouble. I didn't write that, but I guess I'm just not a dev-type... I saw that code and saw it as 'just another piece of code'... I just haven't seemed to grasp the nuance of it all yet, I suppose. Any ideas of how I could improve on this?
I'm a sysadmin, and I'm very good in Python and OK-ish in Perl. I use Python because our site is written with Django, so it's kind of necessary. I do use Perl from time to time; I'm just not very good at it.
ah regex in perl... while (&lt;FILE&gt;) { s/this/that/; print $_; } doesn't get much easier.
Another self-rubbing "Open Letter" that nobody really cares about. 
Perhaps life's too short to spend hanging around negative people.
I understand. My loathing for perl is based on a long and gory history with it. By which I mean that I'm not a bigot, I've just been burned. It's easy to have a strong opinion on the matter: many (if not most, IMHO) of the people that adopt python do so because they recognize a superior tool. In my line of work, maintainable code is *critical*. I really need to be able to read other folks code. Python makes that easier, while perl makes it about as hard as *any* language of similar caliber. It is literally the worst thing this side of Korn shell in which to write a large application, IMHO. So, when I see perl in the workplace, I question the wisdom of the author. When I see perl in the wild, I *really* wonder what the hell somebody was thinking. I wonder if they just haven't heard that there's a better way to do it. That's what I mean by having a strong opinion, and thinking that python is the better tool. I do probably come off as a bit rant-y on the topic now and then, tho.
Guess it's time for my yearly ORM rant. http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx SQL has the unix nature. With one string (query) you can easily exercise thousands of lines of C code. It's declarative, so mapping an imperative language on top of it just makes an abstraction that leaks like a sieve. 
If Django would adopt SQL Alchemy as its default ORM, I think SQL Alchemy would become the standard. Right now it's just an 'option'. And there are some nice advantages to using SQL Alchemy -- especially when the sql (e.g. join) becomes complex.
Just out of curiosity, why do you conclude that your inability to read perl is the language's fault? I'm sincere in asking.
How would that work? I'm relatively new to python...
Or while (&lt;FILE&gt;) { s/this/that/; print; }
Perl developer and sysadmin here seconding mithaldu's point that that code is all sorts of wrong. It's not good evidence that perl is bad, but it's great evidence that you're free to create bad things with perl.
Ugh. I can't believe I'm jumping into this fray, especially since it's r/Python, so one shouldn't exactly expect an unbiased response. But as a serious, professional, enterprise-level big-system application developer, Perl is my language of choice. There's absolutely no truth to the claims that Perl is hard to read, or that it can't be used for large systems. If you don't know the language, and you don't know what the program is supposed to do, any language is hard to read. When I look at Python programs, I see a lot of English words mixed with "def \__init__:" and "lambda" and "x[:-1]". There are more than enough unknowns to make it incomprehensible without a basic understanding of the syntax. It's just ridiculous to keep making the claim that people can't, don't, or shouldn't write large programs in Perl, or that they're necessarily hard to maintain. My experience with Python has only been that Python advocates are insufferable to be around, and that's probably what keeps me from learning it. That, and the belief that if I'm going to spend time learning something new at this point, it should probably be Ruby.
As a system admin, the vast majority of my scripts are &lt; 10-15 lines, and when I'm trying to bang something out in 5 minutes, adding in things like "import re,os", re.compile, os.*, etc, just feels like a huge time waster. I still like using python just to learn it and keep myself fresh, but Perl is definitely faster for me, for the vast majority of what I need it for. Edit: Just to provide a quick example (not anything that would even work, just throwing together an example of RE + file/dir operations to show how python might take a lot more work for the same thing): Perl: #!/usr/bin/perl while (&lt;STDIN&gt;) { if (/^\D\d+\s[:alphanum:]\s\d\.$/) { if (-d $_) { print "$_\n"; } } } Now - how many lines would this take in python? I'm sure its not a major difference but it makes a big difference over the course of dozens of scripts :)
I've noticed that as well. Not that theres a huge difference or anything but running a Perl script on a standard Linux OS install definitely feels like it has 'less startup time' than something calling the python interpreter. Most of my scripts are short and I write them in 5-10 minutes while trying to accomplish a quick task, and in this case I can write something much faster and shorter in Perl. I write a ton of 'throwaway' scripts (sometimes just using perl on the command line but I find it easier to organize/troubleshoot even short scripts from within a file).
1. [Download Debian](http://www.debian.org/) 2. Install it, deleting OS X 3. Install the emacs23-nox package 4. Done.
Homebrew: http://mxcl.github.com/homebrew/ [These are the supported formula](https://github.com/mxcl/homebrew/tree/master/Library/Formula) (But by no means is this a complete list of things you can install with Homebrew! You can check out the Forks of this repo for more) From your Mac Install Disk: Install Xcode Run in terminal: ruby -e "$(curl -fsSLk https://gist.github.com/raw/323731/install_homebrew.rb)" Then: brew install git python # Homebrew uses git, so you'll need it first. You'll need to add the new locations to your path: echo -e "\nexport PATH=/usr/local/share/python:/usr/local/bin:$PATH" &gt;&gt; ~/.profile Then use easy_install to install pip: easy_install pip Now you can use pip to install just about anything else from http://pypi.python.org/pypi pip install django
This is pretty much what I use. Homebrew's python with VirtualEnv/VirtualEnvWrapper &amp; MacVIM (also from homebrew).
Ctrl + F, cpan, upvote.
Mac Ports drove me to drink ;)
After a little more digging I found what the problem was. Python doesn't scope code to the local class automatically; you need to tell it to. so instead of: def checkactions(self): global input input = raw_input("&gt;") if "go" in input: actionsgo(self) elif "get" in input: actionget(self) elif "drop" in input: actiondrop(self) elif "quit" in input: pass else: print "I dont understand that" I needed to have: def checkactions(self): global input input = raw_input("&gt;") if "go" in input: self.actionsgo() elif "get" in input: self.actionget() elif "drop" in input: self.actiondrop() elif "quit" in input: pass else: print "I dont understand that" (and also no argument :D) Once I am done the game I will post it for you guys to check out.
You already seem to undestand what functions are - reusable code snippets. A cool thing about functions is that they accept input data, thus they are very flexible. Another cool thing about them (which you don't seem to be using in your original example) is that they can return a value. So you have some input values like this: value1 = 1 value2 = 2 Let's say you want to have a function that adds these two values. You can do it with global variables: value1 = 1 value2 = 2 def myaddfunction(value1, value2): global result result = value1 + value2 myaddfunction(value1, value2) # same as myaddfunction(1, 2) print result # prints 3 But this is bad, since you're using a global. Here's a better way: value1 = 1 value2 = 2 def myaddfunction(value1, value2): result = value1 + value2 # result is not visible outside myaddfunction() return result # it is returned so it can be assigned res = myaddfunction(value1, value2) print res # prints 3 
It's self.actionsgo(), not actionsgo(self), because even inside a method, members of the same object aren't part of your local scope. Python tends to favor explicitness like that. Btw, it's easier to read code if you paste it on pastebin.com or something, and syntax highlight it.
If you are looking for an IDE experience, I can recommend two: * Eclipse + Pydev Plugin. It will give you syntax highlighting, code analysis (error/problem detection), code completion, code-jump, auto-importing, auto-formatting, and a ton of other good stuff. My whole team uses it for daily development on a half-million line Python application. * PyCharm. It is made by Jetbrains (same guys that do IntelliJ) and has many of the same features. While it shows a lot of promise, PyCharm is not free, and only came out of beta about a year ago iirc. If you aren't looking for an IDE, then just set up a good .vimrc, install homebrew+pip, and get a decent terminal setup such as iTerm (change bookmarks&gt;profiles&gt;display profiles) and iPython.
Does the brew python have the same native stuff that ships with the preinstalled python? In particular, I'm curious about the native wxpython bindings. (Macports python uses X, which I wasn't particularly fond of..)
perl wins sometimes on CPAN's comprehensiveness (a few years ago, I fought to get a db connection working under python, where the CPAN module made it trivial under perl). perl can win on inertia: existing codebase dictates adaptations stick with the original decision. As for python's advantage, python doesn't tend toward Write-only code. Perl's got object-orientedness available, but it's not the rule. Yet. Perl tends to be more ubiquitous. It's like emacs/vi: vi is more widely installed, so being competent at it makes life easier. Having said all that, I prefer python and ruby because they don't get in the way of my coding, code makes sense months after writing it, and it's reusable. ... and then there's scapy. God, I love scapy for network coding.
Check out iPython. It is a replacement for the default Python shell. It has a bunch of cool features and is very widely used in the Python community. Not only can you use it as a bash replacement for stuff like directory navigation, but it has a built in edit/run mode that is quite sophisticated, better stack traces and tab completion.
I cannot resist. In web2py: query = User if gender: query = query&amp;(User.gender==gender) if name: query = query&amp;(User.name.contains(name)) rows = db(query).select(orderby=User.sort or User.created_at) Just to validate the point that a DAL (or an ORM) can be convenient. Welcome "Magic" among us. I will be taking a close look as it seems to contain good ideas. 
as a matter of fact, it takes 2 lines less in python ;-) (because I don't need curlies). import os, sys,re for line in sys.stdin: m = re.match('/^\D\d+\s\w\s\d\.$/', line) if m : if os.path.isdir( m.group(0)): print m.group(0) But I do see your point: python program is a bit more verbose and most of python advantages don't matter for throw-away scripts anyway. And it's easier to work with external tools in Perl...
:-)
$_, it isn't there, but it is there!
Alright I guess "lines" isn't the right word. I would say that the verbage in your python script is more annoying to write than the perl script, IMO. If I had to write a script like that, to do something as simple as that, I can't ever see myself using the python such as in your example versus the similar perl example, mostly because it's just easier. Also, I've never really checked it out before, but python compressed down that far actually looks even worse than Perl IMO (and for what its worth I could have written the entire perl script on one line and it would barely have line wrapped :) I do typically write with less lines in perl but then no one has to read my scripts. Example: while (&lt;STDIN&gt;) { if (/\D\d+\s\w\s\d\.$/ and -d) { print "$_\n"; } } Not that is is relevant any longer, and I don't really do anything like that. But, I just thought I'd say, if we're compressing scripts to compare number of lines, Python will probably never win to Perl :) Anyway, just my opinion of course :)
use a dictionary.
Say I've got these three functions: def example_A(*args): print "Example A." if (args): print "args passed:", args def example_B(*args): print "Example B." if (args): print "args passed:", args def example_C(*args): print "Example C." if (args): print "args passed:", args Say I had a variable named 'option' - and depending on the value of it, I wanted to run one of the three functions listed above, and maybe pass some other arguments. Normally, it'd be a series of if / elif statements like: if (option == 'a'): example_A(some,args,here) elif (option == 'b'): example_B(some,args,here) elif (option == 'c'): example_C(some,args,here) (similar to a switch/case statement structure found in other languages) Instead of that, though, you can set up a dict of functions: fDict = {"a": example_A, "b": example_B, "c": example_C} And then do a single line of code to avoid the whole if/elif structure: fDict[choice](some,args,here) In the dict 'fDict', the key string "a" is associated with the value &lt;function 'example_A'&gt;. So when you do: fDict['a'](args) it evaluates to &lt;function 'example_A'&gt;(args). http://en.wikipedia.org/wiki/Switch_statement#Python
pip, brew, git, ipython, vim pip and brew are install tools. pip is used for python packages, brew for system related stuff The latter 3 are, in my eyes, the holy grail of essential tools for me when doing python development. (Python/django developer)
What do you mean?
ORM is an exercise in the area of database. It's a speck of dust in what we call Computer Science.
Python.org binaries. People say Homebrew but I've not seen a compelling reason to use it (plus, Ruby, ew) since the 2.7+ binaries are 64-bit. Other than that, get IPython. Beyond that, it will depend what you're developing. As for editors/IDEs, I use Vim (I'd compile your own MacVim and link against the new Python 2.7 you download) and grab some subset of [these plugins](http://sontek.net/turning-vim-into-a-modern-python-ide) and such. If you go the Homebrew route it will compile and install MacVim and console Vim (newer version than the one that ships with OS X) from the same recipe. Eclipse + pydev is popular but not to my taste.
wxPython is in a sad, sad state on the Mac last I checked. wxMac is based on Carbon, which is deprecated in 10.6 and not being brought forward to 64-bit, and wxCocoa was years behind (again, at last glance). Plus wx is an awful GUI toolkit from the programmer's perspective when compared with Qt4 + pyside.
It's not really "telling you it's not all that good", it's rather the fact that, as you mentioned in your quotes, people seem to advertise Python with "because Perl sucks", and I'm afraid it's not only the percentage of the actual community; I once stumbled upon a link to some Python ML with a quote defining Python activist as someone who blows up Perl installations worldwide. Also, what mr_chromatic says.
Yeah, um, Twisted. [No thanks.](http://www.zeromq.org/)
 action_map = {'go': self.actionsgo, 'get': self.actionsget, 'drop': self.actionsget} if input in action_map: action_map[input]() I think is what he meant.
 choice = dict(go=self.actiongo, get=self.actionget, drop=self.actiondrop) if input in choice: choice[input]()
It's usually a good idea to do this only when you know the value being switched on is not going to fail on you though. one option is to do a default on None. aka, store the value of the dict look up as a temporary variable, then check to insure it's not None. if it is None do something else with it, else call it. saves you from nasty crashes. If instead the dict key is not outside of the program generated, then ignore that, use that technique only when the key is outside sourced.
its one file attached to a blog post. "Magic" !
I wrote SQLAlchemy largely inspired by the prospect of proving Ted Neward wrong. Based on the 17000 downloads version 0.6.7 has had in the past 35 days, I think we've succeeded. Thousands of developers get tons of work done every day with ORMs, whatever imperfections and impurities they have versus the idealizations of various technological pundits are mostly irrelevant - when a strong product is used thoughtfully and intelligently, productivity increases - dramatically. Ted can complain all he wants; he is wrong. edit: yeah that's some post that guy wrote. Let's reminisce: &gt; Just as it's conceivable that the US could have achieved some measure of "success" in Vietnam had it kept to a clear strategy and understood a more clear relationship between commitment and results (ROI, if you will), it's conceivable that the object/relational problem can be "won" through careful and judicious application of a strategy that is celarly aware of its own limitations. Developers must be willing to take the "wins" where they can get them, and not fall into the trap of the Slippery Slope by looking to create solutions that increasingly cost more and yield less. Unfortunately, as the history of the Vietnam War shows, even an awareness of the dangers of the Slippery Slope is often not enough to avoid getting bogged down in a quagmire. Worse, it is a quagmire that is simply too attractive to pass up, a Siren song that continues to draw development teams from all sizes of corporations (including those at Microsoft, IBM, Oracle, and Sun, to name a few) against the rocks, with spectacular results. Lash yourself to the mast if you wish to hear the song, but let the sailors row. His conclusion takes the time to conceive of how it can work, within the bullets preceding that paragraph, and also in the phrase "careful and judicious application of a strategy that is celarly aware of its own limitations. Developers must be willing to take the "wins" where they can get them, and not fall into the trap of the Slippery Slope by looking to create solutions that increasingly cost more and yield less.". If you trim away all the sopping wet melodrama and horrendously extended war metaphor, he's basically asking that a new breed of tools be built, and not by bloated corporate institutions like IBM and Oracle who can be counted on to absolutely miss 100% of the nuance required for something like this. I think it's happening/has happened.
Personally I like to have different 'game loops' in separate functions then assign them to a dictionary, then use the key on the dictionary as a state switch. I like to think of it as different layers of a plate. that way i can have game menus that 'lay on top' of the game which runs underneath. Set up some default values for a game layer to run then set the state list to game and menu, the menu gets the input but the layer below of the game still gets to run but without input. tada, auto playing game in the background, still working menu on top. pause the game and you disconnect the update loop for the game layer and enable the update, input, and visible, loops for the menu layer.
... or ... you could use dict.get() instead of the [key] syntax: def handle_error(*args): print "Choice not found." fDict.get(choice, handle_error)(some,args,here) dict.get() allows you to provide an alternate if the key is not found.
One of my favorite Perl vs. Python comparison apps is ack vs. grin. Both are powerful programmers grep replacements; ack is written in Perl, grin is written in Python. I know both developers (I know grin's developer better, as I worked with him at Enthought for a few months, while I've only spoke to Andy at YAPCs), and I know them to be *really good* at their respective languages. Both have years of experience, and are wicked smart. They're great for comparison sake because they are so similar in functionality, they are well-written examples of their respective languages (if you ignore than ack doesn't use CPAN because it is intended to be standalone as a single file), they are short enough to comprehend in a few minutes of study by any competent developer in their respective languages, and they are easy to benchmark since their functionality is well-defined (though regular expressions in both languages have pathological cases that could explode benchmark results if you tried hard enough to find them). Anyway, the last time I did an extensive comparison of the two, ack was nearly an order of magnitude faster than grin (and grep was roughly an order of magnitude faster than ack, when given appropriate options to ignore revision control files and other unnecessary stuff), and did more, while being shorter (though probably not by half; but I don't remember the specifics). It would probably be possible to find counter examples, but I don't know any off-hand. I'd be curious how cons and scons compare, but don't have the time to do any experimentation or code-reading. To be fair to Python, though, I think ack is probably the sweet spot for Perl. Pretty much exactly what it was originally designed to do. Parsing, searching, file operations, etc. on text are all core parts of the language because that's what Larry needed Perl to do. But, it coincides with a lot of systems problems, and as others have mentioned Perl does make quite a few systems problems very easy to solve. So, I agree with most of the folks chiming in saying that Perl shines on systems related tasks. It also does really well on text processing tasks. It may not be as good for other types of problems, but as a systems guy, I tend to find Perl very good, and I was frequently frustrated when I tried to implement things in Python for those purposes when I worked in a Python shop. I often did feel like I was writing a lot more code and getting a program that ran slower at the end of the process. 
niiiiiiice
I know you're getting massively downvoted, but I think that the cold, ugly truth is that if you're installing Python for the tasks 90% of people use it for (mainly developing web apps that will deploy in Linux) there's no substitute.
For what it's worth, I currently work on a 500,000 line Perl project. I have not been driven mad, nor does our codebase require sacrifice of chickens in order to fix bugs or add features. In the past, I've worked on a Python project of roughly half that size, and it was also fine to work on. I don't think Perl's rap as being unmaintainable is particularly fair...a bad developer can write unmaintainable code in any language. Python might make it *look* clean, but it still probably isn't maintainable (I've worked on some shitty Python in the past).
you could ask your questions in [/r/learnpython](http://www.reddit.com/r/learnpython) . I'm sure you might be able to get some answers in there. It might be helpful to others as well, to have the responses public.
You've got one major choice to make: do you use the Python that came installed in your OS, or do you renounce it completely? It's important, because *there is no in-between*. If you install another Python, now you've got two things both claiming to be Python, and only one of them can be right. You'll have to make sure that no commands refer to the old one. The Python 2.6 that comes with Snow Leopard is perfectly fine for my purposes. Given that: * "easy_install pip" gets a decent packager. * DON'T INSTALL IPYTHON YET. It's better *inside* a virtualenv. * "sudo easy_install readline". You'll want this later, because it makes ipython actually work correctly and not try to use horribly buggy libedit bindings instead. (For some reason "pip install readline" doesn't.) * "pip install virtualenv" and learn how to use it. Python without virtualenv is like sex without a condom. * Make and activate a virtualenv. * Now run "pip install ipython", which gets you a decent interactive prompt. Now when you run "ipython" it'll actually know about this virtualenv. Lots of guides will say you should install Python from MacPorts. Keep in mind that if you do this, you need to install *everything* Python-related with MacPorts, or at least using things that MacPorts installed. This is the road I haven't taken, but I can tell you about the main gotcha. You should make sure to install distribute (which gives you the easy_install command) in your MacPorts python, because otherwise you're going to get the system default one, which installs into your system default python that you're *not using*, and you'll be horribly confused.
&gt; For example, lets say you create a table with an name column and make it a varchar(10). If someone inserts a value which is longer than 10 chars, mysql will accept the value, truncate it, save the truncated version and move along with non fatal warning. It does the same thing with integers, truncating the bits it cannot save. Well, if someone does his job properly and writes a validator for the input, someone else wouldn't be able to insert more than 10 chars. Who would allow a stranger to blindly insert into database anyway?
Well it sounds like you need to install Emacs.
You don't need to install emacs for two reasons. First, because it is already installed on any Mac. Second, because emacs sucks. Vim 4 life, die emacs baddies.
Scum-sucking unbeliever, we'll get you eventually! P.S. Posting from Emacs.
I am pretty happy with macports + virtualenv + pycharm
First of all, congratulations on learning programming as quickly as you are. I saw your previous post, and am rather impressed by how quickly you are picking up new concepts. Overall, it looks like you are doing quite well, and so I wanted to give a few pointers here and there. While from the comments, it looks like you found your syntax error, there is something that I would suggest in terms of overall structure. It looks like your general structure is to have parentRoom, which is then subclassed into both firstroom and secondroom. I find that subclasses are useful when there is a significant difference between the actions of one and the actions of another. For example, you could have a class Monster, with subclasses Bat and Bear. On the other hand your firstroom and secondroom seem to be rather similar. They both have an intro for when you enter the room, and an action to be taken when you move to another room. Therefore, I would try implementing it as a single class, Room, with two instances, one for each room. In doing this, I try to think about what is necessary to define a room. Each room is connected to other rooms by means of doors. I could have a dictionary defining each door and which room it connects to. Each instance of Room 'remembers' which other rooms it is connected to. [Here](http://pastebin.com/wYHefuMZ) is how I would start out the maze. Notice that I tried to avoid using global variables whenever possible. There's nothing wrong with using global variables in short scripts, but they start getting confusing when writing longer programs. Notice how each the actionsgo function now accepts input of the direction to be traveled, rather than reading from a global variable. Also, I bundled together the controlling code for the maze into a new class called Maze. This is my personal preference, as I like to be able to call the code later from other scripts if I need to. Another thing to pay attention to are python default functions. In general, it is good practice to avoid using these as variable names to avoid confusion later on. 'input' is one of these default functions, so I changed it to 'command' in my example.
Sir, you must tell me how you do this.