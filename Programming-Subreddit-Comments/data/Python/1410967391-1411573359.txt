I think it's ok as a somewhat contrived example of the usage of comprehensions and trying to think in a somewhat more functional way. Using urlparse is probably more desirable in actual practice though. 
The mobile parts definitely feel pushed these days, and rightly so, it's Kivy's major selling point. You would *never* know that it wasn't part of Kivy's core looking at the website, or even the docs. My time with Kivy has long led me to feel it's a little multi-headed and doesn't quite know what direction to go in. The mobile push combined with the sad state of Kivy-iOS and the aformentioned holes. Kivy Garden being a strange unnecessary thing but is there for some reason. .kv files being the recommended way to do things but not the recommended way to do things because they don't do enough. You can write a game with Kivy but you can't do much because the rendering pipeline is completely locked and wholely unique. (Because it's for writing GUI apps - but no, please write your game with Kivy!) The whole project is a bit weird. Personally, even though at work we're built on it, we've been trying to break away for some time. Deploying successfully to iOS is the only thing keeping us around, which is ironically the weakest part of the Kivy ecosystem IMO.
True, and arguably I can't really think of a much better example other than converting lists of things I guess
I wouldn't say that mobile is pushed, but that's what most new users to Kivy are interested in. This means that most of the questions (because new users ask more questions) involve mobile, and a lot of the discussions head in that direction. The relative immaturity of the mobile parts also mean that more of the bugs and development involve mobile. There's relatively little special work that is done for desktop support, but each mobile toolchain has a lot of frequently-changing parts. Every new iOS or OSX release breaks some piece of the toolchain we need. Many new Android SDK releases also cause problems. So although the Kivy developers don't push mobile, a lot of the activity that people see involves it. It's actually a lot nicer to work on desktop apps in Kivy because the whole process is less convoluted.
First of all, SFTP is part of the SSH protocol suite, which actually has nothing to do with traditional FTP. Also, SSL is a protocol standard (and it's successor TLS, though they are frequently used interchangeably in speech), and OpenSSL is a software library for implementing it (you use OpenSSL to generate and sign certificates). I guess I need more info on how you are transferring files. Are you just creating a raw socket between hosts and writing the file over the network?
Yes. I am using a port above 5000, creating a socket, and reading a file on the client into a buffer and writing the buffer to the server, which writes the file.
Ok. According to the Python official documentation, creating a socket using SSL isn't too complicated compared to a regular socket [https://docs.python.org/3.4/library/ssl.html](https://docs.python.org/3.4/library/ssl.html) It looks like you create the client such as: #!/usr/bin/env python3.4 import socket, ssl, pprint s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ssl_sock = ssl.wrap_socket(s, ca_certs='ssl.crt', cert_reqs=ssl.CERT_REQUIRED) ssl_sock.connect(('192.168.65.150', 5443)) pprint.pprint(ssl_sock.getpeercert()) # note that closing the SSLSocket will also close the underlying socket ssl_sock.close() And on the server side: #!/usr/bin/env python3.4 import socket, ssl context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2) context.load_cert_chain(certfile="ssl.crt", keyfile="ssl.key") bindsocket = socket.socket() bindsocket.bind(('192.168.65.150', 5443)) bindsocket.listen(5) while True: newsocket, fromaddr = bindsocket.accept() connstream = context.wrap_socket(newsocket, server_side=True) Create the certificate and key: openssl req -new -newkey rsa:1024 -days 365 -nodes -x509 -subj "/C=US/ST=California/L=Mycity/O=MyOrganization " -keyout ssl.key -out ssl.crt As I mentioned earlier, the devil in the details is going to be generating and signing your certificate. SSL clients can be picky, so you will need to get your cert configured correctly for it to work. Check out this guide for creating a self signed cert [http://www.akadia.com/services/ssh_test_certificate.html](http://www.akadia.com/services/ssh_test_certificate.html). Here is an example for generating a cert/key from the command line using fictitious parameters (these parameters may be significant for the SSL client, read the python SSL docs for more details) the directory structure for this example: [root@cent7 ssl]# ls -la total 32 drwxr-xr-x. 2 root root 87 Sep 12 16:51 . dr-xr-x---. 16 root root 4096 Sep 12 15:55 .. -rwxr-xr-x. 1 root root 405 Sep 12 16:51 client.py -rwxr-xr-x. 1 root root 375 Sep 12 16:50 server.py -rw-r--r--. 1 root root 895 Sep 12 15:55 ssl.crt -rw-r--r--. 1 root root 916 Sep 12 15:55 ssl.key **edit** made a working cut+paste example that will spit out certificate details from the server on the client
No, the author explained problems with the code. I don't think that what he sees as problems are necessarily problems -- perhaps they are, perhaps they aren't, I've not used whisper so I don't know -- but it is fair to criticize a library if it has problems. Just judging by the article, I see these issues: - Lack of tests? Big problem. - Tests are incomplete or of little value? **Huge** problem. - Failure to follow PEP 8? Not really a problem. It's a style thing. - Functions in need of refactoring? Minor problem. - Functions require actual files on disk and cannot use StringIO? Minor problem. - Excessive use of bare "except" clauses? Problem. - Cache never expires? Possibly a problem. - Uses out-dated idioms? Maybe there is a reason for it. Perhaps it has to support older versions of Python. Otherwise, not a problem at all -- old idioms don't stop working just because new idioms become available. Hell, half the standard library is written in a style which the reviewer would call "unpythonic"! The authors of whisper should read this review and take it as constructive criticism.
&gt; Title is misleading... I think it should be "list comprehension". map is something very specific. List/generator comprehensions are just another syntax for a combined map-filter operation.
The biggest reason for preferring the first version is if you still have to support Python 2.4. The second reason is, "if it ain't broke, don't fix it". Code churn just for the sake of using newer idioms when your existing code already works is just an unproductive waste of time.
Yes, I thought that criticism was a bit over the top too. Also, the second version is buggy. Consider what happens if archiveList is not actually a list, but an iterator.
I prefer the use of dict(...) in this case as the dict comprehension has to do the split on '=' twice. 
FYI: You can replace the double split with `item.split('=', 1)`.
Thanks so much! I had actually looked at that page yesterday. I also ran into this page: http://carlo-hamalainen.net/blog/2013/1/24/python-ssl-socket-echo-test-with-self-signed-certificate So I'm assuming the server.crt and server.key need to be on the server, and server.crt needs to be on the client somehow? What happens if they don't match, what error gets thrown? Basically I want the client to be authenticated with the server so that my program can be run. 
The wasted split call makes my eye twitch, though. Even shorter: dict(item.split("=", 1) for item in "a=1&amp;b=2".split("&amp;")) Not that people should actually parse query strings like this. There are corner cases and errors. urllib/urlparse has it covered already.
But in your example there is no executable .. there's only a package. So how can linux launch it ?
Try doing a dual pane view. 
Sorry, I changed my post on you, so check out my new example. It should work as copy+paste at this point (just swap the relevant IP). Anyway, with this self signed cert setup, you will need the .crt file on both the client and the server. In a real world setup, just the server would need this file and a certificate authority would be contacted by the client to verify the certificate is legitimate. SSL public key infrastructure (PKI) is quite complicated, and I am a novice with it really.
This is my try at making a Kivy app for Android (I never wrote an app, I just love Python) : https://play.google.com/store/apps/details?id=org.test.motesnotes There are some downsides, but I still use it for my personal use :) Especially the loading time, and the difficulty I have scanning files for mtp. 
Keep it up!
Two things: 1. Map is so effing awesome - once I got it, I saw its true value 2. Holy cow, I had no idea there were dictionary comprehensions!
Eh - I really wouldn't call an lemon an orange just because they're both citrus fruits. Sure you can substitute one for the other in a lot of recipes, but why would you? List comprehension is a good topic; he should use the name for what it is he's describing.
I dont think Setuptools relates to the Anaconda Python way of packaging, correct? It relates more to pip? I've decided to go with Anaconda for good.
I prefer text.
It's not unusual for libraries and frameworks to support old versions of Python going back a decade or more. There are some [fairly important libraries](https://pypi.python.org/pypi?:action=browse&amp;show=all&amp;c=214&amp;c=528) still supporting Python 2.3, and believe me, that is no picnic! As for Python 2.4, that is the standard Python on older versions of RHEL which are still under commercial support for a few more years. (2.3 was only End Of Lifed maybe six months ago.) That means that many commercial sites will be still using 2.4 for a while yet.
Wouldn't Python 3.10 be the release after 3.9?
This has already been posted, albeit the source is different the article remains the same, nearly identical top comment as well: http://www.reddit.com/r/Python/comments/2dsp5m/why_python_40_wont_be_like_python_30/
Oh, I'm not saying your wrong for doing it! Just expressing sympathy for having to. 
This is not the place for this type of post.
Take a look at kimono labs and see if what they offer can help you. At least with your prototype
Agreed both observations, although if performance is important enough to avoid unnecessary calls, then using `dict()` instead of `{}` would run counter to that (~2x). The overhead of urllib/urlparse could also be unnecessary for some tasks. Nitpicking aside - dictionary comprehensions are dope!
I am a novice too; I like working with code examples for what I'm trying to accomplish since google hasn't been helpful (probably because I failed to search for the correct things). Thanks for your update to make an informative post. I will get to try this later tonight. It's similar to the example I already tried in the link, which is okay. Are you familiar with how this process works? So if the certificates don't agree, then what happens? Also when you wrap the socket, does that add encryption, so that any unencrypted traffic between that socket is now encrypted?
Huh. Weird. I'm on Windows 7 with 64-bit CPython. I get 5.249 and 0.080, respectively. Perhaps a platform difference?
Because comprehensions are just a short cut to map-filter. Arguably, I'd say comprehensions should be used to create new structures and map/filter to transform existing structures. thing = [f(t) for t in thing if condition] I'd write that as map-filter simply because I'm transformer an existing list. But if I wasn't simply transformer `thing` but grabbing values out of it for another structure, I'd probably use a comprehension. Writing this out makes me question my logic though. 
Wouldn't Linux 2.6.40 be the release after 2.6.39? Sure, except the developers decided to simplify the version numbers and call it 3.0. Here's what the reasoning looks like to me: Python is a language that welcomes new programmers, who are not necessarily familiar with the peculiar conventions of comparing version numbers. I can understand why they'd rather just release an uneventful 4.0 instead of preparing to constantly explain that 3.10 != 3.1. Of course double-digit version numbers are common in many software projects, but by 2023, Python will have gotten along for 32 years without them. Why should they have to start?
&gt; You can write a game with Kivy but you can't do much because the rendering pipeline is completely locked and wholely unique. I would have said the opposite, that you can do almost anything because the rendering pipeline is powerful and flexible.
[Semantic versioning](http://semver.org), feh.
Which Python ignores for every release. Most of the code is the forwards compatible, but there always seems to be something... Also waiting 10 years to remove a method seems excessive to me.
Eh? You're stuck with throwing a subset of instructions on top of an instruction stack and you can't do anything else. It's like a set of handcuffs. All I want is an OpenGL context and OpenGL functions.
Been writing a lot of javascript lately: when are we getting real anonymous functions? Decorators are a bad hack (being decoratable necessarily becomes the concern of the called function instead of the caller, only works well with a single function param, unnecessarily confusing language addition when lambadas do everything and better), comprehensions are completely unfit for anything even a little complex, lambadas... just no, and manual define-then-use adds a step and can muddle the intention of the program (which is probably why decorators were added in the first place). And the funniest thing is I feel like their exclusion is mostly just because... they're hard to make pretty with python's significant whitespace... But I could be completely off base here. Anyone want to weigh in?
It's generated when you install it with the setup script. cat /usr/bin/pip for an example.
No idea what anaconda does, but you are probably right.
I have long pondered whether the best approach would be to make the newer code able to compile into a .pyd that can be loaded into the old interpreter. That way libraries that want to support old and new are encouraged to move forward. 
My laptop is currently running Ubuntu 14.04 (I accidentally nuked Pacman's package database in Arch Linux, oops, haven't bothered to reinstall so temporary OS install).
I ran something nearly flawlessly from 11 years ago yesterday - that was cool! I think a bigger part of the issues with updating Python has to do with package manager woes (like why it is hard to have different versions of packages for different programs).
As a rule of thumb, try to avoid writing list comprehensions directly. Instead, write a generator expression and explicitly call `list()` on it (i.e. instead of writing `[ham for spam in eggs if parrot_is_dead]`, write `list(ham for spam in eggs if parrot_is_dead)`). This makes it more obvious that you are explicitly constructing a list. Generator expressions can be built in constant time, so it's reasonable to write them as literals. A list comprehension takes linear time, and using the `list()` call makes it more obvious you're about to do something potentially expensive. It also invites its removal more readily than the square brackets of a list comprehension. EDIT: Wow, -1 in under an hour! Anyone care to explain what I screwed up this time?
Because comprehensions are more readable to most Python developers (though I believe at least a few developers from functional backgrounds have said they like `map()` better), and can do literally *everything* map does: def map(func, *iterables): # In Python 3, map is lazy # For a Python 2 equivalent, convert to a list comprehension return (func(*args) for args in zip(*iterables))
You are right. Now I feel dumb. But the idea is still there, you just need to nest the functions. 
Thanks so much for clearing this up! You are the best. 
If you still have to work with 2.4 (hell I even consider 2.6 borderline) I'd suggest looking for another job.
Such as? Have you submitted bug reports for any of them? (If you're talking about stuff in `os`, well, yeah, those are low-level; you should be able to do most of that stuff via `pathlib` directly)
 helloworlds = [] def f1(): f2() f2() f2() f2() def f2(): f3() f3() f3() f3() def f3(): f4() f4() f4() f4() def f4(): global helloworlds helloworlds.append("Hello World") helloworlds.append("Hello World") helloworlds.append("Hello World") helloworlds.append("Hello World") f1() f1() f1() f1() print len(helloworlds) prints 1024
I honestly don't see any other choice than having to live with typing python3 and seeing Python 4.x pop up. 
If you don't know 3.10 != 3.1 in versioning what are you doing programming computers?
it doesnt really matter if you do list(blah for blah in blah) or [blah for blah in blah]. i would prefer [blah for blah in blah] personally 
Maybe just "python"? And python 2.x would be "python2"
 Personally, I prefer O(n)+ operations to be visually obvious. what does that mean
When you call `python setup.py install` or `python setup.py develop`. If you're using `pip install` or `pip install -e` this will do the same thing too since it's just calling setup.py install/develop in the end.
If you are learning by yourself you better be able to figure it out yourself. If you have a teacher your teacher will tell you. Either way if you are learning python it hardly matters what version you install.
for the query string x {k:v for k,v in [i.split("=") for i in x.split("&amp;")]}
performing a strip("?") doesn't seem too outlandish
That's a rather elitist way of looking at it. But it's something they'll have to learn at some point, so I don't really buy the "it's easier to understand" argument either.
I just noticed... * Python 1 has one kind of string (byte strings) * Python 2 has two kinds of strings (byte strings, unicode text) * Python 3 has three kinds of strings (byte strings, unicode text, surrogate-escaped bytes-in-unicode) So I guess this article is saying Python 4 won't add a fourth kind.
I had to dig a little bit to find if it supports both 2.7 and 3.x, as well as ironpython. &gt; We recommend 32-bit 3.4.1 for new projects or 2.7.8 for maximum package compatibility.
You could also write a simple timing decorator and hook it up to your ``logging``, which is a pattern a lot of people use. I also found this project while Googling, which seems interesting: http://mg.pov.lt/profilehooks/
&gt; Well that doesn't help much if you're passing a Path into some library that internally uses os.stat or some such. Ah. Unfortunately, I'm not really sure what the Right Thing is here, from Django's perspective. Just indiscriminately calling `str()` would be bad because `str()` always works (i.e. you never get a `TypeError`), and would probably produce insane behavior if you passed the wrong type of object (e.g. trying to interact with a file named `'&lt;function &lt;lambda&gt; at 0x7f869bc4eb70&gt;'`). You can't unconditionally convert to a `pathlib.Path` because Django is 2.x-compatible and `pathlib` doesn't exist in 2.x; in 3.x-only code, that is arguably the correct approach. A 3-only library can benefit from `pathlib` because it eliminates a number of pain points for working with paths, so such a library would want to convert incoming paths to `pathlib` anyway. For example, atomically creating a dotfile is easy in `pathlib`: pathlib.Path('.dotfile').touch(exist_ok=False) ...but requires this clunky code otherwise: os.close(os.open('.dotfile', O_WRONLY | O_CREAT | O_EXCL)) In 3.x, you can use builtin `open()` to do this, but 2.x lacks the `'x'` mode (even using the fancier `io.open()` function) and other approaches (e.g. using `os.access()`) are prone to race conditions. In any event, the 3.x code is not significantly nicer. That's assuming you're doing it in the working directory, of course, which is actually a pretty lousy assumption. If you want to do it in `some_dir`, `pathlib` gets even nicer: some_dir = pathlib.Path(some_dir) # you probably already did this by now dotfile = some_dir / '.dotfile' dotfile.touch(exist_ok=False) In `os`: dotfile = os.path.join(some_dir, '.dotfile') os.close(os.open(dotfile, O_WRONLY | O_CREAT | O_EXCL))
what I meant is how do you store a python object in redis.Do I need to pickle the class?
I agree on Ansible. In fact, since Ansible is just an imperative tool in disguise, with a terrible and limited DSL, if I must use an imperative tool I prefer Fabric: at least it is clear and explicit in its intent. 
You'll need to serialize your object to a string. Consequently, you will also need to be able to deserialize that string back to an instance of your class. One option for serializing/deserializing would be [JSON](https://docs.python.org/2/library/json.html).
If you can install everything on your own, hats off too you. For me getting some of those libraries, particularly matplotlib, installed was a pain in the dick. 
Didn't I just read this article a month ago?
I asked [a related question](http://www.reddit.com/r/Python/comments/20n84w/anaconda_not_useful_on_linux/) a while back which yielded some insightful comments.
Well I'd argue that django shouldn't have to care as long as it just passes the stuff on to one of the os.* functions. They should work with pathlib.
Saw this post [1] a while ago. In the comments Tom Christiansen shows some nice manipulations of grapheme clusters. I'm not knowledgeable enough to know the difference of what he does to what you guys were saying is lacking, aside maybe that it may not be a proper built in string class (I don't know perl). He also has a whole cookbook about it [2]. [1] http://mortoray.com/2013/11/27/the-string-type-is-broken/ [2] http://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html
Find the midpoint and return the concatenation of the two substrings using the midpoint.
Might also want to look at the edge case: what are you going to do if your string has an odd length?
Then the second half of the string will have 1 more character when switched So... switch("Hello") Output: lloHe
What Sir_not_sir said: def switch(y): split = len(y)/2 return y[split:] + y[:split] Line 2 gets the midpoint by dividing the length of the string by two. Line 3 uses string slicing to return the substring from the midpoint to the end of the string concatenated with the substring from the beginning of the string to the midpoint. Also, for future reference, questions like this should go in /r/learnpython instead.
I thought i was in /r/fifthworldproblems for a sec.
An argument guaranteed to ensure many eventual python &amp; linux gurus will simply stick to windows instead. 
I hope not.
I already have matplotlib, numpy, scipy, pandas, sympy, ipython+notebook, etc installed. I just got it as it was a recommended way to get scikit learn. I think Im going to remove it and maintain above packages on my own. 
You need a serialization method. Pickle is an option, but it may not be the best one if the object has to be stored long term. I encourage to you watch [Pickles are for Delis, not Software](http://www.youtube.com/watch?v=7KnfGDajDQw) by Alex Gaynor.
That is probably a good idea in theory, but it does create some issues. The primary one is that `pathlib` imports `os`. In order for `os` to properly handle `pathlib` objects, it needs to do type introspection (i.e. use `isinstance()` or `type()`). It cannot blindly call `str()` because that will convert *any* object to a path, probably with ludicrous results. But in order for `os` to do that, it ideally needs to import `pathlib`. And now we have circular imports. Circular imports are not illegal, but you must be very careful when writing them or they will blow up in your face. For instance, here is a representative snippet from `pathlib.py` on my machine: class _NormalAccessor(_Accessor): # [snip] stat = _wrap_strfunc(os.stat) It doesn't matter what this is supposed to be doing (I don't have a clue). It is interacting with the contents of `os` at import time. That means the contents of `os` must necessarily exist when `pathlib` gets imported. If your dependencies are acyclic, this isn't a problem because `pathlib` imports `os`, so `os` is guaranteed to be fully imported before `pathlib`'s code runs. But if `os` and `pathlib` both import each other, and client code attempts to import `os` first, the above code will break. Here's what happens: 1. `import os` in client code gets executed. 2. `os` is added to `sys.modules` and imported. 3. `import pathlib` in `os.py` is executed. 4. `pathlib` is added to `sys.modules` and imported. 5. `import os` in `pathlib.py` is executed. 6. `os` is already in `sys.modules`, so the mostly-empty module object created in step (2) is produced. 7. We hit the above code and blow up because `os.stat` hasn't been defined yet. Frankly, writing circular-import-safe code is a nightmare, requiring cooperation from both modules (since client code could import them in either order). It's much easier to just ensure the import graph is acyclic. Unfortunately, this makes a number of things more difficult, including this use case. Probably the easiest option is for `os` to defer importing `pathlib` until right before it validates a path. But that requires more code and more effort.
I think honestly the best thing to do is package it as python4; debian/ubuntu at least has the ability to have one package obsolete / conflict with another, so if you install python4 it would uninstall python3 (and vice versa). The python4 package would probably have to have symlinks for python3 however, because currently "python" means "python2", so all my scripts (and many others I am sure) that expect to be run with python3 start with `#!/usr/bin/env python3`.
Anaconda is produced by Continuum Analytics whom are largely backed by DARPA (US Defense) funds. I'm sure a lot of the legalese comes from that fact.
Frankly, for the few months I was running python on a fairly locked down Windows machine Anaconda was a lifesaver. Getting a full scientific python toolchain built with only local user access was incredibly difficult, Anaconda simply installed everything for me without spending hours messing around with paths and source builds... I finally got the go ahead to nuke and pave the machine and install Linux so now I just use apt-get and pip + virtualenv. I also manage my own toolchain on OS X (using brew) [0] [0] Although you do get rough edges from time to time e.g., matplotlib and libpng have *never* played well on my OS X box
Nick Coghlan reposted the article to Red Hat developer blog to "borrow Red Hat's credibility": https://mail.python.org/pipermail/python-dev/2014-September/136306.html
Simple is better than complex. Complex is better than complicated.
Pickle works if you're sharing the same code base between multiple things and that the path to the object for both run times is the same and if you can pickle it. Let's assume you can't, you've got a couple of options. One is to serialize by adding a 'to' and 'from' json methods in your object that reduce the data down to a dict or list and get it back out again in a meaningful way, then take that string from your 'to' and put it into redis. I think that's overkill though, especially if you don't need to put this object anywhere else. Instead, use a pipe object and hset or just hmset and store it in redis directly. The next logical step in this path is a proxy object which stores the various attributes in redis as they're set on the fly. 
more that the transition is not going to be the tortuous balls-up that 2.x to 3.x was because if it is there will be no 4.x
Hopefully the latest, with no need to care for versioning since you got it through your package manager or a big generic download button.
It's possible to get in sticky situations with pip e.g. update pandas, then update numpy, pandas will complain that it was compiled against a different version of numpy.
yes... i was just thinking the same thing. to make it worse the article is bs.
That seems pretty accurate to me. True, Maybe, Meh, and False.
considering how long python3's been out, a week might not be enough.
I dunno, some distributions (notably arch) seems to do it fine without breaking anything. Most packages which require python2 do it in the background without you noticing. It's when you start to work with scripts that you need to run with python2 manually that you ever notice the issue and by that point, hopefully you know about the python version differences. hopefully.
&gt; four types of Boolean What besides `Boolean`?
Been using it for a while now, absolutely recommend!
I think you are on the wrong track with that reasoning. 
&gt; How to find out when Airfares are Cheapest ... on hotwire.
Please leave that as a comment on the post. Thank you...
Yup, I figured out. Everything is working fine now. 
Anaconda provides an alternative to the pip/virtualenv workflow that is geared towards using python for numerical work. It does everything that pip/virtualenv gives you (pip and conda will happily co-exist, so you don't lose out on pipy) but brings some new things to the table that are really useful if you're part of their target audience. A couple nice features: - conda doesn't recompile packages from source when you install them. Recompiling numpy in each new virtualenv gets old really quick (and if you're part of anaconda's target audience you're probably installing numpy in every virtualenv). - continuum provides numpy linked against the Intel MKL and makes installing it trivial through conda. I cannot overstate how awesome this is. MKL gives numpy a _huge_ performance boost and is also a huge pain in the ass to set up yourself. Honestly I would use anaconda for this alone even if the rest of the environment kind of sucked. The fact that the rest of the toolchain is also good is a bonus though.
Is there a reason you're trying to use Notepad to do this? Creating the file and writing to it directly using Python's built-in open() function would be much easier.
It's a decent toolset... but honestly their presentation was pretty lackluster, specifically compared to previous times they have shown the tool ([compare to their feature overview, which really gives a better impression of the tool](https://www.youtube.com/watch?v=JNNAOypc6Ek)) and actually talked about advanced features. For whatever reason, this time around, they only talked about how "amazing" it was that you could put break points in code... This is something Python developers have been able to do with PyCharm and PyDev for a very long time (and the previous version of their toolbox, no less). They only compared their product to the most basic of Python editors, not to actual python IDEs. Really, some of those weren't really Python IDEs, rather, just editors. When compared with other real IDEs, the features they actually discuss in the video are kinda basic. The overwhelming majority of [Python IDEs support debugging features](http://en.wikipedia.org/wiki/Comparison_of_integrated_development_environments#Python) and have done so before even the very first version of VS Toolbox was ever even created.
Gotta agree with the last part, BUT if you're dealing with a large file it's almost certainly the case there exists - though it might take some eeking out - a neat way to break it up logically. I was wondering if I should have *started* the project in multiple files... I'm just not sure it would have made sense at the time (it wasn't initially clear how I was gonna get the job done)... but maybe thinking about how to split from the beginning would have led to more rapid/better development in the long run. In your example, would you **start** with separate GUI, front-end, formatting from the beginning?
no I have to use the notepad unfortunately
As a python user for numeric stuff in windows, I don't know wtf are people talking here.
Hmm, I have what I think is a good microphone, and to my ears, the sound seems OK. But it's quite possible that (a) I needed to stay closer to it, (b) I needed to tune it, or (c) I need an even better one.
That's basically what I wrote this to do. Feature-wise, AutoHotkey is great. But what kills it is that 1) it's Windows-only and 2) they invented their own programming language. :P I plan on adding global hotkeys and window-related functions to PyAutoGUI in the future (feel free to fork it and make Pull Requests). Any other parts of AutoHotkey you like that should be included in this?
You might have a better chance of solving your problem at /r/learnpython. People generally don't come to /r/Python to answer questions like this.
Menus and windows would be nice to have. That's one of the advantages of AutoHotkey - even though it's a pig language, it's easy to make a simple GUI.
The point is letter should be ['a', 'b'] there
If I understand you correctly (by the way, please indent your code blocks with four spaces so that reddit renders them correctly!), this is your desired outcome: * Your script creates or overwrites a text file, filling it with the "X green bottles" song for some value of X. * Your script then opens notepad to display the new text file for your entertainment. To write your output to the file, the cleanest way in your case is to use the `print` function with the `file` keyword. That is: `print(some_line, file=my_file_handler)`. To open `my_file_handler`, use the `with` idiom: with open("green_bottles.txt", "w") as O: for line in generate_bottle_lines(): print(line, file=O) Because print is friendlier than the `write` method of file-like objects, you'll find it easier to work with, generally; it will auto-add newlines, for example. Now, to open your file at the end, you use a function from `subprocess`, yes. However, `subprocess.call`, IIRC, does not block while the file is open; it'll open notepad and then immediately move on, finishing the script. Whether this is what you want is entirely up to you, but an alternative is to use `subprocess.check_call`, which will "block" until you close notepad or it crashes, and will store the "return value" of the program, notepad in this case. On Unix platforms (almost everything but windows), the expected behaviour is that a successfully closed program without errors will return zero, and any crashes or error conditions will return some other number. I don't know whether Windows does so, or whether Python pastes over windows' unhelpful deviations from the norm, or whether you should expect to receive a complex number or a string full of "BILLGATESSTEVEJOBS" or what-have-you. The point is, the script will wait for you to close notepad before resuming execution. So, that's the core. The only other thing I'd suggest based on the code you pasted, is to patch over your many strings by using the magic of *string interpolation*, e.g. the `str.format` method. with open("green_bottles.txt", "w") as O: for i in reversed(range(1, 100)): # Starts at 99, stops at 1 # Counts from 99 to 1, uses some logic to determine whether to use the plural. # Handy trick; if you just put two string literals next to one another, Python will join them. # This is a very visually pleasing way to create long lines without breaking visual indents. # Wrap it in brackets, and you can call methods like format() on the final joined string. # To learn more about formatting, look up the docs, but suffice to say the {n} bits mean # "insert a stringified version of the nth argument to format". this_line = ("{0} green bottle{1}, hanging on the wall;" " {0} green bottle{1}, hanging on the wall!" " And if 1 green bottle, should accidentally fall," " there'd be {2} green bottles, hanging on the wall." ).format(i, 's' if i != 1 else '', i-1 if i &gt; 1 else "no") print(this_line, file=O) else: # Runs after the above for-loop unless it encounters a "break" condition (i.e. never) print("No green bottles, hanging on the wall!", file=O) The above code should output, to your "green_bottles.txt" file, the following: 99 green bottle, hanging on the wall; 99 green bottle, hanging on the wall! And if 1 green bottle, should accidentally fall, there'd be 98 green bottles, hanging on the wall. ... 1 green bottle, hanging on the wall; 1 green bottle, hanging on the wall! And if 1 green bottle, should accidentally fall, there'd be no green bottles, hanging on the wall. No green bottles, hanging on the wall!
Accepting critique is hard ... Also, more discussing here http://lists.openstack.org/pipermail/openstack-dev/2014-September/thread.html#46232
can you just use open/write/close to create the file and then open it with notepad? That might be easier to achieve
By the way, I just noticed that this *isn't* posted in the /r/learnpython sub; that'd be a better place to put questions like this in future, it's a really friendly sub with a lot of activity and it keeps the discussion here more on the subject of Python's ecosystem, direction and design.
Looks like the week of January 19, 2014 was the cheapest to fly from here to home.
This is not a new situation. The maintainer fancies himself a special snowflake that doesn't play by the standard rules of software engineering, and it's not likely to ever change. Here's his justification from a [pull request attempting to undo the bundling](https://github.com/kennethreitz/requests/pull/1812#issuecomment-30854316): &gt; - I treat requests as a product. I want to be in 100% control of all aspects of the user experience. &gt; - I believe these dependencies are implementation details. If there's something wrong with one of them, I can change it arbitrarily. I can test new patches before they are merged. I can remove them entirely. &gt; - I want my users to be free to not use packaging if they don't won't to. They can just grab the tarball and go. &gt; - Requests itself is therefore vendorable. This is particularly useful for system-level applications because Python does not allow for multiple versions of dependencies to be installed. If all the CLI tools you use written in Python used different versions of requests, and you had to use site-packages, that'd be a bad situation. It all sounds very noble and user-centric, except when you realize that it's meaningless in many situations. Debian, Ubuntu, and likely every other distro on the planet rips out all the bundled versions and forces the library to play by the rules of everyone else and explicitly state its dependencies. All the careful reasoning stated above goes right out the window if you install Requests using a package manager. Distro package managers have good reason to hate it when projects bundle libraries, and they nuke that on sight. But that doesn't stop Requests from continuing to do what it does. I see bundling as fundamentally selfish, but in a way that's meant to be magnanimous. "Dependencies are hard, let's shield the user from them" sounds like a statement made out of a desire to help, but does it really? One of the listed justifications is that users can choose to avoid dependencies. But how does one package bundling some libraries solve that? To really solve that problem, what you want is a systematic approach, like a utility that bundles any application and all its dependencies into a self-contained unit. If you need isolation, you get it, and you get it from all modules, not just one. And you don't get it by default, because you shouldn't need it by default, and you should have to think long and hard before taking that step. 
I have used [Sikuli](http://www.sikuli.org/) with great succes a while back. Nice IDE, very powerful and under active development. It is based on Jython.
You should use isThereAnyDeal.com. They have a feature which will alert you if a game goes under a certain price or discount level, across as many stores as you want (Steam, GOG etc)
Yes, no, maybe, I don't know?
Yeah but if you read from a file who already had data like: 6 10 blib blupp 4 7 2 rubbish text 3 9 1 3 is an odd number and what i want is a program to do this: Enter a filename: FilSomInteFinns.txt file "FilSomInteFinns.txt" can not be found, please try again! Specify a different file name: tal.txt lane 3: blib blupp Row 7: rubbish text row 10: 3 is an odd number Average of all numbers is 5.0 Median number is 4 Maximum speed is 10 The minimum number is 1
Did you really search well? I think you just want a snippet here. sum = 0 with open('file.txt','r') as f: for line in f.readlines(): if line.strip().isalpha(): print('{} is not number'.format(line)) elif line.strip().isdigit(): sum += int(line.strip()) print('Sum is {}'.format(sum)) You can modify it a little bit to work with several digits on a line, it should be trivial and is your homework
I think you meant to comment on [this post](https://www.reddit.com/r/Python/comments/2gnnth/thinking_with_map/) about using `map`.
I don't understand how this post calling an URL using Requests got so many upvotes.
We accept the criticism, and respectfully disagree. =)
http://i.imgur.com/DufhXrT.jpg
Excellent reference! I'm seeing a lot of methods I've never seen before here, very useful. 
Cute. Are you schizophrenic or just trolling? Cause the contradiction in your poor comment is glaring.
Please google stuff when it's quite likely that people have had the same issue before you. Or use /r/learnpython. 
In what terms can Saltstack everything better than Ansible? Any examples?
This is the right answer, and the person you replied to is a dick, but IMHO blurring the distinction between version numbers (which in reality are tuples) and decimal numbers is problematic. Better teach Python noobs that `sys.version_info[:3] == (3, 3, 4)` is the right way to look at it
That means you tried to install a 64 bit binary module with a 32 bit Python or vice versa. And never post screenshots of code. 
I usually just grab miniconda and install the bits I need.
The main argument I hear for Anisble is that it runs over ssh, no additional configuration. But Salt has salt-ssh, which does the exact same thing. So then it's a choice between two very similar techs, one with many many more features than the other.
Y'know, it's possible to hear someone's criticism, understand where they're coming from and why they think the criticism is important and valid, but still believe that the choice you made is correct. That's what accept + disagree would entail...
For something similar without signing up, Try Python(x,y). 
meh
def OpenFile(File): Op=open(File,'r') return ReadFile(Op) def ReadFile(Op): RdFile=Op.readlines() return RdFile ##def Medianeven (elements): ## elist=[elements] ## elist.sort() ## MedianNr = len(elist)//2 ## median = (elist[MedianNr]+elist[MedianNr-1])/2 ## return median def Medianodd(elements): elements.sort() nr = len(elements)//2 median=elements[nr] return median def Average (Nrlist): average = sum(NrList)/len(NrList) return average def Smallest(elements): elements.sort() return elements[0] def Biggest(elements): elements.sort() elements.reverse() return elements[0] NrList=[] LetterList=[] File = "tal.txt"#input("Ange ett filnamn: ") try: text = OpenFile(File) except IOError: print("Filen '" +File+ "' kan inte hittas, försök igen!") else: for rad in text: rad = rad.strip("\n") rad = rad.split(" ") for element in rad: try: a=int(element) NrList.append(a) GetMed = Medianodd(NrList) GetAve = Average(NrList) GetBig = Biggest(NrList) GetSma = Smallest(NrList) except ValueError: print(" ") ko=[text] for rad in ko: print (rad) try: a=int(rad) except ValueError: LetterList.append(rad) ## LetterList.append(element) ## for rad in text: ## try: ## x=int(rad) ## NrList.append() ## except ValueError: ## LetterList.append(x) ## print("Rad", LetterList[], ## print("Rad", LetterList[], ## print("Rad", LetterList[], print("Medelvärde av alla tal blir: ", GetAve) print("Median talet är: ", GetMed) print("Största talet är: ", GetBig) print("Minsta talet är: ", GetSma) print(LetterList) I get this but it doesn't print out a string in lines :/
will you run multiple instances of your project on the same machine? -&gt; yes otherwise -&gt; yes
always, everywhere, for everything* system python &amp; packages != your application python &amp; packages *except system tools if you are a system (linux distribution) builder, though maybe they should too...
Same here! I wish more people know about miniconda and the direct downloads [link](http://conda.pydata.org/miniconda.html). I think that would take care of most of the initial fear or misunderstanding about Anaconda.
Seriously, why would you do that?
For those who might be interested in a less bloated setup, should check out [miniconda](http://conda.pydata.org/miniconda.html)
web faction + django + virtual env = pretty sweet http://michal.karzynski.pl/blog/2013/09/14/django-in-virtualenv-on-webfactions-apache-with-mod-wsgi/
1) This is better suited for /r/learnpython 2) Has this question come from out of the blue? Do you know what a loop is? How to print things? How would you print just the first number in the list?
How is this relevant to python exactly? You used a lot of linux I guess...
this is what i have so far, just to print each number. for xs in ["12", "10", "32", "3", "66", "17", "42", "99", "20"]: print(xs) i'm having trouble trying to figure out what i need to put in order to find the square of each number 
I don't want to start a philosophical discussion without need, but I sometimes get the feeling that developers take virtualenvs as an excuse not to care about API-stability.
 root@lisa:~# ./CrackTheDoor O_o you really just ran a binary you got via email as root?
Cannot reproduce: In [1]: timeit float('500') 1000000 loops, best of 3: 261 ns per loop In [2]: timeit int('500') 1000000 loops, best of 3: 219 ns per loop Besides, when you're trying to benchmark something so insubstantial, then any amount of background noise starts to become significant, so it's hard to get consistent and meaningful results. 
Your first language is not English, is it?
I think it's an excellent post. The company isn't stated but the filename might give it away.
That's interesting. Maybe it's an implementation-specific optimisation. I'm using 2.7 x86 on Windows. I also found this: timeit int('500') 1000000 loops, best of 3: 687 ns per loop timeit int(float('500')) 1000000 loops, best of 3: 513 ns per loop Even if the string contains an integer number, it's it's faster to convert to a float first. &gt;Besides, when you're trying to benchmark something so insubstantial, then any amount of background noise starts to become significant True, but I'm consistently getting a 2x different in execution time between int() and float() which is pretty substantial. 
I'm not sure you should bother with /u/jm_. Looking at their comment history you'll see [this](http://i.imgur.com/4CTrd2E.png) insensitive gem.
Hopefully he asked his employer for permission first.
In addition to what /u/ubernostrum said, it would be cool if you didn't use mental illness as a pejorative.
The main issue (in my opinion) is that you don't want to pollute the system ``site-packages``, because you don't know what other system software relies on those libraries. If you need to use system libraries, you can still do that with ``virtualenv``. If not, then you can do that too. So I would say yes: you definitely want to be using ``virtualenv`` in production.
&gt; All the careful reasoning stated above goes right out the window if you install Requests using a package manager. &gt; &gt; If you install requests with a distro package manager. We don't only have Linux users. We have many, many users on OS X and Windows, and they matter to us just as much as our Linux users. For the record Linux is *the* primary OS which downloads from PyPI, I could dig up exact stats but it's something like ~50% of the downloads come from Linux and an additional ~40% are "Unknown" (aka older pip or still using easy_install) and we can assume that a large chunk of those are Linux as well. The point being, there are a lot of people *using Linux* whom have chosen to install from PyPI rather than their distro's package manager.
&gt; Debian, Ubuntu, and likely every other distro on the planet rips out all the bundled versions and forces the library to play by the rules of everyone else and explicitly state its dependencies. We accept that they do this but never actively encourage users to use those packages for this very reason. Users can choose to do so, and when those maintainers mismatch urllib3 versions and break things, we do our best to support those users. Installing from PyPI is realistically your best option for up-to-date and relevant packages for any distribution. It's also the single most consistent distribution for users who are not on Linux (which is fairly significant in size, lest you think otherwise). &gt; But how does one package bundling some libraries solve that? We can't solve it for the community because the community has to solve it (and is starting to with a variety of PEPs surrounding packaging). What vendoring solves is that problem for one of the user's dependencies. That user can now shove requests into its source tree (as several tools already do, including pip) and not need to modify a single line of it by hand to make it work there. &gt; To really solve that problem, what you want is a systematic approach, like a utility that bundles any application and all its dependencies into a self-contained unit. Right and that sort of exists but it doesn't work across all platforms. You even have large companies like Twitter working on this problem. &gt; And you don't get it by default, because you shouldn't need it by default Are you sure of that? Install something that depends on a version of requests &lt; 1.0 (without vendoring requests) and then install something that relies on requests &gt;= 1.0 and then try to use the earlier tool. (Or do the opposite, either way ) You're breaking a user's system because they're not aware that tool X relies on that old version and tool Y relies on a new version and that breaks one of them. That user is now utterly frustrated because tool X was reliable until tool Y broke it. &gt; I see bundling as fundamentally selfish We'll agree to disagree. It's not selfish if we can release with features that are yet unreleased in urllib3. More often than not, /u/Lukasa and I are not the ones who benefit from those features. Projects like OpenStack and companies like CloudFlare, Twilio, and many more rely on these advanced features being released quickly. urllib3 isn't usually a bottleneck but often times this allows us to provide the best user experience possible. If caring about our users' experience is selfish, then I'm one of the most selfish people in the world.
it's a job interview. Personally, I'd call it safe as well.
My output is from 3.4 on Windows. &gt; I'm consistently getting a 2x different in execution time between int() and float() which is pretty substantial. It's the operation itself that is insubstantial, not the difference. You could, for example, actually be testing memory allocation, since on 2.7 under x86 a Python float object requires 16 bytes while a Python int requires 12 bytes, and maybe having a size that's an exact power of 2 has a fast-path through the allocator. That's what I mean about noise and not actually measuring what you think you're measuring. (Python 3 got rid of the old `int` type and renamed `long` to `int`, and `long` occupies 16 bytes.) 
Still, even on a VM I wouldn't run something like that as root.
Yes, I see what you're saying. Though I suppose even if I'm not measuring the operation itself, this is a valid comparison for this implementation and so I should choose the method that's fastest for this computer. I wonder if the difference comes from 3.x vs 2.x or if it's a 32-bit thing.
y'all is crazy
Co-incidentally just found that site last month. On second visit it went into Bookmarks under "Help". I like the clarity and ease of navigation: I always come back with a specific question and it is so easy to get to the right text, read a good explanation, grok the idea and go back to coding. Cool.
I doubt it's against a rule to ask a question here, but this subreddit (from what I've seen by lurking a bit) is more aimed at news and useful things people have found in python-- not teaching you how to solve a problem. As the sidebar indicates, if you have questions, consider posting in /r/learnpython
Are you asking how that's implemented? It's just JavaScript, look at the source: function on_switch() { var selected = $(this).children('option:selected').attr('value'); var url = window.location.href, new_url = patch_url(url, selected); if (new_url != url) { // check beforehand if url exists, else redirect to version's start page $.ajax({ url: new_url, success: function() { window.location.href = new_url; }, error: function() { window.location.href = 'http://docs.python.org/' + selected; } }); } } $(document).ready(function() { var release = DOCUMENTATION_OPTIONS.VERSION; var version = release.substr(0, 3); var select = build_select(version, release); $('.version_switcher_placeholder').html(select); $('.version_switcher_placeholder select').bind('change', on_switch); }); 
You can't think of one good reason for posting this? The number of people helped by the educational value of the article vs the number of people harmed by abusing the details to try getting a job? I'm not sure that the second factor would even be very negative; if an employer can't vet them, then they kind-of deserve the opportunity. 
First thing I noticed too. Bad security engineer! Bad!
thanks xD 
A lot of people don't think that the setuptools approach *is* a good one. This is the solution the Ruby community has chosen via Bundler, and it comes with it things like having to do ``bundler exec foo`` instead of just ``foo`` without specialized entry points (Ruby's binstubs, setuptools console entry points). It also means that just plain ``python -c "import Django"`` doesn't work, you have to have something that will run before your code does. Setuptools again has something for this, mandating that you do ``import pkg_resources; pkg_resources.require("Django")`` prior to importing Django so that it has a hook to munge the sys.path to add that distribution to the sys.path. There's also just the simple differences in isolation, currently with virtualenv each environment gets it's own copy of any of the dependencies. This does mean that you have to update each virtualenv individually, but it also means that for instance you can easily drop into the stdlib or a third part module and modify it to add some extra debugging information without having to worry about that affecting other pieces of your system. Generally the "in memory environment" ideal tends to work better in deployment with defined entry points (the setuptools concept, not the general concept) and tends to become burdensome in other situations, especially development. The virtualenv style tends to add duplication which requires some tooling to manage but overall it tends to work out a bit nicer albeit at the cost of needing to explicitly activate an environment or reference it's bin files directly.
It's not at all relevant to python. He just wanted to show off his understanding of basic x86 instructions and debugging in gdb.
It's more of a trust/privacy issue than anything. If he cleared it by his new boss I see no issue here.
 In [1]: %timeit float("500") 1000000 loops, best of 3: 272 ns per loop In [2]: %timeit int("500") 1000000 loops, best of 3: 855 ns per loop Python 2.7.3 64-bit on OS X Mavericks. Interested in knowing why (even if it's pointless to try to optimize it out) 
What is the worst that could happen?
I've written a few gists based on interview questions: * [Find the deepest Node in a Graph](https://gist.github.com/jasonsperske/8339280) * [Write an algorithm that counts the number of ways you can paint a fence with N posts using K colors such that no more than 2 adjacent fence posts are painted with the same color](https://gist.github.com/jasonsperske/7952566) * [Implement multiplication without the multiplication operator](https://gist.github.com/jasonsperske/7776047) (and in [Clojure just for fun](https://gist.github.com/jasonsperske/7798178)) A good interview question isn't just about being able to have an answer to some obscure puzzle at the ready, but being able to explain it and walk though solving it in front of others clearly.
Seeing the same thing on Linux, Python 2.7.6. In [2]: timeit float("500") 10000000 loops, best of 3: 123 ns per loop In [3]: timeit int("500") 1000000 loops, best of 3: 287 ns per loop 
Thanks Rhomboid. My problem is I over think the problem. I thought they where doing fancy things with the sphinx build. 
As mentioned by everyone — yes. There is a good explanation in quite rescent article: https://hynek.me/articles/virtualenv-lives/
There's some python stuff near the end.
lisa is the computer name, we have no way to know what gender is running it.
If you have an outside directory or something mounted, it could escape and do damage to that.
Which would almost look the same if written in php/perl/ruby/whatever.
If you're not allowed to collaborate on your homework, asking specific homework questions on any subreddit would be considered cheating.
I haven't been able to find any. I guess it's similar to how PEP8 doesn't say anything about naming functions well or OO - although these are style-y things they are different to how the language is written? I think this would make an interesting research project!
It's interesting as I found the process of splitting up very destructive (I had to make some big changes to functions to allow the splitting - and I think there are a couple more splits I'm considering) and wonderful... I think without a big testing suite I would have struggled big time to make the change. I guess if I was confident in my testing (I wasn't!) from the beginning then I could have made the transition whenever.
If I was interviewing someone for security, I would make it do something malicious if they ran it as root, or at least get it to send me an email telling me they did. 
Few of the possible reasons *not* to use it: * You are deploying just a single app on a system (thus no expected conflicts). * You need to be able to downgrade libraries (if upgrading unexpectedly breaks production even after testing) but upgrade them automatically (e.g. security patches). * You have another way of deploying dependencies already and need some binary dependencies that can't be easily compiled. Relevant question: is there something like debian stable for python packages, i.e. versions that will get old but will still get security patches / bugfixes? 
Because there are a lot of fanboy chuckleheads in the Py3 brigade that get all downvotey if anyone says *anything* pro-Py2 and anti Py3. The validity of the comment plays no role. It must die!
Did you follow instructions and get an access token for yourself?
Not sure what you mean but the main reason for many people using virtualenv is that they can pin exact versions of libraries in order to *ensure* API stability.
Maybe it's a vintage Apple Lisa?
Or use a different download link: http://continuum.io/downloads
I'd recommend easygui for this. I copied some of the code for the message box features (and later spun it out to a separate PyMsgBox module for cross-platform message boxes). I probably won't add a full blown gui toolkit, but it's good to know that there's a demand. I will be looking at extending easygui.
I like how people think having some non-server modules bundled in their app is somehow a "security time bomb" if you're not processing input from a 3rd party there's no security issue there. I don't understand the security concerns, unless there's something in urllib3 that arbitrarily executes network content, which is extremely unlikely.
&gt; I see bundling as fundamentally selfish, but in a way that's meant to be magnanimous. In a perfect world that would probably be true. But we live in a world where Python can't handle multiple versions of a library and libraries are not updated in perfect lock-step with their dependencies such that everything that relies on, say, `requests` is *always* compatible with the very latest release and nothing can ever break due to incompatible versions. Most importantly, when shit does break due to incompatible requirements, not every Python programmer is skilled enough to figure out what's gone wrong and fix it. Which inevitably means a lot of support requests to the developers, who could be making better use of their time. So you can stick to your "bundling is bad" line, but you should recognise that you're being elitist because what you're saying is, "my high-minded principles absolutely outweigh the needs of less skilled programmers regardless of the difficulty it may cause them." If you care about making your library as accessible as possible to novice users (which is kinda implied by the "for Humans" shtick), then your approach isn't really acceptable, regardless of how theoretically better it is. 
Wow. My first time on this subreddit and I find a post that is thoroughly interesting and there is nothing but criticism in the comments. I think I'll stick to ignoring the comments. Anyways, thanks for the article, op! 
It becoming a habit. And writing about it on the Internet ;-)
This is a stupid critique.
2 is the worst example! 
I'm excited about extending this to AMD. I've been considering selling my 280x due to the lack of support in the main GPU efforts. Pyopencl exists but is operating at a different level than the projects referenced.
I appreciate that I can download a single module to do all of this instead of hacking together a mess of 20 different dependencies that may or may not work on whatever platform I'm using. Ignore the haters - they are the same folks who will swear to you that 2015 will definitely for sure this time be the year of the linux desktop. 
Sometimes the best way to learn is to dive into it regardless of where you're at. You'll probably look back on what you write now and think "wow, that's some shitty code". But you'll learn a ton in the process. Even full time devs look at the stuff they wrote a year ago and think its ugly. That is a sign that you are improving 
Really? Why on earth? 
timing resolution on windows is also atrocious. Also no one who cares about nanoseconds deploys on windows, or programs in python
urllib3 has an entire section called "Security": http://urllib3.readthedocs.org/en/latest/security.html#security which describes its hooks into libraries like certifi, certificate directories, etc. Certainly these features may have bugs at some point? If I installed urllib3 for a client that required certificate validation and we found that those certs were being silently ignored, that's a security breach. A big one that can get you as a contractor in big trouble if you don't take it seriously.
*Very important fact: By default, urllib3 does not verify HTTPS requests.* That is not a bug. But I concede your point. 
Doesn't work with departure locations outside of the US.
python -c 'print (&lt;your celsius value&gt;*9/5)+32' is one simplistic way of starting out.
You probably want to use `9.` instead of `9` on python2 (doesn't matter for python3).
What you have typed there is almost valid Python f=9/5c+32 There are some adjustments, since "9/5c" doesn't mean "multiply 9/5 times c" in Python. So: f=9/5 * c + 32 So, if you set c=100.0, you'll get the expected answer f=212.0. But we can do better. If you were to put c=100, you'd get an incorrect answer because the floating point "9/5" would be truncated to 1. So: c=100 f=9.0/5 * c + 32 print f This gives us the expected answer of 212.0
I believe there is a way although I don't know it on windows (on some linux distros, there are two different binaries python and python2). A better question, I feel, is why keep python 2? If you don't have a good reason for it, then uninstall it and then you don't have to worry about workarounds.
This is fun and all... ...but the proper way to sandbox Python is to do it at the OS or hypervisor level. Run Python as a limited user which only has access to things you want to grant access to. `chroot(2)` may be helpful, but know its limitations and practice defense in depth. If that is insufficient, run Python in a full-blown VM.
Related: ["Why is float() faster than int()?" on SO](http://stackoverflow.com/q/21232733/489590) Interestingly, it's not faster with `pypy`. This was on linux x86_64. + python -m timeit int('500',10) 10000000 loops, best of 3: 0.185 usec per loop + python -m timeit int('500') 1000000 loops, best of 3: 0.434 usec per loop + python -m timeit float('500') 1000000 loops, best of 3: 0.215 usec per loop + python --version Python 2.7.6 + echo \n\n + python3 -m timeit int('500',10) 1000000 loops, best of 3: 0.273 usec per loop + python3 -m timeit int('500') 1000000 loops, best of 3: 0.246 usec per loop + python3 -m timeit float('500') 1000000 loops, best of 3: 0.22 usec per loop + python3 --version Python 3.4.0 + echo \n\n + pypy -m timeit int('500',10) 1000000000 loops, best of 3: 0.00152 usec per loop + pypy -m timeit int('500') 1000000000 loops, best of 3: 0.00153 usec per loop + pypy -m timeit float('500') 10000000 loops, best of 3: 0.132 usec per loop + pypy --version Python 2.7.3 (2.2.1+dfsg-1, Nov 28 2013, 05:13:10) [PyPy 2.2.1 with GCC 4.8.2] + echo \n\n
Disable folder sharing in the VM and disconnect the virtual NIC. 
Because **his** name is Eren, and **his computer** is named Lisa, possibly after the famous Apple machine.
Really? Cause I've noticed that more than half of the replies are all in python 3 and the ones that aren't have comments laying out the python 3 version. And honestly, I maintain that unless you're doing pretty complicated stuff, the differences are easy to catch (especially if you learn to read the documentation). edit: and you could always ask here, in /r/learnpython, or /r/progether 
I enjoyed it.
I used pygame to make a graphical user interface for a non-game application. Depending on how simple I say a python beginner could code a 2-d pygame. Nearly any pitfall you will run into will likely have already been answered on the net some where. Just Google error messages. And nearly any feature you want probably all ready has code examples on the net. I learned from youtube tutorials, and googling. 
No, it will not. "python" will be the last version you installed, AFAIK, and there will be a launcher named "py" which can invoke Python 2 with "py -2" and Python 3 with "py -3".
Cool, ill check out the tutorials and then your code. Thanks for the info!
I completely agree with you. I would definitely ask my boss before writing one up though, unless it was for an interview that didn't get me a job =)
Reading through the code for Python 2.7.6... When you use float() it always assumes base-10 and quickly kicks the call to the (presumably highly optimized) underlying platform's string to float conversion routines. When you use int(), it uses a general-purpose string to int routine that handles all bases from 2 to 36, which involves a general purpose character-to-int function call that handles arbitrary bases. If you explicitly call it with base 10 ( int('500', 10) ) you'll see that it speeds up and has performance similar to float(). I'm not sure why it's faster - I don't see a special case in the source for it but maybe there's some os-specific special case handling in there.
My point was that it could happen since OP was asking why a VM wasn't safe.
It doesn't have to be "in memory". A virtualenv could just have symlinks (or pth) to the particular versions of the packages it is supposed to have. Interestingly we are going this way (kind of) with wheels (but it's more of a cache).
this is the most dangerous attitude which is also revealed in the original post. It's not that there's some technical packaging problem that Requests has to work around for this reason, it's strictly to appease a subset of users who somehow don't want to be bothered working with libraries like everyone else (with the strange irony that Requests itself...*is a library*). No matter how good the packaging tools are, no matter how much work goes into them making this experience simple, it's still too much. Everyone in Python wrings their hands, damn our packaging tools are still not good enough, because some people are skipping them, and some outlier packages are still encouraging it! (make no mistake Requests encourages this, no matter what the developers say, by the simple fact that it is supported) . So if you care to prove my point (which Nick Coghlan disagrees with, and I suppose I'd hope he's right in any case) - is there any point at which packaging and library dependency tools could be good enough that you'd actually use them? Or you will just simply always prefer a fully bundled tar.gz no matter what? Because my position (which I will gladly change! right now!) is that at some point, people who refuse to work with packages like everyone else need to be ostracized, rather than eternally appeased and held up as evidence that the rest of the community has failed them.
What cities are you testing with?
It totally depends on the project. If I'm writing a one off script that needs to do something specific I would rather install the least amount of crap (manually) necessary to get the job done. When I work on production software we typically have a system admin who can be responsible for deployment/patches/etc. so that's a different story. Another minor quibble - it's nice to know that when you update a random module somewhere it won't break something completely unrelated. It's unlikely but possible, packaging everything together helps mitigate that risk. Also - wasn't there a problem with a jpg compression/decompression library a few years back that was made much more serious because so many people packaged it directly with their programs instead of linking to a system library? I don't remember the details exactly, but that would be an example of you being absolutely correct in your stance against vendoring (this is the first time I've seen that term so I don't know if I'm using it corretly). 
It's an enjoyable article, but it contributes literally nothing about Python to this community. The only thing it contains that has anything to do with python is a small (7 line) python script that is completely secondary to the point of the article. If the article were about how the author used python and python libraries as a major component of their efforts, it would make more sense to be reposted here.
I dont understand whey you even consider using python. You better off using C . C is fast and very hardware oriented. I am also an embedded developer we use python for signal integrity test and it is a nightmare. Python is not even strongly typed. then you have to write helper functions just to do type checking. In python most of the errors/bugs you could catch at compile time can only be caught at run time. How would you declare volatile in Python. It is slow. Syntax is confusing. no parenthesis for functions. List goes on and on. I would stick with C if you are working on Embedded systems. Python or any other interpreted languages are only ok for web development. But I would still pick C# or Java for web development. 
I've looked at that but couldn't find a tutorial dumbed down enough for me
https://github.com/RafeKettler/magicmethods/issues if you don't report it I'll do a pull request for you -- good catch!
OK, see [issue #49](https://github.com/RafeKettler/magicmethods/issues/49).
There's really no tutorial necessary. http://pythonhosted.org/PyInstaller/#using-pyinstaller You're just CDing into the directory of your script and running a single command. I've used this tool before and it was as simple as that.
I don't know about a good tutorial for it but a combination of sqlalchemy and the built-in json module works really well. Drop by /r/learnpython or /r/progether (#reddit-progether on freenode works too) if you want specific help.
It seems to be to do with how Python2.7 handles default values for named parameters. Consider: from functools import partial from timeit import timeit print(timeit("int('500')")) print(timeit("int('500',10)")) # specify base explicitly print(timeit("float('500')")) baseten = partial(int, base=10) print(timeit("baseten('500')", "from __main__ import baseten")) For which 2.7 reports: 0.299404144287 0.130570888519 0.111737012863 0.21283698082 where supplying the base= explicitly makes the code run three times faster - about as fast as the float. Even with the overhead of the partial function it still runs quicker than with the base implicit. But for 3.4: 0.15437157500127796 0.16261526999733178 0.14534877900587162 0.5046625770046376 The default parameter now isn't a major effect (and the partial function is just overhead). I think this is mostly noticeable in this example because the native implementation of int() itself is so fast that the overhead of checking the parameters and filling in the blank is actually significant. **edit** yeah, I should have read the whole thread :)
no problem. Anything to promote some good subs.
&gt;Python really doesn't touch the rest of your operating system. Not always true, I once broke the UI in Linux Mint MATE by changing python path.
You won't find what you're looking for. Py to exe programs bundle a little python install with the exe of your script so you will always need the additional files in the directory. 
That's a serious bummer :/
I know, that's the biggest bummer of scripting languages, you know; I don't really know where's the problem with compiling to an exe, at some point your code is going to become binary either way.
Redis *and* ElasticSearch. So trendy. 
What happened at the end of 2013 to gain so many subs?
There are some pretty good arguments *against* using it here: http://pythonrants.wordpress.com/2013/12/06/why-i-hate-virtualenv-and-pip/ 
I'd actually say that Docker presents a pretty good alternative.
But this post isn't about the PROPER way of doing a sandbox. The competitions show what NOT to do and challenge the teams to break it when it's set up wrong.
It's easier to share 1 file with non computer-savvy people 
Your problem is that you're storing the numbers as strings not ints. A string is a text format. You obviously can't square the word 'four' and neither can you square the symbol for four (not the number, the symbol). You need to save the numbers as numbers and then use the squared operator (**) on each of them. 
I run a little script to adjust the path. Here is my +py34.bat file: @echo off set PYTHON_HOME=C:\Python34\ PATH %PYTHON_HOME%;%PYTHON_HOME%\Scripts;%PATH% python -V I start a command window, run this, or a similar script for the python version I want to use, and away I go. If I open another command windows, I can run a different version of python there depending on which batch script I use to set the path. I keep these scripts in a directory in my (customized) windows path. There are lots more environment variables you can set. If you want to, you can even setup to run both 32 and 64 bit versions with this scheme. Python versions 2.7+ and 3.3+ now include the Python launcher. Enter "py" for latest 2.x or "py -3" for latest 3.x installed on your machine. Search python documentation on disk or online for "Python Launcher", or enter "py --help" in a command window.
My guess is that python is starting to get used a lot more in the EARLY curriculum for computer science majors at four year universities in the US. I think they do this because java and c++ syntax tends to scare people away from the major in general. So a few courses of python probably led them here at some point or another for reference or help. Purely guessing though.
It's too late to be codecademy. Not really sure.
Was not expecting Javascript.
&gt; Python 4 will get rid of the GIL That makes no sense; it's not Python that has a GIL but its canonical implementation. Python guaranteeing no GIL would be stupid (although *CPython* guaranteeing no GIL might make sense).
All talks are now up on YouTube https://www.youtube.com/playlist?list=PLBGl1tVyiWQSVwxne3yOH79uaSqgbnCqL . Matching slides are available at : http://kiwi.pycon.org/kiwipycon/wellington-2014/ 
The matching slides are visible at : http://kiwi.pycon.org/kiwipycon/wellington-2014/ . 
I feel there are only two legitimate reasons for doing this: avoiding namespace conflicts, and mental clarity. If you have a good IDE it shouldn't make a difference in terms of navigating the code, but that should be a minor consideration. In general, if you do something different and find yourself saying, "that's *way* better" then it was the right decision.
I wonder what the python static typing he mentioned would be like.
Awesome, I've been busy and forgotten about this. Thanks!
I run timing benchmarks all the time in my research. I can confirm this. Timing resolution on Windows only sucks if you measure cpu time (process time). Typically the resolution is 64hz, or 15.6ms. But the high performance counter (wall clock time) is good well below milliseconds. Now there could still be random variations due to things like process scheduling, but that shouldn't matter much past tens of milliseconds. Op should rerun many times to see how stable the measurements are, and if necessary, increase the number of repetitions beyond one million.
Has no one in this comment chain heard of virtual machines?
Maybe because HE IS COMPUTER????
 def foo(a: int, b: int) -&gt; str: return "%d + %d" % (a, b) http://www.mypy-lang.org/
I'm gonna assume you mean try asking... Well, I need to design an experiment that works like this Participant views/"studies" 20 images, from a folder of about 360 images. The images are selected at random from the folder. Next, the participant is tested on 60 images (Have you seen this image before? test), 20 of which are from the study phase. The 60 need to be in a random order and include the 20 from the study phase. I need to know how to tell open sesame to go to a folder, pick out 20 random images (random for every single participant) and then use those same 20 in a test of 60, and make that 60 list random... This is confusing.
One of my lab partners tried the forum and they gave a good response BUT we're running into problems with the code they gave us.
He's such an easy guy to like. 
why did he quit Google ?
oh great, it's back in active maintenance, good to know that
OK...better...Python 4 by using CPython as the reference implementation will define libraries for clearly and efficiently implementing GIL-less Python. PyPy supports some Python 3 features, but not all. It was a joke anyways. What's another huge potential change to Python?
In that picture where he's explaining Python 3, it says print was changed to a function and that he would explain why. Can anyone explain why to me? I don't understand that.
I wrote some grid manipulation code that was dog slow using floats (for the locations) and ints for the connectivity. So I decided to switch everything to strings since I didn't really need to change types. I sped it up from 4+ hours to 20 minutes. Had I used numpy, I probably could have made it even faster. For 8 million numbers, you shouldn't be using Python's ints.
Consistency? It doesn't really make sense that it should be a statement. It's also more useful as you can now pass it as a variable to functions like map.
Is that really the reason? I guess that makes sense. I always forget about map, I usually just use list comprehensions for that, and feeling all pythonic when I do so :p
This is probably true. I just started programming classes and we are using python and wing 101. I love the damn thing so far!
Erm... If Guido's attempts to get optional static typing into the standard library succeed, I wouldn't be too surprised if Python made syntactic changes to make it look nicer. That's about the biggest thing I can think of.
Is this a joke post? It has to be a joke post...
All I want is logging to a file...a feature that seems completely missed from the feature set.
Why do you think that, /u/LightShadow ?
I definitely think it's *way* better! If you know the name of a function then it's easy to find in either a single or all files, BUT if you don't having the sep files makes it waaay easier to browse (I know it's about X so it must be some function in file X). And e.g. help(pep8radius.shell) becomes useful/useable.
Ah, I didn't mean that I use print in a list comprehension, I just meant that I tend to use it instead of map because I forget about map. Thanks for the tip about function calls being better than statements, I'm currently trying to learn about core computer functionality on a deeper level to make things like that more intuitive. I completely agree on your last point. Thanks for the write up.
When print is a function, you can override or replace it like any Python function: &gt;&gt;&gt; def print(s): import sys; sys.stdout.write('&lt;'+s+'&gt;\n') ... &gt;&gt;&gt; print("hello print world") &lt;hello print world&gt; By changing the function definition, you can redirect output to a logging system, or wrap it in markup, or translate it. When print was a statement, you were limited to the built-in functionality.
Not usual request, I would say, but I hope You know what You are doing. Here is good answer http://stackoverflow.com/a/15702647/2681666 ctypes should help You
I guess that's useful, but in my experience I'd rather have an extra reserved word than be hindered by the use of previously unneeded parens. Why would I want to replace a function that's useful in any namespace, especially in a language that most people use primarily for simple scripting, prototyping, or just hacking at something? I mean, I'm just bitching at this point and I get it, I just don't agree that it's more useful as a function for that reason.
Because he prefer programming over managing. No?
Every stuff I saw on docker is aobout having root privilleges in the container, which sucks a lot. How do you fix that?
i can't imagine a scenario where you will want to use `assert` with `map()`.
But you can with print?
&gt; most people use primarily for simple scripting, prototyping, or just hacking at &gt;something? Given its major status in science, data analysis, finance and web development, I'd say that most people use it for more than simple scripting or just hacking. After all, DARPA didn't give Continuum Analytics $3 million dollars to continue to develop Numba, etc. for nothing. 
I agree. And everything else could be solved by having the print statement always just calls print_function. So you can do: map(print_function, ....) And print_function.set(my_function) And print "Hello World!" Sure, the second example is a *little* unidiomatic, but it's such a rare thing to do anyway.
Because I'm a member of both, I found this interesting: http://redditmetrics.com/r/Python#compare=kerbalspaceprogram
Notice I used the word "primarily" instead of "just". Obviously it's an extremely useful language and it's by far my favorite, I use it in my job more than any other [edit: except maybe javascript] (usually version 2.7 so the veterans can adjust my code as needed without headache) but when the optimization is given to the user instead of the computer (I believe this is a core tenant of Python), I don't understand why they would make that syntactical change.
But I doubt you'd actually see a 2.4 second difference. It's very rare that you can extrapolate from microbenchmark like this one by just multiplying by the problem size. I encourage the OP to try their program both ways and report the total running time. I have a feeling the difference will be unmeasurable. 
What about local vars? 
yep, this is especially true in linux systems where binaries rely on /usr/bin/python which can either be python 2 or 3. It's why a lot of distros have to custom bind binaries to /usr/bin/python2 (oversimplification)
http://www.mypy-lang.org/examples.html Instead of: d ={} s = "" v = None v = 5 You would use: d = Dict[str, int]() s = Undefined(str) # say that s is a str s = "" v = Optional[int] # for None or int v = None v = 5 In a lot of chases you wouldn't need to actually write that, as the type is derived from the value you assign, i.e. `v = 5` would automatically tag `v` as `int` and give an error assigning anything else.
Yup just arrived. Looks like it's going to be a good one :) 
It's also untrue - you can easily make single-file exes.
So basically, it's close to the auto behavior in C++.
Not always. But I am not sure about it.
Unless you're interfering with the compilation process (eg. via a custom codec), `b = 3` can *only* produce an `int` (not an instance of an int subclass, but an instance of `int`). Since you have already stated `a` is an `int`, the only circumstance in which the return value may not be an `int` is if `a` is an int subclass whose `__add__` method doesn't return instances of int nor instances of its own subclass. "Not always" is a valid criticism -- semantics become ambiguous whenever operators get involved, in Python -- but you didn't pick a realistic example.
You are right. Post release party hangover. I remove my statement.
&gt; Also, the auxilliary features of print, (file, end, sep), are much more naturally handled as function keyword parameters rather than the way the print statement did these things Not to mention that now `print` is a function, you can use `functools.partial` on it: import functools rprint = functools.partial(print, end='\r') tprint = functools.partial(print, sep='\t') iprint = functools.partial(print, flush=True) info = functools.partial(print, stream=sys.stderr, flush=True) 
&gt; I don't understand why they would make that syntactical change. $ python Python 3.4.1 (default, May 19 2014, 17:23:49) [GCC 4.9.0 20140507 (prerelease)] on linux Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; # All relevant principles italicized. &gt;&gt;&gt; import this The Zen of Python, by Tim Peters * *Beautiful is better than ugly.* * *Explicit is better than implicit.* * *Simple is better than complex.* * Complex is better than complicated. * Flat is better than nested. * Sparse is better than dense. * *Readability counts.* * *Special cases aren't special enough to break the rules.* * Although practicality beats purity. * Errors should never pass silently. * Unless explicitly silenced. * In the face of ambiguity, refuse the temptation to guess. * There should be one-- and preferably only one --obvious way to do it. * Although that way may not be obvious at first unless you're Dutch. * Now is better than never. * Although never is often better than *right* now. * *If the implementation is hard to explain, it's a bad idea.* * *If the implementation is easy to explain, it may be a good idea.* * Namespaces are one honking great idea -- let's do more of those! IOW it was less explicit, more complex, less readable, more ugly, a special case (keyword) when there was no real justification for it, and harder to explain. 
&gt; In the past, I was thrown into such a role for a small team, and it never really worked out. I never really felt comfortable in that type of role. I was always much more comfortable just writing code. Hear hear. In parts of our industry, it's hard to make people around you understand that it's a great career choice and you aren't a looser for going that path.
Did he? I wasn't aware of this, do you have any specific details?
You could also [ask](https://groups.google.com/forum/#!forum/pypa-dev) the PyPA guys about a metadata field for the docs url. That would make the lack of moderation on RTD less of a problem.
&gt; There doesn't seem to be a correlation between Python packages listed at pypi.python.org and readthedocs.org project names There isn't. I tried to put some docs for a PyPI project on RtD the other day, but the name was already taken. If you want a .docset for a Sphinx-documented package, then why don't you write a Sphinx backend that generates docs in that format instead of trying to parse HTML files that are meant to be read, not parsed? 
how did you get this stacktrace ?
with windbg. step-by-step: 1. grab the [pdb](http://en.wikipedia.org/wiki/Program_database) files for your python version at https://www.python.org/ftp/python/ python-x.x.x-pdb.zip for 32 bits python-x.x.x.amd64-pdb.zip for 64 bits 2. extract the pdb files 3. open windbg, press ctrl+s to add the path to the pdb files 4. press ctrl+e to open python.exe (Note that windgb automatically pause the program) 5. in the windbg's command window, set the breakpoints with *bp python27!PyOS_strtoul* *bp python27!_Py_dg_strtod* 6. press f5 to continue/resume the execution of the program (or type the command *g*) 7. now the python repl should be running, just type int("500") or float("500") to trigger the breakpoints 8. in the windbg's command window, type the command *k* to print the callstack (or *kp* to also print the passed arguments) 
Wow, if that's true then shame on you Google.
Yes but the original post doesn't compare int('xxx', 0) with float('xxx') it does compare int('xxx') with float('xxx') and in this case both are treated as base 10 
And also udacity and Coursera's courses started getting a lot attention 
You can use a plugin: [Logcapture](http://nose.readthedocs.org/en/latest/plugins/logcapture.html)
yeah, sorry about that, I was trying out something...
&gt;For this particular datastores feature, I’ve done most of the work independently, with two other people contributing, mainly in the form of code reviews. It must feel pretty awkward to be a Python developer doing a review of Guido's code. I'm sure Guido's a nice guy about it, but I'm not sure I could tell him to his face "yeah you fucked this up" or "this doesn't conform to our internal style guide".
This is likely because PyPy JIT compiles them both to the same or similar machine code.
i would use os.walk() to create a list of all the files. Then shuffle the list of file names with random.shuffle(). Take the first 60 images in this shuffled list and that will be your set for participant x. The first 20 images in your list for participant x will be the memory set. Show participants these first 20 images. Then when they're done, shuffle the 60 images for participant x again and present all 60 images. I don't have the time to write out the actual code now, but maybe i could help more this weekend if this doesn't make sense. 
Is there someone who is interested in discussing Python problems with me? After two months I've learned most of the basics (done the codecademy-"lecture", looked at some of the official docs and listened to some YT stuff). Now I'm doing The Python Challenge and I would like some pointers from maybe someone a littlebit more experienced :)
My Air is named "Gulliver" (because it goes everywhere with me), and my Pro is named "Lysander" (after Lysander Spooner). I don't think it ever occurred to me to name a device after myself. Oh, and my Android phablet is named "Agun". That way I can say I always have Agun in my pocket.
Would it be possible to have version constraints prevent upgrading? Eg, pkg1 depends on pkg2&lt;2.0,&gt;=1.4 - so, could pip raise/abort if upgrading pkg2 would break that constraint from pkg1, like most system package mangers?
I remember Guido tentatively picking one of the options. I can't remember which it was. It might have been mypy.
&gt; otherwise -&gt; yes
Do something like this import random //Why are you setting side_1 = 1 side 2 = 2 .. Dice_Sides = (side_1,,...) etc and not just a range 6? Much easier to work with roll = 0 //initialize it to enter the while while(roll != 6): roll = random.randint(1,6) //Get a random integer from 1-6 print("You rolled a %d" %roll) //im not sure about this syntax, I always just str concat. roll_again = raw_input("Roll again?) if(roll_again == 'n'): if(roll == 6): print("You win") else: print("You lose") roll = 6 //just set the roll to break out of the while loop 
Man, I would love for Python to be a first-class citizen on a mobile device. I mean, Java and Objective-C aren't that hard, but they sort of slow you down if you're in a sort of rapid-prototyping mindset.
With the "with" block, the "else" block is only executed once - when all the looping is complete. In your code, the looping only completes once the you answer no. In other words, "while roll_again == "yes" or roll_again == "y"" gets evaluated every single time through the loop, the "else" stuff only gets run at the end. We can re-work your code, like this: import random side_1 = 1 side_2 = 2 side_3 = 3 side_4 = 4 side_5 = 5 side_6 = 6 Dice_Sides = (side_1, side_2, side_3, side_4, side_5, side_6) roll_again = "yes" while roll_again == "yes" or roll_again == "y": roll = random.choice (Dice_Sides) if roll == side_6: roll_again = "no" print "you win" else: print "you rolled a %d" % roll roll_again = raw_input("Roll the dice again?") If I were to re-write it a little cleaner\succinter, I'd do: import random playing = True while playing: roll = random.randint(1, 6) if roll == 6: playing = False print "You rolled a %d and won!" % roll else: playing = raw_input("You rolled a %d. Roll again? [y/n]" % roll) == "y" 
You probably know this, but my 2 cents is that any engineer worth their salt can check their ego at the door and discuss a piece of work rationally; whether or not it's theirs. It's not a big deal to point at a piece of code and point out that it broke a bunch of regression tests, for example, and then discuss how do we fix it. Folks like Guido don't get where they are by being defensive egotists. Conversely, your own tone in such a conversation shouldn't be "you fucked up" or the like. Just discuss the piece of code in question like it's an amusing and errant child, and you're good to go. This is especially useful if you happen to be wrong, then all the in your face attitude doesn't have get in your face instead. Don't make it personal. Ever. 
You know what's funny is that I don't use assert on its own often enough (always use the methods inside `unittest.TestCase)`, but when I do go to use a plain `assert`, I always try to call it as a function before I am reminded.
To be fair, I would prefer C#'s ``var`` or Scalas ``var`` - as they exist much longer than C++'s ``auto`` which came with C++11 - and became feature equivalent to the mentioned just with C++14... But never the less, there are a lot of languages with **type inference** these days - of course static typed languages need to adopt closer to dynamically, as those became gain more and more attention...
You asked about non-string literals and a string with a base specified, those are not different than what the OP was talking about as well.
Yeah and I've added the key to the Python file and changed the default from/to (lines 27 and 28) to 'LHR' and 'WLG'. When I run the program with python flightfinder.py --start=10/20/2014 --end=12/01/2014 I get 'No results found'.
Do you get flights on the hotwire.com site for those particulars?
/r/learnpython is good, and this sub is also a reasonable place to ask any specific question about a particular problem or concept. The more specific and well-researched you are when coming here, the better you will be received in this subreddit.
https://mail.python.org/pipermail/python-ideas/2014-August/028742.html Your right he hinted his preference to mypy
Hey! I'll be presenting too! Let's meet up! 
I used [Beginning Python: From Novice to Professional](http://www.amazon.com/Beginning-Python-From-Novice-Professional/dp/159059519X). Great book! Includes some projects as well.
It seems silly to choose a language based on the personalities of the people involved with it, but I find myself doing just that. And, y'know, those people shape the interactions you have with people in the community, as well as just leaking into the product itself somehow.
Because you're not doing anything...really. A better blog post/submission would be to track multiple airline sites over time to "really" determine when airfares are cheapest. This is essentially a boiler-plate wrapper around a single line of code. You could literally reduce the whole script to 2-3 lines; which I think would be more impressive still.
Log to a file without writing my own logging statements. Essentially stdout/stderr =&gt; custom file broken by test precision. example: -L all stdout goes into 1 file for the executed tests -LL all stdout goes into files broken down by the middle most level (usually classes) -LLL all stdout goes to individual files for each test-name
&gt; When you use int(), it uses a general-purpose string to int routine that handles all bases from 2 to 36, which involves a general purpose character-to-int function call that handles arbitrary bases. When you use int(),it assumes base-10 unless you passed the second parameter. so unless you pass the second parameter int's speed is supposed to be faster than float
Is there a reason you feel you need to use 2.x? The general consensus is that you should use 3.x when starting a new project unless you absolutely have to use a library that hasn't been migrated yet. As an absolute beginner, it is unlikely that you fall into the exception category.
I love this one http://learnpythonthehardway.org/. I'm not sure if it's suited for new programmers, but take a look and try. You should read it sooner or later anyways. Good luck!
So here's my test, which is significantly different to yours. In my test, `int()` performs no worse than `float()` All test done with IPython 2.2.0 %timeit magic and a clean virtualenv: Python 3.4.0: tie In [1]: %timeit float("500") 10000000 loops, best of 3: 156 ns per loop In [2]: %timeit int("500") 10000000 loops, best of 3: 154 ns per loop Python 2.7.3: int() significantly faster In [1]: %timeit float("500") 10000000 loops, best of 3: 122 ns per loop In [2]: %timeit int("500") 100000000 loops, best of 3: 12.9 ns per loop Out of curious, I also tested PyPy2.2.1 (implement CPython 2.7.3) In [1]: %timeit float("500") 10000000 loops, best of 3: 115 ns per loop In [2]: %timeit int("500") 100000000 loops, best of 3: 11.6 ns per loop
Perhaps he runs OS X and wants to write a plugin/workflow he hopes to share with other users. Why do all Py3 converts automatically assume that someone wanting to use Py2 is mistaken? He asked for Py2, so why not answer his question instead of (or perhaps in addition to) questioning his motives? 
I wouldn't mind if I mop floors at Google...
I'll try this in a bit (maybe tonight or tomorrow?) and let you know if this works. As far as just manually entering code in OpenSesame, where would you put the os.walk() and random.shuffle(), etc. I guess I can play around with it...I know there's a place where you can edit the code of a particular section but I'm not sure which section to put that in.
Wow, your int() call is extremely fast! I wonder why? 
This may exist in the stdlib but I usually define a helper function as such: def drain(*iterables): for iterable in iterables: for item in iterable: pass It's a very dumb function on its own and always makes me frown to look at its definition, but it can be useful if you're writing generator-heavy code which is increasingly common (and powerful) in modern Python. Anyone know of a cleaner way of doing the same thing?
Yea, Google lists [no nonstops](https://www.google.com/flights/#search;f=LHR;t=WLG;q=LHR+WLG;d=2014-10-05;r=2014-10-09) between London and Wellington.
I think you'd be surprised, I've met a lot of people who work there and the general consensus is that outside of a few really 'cool' projects, it's not that great of an environment to work in any more. There's perks, but there's also vast halls of the "best and brightest" working on aligning pixels on mail.google.com
You could do that already by replacing sys.stdout and sys.stdin. 
I'd suggest you think deeper about that.
I started my post with a question. If he has a specific reason, then starting with 2.x is fine. You pointed out a valid example of a reason. My point is that he is a self-described "absolute beginner". If that is the case, it is possible that he doesn't understand what the real differences are between the two versions. Or why you would use one instead of the other. His decision could be based off hearing that many people are still using 2.x and that "some things" don't work with 3.0+. 3.0+ is the direction the language is going. It is more likely that he will eventually use a 3.0+ than needing 2.x in the future (assuming he doesn't have a reason now).
&gt; think deeper to the food court mmmmm.....
What topic are you presenting?
Figures as soon as you ask you find the answer. They are called "Modules"
virtualenvwrapper works fine for me under ZSH.
I highly recommend [Hello World!: Computer Programming for Kids and Other Beginners.](http://www.amazon.com/Hello-World-Computer-Programming-Beginners/dp/1617290920/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1411156281&amp;sr=1-2&amp;keywords=python+for+kids) I started my son at 6 years old with it and he was off and running within 2 days. 
I need to say THANK YOU for this suggestion. It is going to make my life 10x easier than using xlrd/xlwt
I know obviously a developer as good as Guido wouldn't be egotistical about code reviews, but I'd still be a little awe struck doing a review of his code. Also, I did not mean literally saying "you fucked this up". But some people might feel reserved even saying "you made a mistake here" to the creator of the language they're critiquing their code in.
No, 1 is. 1**1=1 =P
Just curious, why would you want to do this from within python, not from a C extension?
Yeah, I'd be nervous too. :) 
&gt; build a genuine relationship Did you try #tinder In all seriousness I have/am apart of a few irc communities that I would call friends. Irc is a great forum to share ideas/get help with problems. But just writing. code and developing and just being in the channels is where it starts. Even if you don't say anything. Can't hurt. 
But Google really wouldn't allow him to become an engineer rather than leave?
But don't you now risk introducing unexpected behavior by just brute-force changing the definition of print() across the board? It seems like if your issue is that you can't change all the call sites by hand, you also can't check that this won't affect places it shouldn't. Also I'm really just trying to learn, not heckle, I've never considered doing something like this before. 
lots and lots of dudes...
What level will the interview be at? Proficient or expert (or both I suppose)? Do you know if it'll be focused specifically on 2 or 3?
From a couple of months ago: http://www.reddit.com/r/Python/comments/2b4ytx/python_interview_questions/
https://docs.python.org No, really. They are authoritative, to the point, and have lots of examples. For typical interview questions, you can just google that yourself. It will probably be like most other interviews unless you have a reason to believe they have a different process. I've been to 30-40 interviews and I'd say that only 4 or 5 tops didn't exactly fit the typical format discussed online. Fibonacci, how does the web work, model this data, and all that stuff pops up every time.
I don't even c extensions. 
Function calls are more flexible than statements because by definition you can use a function call anywhere you would use a statement in Python. Function calls *are* a kind of statement. Whereas there are many places that you can use a function that you can't use a statement.
How about [here](https://www.reddit.com/r/Python/search?q=python+interview+questions&amp;restrict_sr=on&amp;sort=relevance&amp;t=all), [here](http://news.dice.com/2014/04/30/interview-questions-pythondjango-developers), and _definitely_ [here](http://lmgtfy.com/?q=python+interview+questions).
Can you code in C++ or Java? I wouldn't hire a programmer that couldn't code in a "real" language. If s/he was an engineer (e.g. me) that could code in Python, now that's just gravy. Don't forget what your proficiency is in and what you're expected to know. I learned Python decently enough in 3 weeks without really trying too hard coming in cold to programming. Threads/GUIs/multipprocessing isn't really that hard once you've done it a bit. I haven't done much networking, but I can't imagine it's that hard (assuming things don't cut out). During one interview I did, I teased a programmer about not putting down that he knows Windows/Word/Excel/Powerpoint. He flat out said he didn't. He knew Linux instead. That got him bonus points because anybody can learn Windows. Having somebody that knew Linux was a big plus. Also, I'd learn how to use SWIG if you don't know already. I wouldn't bother learning Python 3 if you don't know it.
I should have gone straight to the source to start with, here's the PEP (Python enhancement proposal): http://legacy.python.org/dev/peps/pep-3105/ Here are the relevant points: &gt; * print is the only application-level functionality that has a statement dedicated to it. Within Python's world, syntax is generally used as a last resort, when something can't be done without help from the compiler. Print doesn't qualify for such an exception. &gt; * At some point in application development one quite often feels the need to replace print output by something more sophisticated, like logging calls or calls into some other I/O library. With a print() function, this is a straightforward string replacement, today it is a mess adding all those parentheses and possibly converting &gt;&gt;stream style syntax. &gt; * Having special syntax for print puts up a much larger barrier for evolution, e.g. a hypothetical new printf() function is not too far fetched when it will coexist with a print() function. &gt; * There's no easy way to convert print statements into another call if one needs a different separator, not spaces, or none at all. Also, there's no easy way at all to conveniently print objects with some other separator than a space. &gt; * If print() is a function, it would be much easier to replace it within one module (just def print(*args):...) or even throughout a program (e.g. by putting a different function in __builtin__.print). As it is, one can do this by writing a class with a write() method and assigning that to sys.stdout -- that's not bad, but definitely a much larger conceptual leap, and it works at a different level than print. 
Oh, certainly. I once implemented a simple logger as: def __init__(self, ..., verbose=True): self.debug_print = print if verbose else lambda x: None
I am not doing realtime systems in Python, so why bother to implement something in C when speed and resources are not critical? Are you saying there is no practical use for Python on some of these micro that have plenty of power to run these sorts of applications? Of course when I want to deal with hardware I use C, but for this, the application code is much more important. Just because it is a nightmare for you to maintain and test Python doesn't mean it has to be. I have had minimal issues setting up many systems with both Python and C, they just have very different work flows you need to learn. I was skeptical of using Python for certain applications in embedded systems, but was very surprised by how reliable the resource usage was running over months on end. Just because it doesn't work for you, doesn't mean it's wrong.
based on the attitude you've expressed in this post I can tell you that you'd fail any interview I was conducting. 
On github (just pushed a new version, lots of refactoring) https://github.com/hayd/pep8radius
True. And I have used that technique to, for instance, provide my own console window for GUI programs. The drawback with this technique is that you are processing the output byte stream after all formatting and encoding has occurred. It is easy to redirect that stream to another destination; not so easy to manipulate the content of that stream. A very simple and complete print function replacement might look like this. def print(*values, **kws): import sys real_print(kws.get('sep', ' ').join( [str(value) for value in values] ) + kws.get('end', '\n'), sep='', end='', file=kws.get('file', sys.stdout), flush=kws.get('flush', False) ) To truly benefit from this capability, you could change how you process the values passed as positional arguments. You could change the function you use to convert objects to strings by calling a different method than __str__() calls. Or, you could provide a smart method for folding long ouput lines. Edit for PEP8 formatting
Probably a lot like the function annotations introduced in Python 3. http://legacy.python.org/dev/peps/pep-3107/
Yes, It not only keeps your dependencies separate from the OS's, but it keeps your dependencies separate from your other dependencies. It's also included in the standard lib with Python 3.3 =&lt;. `python3 -m venv path/to/my/venv`
I was honestly trying to be helpful.
I won't pretend that vendored software isn't a security tradeoff. But running bleeding-edge software is also a security tradeoff (not to mention an operational one, should that bleeding-edge version be incompatible in some way). Who's to say that a later version doesn't introduce other security problems? Are you well-versed enough to dive into every changeset of every dependency and definitively declare one way or the other? 
&gt; I wouldn't hire a programmer that couldn't code in a "real" language. &gt; Having somebody that knew Linux was a big plus. Too lazy to write the snarky remark, but something something pot and kettle, something something no true scotsman.
No feed the troll plz
This is a rewrite of original hand-written parser. It uses simple but great Python grammar parsing library Grako – https://pypi.python.org/pypi/grako/3.4.1
i would just put an inline script at the beginning of the experiment. 
Yeah, that would be a nice addition. 
I think you have a typo in the README -- shouldn't "**Binary** logical operators: `and`, `or`" be "**Boolean** logical operators..."?
Don't try to "cram." Just write code. When I interview someone, I'm not looking for gotchas, or to make sure they have encyclopedic knowledge of the knowledge. Instead, I'm looking for someone who can think through a problem, figure out how to solve it, and then do so. I'm looking for someone who's reasonably careful, doesn't make a lot of basic obvious mistakes. If you can write code that solves problems, and doesn't make a whole bunch of obvious mistakes, then you should be able to do fine. I don't know how your interviewer is going to do it, but when I do an interview, I let people use Google, any docs that they want, and so on. I don't really care if you've memorized every last API detail, as long as you know where to look when you don't know some detail.
It really is, a fantastic IDE :)
It'll not be web based stuff. Mostly backend for version 2
thanks
I agree. Maybe "cram" is a wrong word - I was referring to tutorials that are condensed. I already know the language but the latest Python book is too versbose and detailed - I just want a compact tutorial which assumes that the read knows the languages and goes at a fast pace covering everything without going into too much details.
That syntax is ugly =/
Wow, that does look cool. I've only every used Eclipse+PyDev.. am going to definitely check it out.
https://pip.readthedocs.org/en/latest/user_guide.html#requirements-files This is a valid pip requirements file: pkg1 pkg2 pkg3&gt;=1.0,&lt;=2.0 [EDIT] Create a virtualenv, pip install, run adequate tests 
In the world I come from, to try out a Beta (no alpha) release of the IDE/language you have to sign an NDA and those who own the previous version are given "priority" - apparently it's a privilege. Even the day of release of the product is a secret - apparently even to those in the company, since there have been instances of a "preview webinar" ending up being scheduled for after the product's released. It's so refreshing that JetBrains is a company that doesn't live in the world of the early 90s, big iron and NDAs and actually involves their customers in the design and testing of their product. They also appear to actively engage their customers, another thing I've seen lacking in commercial dev tool vendors.
I solved with the steps in this link: http://bbruno5.blogspot.com/2014/09/fixing-problem-ioerror-errno-2-in-pgs4a.html I hope that helps you.
Your file is identical to the original yet. Modify the file is not advisable, because other files can use the same way. So is better download manually the new files rename to the same names searched by file and put in the respectives directories.
#python has been my programming buddy since I started on Python LOL
PyCharm really is a charming IDE.
Honestly I think I like your answer the best! I wish I understood it better, but ... meh 
Your are absolutely right. To enable returning a value for an actual '*' key one could do: if key == '*' and '*' not in self: anyways... its a quite ugly hack :)
Some people who are learning python don't know what a CLI is .. terminal, bash, $, sudo all those things are foreign to them as they were once to me. 
AssKick.py – Python script to search and download torrents from KickAss Direct link to Github: https://github.com/pantuts/asskick
Try it! I really hate Eclipse+pydev but pycharm is awesome. Made me stop using gvim for python coding. 
&gt; model this data ELi15 please?
Start a blog and setup a git account.
Few interesting channels on irc.freenode.net, YMMV: * `#python` - it's for helping people solve newbie problems; it's very active, so offtopic discussion is discouraged * `#python-offtopic` * `##python-friendly` * `#positivepython`
It appears you misunderstood my question. It was about preventing upgrades (raise conflict error) when upgrading something would break something that's already installed (and depends on lower version). It has nothing to do with requirement files, virtualenvs or tests at all, it's purely a question about what pip could/should do ...
and everything depending on python3 will break. ugh.
Wow that's really exciting about the increased BDD support, this is going to clean up my workflow quite a bit
PyCharm is an idea that often surprises me during usage. I then go and say "what? I cant believe it knows about this and suggests it to me, this is like writing Java".
use random.sample, e.g.: numbers = range(1, 50) lists = [random.sample(numbers, 6) for i in range(1000000)]
Hmmm... Python has an interpreter for these expressions -- eval. And you can use ast to get the associated tree. What does this add?
Couple of things I don't like. I can't tell if a file has been modified. It appears to auto save every time an edit is made. Second one is the following: Ctrl-z is undo, Ctrl-shift-z is redo. But in most editors redo is Ctrl-y. In Pycharm Ctrl-y deletes a line. This means that if you undo-redo as you are used to, go are going to severely mess up your script and changes will be unrecoverable....
what about using a hash?
He's right that the IDE default settings should be something familiar. Don't have a computer in front of me, but are those shortcuts really not the default?
a fast one
I'm on OSX and these are the few other I can see for Redo: * TextEdit (default OSX editor): cmd-shift-Z * TextWrangler: cmd-shift-z * jEdit: cmd-E cmd-Z * MS Word: cmd-Y
Not just real VC -- every file has an implicit commit in the "local history". Select Local History from the appropriate menu and you'll see every grouped change as its own "revision", and can view a diff of each one. I'm not sure far it goes back, but Pycharm seems to be saving it together with some project data, as I can see changes to my TODO file 15 days back.
I assume you've seen Peter Norvig's solution: http://norvig.com/sudoku.html 
Settings.Editor.Editor.Editor Tabs-&gt;Mark modified tabs with asterisk. I haven't found that I need this though, as the editor auto-saves often enough that I guess I've just been assuming my file was saved. As for the keymap settings - there's 10 included schemes, maybe one of the others would be better? They have ones to match Visual Studio, Mac OS X, emacs, eclipse, etc. You could also just disable the binding for CTRL-Y - I've actually had to disable it myself in the past as I had CTRL-K-Y in muscle memory as my 'format code' keystroke from SQL Prompt. I've gotten used to the IntelliJ keystrokes now though.
I would be interested to see how you're generating the numbers and it's so slow. I tried writing a naïve script to do this and it took 0m18.607s import random with open("numbers", "w") as numbers: for line in range(1000000): generated = [] for _ in range(6): generated.append(random.randint(1, 49)) generated = map(str, generated) numbers.write(" ".join(generated) + "\n") A fastest I can manage (taking a hint from /u/diesch) is: import random NUMBERS = range(1, 50) def format_line(numbers): return " ".join(map(str, numbers)) + "\n" def generate_numbers(): for x in xrange(1000000): yield format_line(random.sample(NUMBERS, 6)) with open("numbers", "w") as numbers: numbers.writelines(generate_numbers()) which shaves off another ten seconds. I think you have a more serious problem than how you're generating the random numbers.
The questions are often in the form of: * Let's pretend we're opening an online music store. Using the whiteboard, show me what the DB schema would look like for storing the inventory. * What would the queries look like for displaying search results and the songs a given user owns? * Now that we're happy with that, let's add rentals next (48-hour 'checkout' period vs. owning it forever) * Say we want to have a "what's hot" section on the landing page. How do we change the schema and what are the queries like? Can we pre-populate this data given what we already know? * Let's pretend the service becomes really popular and now we have millions of users. How do we keep performance snappy in the persistence tier?
I agree pycharm is great. It made me cease using vim and some other plugins. It is really great, espeically if you frequently work on larger python programs. Additionally, there is a VI-key bindings plugin that I use. It works rather well, although the name escape me at the moment. EDIT: I should clarify. I still use VIM quite a bit, but when I am working with larger python projects pycharm is the way to go. 
Not sure if it's the way to do it on Linux, but get Pip (they provide a .py to run) and then use 'pip install [module]' on the command line.
Indeed I've never seen any solution before. This looks interesting, I am reading it now.
just use the package manager. sudo apt-get install python-mechanize or search for "python mechanize" in synaptic.
Thanks for the suggestions.It's good to know that I can customize, otherwise it gets difficult to use different editors. I've been using Sublime lately and the transition to PyCharm has been a little hard. But I appreciate the degree of customization available. 
wow nice! Thank you very much for elaborating... are there any blogs/sites where they discuss more about databases and schema? like we have High Scalability for scaling related blog posts 
Nice. Thank you!
Sweet! 
Nothing terrific, but I do have a couple in my feeds: http://kejser.org/category/modeling http://database-programmer.blogspot.com http://database-scalability.blogspot.com And a repository of the most common models: http://www.databaseanswers.org/data_models/index_all_models.htm
thank you very much again!! 
From an old timer: Ctrl-y is the old Wordstar line delete command, I think. I adapted to it pretty quickly, but then I started to ctrl-KB &amp; ctrl-KK stuff. Then I started looking for SuperCalc! Cool! 
Generating random numbers should be pretty fast, even if there's a million of them. It seems to me your slow down could be the file writing itself rather than filling the list. Does your time include that in it or did you just time the list itself?
You might also want to check out generator expressions, which usually are faster to set up and uses less memory than evaluating a million lists at once. The syntax is very similar to list comprehension. This example uses python 3. lottery = (random.sample(range(1, 50), 6) for i in range(10**6)) next(lottery) # returns six lottery numbers. next(lottery) # six different numbers next(lottery) # You can do this one million times, until it raises StopIteration To sort each set of lottery numbers, use sorted() lottery = (sorted(random.sample(range(1, 50), 6)) for i in range(10**6)) 
It's a bit of a catch-all. Post the code and the complete traceback. The string associated with the exception should explain the problem. 
See the [Python documentation](https://docs.python.org/3/library/exceptions.html#RuntimeError). Without the exact error message and your source code we don't have any idea what went wrong and how to fix it either. 
Is this supposed to be a new pypi?
The code is pretty convoluted, unfortunately. It's hard to follow what is going on. It's not messy, in the conventional sense, but . Also, the output makes no sense at all. I can't even tell if the program solved the puzzle, since it's not displaying the puzzle with all the cells filled in at once.
Not sure what sorts of projects you're working on, but I made a simple django app that crawled sites and stored things in a redis database. I also know that it can be used as a messaging queue for distributing tasks to workers, so you could always mess around with it on a free Heroku app if youre interested: [https://devcenter.heroku.com/articles/python-rq]
I ended up calling one of my friends over and sent him the entire code. He fixed up the mistake, thank you for helping me out. 
I can't tell you why it happened without seeing the code and the traceback. 
The coolest problem that's ever infected my mind was representing each group of 9 squares and the 9 possible values as a bipartite directed graph. (with 18 vertices, an edge between a square and a value means that the value is legal in the square) Make the graph maximally connected, call these 9 lines M. Take your maximally connected graph, and find all of the strongly connected components. A value is legal in a square if and only if it's a member of M or it connects a vertex in a strongly connected component to another vertex in the *same* strongly connected component. It allows you to take a puzzle that looks like this: x|x|x|x|x|x|x|x|x |:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| 1|2|3|4|5|6 |_ |_ &lt;plus six more rows... ignore the x's, that's just to make the markdown render&gt; It allows a computer to conclude in O(n) time (where `n` is the sum of vertices and edges) that the three squares in the upper right can only have the values 7,8,9, and the six remaining squares in that box must not contain 7,8, or 9. It's a very, very powerful approach to solving sudoku.
Eventually, yes.
Either `lottery.next()` should be `next(lottery)` or `range(10**6)` should be `xrange(10**6)`, I think. (The former for Python 3, the latter for Python 2.)
if you search for a use for a tool without knowing why to use it something is wrong. It is a KV store poorly designed it is (often) used for as a session/cache storage backend. It might be wiser/easier/safer to use it as a backend for another clean wrapper of solving the problem (beaker cache, dogpile) rather than using it directly blindly.
Well, he could do a few things better. Sudoku puzzles, by definition, have unique solutions. So the hardest "puzzle" he identified isn't actually a sudoku puzzle. Semantics aside, I don't know why his performance is so bad. I'm able to enumerate several hundred thousand solutions to his hardest puzzle relatively quickly with a dumb, greedy, bad algorithm. So this needs work. One of the more obvious mistakes he makes is that his possible values in a square are a list of values in numeric order. So possible values might be `24689` or something. Then he assigns values to try in numeric order. So a nearby square would try `1` first, which does nothing to our `24689` square. Then it tries `2`. When it gets to our `24689` square, it iterates through the list, eliminating the number `2` anywhere it shows up. So it checks the first character, which is two, and eliminates it, which is an O(n) operation. Then it checks the second character, then the third character, and so on, which is also an O(n) operation. And these O(n) operations are deep inside an inner loop, they happen thousands of times. If he used a set instead of a list this operation would be O(1).
Anybody tried and can comment on the two main features, BDD and the merged debugger?
One tip for using pip: use it with virtualenv. Pip will try to install modules in a shared directory that's generally not writer for regular users. And because (I believe) the packages aren't fhe led its generally not wise to use sudo to install packages. Also if two projects need different versions of a package (or module) then upgrading it might break one project. Within virtualenv you can setup a local environment for each project. This is all explained in this [tutorial](http://www.dabapps.com/blog/introduction-to-pip-and-virtualenv-python/) as well.
Link redirects to https://github.com/what-studio/profiling
Warehouse is a next generation Python Package Repository designed to replace the legacy code base that currently powers PyPI. Even has its own pypi page: https://pypi.python.org/pypi/warehouse 
thank you! (and thank you for fixing the issue i reported!)
When you run `pip install --upgrade -r requirements.txt`, does it not satisfy the constraints specified in the requirements file (possibly output from `pip freeze`)? Would file permissions be more helpful in that case? (When it's not feasible to simply create a new virtualenv and install the modified set of requirements) Or would nesting of requirements files accomplish such a dependency pinning objective? Here's a requirements.lock discussion: https://github.com/pypa/pip/issues/1175 Here's an article about pip-compile: http://nvie.com/posts/better-package-management/ ([EDIT] `requirements.in`) Is this why conda requires pycosat: http://conda.pydata.org/docs/#requirements
That would eventually be a goal, but we're having enough trouble finding the tuits(round) to just implement the base functionality.
Yep, that's our work-in-progress replacement for the old, crufty PyPI code. You can see the progress to that goal here: https://github.com/pypa/warehouse/milestones/Become%20PyPI
I use time command on linux command prompt.I dont have an opportunity for trying on a pc right now , I code on linux in an android phone(nexus 4) for fun maybe its something about chroot .thank you all for your affords .
…and therefore hosts itself: https://warehouse.python.org/project/warehouse/
I, a python noob, am trying to run your code. I got it to run in python 3.4, but get an error: It says at line 92: TypeError: 'map' object is not subscriptable l.83 fitted_cell_list = map(itemgetter(1), fitted_cells) l.92 cell = fitted_cell_list[0] Is this a python 3.4 problem? Can you suggest a fix? Thanks.
Did not work at all, must not support the pygame library. But thank you for the help.
If, by chance, you are interested in building a sequence of unique lottery numbers, consider a set of sets.: sets = {frozenset(random.sample(numbers, 6)) for i in range(1000000)} A list of one million randomly sampled lists will contain about 35,000 non-unique entries.
p=float(input("What was your total amount of purchase? ")) print("") statesalestax=0.06 * p countysalestax=0.02 * p print("amount of purchase",p) print("amount of state tax",statesalestax) print("amount of county tax",countysalestax) print("amount of total tax",statesalestax + countysalestax) print( "total sale",p + statesalestax + countysalestax ) this is probably very pathetic looking but this is what I have so far, I'm only 2-3 weeks into my class now. A response with feedback would be GREATLY appreciated thanks :) btw how do I put dollar signs in there?
Needs more blinking lights and dancing hamster GIFs. 
Saying he's doing something "wrong" is a little stiff. He solves sudoko (or sudoku-like, if you're feeling pedantic) puzzles with minimal logic and fairly straightforward code. Yes, more complex algorithms could be used to solve more efficiently, but there's also the matter of optimizing the programmer's time, both coding and runtime.
I'm assuming external libraries are out of the question? I was able to get something pretty fast with numpy. Python version stolen from /u/MatthewWilkes %%timeit NUMBERS = range(1, 50) def format_line(numbers): return " ".join(map(str, numbers)) + "\n" def generate_numbers(): for x in xrange(1000000): yield format_line(random.sample(NUMBERS, 6)) with open("numbers.txt", "w") as numbers: numbers.writelines(generate_numbers()) 1 loops, best of 3: 9.57 s per loop numpy %%timeit random_mat = np.random.randint(low=1, high=47, size=(1000000, 6)) np.savetxt("numpy_numbers.txt", random_mat, fmt="%d", delimiter=",") 1 loops, best of 3: 6.4 s per loop That being said, the numpy way is way faster if you cut out the disk. Just generating the numbers like so: for num in generate_numbers(): pass 1 loops, best of 3: 9.19 s per loop numpy random_mat = np.random.randint(low=1, high=47, size=(1000000, 6)) 10 loops, best of 3: 123 ms per loop Shows that numpy creates the data almost immediately. 
[Mind. Blown.](https://www.google.com.au/search?q=recursion)
You are right. I literally pushed right after I finished coding. Needs some work. But output should be fine, I don't understand the problem.
I am not sure I understand this but it sounds cool :)
oh and one more thing, give your variables meaningful names. so instead of p, use something like userPurchase. this is just convention, just like moving the variables to the top. functions come in the middle, and executing them come at the end. python has conventions regarding naming things, look into that. makes code easier to read, and later debug! edit: and use this book as reference, i'm going to bed soon :) http://learnpythonthehardway.org/book/
&gt; Semantics aside, I don't know why his performance is so bad. I'm able to enumerate several hundred thousand solutions to his hardest puzzle relatively quickly with a dumb, greedy, bad algorithm. So this needs work. Could you post your code? No offence, but I'm willing to bet the reason his performance is bad and your algorithm's performance is good is that yours didn't yield the correct answer. Also, there's good reason to use strings instead of sets in Python - the overhead of duplicating a string is smaller than the overhead of duplicating a set. He isn't eliminating '2' from '24689' - he's creating a new string '4689' and passing that in to the next iteration of the solver. Why duplicate? To make sure the backtracking is consistent. 
&gt; python's print statement doesn't take brackets, so ditch the (). that's more C style than python. except in python 3. OP's print statements are valid if he/she's using python 3.
https://github.com/pypa/warehouse/milestones/Become%20PyPI
thank you all very much for the insight, and yes I believe my class is using the latest version of python so I was definitely thrown off for a second there when you said to ditch the () because that's how our teacher taught us. I will be sure to make it clear what version of python I'm using next time. Again thank you VERY much, appreciate the support, will come here in the future when I need help.
Another reason why the code is convoluted is because I tried to write it in such a way that it explains what it is doing. If the only functionality was to solve it would have been simpler obviously.
The PSF hasn't been directing any of this work, it's all being undertaken at the direction of the PyPI maintainers (mostly Donald Stufft)
Thanks. That worked. Seems pretty obvious. :-)
People that are learning Python from scratch right now (like me) are going to be using 3 over 2, mostly because from our POV, 2 is deprecated, and there's no point in using it unless you really need a library that only works with 2. You might want to catch up and update. 
Looks really nice. Hoping for some support for Markdown in descriptions though!
Dude, that baby dancing gif is rad!
Python 3 was dead on arrival. Especially if you want to do any scientific computing, avoid it like the plague. Catch up will you.
This is NOT a python expression compiler. The grammar is based on very basic SQL grammar. Few other simple SQL grammar features might be added in the future. It is not meant to be a rich expression, but a small subset of quite common expressions to allow easy translation to other languages or object structures. Main use is arithmetic expression support for a modular application with different backends. It is not an expression of an object-oriented language – it does not have access to object attributes – the '.' dot operator is just an attribute name concatenation. It has a very small knowledge requirements for compilers – anyone can write a simple expression compiler. **EDIT:** Another use-case might be an expression entered through a web application, for example some formula to be plotted. The library allows safe translation of such expression without exposing any application's internals.
Thanks for this very interesting link. I had not thought of a tenth of the issues surrounding these problems -- only that I know of some pypi packages where the doc and maintainer links are dead, and think the pkgs should be pulled. One of the ideas proposed in that thread is giving every package a "lifespan" time that is reset with each upload or ping from the maintainer. I suspect that quite a few packages would have gone on the "dead or dying" list if that were in place now...
&gt; Saying he's doing something "wrong" is a little stiff. I agree. I'm going to edit more original post. &gt; Yes, more complex algorithms could be used to solve more efficiently, I agree with you; that's not what I'm saying. The thing is that the author is making a lot of extra effort to model his data as strings when his data is fundamentally not a string. Python's `set()` interface is brilliant, and the data he's working with is fundamentally set-like. He can replace a bunch of O(n^(2)) statements with O(n) statements that are easier to understand. He can replace a bunch of O(n) statements with O(1) statements that are easier to understand. The problem is that using string-like data to model a set-like domain in a language with a better set API than *any* language I'm familiar with isn't more complex, it's less complex. In other places in this thread I mentioned writing an alldifferent constraint. I brought that up because it blew my mind because of its *elegance*. The author mentioned hardcoding lots of Sudoku-specific tricks ("naked twins" etc) to solve the problem. A correctly implemented alldifferent constraint is a *general* solution to an enormous number of the specific tricks mentioned on the page he linked, but it's relatively simple and you only code it once. Using a linear time complexity general solution instead of an arbitrary number of hardcoded solution is a win-win.
Well, to be pythonic, it would have to have support for ReST, not Markdown, but still...
&gt; Especially if you want to do any scientific computing The scientific computing community has adopted it more than the web-based community. I'm in the scientific community. Python 3 is not dead. It's just people have dependencies on Python 2. I'm looking at you VTK...
I guess you don't if all you're trying to do is play around with redis, it just happened to be the framework I was using. Regardless, you could try making a webcrawler with python and a redis back end to store the data.
I was just on [/r/recursion](http://www.reddit.com/r/Python/comments/2gyznt/warehouse_pypipythonorg/cko82w6). Fun place.
Tell her to switch to Mastercard and get over there! Oh wait....
... and https://warehouse.python.org/project/pypi/ :) (note that Warehouse just sits on top of the PyPI database)
The PSF doesn't have a "priority list" as such. It has volunteers, and those volunteers work on what they can, and are interested in*, when they can. * with the caveat that once you create a PyPI you never get to walk away ;)
Calling a package "dead" and auto-removing it is fraught with danger. This is the reason why I won't just remove an orphaned package just because someone asks me to - I will look into transferring ownership/maintenance of such packages though.
Sorry, but Markdown is very popular, and missing support for it in PyPI is something that is a problem. People would like their README.md to Just Work like the README.rst currently does. (and before you ask, it's the lack of tuits(round) that has prevented me from adding Markdown to PyPI)
The last bit of output was this: ------------------------------------------------------------------------- | - - - - | - - 3 - - | - 2 - - 1 | - - 6 - - | - 4 - - 5 - | - - - | - 9 - - 8 - | - - - - | - - 7 - ------------------------------------------------------------------------- | - - 2 - - | - - 1 - - | - - - 3 | - - - 4 - | - 6 - - - | - 5 - - | - 7 - - - | - - - 8 - | - - 9 - ------------------------------------------------------------------------- | - 3 - - 1 - | - 2 - - - | - - - | - - 5 - - | - - - - | - 4 - - 6 | - - - - | - - 7 - 9 - | - - 8 - ------------------------------------------------------------------------- ------------------------------------------------------------------------- SOLVED! I can't see the solution. The rest of the output looks the same. This is just running the script unchanged, so it's solving "extreme3".
I've been learning as well, through a few online 'courses' and have a couple favorite projects I've worked on. I don't do anything advanced, mostly I just learn through looking and tweaking other people code. Currently I'm trying to learn django so I can blog and keep track of my learning, but it comes with a bunch of other required knowledge. So far I'v made a text-bombing program, that sends any number of texts to any number(given their provider, which isn't hard to guess) from a basic gmail account. I made a little stock info scraper, but it doesn't beat the websites that automate everything. My problem is practical project ideas that haven't been done, I plan to move onto web/app dev with kivy in the distant future. Anything seems to be possible.
well i'm working on an open source project, which have existed for a few years now, and updating it to use 3 over 2.7 is a lot of work ;) sometimes you have no choice
&gt; A list of one million randomly sampled lists will contain about 35,000 non-unique entries. ~~Are you sure?~~ &gt;&gt;&gt; sets = {frozenset(random.sample(numbers, 6)) for i in range(1000000)} &gt;&gt;&gt; len(sets) 965299 *No, I'm pretty sure he is, dude.* ~~What! But 965299 ≉¹ 35000.~~ *It sure isn't.* ~~I knew it!~~ --- ¹ That's probably the only time anyone's ever added a footnote to a crossed-out not-approximately-equals sign.
Yes. You can't really get faster than Numpy here without using a faster random number generator, and there aren't many good choices of those.
??? 1000000 - 965299 = **34,701** I would call that 'about 35,000'.
unclick the "Use subreddit style" in the sidebar. Either that or convince the mods to change it or use some extension similar to stylish
Like the clean ui! An idea... The first thing i usually look for on the package detail page is a link to a browsable source. The "homepage" link often leads to github, but not always. I'd like to see icons/alt text for some very popular sites next to the links indicating where they lead. eg. icon for readthedocs, github octopus, bit bucket, ... I usually would choose a project using github and readthedocs over one with handcrafted page and just tar ball (because best practice). Icons may also further promote using those services...
Should never be removed, might still be useful working code and base for further development. Maybe pip/pypi need a package-is-unmaintained/deprecated warning feature.
Disabling stylesheets for specific subreddits is [Reddit Enhancement Suite](http://redditenhancementsuite.com/) feature and is not available without it, OP could disable custom CSS globally in [preferences](https://ssl.reddit.com/prefs/) if he/she doesn't have, or want, RES installed.
Haha nice
I have two books but never had time to read them: [Kivy Interactive Applications](https://www.packtpub.com/application-development/kivy-interactive-applications-python) [Creating Apps in Kivy](http://shop.oreilly.com/product/0636920032595.do) But that video tutorials from @inclemnet look promising. :)
combine subreddits into larger "multi" reddits, they are always shown in the default style. If you dont know what i'm talking about: you can access any nr of subs using the /r/&lt;sub1&gt;+&lt;sub2&gt;...+&lt;subn&gt; method. Also helps with the low amount of content some subs get. For example this is my programming sub: /r/programming+compsci+javascript+python+coding+php+functional+tinycode+java+coolgithubprojects
This is a subject I want to learn more about. Not many reviews of the book yet though; are there any alternative books I should check out?
Hmm [Common markdown](http://www.reddit.com/r/programming/comments/2fi4mh/standard_markdown_is_now_common_markdown/) Que the Xkcd comic !
This one? http://xkcd.com/927/ Also, it's not even common markdown, it's [CommonMark](http://commonmark.org/). I think that [John Gruber](http://daringfireball.net), the author of [Markdown](http://daringfireball.net/projects/markdown/), is being a bit of a dick on this.
Yeah. I just can't read. 
This is just an alpha to see how it goes. This was recorded over Google Hangouts. The first two videos in the series turned out well, but this was just a disaster. No idea why. Check out http://discoverflask.com for much higher quality videos.
Or just do like http://www.reddit.com/r/python+none situation
It's interesting that the response is "don't like it? don't use it". The styling is clearly in violation of styling norms for links, and it reflects poorly upon the python community, imo. 
I am going to selfishly blare my opinion and state that the styling for this sub reddit is highly non plus good.
Other relevant numbers: * /r/coding 48,325 * /r/dailyprogrammer 44,643 * /r/lolphp 3,996
So in this output, every cell is a 9*9 square containing all the possibilevalues for the cell. If there is one possible value per cell, then the value for that cell is set. You have 81 such cells.
This subreddit's CSS is irritating in general. Like you said, there's no difference between a viewed and an unviewed link. And the font size is weirdly large with text having a large gap before and after the username/points/time ribbon and the permalink/save/report/give gold/reply ribbon. The font size also means that there's some text overrun on the side bar. For example there's a "this post was submitted on 21 Sep/2014" because of the size.
Except it can be rather hard to convince the mods to change it especially if the majority doesn't have a problem with it (I'm not sure if they do). So the easiest way until the mods can reply on whether they're okay with changing it, is to find a temporary (or permanent) workaround. fix it on the user's end before trying the sometimes long process of fixing it for everyone. 
Yeah that's exactly it.
Maybe it's some bias against reddit because it's written in python.
I made a chart including bash: http://i.imgur.com/k77GJca.png
Will this project make it straightforward to host and upload to one's own private warehouse/ pypi server? It would be great to do this at work for our internal projects (instead of directly installing them from git or from a S3 tarball) and for mirroring external projects we rely on (instead of directly pulling from pypi in production).
this is much nicer than pypy standard repo. Awesome job mate
are this https://www.pyweek.org/ guy?
Good work! 
Thanks!
There is a surprising amount of content on that sub.. does it have any special function? or is it just a gag sub?
Reddit was built using web.py then Pylons, not Django.
&gt; Like you said, there's no difference between a viewed and an unviewed link. Am I the only one who sees a color difference? The viewed links are more purple.
To me it is, perhaps this is why there aren't more complaints?
I use virtualenv on Windows, no problem at all. I use it in Powershell with activate. Cmd works fine too, but I just like posh more. Virtualenvwrapper won't work though. There's a project somewhere on github, something like virtualenvwrapper-powershell, but it's dead.
Doubtful, how many people even know that?
Well, kind of. Pip is tool for installing things from PyPi. But neither of them are the same as PyPy!
It must be from a lot of snake enthusiast who got very confused and didn't know how to unsubscribe.
In general, I've always been asked super basic stuff ("what's the difference between a tuple and a list"), then some kind of exercise. Learn itertools. It's useful for stuff like that.
import everybody def win_reddit: everybody.subscribe
All the Python developers.
Off the top of my head: - Know what the GIL is, and how it works - Know what a generator is and how iterators are determined
sounds like your putting data into a template. 
It also helps that Reddit is programmed in Python.
It is because Python is totally great. Good job, Python!
/u/aphoenix -- gamer first and Redditor extraordinaire -- decided [months ago][0] to use his authority to make a design change for the most popular programming language subreddit. His [exuberance][1] reveals his motivation. **KARMAA** `Flask` author chimed in to defend the minority position that the design change was terrible. `Django` committer chimed in to be a sarcastic douchebag. Admins quietly joked about the few people that disagreed with the new design keeping mostly quiet until the frustration subsided. *Most* of the admins here are ***NOT*** representative of the Python community at large. The politics here are very much anti-Python. Given the history of Reddit the current state of /r/Python makes me sad. Given my conversations with /u/aphoenix I have no hope. But "it's just the design!" Sure, because Python's design has had nothing to do with its success... [0]: https://www.reddit.com/r/Python/comments/27o61z/original_reddit_vs_todays_python_subreddit/ [1]: https://www.reddit.com/r/naut/comments/27hxrw/rpython_is_now_using_naut/
checkout /r/progether (and it's irc #reddit-progether on freenode), /r/learnpython, /r/coolgithubprojects. look at projects on github or bitbucket. find a problem you want to solve and look up solutions. If something's being worked on already, join them and help out. If there isn't one or you don't like the current state of it (too messy or inactive or out-of-date), start your own and try and get contributors or just work on your own. Don't worry about being ready. Half of programming if learning as you go and if you're not ready, you'll quickly catch up to speed. However, if you're working with other people, try and learn and do the work instead of just expecting people to do all the hard work. Being inexperienced isn't a drawback at all, but being inexperienced and not willing to read documentation or start writing some code first can be annoying. hope it helped.
It's nice to see /r/Scala and /r/Rust getting popular.
 import everybody def win_reddit: everybody.subscribe()
I'd love to see the original LISP version.
This is the second highest up voted thread in this subreddit.
Hello, author Ian here. O'Reilly's site has reviews of the early versions (which started at 4 chapters [and lots of typos - since fixed!]), so they're a bit out of date. I see a review on Amazon .co.uk and .com (both 5 star). I've just done a signing at PyConUK with Harry Percival ("TDD With Python") and we had a queue out of the door, the receivers said they were very happy after they'd had a chance to poke through the books (but then...they'd got the books for free, so who knows!). I've also taught this material at PyCons/EuroPython/EuroSciPys/PyConUKs for years, if you go through my blog you'll see presentations, videos and src for each tutorial I ran. Alternatives - Packt published their "Python High Performance Programming" a few months ago and a Cython book before, Amazon has some reviews. O'Reilly have a Cython book coming out later this year (it'll be much more in-depth than my coverage of Cython). Packt &amp; O'Reilly have several numpy books (again reviewed in Amazon). This field for Python HPC is lightly covered at present, we aimed to put 10+ years of our personal experience into the book (particulaly - the painfully learned lessons) to try to make your life easier. HTH, Ian.
I don't think that really has anything to do with it.
I still doubt that is has anything to do with it.
Not many people know that. Most people don't know the language behind the sites/programs they use.
It's poor styling if the difference is just a little more of the same color. I am color weak and I cannot see any difference at all in the subreddit. 
What is that? What is different? Can I have a link to docs? I don't know how to refer to package:def()... :)
What is this Ruby?
mind your language please
The LibreOffice project is quite nice and welcoming. You can always drop on the IRC channel or drop an email. To get started, do an [Easy Hack](https://wiki.documentfoundation.org/Development/Easy_Hacks). Although LibreOffice itself is written mostly in C++, it uses Python for it's wizards (which need conversion from Java) and for it's website ([on GitHub](https://github.com/tdf)). Its certainly not the easiest (in terms of size) project to contribute to, but just imagine the 125 million people using LO seeing your change! Have fun!
If you wish to run your own server then use devpi (http://doc.devpi.net/). See my recent PyCon AU talk for an overview: https://www.youtube.com/watch?v=pZTiAkwiPgI
ReST was invented as a way of fixing issues with StructuredText from Zope. Both are part of the Python ecosystem, solving a problem that Python folk had. In the absence of anything else, ReST was adopted by the Python community. docutils is an extremely ambitious project with an extremely complex API to use. This has caused problems for ReST adoption beyond some core tool developers. Then Sphinx came along and made documentation awesome so we didn't care. ReST is therefore all through Python, including the core docs. Later on, John Gruber solved some perceived usability issues with the ReST format and created Markdown. As has been mentioned, he's not played well with others :(
This sub's design is a noxious piece of shit. Was a total fucking joke how /u/aphoenix dropped it in place, and then ignored all discussion about how awful it was, and just completely went offline until people just said "fuck it" and gave up their complaining. See /u/aagl's [comment in this thread](https://www.reddit.com/r/Python/comments/2h0twr/the_styling_of_this_subreddit_makes_every_post/ckooxjj) for more info. Some options: use Reddit Enhancement Suite, and turn off the "Use subreddit style" option. Or, view the "compact" version at http://reddit.com/r/python.compact. 
Surprising, I figured JS and Java would be the top dogs.
This is primarily for mobile but try this one: http://shop.oreilly.com/product/0636920032595.do I haven't read it yet but all the other Python books from O'Reilly I've read have been fantastic.
This is the bottom 3 side by side squares of the table. It's not the whole table.
This solution uses a depth first search. My approach was a more "human" approach as I wanted not only a solver, but also an explanation to the solution found.
I think there is virtualenvwrapper-win that works ok.
Thanks. I'll check it out.
If the spreadsheet is straightforward you can export the sheet as a CSV file and process it easily with Python. If the sheet is a not so much a database but Rather a mash up of formula and data you may have a big project ahead of you just to read the data and establish it as a usable structures in Python. Once in Python getting the data into the other systems will likely be very involved. Frankly if you are asking here you have trouble. Most likely the ERP software is using some sort of database. To transfer the data int to database you will need to understand the databases structure and SQL. You will need to attach to the database through Python and prepare the SQL states to load the data into the proper tables. Needless to say coming up to speed with the database will be a big part of this project. 
One more thing; search the internet for tutorials! Reading an Excel file or CSV file "can" be easy but is hard to cover in a pet here (especially on a cell). At the other end expect to do lots of reading when it comes to database interfacing. This can become very complex depending upon what exactly is expected of this project. 
Don't different dev communities congregate on different corners of the internet? Like android devs sharing stuff through Google+, xda, or RootzWiki? 
That's cool and all but what do you think it means? Do you think it means that career minded people should learn python as opposed to .NET or Java? Do you think it means that Python is the best language?
Related thread asking the same question: http://np.reddit.com/r/Python/comments/2b4ytx/python_interview_questions/
Same with coffee drinkers for /r/java then! 
Ruby community probably loves Twitter (to communicate professionally, well 'professionally') since it is well known among Ruby devs that Twitter was originally launched as a RoR app. There is something to be said for home field advantage.
And as someone who frequents /r/python /r/learnpython and /r/django consider me pleasantly surprised when the folks at all 3 pointed me in the right direction when numerous days of asking similar questions on SO got me nowhere. The communities here for programming in general are awesome as it is but Python really takes the cake :)
With the advent of sites like github.com it is so trivial to do this now; find a project you like, make your fork, start fixing bugs, send a pull req back when you've nailed it. If the developer doesn't like your code, they'll tell you why. When it comes to open source projects all contributions are welcome - its better to ask forgiveness than permission :) Just remember to never take criticism personally, you're rarely going to run into a developer who cares about your personal feelings. Also, there's so many non-code issues that can be resolved, all it needs is someone with time. e.g. writing manual pages (you get to *read* lots of code so your documentation matches how it works, and reading code is the first step to understanding it); or fixing spelling or grammatical errors in (especially user-visible) code or documentation. github projects have an issue tracker, so its so easy to find work that can be done. If something takes your fancy, do it even if it turns out later on the developer also worked on it and fixed it their own way instead - programming is like exercise, you need to do it to get fitter.
Hello there! I am also a fellow EE student. I started contributing last year and I have found it really satisfactory to contribute code and it can become quite addictive. I recommend looking at [OpenHatch](https://openhatch.org/). They have a lot of neat information about contributing to open source and if you look through the projects you might be able to find a mentor (contributing becomes a lot easier with a mentor). Finding a project that is a good fit is sometimes a trial and error process. I suggest you look for projects that are welcoming to beginners with a healthy collaborative community and that way you're not "wasting" anyone's time. I was very lucky to find a friendly project within Fedora. People would volunteer their time helping me figure out to use git at the beginning and would make constructive criticisms about my code which I think is important for a newbie since it's encouraging to keep going. If you bump into an unfriendly project I suggest to ditch it and find a new one before deciding to give up on contributing. Once you've found a project you like, set up the development environment and look for an easy bug. I recommend to start out with small bugs (such as fixing typos, refactoring, and fixing styling errors) to boost your confidence and get you used to the development environment and then grow into doing more complicated tasks. Your first patch might not get merged right away and might go through some iterations of code reviews, but it is really satisfying when it is finally merged so stick with it. Good luck!
Gotta be honest I found /r/coffescript when I was writing my screen play in San Francisco. &lt;/sarcasm&gt;
That logic is funny to me as Twitter realized RoR couldn't handle their throughput and rewrote...!
no need to bash
&gt; many projects will require knowledge of C++/C And many others won't. Perhaps the most prominent open source projects are in C and C++, like Linux, Firefox or Libreoffice. But if you're willing to work on something smaller, there are literally thousands of open source projects which are pure Python (or Ruby, Javascript...) &gt; formal training makes for better code Don't be discouraged by this. I've never had formal education in programming, and I'm paid to write code. I know plenty of other programmers who haven't been formally trained. If you have the right mindset - and it sounds like you, OP, do - experience and learning from the internet works pretty well. Of course, maybe there's some secret lore that you're only taught if you get formal programming education. But I doubt it. ;-)
Why does every distribution bar graph in the world look like a exponential curve if all the mid points are joined?
You will probably end up counting users twice.
/r/fortran coming in strong at 765.
Checking if you're ready: one way is to look for recent pull requests or patches sent to a project. See if you understand them, and if you could have written them yourself. Or see if a project has a 'bitesize' or 'quickfix' tag for bugs, and try to fix some of those. If you can fix it in a simple, satisfying way, there's a good chance it will be accepted (give or take code style, writing tests, etc.) Picking a project: If you use open source projects, do you run into any problems with them? Either bugs or features you miss - dig into the code and see if you can make it do what you want. The smaller the project, the more likely you are to be able to help. But look out for dead projects, that haven't been updated for months: if you want to work on one, contact the author first to check that your work won't be ignored. If you don't run into any problems yourself, look on the issue tracker for problems other people have had. The comments can also give you an idea of how hard it is and whether a fix would be accepted. You can also start by open sourcing some of your own projects and inviting people to use and review them.
&gt; I've never had formal education in programming, and I'm paid to write code. I know plenty of other programmers who haven't been formally trained. If you have the right mindset - and it sounds like you, OP, do - experience and learning from the internet works pretty well. There's also the opposite of this, where a guy with a CS degree can't write a line of code to save his life.
I am looking forward to using Rust some day.
It used to years ago. The LISP -&gt; Python port was quite controversial/talked about back in the good ole days. . . This is not my original reddit account btw, I've been a redditor since 2005.
All of the early redditors too. Back in the olden days (2005 to about 2007/2008), just about everyone on reddit was a programmer of one form or another. Not my original account btw, I started using reddit in the summer of 2005, after reading an article about it on boston.com.
I cut off the data at 3000 subscribers (arbitrarily). Other languages that didn't make the popularity cut: OCaml, CoffeeScript, Elixir, F#, D, R, Pascal, Ada, Prolog, Smalltalk. Some are way ahead of the popularity bell curve and have *lots* of potential, others are dead languages. Python is at its peak.
Notably, virtualenvwrapper-win is no longer updated. It still works, but there are a couple of tweaks to the package to make it modern. * mkvirtualenv script expects to use the (going from memory here) `virtualenv-script.py` executable to run. This needs to be changed to `virtualenv.exe` * expects/installs dated versions of virtualenv and pip (the version that gets loaded in the new virtualenv)
The more subscribers there are the more interesting content there is, which attracts more subscribers. I can see how that could roughly follow an exponential function.
Eh... I wouldn't say Python is a normal/easy beginner language. Colleges still primarily start with C/C++/Java, and PHP is, by far, the easiest language to get into for a complete noob (which is primarily why there's so much atrocious PHP out there). I think Python is just riding the popularity train and the moment, and it's got a pretty unique style in the grand scheme of all languages. It's a rare language that can attract hipsters, gurus, AND the odd programming newb.
I was a big linux fan before I tried to learn to code now that I'm learning I wouldn't do it any other way then with linux
One option might be Toga (http://pybee.org/toga). It's an early stage project, but it allows for building rich native GUIs in Python, and a webkit browser is one of the supported widgets (there's a tutorial demo that builds a browser: http://toga.readthedocs.org/en/latest/tutorial/tutorial-3.html) It's still got a lot of sharp edges, but if you're willing to get your hands dirty, it might do what you need it to. 
Previous discussion on Reddit http://redd.it/1clpi4
Don't you ever feel like denoting sarcasm takes away something inherent in its properties? I feel like needing to detect sarcasm is an intrinsic or inherent part of using it in a language. Not to say I don't get why you feel compelled to use it...
If python is going to 'do something,' then I would argue that it's at the peak of its popularity curve and that this is the time to *do it*. Some languages that *did something*: C, SQL, Erlang, Perl, PHP, Java, JavaScript, Ruby.
So what do you use? Bash has always suited my needs and it's the default setup for trisquel.
I can't find my original account either. This is my oldest account now, closing in on 5 years. But I could have sworn I started commenting back in 2007, not late 2009.
http://cacm.acm.org/blogs/blog-cacm/176450-python-is-now-the-most-popular-introductory-teaching-language-at-top-us-universities/fulltext
[Poe's Law](http://en.wikipedia.org/wiki/Poe's_law) will amuse you
If you want to contribute more than minor bug fixes, I would advise to (1) choose a project that you really like (ideally, that you will actually use), because you will need a motivation to maintain it, and (2) clarify things with the project owners *before* you start coding. Like "do you need this feature ?" "I intend to implement it like this, is it ok ?", etc. otherwise you have a risk of getting refused if the owners disagree with your implementation. Also in Python, use the PEP8 coding standards, it will make everyone happy.
I'm familiar with it but I'm not sure what it has to do with my comment.
But...but...how many are girls ?
Splinter might be the right solution: http://splinter.cobrateam.info/ Its a library that i came across a few weeks ago, and its really simple, powerfull and kinda looks flashy also.
Hey, don't forget /r/Delphi! 556 subscribers, and may even break 600 by the end of the year. And from there... the world! Or not. Maybe that's a stretch goal. I'd like to think a goal of having double the /r/COBOL subscribers (307) would be more realistic. True fact: while there's a web forum that interoperates with it, most Delphi programmers still communicate via a corporate NNTP server and dedicated USENET reader software. 
Trying to find one file in a folder of 50 is a pain. However, it lets you replace versions of things like numpy by deleting the so files. It's really useful if you're trying to use somebody's software and you need to upgrade packages either because they're really old or because they didn't include them and you need it.
The issue with sarcasm on the internet is it's very hard to detect - you rely highly on context. Making it clear is helpful when it might be ambiguous.
I don't disagree that it is helpful, I just think that it is degraded when we do. I saw a comment to the effect of "we lose something when we use a sarcasm tag" and I wish I could find it, I completely agree. It just doesn't have quite the same effect when you have to spell things out.
Because Python is awesome and Javascript Hipsters are all on Twitter &gt;.&lt;
Can't you call a `.sort()` on the lists before comparing them in your tests? Even if the lists are large that shouldn't be a big issue for unit tests.
Well, I used LibreOffice calc. I wanted to see what customizations I can make and am quite surprised of the result myself. Usually, I use Pandas and matplotlib (Python) or D3.js, this was kind of an experiment.
This is awesome, thanks!
Reddit was not created with python. It was started with Lisp I want to say? It wasn't that long, I know Aaron Swarz was involved in the port.
I thought Salt also used YAML, and I thought that also was imperative, since it uses Jinja templating to do looping in these files? That also makes the syntax extra horrid.
That's what I do for now, and it works. But when I was writing that I thought it might be good to prevent end-users from using an "indexed" interface, because in this case it does not make sense.
Is Salt really more declarative? The YAML files aren't executed in order?
Well I missed it a year ago - at this time I struggled getting the basics of python right and never thought about packages and things. And now I understood why to use virtualenv, thats great.
Author here, in case anyone has any questions.
This is quite interesting, and the more I think about it, the more it fits. But a thought I am going through is the case where two distinct instances produce the same hash. Then, the Counter instance would drop one of the two, and when calling `Counter.elements` would return the other (non-dropped) instance twice. This could cause problems. Arguably the user's own fault for doing wonky stuff. Might be okay to simply document that behaviour though... ... I'll give it a quick run-through and post my results here. **edit:** Nevermind, it actually works! Here's the code I used for testing: from collections import Counter class Tester(object): def __init__(self, value): self.value = value def __hash__(self): return hash(self.value) def __repr__(self): return 'Tester(%r)' % self.value values = [ Tester(1), Tester(1), Tester(2), Tester(3), Tester(4), Tester(5), ] cdata = Counter(values) for row in values: print(row, id(row)) print 80 * '-' for row in cdata.elements(): print(row, id(row)) And the result: (Tester(1), 3072254188L) (Tester(1), 3072254220L) (Tester(2), 3072237100L) (Tester(3), 3072237132L) (Tester(4), 3072237164L) (Tester(5), 3072237420L) -------------------------------------------------------------------------------- (Tester(1), 3072254188L) (Tester(2), 3072237100L) (Tester(3), 3072237132L) (Tester(4), 3072237164L) (Tester(5), 3072237420L) (Tester(1), 3072254220L) From the `Collections` doc, I was actually expecting the `id` of `Tester(1)` to be twice the same in the results from the Counter (either twice `3072254188L` or twice `3072254220L`). But it turns out not to be the case. Given this, I believe `Counter` is a very good candidate for the data type of the clusters. Thanks!
My university teaches python for introduction to computer science and for first and second year algorithms and data structures. It feels sort of silly trying to do algorithms and especially data structures in python, rather than in C or C++.
Hi from Heinsberg, Iam using cx-freeze, wich works pretty neat (so far I have down a resistor identifyer and a tracking tool tracker). I froze the whole thing into binarys and used Inno Setup Compiler to make a Setup, which distrubute all the other files. There is a way to get all of the files in one exe file: [Abstract](https://us.pycon.org/2014/schedule/presentation/201/) [Video](http://pyvideo.org/video/2636/the-day-of-the-exe-is-upon-us)
This article is out of date. The officially blessed way of getting pip is `python3 -m ensurepip ` and getting a virtual python environment is `python3 -m venv`
I saw the similar graph in distribution of different swear words in comments of source code.
The rewrite from lisp to Python was announced in [December 2005](http://www.redditblog.com/2005/12/on-lisp.html), and [here is what reddit looked like in July 2005](http://web.archive.org/web/20050725010627/http://reddit.com/). Note that there were no subreddits, and no commenting, but there was a list of [daily, weekly and all-time top posters](http://web.archive.org/web/20050924151959/http://reddit.com/topsub) (you can even find my name amongst them ;).
Also, the color of the user names in the comments is similar to the default thread submitter color in most other subs.
nice try pythonjobshq.com guys j/k anyways, wiki will be nice and it will also bring more people to this sub.
Perhaps humans copying other humans tend to copy things other humans tend to copy? That is, memes might be inclined to snowball regardless of whether they're subreddits or swear words.
[Benford's law]( http://en.wikipedia.org/wiki/Benford%27s_law)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Benford's law**](https://en.wikipedia.org/wiki/Benford%27s%20law): [](#sfw) --- &gt; &gt;__Benford's Law__, also called the __First-Digit Law__, refers to the frequency distribution of digits in many (but not all) real-life sources of [data](https://en.wikipedia.org/wiki/Data). In this distribution, 1 occurs as the leading digit about 30% of the time, while larger digits occur in that position less frequently: 9 as the first digit less than 5% of the time. Benford's Law also concerns the expected distribution for digits beyond the first, which approach a uniform distribution. &gt;This result has been found to apply to a wide variety of data sets, including electricity bills, street addresses, stock prices, population numbers, death rates, lengths of rivers, [physical](https://en.wikipedia.org/wiki/Physical_constant) and [mathematical constants](https://en.wikipedia.org/wiki/Mathematical_constant), and processes described by [power laws](https://en.wikipedia.org/wiki/Power_law) (which are very common in nature). It tends to be most accurate when values are distributed across multiple [orders of magnitude](https://en.wikipedia.org/wiki/Order_of_magnitude). &gt;The graph here shows Benford's Law for [base 10](https://en.wikipedia.org/wiki/Radix). There is a generalization of the law to numbers expressed in other bases (for example, [base 16](https://en.wikipedia.org/wiki/Hexadecimal)), and also a generalization from leading 1 digit to leading n digits. &gt;==== &gt;[**Image**](https://i.imgur.com/8RbF6oH.png) [^(i)](https://commons.wikimedia.org/wiki/File:Rozklad_benforda.svg) - *The distribution of first digits, according to Benford's law. Each bar represents a digit, and the height of the bar is the percentage of numbers that start with that digit.* --- ^Interesting: [^Gregory ^Benford](https://en.wikipedia.org/wiki/Gregory_Benford) ^| [^Frank ^Benford](https://en.wikipedia.org/wiki/Frank_Benford) ^| [^Mark ^Nigrini](https://en.wikipedia.org/wiki/Mark_Nigrini) ^| [^Logarithm](https://en.wikipedia.org/wiki/Logarithm) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckp85jo) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckp85jo)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
[Don't worry bro, Rust has enough hipstercred to be webscale for the foreseeable future](/r/programmingcirclejerk)
Very cool! Can you explain how these N-D arrays differ from the pandas' built in Panel structure?
I also see a colour difference, which had me confused, but it seems like it might be something to do with the difference in people's monitors I guess?
Not to mention /r/marijuanaenthusiasts and /r/trees
I think reddit has one... ops you are here ;)
Writers have been able to convey sarcasm through the written word long before the internet existed. And they didn't have to say "lol jk" at the end of it.
Fizzbuzz
something more personal maybe ? 
The suggestion of collections.Counter was a good one, but if you wanted to simply remove the __getitem__() method, you could add a wrapper class that lacks it but acts like the list class otherwise.
not sure of the benefits of using xray over pandas. Can you elaborate some examples?
To make the code more declarative you could just: order_independent = sorted That way the tests look like: assert order_independent(foo) == order_independent(bar) which might make more sense to the reader than "sorted".
Sort is a list method, not a function. This wouldn't work. I think order\_independent = sorted will work, but I'm not sure if iterator equality is defined that way.
I could, but thinking about it, I might gain a little bit else from using Counters: The algorithm needs to mutate the collections by removing and adding items. Especially removing is quite a bit faster when using dicts (the underlying implementation of Counters if I read that right). And semantically, "bags" are much more correct than lists. So all in all, I think a Counter is better suited than a list. And there can be a potentially large number of instances, so the wrapper would add additional memory overhead compared to Counters. And as the algorithm is already painfully slow (just by the very nature of the problem), every little bit helps. I have not yet calculated the complexity, but I'm sure it will be painful \^_^
this sounds like you're [shaving yaks](http://sethgodin.typepad.com/seths_blog/2005/03/dont_shave_that.html). what's the larger problem you're trying to solve here? what is the program going to do when you're done?
The JS runs in the browser and interacts with an API on their servers running Django. IIRC, they still use Django to do much of the HTML rendering you see.
&gt; IIRC, they still use Django to do much of the HTML rendering you see. HTML rendered in the comment box?
...or just click "unsubscribe" :)
There are several subreddits, mailing lists, IRC channels, user groups for Python and projects written in Python. It's also not really that difficult to find them. Is there anything specific you are looking for?
i need to store a class object containing 4 ids i.e a user id,a verb(string),object id and a target id e.g leader board and a timestamp.
Counter only folds values when they have the same hash and also compare equal. class Tester(object): ... def __eq__(self, other): return self.value == other.value
I like the `order_indepentent` idea. But in this case, the result is a collection of clusters (currently a list of lists in my case), so a simple alias to `sorted` wouldn't work anyhow. But defining my own function in unit-tests to "normalise" the data beforehand is a good idea. I like that, and may use that idea in the future.
knowledge exchange... I am arranging some ideas and creating apps in python in order to make something useful to the world. Hoping to find similar people who have the same goals and trust python for that ! I am aware of the most things you said but almost every time all are occupied with their projects. 
Ah sorry, yea I meant sorted. Thanks for catching that.
Geez, if the internet was around when I was in uni... 
What's a good use for lua anyway, I mean is great, I can use it, but how could it be used 
Haha,I never heard that term before, but I'll definitely be using it. Thanks for that. I'm not too sure this is going on here though. This is actually the meat of the program I want to create. There will be some ancillary things I'll add over time, such as that last piece on shuffling the algorithm to reuse components when presented with a list of rgb values to solve, and some snippets of code to add rgb values to the my stored list automatically as I get new options that I'm allowed to use, and a bridging piece that will take my output and shuffle it so it becomes legible to others in a useful way. But pretty much I have a list of very specific rbg values that I have to use in varying proportions (equaling 100% total) to find a given input. Maybe stepping back a little and breaking it into one issues only. I'd like the mathematics of solving within constraints like these written as psedocode. As a newb I'm having trouble getting the pseudocode up to par.
the problem is you've only explained the algorithm the program uses, not what its end goal is. very few people enjoy mucking around with RGB values for no reason. what is the output used in? *why* do you need the rgb values to total 100%? *why* do you need to pick from a fixed list of values? help us understand what you're trying to solve.
Well, World of Warcraft is written in it, so you can do something with it. 
The latest version of the *Zeus IDE* adds Python autocomplete using the Jedi package. Details about the Jedi package can be found here: http://jedi.jedidjah.ch/en/latest/ Details of how the autocomplete works can be found here: http://www.zeusedit.com/zforum/viewtopic.php?t=7200 **NOTE:** Zeus is shareware, runs natively on the Windows platform and runs on Linux using Wine. Jussi Jumppanen Author: Zeus IDE 
thanks for the comment.i am very much sorry if my blog looks like spam.i have no intention of spamming and will be grateful if you please explain how should i improve my blog. Cheers ! 
I still prefer and use the old layout. Gratz to your efforts and what its become!
Or his girl friend, or wife, or sister, or favourite cartoon character, or ...
Bonus! Now they can never replace him!
Damn, that looks really nice, but it won't work on mac. :(
He wrote a blog post sharing his knowledge about how to crack a Linux binary, he didn't publish their root password. That knowledge isn't the property of the employer, and it's not up to them to tell him whether he blogs about it or not.
No World of Warcraft API's are written in it. Lua is a flexible language, but games like WoW in Lua, would be RAM heavy and ineffecient. Lua is better for things like the Api's and plugins.
this is misleading. you can't include learnpython if you're not going to include other help/learning subreddits, ie. learnjavascript, learnjava, javahelp etc... 
That is **not the object's address**, except by accident. Here is an undoctored copy-and-paste from a Python interactive session: &gt;&gt;&gt; class C: ... pass ... &gt;&gt;&gt; instance = C() &gt;&gt;&gt; print instance &lt;__main__.C instance at 0x1&gt; The thing you are calling an address is *not an address*. It is the object ID, which is an arbitrary number. Different versions and implementations of Python have different schemes for generating object IDs. Some versions might happen to use something which looks like an address, which might even be numerically equal to an address, but they are not addresses, it is unsafe to treat them as addresses. By using it as an address, you are playing Russian roulette in your code. At *any time* you could cause a seg fault by dereferencing some random object ID which points by accident to some arbitrary place in memory. Just don't do it, it is not safe, it's not guaranteed by the language, and the very idea of treating object IDs as addresses is unsupported.
Not a good answer. It's a terrible answer because it (sometimes) works. If would be *less terrible* if it actually failed to work. Anyone asking this question has demonstrated that they don't know what they are doing.
Why would there be a way to do this from Python? If this surprises you, that just indicates that you have completely missed the point of a high level language like Python. This is not C, you're not doing pointer manipulations.
This feels a little bit silly, but is what you had in mind? &gt;&gt;&gt; class Speed(object): ... conversion_table = { ... 'm/s': 1.0, ... 'mph': 1609.344/3600, ... 'km/h': 1/3.6, ... } ... def __init__(self, speed, unit): ... if unit not in self.conversion_table: ... raise ValueError('Unsupported unit %r' % unit) ... self.meter_per_sec = speed * self.conversion_table[unit] ... def __repr__(self): ... return "Speed(%r m/s)" % self.meter_per_sec ... @property ... def mph(self): ... return self.meter_per_sec / self.conversion_table['mph'] ... @property ... def kmh(self): ... return self.meter_per_sec / self.conversion_table['km/h'] ... &gt;&gt;&gt; s = Speed(25, 'm/s') &gt;&gt;&gt; s Speed(25.0 m/s) &gt;&gt;&gt; s.mph 55.92340730136006 &gt;&gt;&gt; s.kmh 90.0 &gt;&gt;&gt; s = Speed(1, 'c') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 9, in __init__ ValueError: Unsupported unit 'c' &gt;&gt;&gt;
some of the conversions require more than just a simple multiplication/division. Foo is an angle, a is radians, b is degrees, then we have c, d, and e being e5, e6 and e7 formats.
Anytime you need a language. It is probably the fastest scripting language (especially if you include LuaJIT, an alternative implementation, the equivalent of PyPy) and has a very small disk size, so can be embedded easily and effectively in larger applications. It is used extensively in game dev, but is also used in other fields such as webdev and general scripting.
Why is there no such thing as r/R? Statisticians need love too ;(
Both of you have valid points. However formal training in the hands of someone seriously interested in programming can make a huge difference. Instead of taking years to come up to speed you can grasp advanced techniques faster and better understand how to use them. Of course this implies a formal program worth the time. I just find such learning environments more stimulating than reading a book. 
This is how I would go about it as well -- the class should only really store values in one format and have getter methods which return transformed values when asked
I know people will hate me for posting this on /r/Python, but... * Lua (with LuaJIT) is the fastest scripting language out there; * Lua is not bloated with tons of stuff I don't need; * The language is very stable and simple (this means that LuaJIT will always be very compliant, as opposed to the hopeless PyPy); * The "only one way to do it" thing is actually true in Lua, as opposed to the endless bikeshedding opportunities in Python; * You can easily cross-compile Lua or LuaJIT to a potato (cross-compiling CPython is a PITA, when at all possible); * You can integrate Lua code with C code in a very natural way (in Python you have many different ways, one worse than the other). In short, if I'm doing something for money I'll do it in Python because all the batteries are there and I can ship something with minimal effort. I don't care if it will be slow, buggy and bloated. Now, if I'm doing something I care about and it must be done in a scripting language, I'll use Lua.
This would make a fun weekend project with my old HTC Hero. Try and get it running as a portable CCTV. Probably would have to leave it plugged for battery usage. 
Make an exciting project, talk about that project and people will eventually join in. I can only speak for me but you pretty much have killed any interest I could possibly have already. &gt; I am arranging some ideas[...] Of course you do, I too have a todo list. &gt; [...]and creating apps in python[...] Well yes, of course. Who doesn't? &gt; [...]in order to make something useful to the world. Nuclear fusion? Curing AIDS/cancer? Any less than that and you sound ridiculous. If you would be doing anything of these things, finding other people who want to join you shouldn't be a problem, so ridiculous it is. Drop the meaningless marketing speech. Post a link to your project on HN/Reddit, present it at a local user group and setup a mailing list or IRC channel for your project. If it's interesting and useful to the world, you will inevitably get to meet and talk to people that are interested in working on such a project or are already working on similar projects, you can learn from.
Why? 
Ok, again, you are *semantically* correct. As a person who hates pissing off his boss though, I'd *still* have checked with them first. Their proprietary information is, of course, the binary itself which he offers to provide via email.
This is a really good article. Must tinker with open cv and see what it can do. What is the deal with the underscore though? &gt; _, image Ive never seen that before.
Camera.read() returns two values. A flag, and the image. The flag is Boolean as to wether an image is read or not. As he does not care about the flag he sets it to an underscore. 
Nothing magical, just something I picked up when using Go. In Go, you can ignore a return value by setting it to _ like: ``` _, err := DoSomething() ``` I use _ in python when I don't want one of the return value, i could use [1] in the example but I'm just used to _
Can you define reporting? Are you looking to chart and graph your data? Are you looking to pull a csv from postgres? Are you trying to write a daily stored proc to pull stats? If you're looking for charting and plotting, matplotlib is really nice, and integrates fantastically with ipython notebook. However, you could also integrate matplotlib charts with either a Django or Flask webapp.
Yes, 3.0 has yet to catch up. I also assume that the same procedure (or something similar) would work on unix.
According to what I can find eX is just a scaling of degrees so that 1 eX = 1*10^X degrees, is that correct? If that's so I can't see why a conversion table wouldn't work.
Great start, although if you are interested in motion analysis, I wouldn't use *just* the previous frame. I would use cv2.accumulateWeighted to compute the *weighted average* of the *N previous frames*. This will make your algorithm substantially more robust and less sensitive to noise.
`-m venv` is broken on windows - doesn't install the sh version of Scripts/activate. i like being able to use the venv correctly with a git/msys shell.
Thanks alot. I will look into this. I started learning Python 3 instead of Python 2.x. However from what the Internet has to say- there is not much of difference. 
But some of those dead languages absolutely refuse to believe that they're dead and insist they're either still relevant or coming back (even COBOL). Putting them on the list helps contribute a dose of reality. For instance the product manager for Delphi told me at the beginning of 2013: &gt; I'm convinced that in the business world Python has a fraction of the Delphi &gt;influence. Hard data is a good thing to craft realistic worldviews with and we need more of it.
It probably says that the younger-skewing Reddit readers really like Python, and that Reddit hosts the Python discussion group with the most critical mass so it attracts Python users in general.
What do you mean by "do something"?
Beginners lose interest. Other languages *usually* have programmers that have been going at it for an intermediate amount of time, and usually aren't the type to pick something up, and put it down five minutes later.
Sure! The main differences are 1. xray has one array type (DataArray) with any number of dimensions, instead of the hierarchy of Series, DataFrame, Panel, etc. 2. Dimensions can have names (e.g., "time", "latitude", "longitude") that makes them much easier to keep track of than using axis numbers. Dimension names are then used for indexing, aggregation and broadcasting. This is also in the FAQ: http://xray.readthedocs.org/en/stable/faq.html#why-is-pandas-not-enough
My mistake. I knew something to do with WoW was written in Lua. 
Thanks for the tip, I'll play with that !
In openhatch there are hardly many projects other than twisted, open stack etc and most of them are document edits
No problem, glad to help. I write about computer vision frequently over at [PyImageSearch](http://www.pyimagesearch.com), feel free to send me a message if you ever ever need some help.
radix07 All I am saying is if you are good with C or C++, you can pretty much do anything from device driver/firmware to high level UI development. I do not see the need to delve with something like python. With advent of C++ version 11 and boost, the language is fun, fast, strong, jack of all trades. Give C/C++ a try you will be hooked :)
Don't get used to it. In Python `_` is usually used for [gettext](https://docs.python.org/library/gettext.html).
I know, I don't use it if i'm using gettext in a project. This script is not going to be translated for example but I don't use this pattern in django apps for example
What about other people reading your code, especially newbies and your future self? Eventually it'll confuse the hell out of them.
I would recommend not using easyinstall and use pip instead. Also, the I have used Numpy, Scipy, and Matplotlib with Python 3 for years. Don't get discouraged. Package installs are the hardest part of Python for a lot of people.
I think it's most compelling if you want to easily do arithmetic with multi-dimensional arrays. For example, `x - x.mean(dim='time')` always works, regardless of which axis "time" corresponds to. Another use case: you have a 2D array and a handful of associated 1D arrays that share one of the same axes. Storing these in one pandas object is possible but awkward -- you can either upcast all the 1D arrays to 2D and store everything in a Panel, or put everything in a dataframe, where the first few columns have a different meaning than the other columns. In contrast, this sort of data structure fits very naturally in xray.
More why do you need to store it - does another program need to access it? A redis hash is the way to go HSET/HMSET to store attributes for a single object - you'll need to figure out what to key it off of. 
Because python does it all for you. Also, implementing a lot of data structures involves using higher level data structures and ignoring features. There's no need to implement linked lists in python, when you can just use a regular linked list. The lack of pointers also makes things a lot more annoying. There's also the fact that python is significantly slower than C or C++, so if you really wanted to do things quickly, you'd use them, or even Java. It just seems bizarre that you have to try and shoot python in the foot and basically suppress a lot of its features, just to try and teach algos and data structures. For instance, I recently had an assignment where I had to make a chaining hash table, using a list for the table and jury rigging some sort of recursive linked list for the linked list. Why go to all that trouble in python, when you could just as easily use a dict or a set? I guess a lot of that goes for C++ and Java though, since they have higher level data structures implemented as well. So really, people should be learning algos and data structures in C, where you can actually see what you're doing with the primitive data types and pointers. In C, you don't get the luxury of a set, you have to make your own hash table, and understand how pointers work properly to make a linked list. I feel that when teaching computer science, you're better off starting near the bottom, and working up, rather than starting at python, and not touching C programming until the second semester of the second year, where it's not even a computer science specific paper, but actually a computer engineering paper, which all the electrical engineering students have to take as well, so the programming aspect is a bit watered down with computer architectures and other shit.
Great work, although the AVI file won't play for me. I keep getting "VLC can't recognize the inputs format, the format cannot be detected." But at least I can look at the photos. 
I do not buy it looks like it's in a similar situation to nltk, which I have used with Python 3. Python 3 support exists in the upcoming version, which is available it looks like here http://opencv.org/opencv-3-0-alpha.html If you're looking for a way to contribute to open source, this is a great way to do it too.
You're gonna play with the tip? I hope something comes out of it.
Yo mum called, dinner is ready
Before Python, I was writing a lot of Perl. Python was introduced to me at the University of Washington through a group of students, but I wasn't attending the school yet myself. The project had something to do with something that crossed iTunes with Bittorrent. This was around 2006 or so. I can't remember when or how I made the actual transition a year or two after that, but the cleanliness of Python is a big part of what motivated.
*Your 
thanks,guy,i will try this.
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=353#Explanation) **Stats:** This comic has been referenced 84 times, representing 0.2441% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_ckplhdz)
It has to do with your codex. You need to install a avi codex I order for it to work. 
No list of dependencies. Which makes it really hard to try, especially if you don't where to get the `visual` library. :(
If you speak Portuguese try Googling "Python Brasil" :)
Everytime I use Python, I can't *not* think of that comic!
Thanks , downloading to test out now.
This is not helpful. I need to turn a CCTV into a laptop.
it seem that is a good choice,but,i will create multi thread to test a website in same time,so the webbrowser Windows is a big problem,any other support backend webdriver?
Back in 1999/2000, I was into XML and RSS. Quite a few people in that scene used Python (people like Mark Pilgrim, Joe Gregorio, Jon Udell, Uche Ogbuji etc). I've always been a stickler for indentation, so it was love at first sight. Sometimes I can't believe that 13 years have gone by, and I'm almost as crap a python developer as I was back then ("programming" not being a real part of my day job until very recently). 
I use this _ idiom too, its one nice thing MATLAB has, kind of. Gettext injecting a global _ into my project is much more offensive than using _ to mark a useless return value as useless.
AVI is only the format of the container, not what is used to actually compress/encode the video itself. You may need to either modify the script to use a codec you have, or install the one the OP is using.
[IP Webcam](https://play.google.com/store/apps/details?id=com.pas.webcam&amp;hl=en) may come in handy, I've used it a few times for Skype sessions as I don't have a webcam. 
I've been working with ArcGIS for about a year. About 6 months into that work, I got fed up with our antiquated processes and looked into automating a lot of weekly and monthly reports. With python, it's just so... easy. Before we had a Golem made of SPSS, VBA, Excel, blood, and tears. Now it's just a few custom python scripts that are easy to debug when things change. Heck, we even fire them off from access when we're doing our data pulls. Saves a lot of time.
I've delt with this for a school project. You need to have encoding codex to save pictures into a video. Being able to view other .avi doesn't mean you have the codex to compress them to avi
I learned Python at Uni as part of the 'Numerical Methods for Physicists' course with numpy/scipy/matplotlib. I immediately loved it (except for matplotlib, but you get used to mpl's syntax).
I'm not sure that reddit subscriptions is a good way to evaluate how popular languages are though... I'm not subscribed to all the languages I program. 
Why would anyone hate you for that? Someone asked the question, it's not like you're advertising it out of the blue. No programmer worth his salt sticks to 1, or even 2 or 3 or 4 languages. I'm primarily a Python developer but I've used Lua for all sorts of things over the years. It's a perfectly good, simple scripting language and with LuaJIT it's an extremely fast simple scripting language. LuaJIT is a lot more mature than PyPy is at the moment so there's no question that Lua has some significant advantages over Python when it comes to performance.
I appreciate the explanation. Thank you for that instead of the "lot but y" anti-explanations. And yeah, I'm avoiding this all together. Don't worry! 
Well this is a Python subreddit... I actually spend about 80%+ of my time using C or C++ for low level embedded system or PC applications with Qt. But Python has it's merits in many applications outside of scripting and web. Sure I could do everything in C, and make it work fine, you can make anything work in C if you try hard enough, but if there is a faster and more efficient way to do something that can be just as reliable, why not do it? The question is regarding the feasibility of using Python in an environment with limited resources, not weather Python is better than C/C++.
Ahh, gotcha. Didn't think of that.
I dunno. Something like IPython maybe that takes a hold of a professional group and then expands as a more mainstream tool and even gets recognition in other language communities to be ported to their ICode as well.
ATTENTION anyone competent: please be advised that Mr. Hannibal and associates "would definitely be willing to even pay".... "like $100". Don't be foolish like me, and do work pointlessly. I corresponded with him, scoped out the project, gave a very reasonable estimate, received a "thumbs up" from him, did more work, informed him of that, only to find that "their budget" is "like $100". Unacceptable and borderline-devious.
I see `try...else` in use quite often. I wouldn't call it "forgotten", especially not in the same way that `for...else` is.
else for try statements is very useful and I still see it often, I wouldn't really call it forgotten.
Your first line in the function is ending the function. You should save that as "bmi" (or some other) variable instead of returning it. Then change your print statements to "return". Also, in the future, consider posting to r/learnpython. It's a better fit for questions like this. Edit: Forgot to mention that you don't want reuse names. So if you make the formula line into a variable and call it "bmi" (which would make the lines below it work), you should rename the function.
In your code, lines 3-7 never get executed. As soon as you finish line 2, your code returns from the function. Your return statement should come after you've done whatever processing you need to do. In this case, it should move to Line 8.
Ahh I see, thank you for the information, and I was unnaware that subreddit existed, should have checked the side bar... doh! Thanks again 
The 'return' statement ends the function execution immediately. Also, you've failed to set the bmi variable. Instead you probably want line (2) to asign the bmi variable, and then return bmi at the end of the function. Another unrelated thought: if the weight and height are passed in as integers, that calculation will do integer division, while you probably want float division if you ever want to see fractional BMIs.
It uses YAML by default. There are other ways to go about defining your states (e.g. writing actual Python).
Hi, it's great that you're learning python, good luck on your adventure! The reason you're not seeing the print statements is because return (w*703)/(h*h) makes the function exit with the specified value. As return exits the function, the code below it is never reached. Consider the following fix: def bmi(h,w): score = (w*703) / (h*h) if score &lt;= 18.5: print ("You skinny fok") elif score &gt; 18.5 and score &lt; 25: print ("not bad m8") return score print bmi(70,150) that way you save the calculation in a local variable, use it to print your messages, and still return it as the function's return value. Rule of thumb: nothing gets executed in a function after the return statement* *there's actually an exception to this but don't worry about it just yet!
Thank you everybody for your advice! It is greatly appreciated ~ 
I'm curious why Python is even more popular than Javascript. 
Thank you. Much better articulated than I could manage. It's like, I know it's helpful to spell things out for people but that's my whole point about what the problem is: spelling everything out for everyone!
by the way, and now that we're at it, it's generally a bad idea to include _magic numbers_ in your code. Those are numeric constants that seem out of context, and make the code hard to understand for an outsider. What about… def body_mass_index(height, weight): imperial_constant = 703 underweight_limit = 18.5 overweight_limit = 25 bmi = (w * imperial_constant) / (h * h) if bmi &lt;= 18.5: print("You skinny folk") elif 18.5 &gt; bmi &lt; 25: print("not bad m8") return bmi print body_mass_index(70, 150)
Was stuck in a PHP shop and replacing daemon/service scripts written in PHP, they wouldn't me use C/C++ so I decided to learn Python and went from there.
In general, yes, it's a bad idea; Ruby allows monkey-patching damn near everything, and there are plenty of examples of that causing major issues. But on occasion you want to do something even if it's a bad idea, and that follows python's "we're all consenting adults" philosophy.
Here's a BASH script that determines which version it will be executed with based on the shebang: failmsg () { echo $1; exit 1; } [[ -n $1 ]] || failmsg "No file name provided." exe="$(head "$1" -n1 | cut -c3-)" ((which $exe &amp;&gt;/dev/null) &amp;&amp; ($exe --version)) || failmsg "Bad shebang." exit 0 Wrong sub for this I know. It was just something I tried real quick.
Anyone care to comment on why the else is needed? I mean, the statements to execute when exception is not raised can just follow the statement being "tried". try: &lt;possible exception causing statement&gt; &lt;statements to execute when exception IS NOT raised&gt; catch: &lt;statements to execute when exception IS raised&gt; finally: &lt;statements to execute in either case&gt; Is the "else" preferred for the sake of clarity?
The `else` statement in a `try:` clause will run only if no exceptions were caught. Unlike `finally:` which always runs or an `except:` statement which runs for specific cases. Here's an example of else: from __future__ import print_statement import errno try: with open("foo", "w") as file_: file_.write("foobar") except OSError as e: if e.errno == errno.EEXIST: print("file exists") else: raise else: print("file created") 
Purely accidental. I was doing bioinformatics and I wanted to learn either Perl or Python. Since this was 5 years ago, Perl was king. I tried to install Perl and couldn't get it to work, so I learned Python.
To clarify further, the else: section is most helpful if you are trying to execute statements that are likely to raise an exception that you don't want handled by your except: block. Say something like: try: &lt;something that could raise IOError&gt; except IOError: &lt;some code&gt; else: &lt;something that might raise a different IOError&gt; That form isn't super common (I don't think I've come across a non-contrived example yet), but if it's what you need, it's just about the only clean way to do that.
Thanks, I really appreciate it! Even cooler things are coming: two new plugins, one for the IPython notebook and another for conda (to do package management inside Spyder).
It sounds like you need to refine what exactly your end goal will be as "reporting" is a fairly vague term. I think the nightly cron job is a great idea. It would be beneficial to write "stored procedures" to build your data objects nightly and dump the data into staging tables which your web interface can then directly load. From there you can use something like django reporting to build some basic charts for the users. Even simpler, building a well-styled html table with some jquery/ajax embedded could be a nice way to provide the user the ability to sort/filter the data based on their needs.
it's useful if you want to defer an exception to the outer handler. try: try: A() B() except: # handle both A() and B() C() except: # handle C() with else: try: try: A() except: # handle A() C() else: B() except: # handle C() or B()
There are also built-in algorithms for foreground-background segmentation via change detection in OpenCV; check out the video analysis module (and the BackgroundSubtractor*** classes). Most should work out of the box.
IMHO you should *always* put the thing that's not part of the "might raise an exception" into the "else:" block, rather than following the target code in the "try:" block, regardless. This serves to make the code self-documenting as to its intent. if we compare: try: value = data["some_key"] return process(value) except KeyError: return process(None) Suppose we know that `process()` has no chance of raising a KeyError or anything else. The code above works fine. But does the *reader* know that `process()` can't raise a KeyError? What if we had this: try: value = retrieve("some_key") return process(value) except KeyError: return process(None) Now it's even less immediately clear which part of the code might raise a KeyError and which might not. Compare this to using `else:`, for no other reason than to clearly specify the intent: try: value = retrieve("some_key") except KeyError: return process(None) else: return process(value) The code without the `else:` is just as bug-free as the code with it, however, the `else:` version makes the intent immediately clear - we mean to catch a KeyError from the `retrieve()` and nothing else. The presence of "except" and "else" together give the reader a simple cue that this is really a conditional block with two different outcomes, rather than one large block with a possible "interruption". This is a clear win for "readability counts" and I always go for the `else:` if it can be applied.
An ex-coworker of mine and I were trying to figure out which languages we wanted to develop in in the future (moving away from PHP) and it was a toss up between Python and Ruby. We each picked one to evaluate and I chose Python, it was a great decision :)
Back around maybe 2000 or so I was waiting for an installation of Red Hat Linux to finish and I kept seeing "-python" or some other variation of the name "Python" appearing on package names. I looked it up out of curiosity afterwards and thought it was pretty neat, and giggled at the Red Hat installer's name: "Anaconda" which had been written in Python. Found that there really wasn't much I didn't like about it and within a few years I'd created some GUI desktop apps with it and then from about 2008 started making web apps with it. Haven't looked back since &lt;3 I still use other languages / stacks to keep my horizons broad and my perspectives varied (also depending on what my current employer wants / needs for their clients), like C#, ASP.NET, PHP (legacy apps only!), Node.js, C++, and starting to learn Haskell now. One thing I always find is more things to appreciate in Python, and often moreso the things around the language rather than the language itself. I mean things like the documentation, consistency of decision making and design of the platform and standard library, those sorts of things. I also have the Zen of Python up on my wall and I use those principles in whatever language I am working with and to inspire my own designs. Clearly Python has played a big part in my programming career, in many ways :)
This is useful for a quick hack, but it's a very inefficient form of interprocess communication. (Ideally you'd have either the Python or the Ruby script create listening socket, perhaps a Unix socket, and then the other script can send the data as JSON or in a more efficient format like msgpack, protobufs, or capnproto.)
That's a common convention, but one you don't have to use. I've been developing in Python for a decade, and I mostly run into gettext usage for web-UI based packages. Everywhere else, using underscore as a "I don't care" placeholder is very common. In any case, I doubt his command-line CCTV script is going to need multi-lingual translation support.
That's actually pretty easy. Just follow these simple steps: 1. Place CCTV in your lap. 2. There is no step 2.
lol. I'm just annoyed that more original content gets stifled by the number of "can you guys give me a list of interview questions" posts.
Do You have a proof why it works sometimes? And this is not my answer, btw. I've read about accessing py object through id by means of ctypes several time, so this way is legit. And who cares, that person doesn't know what he\she is doing? This called learning process, making mistakes and fixing them. I don't think that someone will commit such code to production. So, take it easy)
Everyone else has already answered the question so I'll mention something that you will find very useful as you dive deeper into python: the command line debugger. You can use this to make python pause anywhere within the code. You can then type and try out various expressions to see what is actually happening. You can also get a list of all the variables that have been created. http://pythonconquerstheuniverse.wordpress.com/2009/09/10/debugging-in-python/ http://stackoverflow.com/questions/4228637/getting-started-with-the-python-debugger-pdb It is really hard to spot mistakes when you are just starting out so the debugger can be an invaluable tool.
That's an interesting idea. My current solution is obviously a heuristic, and I'd like to integrate others into the tool; something like this would work well. Of course not all code bases have a shebang, but the presence of one could be very useful.
What else could it be? If we talk about the general community size of programming languages, I would assume PHP is much larger than Python, still reddit somehow manages to attract a lot more Python developers. I am actually one of those that decided to join reddit, because I heard it's written in Python and one of the first subreddits I join was obviously /r/Python.
Well, it's probably similar phenomenon to bell curve
The main motivation for this comes from my refactoring tool traad: https://github.com/abingham/traad Traad uses rope, and rope can only work with code which is compliant with the same Python major version as that running rope. I'd like to be able to launch the right version of traad (Python 2 or 3) without asking the user, so I need to be able to detect the major version of the source upon which traad will work. Hence a tool like this. Obviously version_probe is making a "best guess". I have yet to find a fool-proof way of doing this, and there are numerous ways that version_probe could be improved. As long as those ways aren't too time-expensive, I'd be happy to consider them. The shebang idea mentioned above is a real possibility, for example.
I would add, though, that a bash script is only half of the solution. Whatever solution I use needs to be as platform-independent as possible, which is one of the reasons version_probe is itself a Python script. The basic technique you describe can, of course, be implemented in Python.
Just won a convert. Thanks for the clear explanation of your usages.
Work. We were being weighed down by the insane "build times" involved with testing, debugging and adding/removing modules in drupal. One of the lead devs was trying out django and it fit the bill really well. In a few weeks time, they had all of us php boys on python.
/r/Minetest, some sort of Open Source Minecraft, has a heavily used modding API using lua. Maybe you want to check that one out.
He didn't *include* it.
Python already has this builtin with [assertItemsEqual](https://docs.python.org/2/library/unittest.html#unittest.TestCase.assertItemsEqual) in unittest.TestCase
I won't even try this without an example.
You have convinced me.
I was scared he was abandoning Python for [Ada](http://en.wikipedia.org/wiki/Ada_(programming_language\)) (a Pascal-like language whose severely strict typing is the exact opposite of Python's duck typing) EDIT: Typo in typing
&gt; Why are you so stuck on this idea of a configuration management utility executing things in a specified order? I illustrate several thing you can do with configuration that you can not do with a script in the article. &gt; I would be really, really surprised if Buildout came anywhere close to the power that tools like Salt or Puppet can provide. From other comments here it seems that Salt in fact defines configuration, I haven't looked into it much. Next up for me (but that will take months before I have time) are looking into Puppet. But from what I can see, Puppet files seem also to be about defining configuration, and not writing scripts. If they can get close to the power of Buildout I don't know until I have tried them.
Python is most definitely imperative and not a configuration syntax, so that answer was not entirely clear. ;-)
If I had to do this, I would probably mess around with calling some AppleScript functions from python (import os, and then read the documentation about the osascript command e.g. os.system("osascript ...") )... this link might help [Stack Overflow, bring to front](http://stackoverflow.com/questions/14947890/bring-a-window-to-front-in-applescript). This is assuming you have a mac (you had mentioned terminal) which isn't a definitive assumption, but if it's true, then this can help. 
I am so happy that Guido is for women programming, I am all for equality. However, I am appalled by the sexism displayed by Guido at Pycon 2014. I am sure that SJWs and SRS will not truly understand what I am getting at, so I have been scared into using a throwaway. I just wanted to say that by allowing only women to ask questions you are being just as sexist as the people who do not include women. When you do something like this, it only enforces the fact that "women are different" (I DO NOT BELIEVE THIS) and further pushes them into their own group. I get that we want women to participate, but this is not how it should be done. Please offer me your reasons why my opinion is wrong, maybe I do not understand. &gt;prepares for downvotes.
I used it in actual code a few days ago. I was so happy!
Oh hush. Yes do prepare for down votes. When women comprise such a tiny number in the science and technology fields radical measures are required if we want to address this otherwise it will likely be centuries before any noticeable change occurs. I'm sure your world won't cave in because woman got to ask the questions for once.
Only a few comments in and it's easy to see why women are turned off by tech. Perhaps they prefer this charmer ... http://arstechnica.com/information-technology/2013/07/linus-torvalds-defends-his-right-to-shame-linux-kernel-developers/
And if we want to get really fancy there is always the Lucas-Kande algorithm and Optical Flow.
&gt; Is the "else" preferred for the sake of clarity? Also semantics, if `&lt;statements to execute when exception is not raised&gt;` happen to raise, they'll be caught by the exception handler. In the `else` clause they are *not* covered by the exception handler at all.
This is the first release where calling a C library with cffi+pypy+jit is faster than c-api+cpython \o/
the "else" keyword is a bit confusing, which is maybe why its not used much. It's meaning is more like "then", at least I would find try...then more intuitive. I suspect they didn't want to introduce a new keyword just for this feature, which makes sense, but maybe makes it a bit more obscure
No comment on the actual article, but if an organization wants to exist in technology/open source spheres maybe they should pick a less confusing name
Yeah, I think finally is more unused than else.
`import antigravity`
Wanted to write a script to ssh into 10 boxes at once and send me the logs, loved it and kept coding it, this was about... 2 years ago? I used to code php/perl but python is so clean, it makes my OCD happy.
All you're saying makes perfect sense. Except you're missing a tiny little point: in order to treat women somewhat equally, the people who are not misogynists need to compensate for the misogynists. Think about it. If the non-misogynists just were normal nice, and the misogynists keep doing their thing, by definition the misogynists win.
Its not mens fault there is not enough women in science/IT. Who stopped them from joining 20 or 30 years ago? Who stops women today from learning and programming? 
Good point and to be fair to the guy he wouldn't know any different. When you lead a comfortable middle class life it's easy to think you've arrived where you are in life because of your talent and not be aware of the huge social advantages that effectively means you get to start the race halfway in front.
If everyone got where they were on enterprise and endeavour as you say then every woman in Africa would be a millionaire. 
Which is why I added the caveat 'when it might be ambiguous'
I prefer to think of the 'else' as an 'and-then' that is bound to the 'try'. So try ... and-then ... try: # statement that might cause an exception except: # deal with the exception else: # and-then # there was no exception so do this finally: # always runs ... usually cleanup 
Codecademy.
This is fantastic! I never knew it existed but it is certainly a much cleaner option for most of my try/catch blocks than just jamming everything in the try. As a matter of fact I've had several occasions where I've felt wrong doing just that thing, but had nothing to go to. Time traveling Guido strikes again! 
It's always someone elses fault when you fail, and always your own competence that you succeed :P
Maybe it's not mens fault. But who cares who's fault it is? It's not my fault that the climate is changing either, it's not currently living white americans fault that blacks have suffered for centuries. But we are the ones with the power to make all those things better than yesterday. That's pretty cool, and something we should be proud of instead of whining "it's not my fault" and letting injustice continue.
Dat downvote on that comment -_-; Here's an upvote for stating something that should be obvious.
How about this? try: value = retrieve("some_key") except KeyError: value = None return process(value)
Some features from python 3 were backported into python versions as old as 2.6. In particular, as you have noticed, the print() function works the same as the python 3 implementation in both python 3 and 2.6/2.7 (*Edit: this isn't strictly true, see reply by /u/sushibowl*). However, old features from 2.x were not ported to python 3, since that would have defeated the purpose of the new version. Some other features that aren't directly supported in 2.x can be obtained using packages, such as `__future__` or `six`. If you're not using those packages, you could run into cases where your python 3 code does not function as expected in python 2.x. For example, in 2.6 you have to do dictionary comprehensions with `dict()`, whereas in python 3 you can just use the braces `{}`. Another great example is division. `print(1/2)` and `print(1//2)` will give the same answer in python2 (`=0`), whereas in python3 the first will print `0.5`. 
[Udacity](https://www.udacity.com) - It's gotten rather huge as of lately. And instead of paying for you you can browse through the course and still do them.
I don't have much experience with Python 2 but I think the situation is basically that print('Hello World!') is valid Python 2 code. The parentheses are extraneous for 2.x but don't break anything. Also, this should be in r/learnpython I think.
It's true that some things from python3 are backported into python2, but the print function is not. This is in fact impossible since "print" is a keyword in python 2, and no function can have that name. Try `print("hello", "world")` in both python 2 and 3 and you'll see what's actually going on here.
 &gt;&gt;&gt; ("hello world") 'hello world' your ```print ('hello world')``` gets evaluated to ```print 'hello world'``` so python2.x has no issues. But no ```( )``` in function is a problem for python 3. This is what I think. 
This is the correct answer. In python 2 you're still using the print statement, it's just that when you follow it with something in parentheses you don't need a separating space. The difference can be clearly seen when you try more complicated things: &gt;&gt;&gt; # here, it's a print statement with a tuple &gt;&gt;&gt; print("hello", "world") ('hello', 'world') In python 3: &gt;&gt;&gt; # here, it's a function call &gt;&gt;&gt; print("hello", "world") hello world
Ah sorry, yes you are correct. I often forget because most code that I write with backwards compatibility in mind I use `__future__` which includes the `print_function`
Apologizes for posting it in the wrong thread. 
PhD student in AI here. I'm using Orange on a daily basis... but not its visual part. True, the interface is gorgeous. You can visualize, plot, combine algorithms in a pretty neat way... However, I'm using the Orange API as a machine learning library, much like you'd use scikit-learn. The documentation is... tricky to understand (the natural purpose of Orange is "work with plots and graphs", not "work with lines of code"). I'd recommend Orange to discover machine learning &amp; data mining, to see how algorithms behave. You'll have fun with the interface.
While "time" is all well-and-good for just generic performance testing, there are much better ways to do this. Using [perf](https://perf.wiki.kernel.org/index.php/Tutorial#Counting_with_perf_stat) gives you a lot more information on performance, including cycle count, instruction count, cache misses, context swtiches, etc. Good to see that PyPy is moving right along, though.
I dont want the injustice to continue. I want the injustice to stop. Thats why I dont want special treatment of women compared to men. Equal, and thats it. Just because white men centuries, or decades, ago enslaved black men, doesnt mean blacks should now enslave whites. 
Yes, typically `python` will execute using the 2.x interpreter and `python3` will execute using the 3.x interpreter. It could depend on the system though, so if you're using an unfamiliar system you will want to check first. 
ummm ... not sure what you mean. The &lt;statements to execute when exception is not raised&gt; (in the original comment) get executed exactly as if they were in the "else" block. Both blocks of statements get executed when exception is not raised. So they are equivalent. Right?
Yes, makes sense.
It works *sometimes* because some implementations of Python may use a pointer address as the ID. But you cannot rely on this.
Orange 3 should be pretty great, will able to work with database stored data.
And your life is [any less](http://www.reddit.com/r/ruby/comments/2gt1mn/is_anyone_developing_on_windows_what_are_some/ckmpyhd?context=3) middle class? Where do you get off saying things about me and acting like you have any inherent advantage in knowledge about how the world works. Your opinion might as well just be as skewed, if not more so, than you perceive mine to be. Also: &gt; start the race halfway in front You can't be serious. You really think you start with a 50% advantage in the world of tech because someone is male and middle class? Please revise your opinions. If you need to resort to criticizing my person instead of my argument I think that's saying something.
I understand that, but Ada is more well known as a DoD programming language. Why not the Lovelace Initiative?
And while you're at it, `import this` and `from __future__ import braces`.
When you were a young woman in computing undergrad, you're saying you didn't face any different social pressures? 
I'm not even sure of the point you are trying to make with this inane question. I couldn't tell if I faced different social pressures, just as much as you couldn't tell if anyone else did, since you probably didn't attend as a woman and a man at the same time. I said in my argument that there are social differences, and those differences in environments probably lead, among other factors, to a different choice in majors.
&gt;The whole "group-think" mentality is really strong among developers. Most are easily convinced the group is correct ... since they assume it's harder for 10 people to be wrong than 1 person ... and it's easier to just believe the group than to engage in the practice of thinking. If no-one is taking the time to think over the concepts or test the validity of the group-think, you have to imagine the quality of thought they engage in and ideas they produce ranges from that of a severely brain damaged all the way up diagonally to the criminally insane. Cool armchair psychology.
I was feeling the great divide in the php/web development community (local &amp; overall) as in lets do everything through a cms. I felt that I needed something more than just web and something that required more skill. Although I live in a crappy area (tech-wise), personally I am happier since python allows me to do a lot more.
&gt; Now I may be a mean cuss. But I'm the same mean cuss with everybody out there on that ~~football field~~ mailing list. The world don't give a damn about how sensitive these ~~kids~~ developers are, especially the young ~~black kids~~ women. You ain't doin' these kids a favor by patronizing them. You're crippling them; You're crippling them for life. That came to mind immediately when reading your comment. Two different approaches, certainly.
Exactly.
&gt; brackets parenthesis*
If he spoke to me like that he'd get a knuckle sandwich. Maybe you think some people reach a status in life where they are allowed to bully people but I don't and nor I suspect do most women. Did you consider such people may have got where they because they are good at pushing people around, aside from any talent they may have? Such macho posturing is hardly conducive to a good working environment that's open to all.
If you want to be sure, use ``python2 filename.py`` and ``python3 filename.py``, but really you're now talking about your shell's features, not Python. Under Linux, ``python2`` is just an executable name, and it probably ends up calling something like ``/usr/bin/python2.7``. You can check with the ``which`` command, which will tell you the full path to the executable. Here I am running the standard "bash" shell: [steve@ando ~]$ which python2 /usr/bin/python2 [steve@ando ~]$ ls -l /usr/bin/python2 lrwxrwxrwx 1 root root 6 Jan 22 2013 /usr/bin/python2 -&gt; python So on my system, python2 calls /usr/bin/python2, which is a link to /usr/bin/python. (Which happens to be Python 2.4, for my sins.) You can also use the ``alias`` command to create your own pseudo commands: ``alias python=/usr/bin/python3`` and now ``python`` will call Python 3, *but just in this shell* and nowhere else. So you can customize your system and make it as useful or confusing as you like. Because I frequently use old versions of Python, I have a set of aliases and environment variables defined automatically whenever I log in: # extract from my .bashrc file export PYTHONPATH="/home/steve/python/" export PYTHONSTARTUP=/home/steve/python/utilities/startup.py alias python1.5='env -u PYTHONSTARTUP python1.5' alias python2.3='env -u PYTHONSTARTUP python2.3' alias py3=python3.3 These are not strictly Python features, although the PYTHONPATH and PYTHONSTARTUP environment variables have special meaning to Python. 
Thanks alot!. This is definitely helpful!
Yeh, I'm not sure how useful this BASH would be. I could release a Python 3 project that uses '`#!/usr/bin/env python`' on Arch, but on my current system it would report `Python 2.7.5`. It could really report almost anything. I could have `python` linked to something else entirely. It was just an idea. I think the heuristic approach is the way to go.
He's rude to everyone.
Noob question: Why webscraping is so popular in python?
Link for the lazy: http://legacy.python.org/dev/peps/pep-0008/
I never really looked into the distinction, but it appears it is more precise to call them parentheses as you suggest. According to WP though there are several countries where it's common to simply call them brackets, including Canada (where I live.) http://en.wikipedia.org/wiki/Bracket#Terminology_and_names_for_various_symbols
Software and Systems engineering - I moved from dev into systems then into devops - needed it to scrape/move/create all sorts of auxiliary changes and reporting. Automation is big here.
I was just playing with `lib2to3`, and it looks like the machinery is there for you to use if you didn't want to shell a subprocess and parse stdout (maybe not parsing, but checking). Here is the most basic example I could come up with, I trimmed it down to fit in a reddit comment: from lib2to3 import refactor from lib2to3.pgen2.parse import ParseError import sys class MyRefactoringTool(refactor.RefactoringTool): """ Look at: refactor.RefactoringTool, lib2to3.main.StdoutRefactoringTool """ def __init__(self, *args, **kwargs): refactor.RefactoringTool.__init__(self, *args, **kwargs) self.output = [] def print_output(self, old_text, new_text, filename, equal): # You don't really have to save the output. # You could set a flag like: self.output = True self.output.append(new_text) rt = MyRefactoringTool(refactor.get_fixers_from_package('lib2to3.fixes')) try: # File to parse is the first argument given. rt.refactor_file(sys.argv[1]) except ParseError as ex: parseval = getattr(ex, 'value', None) if parseval in ('print', 'from', '**'): # Happens when parsing Python3 files # though this still needs investigating. print('Python 3') else: print('Syntax/ParseError: {}'.format(ex)) else: if rt.output: print('Python 2') else: print('Python 3') It would take more testing to be sure, but so far it has been correct for the scripts that I used it on. After looking into this, Python3 files fail with certain `ParseErrors` where `ParseError.value` is set to something meaningful like `print`, `from`, or `**`. Other `ParseErrors` are simply bad code.
Not a benchmark to be taken serious. See points 2 and 3 from [Create benchmarks and results that have value](http://kellabyte.com/2014/02/12/create-benchmarks-and-results-that-have-value/): &gt; I seem to encounter 3 problems the most. &gt; 1. The setup makes no sense and testing the code in a config it will never have the privilege to run in. &gt; 2. The benchmark is way too short to prove that this code/technology/whatever is a good idea. &gt; 2. Published results that offer statistics that have very little value that don’t reveal anything.
well it is easy. And short. the scraping bit was 5-6 lines in the code. The entire thing is ~60 lines. And it does quite a bit.
Messing with Gentoo's package manager back in 2001, and had to read a lot of python. Started falling in love immediately. Left Perl and PHP behind and never looked back.
it is the 79 char line thing right? I ran autopep8 on it just now and thats all it changes.
No example at the end? plz2addinstantgratification
What do you mean?
In Py2, print is a keyword and the parenthesis get stripped (would you add a comma at the end before the closing paren, it would be interpreted as tuple). In Py3, you need the parenthesis because print now is a function. This syntax change explains the one-way behavior you are observing.
Nearly right - see my own answer.
You can script nginx with it.
Summary: Django Dynamic Fixture (DDF) is a complete and simple library to create dynamic model instances for testing purposes. It lets you focus on your tests, instead of focusing on generating some dummy data which is boring and polutes the test source code.
Awesome write up. I love it. I did something similar a few months back using a mix of bs4, re, and urllib2. [This one used BeautifulSoup and regex](http://redd.it/2dtnvt) [This one was just urllib2, just to see if it could be done cleanly without bs4](http://redd.it/2d46f2). I wouldn't recommend the second way, it only only worked for me because of the way that specific comic ordered the comic pages by specific number and filetype. Still useful for learning purposes though. These were fun projects, I think everybody should give scraping a shot at some point, data collection can be really useful. 
Being critical is the right thing to do with any benchmark. I'll try to address why I think this passes the bar. &gt; 1\. The setup makes no sense and testing the code in a config it will never have the privilege to run in. I was helping someone recently with some code they were writing for their thesis. The overall bottlenecks are exactly the kind of thing that is shown here, being a large number of `set` operations in a very trivial loop. In that sense, the configuration makes sense. &gt; 2\. The benchmark is way too short to prove that this code/technology/whatever is a good idea. PyPy no longer needs to be proven. Hopefully everyone knows that it's fast. Not nearly as fast as C most of the time, though! I just found it interesting that in the case of operations predominantly on medium-to-large sets particularly, PyPy can be as fast or faster than C++, even when optimizing the C++ to a somewhat reasonable standard. This benchmark is very much related to a few costly things, but I think that — *as long as you don't extrapolate the result to things it's not showing you* — this benchmark can be useful. &gt; 3\. Published results that offer statistics that have very little value that don’t reveal anything. The particular numbers here, eg. 0.3s and 0.4s, are of course not going to help anyone. But I think the idea that PyPy is really fast at fixed-sized sets of primitive types is at the very least encouraging, and I've tried to keep the benchmark honest with regards to that. Considering that this workload exists (see my response to 1.), this benchmark seems like it has use. --- But again, I agree that people should distrust benchmarks. PyPy isn't faster than C++ most of the time. Understanding *why* this benchmark is unusual is important for getting something useful out of it. It's certainly not the case that fast code in CPython is fast code in PyPy. I made several changes I expected to slow down code from my experience of CPython that PyPy actually *preferred*. But the same thing happens with C++ as well. For example, calling `s.reserve(number)` actually slowed operations down, which makes sense in retrospect but is completely counterintuitive. GCC's `unordered_set` also has a default load factor of `1.0`, which is a really poor choice. 
Good idea; I'm ashamed I neglected this. They are &gt;&gt;&gt; pypy --version Python 2.7.6 (3cf384e86ef7, Jul 09 2014, 04:28:24) [PyPy 2.4.0-alpha0 with GCC 4.9.0 20140604 (prerelease)] # &gt;&gt;&gt; g++ --version g++ (GCC) 4.9.1 The Gist is updated.
Studied C in college, circa 2003 or so. Forgot all of it. Dabbled in Java in 2009, failed two JCSA certs, realized I was in over my head and not taking that stuff seriously. Forgot about it. May 2014, cramming for MCSA for months, utterly miserable, realize I need to get off this support career path. Interested in programming, said "why not?" and grabbed Python because the simple syntax meant (hopefully) an easier time ironing out the concepts. It worked. I'm still interested months later, still learning stuff, and am now trying to pick up Java again as I don't have any current projects I wish to do right now with Python, though I'm sure something will come up later.
I used to use regex for html parsing too. Scraped a few anime and manga sites that way. Then I read [this](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454). Some months back I was looking for a list of movies to use in a Hangman game I was writing for my mom's tablet. Scraped wikipedia. It comes in handy at unexpected times.
I've read that too. And welcoming our new eldritch abomination overlords is a perfectly good reason to use regex if I've ever read one. :)
You are prejudiced and ignorant. You are exactly what you claim me to be: entitled. You think growing up less fortunate than me (assuming that is even the case) puts you on a higher pedestal, your opinions are somehow more correct and I'm not good enough for you to impart your flawless wisdom on, because "it would be lost" on me. You are disgusting, and the fact that you think it's okay to put me into some category that has no relation to what we discussed, just because we disagree on something, makes you look like an asshole and afraid to continue this discussion. Oh well, I suppose it would be *lost on you* anyways, right?
Hate to burst your bubble, but ESPN will likely block your IP address if they catch you doing this. http://disneytermsofuse.com/english/ &gt; *Additional Restrictions on Use of the Disney Services* &gt; &gt; We do not allow uses of the Disney Services that are commercial or business-related, or that advertise or offer to sell products or services (whether or not for profit), or that solicit others (including solicitations for contributions or donations). You agree not to knowingly or recklessly introduce a virus or other harmful component, or otherwise tamper with, impair or damage any Disney Service or connected network, or interfere with any person or entity’s use or enjoyment of any Disney Service. You agree not to use any software or device that allows automated gameplay, expedited gameplay, or other manipulation of gameplay or game client and you agree not to cheat or otherwise modify a Disney Service or game experience to create an advantage for one user over another. ***Additionally, you agree not to access, monitor or copy, or permit another person or entity to access, monitor or copy, any element of the Disney Services using a robot, spider, scraper or other automated means or manual process without our express written permission.***
"... your opinions are somehow more correct and I'm not good enough for you to impart your flawless wisdom on ..." Sounds about right to me :-)
Some of those in-line comments are also not pep8 compliant. In-lines should have two spaces from the end of a statement and a space between the comment and the pound sign.
Oh. I see. Will put that in there. Didn't occur to me.
I have no specific idea, but am very interested in the answer. The best I can suggest is to read books like [How to Win Friends and Influence People](http://www.amazon.com/How-Win-Friends-Influence-People-ebook/dp/B003WEAI4E) and [Difficult Conversations](http://www.amazon.com/Difficult-Conversations-Discuss-What-Matters/dp/0143118447). But I don't really know how to specifically change people's minds on that.
Is importing random optimized away in the python version? It doesn't look like you're using it (anymore?) such that even importing it might cause a performance overhead; however slight.
A picture is worth 1K words.. :) edit: so that means you need about 2.5 pictures
I would say that you're right, but it doesn't really matter. If the code that exists works and isn't dangerous, spend your energies on something more important. The point of pair programming is to work WITH someone. Make your point with him, but if nothing is hurt, move on. The messy codebase is the reality and you'll likely never be empowered to rewrite it entirely, so it's best to not bother sweating it too much. This might seem like a "get over it" response, but that is far from my intent. The reward for being right in this case is nothing. Winning him over to your side doesn't actually yield anything meaningful.
On a related note, why is webscraping so popular? It's always fragile and so requires maintenance. Half the time you are dangerously close to violating a law or TOS based on what you're doing with the output and how you are impacting their systems. Finally, it's very common now to have an API available for sites that have anything worth sharing, so use that (yes, sometimes you need to pay). 
Done. Thanks for the input :)
autopep8 messed up that height line. The comma spacing is hard to do. Will need practice. Will update. Thanks for the input :)
Aren't the penalties for getting caught violating TOS potentially very high? I'm thinking back to Aaron Swartz, but I'm not really too familiar with the legality and actual enforcement. I simply choose to stick to one rule: leave scraping gigs alone and sleep easy at night without any such worries.
Yea, webscraping is very fragile. Just about all of my past scrapers don't work anymore. One of the anime sites I scraped has even stopped distributing free anime altogether :P Scraping is obviously for when there are no APIs or money to pay for API service available. 
I fixed the code, for starters. If everybody was real, and had subscribe in it, copy and paste. Python is super duper important with dat spacing.
Yeah, if it's not a gated pay site, they really can't do much. Well, they could block your IP.
I use sublime. It should have the feature too. I suck at remembering shortcuts. Should check it out.
Previously you had `everybody:subscribe()`. I didn't recognize the use of the colon with methods in a package.. :P
I may have had a brainfart regarding that, though. It's back to . I use multiple programing languages so sometimes i get a brain fart
* baseball bat * butchers knife * porn featuring the guys wife * eat large quantities of spicy bean filled chile before going to work. Bent as needed to clear the air. I'm tired but these four ideas came to mind immediately. 
I have Sublime (2) as well. I don't see the option, unless you're using an additional package (or I'm blind - entirely plausible).
That was the very first thing I thought. 
The problem here is that feminism has nothing to do with woman in tech. In fact the world would be a whole lot better off if the radical feminist just up and died tonight. The problem is how do we create a positive environment for real woman in tech. To put it bluntly programming and the related fields are not all that enticing to woman and I think the problem goes deeper than the perception of the geek culture. 
At least she accomplished something In life! What has the average feminist accomplished? Not much that is constructive really. 
The problem here is if woman want to be seen as equals in the field they need to assert themselves. Maybe they feel uncomfortable doing so, but there is no reason for being selective based in sex. I've worked with plenty of woman in my time that can be as aggressive as men when they need to be and they have done fine in tech without special programs. There are too few of these sorts of woman in tech though. You solve that problem by engaging them at a far younger age than would be seen in these conferences. Literally you need to prime them in grade school before they even set foot in high school. One thing that just came to mind, maybe Linus just got tired of hearing from the same old ass holes that try to hog the microphone for the entire question and answer period. We have all seen such individual at various conferences and this may simply be Linus being polite and getting the riffraff out of the way. 
I think you missed the point completely. We would have a far wider range of woman in tech if we got them interested early in life or at least understood what turns them off about the computer sciences. The decision to stay away from this part of tech seems to get planted into the minds of young girls at an early age. If you want to correct the problem you don't start with people already in the tech world (that should be obvious), instead you need to develop the interest in those with the capability early in life. Beyond that being selective based on sex is just sleazy in my opinion. By the way there is an assumption in this thread that no woman are involved in technical fields. That really isn't the case as they populate many fields such as biotechnology, and health related industries. Just look at the number of female pharmacist out there. Clearly they are selecting tech jobs that are more suited to their goals. Finally we might also learn a lot if we studied why so many men have rejected this field. Compared to Many occupations the working conditions for many involved in computer science related fields sucks. Obviously it is a matter of perspective but I've seen guys up and leave a job simply because they rejected the idea of being available 24/7. Things aren't as rosy in this world as some think and maybe just maybe woman are seeing this early in life. I don't think anybody has the ideal solution to this problem. However some attempts are far less than ideal and I see Linus approach here as one of them. 
Sometimes the only way to make things better is to radically change a culture. Sometimes it gets so bad that the only way to make positive change is to stand people up against a wall and shoot them dead. Thankfully we haven't come to that point yet. That is why I'm a strong believer in starting with young people and expanding their horizons. Still I believe there is more to the problem than expanding horizons because it is pretty obvious that woman often reject computer science after exposing them selves to the field. I was taking IT classes about 23 years ago and see the same things being noticed by recent graduates today. That is by the time you get to the second year of a program you have nearly all male classes. That in itself might be an interesting research project for somebody. 
Or why not just set the data in your ``setUp``. That's the point of ``setUp``. Point him to the docs. Don't make it look like it's your idea.
Discrimination is never a good thing and you would be hard pressed to find an example where it has done a lot if good. In fact discrimination often encourages stereo types especially if idiots get promoted due to that discrimination. 
I don't know, I think something like ``celery`` is pretty good for something like this. Use ``redis`` as your broker, super simple to set up (e.g. if you use CentOS/RHEL it's just a ``yum install -y redis`` and ``service redis start``).
A) I've carved out a niche in our code base that obeys PEP8 and a mix of functional/OO. I retreat there when I get the "Are you fucking kidding me?" stage. B) keep your cool. C) Find a new job if B fails Good luck.
Good joke. Women are turned off by tech because it's hard work.
&gt;If he spoke to me like that he'd get a knuckle sandwich. Watch out we've got an internet bad-ass over here
I would use the term "otherwise". Try this...exception? Do this...otherwise, do this...
No big deal, I thought it was something interesting I didn't know about, it was a possibility to learn something new!
Summary: Using Blaze to investigate to look at data from the USA's Home Mortgage Disclosure Act, a collection of actions taken on housing loans by various governmental agencies. 
Use SublimeLinter. I use it with flake8 just because it covers more than just formatting, but SublimeLinter with pep8 is also a great tool. It doesn't autocorrect your code, just warns you when you're doing something wrong. I also recommend moving to Sublime Text 3.
Good catch; everything's updated to remove it. The only thing it seems to have affected is memory usage, though, and actual timings are indistinguishable.
Do you need these features? http://www.jetbrains.com/pycharm/features/ I personally use Spyder for my day-to-day scripting as I don't need a heavy IDE, but use PyCharm for a large project I'm currently working on as some features like code refactoring come quite handy for me.
Thanks! https://en.wikipedia.org/wiki/SQLAlchemy
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**SQLAlchemy**](https://en.wikipedia.org/wiki/SQLAlchemy): [](#sfw) --- &gt; &gt;__SQLAlchemy__ is an [open source](https://en.wikipedia.org/wiki/Open_source) [SQL](https://en.wikipedia.org/wiki/SQL) toolkit and [object-relational mapper](https://en.wikipedia.org/wiki/Object-relational_mapping) (ORM) for the [Python programming language](https://en.wikipedia.org/wiki/Python_(programming_language\)) released under the [MIT License](https://en.wikipedia.org/wiki/MIT_License). &gt;SQLAlchemy provides "a full suite of well known enterprise-level persistence patterns, designed for efficient and high-performing database access, adapted into a simple and Pythonic domain language". SQLAlchemy's philosophy is that SQL databases behave less and less like object collections the more size and performance start to matter, while object collections behave less and less like tables and rows the more abstraction starts to matter. For this reason it has adopted the [data mapper pattern](https://en.wikipedia.org/wiki/Data_mapper_pattern) (like [Hibernate](https://en.wikipedia.org/wiki/Hibernate_(Java\)) for [Java](https://en.wikipedia.org/wiki/Java_(programming_language\))) rather than the [active record pattern](https://en.wikipedia.org/wiki/Active_record_pattern) used by a number of other object-relational mappers. However, optional plugins such as [Elixir](http://elixir.ematia.de/) and [declarative](http://www.sqlalchemy.org/docs/orm/extensions/declarative.html) allow users to develop using declarative syntax. &gt;SQLAlchemy was first released in February, 2006 and has quickly become one of the most widely used object-relational mapping tools alongside [Django](https://en.wikipedia.org/wiki/Django_(web_framework\))'s ORM in the Python community. &gt;==== &gt;[**Image**](https://i.imgur.com/EI6RtYt.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Mike_Bayer_talking_about_SQLAlchemy_at_PyCon_2012_c.jpg) - *Mike Bayer talking about SQLAlchemy at PyCon 2012* --- ^Interesting: [^TurboGears](https://en.wikipedia.org/wiki/TurboGears) ^| [^Pylons ^project](https://en.wikipedia.org/wiki/Pylons_project) ^| [^Python ^\(programming ^language)](https://en.wikipedia.org/wiki/Python_\(programming_language\)) ^| [^SQLObject](https://en.wikipedia.org/wiki/SQLObject) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckr0z9k) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckr0z9k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Of course they bail when exposed to the testosterone infused culture. Note though that CS in India is dominated by women because software is seen as a "soft field". So it's not CS per se.
&gt; Clearly they are selecting tech jobs that are more suited to their goals. How is that "clearly"? And which goals? Is the goal "not be drowned by testosterone" then yes I agree :P
&gt; I dont want the injustice to continue. Good &gt; I want the injustice to stop. Also good. Against evil, for good. That's good. &gt; Thats why I dont want special treatment of women compared to men. You mean "I don't want special treatment NOW" right? Because the entire point of special treatment is to do it on a short term basis to compensate for bad karma in order to remove the special treatment as soon as possible. &gt; Equal, and thats it. That's the goal. &gt; Just because white men centuries, or decades, ago enslaved black men, doesnt mean blacks should now enslave whites. Whoha, now you've just gone off the rails.
Just a heads up, the idiomatic way to read files in Python is using the with: context manager. This code: f=open('out/'+localname,'wb') # open a file f.write(image) # write content to file f.close() # close the file Should be: with open('out/' + localname, 'wb') as f: f.write(image) The reason this method is preferable is because the `with` context manager automatically closes the handle on the open file, no matter what. If you hit an exception on the `f.write(..)` line, `f.close()`, the program would crash, but the file handle wouldn't be closed.
print a + 1
There are options for taking away mens right to ask question in favor of womens asking questions only.
Yes. And if you want to raise a real error instead of just printing a message, replace the last line by raise ValueError("This was not a valid number :( ")
You brought in white and black people and slavery into this. I want special treatment every day, for women and men, not special treatment just for some. Karma? So all this is not really about justice its about some oriental religions idea? You cant remove injustice by creating more injustice. There are men in that audience who never treated women unfairly, who will not be able to ask questions just because they have a penis.
For anybody wanting to do serious web-scraping (more than 1 page), I really recommend [Scrapy](http://scrapy.org/). The learning curve may be off-putting, but in a few hours you know where to put stuff and you you get the time you put in back by improved productivity.
Yeah that is [strapdown](http://strapdownjs.com/).. and to scrape it I would have to convert the request response to html.. theres a module for that (written by Swartz I think)
&gt; I want special treatment every day, for women and men, not special treatment just for some. So you agree with me then? I'm confused. &gt; Karma? So all this is not really about justice its about some oriental religions idea? Karma means the actions/consequences that live on by being self-perpetuating across lifetimes and generations. A lot shorter to write, and not a weird concept. &gt; You cant remove injustice by creating more injustice. Sure you can. It's even super easy! Let's take a simple example: A is from a privileged background, B is from a background that is commonly discriminated against. They both have the same education in school and do equally well. A gets his/her first job easily, B is discriminated against because of the group belonging so it takes a year for him/her to get the first job. Now we're in the situation where A is one year ahead of B in job experience for all time assuming they are treated fairly from this point onwards. The only way we can undo the previous damage in that case is to subject A to some local "injustice", which we know of course is a non-local justice. &gt; There are men in that audience who never treated women unfairly, who will not be able to ask questions just because they have a penis. Sure. But they've also all benefitted for decades by having that penis. I think they can suck it up not getting to ask one question to one famous guy that has no obligation to answer their questions in the first place.
Too bad I had just bought a student license :( Ah well, I wouldn't have qualified for the (restrictive? stupid?) requirements they have. I live in Europe and basically no one in university uses .edu E-mail addresses.
same here, not end with .edu and it doesn't accept :(
"Initially, these are the only ways to validate your eligibility, however we’ll be adding more in the coming weeks. Stay tuned for further updates."
Nice work! It's always gratifying to see requests used for this sort of thing. For the future, here are some tips to improve your web scraping with requests. 1. Use Sessions! These give you all sorts of wonderful stuff. I explain some of the benefits on slides 8-12 of [this talk](https://speakerdeck.com/lukasa/a-deep-dive-into-python-requests), but basically you should use them whenever you're making lots of related web requests. 2. When scraping other people's content without permission it's polite to rate-limit yourself a little bit. Your retry function should put small sleeps in between web requests. Something like a second or two is usually enough, but go higher if you want to be really polite. I've used 10 seconds in the past: it makes the scrape take a while but it also reduces the load I put on the server to almost irrelevant levels.
i send the request, but i don't receive the email...can i request resend a email?
Please see the Gist again, I've added a plot. 
Isnt edu.au technically a .edu domain though? Surely it should just check for .edu(.) in the text after the @ symbol, e.g: kmwurf@student.uni.edu kmwurf@student.uni.edu.au kmwurf@student.uni.edu.co.nz
Cool! Thanks. But I would like something, where I could have part-time job and to work actually in a company/univirsity/smth like/ not remotly. Something like volunteering with travelling opportunities.
You guys both have a point. The lack of details on that part of the design is partly because my current assigment is to put together a very simple prototype, partly because I haven't much experience with this kind of things, and kinda hoped that job queueing would come as part and parcel of a library to control jobs. I realize now that basically I was describing Celery just after saying I found it too complex. Thanks for the help. If there's something like a simpler version of celery, even if less featureful, I'd be all for trying it.
Not necessarily: if edu.co.nz isn't a 'real' domain, anyone could actually have bought 'edu' in 'co.nz', then created whichever subdomain they wanted.
Ah yes. I know the ```with``` syntax. I should use it more. edit: formatting
Ah you are correct sir! Don't know what I was thinking, hopefully they will add edu.edu as an approved subdomain then.
I dont know how if they check like mail[-3:] == 'edu' or mail.find('edu') or some regex...but none the less for example the german universities have no .edu domain. They have for example fu-berlin.de for "freie universität berlin"
Down voted, reported for spam. Just a garbage blog with adsense every half page. Top 5 blah blah spam post. Jeez.
STL iterators are not a good choice for performance as they are computed on each iterations. Their role is rather to provide safety. The solution would be to use naked pointers to access your data (shuch compiler I know what I'm doing) In your test the simple fact to use const iterators rather than mutable (cbegin/cend) already give C++ a significant boost. 
Fuckin' .ac.uk email address.
So are you a student? If so, then just look for people doing cool stuff and ask whether they have any internships. I work in linguistics, and sometimes there are announcements on the [linguist list](http://linguistlist.org). I just looked and [here](http://linguistlist.org/internship/browse/intern-browse-announceProcess.cfm?id=35958717) is an example internship that could be interesting.
Anywhere you have a `float(input(...))` or an `int(input(...))`, you can do something like this instead: try: a = int(input("Vælg her:")) except (TypeError, ValueError): # This code will only execute in case of the above mentioned errors print('Dra til helvede') die_in_a_fire() 
I think women in general can just suck it up. Well I dont really think that, but its kind of your attitude towards "local-injustice". Also its just your theory that men have benefitted for decades just because they are men. Maybe where you are from, some arab country, but not where Im from - modern Europe.
Yeah, I'm on my way of getting master's degree =), last year. Thanks, it looks very interesting.
Can you? I thought, you could only access them for the 2 week trial period?
Go to github and look through the python projects, find one you like and try to commit bug fixes or new features to it. [Looking For Pull Requests](http://www.lookingforpullrequests.com/) is also a good resource to find open source projects to contribute to. 
&gt; Also its just your theory that men have benefitted for decades just because they are men. Well I guess that settles it. You're just a troll or totally ignorant about the world. 
You can just use one of the message brokers directly without celery. http://www.rabbitmq.com/tutorials/tutorial-one-python.html If you are just prototyping, you can probably set up a [Vagrant](https://www.vagrantup.com/) box with rabbit with something like this: https://github.com/toretto460/vagrant-rabbitmq 
I'm not particularly sure about the Anaconda plugin but I can recommend [SublimeJedi](https://github.com/srusskih/SublimeJEDI) Add this to your `.sublime-project` file to make it point to virtualenvs instead of the system Python. "settings": { "python_interpreter_path": "/path/to/interpreter", "python_package_paths": [ "/path/to/site/packages" ] } 
You are not exactly giving away for FREE. You are taking our emails. And secondly, I find title misleading, cos its a lottery anyways, I submitted my email and hope to win.
"Technically", no. They're looking for domains under the edu TLD. What's to stop the non-student owner of example.com from registering edu.example.com?