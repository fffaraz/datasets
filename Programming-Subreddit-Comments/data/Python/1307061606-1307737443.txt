What is this, linking directly to some kind of file is usually bad form. Some kind of explanation?
Very cool. Have you read the book "A practical introduction to the simulation of of molecular systems" by Field? 
No worky.
Try changing the panic= line to panic=pygame.mixer.Sound('Resources/Panic.wav') That is relative to the current working directory while the original is absolute to the computer.
It is a short sound clip, in a language that I don't understand, then the person makes some bird noise at the end.
`resume` and `ex` are in a grid relative to the Frame `con`: l.grid(row=0) con.grid(row=1) resume.grid(row=0, column=0) ex.grid(row=0, column=1) 
You can: pypm install /path/or/url/to/.pypm/file
no changes
It has some good examples for those being introduced to the topic. I found it rather nice to use Python as someone who has a bit of systems biology experience rather than the traditional matlab. 
You might also be interested in the [atomic simulation environment](https://wiki.fysik.dtu.dk/ase/).
It is similar. PySchools is for beginner and intermediate programmers who have some experience in other programming language. BeginPython is for non-programmer who would like to start learning programming. 
http://www.python.org/~guido/ **Guido van Rossum - Personal Home Page** * Waste more bandwith with a sample of my [voice](http://www.python.org/~guido/guido.au).
I'd consider Google App Engine, even with the new pricing it's still pretty affordable. You can read more about how do deploy it here: http://wiki.web2py.com/Deploying_web2py_on_Google_App_Engine_GAE_
[Pyrrrrrrrrrrrrrro](http://tf2wiki.net/w/images/thumb/8/81/Pyrotaunt1.PNG/300px-Pyrotaunt1.PNG)
I can't recommend [Webfaction](http://www.webfaction.com) highly enough. Their control panel is custom, nothing like C-Panel, so takes just a little getting used to. Once you do it is great. Support has been helpful and they have good forums, videos, tutorials, etc. You get almost everything you'd get with a VPS (including installing your own modules, apps, ssh, root, etc), but at a fraction of the cost. I've used them for a couple of years and have been really satisfied.
I'd have a default sequence which doesn't require the flags, but just like python function parameters, if the name has been specified then the user should be able to create their own sequence.
I feel like an idiot for completely forgetting that this was possible. Thanks!
Wow, just read their site and it sounds amazing! I was thinking about getting a VPS when my Bluehost contract is up next year because I need a lot more freedom. Looks like I may just go this route.
via: http://www.saltycrane.com/blog/2011/04/how-use-bash-shell-python-subprocess-instead-binsh/
web2py itself is hosted on VPS.net and runs very smooth. I like the daily, weekly and monthly backups.
Thanks! I created an [issue](http://bugs.python.org/issue12242) about it; I'll try diving into the code, and see if I can come up with a patch.
haha! sure am. glad to be of service. everybody wins.
I'm using Webfaction as well, web2py working great here.
This is sad. My intuition tells me that the number of python module projects is far smaller than the number of apps that need to stand alone. I might be wrong. :) As for the OS specific part, I know that this is hard, maybe very hard, and I think that this is PRECISELY why you should have done it. If you guys don't do it, the users (developers) have to do it using various hacks that might or might not work with the latest version of Python. And then is HARD_WORK * NO_OF_USERS. Not a good number. py2exe is not working on Python 3.x and this is yet another show stopper for my transition to the 3.x series. I could use cx_freeze but I got hooked on creating a single file EXE and I haven't figured out how to do that with cx_freeze. I respect the huge amount of work you put in and I hope you don't take this as a criticism. Is just me venting my frustration. Nothing personal. Keep up the good work!
I was aware of all that. The issue isn't quite this simple. See this thread on the Python-ideas mailing list: http://mail.python.org/pipermail/python-ideas/2011-June/thread.html#10402 
You're absolutely right.
Well, I have heard that [this sound clip](http://suseroot.com/misc/torvalds-says-linux.wav) is supposed to be in the Linux source-tree...
I found it in the [Porting Python 2 Code to Python 3](http://docs.python.org/dev/howto/pyporting.html#support-python-2-7) guide.
No, in theory you could do that. In practice, it doesn't work (it complains about the URL or path being invalid, or some such error) Edit: I should also say, when you do have an internet connection on the host, 'pypm install somepackage' works fine &amp; dandy and is a great way of getting some extra useful stuff into ActivePython. 
Seems like producing a patch for `fabric.main.load_fabfile` and/or `fabric.main.is_task` might have been more productive. Anyway it seems like this is perfectly doable without any trickery at all. * _base.py_ settings = {} def base_task1(): fab.something(…, settings['foo']) * _mywebsite.py_ from base import * settings.update({ 'foo': 'bar' }) def my_task1(): fab.something(…, settings['xyz']) There! This works using the same principle, that prevents you from using a list or dictionary as a default value in your function's signature keyword values (i.e. `def foo(x={}):`).
That's a good point, if they're all optional. Consider me educated!
&gt; I'm Guido van Rossum and I imitate Woody Woodpecker. *Woody Woodpecker sound*
You can use feedback from an output delay line to implement the basic difference equation: y[n] = a * y[n - N] + x[n] Solve for a given a required RT60 (i.e. time for the reverb to decay by 60 dB) and length N of the delay line (proportional to the echo time). Where d is the number of loop delays, find where the amplitude is down 60 dB: 20 * log( a^d ) = -60 log(a) = -3/d a = 10^(-3/d) The sample time is the reciprocal of the sampling rate fs; thus the loop delay is N / fs. Plugging in: RT60 = d*N/fs =&gt; d = fs * RT60 / N a = 10^(-3 * N / (fs * RT60)) The echo time N/fs can be modeled from the dimensions of the room and speed of sound in the room, and RT60 additionally needs the room's absorption constant.
Excellent, thanks for sharing! But you should consider building a package of it and putting it on PyPI (Python Package Index) to get the most exposure among Python developers. http://pypi.python.org/pypi
I think a good hoster would better not support *web2py* :-P
Isn't the accent just hearable in the pronounciation? 
Nope. I've done the shrake and rupley algorithm in my work and tried my darndest to get Connolly surface area code working without success. I was hoping you had some protips.
Just remember whatever you do choose, be consistent with that throughout the code. 
I don't know then, that made a difference in my tests.
I personally use [TekTonic](http://www.tektonic.net/) as my VPS provider, and they have been a reddit advertiser in the recent past. I have nothing but great things to say about them. I currently run a Zope/Plone instance on a Debian VPS through them. They use an industry-standard Parallels control panel. They've improved my plan (more RAM, disk) multiple times while I've been with them (over two years now) without ever increasing my monthly fees. The one time I needed support, which involved my not being able to order an additional domain name, they were quite helpful.
You can try http://www.python-forum.org/pythonforum/index.php. It is very active, with lots of helpful people in the forum. However, you are expected to write some code before asking for help. Never post your homework in the forum as well.
its a reference to a tv show "[word vervolgd](http://translate.google.com/translate?hl=en&amp;ie=UTF8&amp;sl=nl&amp;tl=en&amp;twu=1&amp;u=http://nl.wikipedia.org/wiki/Wordt_Vervolgd_\(televisieprogramma\))" that was popular in the netherlands
All links are directly to some kind of file. Whats your problem?
If you are writing new code I wouldn't even bother with the 2.x versions. Especially now that key libs are supported on 3.x, even if an obscure lib that you think is needed for your code I'd still go with 3.x and address the lib issue separately. Writing new code in 3.x is the smart long term choice. I'm not familiar with Windows but it is possible to install multiple versions on a Mac. As to the 64/32 question, remember this is an interpreted scripting language, so for many users there is seldom a need. However your handle could imply a need to use more memory than the average user. You might want to spend some time on the net looking for valid comparison info. I suspect that a 64 bit version would be faster for you. 
Which bit in particular? As far as I can tell, the issue _is_ fairly simple. `x += 1` is an assignment, so it creates a variable in the local scope if it doesn't already exist. As the scope is created before the code is actually executed, `x` cannot be resolved to the outer variable of the same name, so the expression necessarily fails. The only way to avoid this problem without using nonlocal (i.e. declaring the variable as being from an outside scope) would be to change the behaviour of the scope initialization so that all variables which share a name with a variable in the outside scope are set to the outside values prior to assignment. The value of the outer `x` would then be copied to the inner `x` upon calling the function and changes to that value would then still be locally scoped. There are two obvious problems with that, though: changes in immutable objects would "leak" into the outside scope (e.g. in `x += 1`, `x` may modify its state and return itself rather than a new object) and I'm not sure whether such an "initialization" step exists at all and whether it could be modified in such a way. It's way easier to just understand that assignment results in _all_ occurrences of the name in the local scope referring to the locally scoped variable and that therefore `x += 1` is going to break unless you previously defined `x` in the local scope (because the same name cannot refer to two different variables in different scopes within the same expression).
Stirring another framework war?
Wow, that's comprehensive.
So Python 3 only uses bignums? Cool. I'd like to see an article on the performance implications when doing lots of math with small integers.
It is not a war, just healthy competition. It should push as all to do better not worse. Anyway, I did not present any opinion, just numbers.
Yeah, I have vim setup to highlight mixed tabs &amp; spaces in bright colors., and it's a good idea to use python -t or -tt.
&gt;except KeyboardError: isn't this a typo of "except KeyboardInterrupt:"?
lol, yeah shortly after posting this comment i realized that duhh, they'll still need a js engine to render the graphs. honestly, i'd say short of getting HighCharts to work via node.js or whatever, you'd probably be better off using matplotlib or whatever to render static images of the graphs and then styling them to look like the highcharts graphs. they won't be interactive like the highcharts ones in the browser, but you could always include a link to view the graphs on the web, which would then allow the user to have the level of interactivity that they are used to. or, if you aren't using any of the interactive features of highcharts (not familiar with the library, so i'm not sure what it gives you beyond just generating the graphs from static data) just change your web-service to render the graphs server side, so that they graphs they get in the email are the same as the graphs they see on the web.
I was under the impression that the int-&gt;long promotion is now just silent, but underneath there really are still 2 implementations. Might be wrong though.
I doubt the 4 byte memory overhead will show up in performance benchmarks.
I haven't used web2py (nor am I avid web developer), but I'll give another recommendation to check out Webfaction. They had a lot better Python support (language space and extensions) than the other options I looked at and my previous host. 
I can recommend pexpect (and winpexpect on Windows as wexpect is dead) if you need to get a subprocess's output while it is running. This is the *only* thing that can get around C stdio's automatic buffering for non-terminal interaction (which is what subprocess, QProcess, etc. give you). 
Thank you. 
Heh, I'm just doing this for my own fun. I write what I can, when I get stuck I try searching out the answer, then repeat.
I was going to do something similar. How do feel if I used yours as a base with obviously passing back what I've done to you in case you want it?
Absolutely! Feel free to use or modify the code to your will. Glad to help! :)
relevant for your travels http://www.catb.org/~esr/faqs/smart-questions.html
It was a comics show. One of the sections was guests who signed up talking like a character from a comic. Woody Woodpecker in this case. 
What's a "good hoster"? I do not think [hoster](http://dictionary.reference.com/browse/hoster) is a word. Perhaps you meant a [good toaster](http://www.youtube.com/watch?v=LRq_SAuQDec) would better not support web2py, in which case I'd respond that web2py does not run on toasters, perhaps some other framework does and I am sure you will be happy to suggest one. 
Pretty sure with a screwdriver and a hand full of parts I could make my toaster support web2py!
that some are rendered inline but this one doesn't.
No, but arbitrary precision arithmetic is much more expensive than a single ADDL instruction :)
What about http://code.google.com/p/wkhtmltopdf/ It's a command line version of the webkit rendering engine - just pass it the html for your email and get a pic out.
You shouldn't be using Python if you are _at all_ concerned about speed. Or use Cython for the critical parts.
Not particularly true; it depends on the problem and how you use the language. Simple example, string parsing isn't the fastest thing around if it's char by char inspection- I'd do that in c for example. If your main thing is string parsing, well... yeah, it's not the best suited. Basically, a lot of the things that will bite you in the ass elsewhere (repeated object creation/destruction), will bite you in the ass in python. It has it's own quirks in addition, but by/large I've seen far more instances where the algorithm/design is the problem, not the language. That said, there are instances where it is too slow... but your statement is generalized in the wrong direction ;)
I think you're correct. As the original author notes: &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getsizeof(10) 24 &gt;&gt;&gt; sys.getsizeof(10L) 28 There are still different representations of "int" under the covers, but You Shouldn't Need To Know This^tm .
Nerd
Why I love reddit: The person who wrote the framework you're using will probably respond to your question directly. :D
BTW feel free to have to a look at my repos. https://bitbucket.org/toadwarrior I will admit I have nothing awesome there at the moment so don't expect to be amazed. Most stuff is still private atm. I have some nice stuff I've been doing at work for data transformation (either DB to other formats or images to other image formats) which are much more interesting but I need to find some time to remove the employer specific bits. My proudest (though not hardest) bit is this Solr log parser I'm working on. With a little config it should handle most any Solr log you throw at it. That should be coming live soon. I'm 50% through the re-write. Once they're tidied up for public consumption then I'll make them public rather than private and now that I've received the job offer I want I'll probably coast through my current job meaning I'll have enough time to finish up my flask message board and I'll put that up. :D
Looks really interesting! Would like to have a look at the source code. Can you pass the link?
You can download the sourcecode at [github](https://github.com/it3s/mootiro_form).
Once you know how to calculate the feedback coefficient and how large to make N, implementing the difference equation is straight forward. It might be nerdy to use the Z transform to derive the transfer function H(z) = Y(z)/X(z); factor the feedback path into complex poles; and pair the conjugates into cascaded biquads for better numerical stability. :) 
&gt; While her academic colleagues laugh at her for her choice of such a non-theoretical language like Python I thought Python was reasonably well established and liked in the scientific world? Maybe that's just for processing data though, not for actual algorithmic research? At any rate, I wish Guido would blog a little more often. He usually has something interesting to say.
My tax files have a broad Cockney accent, actually.
I'm not as up to speed on LFSR's as I should be, but it might have been easier to do this using a permutation generated by exponentiation mod a large prime. I suspect that might be a slightly slow solution, but if you write it in C with MPRF, you might be able to make it fast. 
That's a linear congruent generator. Turned out those were extremely hard to tune for periodicity. At any rate I didn't need this to be fast as seeking around a block device and writing 512 bytes is very much the bottle neck in my code.
I'm a scientist and I love python. Python is reasonably well-established in certain fields, but certain academicians are unfamiliar with it or only know of it as another interpreted scripting language. In my own department, I was the first to start using python... soon followed by a number of others. 
No, you didn't read the article carefully enough. The example you quote is from running Python2.6, and not from Python 3. There is no 10L in python3, trying to use it causes a syntax error, regular ints can be arbitrarily long. Python 2.6 has different ints under the cover but you shouldn't need to know, Python 3 only has bignums, and no support at all for plain old ints. Copy pasta from my machine (different numbers because I use a 32 bit OS): axel@phoenix ~/c/c/anna&gt; python Python 2.7.1+ (r271:86832, Apr 11 2011, 18:05:24) [GCC 4.5.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getsizeof(10) 12 &gt;&gt;&gt; sys.getsizeof(10L) 14 axel@phoenix ~/c/c/anna&gt; python3 Python 3.2 (r32:88445, Mar 25 2011, 19:28:28) [GCC 4.5.2] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import sys &gt;&gt;&gt; sys.getsizeof(10) 14 &gt;&gt;&gt; sys.getsizeof(10L) File "&lt;stdin&gt;", line 1 sys.getsizeof(10L) ^ SyntaxError: invalid syntax 
Int to long promotion was always silent. Just try calculating the factorial of 100 in Python 2, it just works. But I've checked, and unlike Python2, Python3 actually does not have non-bignum ints. 
Looks neat. Looking forward to the full release.
I have far more respect for python + numpy/scipy than matlab. 
Speak for yourself, some of us run Python interpreters that hold their own against C/Java/whatever.
My bad, thanks for correcting. 
Which? PyPy? 
Yup
Are you trying to fill a disk with randomness, or with a pseudorandom permutation? 
It's a data persistence test. We already had a sequential test. This one exercises our driver much differently under the covers. I am writing a 512 bytes buffer of random data to a sector until the drive is full. What is MPRF by the way? I googled around but the acronym seemed to have many uses.
I saw this language mentioned on Python ideas a couple weeks back, and I've been thinking about some of its nicer features, like optional static typing, built-in testing, and design contracts.
`+=` is an assignment, but it doesn't need to be a local assignment. There's no reason that `=` and `+=` have to work the same way in terms of affecting the compile time binding of a function. Having an `x =` anywhere in a function body causes it to be locally bound, so that indeed this program will always crash: &gt;&gt;&gt; x = 0 &gt;&gt;&gt; def f(): ... return x ... x = 2 ... &gt;&gt;&gt; f() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in f UnboundLocalError: local variable 'x' referenced before assignment whereas its near identical brother will always return: &gt;&gt;&gt; x = 0 &gt;&gt;&gt; def f(): ... return x ... &gt;&gt;&gt; f() 0 The difference between the two is that an `=` statement anywhere in a function body will at compile time cause the LHS variable to be treated as a local variable throughout the function. Right now, `+=` behaves identically to `=`. &gt;&gt;&gt; x = 0 &gt;&gt;&gt; def f(): ... return x ... x += 2 ... &gt;&gt;&gt; f() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 2, in f UnboundLocalError: local variable 'x' referenced before assignment Because of the meaning of `+=`, any use of `+=` in a function that is not preceded by the use of `=` (or some hack with `locals()` or the stack frame) will raise an exception. But there's no need for that to be the behavior of Python. Because functions that only have `+=` but not `=` in them are all already broken, Python could, without breaking backwards compatibility, change things so that having a `+=` without an `=` doesn't always crash by treating the LHS variable of a `+=` as a nonlocal at compile time by default unless that same LHS variable is used elsewhere in a `=` statement. Anyway, this change isn't going to go into Python, since the existing behavior is too entrenched, but there's no in principle reason it couldn't change.
As some replies have already stated, Python is a great tool for all sorts of work that scientists do, but it is not well founded in *computing* theory. Pervasive reflection, duck typing, lack of information hiding all make it nearly impossible to prove anything about language constructs or bits of code written in the language. It's hard to even state the computational complexity (*O()*) of a short algorithm. Generally this makes it a poor language for proving theoretic results. To be honest, I'm curious about how Liu's work addresses this. Perhaps using a strict subset of the language those concerns could be mitigated or even go away, but it sounds suspiciously like her research addresses optimising code for CPython's set implementation, rather than discovering interesting properties or approaches to the "fundamental algorithms" under study. I couldn't find anything on her faculty website obviously related to it, and Guido's lack of theoretical understanding made his description effectively useless.
hi, I understand that you are not posting your homework. :) Have fun in your coding. 
I think he meant MPFR: http://www.mpfr.org/
Sorry, I meant MPFR. It's the floating point equivalent to GMP, the bignum library. 
I've used wxPython fairly successfully. It has its quirks, but for the most part little effort is needed to get a fairly consistent result on OSX/Windows/Linux. Zero issues making all in one executables with py2app (OSX) and py2exe (windows), though the resulting applications can be surprisingly large.
Aside from my own program code, does the resulting executable contain its own Python implementation, any Python packages required, and also the wxWidgets library? 
All of the above. I believe there is an option to use a system installed python though.
Thanks for the info, adamc. 
&gt; It's hard to even state the computational complexity (O()) of a short algorithm. I don't see any basis for such a claim. While Python programs are essentially impossible to analyze statically, this is mostly due to features that are rarely used in algorithmic code, like dynamic modification of classes, shadowing builtin functions, etc. Python is probably a bad choice for automatic complexity analysis unless you use a reasonable subset of it (and you certainly would), but in no way is it hard for a human to analyze Python code.
Hm...a type-inferred language with python-like syntax. I like.
My biggest problems with it is it runs with C#; I ams more interests in Genie for going essentially through C ins stead. Genie ams also has great syntax, pretty looking type declarations, one thing it ams misses ams contracts. If I really wants something to versatile and not to have to compile native codes, I woulds just use Python (or PyPy with llvm)
This reads like a twitter toilet update. Who are you, what is your project or why should we care to look at it?
You're right, that claim was clearly going too far. While the cost of accessing a property on an object passed to a function is unbounded, that doesn't stop meaningful statements being made about the complexity of that function in terms of its inputs. FWIW, [today's post about Cobra](http://www.reddit.com/r/Python/comments/hr9po/cobra_an_interesting_language_designed_to_be_an/) is pertinent here. It slightly upsets me that python modules can't be "closed" to dynamic modification to permit compilation, but I need to remind myself that that's not what the language is intended to be.
Are you computer scientist (computing theory or similar) or other field?
Nit: isn't this a binary lfsr, so its output is in 2**30, not 10**9? Not that I'm arguing for a base-10 LFSR for this job -- I think you'd be better off applying ifilter(lambda x:x&lt;1000000000, lfsr) I'm curious how one would go about computing the taps for a maximal-length LFSR in base N with K digits, or even a proof that binary LFSRs with period 2**K-1 exist for all K. (and why not period 2**K?)
I'm Mark Holmquist, a computer science major at the University of Redlands. I've spent some time programming for the web and decided to put the skills to good use in the free software community. Stattr is a web application built in Python on top of Flask that keeps track of competitive activities. Tournaments, competitive leagues, and single-shot competitions can all be tracked by one site, and each one can have multiple moderators and competitors (of course). The project started as a scratch-your-own-itch thing, because I wanted to keep track of how well my friends and I did at various things--specifically Smash Bros. and Ping Pong. I see the project being mostly a pet-project thing for most people, getting set up once and used consistently thereafter to keep track of casual games or competitions between friends. I also hope to see fundraisers use it to track and publish their results, giving a more accessible method of accessing the results. The project will soon evolve into giving more statistics based on team groupings, individual users' progress, and so on. I'm also hoping to include graphs and sorting by various statistics. Plus it's a cool bit of software and I really want people to help me get to be a better programmer, so I can better serve the community. Thanks for the feedback, I'll try to be more descriptive in my posts.
In addition to what fredrikj says above, this is a useful chart -- [Time complexity of basic Python data structures](http://wiki.python.org/moin/TimeComplexity).
There are only minor differences between 2 and 3. Many libraries still don't support 3 though. I'd go with 2 for that reason alone. But they aren't mutually exclusive, you can write code that works in both for the most part (if you don't count strings...). Tutorial on Python.org not enough?
Considered [Jython](http://wiki.python.org/jython/JythonFaq/GeneralInfo)? &gt;Jython is an implementation of the Python language for the Java platform. Jython 2.5 implements the same language as CPython 2.5, and nearly all of the Core Python standard library modules 
It is interesting but it doesn't offer anything I don't already have or want. It seems truthfully to be a different take on the CLI pytonic language. There's already IronPython and Boo. All three seem to have different priorities.
I haven't read it yet, but is it thorough enough to learn to language properly from?
Yes, the official documentation is sufficient, especially if you have prior programming experience. As always, the best way of learning a programming language is to find a problem and solve it and as a physicist I am sure you can think of plenty of cool things to do with numbers. :)
I would suggest Qt. You can choose between the PyQt- and PySide-Binding packages. The QtDesigner is an excellent tool for designing the GUI.
Wow, I didn't expect such a detailed response. You should put this in your readme on github so people can see it there too :-).
Ok, you're right. It is a "denglish"-word which we use in german. But within the context I think it is understandable :-P Why should I suggest other frameworks? I can not believe the OP does not know about alternatives to web2py. If he does not, we got the answer to the question, why he decided to use web2py ;-) If he does, it is pure mystery to me, why he chosed that! I think every full stack webframewok is far better than web2py!
Doesn't really address my points, but that's a nice chart anyway :-). No real surprised in there but it's good to have evidence.
There are quite a few things you can try to make the resulting app smaller - py2xe has a full page about it, but if you just manually specify which modules to exclude from the final exe you will save some space, then turn on compression and optimization and you'll already end up with a much, much smaller file. Also, I've read good things about pyInstaller - it can also do UPX compression which is meant to be really good
You say it depends on the problem and how you use the language, so what would be a problem and a way of using the language in which Python will be fast (faster than C??)? You're right about object creation, but doing recounting, garbage collection and _type checks_ is added to that for Python, which is a killer. And yes, you have to use the right algorithm, but if you implement a textbook algorithm for a data structure in Python, it is definitely going to be more than twice as slow as the C/Cython version, so we are also talking about large constant factors. But I'd love to be corrected, so if I do generalize in the wrong direction please make a clear argument for that.
When you say "short algorithm" what I have in mind are my solutions to projecteuler problems. I would be able to state their complexity fairly easily using that chart and some basic algorithm analysis knowledge. Either your idea of a "short algorithm" is different (is it?) or I don't understand what the problem in finding out the complexity of said solutions is.
&gt; Stattr is a web application … You need a demo and/or limited hosted version. Your audience is all kind of folks, not just programming community. You can do this for free—check out Google's Appengine or other hosts with free tiers.
There's [Dive Into Python 3](http://diveintopython3.org/)? It covers Python 3 and the differences between 2 and 3. 
If you're a scientist, Python will be far more useful to you than java. I speak as a professional physicist. The best way to learn python is to *do* stuff with it. Solve problems, control experiments, crunch data, visualise results. Any of the tutorials on-line will get you started. The advantage of python for science is not just the beauty of the language but the libraries available for it and for the scientific domain in particular. Browse PyPI (http://pypi.python.org/pypi?:action=browse&amp;show=all&amp;c=385) for examples.
The FAQ for one: http://docs.python.org/faq/design.html#why-are-colons-required-for-the-if-while-def-class-statements
Done, thanks! I definitely want to keep in touch with the community first, since that's largely why I work so hard on the project. I'm not about to blow you off with a quick response! Besides, I got a bunch of new information for my README file out of it.
I was thinking of starting this on my own server, but I'm not sure how useful it would be right now. Only admins can add users and/or make users moderators. Most of the features would be useless without user/event creation, so it's probably OK for me to let people run it themselves (it's not hard to do, honest). Once I add more features for *viewing* data, it might make more sense to host an instance on my server. Right now most of the features help with the input of data instead. Thanks for the suggestion, I'll keep it in mind!
None of the commenters seem to grasp quantifiers. The point is to have both the truth-value, and the element for which the quantifier holds/fails. So this does require some weird side-effect, and probably an extension of the language (unless you are willing to wrap it in list as argument, but that's a hack).
Why don't they mention worst-case as well as amortized worst-case?
Turtles all the way down.
I've been trying to get a standalone GUI working the last few days. I'm using PyQt for the GUI, and py2app and py2exe for the deployment. py2app will create a single .app, and you can configure py2exe to create a single .exe. One problem I had is that I can't load images using PyQt when deployed, so you need to use PIL to load the images.
I cannot say for sure, but I think that: * you don't really have to care; the amortized worst-case is enough for most analysis purposes * with basic data structure knowledge and the information provided about implementation (e.g. python lists are dynamically resized arrays) you can figure the worst case yourself For instance, what use is it to know that a python list append is *worst case* O(n) when the amortized worst case is O(1)? I can't think of an example where this would play a role. Also, they explicitly note the cases where they use the *amortized* part with the [1] sign.
If you want to optimize for worst-case latency, and not the overall performance, it can be relevant. I guess it is mostly for soft/hard real-time stuff, and Python doesn't shine there anyway.
Didn't think of that, thanks. You're also right that I'd be expecting RT sensitive parts to be written in another language, if Python was used at all. But I have no experience with RT stuff, so I don't have much to say about that anyway.
http://www.learnpythonthehardway.org
Has all you need if you already know another language (so you know what to look for when you have a question). Otherwise, this is quite good: http://diveintopython3.org/ Free PDF and all!
This was very interesting. I hope Guido will share more stories soon.
&gt;is it thorough enough to learn to language properly from? It is thorough enough to get you started. To learn the language, you'll have to read at least a dozen books and practice by writing your own programs that solve real tasks (don't worry if those tasks are small).
This. Whatever peoples personal opinions of Zed, you can't deny that its a good book. 
Those differences to python do sound like cool improvements. Also notice that it may have overcome the main disadvantage new languages have by having access to all the C#/Mono standard libraries. 
&gt; ...at least a dozen books.... think u exaggerated a bit there
**TKINTER** I use Tkinter and for bundling as a distributable unit I use py2exe.org http://www.py2exe.org/. I don't use Rapyd or PAGE, but you may find them useful for doing direct visual design for Tkinter. Rapyd http://www.bitflipper.ca/rapyd/ PAGE 3.1 http://page.sourceforge.net/ Do you have a sketch of your frontend? Thing nice about WxPython, QT, and GTK is you can use the XML resource file creators. **Tkinter and WXpython side by side** http://sebsauvage.net/python/gui/ **Tkinter** http://www.ferg.org/thinking_in_tkinter/index.html http://infohost.nmt.edu/tcc/help/pubs/tkinter/ http://effbot.org/tkinterbook/ http://www.java2s.com/Code/Python/GUI-Tk/CatalogGUI-Tk.htm **WX** http://wxformbuilder.org/ 
Agreed - I was a CS major who didn't learn Python in school and Dive Into Python is how I learned the basics of Python.
**Python Osmosis (50 Video Tutorials)** http://python.sourcequench.org/?m=200905&amp;paged=12 High Level to Low Level (For me) Python -&gt; C++ -&gt; C -&gt; Assembly -&gt; HDL -&gt; MSI -&gt; :-) I fooled with Java for a little bit on a couple projects, but found the level of abstraction with Python increased my overall productivity. If you don't have an favorite editor yet, I suggest VIM (Tutorials =&gt; http://derekwyatt.org/).
This sounded really interesting, until I got to the bit like 80% of the way down where they finally admit it's a .NET language. Screw that. Write an llvm frontend and get back with me boys..
Since you're learning the language, and plan on using it more heavily in the future, 3 seems to make sense. However, your specialty might still mean that it is a good idea to start with 2, so that you can apply it using available packages more quickly. Take a look at [Python(x,y)](http://code.google.com/p/pythonxy/wiki/Welcome). It packages together a lot of components that could make what you learn useful in other courses really quickly. The welcome page even talks about it being particularly well-suited for porting experience with MATLAB to learning python.
I started by going through Think Python first, and it really helped guide me through the basics. As you've some experience programming, perhaps Dive into Python would be the better option, but both are excellent books. I've heard good things about Python the Hard Way, but I've not read it, so I cannot comment. Each of these three books are available for free. From there, I've been reading documentation on docs.python.org and learning to use the standard library. Going through other people's code is a good way to learn too. As I learned, I'd go through ProjectEuler problems and once I solved them, I'd go look at how others did the same task. This way, you'll (usually) find some basic programs that are easy to understand with even a limited understanding of the language. Finally, setup ipython. I used the IDLE interpreter for some time to prototype complex code, but my workflow has changed. With ipython, you can link to the Gvim server, and write your code there, if vim is your kind of thing (once customized with the proper plugins, it's a great environment). There are instructions [here](http://ipython.scipy.org/moin/Cookbook/IPythonGVim) to setup the system. The path mentioned on that page didn't hold the ipy.vim plugin for me, but it's a simple matter to use "locate ipy.vim" on a *nix box. Once you've set up the link and enter %vim, a gvim window will popup. Any code in the gvim window will run in ipython by hitting [F5]. Be comfortable in your coding environment. I like vim with some plugins. Find an IDE or editor that you like, and get comfortable.
Consider using [urllib3](http://code.google.com/p/urllib3/)'s HTTPConnectionPool method. It will decrease your scrape time dramatically(50-80%), as only one connection socket will be used instead of n-pages connection sockets. Keep in mind, it only works if all the pages are from the same domain, which it is in this case. Also, if you feel like going the extra mile, make the parse process multithreaded. It will cut the scrape time effectively too.(Depends on your setting)
Have you used it yourself and found it to be straightforward and simple to create a standalone app? 
Had not considered it. Haven't used Java in years. For GUI work, does Jython have you use Swing from your Python code? 
Interesting. Had not considered Tkinter. I've used it a little in the past and found it easy to get started with. Some GUI elements seemed weird and old-fashioned though. &gt; I use py2exe.org Have you ever tried creating a standalone Mac OS X app? That is, without using whatever Python OS X comes with? (IIRC, OS X comes with Python and Tkinter as well.) Thanks for all the links! 
The type declaration syntax is too reminiscent of Visual Basic.
Once you pack it with Py2EXE/cx_freeze or PyInstaller it's ready. Also, Qt4 is a joy to work with.
I really like some of the language features (design by contract and built in unit testing). It appears to target the CLR. Runtime performance on my Mac is ok. I wonder about Mono's stability though. Anyone have any experience with that?
Someone just needs to port this to Dalvik (C# and Java share a number of similarites) so that I can ditch writing Android code in Java :)
Regarding the py2app/py2exe/cx_Freeze tools, can they be run from GNU/Linux to create apps for other platforms, or must I run them from a given platform to create an app *for that platform*? 
Have a look at [Nimrod](http://force7.de/nimrod/index.html) then. Seems more interesting to me.
freenode #python is full of zealots though, if that bothers you or you just don't like the high user count on that channel you can try the quakenet #python channel
&gt; Also, Qt4 is a joy to work with. I noticed that both Qt and Wx are C++ toolkits (with Python bindings). Do you think Qt4 is any nicer to work with than Wx? 
Use a [dictionary](http://docs.python.org/tutorial/datastructures.html#dictionaries). The word is your key and the count is your value. Your method would work, but it is a little clumsy.
What would be a cleaner method? edit- Oh, I see.. THe dictionary method is the cleaner method than lists.
What this article is really missing is the info what python has that cobra doesn't. Seems to be a lot of things, but it's hard to say due to lack of documentation
No experience creating a standalone Python Mac OS X app You may want to check out py2app. I believe it's like py2exe, but for Mac OS X and should do what you want (bundle a set of modules along with a specific version of python). http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html As long as, you're not using OS specific modules you shouldn't have much trouble when it comes to cross platform use. I know one of the modules I uses has wraps the native OS API with a general interface so you don't have to write OS specific code. You might want to look at virtualenv. http://pypi.python.org/pypi/virtualenv http://www.arthurkoziel.com/2008/10/22/working-virtualenv/
Something like: wordcounts = defaultdict(int) for word in words: wordcounts[word]+=1 
If you have python 2.7 there's a built in counter class &gt;&gt;&gt; from collections import Counter &gt;&gt;&gt; c = Counter([1, 1, 4, 2, 5, 1, 5]) &gt;&gt;&gt; c Counter({1: 3, 5: 2, 2: 1, 4: 1}) 
 from collections import Counter max_hist = 32 data_file = open('temp.txt', 'r') words = Counter() for word in data_file: words[word.rstrip()] += 1 tmp = max_hist / words.most_common(1)[0][1] for word in sorted(words): t = int(words[word] * tmp) print('{0}:[{1}] {2}'.format(word, words[word], '*'*t)) 
look at defaultdict object from the standard library from collections import defaultdict fopen=open(in_file, 'r') counts=defaultdict(int) for word in fopen: counts[word]+=1 defaultdict saves you the trouble of initializing. you'll have to deal with tabs or new lines, but those can be stripped out (word=word.strip('\t').strip('\n')) edit: and now reading the rest of the thread, i see yggdrasilly has posted the same.
 &gt;Before you jump in to open up the Dropbox distro and learn all about how it works, beware that the source code is not included and the bytecode is obfuscated. So are they using something like p2exe or have written a custom solution?
You should check out: https://wiki.fysik.dtu.dk/ase/ It is written in python 2. It supports a large number of force fields from simple empirical models to DFT, HF, and Post HF methods.
Though `defaultdict` and `Counter` can be considered more elegant, let's not forget the basic version: li = [1, 1, 4, 2, 5, 1, 5] d = dict() # or: d = {} for e in li: if e not in d: d[e] = 1 else: d[e] += 1 Now `d` is `{1: 3, 2: 1, 4: 1, 5: 2}`. This is the basic version and it can be improved as seen in the other posts.
I just read some of the code examples in the [how-to section](http://cobra-language.com/how-to/) and it is indeed very similar to python. Most of the differences to python really seem to be elegant improvements not that far from the original "spirit" of python...
I'm interested to know whether or not the type declaration syntax means Python's `as` keyword isn't usable.
Bloom filters are real cool - any other trick data structures worth knowing?
My own implementation: https://github.com/sangelone/python-hashes/blob/master/hashes/bloom.py The main difference is that you specify how many items you expect to insert and the desired false-positive rate. It calculates the optimal bit length and number of hashes to use internally so you don't have to worry about how Bloom filters really work to use it. Examples are in [the README](https://github.com/sangelone/python-hashes/blob/master/README.md).
&gt; It calculates the optimal bit length and number of hashes to use internally Hey, that code [looks familiar](http://hur.st/bloomfilter) :) A [good optimization](http://algo2.iti.kit.edu/singler/publications/cacheefficientbloomfilters-wea2007.pdf), especially if a filter is ever going to be stored on disk, is to split the filter into lots of small buckets - using a hash to pick a bucket, and then having the rest operate only within that bucket. Much more cache-friendly. [Lots](http://appolo85.wordpress.com/tag/bloom-filter-variants/) of other variations to play with too.
Variations: def hist1(sequence): d = {} for value in sequence: d[value] = d.get(value, 0) + 1 return d def hist2(sequence): d = {} for value in sequence: d[value] = d[value] + 1 if value in d else 1 return d def hist3(sequence): d = {} for value in sequence: try: d[value] += 1 except KeyError: d[value] = 1 return d 
http://en.wikipedia.org/wiki/Cuckoo_hashing
I actually took the equation implemented in `_optimal_size` from Wikipedia of all places. Yes, once you understand Bloom filters you can adapt them to all kinds of specific conditions and tradeoffs. That's why I wanted to implement them very plainly in Python so I could quickly tinker around with variations.
I have recently built a small GUI-based application that was to be deployed on Windows XP. My first attempt was in Jython. Using Swing was surprising a pleasure (compared to using it in Java) in Jython. Where this venture ended up failing, in my eyes, was actually deploying this application. It required a bunch of [messiness](http://stackoverflow.com/questions/1252965/distributing-my-python-scripts-as-jars-with-jython) which ultimately ended with requiring *the user* to execute a batch file which called: java -jar _filename_.jar -jar _filename_.jar (I couldn't get the suggested fix to work) **Ultimately**, I ended up rewriting it using PyQt4, which was also fun to play with. I used the suggested Py2EXE and it works wonderfully. The only drawback for me is that *the user* is required to have MSVS2008 C++ for the application to run. Hope this gives you some insight!
&gt; The only drawback for me is that the user is required to have MSVS2008 C++ for the application to run. Wow. That would be a deal-breaker. If py2exe binds together Python + libs + PyQt4 + Qt, the resulting exe should have everything it needs. Seems odd that MSVS would be required. MSVS was required for the end-user to simply *run* your exe? 
That's a cute little implementation, but for someone at OP's level of experience it should come with a reading guide and lesson plans.
I'm using this in a fairly large project, and I'm a big fan, in case anyone was wondering about the quality, I give it a pretty big thumbs up. Ninja-edit: Just a forewarning, it is a lot less pythonic than it could be. 
oo! oo! I had something like this for an assignment this quarter. I'll post a solution later. the problem is similar enough that it's probably useful.
How is this a question multiple times a week? I've used Komodo for 5 years and love it. I still end up using plain old Vim a lot of the time as well.
I doubt the typical Python usage of *as* would be rendered impossible. Special cases can be made for *except* statements and context managers (i.e. *with*).
Nice ones, thanks. I didn't know about the `dict.get(...)` function. I prefer versions (1) and (2), if possible I try to avoid exceptions.
Do yourself a favor and don't use an IDE. Learn Vim or Emacs. Stick with it. Become a pro.
I rather enjoy Pydev. I'm not sure why it doesn't get any love in this subreddit.
I may not have supplied the proper .dlls with the application? I included msvcp90.dll, but that wasn't enough. As soon as I installed the MSVS on the machine, it worked fine.
I agree. Vim (or Emacs, or BBEdit, or whatever) is all you need. Everything else is fluff.
For writing a very short script, I use Vim. If it's a bit longer but the "project" is still one file, I fire up Eric. If it's a real project with multiple files (with packages, etc.), then I start Eclipse with PyDev. For me a very important feature is intelligent renaming. When I finish a script/project, I read it over and I try to invent better variable/function names. Among the three candidates, this works best with PyDev.
**PYCHARM!!!**
If performance matters on a large data set, using the exception is more optimal. `dict.get` and the conditional expression always ask permission, while handling the exception begs forgiveness if and only if it attempts to increment a new key. I assume that's how `defaultdict` works.
I use pyscripter. It is a simple IDE with all the basic features. 
Unix
Vim with some [plug-ins](http://peterodding.com/code/vim).
For scientists and engineers who are used to MATLAB, try PythonToolkit (PTK) or Spyder.
WingIDE is pretty nice. But generally I just use Vim and/or UltraEdit.
I mostly code in vim. before that notepad++. I really like PyCharm, but haven't jumped yet. If you are curious about all the possibilities check this out [Python IDEs on StackOverflow](http://stackoverflow.com/questions/81584/what-ide-to-use-for-python)
I use vim for everything *except* Java for which I use eclipse. Use vim. A text editor is a good tool to have in your tool chest.
Emacs. (also vim)
Yes, case (3) is a clever hack if performance is above all.
 &gt; No way to do vertical selects of data. For instance, sometimes I need to select the first ten columns of x number lines of text. Maybe I misunderstood your problem, but Komodo has column editing when holding ALT while selecting text.
Jetbrain's pycharm is good and inexpensive. 
erm... the OS?
... or [iep](http://code.google.com/p/iep/) -- the Interactive Editor for Python.
VS users might want to check out http://pytools.codeplex.com . free &amp; oss.- intellisense, debugging, profiling, browsing, etc. along w cluster computing support for both CPython &amp; IronPython [disclaimer - i'm involved in the project...]
PyCharm!
When should we expect the actual tutorials?
Yes, especially if you need Python 3 support and interaction with the GUI event loop (e.g. for plotting data). It's not as full-featured as the others, though. PTK uses wxPython, and I have no idea when that'll be ported to Python 3. Spyder uses QT, so maybe it'll have Python 3 support soon(ish). But with IEP, NumPy, Cython, SciPy, and Matplotlib -- Python 3 is already an option in technical computing.
Yeah. Nimrod has a python-like syntax, and it compiles to C!
Am I the only one who uses IDLE?
Python 3 docs for [tp_basicsize and tp_itemsize](http://docs.python.org/py3k/c-api/typeobj.html#PyTypeObject.tp_basicsize).
WHY U NO USE THE SEARCH? Seriously, why do these threads pop up every month? Shouldn't Python developers know how to use a search field? http://www.reddit.com/r/Python/comments/hlgfm/any_good_python_ide_with_vimlike_key_bindings_for/ http://www.reddit.com/r/Python/comments/fvmnh/im_new_to_python_what_ide_do_you_recommend/ http://www.reddit.com/r/Python/comments/ed8sk/so_whats_a_good_ide_for_python_coming_from/ http://www.reddit.com/r/Python/comments/dp8k8/is_there_a_better_python_ide/ http://www.reddit.com/r/Python/comments/dc992/yet_another_quest_for_the_perfect_ide/ http://www.reddit.com/r/Python/comments/cbvns/your_favorite_python_ide_go/ http://www.reddit.com/r/Python/comments/c3x3i/python_ide_frustration/ http://www.reddit.com/r/Python/comments/9egaz/ask_reddit_best_open_source_ide/ This is what I got from a search for "IDE" from the first two pages only!...
Affirmative.
If you are using Python 2.7 or 3.2 then you can use the [Counter](http://docs.python.org/dev/library/collections.html#collections.Counter) class in the collections module. If you have a list of words `word_list` then you can count them with: counts = Counter(word_list) This will create a dictionary mapping each word to how many times it appears in the list. Job done. **Edit**: damn, I should have read all the comments before replying - this has already been pointed out several times.
There's a 0.1 version on Github waiting for feedback.
 def get_probes(self, key): random = Random(key).random return (int(random() * self.num_bins) for _ in range(self.num_probes)) Mmm. That could be somewhat of a performance bottleneck: Python's `Random` uses Mersenne Twister, which allocates and fills 2.5 kilobytes of state on creation. Why not use something faster, like, I don't know, repeatedly hashing the key? Of course it might not matter at all, even `Random` could be well fast enough.
Forgot to mention that the [examples](https://github.com/stchris/untangle/blob/master/examples.py) page should give a pretty good overview on what it does.
Yes, definitely. Even its author Guido doesn't use it.
Pydev with Vrapper (vim plugin for Eclipse) for me. 
dead's point is that Unix with it's standard tools is a development environment all by itself. 
emacs. 
Disabling syntax highlighting will make komodo faster with binary files (your unformatted json file). Also, it has an option to strip trailing whitespaces - check the settings ! If you need more than a text macro just write yourself an extension.
I don't think you have looked through the options. I have line wrapping and trailing trailing whitespace being stripped in all files with Komodo IDE. As Buzzard mentioned there is vertical text selection.
&gt;Learn Vim or Emacs How come you are apologet of legacy text editing tools, but still do not belong to either vim-only or emacs-only sect?
But a crappy one.
Awesome! any known bottlenecks/issues? i will definitely use this...
[here we go yet again](http://www.reddit.com/r/Python/comments/gdb88/what_ide_do_you_use_for_your_python_scripting/c1mqzzo)
funny thing is the "which IDE ?" thread **always** gets more than 30 replies. and...LOL....most replies are like "...vim !" or "...emacs !"
I picture you slapping the OP and then hug him LOL funny thing with these weekly thread is that most answers are like "...VIM!" or "...EMACS!"
For vertical selects, use `CTRL+SHIFT+ALT` and select. (That's on Windows, not sure what the Mac/Linux equivalent is) EDIT: wow, it's even easier than that as Buzzard stated above. The keystroke I suggested is for Visual Studio.
I don't know much more than what you can find in the tests. I guess one more bottleneck is the lack of namespace support. That's why I'm trying to get the word out: to find out what's missing and what's not working. Feel free to add issues or fork and add features / tests etc.
IDLE, with some extensions to make it awesome.
What's are the differences between your library and BeautifulSoup? Also, what happens for malformed XML?
Firewall it off and only let VPNs you trust access it. This is a perfectly legitimate way to layer concerns separately.
It's written from scratch by me as I always wanted a tiny lib for something like this. The source code is very compact - of course it's also missing functionality compared to other libs. Any XML that can't be parsed using the xml.sax parser will raise an Exception.
The more apt comparison is to ElementTree.
Well ok... I was just surfing reddit and didn't even check the link. I thought it was a self post (stupid me). Pointing to other sources on the internet so that the whole Pyhthon community can jump on it is a good thing of course. Upvoted.
There is also PyROOT.
And [lxml.objectify](http://lxml.de/objectify.html).
Emacs. FTFY
IDEs are for the weak. No Klingon would be caught using an IDE.
Just a nitpick: instead of `map` (and some other functional programming idioms) you would mostly use comprehensions in Python.
The other day I was surprised to learn that at least in Cython, lists were faster than tuples (for accessing items). Makes you wonder what the point of tuples is, if they don't have any advantages ...
http://jtauber.com/blog/2006/04/15/python_tuples_are_not_just_constant_lists/
Ah ok. I agree completely, I just didn't quite get what he was saying.
They had me until: "Out of the box, Python performs arithmetic incorrectly" ::facepalm:: Yes, binary floating point, IEEE-754 which has been around for 25 years, is wrong. If binary floating point is wrong, then I don't want to be right. 
Nice. What is the specific itch this scratches? How would you say this compares to lxml.etree or lxml.objectify? 
Wow, I like PyCharm too. lol
I know about that blog post, but it doesn't address my wonder of why tuples aren't implemented in a way that makes them faster than lists. It's just a suggestion of how tuples and lists should be used, and I disagree that this distinction of homogeneity vs heterogeneity is crucial, it is completely natural to have a tuple with only integer values. Mutability is the only enforced difference (with the important consequence that they can be used as dictionary keys).
I tried to do a simple, straight-forward implementation from scratch in order to implement only the bare essentials needed by my simple use cases. Now that I have the basics up, I'd like to hear what other people think about it, what's missing ... preferably also a little code review. That said, I want the code base to remain small and the usage dead simple.
It would be nice to see it as a deserializer for a format-neutral, well-validated system like [Colander](http://docs.pylonsproject.org/projects/colander/dev/). Portability between XML and Json is a must have for this kind of thing these days.
bug found: assert untangle.parse("&lt;reddit/&gt;")
This kinda stuff just seems so obvious. Why wasn't this done all along?
By design you get an object back which points to the root node. So assert untangle.parse("&lt;reddit/&gt;").reddit should work. It's still questionable if the assert should fail, seeing as the document is non-empty. Thanks for reporting this!
All numbers can be divided into one or more prime numbers. For example 8 is 2 * 2 * 2, 84 is 2 * 2 * 3 * 7. So using this property we can walk though all possible numbers until we find a factor of n. This factor must be prime since it would have been factored out earlier if it was not. So every time we find a factor it is a prime number. This just loops over the number dividing it by each factor it finds. Once i**2 is greater then the remainder then the remainder must also be prime, and therefore it is the largest prime.
That's easy. Nobody thought about it and implemented it and submitted a satisfactory patch before. I hope it's accepted. Edit: it's merged! http://hg.python.org/cpython/rev/44d46d74ef4f/
The problem isn't that Python uses binary floating point. The problem is making it *default*. You have to use the decimal type to get true arithmetic. High level languages should provide true arithmetic by default and approximate (fast) arithmetic as an option. Python gets int right (integers do not overflow) but rationals wrong (1/3 returns an IEEE-754 float, but it should really return a decimal value). Cobra gets this right. So do Clojure and Scheme.
well, to start you only need to worry about looking at numbers that are less than or equal to the square root of n, because any factor that is greater than sqrt(n) will have to have a corresponding factor that is less than sqrt(n) (which you will have already covered if you just limit yourself to &lt;=sqrt(n)). If not n % i is a little bit of a trick, taking advantage of the fact that python recognizes integers are booleans when necessary. if i goes into n, then n % i will return 0, thus making NOT (n % i) be true. if i does not go into n, then n % i will return some non-0 integer, and NOT(n % i ) will be false. That's for the mechanics of the code -- now for the mathematical subtleties behind it. Instead of thinking of n as the 12-digit number that was presented, think of it this way: n = x[1]^k[1] * x[2]^k[2] * x[3]^k[3] *...* x[m]^k[m], where x[j] &gt; x[j-1] . In other words, n is the product of some finite number of prime factors, each of which can be repeated several times if need be, and which are arranged in increasing order. So for example, if n = 100, then we would write n as 2^2 * 5^2, making x1 = 2, k1 = 2, x2 = 5, and k2 = 2. Each time a loop in the above script executes, it either divides out one of the x's from n (where x[j] is represented by "i", in your code), or if i isn't a factor of n, increments i and tries again. Note that the incrementing step is in an else clause and thus doesnt always execute. This is to take care of the k's -- each prime factor can be repeated, so if you find a prime factor you have to stay on it until all of it's factors are gone from n. Since x[j] &gt; x[j-1], the program chops off factors starting with the smallest x's. the final x that is left will be the largest prime factor.
Nimrod has some really good things and some really terrible things. Example of a terrible thing: &gt; Case is insignificant in Nimrod and even underscores are ignored: This_is_an_identifier and ThisIsAnIdentifier are the same identifier. This feature enables you to use other people's code without bothering about a naming convention that conflicts with yours. (from http://force7.de/nimrod/tut1.html)
Thanks, this and ThereOnceWasAMan's post cleared things up a lot! So basically a number x cannot have more than one prime factor greater than the square root of x.
Thank you for the detailed response. It finally clicked!
That's the point. The object has no reason the be nonzero.
I've never used zeo, but I just want to say that it's always worth trying to be as secure as possible. VPNs and firewalls are great for network based security as previously said. I would go further than that and look at hardening the OS (chroot, limit running binaries, insist on strict access control, etc...) and seeing what can be done about the application itself.
Fabioz did a great job with PyDev, but Eclipse is a horrible bloated, buggy, brittle and slow beast. I struggled with it for two years. Everytime I had to get someone else set up with the dang thing, we ran into all kinds of subtle problems. And key bindings on the Mac? A mess which needs to lots of work to get it into an even semi-usable state. PyCharm is $100, but works beautifully out of the box. Just point it at your existing git/svn/cvs directory and it slurps up all the repository information automatically. That's just one of many examples that make it *so* much nicer than Eclipse/PyDev. (I switched about 3 months ago).
I just use eventlet to do all networking: http://eventlet.net/doc/examples.html There they send newline delimited strings in the echo example. They turn the socket into a file descriptor so they can use .readline() and .write() methods with it. That is how they know how long the message length is. But of course their messages cannot contain newlines embedded in them. In your example from socket howto MSGLEN is something your define. So if your messages are 1024 bytes you'd have MSGLEN=1024 and so on. It is basically a constant for the lifetime of your program. You are saying your are from the Java/C++/C origin but it looks like that doesn't matter, since this is networking stuff, I think you should read more about TCP sockets and stream based protocols.
Everyone should know Vim or Emacs. But seriously -- you're recommending people give up on modern tools that do real-time code analysis, source level debugging, integrated graphical diff, etc? The simplicity of Vim and Emacs certainly beat bad IDEs like Eclipse, but I don't really see them as offering advantages over good IDEs like PyCharm.
Try the [select module](http://docs.python.org/library/select.html).
People at #python generally recommend the Twisted framework. There's also a huge ecosystem built around WSGI (my favourite combination is gunicorn:meinheld + Flask).
Something I'd definitely recommend is doing some of the [Project Euler](http://projecteuler.net) problems. They're interesting from a mathematical perspective, and they'll get you some good experience with Python. Since you've already got some programming experience, you shouldn't really have too much trouble learning the syntax :)
Mongrel2 + uWSGI + Django is a very posh (web) stack you could have a look at for said requirement. Mongrel2 is build around ZeroMQ, *sockets on steroids*, a hip and on-the-rise messaging solution/library/framework. It has bindings to 20 or so languages so it's perfect for gluing together things written in different languages e.g. you would probably be able to continue using a ton of your Java/C code and at the same time write all new stuff in Python.
Twisted is crazy-awesome ([client/server examples](http://twistedmatrix.com/documents/current/core/examples/)), but I'm not sure it fits the requirement "simple". You have to spend a little time wrapping your head around event-driven/asynchronous programming--but when you've done that, it's great.
Moreover, some of the complaints about python's decimal arithmetic are misleading. It says that python returns 0 when presented with 4/5. However, this is only true of 2.x. The more modern 3.x, which has been out for more than 2 years, returns .8.
Well, for one, I always use / instead of \ because \ has all kinds of weird issues when I try to use it and / works just fine on windows since like XP. No idea if that's your issue, just throwing it out there :p
All these tools are available in some form on the command line. Youre not using losing a single thing. Never heard a proficent vim/emacs person complain about these things. Theyre both extensible. IDEs are mostly bloated with things that should be ran after you wrote our code and tests. Also, these tools are free. Not sure why youre singling me out when others in this thread have said the same thing.
Thank you for explaining both sides to the puzzle. 
I'd also recommend using os.path.join()
Came here to recommend zeromq. +1
upvoted for being from d.i.c.
this is what i came up with. its not working So I need to create a python program that successfully calculates a reverb response time. Its not going well at all. This is my first attempt at programming. Any advice feedback would be much appreciated. here is our formula: RT60 formula (.16*V)/(Sa) Here is my code: This program will help you calculate the RT60 of a room, depending on the materials and the room volume x=0 materials = ['Brick Wall (18" thick unpainted)', 'Pouder Concrete', 'Carpeting (with pad)', 'Plywood Panel (1/8", 2" Air space)', 'Occupied Audience Seating Area', ] absortion_coefficients = [.02, .01, .10, .30, .50] def vol(l, w, h): v= w * l * h return v def surf(l, w, h): s = (2 * w * l) + (2 * w * h) + (2 * l * h) return s choice = 0 while choice != 2: print ("Welcome, this program will help you calculate the rt60 of any room") print () print () h = input ("Input the height of the room (in meters)?") while h &lt;= 0: print("Please input a positive number") h = input ("Input the height of the room (in meters)?") print() l = input ("Input the length of the room (in meters)?") while l &lt;= 0: print("Please input a positive number") l = input ("Input the length of the room (in meters)?") print() w = input ("Input the width of the room (in meters)?") while w &lt;= 0: print("Please input a positive number") w = input ("Input the width of the room (in meters)?") print() print() print("The Volume of the room is = ", vol (l, w, h)) print("and the surface of the area is = ", surf (l, w, h)) print() print() print("What is the wall material of the room? (choose one from the list, typing the respective number (1 to 5)") print('1: Brick Wall (18" thick unpainted)') print("2: Pouder Concrete") print("3: Carpeting (with pad)") print('4: Plywood Panel (1/8", 2" Air space)') print("5: Accupied Audience Seating Area") x = 0 while 1 &gt; x or x &gt; 5: x = input () if 1 &lt;= x &lt;= 5: print("You choose ", materials [x-1]) print("The Abosortion Coefficient of that material is ", absortion_coefficients [x-1]) else: print("The number has to correspond to one of the materials on the list") rt60 = (0.16 * vol (l, w, h)) / (surf (l, w, h) * absortion_coefficients [x-1]) print("The RT60 of the room at 125Hz is = ", rt60) choice = input("Please enter 1 to run again, or 2 to quit: ") while not 1 &lt;= choice &lt;= 2: choice = input("Please enter either 1 or 2: ") not_using python 3
Argument parsing is more complicated than it seems.
Me too, pyzmq is a great place to start with sockets as it lets you focus on the high level.
Just responding, not singling out. &gt; All these tools are available in some form on the command line. I wasn't aware of an Emacs-source level debugger for Python. I'm a bit skeptical. I used Emacs and tricked-out SLIME for Lisp coding a few years ago and even though it was Lisp, source-level debugging couldn't hold a candle to commercial source debuggers (like Lispworks). &gt; IDEs are mostly bloated with things that should be ran after you wrote our code and tests. "Should" - why? Real-time code analysis in PyCharm, for example, shows unused or undefined variables, enables autocomplete of class methods, and lots of other goodies I've never seen in Emacs. These are awesome productivity tools. I've seen emacs gurus needlessly struggle because they don't even know what they're missing.
Me too, pyzmq is a great place to start with sockets as it lets you focus on the high level.
I was about to say "magic and fairies" but then I remembered how bad i am at programming logic and decided to leave the smart people be.
This is good for threading and sockets: http://www.devshed.com/c/a/Python/Basic-Threading-in-Python/1/
[Load balancing work between Java threads using ZeroMQ](http://sysgears.com/articles/load-balancing-work-between-java-threads-using-zeromq). Eventlet/zmq: [zmq-simple.py](https://bitbucket.org/which_linden/eventlet/src/6e6a02e7ac7c/examples/zmq_simple.py) gevent/zmq: [gevent-zeromq](https://github.com/traviscline/gevent-zeromq) 
&gt; Am a tad befundled currently by the fashion which Python sends messages between a server and a client. How would you do it in Java/C++/C? Socket communications is easy, getting it right is hard. My guess is you aren't doing simple socket communications in your previous experience, you're using some higher level protocol. Two ends of a socket are like ends of a pipe. I can shove stuff in one end, but how do you know when I'm done sending and waiting for a response? There has to be some understanding on each end of what to expect and when to reply. Here's my suggestion: http://docs.python.org/library/xmlrpclib.html That will handle 99% of anything you need to do. Evar. 
Talk about overkill...
&gt; You are saying your are from the Java/C++/C origin but it looks like that doesn't matter, since this is networking stuff, I think you should read more about TCP sockets and stream based protocols. I wish I could upvote you more for recognizing OPs intrinsic problem.
Check out the [SocketServer](http://docs.python.org/library/socketserver.html) module in the standard library, it's probably the simplest option. Twisted, et al. are great for real work, but if you just want to play with simple stuff the SocketServer module is probably what you want. In fact, the docs have a (very short) example of exactly what you're asking for.
Do you have an example of what you are trying to do? The most simple method I can think of is to loop on .recv() until you hit something unique. 
Low level socket IO (like the kind that Python's "socket" library gives you) is a challenging topic. It is the assembly language of networking. It's only a step up from constructing raw packets yourself. If you just want a simple way to communicate over the network, it is probably better to use an already established framework and protocol, like many others have suggested. It is a relatively non-trivial task to do it yourself. If you *do* want to learn how to do it yourself, then I can at least reassure you that the mechanics of doing socket IO is very similar between Python and C and most other languages (I don't know about Java). The challenges of building a proper single-threaded, multi-threaded, or multi-process server are largely similar regardless of the language you're doing it in. "select" as aweraw recommended is going to be your weapon of choice in most cases. Also, plan on learning about the merits of non-blocking reads, and how to set up a socket to be non-blocking.
I've got a simple example [here](https://github.com/Ceasar/Python-192-Homework-5) that I did for an assignment in my Python class last semester. It's just a simple chat server that lets you open multiple clients and send messages between them.
Why use a hammer when you can use a tactical nuclear weapon? It's the only way to be sure.
Thanks for the reply. Tried it, replacing \\ with /. Code executes fine in command prompt, doesn't work for executable.
check to see if you are using "console" instead of "windows" in your setup parameters. Your script might be working but its output might be redirected. Also, don't use os.path.exists() == True. It's silly. Use: if os.path.exists( '%s:\\blade.conf' % letter ): or if not os.path.exists( '%s:\\blade.conf' % letter ): if you want to check for a false. Also, take a look at [this snippet](http://pastebin.com/5EfR2f9d). It's a better way to check for drives (your script throws a "drive not ready" error). 
Thanks for the reply. Thanks for the if.. statement correction, the original was odd. When the script opens the .exe, the .exe generates a log file, which is how I'm checking whether or not the python script ran correctly. I'm not completely sure if the snippet is what I need, I'm looking for a flash drive that must have blade.conf in it. My build script is here: from distutils.core import setup import py2exe, sys, os sys.argv.append('py2exe') setup( options = {'py2exe': {'bundle_files': 1,'compressed': 1, 'optimize': 2}}, windows = [ { "script": "fbex.pyw", "icon_resources": [(1, "bobafett.ico")] } ], zipfile = None, ) 
etree objects behave like a list of their children, so it makes sense that they kept the container convention of using non-emptiness as their bool value. The current version recommends being explicit, using `len(elem) == 0` or `elem is None` depending on the intent.
Somehow I feel that judicious addition of the phrase "including 'self'" to the error messages pertaining to methods would reduce the cognitive load in processing these messages. I'm all for explicit 'self' in Python but the fact that in the common case it isn't required in the argument list at the call site means I have to subtract one from the list of expected arguments. What I want is this: &gt;&gt;&gt; class Foo(object): ... def bar(self, value): ... print value ... &gt;&gt;&gt; f = Foo() &gt;&gt;&gt; f.bar() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: bar() takes exactly 2 arguments including 'self' (1 given) 
The snippet is used to search for a flash card used by a photo camera. It's very similar to what you have. The main advantage of using win32com is that you get information about the drives and you can avoid the "drive not ready" error. You might not see this error but users with a card reader might see it. ;) If your script does not have a GUI, replace windows = [ { "script": "fbex.pyw", "icon_resources": [(1, "bobafett.ico")] } ], with console = [ { "script": "fbex.pyw", "icon_resources": [(1, "bobafett.ico")] } ],
I don't think their front-page example makes a compelling case for Python programmers. Could someone say whether or not this is worth learning for the non-dot-NET crowd? IMO this example really goes against the grain in Python: &gt;&gt;&gt; query(words).order_by(len).then_by().take(5).select(str.upper).to_list() vs &gt;&gt;&gt; [w.upper() for w in sorted(sorted(words), key=len)[:5]] or &gt;&gt;&gt; list(map(str.upper, sorted(sorted(words), key=len)[:5])) 
Yes: let's say a and b are both prime factors larger than the square root of x. Then a\*b is the smallest number they can both be a factor of. But a\*b is larger than sqrt(x)*sqrt(x) = x, so that's not possible.
If you look at their [xmlrpc example](http://twistedmatrix.com/documents/10.2.0/web/howto/xmlrpc.html), it is very very simple to get a server up and running, basically just sub class twisted.web.xmlrpc.XMLRPC, and prefix the names of methods that should be exposed with "xmlrpc_". If the OP just wants to be able to go `proxy.foo()` and have foo called remotely, then I would definatly reccomend twisted.
Oh, I understand now about the drive issue. Thanks! After switching from windows to console, I can see it going through the lines of my script, finding blade.conf, but it doesn't execute it like running the python script does.
Well, the 'Pythonic' version eagerly evaluates the entire sort (twice!) whereas the asq version performs one partial sort (sorting only sufficiently to get the first five items in order) using both keys combined into one comparator. Also consider cases where you want to sort by multiple keys some in ascending order and others in descending order which can be more tricky to get right, whereas with asq you could write: &gt;&gt;&gt; query(words).order_by(len).then_by_descending().take(5).select(str.upper).to_list() Finally, asq includes support, albeit not yet at production quality, for performing queries in parallel across multiple cores: &gt;&gt;&gt; query(words).as_parallel().order_by(len).then_by().take(5).select(str.upper).to_list() According to the project [roadmap](http://code.google.com/p/asq/wiki/RoadMap) production-quality parallel support is coming in asq 2.0.
That's a feature of Python's socket library, not specifically eventlet. See http://docs.python.org/library/socket.html#socket.socket.makefile for how to make a file object interface to your socket. In fact, looking at their examples, all they do is invoke the makefile() method of the socket as provided by Python's stdlib.
I just did a test. It looks like tuples are a little faster, though not "bottleneck" faster.
The same general recommendation of Twisted is in my opinion also the reason why working with raw sockets on Python, specifically in a threading environment, is in a dire state. Twisted is all fine and dandy, but I personally find the API horrendous to deal with. On larger projects code become increasingly unwieldly. I am unsure why you even mention WSGI.
It works reasonably well. Quite easy to set up a threaded server with SocketServer and the ThreadingMixIn. But threading could be much improved in Python.
You might want to set git to ignore .*.swp *.pyc *.pyo
I personally found http://showmedo.com/videotutorials/series?name=J8Pgfi4nA to be an interesting resource when it came to threaded socket operations.
Check out rpyc. 
Geany FTW. I also use it for C++, bash and Java. It's small, fast and great overall.
maybe os.startfile('%s:\\bex.exe' % letter) works. :)
This both is a good thing and a bad thing. I think it's more bad than good, but hell, it's gonna save lots of nerves. Although I believe underscores at beggining should not be ignored.
Nearly all client-server communication is based on socket programming but it rarely a good idea to work at such a low level. The easiest thing to get going with python is xmlrpc: see the xmlrpclib and SimpleXMLRPCServer (http://docs.python.org/library/simplexmlrpcserver.html). The nice thing about xmlrpc is it is not python-specific, so other platforms can interoperate. Also built in to the standard library is multiprocessing.connection.Listener and multiprocessing.connection.Client . These are a good way to send serialised python objects between processes/hosts. More featureful python RPC is available from: - RPyC (http://rpyc.wikidot.com/) - Pyro (http://irmen.home.xs4all.nl/pyro3/) Finally, if you really want low level socket stuff you should look at zeromq (http://www.zeromq.org/). If you want to do everything based on HTTP protocol (good for interoperability), then you have *lots* of http-servers to choose from. CherryPy might be a good place to start but there are plenty others.
Thank you. Your points are well taken -- especially regarding the parallel processing aspects. One way to get out of the double sort is a more complex key: skey = lambda w: (len(w), w) [w.upper() for w in sorted(words, key=skey)[:5]] As to mixing ascending and descending ordering within a partial sort, it sounds like a great idea for a new sort function that yields the sorted values from a generator. 
This looks like the client and the server are very tightly connected during the execution. I was thinking of something more like PiCloud: pack all which is required from the client, send it to the server for processing, get the result back when that is done.
Maybe far fetched but these days I'd actually plug ZeroMQ on both ends (client/server) and then you can in its simplest case just put your `foo.py` script onto both and add a few ZeroMQ lines to send/receive "instructions" and of course execute stuff if you're the receiver. This would be very modular thus flexible and above all, just a tiny bit of add-on for existing code you already have so it makes it possible to reuse stuff you've written in the past.
You've linked Pyro 3.x which is perfectly fine, but I just want to point out that there's also Pyro 4.x (http://irmen.home.xs4all.nl/pyro4/) which is the actual version. It is only lacking proper documentation at this time but I'm working on that. (Pyro 3 comes with extensive documentation).
just because you can mash syntax in python, doesn't make it pythonic. the "pythonic" examples look perlish.
As an aside, you're better off avoiding a sort altogether in cases like this, and using something like: [w.upper() for w in heapq.nsmallest(5,words, key=lambda w: (len(w),w))] which is generally more efficient (only needs a single pass, so it's O(n) rather than O(n lg n)). Also, you can also get alternating ascending/descending by manipulating the key. As a hack, key=lambda x: -x is equivalent to descending for integers. More generally, you can wrap the key with an object that reverses the comparison. Eg. class Desc(object): def __init__(self, obj): self._obj = obj def __cmp__(self, other): return cmp(other._obj, self._obj) Which makes the ascending length, then descending by name version: [w.upper() for w in heapq.nsmallest(5,words, key=lambda w: (len(w), Desc(w)))] 
In Cython? Well not in my code, but I measured overall speed of the whole program (with tuple/list as only difference)
nsmallest puts the whole list in a heap, which is O(n) with n being the length of the whole list, but to get the k-smallest elements you need to pop from the heap which makes the total O(n + k * log n), which is still better than sorting the whole list of course, but not quite linear. I recently found that using a quicksort selection algorithm, which returns the k-smallest items in unsorted order, performed better for my purposes.
If by that you mean you want to be able to drag files into your application, I think that is a windows thing and might be best to do a google search or find an open source application with that functionality. I don't know if it is already there and you just have to hook into it or if you have to code it.
I haven't look at the PiCloud implementation, but I guess most of the problem is knowing the boundaries of your environment. For example, deploying with, say, `pip bundle all.pybundle dist/*.tar.gz` is one way to set the boundaries; the server can bootstrap itself portably and reliably enough from source packages. Pickling instances of your own classes requires these classes to be visible to the server, and maybe passing around some file contents or code objects.
Also: Klingons do not "release" the code. The code "escapes" murdering all in it's path...
Actually, this is exactly what asq is doing under the covers - both using a heap and building the wrapper class with the modified relational operators, and then lazily popping elements off the heap as required. I'd argue the intent is clearer in the asq incantation though, and if we subscribe to the [Zen Of Python](http://www.python.org/dev/peps/pep-0020/), then "Readability counts".
I like the idea of wrapping the object with a new comparison function to get arbitrary sort order for the key values. I suggest to use `__lt__` to be compatible with Python 3. 
I would also recommend web2py using it's service decorator where you can define how output of your "webmethod" will be transferred back to your client. For the sake of low protocol overhead I would suggest you to have a look at json-rpc. If your API is clearly defined you get the advantage to programm a fatclient frontend or use AJAX technologies to code the frontend. As raw socket i/o is nice (therefor zeromq would be best) creating a more compatible frontend using SOA is in my opinion the way to go.
I didn't find a couple aspects of it clear: the end from which it will "take" items and also how select uses the function argument. Why should select mutate the data; shouldn't the argument be a filter? I figured it out from looking at the results. I'd have maybe a 50/50 chance on a test question given no prior knowledge of LINQ.
"False" is a non-empty string, which is of course True. def mybool(val): return { "__False": False, "__True": True, }.get(val, bool(val)) You can use above snippet or variations thereof *if you really have to* serialize- unserialize booleans yourself. I prepended the strings with double underscores to prevent accidental collisions with strings containing "False" which should be True. ;-)
the LINQish version is a bit more readable.
Can you elaborate. I'm working though this example on a project I'm working on, so now you have me a little scared.
That's an interesting point. I haven't run into the stability issues, but I don't get to use it for writing production code either. If I experienced your issues and had to "get something done" with it, a $100 price tag for alternatives would begin to look *very* appealing.
It looks like version 3.0 on the roadmap, "pluggable asq providers", would be the point at which SQLAlchemy SQL expression and/or ORM plugins could be built is that accurate ? At least then we'd have an exact drop-in for linq-to-sql. 
I'll use this from now on; until now, though, [this](http://thepiratebay.org/torrent/5090599/UK_government_database_of_all_1_841_177_post_codes) has served me well.
I think this is only a pitfall if you haven't seen the documentation. &gt; Convert a value to a Boolean, using the standard truth testing procedure. *If x is false or omitted, this returns False; otherwise it returns True.* bool is also a class, which is a subclass of int. Class bool cannot be subclassed further. Its only instances are False and True. "False" is just a string with the contents having no particular meaning. The `bool("False")` call is pretty easily dissected in C - `bool_new` in `Objects/boolobject.c` is where this occurs. All it does is have `PyObject_IsTrue` (from `Objects/object.c`) tell it about the value. In the case of `"False"`, that function sees that the value is not `True`, `False`, `None`, a number, or a mapping, so the test is on the length of `"False"`. A zero-length string gives you `0` or `False`, and anything else gives you the length as a positive number which converts to `True`.
 &gt;&gt;&gt; False != "False" True &gt;&gt;&gt; 
That python thing bites y'know ?
Here's a little Tk demo for you to play around with that uses COM via pywin32. You'll have to modify it a bit for Python 2 (Tkinter mainly). from tkinter import Tk, Listbox from tkinter.constants import * import win32con import pythoncom import pywintypes import win32com.server.policy from win32com.shell import shell, shellcon class DropTarget(win32com.server.policy.DesignatedWrapPolicy): _reg_progid_ = "Python.DropTarget" _reg_clsid_ = "{411c82bc-d2c4-4a67-a8fa-6a94996190bd}" _reg_desc_ = "OLE DND Drop Target" _com_interfaces_ = [pythoncom.IID_IDropTarget] _public_methods_ = ['DragEnter', 'DragOver', 'DragLeave', 'Drop'] data_format = ( win32con.CF_HDROP, None, pythoncom.DVASPECT_CONTENT, -1, pythoncom.TYMED_HGLOBAL) def __init__ (self, hwnd): self.hwnd = hwnd self.drop_effect = shellcon.DROPEFFECT_COPY self._wrap_(self) self.register() def DragEnter (self, data_object, key_state, point, effect): try: data_object.QueryGetData(self.data_format) self.drop_effect = shellcon.DROPEFFECT_COPY except pywintypes.com_error: self.drop_effect = shellcon.DROPEFFECT_NONE return self.drop_effect def DragOver (self, key_state, point, effect): return self.drop_effect def DragLeave(self): pass def Drop(self, data_object, key_state, point, effect): global text_list try: data_object.QueryGetData(self.data_format) data = data_object.GetData(self.data_format) n_files = shell.DragQueryFileW(data.data_handle, -1) text_list = [] for n in range(min(n_files, 20)): text = format(n + 1, '&gt;2') + '. ' text += shell.DragQueryFileW(data.data_handle, n) text_list.append(text) except pywintypes.com_error: text_list = ["Unsupported data format"] def register(self): try: pythoncom.RegisterDragDrop(self.hwnd, pythoncom.WrapObject(self, pythoncom.IID_IDropTarget, pythoncom.IID_IDropTarget)) except pywintypes.com_error: global text_list text_list = ["COM failure!"] def update_list(): listbox.delete(0, END) for t in text_list: listbox.insert(END, t) root.after(100, update_list) root = Tk() root.geometry('720x360') listbox = Listbox(root, font=("Courier", 10, "normal")) listbox.pack(fill=BOTH, expand=1) text_list = ['Drag files to this window.'] hwnd = root.winfo_id() pythoncom.OleInitialize() root.after(100, update_list) root.after(200, DropTarget, hwnd) root.mainloop() 
Check out [Twisted Perspective Broker](http://twistedmatrix.com/documents/current/core/howto/pb-intro.html). Otherwise known as peanutbutter.
I'd like to point out that I'm (1) using Linux and (2) like to keep it cross-platform. Anyway, thank's for the demo.
There are urban legends about Indian Java coders using "True" and "False" strings as boolean flags. Perhaps Python's choice was meant to troll those ones :-)
Sounds similar to [execnet](http://codespeak.net/execnet/)
Bools are treated differently because there are many contexts which could potentially define how *bool()* behaves, and it's relation to *int()* is only one of them. One of the design principles in Python is that the common case should be simple. Explicit *bool()* is not the common case, the most common use of *bool()* is the implicit one contained in every *if/then* condition - anything that's passed in as the conditional expression of an *if* statement is coerced to bool if it's not already a boolean. The logic that best makes sense for this case is that non-empty strings are *True* and empty strings / None are *False*. This allows easy testing for a non-empty string, eg "if x: ...", a very common operation... which also matches with easy testing of empty dicts ("bool({}) == False", "bool([]) == False", etc). These are the common cases which bool's behavior is designed to deal with. If *bool()* also accepted "False" etc, it would be incredibly hard to predict the outcome of an if statement in many cases. And which language should the word "False" be written in? English? User's locale? In any case, the statement "x = False" becomes incredibly hard to predict if x might be a string. And the behavior of all the constructors is to mimic any implicit coercion python uses, so *bool()* pretty much has to follow all of the above... principle of least surprise and all (also to simplify the implementation of everything).
Well... &gt;&gt;&gt; int('reddit') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ValueError: invalid literal for int() with base 10: 'reddit' &gt;&gt;&gt; bool('reddit') True bool() doesn't work like int() and float(). It's not intended to -- read the docs.
x cannot have *any* \*prime\* factors greater than sqrt(x). There can be composite factors, though. ETA: herp derp
Would anyone care to post why they need this data?
That's to be expected. Here's an actually nasty one from Javascript for you: new Boolean(false) That's an object (which is truthy) that acts false in some contexts. Fun times!
you mean like [KnowBots](http://www.cnri.reston.va.us/home/koe/people.html)?
Yes, that's certainly the ambition level. Do you think there is much demand for such a thing as asq-to-SQL(Alchemy)? What about a asq-to-XML -- any takers? Would you rate this as more or less important than complete PLINQ (parallel execution) support?
Link: http://www.jetbrains.com/pycharm/ PyCharm Features: http://www.jetbrains.com/pycharm/features/index.html What's new since 1.2: http://www.jetbrains.com/pycharm/whatsnew/
To answer your specific questions: Regarding take(), &gt;&gt;&gt; import asq.queryables &gt;&gt;&gt; help(asq.queryables.Queryable.take) Help on method take in module asq.queryables: take(self, count=1) unbound asq.queryables.Queryable method Returns a specified number of elements from the start of a sequence. If the source sequence contains fewer elements than requested only the available elements will be returned and no exception will be raised. None of the query operators such as select() mutate the sequence, they all return a new iterable over the result elements, most of them lazily, like a generator. The method names and behaviour are the same as LINQ. 
If your trying to run a website that takes a users postcode and provides location based services (e.g. Nearest shops, businesses, etc) you need to know where a postcode actually exists. How do you think all those "Find your nearest branch: [input postcode]" features work?
I presumed if you're already on the net it was doing some googling behind the scenes. Seems a little easier than just having a database of post codes on your site somewhere.
Maybe it's a pitfall, but Python does it right. bool is implicitly used in if and while, so it has to behave like a conversion rather than a constructor. So the semantics are something applicable to almost every object, and it converts to true mostly if the object is considered "nonzero". Which is the case for almost every object, except empty containers and zero numbers. Making strings falsey when they are non-empty containers would cause more headache.
Move the Panic.wav sound into the same directory as the script. Then: panic=pygame.mixer.Sound('Panic.wav') See if it plays. If it does, then your directory structure isn't working the way you think it is. 
You'll need to use GTK or some other GUI toolkit to abstract away the platform specifics. Otherwise, the above shows a bit of the OLE DND protocol on Windows. Linux systems use the XDND protocol, and OS X uses Cocoa DND. 
Well, since SDL/pygame doesn't have built-in support for this, I think your only real option is to implement it like this for every platform you care about, and to handle the signals yourself. 
I was I just pointing out the technique. Eventlet greens the socket module and you can use all the regular socket operations. It is just that eventlet docs have a much better example of how to do newline delimited messages over a stream than the standard docs. &gt; all they do is invoke the makefile() That's exactly the point. If you just want to do basic newline delimited messages over TCP you dont' have to write your own accumulation buffer, you can juse makefile(). Wish standard docs would just point that fact out. One sentence would really do the trick.
That then_by in the asq example looks COBOLesque to me. Having order_by take multiple arguments would be far more elegant than pretend English.
I suppose that's not the best of examples, possibly if you wanted a backup to whatever online service you was using or was just paranoid. He does mention that his data is more accurate than some online services.
Awww :/ Guess I'll give up writing my own file manager for now. I've got few other projects I'm working on right now anyway.
That's a fine enough answer for me. I just thought that there would've been some *greater* use for this is all.
Thanks again. I realize it's stuck with LINQ's nomenclature. By mutate I just meant that it's altering the returned values (such as making them uppercase), not mutating the underlying objects. It was counter-intuitive to me that a selection would do that. I expected the argument to be a predicate. Regarding 'take', I thought it could go either way -- taking from the beginning or the end. Neither of these was hard to figure out based on the results. 
The API naming is directly from LINQ. Your multiple order_by() arguments is a nice idea and could make certain queries more concise; I'll consider it as an option for a future version. However, the method chaining allows you to do also specify the sense of the sort for each key. query(xs).order_by(len).then_by_descending(lambda x: x.foo).then_by(lambda x: x.bar) or more concisely using some other features of asq: query(xs).order_by(len).then_by_descending(a_("foo")).then_by(a_("bar")) 
Writing a file-manager in pygame sounds like an awful idea anyway, tbh.
While I use this in several projects, this doesn't handle the OP's requirement of actually transferring the code as well before executing it. You'd have to do that on top of it. However, sending code to execute seems like a security nightmare waiting to happen, so it might be better to write it so you don't have to send arbitrary code to execute...
Is there a more legitimate source for this data, or is it still licensed from the royal mail?
I have never or heard anyone struggle due to the lack real time code analysis in their editor. Anyone using Vim/emacs can accomplish the same thing as someone using an IDE. Still in all, the shortcuts and tricks that Vim/Emacs have are far superior than any other IDE or editor. Even a lot of IDEs try to mimic them because they know how powerful they are.
In practice, fully accurate locations to the entire extent of the postcode are not generally available across the entire UK. As an example, unless you are using Google maps directly, using their API Webservice will return with a less accurate result, for example a postcode of the form AANN NAA will only return AANN NA (missing the last character and therefore accuracy). This is not *always* true, but if you have an app that needs accurate positioning info from postal addresses, then hooking the Google services up is not always the most accurate option (strangely unless you are also using their maps to display the data!). Also, in my case, I run a number of geo aware applications which need to be able to work without an internet connection - web API's are therefore useless. In any case, a 50Mb searchable and freely distributable database of *every* valid UK postcode is not something I am aware of that exists anywhere else, hence my reason for sharing it. (I'm still looking for freely available data for the Isle of Man and Channel Islands though)
true, the linq extension functions suck as syntax in python as well in C#. But C# does have the linq augmented syntax, python doesn't.
There is ;-) I needed it, therefore I built it. I thought other people might find it useful too! Plus for anyone learning Python, or just programming in general - finding out how to convert between co-ordinate systems based on arbitrary geoids as well as understanding why latlongs aren't always the same is a fairly fun thing to learn. As an example, did you know that latlongs measured by the Ordnance Survey are different than the ones measured by your iPhone GPS? In some places, this difference can be fairly significant.
neat
It would seem that XML (such as etree objects) and direct SQL (without the need for SQLAlchemy) would be much higher value targets for asq than python objects - LINQ's agnosticism between data sources seems to be it's strongest suit. Of course, getting this far is nothing to sneeze at either.
my experience is that even though pycharm is a _really_ slick IDE and my weapon of choice, the x.x releases are pretty unpolished. i just checked most of the new docs features and a number of glitches are easily spotted. a brilliant app, but the lack of hardcore QA is a pity imho.
So fill me in. What does it mean to "green" something?
As a .NET and python developer I am definetily gonna try it out. Seems really nice.
[Pyro (3.x)](http://irmen.home.xs4all.nl/pyro3/) does what you are describing. It pickles the modules (source or bytecode if available) needed to run a piece of code on 'the other side' and sends them across. They are added to the module list there and once all dependencies have been satisfied, the code is executed. This works transparently. Pyro 3.x comes with an example that uses this to send computation tasks to the servers that will execute them. There's a couple of rather serious problems however, which is why the feature is disabled by default in Pyro 3.x, and not available at all in Pyro 4.x.: * It is a security nightmare if you're not 100% certain about who is connecting to your server. * It messes around with Python's import logic, which is kinda complex. It can trigger obscure problems, for instance, deadlock on the internal import lock. I've tried to work around this as good as I could but it proved to be quite hard, and I'm not sure all weird cases are taken care of. * You cannot 'reload' modules that have already been transferred before. Although this might be considered to be a limitation of Pyro, I do think this aspect would be very hard to get right (and not a task that Pyro should solve for you) * It made the remote calling code quite complex. I now prefer an easy, testable implementation over this particular feature. You can perhaps emulate a form of mobile code by building it using explicit remote calls that transfer the correct source files, or something.
I applaud your skill, that's for sure. One can only dream of completing a project like this. I've got some books coming in the post, I know that reading books will not solely advance my knowledge, but having books around is a definite boost for productivity. Thanks for linking.
That's actually pretty damn cool. See, I wish I think of stuff like this to make.
Check out [ExecNet](http://codespeak.net/execnet/).
After some quality time with the timeit module, my answer is: it depends, but the difference is slight. Accesses on tuples and lists are relatively fast. As for the advantages of tuples: 1) They're immutable, so they can be used for keys in dicts, sets, and other things that require hashes. 2) They're hella efficient. The interpreter keeps a statically allocated free list, so tuple creation is often extremely efficient. The fixed length allows the free list entry to contain all of the tuple's memory. Spend some quality time with tupleobject.c.
Excellent! I just installed it and I'm loving the dedicated reStructuredText mode already. I'm still getting unresolved references for built-ins such as enumerate() when used with IronPython 2.7 through...
Agreed. They need to ease off on the new features and concentrate on quality attributes (correctness, stability, performance, usability) for a release or two.
The security could be handled separately. I wanted to do this as a proof of concept and then come up with sandboxing: limited resources, limited rights on the target and blocking network access in the executed code.
TIL I can explicitly convert to booleans with `bool(x)` instead of `not not x` (`!!x` is the JavaScript idiom for this). Not that I have ever needed to explicitly convert anything to boolean in Python yet. The implicit conversion is usually good enough and I don't find myself using (and storing) pure booleans much.
&gt;... expected [the argument to select] to be a predicate That would be `where() `. It took me a while to learn the naming conventions (I guess a bunch of the names come from SQL) 
Having this available for SQLAlchemy objects would be a huge win for us. At my company we write a lot of software for scientific data analysis and often make use of SQLA. However, we also have a lot of non-SQL data sources as well. Being able to create reports and data aggregators using the same set of functionality regardless of the data source would most excellent. We've already had numerous instances where we started off with a database that had a reporting layer done in SQLA but then later decided that we want to use some other file format instead of a database and had to rewrite the queries. At least two developers here have already taken a crack at writing a similar set of functionality for general Python objects, but I think I'll try to start using asq for those kinds of things in the future...
I can't judge what the demand would be though it would be a great proof that SQLA can do everything LINQ does - it might also send back improvements to our API as a result.
I didn't know that bird swarms used Python and Pygame...although I suppose Parrot does offer Python support... 
That makes sens. But it's not the behavior of untangle.
I didn't know that bird swarms used Python and Pygame...although I suppose Parrot does offer Python support... 
the problem with the whole approach of LINQ though is that it is, like everything else, a leaky abstraction. A single query is going to behave really really differently based on backend and often would need tweaks that are specific to each context.
I wrote [a level editor in pygame](http://www.minecraftforum.net/topic/13807-mcedit-minecraft-world-editor-updated-for-mc-beta-165/). It was an absolutely terrible idea. I wish I had picked wxWindows when I started.
Pickle pickles data. I don't think it pickles code. But, code is just strings to an eval. Find an echo server, add an eval, reply with pickled return. And ye're done. 
This is awesome. This makes me want to learn Pygame.
This is incorrect. Example: 13*2 = 26, the square root of 26 ~= 5.1. 13, which is a prime factor of 26, is greater than 5.1.
Nice. Couple of observations: 1. Follow PEP 8. Your formatting is a bit inconsistent and that's (very) slightly harder to read. 2. Way too many global variables. Refactor them away, or put them in an object instance to hold state, and then pass that state around to your functions. 3. Too many needless comments; this detracts from readability. I realize you might be after instruction/edification, but you've gone overboard in cases like this: screensize = [1000,700] #screen size in pixels That's just as bad as something like this: x = x + 1 # increment x It's bad because it slows down the reader -- and code is read many, many times more than it's written. Also, comments can be considered non-executable code, in that you've got to maintain their accuracy just like you do the executable code. More is not necessarily better. 4. Use boolean expressions more effectively. Two examples: if running == False: Should be: if not running: And also: if ((( (b1b2v[0]*birds[x][2][0] + b1b2v[1]*birds[x][2][1])/(vmag(b1b2v)*vmag(birds[x][2]))))) &lt;= viewangle: return True else: return False Could be written: return ((( (b1b2v[0]*birds[x][2][0] + b1b2v[1]*birds[x][2][1])/(vmag(b1b2v)*vmag(birds[x][2]))))) &lt;= viewangle 5. You're using lists a lot as return values; these are more expensive than tuples, so if you can, use them instead, especially where you're making lots of them. 6. Don't guess about performance problems, profile and know for sure. Good luck! 
Did you submit them to the tracker?
As far as I know, it is. I have only used that data for testing and some private (non-commercial) projects. The 'official' data still appears to be [quite expensive](http://www.mapstop.co.uk/cat236_Postcode-Datasets.aspx).
Evar! heh. Encryption, authentication, persistence to name three missing things. Still, XML-RPC is easy and cross language so a good suggestion.
Aha, good question. It means that the module has been monkey-patched such that typical blocking functions from it, that would normally block the whole *process* when called, will not block the whole process but only the *green thread* it is called from. Now there are at least 2 strange terms in that paragraph -- monkey-patched and "green thread". Not sure which one you'd like to know more. But monkey-patching is overwriting behavior of class methods and functions at runtime. So you can take the socket module and at runtime replace some of its functions with non-blocking versions. When user calls .recv() the process is not put to sleep but only one threads where it was called from is put to sleep. Others can continue executing. Green threads : green threads are threads that are not backed by regular OS threads (like default threads are in Python). These threads are all set up inside the process in user-space. Now you are probably thinking "Well what good is that? Why the heck to I want user-space threads when standard Python already has _real_ threads?" -- Well, that's another good (albeit hypothetical) question. Green threads turn out to be better for Python as real Python threads cannot run code in parallel in Python because of the GIL (Global Interpreter Lock). But they sure can lead to the same preemption and race-conditions so you have to put locks, semaphores, and queues in place as you would for real OS threads. So you get the worst when it comes to threading in Python: 1) Have to deal with fine grained preemption and synchronization issues (yes even something like x+=1 is not thread-safe with default threads). 2) Can't really run computations in parallel because of the GIL. 3) You can spawn a surprisingly small number of them. No running 100K threads on a regular laptop. Bummer. That makes me sad. :-( So what if someone came to you and said, that they have a library that makes 2 of the above points go away. Let's say they can make 1) and 3) disappear. That would be great, won't it? And, surprise, the creators of eventlet and gevent have done that -- they created a threading model that doesn't rely on real OS threads, they rely on 'green threads'. These threads are provided by another low-level library module called greenlet. These threads are very lightweight and you can create hundreds of thousands of them per-process. Imagine you have a chat server with 100K users connected, it would be more difficult to manage one thread per user is you used real OS threads, but with green threads it is not a problem. Also these threads do not unpredictably switch underneath your code when you are not watching. So you don't have to protect most data structure accesses since the only time these threads will switch is when doing an explicit sleep or performing IO. If you are just updating a dictionary with some data or iterating over a set, you don't have to put locks and queues in place to protect your data against corruption. That is the the (extended) story behind "greening" modules.
[PiCloud](http://www.picloud.com) dev here. To figure out how to handle everything, you can look at the cloud module [source code](http://pypi.python.org/pypi/cloud/). This covers pretty well how to build a client that pickles everything locally (see cloudpickle.py) and transport all necessary info to the server. Building your server is an entirely another matter. The easiest case is if the clients are 100% trusted and the server and client source tree matches. In that case you can just depickle a client function and execute it. 
You may take a look at pyglet. I am not sure whether it is ported over to 3.x. 
Err, did you actually write your own software rasterizer, or do you use pygame with pyopengl?
Very good advice, thanks for taking the time! I briefly skimmed the code but gave up because the poor formatting bothered me too much (I'm overly finicky because it's almost bed-time). One small addition: &gt; you've gone overboard in cases like this: &gt; screensize = [1000,700] #screen size in pixels I think a comment that just says "in pixels" would actually be nice, so I consider the above better than no comment at all. Bonus points for formatting it as a docstring. And there should be a space after the comma, of course. Profiling to identify a function that becomes slower over time would be a bit more involved than just finding one that is generally slow, but could be done. I didn't see anything that would make me suspect a memory leak, so before you go searching for one, just monitor the process with something like top or process manager to see whether it grows any larger. It's probably something else; alas I can't see what it would be. OP: &gt; slows down after a while How long is "a while"? I ran it while I looked over the code and wrote this comment, didn't notice any slow-down after seven minutes. Oh, but I thought of a purely aesthetic suggestion: try limiting the rate at which the birds can turn, smoothing out their flight paths might look cool. Making them avoid crossing the window borders (in non-wrap-around mode) might also be neat.
&gt; I think a comment that just says "in pixels" would actually be nice, so I consider the above better than no comment at all. Respectfully disagree. The fact that the values are pixels is easily assumed, and I would add a comment if and only if the value wasn't pixels. Bonus would be `screen_px = [1000, 7000]`. &gt; And there should be a space after the comma, of course. Yes, exactly! 
Are you referring to just performance characteristics, or other forms of behaviour as well?
The docs say it should work using 2to3
Out of curiosity, you say: &gt;Don't guess about performance problems, profile and know for sure I am not so advanced and was wondering how one goes about profiling. Tips or anything else would be greatly appreciated.
Improvement? What improvement? Indent-aware syntax is not all of Python.
It would be better if there’s setup.py in the root and it’s packaged with `distutils` and [Distribute][]. Read [Distributing Python Modules][1] also. [1]: http://docs.python.org/distutils/ [Distribute]: http://packages.python.org/distribute/
Agreed that the variable names could reflect the unit of measurement, but I would insist that the unit of measurement be stated either there or in the comment. It shouldn't be assumed.
A better bonus is *screen_px = (1000, 700)*. I see no reason that a list should be used here.
no you can't override python's syntax. so when you use the generator syntax, you'll always get back an instance of &lt;type 'generator'&gt; you could write a simple wrapper though. class wrap(object): def __init__(self, gen): self.gen = gen def __iter__(self): return self def next(self, *args, **kwargs): return self.gen.next() and use it like so sum(wrap(x ** 2 for x in xrange(20))) although this example would be better without the wrap use. in fact I'm having a hard time coming up with a reasonable use case for an argument eating wrapper like this. consider revisiting the assumptions that led you to think you need such a thing in the first place.
I use webfaction, its great
Awesome! This could only be better if it had exercises, but seriously, thanks for sharing this. :]
not sure if anyone posted [this](http://www.evolt.org/node/60276) but if not, you can check it out. hope that helps.
Oh, good catch!
I use Dotcloud and I absolutely love it. Once you get it all set up it is extremely simple to use and seems to work nicely as well.
I am not sure how much of an issue not being able to reload a module would be. A Python process should be created for each submitted function / set of functions. When that function / set of functions is done, the process is stopped and the results are returned to the caller.
It's actually very easy, and the batteries are included. See [this](http://docs.python.org/library/profile.html#module-profile). 
In this case, I think the assumption is quite safe. It's how pygame measures the drawing area, and absent any coordinate system defined within the app, there is exactly one kind of unit for this, and that's the pixel. I mean... what else could it be (for this app)? Also, if you've got to have a comment, a better one would indicate the dimensions, e.g., `# H px by W px` or similar. 
&gt; I mean... what else could it be (for this app)? Well, that's the rub, isn't it? The program could very well be calculating the field of action on an arbitrarily sized virtual plane/space and then mapping the results into the current screen size plane for partial or full display. We wouldn't show an equation without units of measure, and all I'm suggesting is that we give the same consideration to code. Why make the reader guess, regardless of how obvious it appears to be when first writing the code?
I am starting out with VIM/macvim. I would be more than happy to know how can these be achieved?
Please do submit the reports about the glitches into the issue tracker. The diversity of real-life Python projects makes it really hard to cover all possible cases via hard-core QA.
Will do. Thanks for the helpful code!
Cool project!
Thank you. The order_by idea is from [SQL](http://www.sqlalchemy.org/docs/core/tutorial.html#intro-to-generative-selects-and-transformations)[Alchemy](http://www.sqlalchemy.org/docs/core/expression_api.html) and [Django](https://docs.djangoproject.com/en/dev/ref/models/querysets/#order-by); they support descending orders with a desc modifier and a minus sign respectively.
Excellent! Thank you.
I've used flixel and pygame a bit. I'd say built-in physics and collision detection is a nice feature though not a very simple one to add.
upvoting is a way to say thank you.
Double done!
Just tested this and this works correctly for me. Do you get any error messages if you press "Reload" in Settings | Python Interpreters?
If you can make the library present the user with an idiomatic python environment for developing games, I'd be all for it.
Definitively much interest here!
Creating a new competitor for the sake of having more competition is pretty stupid. You lose the accumulated experience of the existing frameworks. The ecosystem gets conflicting options for doing the same thing, with divergent features and misfeatures, and your potential users have to spend time choosing to which they will be tied in the future. Have you considered improving and extending one of the existing projects?
What's the "jinja2-scenario" that the author mentions?
Very good article. The future of Zope is Pyramid.
I used to be heavy into Zope, back in the early 00s. I don't miss it. The python was nice, but the templating languages they used then, and the hacks they kept adding on top of them really didn't work well. DTML was crap. ZPT was a step sideways, having some benefits but a lot of added headaches. Plone was... Well, Plone was Plone. 
Zenoss...
I've only used the ZODB, but I thought that was pretty sweet and simple to use. I have a site running on an ancient Plone version, but when I look at the templating, I shudder.
or [bluebream](http://bluebream.zope.org/) depending on who you talk to. :-)
Haha, you're totally right! My bad.
Zope preaches too much XML for my taste.
Why don't you look into Dabo, a very mature Python desktop DB framework, which can connect to a DB server on the web. It handles authentication. The final source code can be assembled into an executable and distributed to the users. 
Any idea about your interest in including something like SVG support? Also; do you own an Android phone? -- I'm *dying* to get a Python/SDL/Numpy loader on Android... There is http://pygame.renpy.org/ for Android but development is uber slow, lots of stuff missing, the author doesn't address issues that people are having, and much more...but it's the closest thing I have right now.
It also provides competition; which there currently isn't any. Without competition, frameworks and libraries stagnate much like PyGame has. If this guy can code up something he enjoys doing, then hell I'm all for it!
An active ecosystem need eyeballs and interest, which isn't exactly the same as competition. Also, I'm not opposed to competition, I just thing it's a pretty weak argument for not contributing to existing libraries.
I'd be happy to hear further thoughts on what in your mind might satisfy these requirements. I have my own ideas of pythonic and certainly want to strive to make it so but I'm sure there are great ideas out there.
Sometimes it's easier to start your own codebase than to jump into an existing one. OP also states: "Also it seems that neither library is all that actively developed" -- so obviously competition isn't his *only* factor in this as you suggest. My guess is that you'd like every python web framework creator to have just jumped into django development instead of creating the plethora of micro-frameworks we have now? I much prefer the differentiation and selection I have because they didn't. And this guy certainly has my eyeballs and interest...
I hadn't considered SVG support, it is a complicated spec but I'll look into what exists that I might be able to lean on. I do own an Android phone, I have a feeling that for now any attempt to get Python on Android is doomed to be slow, but I could be completely wrong. I'd be happy to help support a port but I certainly don't have the expertise on my own.
I'd certainly be willing to take patches to a hypothetical library, but I'm not a windows guy myself.
In theory, I'd agree. If there was a great library that people were universally happy with there'd be little point in duplicating it. A 'perfect' json library is perhaps possible, but game development isn't so cookie cutter. There are a lot of approaches (like in web development some projects may favor a larger framework that does more of the work but some may lend themselves to something simpler). That said, I'd be willing to contribute to an existing solution if it seemed like there were any truly active projects. That's part of my initial question, if I'd misjudged the status of pyglet/pygame.
Check out PyGame subset for android; it's amazingly unhindered. I've done a 100-sprite starfield at 24fps with no hiccups at all on my aging 550mhz Droid 1... Here's the SDL port for Android: http://www.anddev.org/sdl_port_for_android_sdk-ndk_16-t9218.html And here's my starfield example that runs on PGS4A: http://pygame.renpy.org/forum/viewtopic.php?f=6&amp;t=26&amp;p=79 Just saying maybe keep it in mind when you start building your new library :)
A simple function will often suffice: def search(n, lists): for li in lists: for val in li: if val == n: return True found = search(42, lists) 
I tried PyCharm a few days ago. I use Linux and my biggest problem is that the fonts in PyCharm look awful. I tried all monospaced fonts but I didn't like any of them. So I ran back to PyDev... I've read so many good things about PyCharm and I'd really love to try it but it kills my eyes.
you are defining matrix operations that numpy has standard, might want to hip yourself to numpy
An interesting approach, which I didn't explore in Pyro.
It's just a feeling I have, but it seems to me that people who started out with Zope when it was simpler and have kept up, can use it very well. It's too daunting for new people. And I'm afraid that a similar thing is happening with Django, as it grows larger. Perhaps in five years people will say that there's just so much to learn in Django, better look for something simpler -- etc. Or not.
TIL
[Fixed it](https://github.com/stchris/untangle/issues/2) and added a test case. Thanks for reporting this!
Good to know it's not easy. I had a 6 month IT job where my bosses plan was to teach me (and two others hired at the same time) python then zope &amp; plone then how to build products for the centers website, and then we'd be really useful. (Also we had no real linux experience between us and the entire place was ubuntu based.) As a system it didn't really work (Still haven't a clue what buildout was all about, and never quite got my head around the zope instances, .namespace stuff and how the hell it all fitted together). I'm pretty good at python now though....
Same here. I was interested in using Plone. Felt way too much like MS Sharepoint to me.
I use Valcato. No complaints.
if you're getting an interpreter crash, it's because you've tripped a bug in CPython, or a bug in the extension. It's pretty safe to assume it's the extension. There isn't an effective way to debug this from Python code; if the extension is causing a segfault, you're not going to get a traceback and interpreted code won't be able to deal with whatever is going on. You might be able to figure out what's going on with a debugger, and that might lead you to the bug in the source... but really that's going to be a lot of effort. Try a different version of the extension, a different extension, or a different database (or some combination of the three).
I mean I am completely off on a tangent. Hadn't had coffee yet and haven't set Zope up for about 3 years, since like many others in this thread I no longer use it by choice. For some reason I had it in my head that Zope set up its own python instead of remembering that I always did that manually and then pointed Zope at the isolated python instance I set up just for its use. 
thanks. I was pretty sure I wasn't going to be able to do anything about it, but its nice to have confirmation. I'm using pyodbc now and it seems to be working fine, so I guess my problem is solved.
Still working my way through this, but it seems a decent, practical intro to ML, starting with the basic theory, followed by hands-on python code examples. There are discount codes available that should allow you to get this for $18. 
People are saying that about Django *right now*. Remember microframeworks? Django hasn't increased the basic level of knowledge required despite all the additions. The additions are just extra stuff you can use if you find them useful. Templates, URLs and models work exactly as simply as they used to work, indeed in the exact same way. Django *apps* are growing a little more complex than they used to be, and this is largely a good thing. Class based apps (e.g. `django.contrib.admin`) are awesome for customization, but customization you only need to do if you need to. The apps will continue to supply a basic configuration with a urls module to import, that's just boilerplate for an instance of the application class. Class based views are also more complicated and indirect than the old function style, but the old function style is still the simplest way to do simple things and is fully supported. One only needs to deal with class based views when customizing things thoroughly. Class based views are something I expect to remain a somewhat arcane art due to abundant Python multiple inheritance.
Thanks for that. IronPython built-ins are working for me now.
Thank you for the tip! I will check out cloudpickle.py for the client side. I also found some slides from PiCloud which may prove helpful for the server side.
That's completely fine as Pyro is more general purpose. What I've got in mind is a bit more restricted, let's call it "transactional". This is why I thought of the approach since the start.
Zope is not the best introduction to Python. Python has a gentle learning curve. Zope is very steep. I came to Python through Zope. I eventually migrated to Plone.
http://bluebream.zope.org/doc/1.0/introduction.html &gt; BlueBream registers components with Zope Component Markup Language (ZCML), an XML based configuration language, providing limitless flexibility.
for the making of the dictionary, you could do something like: dict(zip(names, ages)) 
Pretty good! I'll have to say the two clunkiest parts were getting this to work correctly on a Windows Command Line and getting OAuth to behave correctly.
Really? I implemented Plone 3 on a project in 2007. I loved it. When I had questions, I got great feedback (Alexander Limi was doing support and was awesome!). I was WAY more of a Web designer at that point too. We launched in 7 months - there was really limited documentation. I kind of feel like if I could figure it out anyone could. 
I love Plone. I did not have a strong programming background when I first worked with it but I managed to do some really cool stuff with it (like integrating interact reports, etc.). EDIT: Ubuntu? I had Red Hat. I've never used Ubuntu for anything but home and I use Mint for home now. 
macports installs everything in a cordoned off directory "/opt/local". In order to be able to type "python" and get 2.7 you will need to add "/opt/local/bin" to your path, and if that doesn't work try "/opt/local/Library/Frameworks/Python.framework/Versions/2.7/bin/". (Note that you will need to add these *before* your current path and not after, or else your old version of python in /usr/bin will shadow the newer versions.) I don't know how to get a GUI installer to look for Python there off the top of my head, though. You may have better luck downloading a binary for Python 2.7 directly from http://www.python.org/download/, which will install it to a standard location where GUI installers are much more likely to find it.
Sweet! I had not tried this on anything outside of Ubuntu and Gnome-Terminal (I didn't even know if the windows command line supports Unicode characters and bold text, etc..), but if you got it to work, that's great. :) What was the clunkiness regarding OAuth? Was it just getting all those data fields filled in? Do you have any additional feedback about this? Thanks!
Anyone familiar with this?
Thanks for the reply. The opt/local/bin was already part of my path but still didn't work. For future users, I ended up trying $sudo port select python python27 and now the default python is version 2.7 
How do I go about deleting a site that I added?
does anyone use myHDL for serious work? I work in an FPGA lab and we use Python for FPGA verification in the lab. I'd like to be able to use the same stuff in simulation.
That's been changed. Latest versions use Python 2.6.
I'm definitely interested, especially the 3.x support
To anyone else who encounters this problem: Macports has all these libraries (matplotlib not matlablib) for different python versions. I thought the "easy install" would be the best option but using macports works better. Here's what I did (xx is the version you want, eg for 2.7 xx=27: $sudo port install pythonxx $sudo port select python python27 $sudo port install py27-matplotlib $sudo port install py27-scipy $sudo port install py27-numpy Don't forget to selfupdate if you haven't in a while. Thanks grcross!
Could you give me a link to that?
Yes, the clunkiness on OAuth was the lack of instruction for someone unfamiliar with which keys you needed and what the format of the file was. Even an inclusion in your readme like: 1. Open https://code.google.com/apis/console 2. create a new project 3. create an API Key for an "Installed Project" 4. Copy the Client ID, Client secret, API key onto 3 seperate lines in a new file called "keys.txt" Or a "keys.example.txt" with sample data and a few extra lines describing what to copy would be great. Also, Windows did NOT support the unicode characters so I just found replacement characters to use. And Bold/Strikethrough didn't work so I just changed them to "bold = lambda x : x"; I could have made this specific to win systems, but I just wanted to get it up and running. Also, you have a call to your "bold" lambda inside "Search", which is broken, because you've actually got "bold" scoped to "PrintAllTasks"
http://code.google.com/p/pyglet/source/browse/PY3K
Possible problems: $sudo port install python27 ---&gt; Computing dependencies for python27 ---&gt; Dependencies to be installed: db46 gdbm openssl python_select readline sqlite3 ---&gt; Configuring db46 Error: db46 requires the Java for Mac OS X development headers. Error: Download the Java Developer Package from: &lt;https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/wa/getSoftware?bundleID=20719&gt; Error: Target org.macports.configure returned: missing Java headers Error: Failed to install db46 Log for db46 is at: /opt/local/var/macports/logs/_opt_local_var_macports_sources_rsync.macports.org_release_ports_databases_db46/main.log Error: The following dependencies were not installed: db46 gdbm openssl python_select readline sqlite3 Error: Status 1 encountered during processing. To report a bug, see &lt;http://guide.macports.org/#project.tickets&gt; Installing the Java Developer Package requires an Apple ID.
Any scoop on where I can find the discount code?
Buildout is a slightly higher level way of managing a set of Python packages (eggs) that make up your development/deployment environment. Since sometimes you may not be able to install eggs on the system level, buildout provides a nice way that will create an environment that includes all those eggs on a standalone project directory basis. It is basically an ini-like file that lets you specify which eggs to include, with the option to lock down to some specific version (the known good version) such that everything would work together. There are different sections, with each of them calling a specific recipe that can apply further installation steps, such as setting up various configuration files and various parts. Instances are basically "server daemons". In a typical low-traffic setup there would be a single zope instance and a zeo instance. Zeo is the object database server, where all the persistent data is stored. The zope instance connects to it, and then in turn listens on some ip:port which other clients (web browsers) connect to acquire/access the data inside. The namespaces you are referring to, I am guessing it has to do with the zcml, or the XML configuration files for various products (i.e. XML namespaces). Yes, I found it strange at first, but it is not that bad, however enterprise it is. I am not sure what your issue with it is, but if you pin down something specific I may be able to explain it. As grandparent had said, it has a very steep learning curve. It did take me about three months to become accustom to how everything fits together, and another three before I fully grok the system to the point where I can start adding new bits. However, as a system, this works very well. A properly defined buildout ensures a very consistent environment is created every time it is executed, such that a new developer could come in, execute four commands (git clone/svn co $project; cd $project; python2.6 bootstrap.py; bin/buildout) and have the same environment as everyone else who follow this step and they can pretty much start developing. I can also tell you in the last five years I've spent doing Zope/Plone development, things have improved tremendously. It should take considerably less effort to start building Zope/Plone web applications than before.
Just had this issue recently! Also, if you want to do interactive plotting with IPython, make sure to set your backend as "macosx". So much tasty plotting.
I tried messing with rpy2 sometime back. Fuck it. I'm just going to learn R the hard way. So far I've done data organization in Python and stored the dat files and just ran my stats in R. I would like to help, but wouldn't know where to start(I'm a biologist).
If you open source the thing I'll take a look at what you have and make suggestions. I can't think of any super generic stuff to say at the moment.
this is true
i want to learn gui programming (w/ pyqt). will you open source your app ?
I don't know if at this point you would consider your problem resolved, but I thought I would chime in as I've had a similar issue. Download and install [enthought](http://www.enthought.com/). There are free academic licenses and installing it is easy. However once I actually got the hang of matplotlib, pylab, etc. I realized that it probably would have been more efficient to use R or Octave like most other people. Although python isn't terrible for scientific computing, R and Octave are built around scientific computing and make the routine things routine and save you tons of repetitive code. 
now Drizzle too...purty please?
Thanks for your input I'll definitely look into Octave. I've actually never used python before, the only reason I'm getting it now is because there are some existing scripts written in it and I'm going to be working with them. It sounds like Octave could save everyone some time so I'll be sure to investigate.
The enthought distro would probably your softest landing - it'll have everything you may want built-in.
You could download the Reddit open source at the bottom of the page and look through that code. It's broken up decently and I imagine you could find what you're looking for there. 
in web2py (complete code) def index(): form = SQLFORM.factory(Field('a','integer'),Field('b','integer')) if form.accepts(request): form = DIV('a+b=',form.vars.a+form.vars.b) return dict(form=form) The name 'index' means the function is called when you visit http://127.0.0.1:8000/&lt;yourapp&gt;/default/index, form is just a variable name that can contain a form (SQLFORM) or DIV (html div) or anything else you want to display. The Field objects performs validation, displays error messages if you do not type an integer (will also use JS client-side to prevent you from not typing an integer) and parse the request into form.vars for you. It is 100% python code and you can use any library you want.
Generally, when people are using python for the backend, they are using a framework. [Django](https://www.djangoproject.com/) is a very popular python framework, and so is [Pyramid](http://docs.pylonsproject.org/docs/pyramid.html). Try playing around with one or two of these, maybe walking through one of the tutorials on their sites.
Unfortunately the decision is not up to me. There might be the chance to open source the prototype app at a later stage. For learning PyQt I can recommend these resources (besides the official Qt and PyQt/PySide docs): * PyQt Wiki: http://diotavelli.net/PyQtWiki/StartPage * PyQt4 and much more nice tutorials: http://zetcode.com/ * Very good, lots of good examples: http://www.qtrac.eu/pyqtbook.html * Quite old, but still useful and free: http://www.commandprompt.com/community/pyqt/ Eric IDE is an Python IDE written in PyQt. It's open source, so you might want to look into this: http://eric-ide.python-projects.org/
Short answer: * install python 2.7 from python.org * make sure that when you do python -c "import sys; print sys.version", you get 2.7. * THEN, install numpy, scipy and matplotlib. Longer answer: The main issue on mac os x is that there are several python interepreters by default, and you need to make sure to use the same for everything for various reasons you don't want to know. In numpy, scipy and matplotlib communities, we agreed on not using the default python, and we build all our binaries on top of the python found on python.org. Enthought distribution is another solution.
Python is an excellent choice for scientific programming. Octave is just a Matlab clone, with its attendant shortcomings. Python is a general purpose programming language that gives you lots of room to grow. R is a different beast than Octave or the SciPy stack. It's really best suited for statistical analysis.
I am curious: besides installation issues (which I agree are still a pain), what would you consider more routine in numpy/scipy than octave or R ? R definitely has some advantages (a package management that is actually working, and a lot of quite advanced stats stuff), but less repetitiveness is not one that pops in my mind.
Thanks for the information. Looks indeed very interesting, however, most of the parts where Dabo seems to shine are already done, like the business layer (similiar, but not as comprehensive, with lazy/eager loading and validation) and the gui with autoupdating all the views. I wonder wether Dabo uses direct connection to the database?
You can also look at [Flask](http://flask.pocoo.org). It's a small, lightweight framework that you can use to get a feeling for the flow of what a web app has to do.
You are just starting to think about web programming with Python. Frameworks are a great way to learn how to do some basic web programming. I recommend [Flask](http://flask.pocoo.org/).
Definitely use at least a basic framework such as CherryPy, Paste, Bottle, or Pyramid. The wiki has a list of frameworks: [Web Frameworks for Python](http://wiki.python.org/moin/WebFrameworks). Here's a demo using the low-level Python libraries that should be close to your requirement "to begin with" (though I'm sure the professional web developers here can pick this to pieces, it works for me on win32 Python 3.2 &amp; 2.7): import cgi from wsgiref.simple_server import make_server def app(environ, start_response): output = [make_form(), process_post(environ)] size = sum(len(x) for x in output) headers = [('Content-Type', 'text/html; charset=utf-8'), ('Content-Length', str(size))] start_response('200 OK', headers) return output def process_post(environ): #ignore the query string post_environ = environ.copy() post_environ['QUERY_STRING'] = '' post = cgi.FieldStorage( fp=environ['wsgi.input'], environ=post_environ, keep_blank_values=True) result = "" if 'num1' in post and 'num2' in post: try: num1 = float(post.getfirst('num1')) num2 = float(post.getfirst('num2')) result = "&lt;p&gt;{:.2f} + {:.2f} = {:.2f}&lt;/p&gt;".format( num1, num2, num1 + num2) except ValueError: pass return result.encode('utf-8') def make_form(): form = ( '&lt;p&gt;&lt;form method="post"&gt;\n' ' num1: &lt;input type="text" name="num1" /&gt;&lt;br /&gt;\n' ' num2: &lt;input type="text" name="num2" /&gt;\n' ' &lt;input type="submit" value="Add" /&gt;\n' '&lt;/form&gt;&lt;/p&gt;\n') return form.encode('utf-8') if __name__ == '__main__': host = 'localhost' port = 8080 server = make_server(host, port, app) server.serve_forever() 
That's the way to do it.
Nope, sorry.
It was said to be open source and free, but you need to get yourself a free account. I wonder if one can even work without being online. After I saw it needs an account, I uninstalled it. It didn't stay installed for more than 10 minutes. I don't like my IDEs and development tools to "phone home".
I don't see how you can avoid learning R if you want to use rpy2...
Correct-o, the whole point is to use R anyways.
It's not clear what you're asking for but maybe: - PythonOCC (for 3D CAD modelling) or CGAL (http://cgal-python.gforge.inria.fr/)
Nearly all of my 8GB :O I will see if lists of lists work better, thanks.
Another option is Google App Engine. 
Is it just me, or does this mix of concerns give anyone else shivers? This style looks like a nice gateway drug but also painful to maintain for larger apps...
Nice drug metaphor. I found web2py to be inelegant.
That's the way to start doing it. rpy2 is great if you want to use R functions on existing python data structures. personally, I find data management in R unfamiliar and time-consuming. I'm only good with R when I have simple vectors and matrices. Sure, I could generate these in python, dump them into dat files, call an R script, and read the output, and continue my python work... but I'd rather just do it all at once from within python using rpy2. on windows though... ugh. good luck. maybe pythonxy or enthought includes it in their installation packages?? 
I agree with FriendComputer about not making this a dictionary. The lookup time will be a bit lower, and the memory requirements will be greater since you'll need to associate coordinates with every tile (and you'll probably want each tile to store its own coordinates as well, which means you'll have the coordinates stored in two places). It will be a little better if you say: world.tiles = [] for x in range(world.tileCountX): world.tiles.append ([]) for y in range(world.tileCountY): world.tiles[x].append(Tile()) You can also make each tile instance a bit smaller if you use \_\_slots\_\_. You'd need to do something like: class Tile (object): __slots__ = ["position", "units_list"] I don't know what variables you need in your Tile class, but you'd put the names of each of those variables in that slots list. That will tell Python that you're not going to define any other variables for any Tile instance, so Python won't need to give each tile it's own dictionary for variables. However, I think you need to ask yourself if you really need so many tiles. If your map is going to be mostly the same thing, or if the map will mostly consist of computer-generated tiles, you can use a [sparse array](http://en.wikipedia.org/wiki/Sparse_array) approach. Basically, you'd have a dictionary of tiles, but you'd only define the unusual tiles. Then, when accessing the dictionary, you'd use world.tiles.get((x,y), Tile (coords = (x,y), default = True) This will try to get world tiles at the provided coordinates, and, if you don't have anything special there, it would get the default that is automatically generated. For example, suppose you want the top right corner to be mostly trees, you want the whole bottom to be mostly grass, and you want the top left corner to be mostly water. You'd make a function, like so: def get_default (coords): x, y = coords right = x &gt; world.tileCountX top = y &gt; world.tileCountY if top and right: return TREES if top and not right: return WATER if not top: return GRASS Then, in your tile class, you'd have some optional variables to define a tile, and a default option. If default == True, you'd use get_default (coords) and use that to make the tile. Then, you don't need to keep the tile in memory, you can just generate it whenever it's needed. If you want to add some special stuff, for example, a path through the forest, or a village in the grasslands, you'd define those tiles, as necessary, but anything undefined could be determined through the defaults. Take a look at the wiki article on [procedural generation](http://en.wikipedia.org/wiki/Procedural_generation) to get an idea of how good you can make your defaults. I should point out that there is one caveat with this approach. When a unit moves to a tile that has not been defined, you'll want to define that tile so that your unit can be found on it. Similarly, when your unit leaves that tile, you'll want to delete it, but only if it was a default tile. You could define the \_\_eq\_\_ method for your Tile class, to determine if two tiles are the same. When a unit leaves a tile, make the default tile for that position. If the default is the same as defined tile, then you delete it.
You could probably simplify it a little by using os.path.walk, as that is pretty much intended for doing what you've done here.
I use the cgi module for simple web forms, though it is not fit for creating more complex applications. Example form to add two numbers: #!/usr/bin/python import cgi import cgitb print "Content-Type: text/html" print cgitb.enable() form = cgi.FieldStorage() if "x" in form and "y" in form: x, y = int(form["x"].value), int(form["y"].value) else: x, y = '', '' print '''&lt;html&gt;&lt;body&gt; &lt;form method="POST" action= ""&gt; &lt;input type="text" name="x" value="%s"/&gt;&amp;nbsp;+&amp;nbsp;&lt;input type="text" name="y" value="%s"/&gt;&lt;input type="submit" value="=" /&gt;%s &lt;/form&gt; ''' % (x, y, (x+y))
No! You shouldn't be using template systems until you've output a static "hello world!" string and you shouldn't be using a bloody ORM if you don't already understand relational databases. Frameworks are meant to save you time, not knowledge. They should be where you end up, not where you start.
This is some awesome info! A lot of stuff I hadn't thought of. I particularly like the use of the list of lists as well as slots which is new to me. The procedural generation stuff is interesting, however the way everything is being used the world is generated before hand and then loaded, so there isn't really any "on the fly" tile generation. Another option that I have been churning over in my head is saving this data to a database and only selecting the data when needed (e.g. select * from tiles where x = ? and y = ?). Do you think that's overkill for this?
When I try to import any of the modules in says there is no module named numpy. Do you know how to fix this?
I installed 2.7.1 then made it my default and installed scipy, numpy, and matplotlib. When I try to import numpy it says ImportError: No module named numpy 
For this kind of detail, you might take a look at how the RPG Maker VX engine handles (sometimes pretty large and complicated) maps, in it's builtin Ruby scripting code: http://en.wikipedia.org/wiki/RPG_Maker_VX Well, to summarize: - Maps have some static layers (2 I think), and an "event layer" - The static layers are basically just a list of numbers (or even - a low level C-like array structure, rather than a standard high-level list type), for possible tile types - they're not objects. Also, the number varies depending on appearance of each tile (ie: so edges of forest don't look horribly blocky, the edge tiles would have different numbers). - Bottom layer is basically underlying scenery - water, grass, etc - Top layer is stuff on top of that - trees, walls, parts of tiles, etc - The static layers tile numbers, are also used to look up the corresponding tiles in a set of tile map images (large images with all possible scenery widgets). Also, the tile numbers affect stuff like whether the player can or can't pass through that block, based on what type of vehicle they're travelling in (mountains, oceans, etc tiles). But I think you can also set "passability" separately too, if needed. I think that's an extra invisible layer. - Event layer is a list of actual objects, with their own coordinates, event handling, etc, on top of the other tiles. They're pretty sparse (maybe a few dozen on a given map). Basically they're all the NPCs, hotspots, etc. - The "static layers" are rendered in a compiled (C I think) module for speed/efficiency, including animations (eg: sea tiles, or rivers and such). - The C engine also handles drawing of the sprites (but your Ruby scripting code determines the exact positions, images, etc), rather than you blitting them yourself. - Just about everything else on the map (npcs, UI widgets, menus, etc) is handled by the Ruby code, which calls builtin (C) libraries for drawing (into a type of surface/image), but the C still handles the actual drawing. The C code also takes care of stuff like automatically skinning windows, handling effects (shrinking/growing, transparency, etc) with a special tile map image, rather than Ruby handling it. Well, that is a pretty extreme/optimized setup, while still allowing a high-level scripting language to manage most of the details. 
This is the direction I went with my site. It is dead simple and dead simple to implement. No installation required. 
I'm personally not too big a fan of frameworks in general, unless they're needed or give a big enough benefit for your app (I more prefer lighter-weight libraries). So, for this really simple kind of app for testing/learning purposes, I'd likely just use Python's-builtin CGI support: http://docs.python.org/library/cgi.html And then leave the other stuff for when you've learned more about the nuts and bolts of Python web programming, and want to focus on making the essential glue code for your app in an elegant and higher-level way (and more maintainable/readable), rather than spending time on boilerplate/handling lower-level web programming details. 
This is strange. What does "which python" says in the terminal ?
If you opt to go for a database, the [gdbm](http://docs.python.org/library/gdbm.html) module acts like a dictionary with a database. I'm not sure if this would actually use less RAM or in fact be very fast as it's writing/reading to disk which is slower than RAM. If you use gdbm.open() with the [mode](http://docs.python.org/library/gdbm.html#gdbm.open) 'cs' then alll changes are immediately written
Python 2.7.1 (r271:86882M, Nov 30 2010, 10:35:34) [GCC 4.2.1 (Apple Inc. build 5664)] on darwin 
It would depend on how quickly you need to load those tiles. If you have a player moving across the map, and the player can only see a tiny portion of the map at any time, then keeping the unseen parts on the hard drive is a good idea. However, if you need to be ready to show any point of the map at any time, then putting that data on the hard drive will probably cause a noticeable delay when you want to load an area of the map to look at. I'd go with some simpler techniques first, and, if that still doesn't solve your problem, then I'd use a database.
Your code is already in good Python style. Nice job. I have to really stretch to find anything to critique... I would spell "lstree" as "ls_tree" to be a bit more readable.
They're simple changes to make, so feel free to try it, but I don't think there'll be a big improvement in going from dict to list and I doubt the difference using slots will be noticeable. If a fair number of tiles are non unique, it will reduce memory to cache your tiles. Actually they are already cached, you just need to check if you have one already before creating a new one. Or maybe all tiles are unique, but some of its attributes which occupy most of the memory can be cached. How many tiles are we talking about? Any idea of the memory per tile?
That just gives you a place to run your app.
Client/server sockets and related programming stuff is too _low_-level, not too high-level.
The django docs are a better reply than "go and get 5 years experience", ;)
I agree with this advice. Start with a CGI script running on a standard (e.g. Apache) web server. As soon as you start to generate HTML pages that involve more than a few lines of code, add a templating engine (e.g. Mako), so that you can separate the HTML code (presentation) into a separate file from the python application code (logic). That's a good practice that will serve you well later, as your applications start to grow.
An exception works just as well: class Found(BaseException): pass try: for li in lists: for val in li: if val == 42: raise Found except Found: "found it" else: "didn't" 
Seems you already sorted it out. But if anyone else is interested: Download the source of python, compile and install in your home directory somewhere (or /local or whatever) Install virtualenv (tutorial at http://simononsoftware.com/virtualenv-tutorial/ ) Make sure you do follow this: http://stackoverflow.com/questions/1534210/use-different-python-version-with-virtualenv/1674444#1674444 http://stackoverflow.com/questions/2278028/how-do-i-work-around-this-problem-creating-a-virtualenv-environment-with-a-custom 
8400x2400 is ~20 million tiles. That means ~80MB will be used just for a list containing pointers to these objects. A dictionary would be even larger, since it must contain each coordinate tuple as keys, and has the overhead of each empty space - it's probably 10 times that. (Though you could save some of that by using a defaultdict, and only storing non-empty squares) However, the bulk of your memory will the actual Tile() objects themselves. Each object will have its own dict, and so even a fairly small object is going to be a few hundred bytes. Even 200 bytes is going to come to 4 gigabytes here, which will obviously be problematic. You can shrink this somewhat by using `__slots__` or other optimisations, but probably not be enough to be reasonable. Even 32 bytes per object is ~615MB - not unmanagable, but still a big chunk of ram. However, generally the point of tile systems is that you have relatively few distinct tiles, with the same (basicly static) tile in multiple places. As such, what you probably want is to merely pass a *reference* to a particular tile at each slot, rather than creating a new one. Here, instead of using `world.tiles[(x, y)] = Tile()`, use something like: space = Tile(...) wall = Tile(...) # ... other tile types. world.tiles = [[space for y in range(world.height)] for x in range(world.width)] ... world.tiles[x][y] = wall # Set different values for particular tiles. Doing that gets rid of the object overhead, leaving just a relatively small number of tiles and the overhead of the map. It requires that you have no dynamic properties in the tiles themselves - any difference in state must be represented by a different tile. If you have a few corner cases where such dynamic properties are needed, they may be better off handled seperately from the tile layer. For the overhead of the map, you could use a more compact format than a reference to each object. This uses 4 bytes (for a pointer) for each tile. However, if we have under 256 unique tiles, you really only need a byte. It might be woth taking a look at things like [numpy](http://numpy.scipy.org/) arrays for this purpose. ie. world.tiles = numpy.zeroes((world.width, world.height), numpy.uint8) # Create map of values between 0.255, initialised to zeros. This will take only ~20MB for your map. If you have more than 256 tiles, using numpy.uint16 gives up to 65536 at the cost of twice the memory usage. To get the same functionality of getting Tile objects back, you can wrap this array with something that automatically translates the number into the appropriate tile object. Eg.: tilelist = [space, wall, ....] # List of all tiles, ordered by numeric Id (could also use a dict instead) class Tiles(object): def __init__(self, width, height): self._tiles = numpy.zeroes((width, height)) def __getitem__(self, coord): return tilelist[ self._tiles[coord] ] world.tiles = Tiles(2400,8000) Then: world.tiles[123,456] Will give you the appropriate tile object for that coordinate.
Interested as well.
def lsTree(target): stack = [target] while stack: current = stack.pop(0) for name in os.listdir(current): path = os.path.join(current, name) if os.path.isdir(path): stack.append(path) print path Also, you should here an there add a check whether the path is an directory and if it's accesable, and such.
This is because Python 2.x would keep breaking backwards compatiblity in subtle ways that only came out if you had a large codebase, especially if you used the C APIs. So it would take us a while to fix compatibility issues sometimes. 
&gt; **it is not fit for creating more complex applications.** Emphasized, as I had to refactor my share of complex applications using this exact style. It was not a pleasant experience.
As far as I understand, jinja2 is a reimplementation (with changes) of Django templates. Part of the reason for its creation is that Django templates cannot be easily used standalone outside of Django, without pulling in the rest of Django. 
Did you try importing the module in the interactive shell?
And a tutorial that gives you a little web form where you can leave comments which are stored in the datastore. Not a bad thing.
You have a typo in the 2nd line (target), and the continue statement is superfluous (it won't execute the outer `else`; it has nothing to do but continue the loop). Also the order of the traversal is backwards (IMO). Otherwise I don't see anything wrong with your style. It's simulating an actual recursive walk, and that's great. I think a lot of people would just do something like Spiceboy wrote or use os.walk. I'll just slightly modify your code and make it a generator: def lstree(target_dir): stack = [[target_dir, os.listdir(target_dir)[::-1]]] while stack: dir, files = stack[-1] while files: path = os.path.join(dir, files.pop()) yield path if os.path.isdir(path): stack.append([path, os.listdir(path)[::-1]]) break else: stack.pop() #e.g. dir_list = lstree("/temp") first = next(dir_list) for node in dir_list: print(node) 
For me : - Simple projects : SciTE is perfect (you can configure a lot of things thru config files) - bigger projects : Komodo Edit (easy to configure thru gui (or python macros)) Both are available on gnu/linux ... so you can keep/share yours configs
Yeah, webapp is a nice framework.
Go with bottle, it's dead simple and you completely understand what's going on. 
Go with [bottle](http://bottle.paws.de). If you're just beginning. Then move onto something a little more elegant. 
I've been using UltraEdit for years, it is a truely awesome text editor. Only recently I switched to PyCharm for Python development on Windows. It is the first Python IDE that 'clicks' for me (tried KomodoEdit, Eclipse+PyDev, Netbeans), and I have good past experience with stuff from JetBrains. It is free too, for classroom and open source projects. Other than that, I've mostly used python from the command line, and occasionally used ipython which is free and makes the console experience a lot nicer. I haven't really used virtualenvs so far but I think PyCharm supports them if you select the python interpreter from the bin dir in the virtualenv location.
Consider IDLE. It has syntax highlighting, popup introspection, call tips, parentheses matching, and debugging. The interface is simple and won't overwhelm someone who hasn't programmed before. And it installs with Python. 
The learning curve issue is so well known it's described as a "Z shaped learning curve". Modern ZTK-based frameworks are easier to learn, but still not easy to learn, with the possible exception of Pyramid. Buildout is simply a tool to help you specify what dependencies and installation requirements your project has. You can then give someone else a buildout and tell them to run it, and they will get the same project. I believe that the Zope (2) and Plone buildout has become simpler over time; it had to jump through some hoops in the past as it was distributed in a non-standard way. 
You can use Zope without practically any XML since '06: just use Grok. 
Upvote for PyCharm. It's the first python IDE I've used that feels like it's not in my way, but at the same time gives me an excellent debugging experience and a ton of other features.
Your guesses are correct. We've stopped caring so much about sandboxing for most Zope-related projects; it's not really relevant to Grok, for instance. 
I started with Zope when it was new, but transitioning from the "through the web in-the-object database" development model to "Just python code on the filesystem" development model was hard then too. I remember struggling with it, and I came to Zope as a Python developer. Zope's predecessor Bobo *was* truly simple, however. I think the primary reason it was hard is because Zope wasn't really designed for filesystem development - it had a decidedly grown API which made many concessions to supporting the Zope through the web user interface. In addition Zope introduced many concepts new to the developer, such as an object database, aquisition, and so on. The ZTK is designed with APIs in mind, so doesn't suffer from the same issues. There are other issues though that make it hard to learn, to do with components and configuration - those are also concepts you need to become familiar with. The problem with someone trying to learn "Zope" today is to decide which Zope: the traditional Zope application server extended with the ZTK (that *is* a lot to absorb), or a purer ZTK based system (Grok or BlueBream then?), or a "reimagined" Zope core, Pyramid? My recommendations would be to either start with Grok or with Pyramid. 
I use [mako](http://www.makotemplates.org/) whenever i have to generate a lot of text (HTML, LaTeX etc.). I find that mako is alot simpler than its brothers. The web framework thread pops up once a month in this subreddit. People have alot of different preferences. Though, my personal experience is as follows: If you want to create a: * blog/article-heavy site, try [Django](https://www.djangoproject.com/). * web-application and you are starting from scratch, try the [Pyramid project](http://pylonsproject.org/) * really customizable project that is guaranteed not to get in your way, try [werkzeug](http://werkzeug.pocoo.org/). it's not a framework, but an utility library. So you have to read the documentation in order to make it run.
Err, I don't think your output will be the same as his. He's displaying the contents of the subdirectories as he finds them and you're displaying the contents of the subdirectories at the end.
If only I could use that guy as a logo for Pyro...
Try storing tiles on disk and dynamically pulling them into memory when required. I did this in pySlip (code.google.com/p/pyslip), which is a wxpython widget that uses *lots* of tiles in the more detailed levels (about 1.6GB for 10 levels). It's plenty fast enough. Feel free to reuse some of that code.
The *continue* is necessary.
I don't see your point. The handling is the same. The only difference is the alphabetical output per directory.
I wouldn't call it nice. Simple? yeah. Well Documented? OK. It doesn't do much more than [route a webob request to a callable](http://pythonpaste.org/webob/do-it-yourself.html). What makes appengine attractive is other services like the datastore primarily and others. All of which can be used with any python web framework that supports wsgi. 
Have you tried PyScripter ? - free - open source - syntax higlighting - completion - integrated python interpreter - full-featured debugger http://code.google.com/p/pyscripter/
I must say your code is quite confusing (as you can see in Eryksun here failing to understand what exactly you do). So first thing would be to add a comment along the lines of: dir, files = stack[-1] # do not pop it just yet, instead we are going to pop one file # from `files`, and only if that's empty then this record from the stack. Because you see, you do not one, but two "clever" things here: you peek at the top of the stack instead of popping, and you modify the contents of `files` inplace, through another reference. Both things are relatively unusual for Python code. Problem is, anyone including yourself a couple of weeks later will miss these nuances when they glance over your code quickly, and introduce a bug at worst, or at least spend a couple of minutes being confused about how it could possibly work and why the fuck it does all these strange things. ["The only valid measurement of code quality"](http://www.osnews.com/story/19266/WTFs_m). So while sometimes writing "clever" code is inevitable, all such deviations from the usual boring stuff MUST be explicitly pointed out and explained. Always write code as if the next person who is going to read it would be an axe murderer who knows where you live. And he is hangover at the moment. Then, well, I don't know, do you really need this exact traversal order? If not, then you can do "`dir, files = stack.pop()`", then remove the `continue` and the `else` clause. Or if you do want it exactly like that, you can also add and use this inner function: def push(dir, files): for file in files: stack.push(os_path.join(dir, file)) Oh, and by the way, I personally prefer `from os import path as os_path`, and I'm not alone in that, because working with `os.path` directly is somewhat quirky, it automagically imports `os` etc. 
&gt;The web framework pops up once a month in this subreddit. ?? more like weekly. :)
What happens differently if you remove it? Here: result_with = [] def lstree_with(target_dir): stack = [(target_dir, os.listdir(target_dir))] while stack: dir, files = stack[-1] if files: file = files.pop() path = os.path.join(dir, file) result_with.append(path) if os.path.isdir(path): stack.append((path, os.listdir(path))) continue else: stack.pop() result_without=[] def lstree_without(target_dir): stack = [(target_dir, os.listdir(target_dir))] while stack: dir, files = stack[-1] if files: file = files.pop() path = os.path.join(dir, file) result_without.append(path) if os.path.isdir(path): stack.append((path, os.listdir(path))) #continue else: stack.pop() target = "path with lots of files and nested folders" lstree_with(target) lstree_without(target) print(result_with == result_without) Output: True
It's depth first, not breadth first.
&gt; Something as easy as a virtualenv/easy_install becomes very complicated for me in non-console-land. Windows does have a console, you know... And it can even be made nice enough with [Console2](http://sourceforge.net/projects/console/). So get yourself comfortable with these, learn which environment variables you have to set and how (the correct way is through my computer-&gt;properties-&gt;advanced), then teach your dudes how to do that. I mean, there's no sane alternatives to typing "`easy_install pip`" in the console. Also, WTF is wrong with you, it's 2011, unless you're using 300MHz Pentium 3s found during garbage diving Eclipse isn't slow. Put PyDev on top and you are all set.
Ok. But he asked for stlye, not order.
&gt;They're simple changes to make, so feel free to try it, but I don't think there'll be a big improvement in going from dict to list and I doubt the difference using slots will be noticeable. This is incorrect. I just tested it, and I found that an object's dictionary has a default size of 124 bytes, and the object itself has a size of 16. Without slots, every new object will have it's own dictionary, which will soak up 124 bytes by itself, plus the 16 bytes for the object. You can add up to 5 variables to the dictionary without any extra memory overhead. After 5 variables, the dictionary will expand to 508 bytes. Let's assume we have two variables in each tile. We'll have a list of any units or items in the tile, and we'll have a pointer to the picture to draw the tile. If we don't use slots, the minimum size of each Tile instance will be 16+20+124 = 160 bytes. If we use slots, the minimum size is 16+20 = 36 bytes. The object size decreased to 8 because we used \_\_slots\_\_, so it no longer has a dictionary or weakref (which is None by default), but it increased from 8 back to 16 because we have two variables in slots, so we need two pointers, and each is 4 bytes. So, in summary, using slots will probably reduce the memory consumption of each Tile to **22.5% of the original size without slots**. * If you want to reduce memory consumption even further, you could make the lists properties with a getter and setter, and design the Tiles so that, by default, no list is defined. Once a unit enters the tile, you can define the empty list and put the unit in it, and once it leaves, you can delete the list. If you do this, you'll make each empty tile just 16 bytes, which is just **10% of the original size** without slots. * If you want to go even further, you could define two different Tile classes. One tile class would have unit lists, and the other would not. By default, all tiles would be TileWithoutUnit tiles. When a unit tries to enter the tile, you could call an external function to redefine that tile so that it's a TileWithUnit type. The default TileWithoutUnit tile could be given just one variable, so the size would be just 12 bytes. This is just **7.5% of the original size**. * If you want to go even further still, you could define a two-dimensional array that has pointers to each tile's picture. Then, you could define just one instance of TileWithoutUnit. Empty tiles could be defined as pointers to that one TileWithoutUnit instance, and to get their picture, you'd give them their coordinates and they'd look it up in the array. In this case, you'd still need 4 bytes for each pointer to the pictures in your 2D array, and you'd need 4 bytes for each pointer to the TileWithoutUnit instance that you created. So, 8 bytes per tile, total. That's **5% of the original size per tile**, and I think that's the limit unless you want to try a sparse array, procedural generation or use custom-made extensions written in C. Edit: Corrected some mistakes I made, and found that the memory use with slots is even lower than I thought.
Did you check out Cocos2d?
I have bad memories with Eclipse. But I try as most as I can to not be biased by past experiences: I found Eclipse on their PCs, tried to open it, and after 40 seconds it showed up in all its slugginess. So I left the idea of using it. Besides (I didn't mention this) it's overcomplicated for beginners (i.e. people who don't know what a variable is).
Security tip?! If you had known [RFC-1738](http://www.ietf.org/rfc/rfc1738.txt) you'd know that it's completely normal for urllib/urllib2 to read file://.
I don't think I misunderstood. FriendComputer used 'if': while stack: dir, files = stack[-1] if files: So the continue isn't needed. It's actually doing nothing. The code just loops and grabs from the end of the stack, which is the newly appended directory. I rewrote it with `while`, however, so I have to break out of the inner loop. But combined with reversing the directory listing (correcting for the pop off the end of the directory listing, which reverses the order), it gives what to me is a better order. Compare the two for yourself. 
Well then I don't know. I also use Notepad++ (but it doesn't automatically increase indent after `if ... :` etc) and vim (haha, that should do it for them!). Obviously, you'd have to run stuff in console. Oh, by the way, if you really aim at that kind of people, why not use Idle? It is a bit sluggish on larger files though.
&gt; applications which **blindly** urlopen **untrusted** URLs (for example, from RSS feeds) are potentially vulnerable to information disclosure and denial of service attacks. (Emphasis mine.) Old news is old, and should be obvious.
I have no particular advice on your example, but you'd probably get use out of the [PEP8](http://pypi.python.org/pypi/pep8/0.6.1) style checker in the future.
Yeah but really all he wanted was to see python interacting with the web. I can't think of a better starting point than bottle.
It is just you and some friends. Check out on the web2py twitter channel what [users think about web2py](http://twitter.com/#!/web2py) and why web2py is one of [the fastest growing frameworks](http://i.imgur.com/sPLzH.png).
A similar question showed up here recently, and the top comment was Peter Norvig's code. He writes excellent Python code as can be seen [here](http://norvig.com/sudoku.html) and [here](http://norvig.com/spell-correct.html). His website is: http://norvig.com/ .
&gt;So, in summary, using slots will probably reduce the memory consumption of each Tile to 30% of the original size without slots. No, this is wrong. The OP had the problem that 8 GB of memory is being used. This memory usage is primarily the *data* used for each tile, not the overhead on the object itself (excluding attributes). You have no way of calculating the percentage memory usage saved without knowing the size of the tile objects. In all likelihood, the amount of overhead saved by using slots is insignificant compared to the size of each tile object. Edit: Let's calculate. If the screen size is 1024x786, and the tiles are four by four, then that's about 50,000 objects. If you save 500 bytes for each object by using the methods you described, that comes out to about 25 MB saved. 25MB/8Gb means that memory usage has gone down 0.3%.
Perhaps this helps? class StoreTiles: def __init__(self,nx,ny): self.nx,self.ny,self.m=nx,ny,[None]*(nx*ny) def __getattr__(self,point): x,y=point return self.m[self.nx*y+x] def __setattr__(self,point,value): x,y=point self.m[self.nx*y+x]=value s=StoreTitle(8400,2400) s[4,5]=Tile() print s[4,5] If you try it, please post some benchmarks.
depends on what outcome you want. if you hope this person will eventually be asking ridiculously basic questions on stackoverflow when they need to do something non-trivial, then yeah that is a good reply. if however your hope for this person is to understand how the web works, nothing beats experience. And a good experience is actually going through the pain so that you understand where/why/which frameworks help. 
Consider using the [flyweight](http://en.wikipedia.org/wiki/Flyweight_pattern) pattern. Or use slotted objects or the struct module.
Might not fit your exact specs but I look for highly used resources and have found Google's SDKs for gData and AppEngine, Django, MoinMoin and Python's /Lib to be helpful
[Tornado web server](https://github.com/facebook/tornado)
Let's do the math. The OP says he used a 8400 x 2400 tile map. That's 20160000 tiles. We know that each tile was at least 160 bytes, so 20160000 x 160 bytes = 3225600000 bytes = 3.2 GB. We know that we can reduce memory consumption to 22.5% of that, assuming each tile has one pointer to its image and a list of units. So, we know that the OP could probably reduce his memory usage by 2.5 GB *just by using slots*. That's going to be noticeable. Also, dictionary space consumption is nuts. I couldn't even get my computer to test it because I've only got 1 GB of RAM. I tried the following: for x in range (8400): for in range (2400): dic [(x, y)] = z My computer crapped out before x got beyond 3,500, but the size of the dictionary was already up to 200 MB. I found that if we make x 8400, and make y just 240, then the dictionary will reach about 50 MB. My guess is that the full-size dictionary will be about 500 MB of overhead. A two-dimensional array, on the other hand, will be just 80 MB of overhead. So, we can shave off 420 MB. With these two small changes that shouldn't take more than 5 minutes to implement, the OP's memory consumption can be reduced by 2.9 GB of completely unnecessary overhead. Edit: Also, if the OP uses my suggestion to only have pointers to one instance of a TileWithoutUnit class, that would reduce memory consumption of those tiles to 5%, which would mean the OP would save an extra 500 MB, so the total savings would be about 3.4 GB.
Do these guys write code like this you think ? Or do they get the job done then tidy up / refactor etc ? ( closer to what I do myself ) 
Ah, yes, sorry. This code _is_ confusing! But your version with `while` traverses it differently: it prints the entire contents of the top directory first and only then goes deeper, while his recurses into each directory immediately after printing it. To preserve the behavior you can get rid of this weird "stack of stacks" thing he is actually using, with a function I wrote above -- then you always just pop the top file name.
Nice examples, thanks a lot
afaik this is patched. 
&gt;Edit: Let's calculate. If the screen size is 1024x786, and the tiles are four by four, then that's about 50,000 objects. If you save 500 bytes for each object by using the methods you described, that comes out to about 25 MB saved. 25MB/8Gb means that memory usage has gone down 0.3%. Except that's not the case. The OP has all of the tiles loaded in memory at the same time. There is no paging, no storing any of them on the hard drive. It's not 50 thousand tiles in memory. It's 20 *million* tiles. See my earlier response to your post for a more accurate calculation.
Two of the three current comments on here are other programmers trying to raise their own self esteem by making it sound like everyone in the world should know this by default.. and the one useful comment has zero upvotes. Programming is a continuously learning experience and it's impossible to know everything. Imo anyone who thinks they know more than they actually do are some of the most dangerous programmers to have on a team.
Well there's good and there's good. The most important type of good is "Does the job intended correctly". It doesn't much matter what the code looks like, if it meets that criterion, and I could point to a lot of code which is ugly as sin, but perfect in that sense. It's hard to make a beautiful sys-admin script for example. Then there's good as in "Pythonic". People argue about what that means, but for me it translates roughly to "clean and tidy", or possibly "Using Python's features to make code clean and tidy". I like short functions and methods, with a clear purpose, and minimal indentation, not long blocks which wind back and forth across the screen. But neat and tidy code doesn't happen by accident, you have to work to keep it like that it, and it isn't always worth the effort. I've always thought that CherryPy and Genshi were two examples where the authors have obviously put the effort in.
It breaks off when it finds a directory. It's os.listdir that lists the directories last. I'm just following the given order (I suppose I could sort and promote directories to the top). The original only does the directories first because it's totally reversed, down to reversing the file lists. ~~The issue with your function, if I'm understanding correctly (I'm not clear because lists don't have a push method. Could you write out the lstree function using this helper function?), is that it's recursive. A large directory tree will blow Python's max recursion limit (sys.getrecursionlimit). A depth first plunge is most elegantly handled with recursion, but Python doesn't have tail recursion optimization. You can use a trampoline, or, like here, you can maintain your own pseudo call stack in a list.~~ 
I think regardless of the language, you try to write it clean/tidy the first time. Why muck about latter where you can miss files out. At a previous job 1 of the devs there would comment out the code in a method, make his changes and then...leave in the commented out code. I asked him about this and the response was always: Oh, I forgot to remove it.
One thing I don't understand with IDLE is the ctrl + space pop-up - you know; the one with all the functions and variables. When does it update itself? I've tried saving and running, but it seems to be updating itself randomly.
Hipster pythonistas know all the RFCs by heart. 
Look, here's a complete code that I had in mind: import os from os import path as os_path def lstree(target_dir): stack = [] def push(dir, files): for file in files: stack.append(os_path.join(dir, file)) push(target_dir, os.listdir(target_dir)) while stack: path = stack.pop() print path if os_path.isdir(path): push(path, os.listdir(path)) This one does exactly the same as OP's code. It visits directories in the same order. It prints `'dir1'`, then prints `'dir1/file1'`, only then prints `'dir2'`. Because we pop a single path, then push all its subpaths, then continue with the last pushed subpath, in a depth-first fashion, not with the next path on the same level. The OP code achieves the same via a cunning trick: he basically has a stack of stacks (plus the `dir` part common to everything in a substack), and his iteration algorithm is, "pop the last item of the last stack, except when the last stack is empty, then pop it". Your code on the other hand would print `'dir1'`, then `'dir2'`, and only then `'dir1/file1'`, because instead of popping a single path, you pop the entire top substack and iterate over all paths contained therein.
I use IEP in Python 3 (discovered it recently) for interaction with matplotlib, and before that Spyder. Whenever I've used IDLE it seemed functional. I just tested the ctrl-space popup. I set `x=[]`; ran the file, and `x.` popped up list methods. I changed it to `x = {}`; ran it again, and got the dict methods. It works great according to this rigorous test harness (j/k -- maybe it's a heisenbug). 
Redirection to `file://` [was fixed](http://blog.python.org/2011/04/urllib-security-vulnerability-fixed.html), and [here's the checkin](http://hg.python.org/cpython/rev/a778b963eae3).
those are exactly what I'm looking for, hoping to find a few libraries in pure python though. Thanks!
My function doesn't do what you say. stack.pop() is on the else clause of the while loop. It only executes when `files` is empty. In other words I only pop on the way back after a subtree is exhausted. At first I was going to do it your way, but I decided it was wasteful to store the entire path for every file in the directory. I stayed with the approach of the OP that iteratively consumes the list of files until it's exhausted, then pops off the empty directory. I just wanted a forward ordering instead of having every file listed in reverse order, which yours also does (just use `for file in reversed(files)` to fix that). 
Oh, you have a `break` there too. OK then.
I thought an inner `while` loop was more explicit than having only one loop. You can see where it's yielding files from the directory and where it puts itself on hold to `break` into a subdirectory. It's not clear in the original, IMO, as the totally superfluous `continue` shows which someone insisted was necessary.
Rule number something of Python: Use the standard library. Seriously. One thing that makes code vastly more readable is using the same modules that every Python programmer is already familiar with rather than rolling your own. The importance of "batteries included" should not be underestimated.
They're both really small though.
[Bottle](http://bottlepy.org) is also a really great micro-framework.
Where do you see the benefits of this style, over say, mvc? I remember writing a non-trivial application with Seaside, which also features "html functions" and introducing a clean separation between logic and display became quite painful, as people would rather go the easy route and mix and match to get something to work.
I have gone through the Dive Into Python and Learn Python the Hard Way tutorials, and know about lists, dictionaries and tuples in addition to classes, exception handling and regular expressions. Thats about it. I have rarely used the import statement, in other words, I haven't explored any packages yet. So.. Thats about the python knowledge that I possess currently. On this basis, is learning Django a best option, or is there something even more basic.
Looks good.
I do not mind waiting for some more time before trying out frameworks. And I totally agree with you on the statement "Frameworks are meant to save time and not knowledge". So, I ask you as well. Please read my reply to FriendComputer and let me know your view on starting Django right away or moving on to something more basic.
Yes, `else` isolates a bit of code from executing after a break. It works like the `else` clause in your original. But, IMO, what you did without the inner loop was fine. My code explicitly pops all the files in a loop until it reaches a directory; then breaks. Yours does the same with only one loop, which saves the need for the explicit break. It's maybe a bit less clear like that, but that's just opinion.
I have come across Django, as in just heard about it. But I thought that Django is more like level 3 or level 4. I am still in level 1. (Please read the reply that I posted for FriendComputer later in this thread). Is Django indeed level 2?
Flask? Wow it seems really simple ( and almost seems to meet my expectation of something basic in HTML &lt;&gt; Python integration). Thanks. Will try it out.
Pfff, RFCs. I read PBRs.
PyDev has PyLint integration, for code analysis while you type. What does PyCharm use?
Nothing beats experience indeed, but everyone would have first started out as a n00b and then with time become pros at what they do. What I am looking for is the resources that these people had at their disposal - basically the stepping stones. Any thing that you have in mind (books, web links) that can help me understand how the web works?
Ok. Seems simple. I just run this as it is and then go to 127.0.0.1? I mean what are the steps to view the HTML page of the above...
I try to stick with [PEP-8](http://www.python.org/dev/peps/pep-0008/) for all my python coding. I wrote a little distributed web crawler which I would consider GOOD code. [CRAWL-E](http://code.google.com/p/crawl-e/source/browse/crawle.py) has just over 700 lines of code plus another [300 lines of test](http://code.google.com/p/crawl-e/source/browse/test_crawle.py). Feedback is always appreciated!
Hmmmmm.. I'll write something on this thread if I can get it to work on my PC as well.
At some point in your career you'll have to be able to take things for granted---like that people have read the documentation about the basic structure of a URL. Programming is a learning experience, as are *all* things, but no one gets in a huff when a native college-educated English speaker expresses disinterest in an article purporting to tell him or her that you shouldn't end a sentence with a proposition because it confuses some. 
This looks promising. I will look into using the first method. Thanks
[Gajim](http://gajim.org/)
Oh do they now? Well then. That IS quite good indeed.
well when I first started in web dev in python there was turbogears 1, there was only a very small django beta. I could manage to cobble together a tg app by reading the book/docs but I was basically following directions because there was no explanation of how it all works together. If someone had referred me to this (article)[http://pythonpaste.org/webob/do-it-yourself.html] it would have minimized my confusion, coming from a asp.net/php background. Once you understand how a request comes in from whatever server and how to generate a response under what circumstance.The built in ORM, or widgeting library or admin screens become extra, handy stuff you can use to build your things, not the magic that you rely on and are hopeless without. 
web2py is MVC. It has models (not used in the example because no database needed), controller (the example above is a controller and like Django or Flask it returns a dict) and views (which renders the dict). The example above assumes you start from the scaffolding app with provides a default generic view and default page layout. You can change them.
This guy sure loves list comprehensions. Great code nonetheless. Saved.
I know HTML. As for GET and POST requests, I know how to write HTML code for either. As for the intrinsic behaviour, I would say, I could do with some more research...
Hey, decent article. Seems like a good place to start. And thanks for the hints: "Once you understand how a request comes in from whatever server and how to generate a response under what circumstance". I'll start digging some stuff in this direction right away.
gVim! But I use it with the bash shell provided by msysgit...
Plone is not hard after you read the first chapters of the developer manual, make a couple of sites ( make a theme for a site), and study some of the collective.example or similar example packages. One thing I can guaranty you, learning Plone will make you a better programmer, and if you can get around the initial learning curve, the experience you gain here will be super beneficial for when you are trying to learn any other web framework or python CMS. And please quit bashing xml configurations, I don't see a lot of people complaining about the use of xml configuration with Android, or xaml for Silverlight, or other sistems that you xml configuration, they all have their places, and if you really hate it, in Plone 4.0 and 4.1 you can actually bypass it and use an imperative configuration with the use of five.grok just like Pyramid can use a declarative or imperative configuration 
You put it on a webserver in a directory configured to run as CGI, often it is /cgi-bin.
The hype around Pyramid stems from the fact it's backed by the Pylons team. When it was still called BFG I didn't see many people raving about it.
django has rails and opinions, pyramid does not have rails or opinions, both have useful building blocks for web applications. Why not try both?
If I can slightly change what the code does, writing this as a generator would be more useful. Then the results can actually go somewhere in your program, not just to the console. Just "yield path" instead of "print path". Then you can iterate over the results with for path in lstree(dir):
I guess I could try both, but from what I saw from my research, learning a framework is where the learning curve is at. But my main hesitation stems from the fact that I am a hands on learner. The reason I want to get into web programming is because I thought of a website i want to make (a user expanded archive website). And I want to choose a framework through which I could learn, but also keep true to so that I can develop this site. Do you think it would be worth it for me try both in that scenario?
I'd really suggest storing them on disk. You could optimize the heck out of your Tile class and it's storage, but that would make your system fragile to small changes and will make it even harder to add new functionality. As a first guess, try using a dbhash and just see how it goes. (http://docs.python.org/library/dbhash.html) Even better would be a "real" database to store Tile objects, and ideally, use a database that has a geospacial index. For example, you could use MongoDB which has a great feature set for exactly this use case. (see http://www.mongodb.org/display/DOCS/Geospatial+Indexing) Another alternative would be PostgreSQL with POSTGIS (see http://postgis.refractions.net/) although this is more tailored for "real GIS" not just "big 2d arrays". I'd write a wrapper TileStore class that pulls in tiles from the DB in "big chunks" of whatever your display size is (say, 32x32) and could manage a pre-fetched set of these "big chunks" surrounding the current point of interest. That way, your Tile object can be nearly unbounded in size, you can modify and persist it across runs of your program. All you need is a nice fast database with a good 2d index. 
1. Install ActivePython 2.7 2. Open Terminal and type `pypm install matplotlib scipy numpy` 3. There is no step 3. Ref: * http://code.activestate.com/pypm/matplotlib/ * http://code.activestate.com/pypm/scipy/ * http://code.activestate.com/pypm/numpy/
The Tornado webserver from Facebook (Friendfeed) is very well written and documented. https://github.com/facebook/tornado/tree/master/tornado
Do you really need a distinct Tile object for every slot on the grid? I'm guessing that you don't have more than 256 different tile types, (if this is just the underlying map, and not a persistent "state of the world"). Assuming there are &lt; 256 tile types, then just create a bitmap using something like PIL, (http://www.pythonware.com/library/pil/handbook/image.htm) and then set the color values at the given x,y to another value that you use as an index into different Tile instances (where you store actual images, other attributes, etc.) Make sure to use the minimium image color depth given the number of tiles that you have, and you'll save a bunch of RAM by not duplicating the contents of your Tile objects. If you have some Tiles that are mutable, then use a second sparse array layer (as others have suggested) to store the mutable tiles. 
I've used Turbogears 1, ASP.Net MVC, and Django for different projects. Of those three Django is head and shoulders above the rest - and I say that as someone who finds it easy to find fault with Django. What Django provides is really really good integration, everything is designed to work together, it's all there, and it's all documented. Say you need your app to send email whilst rendering a page. You can do that in any framework. But how hard is it to test that page? Django has a mail sending system, and it has a testing system, and they are integrated and documented. It's that sort of thing that makes Django such a great environment I haven't looked at Pyramid in great detail, but I believe it is very well designed. However it's just one component in a stack you have to put together yourself. And it's therefore **never** going to have testing support, or an email helper, let alone well documented integration between the two. So I say go for Django, there's a lot of things I would like to see done differently, but nothing you can't live with.
I'm a Python developer on Windows. I'm personally using [DreamPie](http://dreampie.sourceforge.net/) (which I would recommend without a doubt to every beginner) and Vim (which I would definitely not recommend to a beginner). So my recommendation to you would probably be: DreamPie + Lightweight Editor of your Choice. 
Yep, I've used bottle before to great effect. It's basically just as easy to use as Flask, except that it optimizes for fitting in a single file, whereas Flask has a richer underlying system (wich lots of extensions) that gives you more room to grow. Both are great!
VirtualBox and an Ubuntu ISO. But to answer your actual question: * PyCharm is pretty good cross-platform (the only Python IDE with strong refactoring support, I think), but it's not free. * Komodo Edit is a good open source option (the commercial version, Komodo IDE, is largely identical but adds VCS integration and other niceties like that). * WingIDE is not free, but has a very flexible licensing model. I don't like it but many people do. * PyDev is a plugin for Eclipse, which you don't want. Other than that, it's okay, if a bit enterprisey. For a good shell I would recommend getting MSysGit (even if you use Mercurial or something else) which comes with a splendid bash port for Windows (unlike regular MSys it's really easy to install). EDIT: If you just want something to edit Python files, Notepad++ is a good universal code editor for Windows if you spend a little time configuring it. I use PyCharm for real programming, but Notepad++ is a good, quick solution if I just want to take a quick look at some files and maybe make a few tweaks outside of any particular project.
That doens't tell me anything about which URLs urllib(2) will open. Edit: Furthermore, it is not at all unreasonable to think that urllib only concerns itself with network file-transfer type protocols, since we already have language support for handling local files.
&gt; I haven't looked at Pyramid in great detail OK..... &gt; And it's therefore never going to have testing support If you haven't looked then how do you know that ? Testing support is a standard component in most frameworks now, it's not an invention of Django. http://docs.pylonsproject.org/projects/pyramid/1.0/narr/testing.html
IIRC you can tell it to indent after colons (Python indenting rules or something). Notepad++ is better than its reputation.
If you run this script, it will print the HTML of the page. The [Common Gateway Interface](http://en.wikipedia.org/wiki/Common_Gateway_Interface) is a standard for [HTTP](http://en.wikipedia.org/wiki/HTTP) servers like [Apache](http://www.apache.org/) which allows programs to receive data from a GET or POST and reply with a document. When you install Apache (available for all operating systems) there will be a cgi-bin directory where you can place executables like Python/Perl/Ruby/PHP scripts and binary programs. Then simply navigate to http://localhost/cgi-bin/myscript.py. It works for every language - I wrote my first dynamic sites in C. I now write them in Perl and Python. This tutorial may be a good starting point http://httpd.apache.org/docs/2.0/howto/cgi.html though it isn't directed at a Windows user. If you are using Windows, ask and I will try to find one directed at you. edit: [I found this on the python wiki](http://wiki.python.org/moin/CgiScripts)
&gt; it's therefore never going to have testing support [You mean this testing support?](http://docs.pylonsproject.org/projects/pyramid/dev/narr/testing.html)
Blatant PEP8 violations in the assignments though.
based on the description of what you want to build, you are probably better off with something like django. bigger pieces, less decisions you have to make. 
The trick is to refactor early and often. Don't leave blatant eye sores in the code unless fixing them would do horrible things to your budget.
Flexibility wise which would you say is more flexible? Also what are the purpose differences between the two. Like you said that I would probably want to use django because of bigger pieces and less decisions. What does that exactly mean and what does pyramid have in place of that 
Pyramid is much more flexible. That also means you have far more ways of shooting yourself in the foot.
It has its own realtime code analysis. You can configure it and it supports quite a few checks and suggestions (such as join-double-if). You can add pylint/pep8/pyflakes or whatever as external tools to make them available in the menu or popup menu. I haven't yet figured out if it's possible to intelligently parse the output of these tools (click on line to jump to editor and such)
email helper: http://packages.python.org/pyramid_mailer/
OK, doesn't have testing support is perhaps not quite what I meant. Obviously any framework which doesn't allow you to test your application is pretty broken. If I understand that page correctly, It's instructions for how to set up stub configurations for your test fixtures when using the stdlib unittest module (presumably any other test framework would be equally usable) and how to use web test (which is awesome, much better than Django's built in thing). That's exactly the sort of thing you'd expect a pure web framework to have. No special test runner, no special assertions, no test framework specified. Nothing too opinionated, just enough to use whatever tools you want to get the job done. Django goes rather further. Partly because it has to! My first step in Django was to run nosetests on the project, and I got some horrible error a bout DJANGO_SETTINGS_MODULE. Also, OMG I can't believe you're talking to me, SQLAlchemy is amazing! Keep up the good work.
The new guy should start with Django. When you start to understand more about web development, grow a more complex system, and customize more, you will find that with a larger framework like Django you will end up "fighting the framework" more than with something like Pyramid. Pyramid is intentionally lower-level, making no assumptions about whether you use a SQL database or another NoSQL solution, etc, which can be important. It will continue to grow tools and support which will help make it easier to start new projects, but currently it's hard to beat Django's tooling just because it is so tightly coupled with contrib and its data model (django.db).
yep
I guess that does make sense. I think I will start with Django, and somewhere in the future move somewhere else 
Thanks. I think I will start with django
Wow, I'm really being made to look stupid here! :-)
This sounds more like what I want. The more I think about it, the better and easier it would be to use a database (such as MongoDB). Thanks for the info.
Some links: http://www.myhdl.org/doku.php/projects:intro http://www.jandecaluwe.com/hdldesign/digmac.html
MSVS2008 C++ is not required, the Microsoft Visual C++ 2008 SP1 Redistributable Package will do. But to make a stand-along Windows executable with PyQt4 and Py2exe, for Python 2.6, you have to bundle the following files with your app: msvcm90.dll, msvcp90.dll, msvcr90.dll, and Microsoft.VC90.CRT.manifest. (available from the Redistributable Package) I put copies in the folder with my Py2exe setup.py file, and setup.py includes: data_files = [('', glob.glob('msvcm90.dll')), ('', glob.glob('msvcp90.dll')), ('', glob.glob('msvcr90.dll')), ('', glob.glob('Microsoft.VC90.CRT.manifest')),] 
nah, easy to miss
Presumably you'd agree though that there are things that Django does as a (very) full stack framework, which Pyramid would consider out of scope? There must be examples of things that Django does where you think "I can see why a web developer would want to have that to hand but it doesn't fit the Pylons project".
well to give you an example.... a lot of django's pieces like the admin interface requires django's orm(this might have changed but as far as I know, still true). This is fine, if you want to use django's orm, but if you wanted to use something else like sqlalchemy, or a nosql database, this is where you start deviating from the docs and will inevitably run into trouble. A lot of other apps that you would potentially reuse also make assumptions based on usage of django's orm rather than deviating from the norm. The overall theme is the rails django provides are very solid, and will serve you well if you stay on them, but if you need to stray from them, you may find that the framework is fighting you rather than helping you. Pyramid on the other hand does not have an orm or officially endorse one, people who use pyramid likely use sqlalchemy for relational databases though, but pyramid doesn't care. (it's the honey badger of web frameworks, it does what it wants). because pyramid doesn't endorse or provide an orm it also doesn't provide or endorse anything that might require an orm, thus it doesn't have an admin interface. To give you an idea of the flexibility of pyramid... For my day job we use pyramid to provide a json rpc service for a single page app built in gwt it runs on appengine. One of my side gigs is using pyramid against mysql and thus using sqlalchemy, and also uses toscawidgets 2 for form/validation and javascript integration. Both apps, use traversal and require row level security. And pyramid does awesome for both. My day job migrated away from django because the appengine support at the time was lagging behind the sdk that was current, so incorporating features unique to appengine that were not already supported by the django non-rel project was a pain in the ass we didnt want to deal with. We determined it was silly to read the app engine docs and see how to do things and then spend hours trying to figure out how to trick django into doing them that way. the shortest path for us was to do it directly on top of appengine, in this case django got in our way. On the other hand, I had a friend who has a local business and got thoroughly screwed by some asshole graphic designer on her website. So she wanted to instead have something that she can manage the pages herself. Either Drupal or django with django-cms would work, I have had enough of dealing with drupal so I used django-cms and had a graphic designer friend theme it and we got that running in a weekend. And now she's happy and I get cupcakes whenever I want. :) Yes I could have done it in pyramid, but I didn't want to waste time on it, as she couldn't afford my rate anyway. Hope that gives you an idea. :) In the end, maybe this will help Pyramid is for libertarians Django is for socialists Flask is for religious fanatics. 
My problem was that I had installed python 2.7.1 manually from the python web page and that python was before the macports version in my $PATH. Thanks
you mad bro?
That kinda make me want to work with Pyramid. Django may be the easier path, but I feel like for what I want to do with that website, I would need the flexibility, not sure though. I also feel like having something more flexible will give me a stronger base/foundation and allow me to learn more in the short and long run. I don' know I just feel like pyramid . I guess i just really liked that image on the pylons website :P. I guess I am just feeling the hype for it . Now I don't mean I have made my decision yet :P. Still torn probably more torn now, but at least I know more. Thank you very much. 
Thanks everyone, I really appreciate you guys taking time out of your day and answering my Question. Thank You So Much.
I like the scikits.learn code, it is well-tested, well-designed, and mostly well-implemented. The quality is not uniform, though, and some parts are sketchier.
Of course it doesn't. It's an RFC. You have it backwards, the RFC is telling urllib how to operate.
Not sure why you're getting downvotes, this makes sense to me. It should be up to the developer to know the libs and do input verification on the data they're receiving. 
You are right. On my folder of ebooks, os.listdir was so nearly in order that I missed a few that were out of order. So I guess my intent to preserve the order of listdir's output isn't meaningful in general. However it seems oddly biased toward being in alphabetic order in most cases. Maybe it's a Windows thing.
I'm trying it now. It seems to fill very well my requirements: it has good tools to expose what's going on (debugger with name scopes, stack state etc). Plus, it's bundled with [PortablePython](http://www.portablepython.com/) so I'll go for it probably.
This is some nice Python.
Sure. An admin interface is one. Pyramid will itself never have one of those. There are already several written with Pyramid that implement CRUD of database tables, but none of these will ever be "in Pyramid". I can see why people like the feature, but binding Pyramid tightly to a relational database (or even just to SQLAlchemy) is not reasonable for its scope.
&gt; Please suggest what you think are the best tools for python development on the windows platform that a beginner can start using from day 0 (with some little help). I love gVim, but I don't think vim is appropriate for beginner non-programmers. 
Thank you, I will absolutely give this a try! I'm very curious, though... what is: glob.glob() ?
Dreampie is indeed great for interactive development on windows...
Are there any benchmarks against closure or uglifyjs?
I don't see why not, as long as you have a good reason to to use `break`. (Some people get confused about the else suite and think it only executes if the loop condition is initially false.) It's typically used in a search loop that breaks if the target is found. Often such a search is better placed in a function, especially if it's nested, from which you can simply return rather than break. There's also an else suite for try/finally. 
No it isn't. It's simply explaining what an URL is. Nothing more and nothing less. It's only very slightly related to what urllib is and does. Unless you're going to claim that urllib is able to use ALL URLS regardles of schema?
this isn't exactly a game but a wrapper for a minecraft server using twisted https://github.com/YellowOnion/minecraft.py I also have experimented with OpenGL &gt;3 in anticipation of making a game https://github.com/YellowOnion/opglex
Knowing what an URL is, and knowing specifically that urllib(2) will open file:// URLs is very different. Unless you work under the assumption that urllib contains code to handle any possible schema, which is frankly an absurd position to take.
I believe PyCharm is free for academic and open-source usage. EDIT: I stand corrected, the academic isn't free, but hey also have a classroom license which *is* free.
I think by far the best response here is [eryksun's](http://www.reddit.com/r/Python/comments/hubv0/how_to_integrate_html_with_python/c1yg888). If you didn't already know, you can run the code he pasted in Python, then visit http://localhost:8000/ in your browser to see the application in action. It uses WSGI, like virtually all modern Python web applications. If you don't understand everything it's doing, try the even simpler example [here](http://docs.python.org/library/wsgiref.html#examples) first.
Sent a pm with a suggestion. The discount codes are not hard to find though if you look around.
Laurence Rowe, one of the commenters on that blog post, put down results for closure and uglifyjs, which is 90,557 and 90,975 / 90,985 correspondingly.
because you can't always do data verification. urllib2 will happily tell you if a redirect has occurred, but only after the call completes. So while the end-programmer could verify that they weren't redirected to a local resource, if they were redirected to, say, /dev/random, it would be a denial-of-service attack on the python application.
Makes sense now, thanks.
[Here is the game](https://www.nytimes.com/interactive/science/rock-paper-scissors.html) in Flash. When you play a bit, a "see what the computer is thinking" button appears, so you can follow what the AI is doing. It can give you some ideas for your implementation in Python.
&gt;20 million tiles Sorry, I missed that part. You're right, in that case, creating a separate object for each tile is a big waste. Probably needs major redesign.
I would recommend studying the internals of unittest in the standard library. It has some interesting design patterns, and your knowledge of the internals will reinforce your use of testing during development.
I use WingIDE and really like it.
file:// URLS *are* URLS and are pretty damn common in the Unix world---anything you can point at an external resource URL can also be pointed at a file that provides the same information flow. I'd expect something that calls itself a cross-platform url library to be able to handle all URLs unless it specifically says it cannot. To give an example, I'd expect a Postgres database driver to be able to handle all the functionality associated with the Postgres database. If they don't provide something like cursor support, and *don't document it* as well, then I'd be surprised. This syrupy sanctimonious idea that "we're all learning" so therefore we should keep the discussion to a low level is what's absurd. I'd love for the people on /r/python to be professionals, researchers, or deeply enthused hobbyist. If instead, a majority are really still taking baby-steps then I don't want to be a member of such a community. There's places I'd go to mentor others, but I never thought *this* was that place.
You're absolutely correct. A URL library ought to open *all* URLs. Expecting it wouldn't its absurd.
&gt; I'd expect something that calls itself a cross-platform url library to be able to handle all URLs unless it specifically says it cannot. That's deluded. Would you expect it to handle ssh urls? scp? git? It's in no way inherent that urllib should read file:// urls, especially since the stdlib already has more than enough ways to open and read local files.
A word or two on [the implementation](http://code.google.com/p/import-file/source/browse/trunk/import_file.py) would have been nice.
Thank you for this. In web2py we have a function with the same functionality but your implementation looks better. We will review and we may use it, with proper acknowledgement of course.
Examples? What can you do with it?
Of note: **Redirection** handling was patched not to redirect to anything other than http/https/ftp but file:// is perfectly legal with urllib if you take a look at the second sentence describing the [urlopen](http://docs.python.org/library/urllib.html#high-level-interface) method for urllib: &gt; Open a network object denoted by a URL for reading. *If the URL does not have a scheme identifier, or if it has file: as its scheme identifier, this opens a local file* (without universal newlines); otherwise it opens a socket to a server somewhere on the network Just thought I would clarify :-)
You won't probably run into the "edge cases" where you exhaust django's capabilities. And since you seem to be on the visual side of things, django has a pony http://djangopony.com/ where pyramid has, well, a pyramid :)
&gt; That doens't tell me anything about which URLs urllib(2) will open. Gotta be shitting me. It does tell you what a URL is and if you bother to look at the Python documentation of urllib; 20.5. urllib — Open arbitrary resources by URL so according to RFC-1738, file:// is a perfectly legal URL and so you'd expect to see urllib to process file://. Those standards exist for a reason. Besides Python documentation says it'll open file: 
&gt; Two of the three current comments on here are other programmers trying to raise their own self esteem by making it sound like everyone in the world should know this by default. It's even written in [urllib documentation](http://docs.python.org/library/urllib.html#url-opener-objects). It'll open file: This is a basic thing. If you're coding in Python, then yes you should know this by default.
&gt; Knowing what an URL is, and knowing specifically that urllib(2) will open file:// URLs is very different. Please read the [library documentation](http://docs.python.org/library/urllib.html#url-opener-objects) at least. You've no clue what you're talking about.
You should try re-reading this thread.
GitHub seems down for maintenance now.
29.00 for academic
lxml.
I think it's a good idea to do a small project in each. Even a tiny project should give you a decent idea of which you like better and which is more suitable for the types of things you might end up doing. That said, you can't really go wrong just picking either one at random.
 &gt;&gt;&gt; [i for i in people if i in set_of_people_who_dont_like_list_comps] == [] True
Numpy arrays don't appear to be either data sources or targets?
There appear to be some use cases in the blog link.
i wholeheartedly agree
I've used both Django and Pylons (from Pyramid people). Definitely go with Django. Technically, both are pretty similar, but from a documentation/tutorial/third-party add-ons perspective, Django blows it out of the water. If you have lots of spare time, Pyramid may be the best fit for you but be prepared for a bigger learning curve.
Rarely seen on Reddit. More people should do this.
Good now. The stattr website, however, is not responding...
The cubes portion is OLAP which is a good portion of the business intelligence field. Marketing people love this stuff.
With BeautifulSoup it would be something like this. It's not perfect but it can serve as a starting point. import urllib2 from BeautifulSoup import BeautifulSoup url = 'http://dl.dropbox.com/u/5768678/dyer/ea.html' soup = BeautifulSoup(urllib2.urlopen(url).read()) for tag in soup.findAll('strong'): print tag.text, "=&gt;", tag.nextSibling **Edit: ** if this is the only file, you can also export it from your browser as a *text file*. Then process the text file line by line. There you have the right to use regular expressions :)
You might want to give web2py a try. I have found it much simpler to work with than django. http://www.web2py.com Try it, you may like it.
I found this: http://stackoverflow.com/questions/3154460/python-human-readable-large-numbers However, no libraries, just copy/paste code... although the top answer is pretty short and sweet.
Your new? Do yourself a favor and read both of these: * [RESTful Web Services](http://oreilly.com/catalog/9780596529260) * [RFC-2616](http://www.w3.org/Protocols/rfc2616/rfc2616.html) Learn the architecture of the web.
He shouldn't use Django! He should spend his first 5 years of web development writing admin interfaces from scratch like the rest of us did.
On the contrary, we're all learning which is why we *should* discuss things like this. I don't think anyone was saying otherwise.
As another commenter said, does that include ssh:, git:, ftp:, etc.?
Parsing as text is a good idea, but there's 46 of these. That would take a while. BeautifulSoup is probably my best bet.
You could check out the [humanize library](https://docs.djangoproject.com/en/dev/ref/contrib/humanize/) from Django, which contains various utility functions along these lines. 
I guess it wasn't clear but I want to do the opposite. I want to take "Three hundred eighty two and seven sixteenths" and convert it to decimal. It's not hard but it's the sort of stupid thing that must have been done correctly many times already.
Yeah, it's on a computer at home, and managed to crash the second I left the state. Sorry about that :(
Thanks. You are right including what you said learning django. I have no idea what I am doing, so it is a must that I learn the architecture of the web. I found out today that I've been to impatient with all of this. I was having trouble installing Django (not quite sure if i succeeded or not :P ). I guess I need a starting place and frameworks are obviously not it. I'll read both of those books. What would you suggest as learning path? (I do eventually want to end up on python) Thanks. 
Cool, I was just teaching my 10yo nephew how to make a simple rock paper scissors game. 
Oh, right. I'm not able to find anything. I think it's a sufficiently rare requirement that there are no such open source libraries. Could be a fun, small project, actually.
Look at [html2text](http://www.aaronsw.com/2002/html2text/) too. [Here it is](http://www.aaronsw.com/2002/html2text/?url=http%3A%2F%2Fdl.dropbox.com%2Fu%2F5768678%2Fdyer%2Fea.html) how your example file looks like in plain text.
I'm seeing if I can't hack one together. Stay tuned. EDIT: Here we go: [Gist](https://gist.github.com/1016189). Tests seem to pass, although it's a lot more permissive than it should be (parse_number("three four") returns 7 instead of raising, for example). It adheres to the short-scale system (one billion = 10^9 ). EDIT EDIT: just noticed that the OP wants to be able to translate stuff like "seven sixteenths." Left as an exercise for the reader. :P
try this too: &gt;&gt;&gt; import antigravity
A nice smaller alternative to the behemoth that is SQLalchemy.
Yes I use it a lot, but I did not ever tried to put that into an exe-File. That allways sounds crazy to me; there are other ways to package Python Apps :-) Besides that criteria Qt is an excellent framework and the two bindings both rock. The documentation of Qt is one of the best I ever was in touch with. As other said yet, it seems to be possible to pack a PyQt / PySide App into an exe. So you should have a look at it :-)
I would suggest to have a look into the variaty of [pocoo](http://pocoo.org) libs and apps. These guys write very clean and nice code. Perhaps the **Brownie** lib is a good starting point.
Hu... web2py is extremly ugly - no matter if you look into the code or the documentation or the general concept. Not a good advice imho!
But CGI sucks ;-) One should use a WSGI compliant framework for we apps. dot. For really small things and if installation is a criteria then use bottle - that is far better than plain old CGI!
Thanks for the tip. I'll try to add some some explanation.
Awesome, thanks :)
I think I might just pump all 46 files through that and parse it by line. That would be much easier, especially since some files use &lt;strong&gt; and others use &lt;b&gt;, and I really don't have the patience for that this week. Thanks for the tip! EDIT: Oh hey, a Python module. Even better! EDIT 2: So, the sheer amount of inconsistencies is making this almost prohibitively difficult... Or I'm going to have a few full days of fixing stuff.
I would definitely second the recommendation to try web2py. Very quick and easy to get up and running. Beauty is in the eye of the beholder - some people do not like some of the core design decisions in web2py, however, it delivers an effective and useful platform. To me that is more important than some assessment of how ugly or pretty it may be. 
If the number of calls you intend to make is relatively small, you could always parse Google output: http://www.google.com/search?source=ig&amp;hl=en&amp;rlz=&amp;=&amp;q=Three+hundred+eighty+two+and+seven+sixteenths&amp;btnG=Google+Search
the 'file' scheme is a registered URI scheme with IANA. ssh, scp, git, are not. http://www.iana.org/assignments/uri-schemes.html If you're going to remain RFC-ignorant, please cease programming for the internet. 
Without reading the documentation for it---I'd expect URLLib to try and open everything that it knows exists, and fail on non-standard resource types like git: or mythinyimadeup://. ftp, file, http, https are standard now. Heck, I'd even expect it to open gopher links. Now after I read the documentation---I *know* it only works with http, ftp, and file by default, and for anything else you need to subclass the URLOpenner and write your own case. This isn't really too complicated, I'm operating on the Principle of Least Surprise.
ftp yes, the others no (they are not registered URI schemas). Please try to understand [RFC-1738](http://www.ietf.org/rfc/rfc1738.txt). Internet standards are not just there to poke fun/ire at ignorant programmers. 
If you have a more user-friendly link, I would love to read it. I'm far too tired to wade through an actual RFC tonight.
Python 2.6.6 (r266:84292, Sep 15 2010, 15:52:39) [GCC 4.4.5] on linux2 Type "help", "copyright", "credits" or "license" for more information. &gt;&gt;&gt; import antigravity Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; ImportError: No module named antigravity 
how it came into being: http://www.zeromq.org/story:3
Scumbag programmer: says he doesn't want to start a flame war / asks which language is more 'fun' and 'modern'
This! By request, I just published a [link collection for Python beginners](https://docs.google.com/document/pub?id=1bCLVfxBkfY5J3gVp3Br8L_f_7trQJCXCJmITHMGn0zw) with 3 sections: tutorials, read code, write code. Guess what code I recommended to read? Exactly what you did: the sudoku and the spelling corrector. BTW, could you provide a link for this &gt; similar question showed up here recently ?
Can't you just make a function for it: &gt;&gt;&gt; def toint(s): ... try: ... return int(s) ... except: ... return None ... &gt;&gt;&gt; print toint('10') 10 &gt;&gt;&gt; print toint('10a') None &gt;&gt;&gt; Or equivalently, if you want to be able to specify a default value: &gt;&gt;&gt; def toint(s, d): ... try: ... return int(s) ... except: ... return d ... &gt;&gt;&gt; print toint('10', None) 10 &gt;&gt;&gt; print toint('10a', None) None &gt;&gt;&gt;
I do plone for food and the no1 tip is to avoid it and use something else and build your foundation on something solid like an relational database or a cool no xml template language , there some articles on Django vs Zope/plone http://thingsilearned.com/2007/08/14/zope3plone-to-django/ From my experience Plone is horrible , the learning curve is insane and when you reach on the top everything changes (plone 2 migration to plone 3 to plone4 ) bellow you , The non relational database is the suck when you do searching and when you really need to do the cool stuff like joins that you have in the relational world (think of it like an regression from sql to the the presequel world of hierarchical insane databases) ps: to make it more usable i use in plone jinja templates instead of the default one and also i use relational databases when i can (yes i try to convince them to use something better like django)
Well, it's harder than it sounds due to the necessary tolerance (e.g. dashes, redundant "and"s) and, of course, if you need internationalisation.
Admin interfaces? Feh. He should spend his first 5 years manually putting holes in punchcards with a pointed stick! If it's good enough for our forefathers, it's good enough for us! When I was your age, we didn't have "whitespace". If we wanted to indent something, we had to print it out and glue it back on a few inches to the right!
Flask is even more flexible.
What's not to love?
&gt; in 3.x
On a small scale (functions, single classes), I usually write my code as elegant and clean as possible on the first go. On a larger scale though, you tend to lose track of the overall architecture a bit, or maybe you start adding things your initial design didn't take in account, so you'll have to refactor. The most important things for a clean and elegant design are to never write *programs*, but to always write stand-alone *libraries*, and to adopt a paradigm which your design will adhere too. For instance, in Python the paradigm is "everything is an object". If you're writing, say, a CMS, the paradigm could be "everything is a container and a container does such and such" (validation, storage, information passing, whatever). This will give your design a nice consistent feel to it.
The security repercussions are obvious if you consider them in this context. But if you never get a chance to consider them -- it may not cross your mind that using urlopen on untrusted URL's is dangerous. I think it is in this sense that people do not know this. They've never placed this in its security context.
Take a look at this: https://svn.electricmonk.nl/svn/mcplayeredit/trunk/ (ignore the HTTPS error, it's a self-signed certificate). It's my commandline Minecraft Inventory editor. A real world example of a live project which has undergone many changes. The initial design still stands up to the changes made in Minecraft. I've had to refactor a bit every now and then. You can see previous revisions [here](https://svn.electricmonk.nl/public/listing.php?repname=mcplayeredit&amp;path=%2F&amp;). For instance, [this](https://svn.electricmonk.nl/public/comp.php?repname=mcplayeredit&amp;path=%2F&amp;) revision saw a rather large refactoring. The code is well documented, relies heavily on proper data structures and does some dynamic things such as mapping commands to functions in a class automatically. The autocomplete is derived from the method definitions and the online help in the editor is derived from the methods' docstrings. It is also platform-independent and runs on Windows, Linux and MacOSX
IIRC you can get PyCharm for free if you deserve it, if you can convince the nice folks at JetBrains of it. The classroom license is an option if you teach them in a lab, for example. In any case, for commercial use, PyCharm is absolutely worth the price tag.
There's some overhead inherit to a function call, however. On the following test using the function typically adds about a 6-7 percent penalty. That said, this is an extreme example and improving readability is probably worth taking a small hit to performance. from random import choice values = ['1', '3.14', 'a', ''] seq = [choice(values) for i in range(1000)] def toint(s, d): try: return int(s) except ValueError: return d test1 = """ integer_seq = [] for item in seq: integer_seq.append(toint(item, 0)) """ test2 = """ integer_seq = [] for item in seq: try: integer_seq.append(int(item)) except ValueError: integer_seq.append(0) """ from timeit import timeit t1 = timeit(test1, "from __main__ import seq, toint", number=1000) t2 = timeit(test2, "from __main__ import seq, toint", number=1000) print(t1/t2) 
alternatively use s.isdigit() for ints, not for floats
in 2.7+
Sorry, forgot to mention that it's available from Python 2.7.
Good point. Could very well be faster than trapping the exception too.
Right. I just checked and it's 2.7+ indeed. Still not as universal as `braces` or `this`.
Something very similar written a few years ago (without multiprocessing though) by Guido van Rossum: http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html
Very true. To amplify on this theme, I extended your test to cover moriaantje's suggestion of replacing exception handling with str.isdigit(): from random import choice values = ['1', '3.14', 'a', ''] seq = [choice(values) for i in range(1000)] def toint(s, d): try: return int(s) except ValueError: return d test1 = """ integer_seq = [] for item in seq: integer_seq.append(toint(item, 0)) """ test2 = """ integer_seq = [] for item in seq: try: integer_seq.append(int(item)) except ValueError: integer_seq.append(0) """ test3 = """ integer_seq = [] for item in seq: if item.isdigit(): integer_seq.append(int(item)) integer_seq.append(0) """ from timeit import timeit t1 = timeit(test1, "from __main__ import seq, toint", number=1000) t2 = timeit(test2, "from __main__ import seq, toint", number=1000) t3 = timeit(test3, "from __main__ import seq, toint", number=1000) print t1, t2, t3 Which is faster still. On my system that yields: 2.76692426584 2.1132926949 0.380761479845
isdigit needs to be enhanced to test for negative numbers and strip white space: def isint(s): s = s.strip() return s.isdigit() or s[0] == '-' and s[1:].isdigit() But this is only valid for string objects. The `int` constructor also handles int and float types, or user defined types that have an `__int__` method: class N: def __init__(self, v): self.v = v def __int__(self): return int(round(self.v, -1)) &gt;&gt;&gt; n = N(14.5) &gt;&gt;&gt; int(n) 10 
Indeed, I have stumbled upon it while was writing the solution (and learned heapq.merge()). array.append() that uses Guido is slower. On huge files overhead adds up to ridiculous amounts.
In fairness, the assignment alignment is a controversial aspect of PEP8
Why would you want to avoid exception handling in python? It's the most useful thing ever. When you have to rely on return values your code starts to look like this: res = do_something() if res: handle_error() res = do_another_thing() if res: handle_other_error() res = do_third_thing() if res: handle_third_error() But with exceptions, oh baby I get excited: try: do_something() do_another_thing() do_third_thing() except Exception: handle_all_them_errors() So much class... 
Interesting. The non-function exception handling should be a bit faster. It is on my machine running win32 Python 3.2: tmax = max(t1, t2, t3) print([t / tmax for t in (t1, t2, t3)]) [1.0, 0.9310327613604773, 0.9557782137792562] 
Whoa, that was unexpected. Then again, my test was run using ActivePython 2.6.5.14 (Win7, 64bit), so direct comparison of our timings might be a little tricky :)
Here you go: http://www.reddit.com/r/Python/comments/hht53/anyone_suggest_great_python_code_to_read/
I said twice that I was talking about Cython, measuring it in CPython is a bit pointless because the rest of your program will execute slow anyway (as you say, it won't be the bottleneck). With Cython you access the Python C API directly, so it's closer to measuring the actual overhead of the tuples/lists themselves, as opposed to interpreter overhead. And you don't have to tell me what tuples are for, I was talking about situations where you can use either tuples or lists, and where you might expect that one has an advantage over the other (the immutability of tuples makes them more "static"). The free list is indeed a difference, but for my code it was about a set of create-once read-many lists/tuples (the rules for a grammar), so that didn't matter.
Handling exceptions should be faster than searching through long sequences to "ask permission". For base10 ints, it's quick to check the value of up to 11 characters (i.e. -2147483648), but it's still faster to not bother checking and apologize if there's an exception. 
-1 off topic. #boom
I'd be interested in this too. I'm going to try and convince my colleagues to give this a try. We do FPGA design tools.
[pony middleware](http://pythonpaste.org/modules/pony.html#paste.pony.make_pony) is provided by paste a dependency of pyramid. Any wsgi application can have the power of the pony. :)
a little bit short...
short and sweet ... just fishing for some beta testers :).
Interesting. I feel the same way about Celery, and my current go-to solution of just using cron always leaves a bad taste in my mouth. I'll definitely check this out. Incidentally, you should really consider adding an introduction or overview to your readme. I had a really hard time figuring out what exactly the project was for until I read your blog post.
So complicated. I take it this guy is a Java programmer.
No I am not :) I am just writing pre- and post- processing code all the time and that bores me
glob is a Python library that helps to created the proper file path to the dlls. You can read more about it here http://docs.python.org/library/glob.html For more details about the Microsoft redistributables and Py2Exe, see here: http://www.py2exe.org/index.cgi/Tutorial#Step5
I guess I'm not enterprisy enough to understand that
you consider that complicated? 
pretty cool article. I like how it describes a possible implementation of some of the magic that web frameworks hide from you.
try this: &gt;&gt;&gt; import __hello__ 
we, and similar new python framework people would like to know what your decision was, and perhaps the 2-3 biggest reasons why.
Is the file created and processed on the same or similar hardware? Otherwise you could define an endian order and swap if the system uses the opposite order. For example, make the file 'big' endian: if sys.byteorder == 'little': a.byteswap() ~~Also you could set the default number of processes based on multiprocessing.cpucount(). ~~ For iterating through a file by chunks, I like the following idiom: for chunk in iter(lambda: f.read(CHUNK), bytes()): ... Then it's simpler to use array's fromstring method instead of fromfile -- no more sentry variables or having to deal with EOFError. 
Only django has the original and [feared](http://www.flickr.com/photos/bastispicks/3400633546/) pony.
I actually haven't settled on a framework. I decided to take ericmortiz's advice and learn the architecture of the web, and get a stronger foundation of the web, before I dive into stuff like framework. It kinda dawned on me that I had no idea what was going on when I was searching through the framework and some of the concepts a.k.a almost all of them I wasn't familiar with. So I am gonna read those two suggestions ericmortiz gave. On side note, before my revelation I had decided on Django because it seemed slightly more safe when it came to new guy learning. It seemed to me (may be completely wrong about this but impressions are impressions) that I would have a harder time getting other frameworks up and running due to my lack of experience and knowledge. Now granted when I tried to install django on my computer it was not easy and still not sure if i succeeded or not. Also part of it was that I was being swayed by people on stackoverflow and here on reddit (the hype). I hope that helps. But all those reasons were based on my inexperience and not knowing where to start(still kinda don't, seems like frameworks may be a little too advanced till i get a better understanding of the web.) What framework do you develop? 
Input the integers into a SQLite db and let that do the sorting for you?
HAHA the sprints at pycon 2k9 were a blast. 
Try it, and let us know the performance difference
Omfg, *sometimes* it indents, *sometimes* it doesn't. Try configuring it to run in python.exe when you hit F5 as well with: $FULL_CURRENT_DIRECTORY After the python.exe in the run command, but it doesn't stick and occasionally throws errors. I really like Notepad++ otherwise.
I lovoe Notepad++, I use it for nearly all scripts I write, then I slowly drift over to IDLE after Notepad++ screws up indentation and forgets my run in... settings. Wish I could fix it actually.
Another, though non-Python, solution is to call the Unix `sort` command. Once I needed to sort a huge file (2 GB) and it did the job.
I work in django day to day. after I learned that, RoR and php frameworks were way easy, but other python frameworks leave me longing for "the django way" often. The main frustration you'll have with django is that it makes something super easy, then you just want to tweak a tiny little thing that devs didn't consider, and you'll need to go back to square one, whereas other frameworks, you're at square one to begin with, so its just natural to build it yourself. (django does allow you to get all the way down to the core stuff, so you can still shoot yourself, but you need to work at it) My biggest boon with django is that many of the web security things are taken care of in a hands-off manner, leaving you time to develop your own code, and learn stuff like web security slower, rather than needing all the knowledge at the beginning. when I started PHP, i was all "WTF?! i need to add code to make my strings safe for databases, EVERY TIME?! thats annoying.(probably not true for all frameworks :-)" I've taught django to kids at computer camp, following along with thedjangobook gives you a good sense for the amount of code needed to write something. also, things like djangosnippets and the community on IRC(freenode) are extremely helpful to point you in the right direction. What it comes down to in my mind is, do you want to develop your framework(giving you a firm foundation), or do you want to develop your website/app(and try not to worry about the base quite yet)?
if you go for a solution that doesn't come with a sufficiently powerful html code object or templating system, i suggest you have a look at [markupsafe](http://pypi.python.org/pypi/MarkupSafe). it's a very lightweight module that creates strings decorated as html, for example: label = Markup("&lt;em&gt;Posted by&lt;/em&gt; %s on %s")%(user, date) where you don't have to worry about html injection any more (if user is a custom string), but you can also have objects provide their own html formatting.
Thanks, that zip trick is clever and saves the hassle of manually typing out a map.
I think I would much rather work on my framework and build a firm foundation. (i have been trying freenode but for some reason it is not sending my messages but thats a story for another time :P I'll just read the FAQ and support stuff later). I had not known about Django Snippets. Thank you for telling me about them.
It's really tempting to do everything in python, but for text munging tasks, a lot of stuff is way faster with `cut, awk, sort`, etc. `xargs` and gnu parallel can make parallel processing easy as well. Fluency with these tools can save a ton of time (development and processing). edit: also `split`
[Quite](http://ponyransom.com/) indeed.
Is it? I find assignment alignment repulsive. Needing to group variables like that is often an indication of poor design (i.e. it's time to refactor again).
sqla may be big but it's also pretty damn useful. 
Yeah, you'd think that the interpreter would notice that the function is being called as a method and alter the error message accordingly.
-1 hash tag
-1 #obtuse
It's turtles all the way down. The same structure (pre-processing, routing, execution, post-processing) can occur on every level down the rabbit hole. Essentially, it's also how the reverse proxy works and how the WSGI server works and how your app works and so on.
There's nothing there? How about post some source code?
&gt; Why would you want to avoid exception handling in python? Then why do dictionaries have the get() method (which includes a default value if the key does not exist) or has_key method? You could always handle the missing-key case with exceptions. Also, if you have to check a couple of variables, the whole exception syntax takes up a lot of code lines. You have 4 lines to basically say 'if you can't make sense of it, make it None'. 
Unix Sort uses an External R-Way merge sorting. This says why it is faster :)
code?
It's [broken](http://bugs.python.org/issue11614) in Python 3.2. But it'll be fixed in the next release, and [new and improved!](http://hg.python.org/cpython/diff/44fd95cead7b/Tools/freeze/flag.py)
This looks pretty good. I too balked at all the dependencies to get django-celery up and running. It just seemed like a complicated solution to a simple problem.
Yeah, I'd be interested, assuming SDL 1.3 is the release with proper hardware rendering. pygame has been stale for years and hasn't kept pace with the capabilities of the machines it runs on. pyglet, although starting promisingly, seems abandoned and comes with some dubious decisions regarding having no game loop, as well as getting really quite fiddly when you want to start doing anything complex with the sprites. It'll only be of interest to me if it's not burdened with lots of 3rd party dependencies, if I can render a 2D sprite using full hardware acceleration with one call, and if you make sure that you don't abandon all the non-graphical things - good audio comes to mind.
Databases usually do more work than Unix sort would do. I'd expect that to be much slower than sort with appropriate memory (i.e., with -S 50% or the likes)
Nice Pratchett expression ;) I am not sure to understand your point though: of course every level has/can have the same pattern, but if you delegate all the checking-converting work to the proxy, you don't have to do it again in your app, and it becomes a collection of callables that are just building responses. e.g. the usual "I am going to return a 400 in case the request is wrong" piece of code, is just moved from your code to a DSL. So, not a big change, just a reorganization
I believe *R* is fixed at 16 in the UNIX implementations (in coreutils) I've seen, FYI. /* During the merge phase, the number of files to merge at once. */ #define NMERGE_DEFAULT 16
Thinking about the problem last night, I realized that making it work for fractions in general would be hard, since there are some phrases that are ambiguous. For example, "one hundred and four thousandths" could be interpreted as either 100.004 (100 + 4/1000) or .104 (104/1000). I don't think this problem exists as long as the denominator of the fraction part is less than 100, since then the numerator cannot contain the word "and".
So... you used a bunch of libraries and frameworks exactly as they were intended to be used?
Thanks for the info. Any idea why 16?
`lxml.html` makes this pretty easy, at least the easy parts. The hard part is that this isn't very structured input. import lxml.html h = lxml.html.parse(open("yourfile.html")) terms = h.xpath(""//br/following-sibling::strong[1]/text()") 
Here is a patch to make it user-modifiable via the command line: http://www.mail-archive.com/bug-coreutils@gnu.org/msg12763.html The coreutils maintainers saw that it was useful to adjust this number to suit your filesystem, architecture, and the nature of the file you are sorting. How was the original figure of 16 arrived at? No idea! Probably just seemed like a reasonable tradeoff at the time.
In proper English, "and" does not appear anywhere in a number except as a verbal separator, such as between whole numbers and decimal/fractional parts. I can't imagine that whatever the OP has in mind could realistically constrain to proper English, though.
The usefulness to amateurs, part-time programmers, or others just learning python. I think it's often important to program for the guy that's going to end up maintaining your code next year. And sometimes in my shop, for some parts of our code base, it may be a completely new python programmer.
I prefer alignment - makes it easy to see what the code is doing at a glance. The only downside that I see is that global search &amp; replaces can mess up the alignment. But a bit of extra work on changes in order to improve readability is fine for me.
i'd like to see proof of that. only because I always see it said, but no one can point to a compelling example. the examples I have seen lead me to believe that at most they are equally flexible. 
Watch out, you'll upset mdipierro.
Awesome, thanks!
I should write a player that slowly oscillates between several strategies, analyzing its own past actions the way the bot in the flash game did to me.
Ok, you looks proud of your code. You are looking for testers, but i haven't seen something to test ? Maybe you can use trial for your first test and get here later to show something.
or to get out of jams
This is completely meaningless without context.
I submitted Project_X2. Let's see how it goes. 
How do you determine what is "proper English"? Is "a hundred and four and five tenths" improper?
Somewhat similar to Evite's Nudge project: https://github.com/evite/nudge
What specifically don't you like about it?
As others have mentioned, I think [WebFaction](http://www.webfaction.com) and [VPS.net](http://www.vps.net) are good choices. Another option to consider is [Amazon AWS Free Usage Tier](http://aws.amazon.com/free/) (note, it's only free for the first year).
har har ... stop bitching and join my pension scheme :D
ill think about it ... if i dont get 10K users in 12 months, ill consider the project a fail and open source it :)
you need not join ... your attitude suggests you dont click on adverts :P
"and" designates a decimal. Saying "one hundred and four" to mean 104 is incorrect. It should be "one hundred four"
hey there is very few full blown twisted apps out there ... i rewrote the thing twice before i got to this stage :)
 def toint(value, default=None): if value.isdigit(): return int(value) return default 
You've said this at least a couple times, yet you haven't mentioned anything specific you don't like about it. Like any framework, web2py may not be to everyone's taste, but given its ever increasing popularity, surely it's reasonable advice to suggest that the OP at least try it.
Errr... what's up with the downvotes in this thread? Have voted everything up, as I don't see why this discussion should be downvoted.
I bet you can sort it with GNU sort faster than you can even load it into SQLite, let alone get it back out sorted. Databases are handy, but they're slow.
Alright
This submission is "a fail."
I bet you're right. We really have three different types of sorts we're talking about, and each has their own pros/cons: * The database (merge sort) * the "sort" command (introsort -- a quicksort/heapsort), * mergesort OP wrote would (merge sort) Big-O-wise, they perform the same amount of time (n log n). In practice, however, the times will differ. The interesting part is this case, when the amount of data exceeds the amount of memory available on the system. Mergesort will win in a distributed environment (multiple cores, or even multiple machines). The "sort" command will win if all data will fit in main memory. The database will win if the data is already in the database, already indexed, and the results will fit in main memory. I personally learn by doing, however, and still think he should do both to know first-hand what the results will be.
Are the titles ["One Hundred and One Dalmatians"](http://en.wikipedia.org/wiki/One_Hundred_and_One_Dalmatians) and ["One Thousand and One Nights"](http://en.wikipedia.org/wiki/One_thousand_and_one_nights) improper?
Ah, looking into it further the determining factor is whether you're referring to numbers in American or British vernacular. From [Wikipedia](http://en.wikipedia.org/wiki/English_numerals): &gt;Note that in American English, many students are taught not to use the word and anywhere in the whole part of a number, so it is not used before the tens and ones. It is instead used as a verbal delimiter when dealing with compound numbers. Thus, instead of "three hundred and seventy-three", one would say "three hundred seventy-three". For details, see American and British English differences. 999,000: &gt;nine hundred and ninety-nine thousand (British English) &gt;nine hundred ninety-nine thousand (American English)
That's my thinking as well, I'll be sure to post here as soon as I have something worthy of showing off.
I did, I like some of the decisions they made but not others, also it depends on pyglet and the python version seems to be stagnating along with pyglet.
You call a function `layers` on line 10: for x, y in layers(a, b): Unlike `zip`, it is not a global built-in function, so it has to be defined or imported into your script. 
doh! thanks! I didn't realize zip was a function
Not sure why you're being downvoted - haters gotta hate I guess. I've done a bit of work with sqlite and Python, and if you take advantage of delayed inserts you can pretty much write the db as fast as the system lets you read the input file. Where it'll be interesting is how quick sqlite can sort the db when you do the SELECT ... ORDER BY, and whether or not other methods (e.g. piping to the 'sort' command) are either better performing, or can start processing the sorting while the stream is input instead of waiting 'til the end. For anyone who hasn't tried this yet, one method I've had great success with is to implement a collections.MutableSequence instance which is passed a sqlite connection object on initialisation, and the __setitem__ method is overridden to perform an self.conn.executemany() every 1000 entries into its internal list - if this succeeds then clear the list (so we deal with inputs larger than system memory) This instance can then be used like any other iterable, so the rest of the code doesn't even need to give a crap about sqlite (just read from the input file, append to the instance object) 
What did you think it was? I mean, there's just no such thing as layers at all, so it actually doesn't even matter what you thought zip was.
Hey, where's your ["off topic" downvote](http://www.reddit.com/r/Python/comments/hurna/django_vs_pyramid_new_guy_asking_extremely_new/c1yot1s) for the Flask mention? ;-)
u mad
I would just use a radix sort, it would sort as you read in the file, easy. At that point you would be 100% disk bound. 
Well, something throws that ValueException in response to the failure of the exact same check, presumably.
Do people at /r/python really need to learn python in 10 minutes?
It's very workable if your editor supports it, e.g. vim with the [Align plugin](http://www.vim.org/scripts/script.php?script_id=294). Otherwise I avoid it as well.
This is retarded. There are plenty of other tutorials that can teach you python in under eight minutes, so don't waste your time.
Why did i just finish a bachelors degree in compSci when i can learn python in 10 minutes. 
But the int constructor immediately goes to work converting the string. It raises ValueError mid-conversion, as opposed to a 2 pass 'check first, then convert'. Let's look at the best-case scenario that doesn't raise an exception. I'll use the simple isdigit test instead of one that strips whitespace and handles negatives: &gt;&gt;&gt; from timeit import timeit &gt;&gt;&gt; s = str(12345) &gt;&gt;&gt; t1 = timeit("if s.isdigit(): int(s)","from __main__ import s", number=1&lt;&lt;24) &gt;&gt;&gt; t2 = timeit("int(s)","from __main__ import s", number=1&lt;&lt;24) &gt;&gt;&gt; t1 / t2 1.1260275289576362 So testing first increased the time by 12.6% on my system. I did it again and got 13.1%. 
It would be interesting to rewrite the recipes using the new appropriate modules and statements and see how much smaller they all become.
Good point. So the question becomes how the overhed of a redundant check stacks up against handling an exception being thrown. But that's hardly a contest. It's resonable to assume for most applications that errors are the exceptional, not common case (otherwise something else is definitely wrong somewhere), and it may very well be cheaper even if that wasn't the case.
if you are in UK ... i promise youll get closer to getting laid then ever before :D
It's one of many built-in functions. Functions are not the only built-in things, there's a lot more e.g. anything that comes with the `builtins` module: * http://docs.python.org/dev/library/functions.html * http://www.markus-gattol.name/ws/python.html#builtins
Can....can we make this a loop? Include Python in a C++ app, then include that C++ in a Python app, then include that Python in a C++ app, then include that C++ in the original Python? Because I really want that to happen. I really, really do.
Compsci is more than just learning mainly syntax. You now know how to actually use all this. 
sidenote - pypy does the memory saving even without slots
there you go ... no need for spiked! on a serious side, service is UK specific. :)
I tested it on a ~200mb file of integers separated by newlines. Sort took 300 seconds, and sqlite3 took longer (Cant remember the exact time). The delay was actually inserting the entries into the database (and the database file was much larger than the input). The order by operation in sqlite was pretty much instant though, which was cool.
&gt;The direct corollary of this is that when you are considering using slots you should measure the memory savings you get with and without them; if it is not significant (to you), you should not use slots because slots have various odd side effects and drawbacks. Another corollary is that if the memory savings *is* signifcant, you should first consider a different object design, in particular the flyweight pattern.
It can be downscaled to a single file. That's flexible. It also makes very few assumptions about the technologies you want to use. Django is better when you can stay within its components, but if you want to use something that's not built-in, it won't come with the same pixie dust.
Pyramid's mostly the same, FTR (single file apps).
in python the flyweight looks like an antipattern to me. when it comes to python and it doesn't solve the size of an object issue unlike java, cpthon objects are a hashmap, not a set of fields in something like a "struct" slots make that transformation, same goes fore pypy's internal mapdict (which is used for __dict__ of objects)
http://norvig.com/21-days.html
Because the markup fucked it up, this mapdict optimization occurs on ``__dict__``, not all ``dicts``.
&gt;it doesn't solve the size of an object issue If I understand the flyweight pattern, then it reduces the number of objects, thus making the size per object less important. In the example shown on Stack Overflow, it reduces the number of objects to one. If that is not actually a flyweight pattern, please comment. This is from [StackOverflow](http://stackoverflow.com/questions/472000/python-slots): &gt;The time when you think you might need __slots__, you actually want to use Lightweght or Flyweight design patterns. These are cases when you no longer want to use purely Python objects. Instead, you want a Python object-like wrapper around an array, struct or numpy array. class Flyweight( object ): def get( self, theData, index ): return theData[index] def set( self, theData, index, value ): theData[index]= value 
its simple "social networking" site ... follow, upboat/like, msg, feed, friends. If you can be bothered register a fake account and see. ;) its nowhere close to beeing feature complete, but its usable, so i decided to make it live.
I've been writing small to medium size python projects for around 6 years now and I haven't been able to find something that served me better than SciTE. Take a look at [Editra](http://editra.org/). It's small and extensible through plug-ins. 
ok, [pyramid has that](http://docs.pylonsproject.org/projects/pyramid/1.0/narr/firstapp.html#hello-world-goodbye-world), so I'm still not convinced. Here's how you can prove it to me. Since bfg/pyramid has been made to do request dispatch in the [style of flask](http://bfg.repoze.org/videos#groundhog1), If someone could make a flask application that does [traversal style request dispatch](http://docs.pylonsproject.org/projects/pyramid/1.0/narr/traversal.html), I might be convinced. Your move holy man. 
I thought the old "Learn {} in 24 Hours" books were amusing, but 10 minutes? Why not make it 8 as DrHenryPym suggests? Or lets learn by download: import this import keyword for kw in keyword.kwlist: help(kw) import builtins for bi in dir(builtins): if bi[0] != '_': help(bi) Subscribe now and we'll also include a tutorial on the standard library. You'll be amazed at how fast it scrolls on your screen: from importlib import import_module modules = [ "string", "re", "struct", "codecs", "datetime", "collections", "heapq", "array", "queue", "weakref", "types", "copy", "math", "decimal", "fractions", "random", "itertools", "functools", "operator", "os.path", "stat", "tempfile", "glob", "fnmatch", "shutil", "pickle", "sqlite3", "zlib", "csv", "hashlib", "configparser", "argparse", "os", "io", "time", "logging", "platform", "errno", "ctypes", "select", "threading", "multiprocessing", "concurrent.futures", "mmap", "subprocess", "socket", "asyncore", "asynchat", "email", "json", "mimetypes", "base64", "html.parser", "xml.dom", "xml.etree.ElementTree", "cgi", "wsgiref", "urllib.request", "urllib.response", "urllib.parse", "audioop", "aifc", "wave", "imghdr", "sndhdr", "gettext", "locale", "cmd", "shlex", "tkinter", "tkinter.ttk", "tkinter.tix", "pydoc", "doctest", "unittest", "pdb", "timeit", "trace", "sys", "warnings", "contextlib", "abc", "atexit", "gc", "inspect", "site", "distutils", "imp", "zipimport", "pkgutil", "importlib", "dis", "winreg", "winsound", "pwd", "spwd", "grp", "resource", "syslog", "ossaudiodev"] for mn in modules: try: m = import_module(mn) for on in dir(m): if on[0] != '_': help(mn + '.' + on) except ImportError: pass *I know kung fu*. All kidding aside, Python is an easy language to learn, but your comp-sci degree covered algorithms, data structures, software engineering, compiler design, artificial intelligence, etc, which should take at least 2 hours after the 10 minutes it takes to learn Python. ;-) 
python still has one mapping per object, which is an allocated hashmap in a sense `__slots__` is a flyweight pattern already, cause it replaces dict accesses by field lockups then all object share the same layout, instead each having a `__dict__` and dynamic layout + overallocation also if you have to pass the index as argument, something is wrong already, and you shouldn’t have that object in the first place
Classic: "S.Lott" says there's no use for `__slots__`.
&gt; Include Python in a C++ app, then include that C++ in a Python app This much, I do on a very frequent basis. &gt; then include that Python in a C++ app, o_O &gt; then include that C++ in the original Python Damn you, but I think you've just decided what I'll be playing with this weekend. Thanks! :D
That is what they've been doing.
The Wikipedia [example](http://en.wikipedia.org/wiki/Flyweight_pattern) has a CoffeeFlavorFactory that contains a central list of CoffeeFlavor objects. TestFlyWeight objects access this common pool of objects. In the spirit of this pattern, I think S.Lott's Flyweight object should have an index attribute. Then if you're creating thousands of these Flyweight objects, it will save memory to use `__slots__ = ["index"]`. I tested with `2**20` single-attribute objects, and the set with `__slots__` used only about 20% as much memory. 
Depends on how complicated you want it, Celery was made with the idea to scale to thousands of tasks per minute. It has got a lot better with support for many brokers, including ghetto broker (db storage). Really Celery should have its AMQP bindings as optional instead of a requirement. I don't think ztask would work in my environment, but it would be highly considered for a new project, I love how lightweight 0MQ is, anything that has [bash bindings](http://www.zeromq.org/bindings:bash) scores points from me.
My attitude ??? look at yourself kid ! You are 16, you think you are the next web billionaire or what ? You think you will build a network with beta tester. lol You failed 
I think it's a Hawking expression really.
I notice they have it listed in the Europython schedule after the sprints on Saturday. Should that be updated if the time is changing? I imagine a few folks won't see this thread and will probably go by what they see on the schedule. We might also lose some people that will leave friday as they won't be participating in the sprints.
that's exactly what i did
multiprocessing.Pool() defaults to multiproccessing.cpu_count()
Boost.Python is great. I use it every day and it really is a wonderfully useful and well-written library. My main gripe is that if you want to extend its semantics in any non-trivial way the documentation is sorely lacking. The code is standard Boost style, meaning if you aren't a bona fide C++ expert then expect do a lot of swearing and crying. I've worked with it long enough that I have a fairly comprehensive understanding of how it works under the hood, but I can definitely empathize with beginners when they look at it and are just like "WTF?". Hopefully this series will help them out.
I think it's less a tutorial and more of a whirlwind tour. Admittedly, I picked up a couple of things I wasn't aware of.
har har :D its a joke dude ... i am not 16 for a while now ... truth is i wanted to build distributed application on a top of twisted ... for all i care it could have been anything, it just turn out to be upboaty thing lighten up ... :D
Thanks.
My list of favorites may seem weird to some but its the changes that have been the most useful to me so far.
Just what I was thinking. Syntax is the easiest thing to learn. Learning common functions/procedures and common idioms is slightly harder, but not by much -- it just takes time and practice. The part that takes a long time is practice, failure, and more practice to overcome failure. And it takes a while to become familiar with the various libraries/modules (or whatever a language calls them) that abstract solutions to common problems.
Ah, fair enough. I was under the impression that Pyramid was more like Pylons (which was neat, but usually came with quite a bit of overhead). Depending on what you mean by "traversal style request" (Flask has no concept of "resources") I guess Modules might be what you're looking for. In any case, it's primarily a thin wrapper around Werkzeug. The flexibility goes hand in hand with a very minimalistic feature set (which I don't consider a bad thing).
sorry still not convinced. :) traversal is pretty powerful and flexible, combine that with view predicates and routes and you have a lot of options for routing requests to views, with the added benefit of having a resource evaluated to determine access to the view and handed to the view via the context parameter. this resource could represent anything, a row in the database, a bundle of services or something else. maybe that is possible in flask through extensions, but no one has bothered. anyway if we define pyramid and flask as ways to route an incoming request to a callable that returns a response, pyramid is more flexible in my opinion. 
Yeah. That is terrible. It took me a while even after reading the title of this post.
Please post your results.
it was in a code snippet example somewhere online, with the explanation hidden below, I thought zip was an arbitrary name, so I thought it could be anything, such as layers, I understand now, and it's awesome how many folks responded!
Because it doesn't have them? 
I see you're not into the whole "actually reading the blog post before posting a sarcastic comment on it" thing.
Probably because you haven't actually linked to a blog post.
Weird, when I submit it I do submit the URL but it becomes a "self.Python" post with no link. Oh well, I'll stick with Hacker News. If anyone's interested, here's the blog post: http://blog.garlicsim.org/post/6388800336/why-dont-people-use-enum-in-python
Not true. Sometimes I *do* read the blog post as well as posting a sarcastic comment.
Counter class is a part of collections module. So you either explicitly do: import collections c = collections.Counter() or this: from collections import Counter c = Counter() You can also do: from collections import * instead of from collections import foo from collections import bar but this is considered ugly because it pollutes the namespace. It's a pitfall you should know about. Also, make sure you read the docs for your installed python version (python 2.x and python 3.x are incompatible). collections module from python 2.6 doesn't seem to have Counter
A joy in Haskell: import Data.Set import Prelude hiding (map) powerset s | s == empty = singleton empty | otherwise = map (insert x) pxs `union` pxs where (x, xs) = deleteFindMin s pxs = powerset xs Oddly, Python's sets are not hashable, so you can't have a set of sets??? &gt;&gt;&gt; set([ set([1,2,3]), set([4,5,6]) ]) Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unhashable type: 'set'
Surely the phrase *"Python doesn’t provide a built-in enum type"* is more than enough information to have answered the question. Python programmers don't use something that doesn't exist, nor are they likely to standardise upon some random snippet some guy found. Enums are a fluffy concept anyway. The term is short for 'enumeration' and yet most of the time when you use them you don't even care about the actual numbers involved, so they're completely misnamed. Usually what you really want are distinct symbols, like 'True' and 'False' in Python. To achieve this you can just create a new object for each symbol: Very_True = object() Quite_True = object() You can now set some other variable equal to either of those, compare it against those, and compare them against each other, with the same outcome you'd expect from an enum. This works because by default object identity is what's compared. (http://docs.python.org/reference/datamodel.html#object.__cmp__) Oh, and if you do care about the numbers, that's easy to do too: a, b, c, d = range(4)
&gt; Perhaps a large portion of Python programmers are ignorant about enums I highly doubt that. I bet more than 80% of Python programmers have also learned Java/C/somelanguagewithenums. &gt; Or perhaps people just don’t really care about making their code elegant? You must be new to Python. Of course Pythonistas care about elegant code! You make vague reference to a possible Django scenario where enums would be cleaner, but I'm not really convinced. Can you come up with a concrete code example where enums are the best choice in Python? IMHO, "enums" are handy for type safety. Haskell's ADTs are a great type-safe way of cleanly representing a limited set of specific choices. Contrast with kylotan's suggestion to simply use `object()` to create a unique reference. No type safety, but that's because types aren't really a big deal in idiomatic Python.
Fantastic article.
I am personally a Pyramid fan, I use it all work on a daily basis and absolutely love how robust it is. That being said, I wouldn't recommend Pyramid or Django knowing your current skill set, I would recommend learning a micro-framework such as [Flask](http://flask.pocoo.org/) or [CherryPy](http://www.cherrypy.org/) because I think you'll end up learning and appreciating how Python + Web work together as opposed to having a framework make every decision before you behind the scenes. After you get comfortable using a micro-framework then I would suggest trying out Django, and once you get get comfortable using that then you could step up to a framework that is more low level like Pyramid. Hope this helps!
TIL
Maybe because we don't need it. Any module can do the job.
Learn python in 1 second! &gt;import everything Done. If only I could load understanding in to my brain like python loads modules in to code.
Yay! Let me know how it goes. I doubt I would have had the expertise to do it without a lot of research. Cheers!