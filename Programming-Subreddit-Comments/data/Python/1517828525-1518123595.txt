Large infrastructure project. Cloud. Micro-services. A whole bunch of buzzwords. Think: something like home-made Ansible.
Yup! The same one I started with https://automatetheboringstuff.com 
/r/LearnPython
Tldr; if you don't like it, don't use it? But what sorts of features **would** make you happy? &gt;None of that worth the downsides of having to make a change to existing working code. I wouldn't suggest changing existing code unnecessarily, but that would be true for any new feature. &gt; Named tuples already have an OK repr, I don't need more than that. Named tuples already have equality and order. Right, the comparison to dataclasses is that you also get many of the niceties of namedtuples but for classes that can define extra methods or be mutated &gt; I don't have classes only for the sake of having a few properties. Why would I need something like that? Objects are almost never a good way to store information (lists, queues, trees etc are). If I just need a bunch of values together, the choice of data-structure would be motivated by the way it is supposed to be used, not by how many lines of code it takes to write it. All of the structures you mention are/can be comprised of objects. Minimally I'd say, if you're just storing all your info into assumed structured dictionaries (useling dicts as a substitute for classes) and lists, your code is likely doing more complicated branching than it needs to (not to imply you are). If you're using namedtuples, then you clearly get it; but if you accept the benefits of namedtuples, then dataclasses are honestly very similar (but more flexible) PS. Class serialization in Python is not just not easy, it is in principle impossible, as is the case with any object-oriented language. It works 90%, but it can never really work 100%. This is because the identity of objects is ensured by the language's runtime. Once the runtime is gone, there is no way to maintain the invariant that every object has a unique identity. But you obviously never tried, so my argument will be wasted here. No need to be aggressive, just trying to explain how they can be useful. I certainly have implemented object serialization (using attrs to get it automatically most of the time, dataclasses' inspiration). The identities of objects are largely unimportant most of the time. For any code I can recall writing, the data a class instance holds is the only important thing (including recursively nested serializable objects). Generally, the only place where that is not true is when you hold inherently non serializable things like database connections, which are trivial to lazily generate on demand
That's right. Programming is similar to art. There's only a few rules and so much freedom, you should learn how to solve problems instead of learning how to solve a particular problem.
Yeah, I meant to say statically typed. Sorry to upset you.
On the subject of f-strings. First, here's an example: from string import Template import sys def f(s): frame = sys._getframe(1) v = dict(frame.f_locals) v.update(frame.f_globals) return Template(s).substitute(**v) &gt;&gt;&gt; x = 1 &gt;&gt;&gt; y = 'foo' &gt;&gt;&gt; f('$y = $x') 'foo = 1' This is the simplified version of the "killer-feature". It was possible to do this since before my time. But... unless as an April First joke nobody really did this. #Why? Because this is outright retarded. Why do you need a new way to interpolate variables into strings when you already have three ways in standard library alone, plus all sorts of Jinjas and friends... #Why this particular method sucks: 1. Internationalization. 2. Backwards compatibility. 3. What happens if you `r"foo" + f"bar"` or any other combination. And why do you even need to be bothered to think about such things? #Why it was really implemented. Well... it appears that Python core developers eat from the same plate with C# core developers... Remember, recently C# also added this garbage to the language? But, why would C# do this? Well... C# is advertised by Microsoft as "multiparadigm" language. Microsoft wants to push it into every hole regardless of that hole's shape. So, C# core devs look at "what's trending in other languages" and copy that into C#. This is not the first time it happened. This time, C# borrowed from Perl / PHP. And, since Python is a new Microsoft's pet, it also got this killer-feature. Lo and behold, new multiparadigm language soon to join the happy .NET family!
Your post would probably help in /r/learnpython better.
u/fiddle_n gave some great feedback however, I'd like to add my personal opinion. First of all for u/fiddle_n: for x in ops: if x in ops: print(f'{x}: {ops[x]}') seems a bit redundant though as there wont be any other elements in ops than the ones the loop iterates over. Secondly, in the class example you gave, the __init__'s arguments (other than the inv list and the hp value) aren't assigned to the classes attributes. Back to your code. I totally agree to everything u/fiddle_n said. Additionally op4 seems very prone to infinite loops. Try to avoid functions calling themselves under all circumstances except for recursion! (but thats a wholly different topic) My personal piece of advice would be to split the whole program into several files to retain some means of readability and order and just add some imports. I get the impression you're a pretty novice coder as most of the code has been written in a very linear fashion. Lots of hardcoded stuff and almost no modularity and therefore no re-usability. Try to think more abstract. All in all not too shabby for 3 years of not coding. Keep it up :)
I am obviously not programming on a phone. I’m trying to use this website ‘grasp code quickly’ which looks like exactly the sort of problems that are solvable in your head thus would be interesting to do on my commute
&gt; if you don't like it, don't use it? OP asked where would I use it. My answer was: "nowhere". I think, I answered OP's question. &gt; But what sorts of features would make you happy? 1. Python sucks in utilizing parallelism of hardware. `asyncio` is a joke as well as "threads" and "multiprocessing". I would like to see something done about this aspect. 2. Python's objects are ridiculous. Whoever wrote the CPython implementation must have had dissociative personality disorder, and did it in several incompatible ways, each of them suck, but in a different way. 3. I would love to see a lot of features removed. Beside the obvious `syncio` garbage, threads and multiprocessing library. For example, meta-classes. All kinds of prefixes for strings. Everything that makes the language less regular and more difficult to work with in a general way. 4. I would love to see Unicode strings gone. I would much prefer Go's approach to this problem. 5. I would love to see a cleanup of C API. It's too bloated and is kind of a moving target. Besides, embedding Python kind of sucks, but that's a separate story. 6. I would love to see Python compile with GNU compilers, including on Windows. 7. I would love to see sane date/time API in standard library. 8. I would love it if standard library would sort out what naming convention it wants to follow and use just that. 9. Man... I can go on forever here, this is just the tip of the iceberg. But I'll just drawn everyone in my complaints. &gt; All of the structures you mention are/can be comprised of objects. You can also make data structures from sticks and stones. (See https://xkcd.com/505/ ). Is this a good way to make them is a whole separate question. Python is a ridiculous language which forces you to use objects to implement things which are, in principle, simpler than objects. But, if you are tired of this nonsense, you can always go back to C and implement data structures the way you want. I'm not the only person who does this (See: http://kmike.ru/python-data-structures/ ). If you look at almost any serious data-structure implemented for Python, you'd have C implementation and Python container interface. Why? -- Because it doesn't make sense to make data-structures from objects. It's a wrong tool. &gt; I certainly have implemented object serialization There's a difference between doing something somehow, and doing it well. This is why I said, that it may be made to work 90% of the time, but not 100% of the time. &gt; The identities of objects are largely unimportant most of the time. Then you don't need objects most of the time. Identity is the only thing that distinguishes object from a structure. &gt; serializable objects Santa Claus is more real than this.
Looks to me like the primary speed up here isn’t the reduced memory copies but rather the fact that the read/chunk logic is done by an optimized handler outside of your Python function. Still I like your clean example code for how to send files. Very nice. 
It's the x64 installer that came from python.org (https://www.python.org/downloads/windows/)
What are the major differences?
Ah, I misunderstood. I'm glad you got things figured out in the end. Cheers
Great examples! Thank you for creating this and answering. Cheers.
Online money making has never been so easy. You just need to have your written plan of how much money you want to make from an online platform and what is the timeline you have. The major ways to make money online are Affiliate Marketing, Youtube marketing, Social media, E-Bay Dropshipping, Kindle E-Book, Become a Tester, Become a Verifier. You can just start making $30 to $50 / day from the first week and taking it up to $1000 / week in few weeks time. If you work consistently on these methods you are well on your way to make hundreds of thousands in a year. Try this tested verified methods of making money online. https://www.udemy.com/earn-good-passive-income-quick-money-making-models-2018/?couponCode=EARNCASHNOW, It has 100% money back in 30 days if you don't like the methods and if these don't work for you! why not try it for only $9.99
CPython hasn't used any form of MSI for years, several different versions of exe are provided. I believe that the web based installer is the most popular.
Most reddit power users install reddit enhancement suite to give it extra features. Its like using punch cards because its less distracting. Many Python develpers would say PyCharm is simple. I didn't need to read a book. I just started using it. Its going to do a lot of things your text editor just won't do.
I'd argue that having your function work "the same way" on lists and generators is basically impossible - `getThirdElement(a_generator)` the way it's currently defined will exhaust the generator, and there is absolutely no way of defining it without at least exhausting the first three elements of the generator. This means that your function may or may not mutate its argument depending on what was passed in. That's not good. As for your `getZeroesListOfEqualSize` function, it's definitely _not_ the same function as `getZeroesListOfSize(n)`. Also, PEP8 says you should use `snake_case` names for functions.
For your first point, that's certainly true, but there are cases where I might have a generator or a list, and I only care about the third element. For example, if I want the third prime number between 1000 and 10000, I could use get_third_element(get_all_prime_numbers(1000,10000)) and it wouldn't matter whether get_all_prime_numbers returns a list or a generator, nor would it matter whether the generator is messed up afterwards. However, I understand what you're saying. Would it be better to have two functions, get_third_element_from_list and get_third_element_from_generator, or to just force the user to cast their generator to a list before they call the method? As for the second point, I agree, in my example those should be different methods. I was just trying to think of a simple example, though; there are lots of cases where I have a function that can work with one type of input just as well as another. A slightly more useful example might be get_line, which can take either two coordinates and return the formula of a line from that, or can take a slope and a y-intercept, and return the formula of a line from that. Should I have get_line_from_points and get_line_from_slope_and_y_intercept, or combine the methods? As for the snake case, I don't know how I missed that, thank you. For some reason I was certain that PEP8 recommends camel casing.
For your first example, this might make sense, but it really depends on what usage patterns you're expecting. It might be easier to come to a good design if you actually explain what's happening. As for your second example, I'd implement it as a class with two constructors - for example class Line: def __init__(self, slope, intercept): self.slope = slope self.intercept = intercept @classmethod def from_points(cls, x1, y1, x2, y2): slope = (y2 - y1) / (x2 - x1) intercept = y1 - x1 * slope return cls(slope, intercept) def eval_at(self, x): return self.slope * x + self.intercept def __eq__(self, other): if not isinstance(other, Line): return False return ( self.slope == other.slope and self.intercept == other.intercept ) def __repr__(self): return f'Line(slope={self.slope}, intercept={self.intercept})' __str__ = __repr__ line1 = Line(slope=5, intercept=3) line2 = Line.from_points( 1, line1.eval_at(1), 2, line1.eval_at(2) ) print(line1, line2, line1 == line2)
Because you never work on serious programs with real-world requirements... it doesn't mean that everyone else is like that. yes, internationalization is important. The most popular language in the world is Mandarin, for example. Second being Spanish. Most people in the world don't speak English. Again, you live in a bubble, where updating to a new version of runtime is not a problem. People living in real world, who come to depend on some software have very different perspective on that. Suppose, your user base are scientists, who have software written for Python 2.7. You want to give them a new program, perhaps even unrelated to the software they already have. Two things will happen: 1. Your tech-support will take a big hit. 2. In the end, nobody will use your program. Lots of time and effort goes down the drain. As to my "crazy" conspiracy theories: well, I'll just leave this here: https://mail.python.org/pipermail/python-dev/2018-January/152029.html
What will Windows users do? Most of them aren't used to building from source.
&gt; The most popular language in the world is Mandarin, for example No it isn't. It's the one with the most native speakers. https://en.wikipedia.org/wiki/List_of_languages_by_number_of_native_speakers If you count speakers total English is number 2 and not far off from Mandarin: https://en.wikipedia.org/wiki/List_of_languages_by_total_number_of_speakers &gt; Again, you live in a bubble, where updating to a new version of runtime is not a problem. Funny. Seriously though, if you need py2 then just don't use f-strings. If you target 3.6+ it's fine. You have to be able to improve stuff. &gt; I'll leave this here Please do leave it.
Oh, I like that Line example! For the first part, it was more of a "for future reference" case, so I'll have to decide how to do it on future projects. Thank you for the advice!
Rip everyone's karma
I also really like it, though we should note it even though it is maintained, there hasn't been a push to pypi since 2015!
Sorry we haven't solved the problem of accessing your project code just by knowing your reddit username, reading it and understanding what you really want to do yet. Maybe one day it will be possible.
&gt; No it isn't. Yes, it is. This is exactly what your link says. &gt; just don't use f-strings. Dude, can you read? Does it look like I'm using them? The problem is with you / people like you, who will put this garbage in PyPI / GitHub, and then I will have to write all kinds of workarounds to make your garbage work. Why? -- Because, in general, programmers don't have time to read through the code of the package they are using. At best, they will read the documentation. The problems usually surface later on, when it's too late to give up on any given piece of the mess.
I feel like django-channels needs more, non-trivial examples.
So you’re upset that you can’t use the free stuff people make? Are you also upset when people use another language than Python so you can’t use it?
Bruh, is this guy seriously comparing the dictionary lines with plaintext? That's a pretty shitty simulation. Even ignoring that dicts and bruteforce aren't the same thing, I can only assume he's meaning to demonstrate something like hash cracking, but he doesn't bother to do any hashing in his program. If you have the plaintext, there's no need to bruteforce OR dict because you can just *read the freaking plaintext.*
&gt; Most of them aren't used to building from source. Try learning?
-20 just because you're still working on 2.7, wtf?
If you don’t want to learn a new framework to do a specific task in a new language, you will not have much luck as a programmer. GUIs are not completely straightforward to program, so if you don’t want to use the tools a language provides, don’t use that language. You may have better luck with something like Electron if you have web dev experience. 
[I found this in the search results you included in your comment. ](https://github.com/ChrisKnott/Eel) Seems like an easy way to do exactly what you're asking. 
I'm genuinely confused. Is this a joke?
Can you assholes tell me exactly what this subreddit is for? Is this a python subreddit? Fuck off
I have done that. This is my final code
It can be done, but there is no "easy" way, not any easier than learning TkInter. If you dont like layout "by hand" you can go wirh Qt instead, then you at least have a WYSIWYG layout tool (Qt studio or something) What is the app supposed to do?
This community is not for questions like this. They will only be entertained in the other community. 
Finishing up learning Flask. Plan to learn Django next. Then back to Anaconda with my Machine learning self-study :)
a coinbase terminal (curses) client. enjoy the laughters
Where are the sub rules so I can see what exactly this sub is for? I would love to know why I can’t ask python questions in a python reddit. You’re welcome.
Read the beginning of the sidebar for the sub “news about the dynamic, interpreted, interactive, object-oriented, extensible programming language Python” It also says if you have a question please consider /r/learnpython or the discord server
Here's a sneak peek of /r/learnpython using the [top posts](https://np.reddit.com/r/learnpython/top/?sort=top&amp;t=year) of the year! \#1: [My new book, "Cracking Codes with Python" is now available and free to read online!](https://np.reddit.com/r/learnpython/comments/7sigre/my_new_book_cracking_codes_with_python_is_now/) \#2: [I'm releasing a free code for the "Automate the Boring Stuff with Python" Udemy course](https://np.reddit.com/r/learnpython/comments/7fxork/im_releasing_a_free_code_for_the_automate_the/) \#3: [90% Python in 90 minutes](https://np.reddit.com/r/learnpython/comments/661o5a/90_python_in_90_minutes/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
/r/learnpython It looks like you are running in the free tier, in this tier network access is restricted to a whitelist.
Why you guys don’t understand r/learnpython sucks is ok with me. I have read over the rules. Thank you and I swear to all higher powers i will never ask you a question again. God forbid i try to learn programming 
Programmers, unfortunately, tend to be antisocial and a bit rude. You will find comments like that in nearly every programming community you find. 
Starting point: accept nothing, treat everything as false. Then you find a paper, read the Title. If you think it might be onto something, then you read the Abstract. If you're still interested, look at the Figures. If you get passed that, look at the Discussion to see why they think it's important. If you get all the way through the discussion without laughing at them, read the Results. If you're a reviewer, you read the Methods.
Sorry about earlier. I actually have to head out now.
If you think we all have the same path in our life, you are wrong my friend. I don't need luck as a programmer, and i don't have to learn a new framework. Please learn to respect other's people rights to express themselves and be themselves.
All I’m saying is that making an HTML GUI for python code is just not a good way to program. You will inevitably run into a lot more problems than if you just picked a better combo. I’m not saying you can’t do it I’m just saying it would be really bad lol 
You have 3 values that you are trying to get (xyz, contours, and hierarchy) but findContours ([only returns 2: contours and hierarchy](https://docs.opencv.org/2.4/modules/imgproc/doc/structural_analysis_and_shape_descriptors.html?highlight=findcontours#findcontours). You need to remove the xyz part contours,hierarchy = cv2.findContours(thresh1.copy(),cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) And calculate it some other way if you need it. --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
I think your question is a .NET desktop application vs. a web application, right? Django is my first choice in most situations, but it still isn't the only way to build a website. In general, something like this does sound like it should be a web app. You instantly get multi-platform support since everything has a web browser, you can make updates to the application without having to distribute code to all the users, the heavy data traffic between the application and database can all happen in only one place, you don't have to support end users various package installation problems... There are just too many reasons to count to favor a web app over a desktop app. If you wanted to fit both of your options, you can build a web app in ASP.NET. It's not something I enjoy working with, and it keeps you pretty nailed down in a Windows development and hosting world, but it's a thing people do.
Yeah that was basically my question. As I was looking more into web apps, that option was looking more appealing. I just wanted to make sure what I wanted to do was possible before I got to far down that road.
Thank you... I'm familiar and NiFi is likely our plan B option. Just wanted to try to focus on something that's a bit lighter weight and all python if possible.
mp3 version is here: https://huffduffer.com/idahogray/456857
I'm learning and sharing my journey of Micropython. I spent the better part of my weekend making up an howto video (2nd in a row) so others wouldn't have as much pain as I did. If it's of interest: [Flashing Micropython Firmware](https://www.youtube.com/watch?v=8_kzeC4AP_M) and [Writing Application code to the Microcontroller](https://www.youtube.com/watch?v=ugpHuTGUuhs&amp;feature=youtu.be&amp;a=)
Pandas is definitely not a good solution for files that big. Have you considered using an actual database like PostgreSQL or maybe [ClickHouse](https://clickhouse.yandex/)?
Stop hamstringing their development workflow, ideally.
ok: https://github.com/Jwink3101/NBweb But again, this is BETA! It is not super refined and has some kludges that are there for now since I haven't had time to fix them.
This is a pretty solid solution for my issue. Thanks
Good article. This reminds of an interesting quirk that a student pointed out to me. If you try to extend a list in a tuple, you will get an error message *and* extend the tuple as intended. IOW it both mutates the tuple and complains that tuples are immutable. &gt;&gt;&gt; a = ('dogs', 'cats', [1, 2, 3]) &gt;&gt;&gt; a[2] += [4] Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: 'tuple' object does not support item assignment &gt;&gt;&gt; a ('dogs', 'cats', [1, 2, 3, 4]) 
You may be looking for something a bit more packaged, but dramatiq is a redis- or rabbitmq- backed python task queue with a lot simpler config than celery, with a simple but powerful middleware api including built-in integration with Prometheus and examples of how to use with Rollbar and raven/sentry. And the source code is extremely readable and well maintained. I suspect it's just part of the puzzle but may be useful to you.
Just try appJar + PyInstaller. Honestly, it doesn't get easier than that.
Have not used but one popular python tool for this scenario is [Dask](https://dask.pydata.org/en/latest/)
Depends on your organization. Python is a very versatile tool and comes with a lot of libraries that would help in working with big data.
That's some /r/maliciouscompliance stuff.
Have you thought about using node?
This makes sense since you're not really mutating the tuple, just the list. the error occurs because you use assignment operator
Is that where I should be posting such dumb stuff? I saw another post that said that's a dangerous place full of bad advice. 
I haven't just because I have no experience with it. Been teaching myself for the last year and a half or so, mainly excel macros and moving into .NET over the last few months. Also have done some python on the side and a little bit of HTML.
Thanks for the link; apparently my student was not the first to find this. 
1) This isn't "dumb" stuff. It's just an honest question :) 2) Yes, that is the subreddit where you should be asking these types of questions. 3) I can't really attest to whether or not it's a "dangerous place". I've had mixed (but mostly positive) success with it. But philosophically, a lack of quality on one sub should not mean that we should start misusing a different sub. The lack of quality should be fixed directly. Maybe try StackExchange if you're worried about quality feedback?
You may need to add python to your path. See steps 7 to 12 on this guide: https://stackoverflow.com/questions/21372637/installing-python-2-7-on-windows-8
tl;dr: Tuples are immutable, but they can contain mutable objects.
Just bring us an asyncio ORM!!
Weirdly I ran the code with python 2.7 and it worked. 
Since when operating systems trigger people? 
This doesn't make sense to me. Isn't `+=` just `__iadd__`? Don't you want to say that: `a[2] += [4]` is equivalent to `a[2] = (a[2]+[4])`? And that doesn't exhibit the bad behavior. Seems like there is a double assignment going on here. How does the tuple ever become aware that the object inside it is getting called with iadd? Shouldn't it just be that `a[2]+=[4]` is the same as: memb = a.__getitem(2)__ memb.__iadd__([4]) And done that way the tuple is completely unaware and doesn't throw any warnings. WTF is going on here? How the hell does the tuple even know what I am doing to its members?
A lot of people have been using react + universal JavaScript have you had a look at that?
Install Anaconda, then run `conda update python`.
Thanks for this- I'll be sure to try this out!
Hear hear. Thanks for the feedback :)
But the promise of python vs. C &amp; Co. is that it is transparent and you don't have to know arcane shit like when is something a"reference" and when a value! ((I **know** what pointers are and why we use them, I started programming on the 90s; just want to point out that this behaviour is unexpected, because it contradicts the python philosophy /promise) 
I understand what the author means, but I'm on the fence on defining tuples in certain conditions as mutable objects. The same applies to the frozenset container. You can have a mutable object inside a frozenset and change its value. It doesn't mean that we can say frozensets are mutable. 
&gt;Don't you want to say that: a[2] += [4] is equivalent to a[2] = (a[2]+[4])? No. `a[2]+[4]` has no side-effects. `a[2] += [4] is equivalent to `a[2] = a[2].__iadd__([4])`. `a[2].__iadd__([4])` has side-effects. A naive implementation of `List.__iadd__` could look something like: def __iadd__(self, other): self.append(other) return self The tuple is not aware that you're appending to a list that's stored in one of members. The tuple is aware that you're trying to assign to one of its members, which it refuses to allow.
Your best bet is probably posting on /r/learnpython. 
Will do, thanks! 
Agreed. It's one of the first things I teach to an intermediate dev learning Python. I love the dict-as-a-default-parameter example, people really lose their marbles over that one.
Hi, I'm the author. I agree, and I'll continue to say that tuples and frozensets are immutable, because that's more accurate than not. But the value of the tuple ('dogs', 'cats', [1,2,3]) clearly changes to ('dogs', 'cats', [1,2,3, 99]) (as in, it doesn't have the same value as before). And immutable means the value doesn't change, so... On the other hand, the tuple still contains exactly the same objects. I think we have to come up with a slightly more nuanced definition of "immutable/mutable". It's a head scratcher that led me down a bunch of rabbit holes about value, identity, hashability, the ==/is operators, etc. I thought it would be good for a blog post.
But at the same time, the value of the tuple changed, and "immutable" means that an object's value doesn't change. I think we just have to come up with a more nuanced definition of immutable/mutable.
I think it's great that Python 3.4.8 exists, but I'm curious as to the usage. My project recently dropped Python 3.4 support. I guess, what do people expect for support from open source projects regarding support for Python versions? Python 3.4 has some oddities regarding bytes that are much improved in Python 3.5.
I am glad you find it useful, looking forward to your results with the ESP8266.
When we release a new x.y.0 version, we (the Python core dev team) commit to 18 months of bug fixes, and then another 3.5 years of security fixes. So the total lifetime of a Python version, once it's out, is 5 years. There are lots of people who keep using these older versions; large enterprise installation, LTS releases of Linux distributions. For example, Ubuntu 16.04 (LTS) ships with Python 3.4, and they won't upgrade to 3.5 or anything else newer, because that's how LTS releases work. (p.s. We come out with new versions of Python every 18 months. So that's why it's only 18 months of bug fixes. After 18 months, we move over our bug fix resources to the latest released version.)
But it is always a value. In this case, (immutable objects containing mutable objects) in my opinion, it is not a problem. It is more about idiosyncrasies of the Python language than some dark corner. 
Maybe the shallow/deep distinction can help here.
Get a new Python from wherever they got their current one, hopefully!
&gt; But if an object implements __iadd__ isn't the assignment back to the object unnecessary? Not necessarily if you've e.g. hooked __setattr__. It becomes very surprising that it would be invoked in one case and not the other, and thus it makes sense that in-place addition would still reassign its target.
https://github.com/librosa/librosa is your best bet for this kind of audio manipulation. 
Maybe don't dump 100+ lines of code and ask "hey it doesn't work can someone solve it?". Nobody wants to read through your entire program and you won't get many responses. Isolate where you believe your code is behaving unexpectedly and ask questions based off of a simple digestible example.
how are you reading your mp3's?
&gt; mutable objects can't be hashable It's more that the hashable part of an object must never mutate otherwise dictionaries stop working. You can still make your custom class hashable and use it as a dictionary key if you promise never to break that contract. You can even have other parts of the class mutate as long as the part being touched by `__hash__` and `__eq__` doesn't overlap with the parts that are mutating. It's something confusing enough to avoid, but if you're writing an ORM for example you might find yourself in that situation -- with metadata that isn't interesting as a "value".
I was trying to link this in another post but the video has been removed! Is there another source?
&gt; It's more that the hashable part of an object must never mutate otherwise dictionaries stop working. You can still make your custom class hashable and use it as a dictionary key if you promise never to break that contract. Eeeeehhh, yeah but the word you're looking for that means "never mutate" is "immutable". You could easily change CPython to allow mutable lists as dictionary keys and they'd work as long as you'd never mutate the list. Which is to say, they wouldn't work all that well and that's why CPython doesn't let you do it. Though you're point about having metadata that doesn't affect equality or hashability is interesting. It brings up the question, "What counts as 'value'?" If the `==` operator considers two objects equal even though they have different metadata, you could argue that they have the same value, and therefore changing the metadata isn't changing the value. On the other hand, those objects clearly have different... uh... value? state? They're different, but not in any way the `==` operator can detect.
I am with you. Tuples are an immutable ordered collection of references to other objects. A tuples does not contain the other objects, just references to them. 
The article doesn't say what bytecode, native or viper are, so I have no idea what I'm looking at.
https://github.com/ofek/bit
A similar concept in Rust is exterior vs interior mutability. The idea is that an object with exterior mutability can be modified in any way, including the reference to it (ex: a list), whereas interior mutability allows a subset of an object's contents to be mutated, but not the reference to it (ex: a tuple storing a reference to an object which is itself mutable, like a list). [Related reading](https://ricardomartins.cc/2016/06/08/interior-mutability) 
Thanks what I’m wondering is there a good library for reading mp3s? Sorry if I wasn’t clear I’m the description.
Thanks this looks great will have to try messing around with it.
Depending on what extensions you’re using, you might have built something that looks pretty darn close Django. Django is batteries included, so it comes with an ORM, views, templates, admin and more already. 
What a *darn* shame.. *** ^^Darn ^^Counter: ^^60294
Think about it from the client’s perspective. They want X done. They don’t really care how or what you did to get X done, just that it is done. Same goes for everything in your life. If you buy Oreos do you really know how they are done? Do you know what machine was used? No, you just want the Oreos and maybe some milk (if you’re not a savage). 
I see, thank you. So, it's safe to say that I'll do good as a Django developer if I promote myself as well as I do with my other work at the moment? My main concern is that American clients may not be interested in a Django developer who is based in Germany (last time I created something for an American client, they were surprised because they previously had bad experiences with German developers, so I'm kind of worried that there is a certain stereotype)
Not even idiosyncratic. It works this way in most languages that I’m familiar with. You can have a constant reference to an object that is dynamic
Well, if you’re talking about the client that is looking for a freelancer in upwork etc, and you want to build a basic static website, then that’s a hard road to go by. Being German or not is probably the same as being a Russian or Paki. Having said that, you should checkout what maybe some of the local area startups are looking for. I think Berlin is a hotbed for startups in EU.
Nah fam, you'll be fine. Just make sure you get the work done. Judging by your skillset, you won't have much problems.
I get my clients through LinkedIn, thankfully. And oh boy... while you are right about the startup areas, I REALLY don't want to work with them. I've been freelancing for 2 years because I can't stand having a normal schedule/doing what someone else says. Not to mention that the pay at most startups is worse than what I can make by myself, but thank you for your suggestion! Certainly comforting.
Biggest would be f strings. I can't think of many other big differences
Apache airflow was pretty much made for this exact case. I've been using it in production for some time now. There is a learning curve but it is highly flexible and has a ton of operators for interacting with specific DB types, external APIs and more. It's a good tool for ETL projects like what you've mentioned.
I simply message people. :-) It's easy, just think of a certain group of workers and then what they may need. For instance, I found it to be greatly profitable to message medical professionals and introduce them to your management software, because chances are... theirs is outdated and looks too complicated. So you ask them if they would be interested to discuss details on a phone call, if they say yes - great, you just got yourself a new client. This works well if you know a thing or two about databases and Java frameworks. 
I created some algorithms to process speech. These are what I used To convert .mp3 to .wav. pydub (https://github.com/jiaaro/pydub) To read .wav files soundfile (https://pypi.python.org/pypi/SoundFile/0.8.1) To play a numpy arrays sounddevice (https://pypi.python.org/pypi/sounddevice)
OK, the specific area is the poly fit and I’m wondering why the best fit lines are not matching my data. Does that help you?
[Indeed it was removed...](https://www.reddit.com/r/Python/comments/7tnbny/raymond_hettinger_python_37s_new_data_classes/?utm_source=amp&amp;utm_medium=comment list) I wonder why? 
Not really, it's too general. Isolate a single example and show the data (if not too large, else show some summary statistics such as the mean and variances), and the code behind how you are performing the regression. With that you can show the results and how they deviate from your expectation. You can upload images to imgur or reddit and just list the results of the regression and how they differ from your expectation.
He was drinking while giving the talk so maybe someone thought it looked bad...
r/savedyouaclick
This one will strip all the symbols from a text file and leave behind unique words. https://github.com/kchawla-pi/word_processor/blob/master/words_from_textfile.py To write a program that knows you and your are stem words and other such cases will require more work. If I implement that I will update here or message you.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [kchawla-pi/word_processor/.../**words_from_textfile.py** (master → 4f268eb)](https://github.com/kchawla-pi/word_processor/blob/4f268eb03fa8a098812971b6cb651a12caa039ae/words_from_textfile.py) ---- 
edit: /u/LouxThefuture here's a working demonstration with a bunch of logging: https://gist.github.com/alanjcastonguay/69148d471bdd1b60ba66d17b26a02afd
&gt; This doesn't make sense to me. Isn't += just __iadd__? It is, but it has other implications when used with a subscript. Consider the following: import dis def func(): a = ([1], 'a') a[0] += [2] dis.dis(func) The output from dis is: 4 0 LOAD_CONST 1 (1) 2 BUILD_LIST 1 4 LOAD_CONST 2 ('a') 6 BUILD_TUPLE 2 8 STORE_FAST 0 (a) 5 10 LOAD_FAST 0 (a) 12 LOAD_CONST 3 (0) 14 DUP_TOP_TWO 16 BINARY_SUBSCR 18 LOAD_CONST 4 (2) 20 BUILD_LIST 1 22 INPLACE_ADD 24 ROT_THREE 26 STORE_SUBSCR 28 LOAD_CONST 0 (None) 30 RETURN_VALUE Note the call to `INPLACE_ADD` which is the op code associated with `+=` (btw apparently `+ =` is invalid syntax, which I learned when I bungled typing the above). After that is the called `STORE_SUBSCR` which is what happens when you do `a[0] = x` it just so happens that `x` is the output of `INPLACE_ADD` and `STORE_SUBSCR` is not allowed on tuples.
Exactly, consider the implication of `public readonly List&lt;Foo&gt; foos = new List&lt;Foo&gt;()` in C#. You're saying "The `foos` attribute of this class will always be a reference to this list" but you aren't saying "You're not allowed to change it" (you'd have to call `.AsReadOnly()` on it for that to happen)
I hope that's not the reason and it's actually some dumb copyright issue -- even if it's because he named dropped the beer he was drinking.
Seems you have a typo that affects whether someone could duplicate this: &gt;&gt;&gt; spam = ['dogs', 'cats'] ... &gt;&gt;&gt; bacon = ['dogs', 'cat'] &gt;&gt;&gt; spam == bacon # spam and bacon have the same value cats/cat
Whoops! Thanks, I'll fix it.
It works much better for building Python web apps. If you're not doing that, I'm not sure there is as much of a benefit (though I'd still use it). It comes down to the commands and the Pipfile/Pipfile.lock system. It's better than a requirements.txt file. One requirements file hits this weird in between point where you want to leave all your requirements unpinned so you get new stuff easily, but then you should pin them so your environments match. Splitting into two files fixes this problem. You get to explicitly define if you want to pin a version (which you usually don't) and then using the hash in the Pipfile.lock makes sure you have _exactly_ the same code running across environments. The commands also work real well. To add a package, just `pipenv install package-name`. This adds it to the Pipfile and the environment. Without that command you'd have to do that separately. A lot of the pipenv commands are like this, taking something I do frequently that's two or more steps and making it one step. I know what you mean about "one more module to install and learn". The good thing is you install it once with pip to your system Python. And, learning is very easy since it has a great interface.
Luigi from Spotify sounds like it'd fit the bill. Pure python as well. 
Seems like a mistake in the language design to me, and a pep that should have been rejected. If you are going to unconditionally assign then you don't need the iadd dunder method. Normal add followed by assignment would have the same semantics, and be safer. All iadd does is optimize away a copy, but at the expense of a vexing parse and this weird behavior. Can `foo[i]+=y` be safely performed as `foo.getitem(i).iadd(y)`? Well I don't know until I fetch item I and determine if it implements iadd, and so you don't know whether to parse this as `(foo[i])+=y` or `foo[i]=(foo[i]+y)`... and so they just do both in a really weird way and that leads to the buggy mutating and complaining tuple.
Actually, this is the whole idea of the puzzle ;)
The irony
I made my freelance career off Django! Yes, it works.
This is the shortest and most accurate definition.
https://i.imgur.com/DED2GmS.png I got False
It gets even more interesting: &gt;&gt;&gt; class My_Container: pass &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 'b' &gt;&gt;&gt; c = My_Container() &gt;&gt;&gt; type(a), type(b), type(c) (&lt;class 'int'&gt;, &lt;class 'str'&gt;, &lt;class '__main__.My_Container'&gt;) &gt;&gt;&gt; id(a), id(b), id(c) (2012966368, 31451320, 50796416) &gt;&gt;&gt; c.egg = 'EGG' &gt;&gt;&gt; id(c.egg) 51198416 &gt;&gt;&gt; t = (a,b,c) &gt;&gt;&gt; t (1, 'b', &lt;__main__.My_Container object at 0x0000000003071780&gt;) &gt;&gt;&gt; type(t), id(t) (&lt;class 'tuple'&gt;, 51243120) &gt;&gt;&gt; type(t[0]), type(t[1]), type(t[2]) (&lt;class 'int'&gt;, &lt;class 'str'&gt;, &lt;class '__main__.My_Container'&gt;) &gt;&gt;&gt; id(t[0]), id(t[1]), id(t[2]) (2012966368, 31451320, 50796416) &gt;&gt;&gt; t[2].egg 'EGG' &gt;&gt;&gt; c.spam = 'SPAM' &gt;&gt;&gt; t (1, 'b', &lt;__main__.My_Container object at 0x0000000003071780&gt;) &gt;&gt;&gt; t[2].spam 'SPAM' &gt;&gt;&gt; id(t[2]) 50796416 &gt;&gt;&gt; t[2].egg_n_spam = "EGG'N'SPAM" &gt;&gt;&gt; id(t[2]) 50796416 &gt;&gt;&gt; c.egg_n_spam "EGG'N'SPAM" The core difference between lists and tuples is that tuple is closer to a C structure - a collection of objects that you usually need to deal with together. In my example with custom class the object **stays the same**. But I can change the attributes of this object, and not letting me to do it if the object is included in a tuple would be quite stupid and counterintuitive. Again, tuple is not close ro strings and lists, it's just a bundle of objects. If objects allow me to mess with their structure and contents, but I can't change the contents of a bundle itself. Tuple's immutability does not affect mutability of its contents. And lists are also a bit more complex than just [1,2,3]. Internally, list is a pointer to a bunch of pointers that point to objects. &gt;&gt;&gt; d = My_Container() &gt;&gt;&gt; l = [c,d] &gt;&gt;&gt; l [&lt;__main__.My_Container object at 0x0000000003071780&gt;, &lt;__main__.My_Container object at 0x00000000030B7A90&gt;] &gt;&gt;&gt; d.x = 42 &gt;&gt;&gt; l[1].x 42 &gt;&gt;&gt; l[0].egg 'EGG' &gt;&gt;&gt; l[1].y = 0 &gt;&gt;&gt; d.y 0 When you add list to a tuple, you are adding a bunch of pointers. You can mess all you want with the pointers and their attributes, but you can't replace that bunch with another. **TL;DR:** Tuples are always immutable, mutability of objects within a tuple depend on their types.
There is a built-in fallback noted in both the docs and the source code.
I've had success with libpostal. Here's the [python wrapper](https://github.com/openvenues/pypostal). I've only used the golang wrapper, but let me know how it goes! Doesn't look like someone has made one using DNNs from my brief googling.
Without having finished the article, this: &gt;&gt;&gt; spam = {('a', 'b', [1, 2, 3]): 'hello'} Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: unhashable type: 'list' looks like a bug in the implementation of Python (specifically, in their tuple hashing algorithm). Tuples are immutable, and therefore their value is immutable, and their hash depends on their value, but I fail to see why the tuple hashing function is trying to hash things that aren't in the tuple value -- namely, the list contents. *The contents of the list are not a part of the tuple value, so should not affect the hash.* But then I suppose that that kind of logic would break nested container comparisons, since the tuple comparison operator searches tuple-item-contents recursively... perhaps it shouldn't... In [1]: a = (1, 2, [1,2,3]) In [2]: b = (1, 2, [1,2,3]) In [3]: a == b Out[3]: True In [4]: id(a[2]) == id(b[2]) Out[4]: False This seems like the same sort of bug. Line 4 clearly demonstrates that the tuples `a` and `b` have different *values*, yet they compare the same. I mean, I guess it's not a bug, it's certainly a great convenience to using tuples to compare-by-item-contents (and certainly "fixing" it would be more hassle than fixing strings-vs-bytes in Py2 --&gt; Py3), but it is inconsistent with the strict interpretation of the language reference grammar.
Most probably, but usually copyright stuff is flagged as removed due to copywrite, well it's sad eitherway as was a great talk. 
"The value of the tuple" is the list of references in the tuple. No more. Modifying a list that is pointed to by a tuple *does not modify the tuple's value*. Nevertheless, hashing and comparison functions *pretend that they do* for the sake of convenience.
My bad, I thought this worked the same as `os.sendfile`.
This gets back to all python values being objects. Two tuples are equal [if all corresponding objects it contains are equal](https://docs.python.org/3/tutorial/datastructures.html#comparing-sequences-and-other-types). A tuple is hashable if all objects it contains are hashable. It doesn't matter whether the objects in question are integers, floats, dicts, lists, file objects, etc. So rather than having the tuple need to somehow have special knowledge of its contents and change its behavior based on that special knowledge, it can just ask the contents whether they are equal or hashable.
I think he suggested startups as a client base for your freelancing business. 
Most of these concepts are nothingburgers when you sit down and study how the program stack, heap, and pointers work. Barring a high-level weed out course, most CS curricula should begin by building an intuitive sense for these fundamentals.
I don't think there is a problem with the `==` operator. It's job is to compare the *values*. The identities of the objects doesn't matter to `==`. I'm not sure what you're trying to point out? Even if the identities of all the items were equal to each other, `a` and `b` would still be different objects: &gt;&gt;&gt; nums = [1, 2, 3] &gt;&gt;&gt; a = ('dogs', 'cats', nums) &gt;&gt;&gt; b = ('dogs', 'cats', nums) &gt;&gt;&gt; id(a[0]), id(a[1]), id(a[2]) (47687248, 47688312, 47584840) &gt;&gt;&gt; id(b[0]), id(b[1]), id(b[2]) (47687248, 47688312, 47584840) &gt;&gt;&gt; a is b False
And they remain immutable because pointers are hashable?
Can you share a bit more on how you get your clients? I'm starting it as well, did a few Django projects before on upwork, but fee is pretty high, and it takes really a lot of time to get worthy clients.
What are good uses for tuples? The hashability and dictionary example comes up a lot but I can't think of good reason to use tuples as dictionary keys. 
Hm, forgot to test that last possibility, so disregard what I say about "is". All I wanted to point out is that value of tuple as a whole is a set of its objects, and comparison operations should be based on ids of objects, not on their values. In that case there are no confusion about mutability of tuples.
It's False, but also it's damned annoying to have it posted as an image of code and not a link.
&gt; learning Python was like picking up the bass after already knowing guitar If you're serious about computer science, you will use many languages over the course of your education/career. Programming languages come and go. Computer science is deeper than language features/idiosyncracies - switching languages makes you learn the concepts, not just implementation. If I ran the world, I'd probably make CS students do their homework in 2 or 3 different languages to prevent people from getting lost in one language/library/paradigm. Maybe one solution in assembly, one solution in a high-level procedural language, and one solution in a functional language. 
I am building a website where people answer specific machine learning quesions about a current project they are working on. After these questions, people can select code-snippets or add a kaggle challange 
**String interning** In computer science, string interning is a method of storing only one copy of each distinct string value, which must be immutable. Interning strings makes some string processing tasks more time- or space-efficient at the cost of requiring more time when the string is created or interned. The distinct values are stored in a string intern pool. The single copy of each string is called its intern and is typically looked up by a method of the string class, for example String.intern() in Java. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Chapter 2 of Luciano Ramalho's book "Fluent Python" has a section called "Tuples are not just immutable lists" that goes into exactly this. Basically, they can work as immutable lists, but also as records with no field names. (But if you do want field names, that's what NamedTuple is for.) And don't forget that swapping variables uses tuples (it's just that the parentheses are optional in this case): &gt;&gt;&gt; a, b = b, a There's a few other things, but I can't think of them off the top of my head.
&gt; and comparison operations should be based on ids of objects Ooo, I just got done typing up an explanation on exactly this, so I'll copy/paste it: CPython will [intern](https://en.wikipedia.org/wiki/String_interning) strings, so `a` and `b` in the following example would not only have equal values but would be the same object and have equal identities: &gt;&gt;&gt; a = 'hello' &gt;&gt;&gt; b = 'hello' &gt;&gt;&gt; id(a), id(b) (42509064, 42509064) &gt;&gt;&gt; (a,) == (b,) True But we can get around string interning with a little concatenation: &gt;&gt;&gt; letterH = 'h' &gt;&gt;&gt; a = letterH + 'ello' &gt;&gt;&gt; b = 'hello' &gt;&gt;&gt; id(a), id(b) (42512088, 42509064) &gt;&gt;&gt; (a,) == (b,) True Now, if the `==` operator decided tuple values were equal by comparing *identities* instead of *values*, then `(a,) == (b,)` in the first example would be `True` but the second example would be `False`, even though they're both comparing `('hello',) == ('hello',)`
**String interning** In computer science, string interning is a method of storing only one copy of each distinct string value, which must be immutable. Interning strings makes some string processing tasks more time- or space-efficient at the cost of requiring more time when the string is created or interned. The distinct values are stored in a string intern pool. The single copy of each string is called its intern and is typically looked up by a method of the string class, for example String.intern() in Java. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Not completely the same, but I learned C in class and then python by myself. The C course was a dreadful experience and learning python after that gave me the revelation that programming doesn't have to be tedious but can also be fun. I have to say that the C teacher was pretty bad and that I don't doubt that a good teacher makes a bigger difference than the language used. Nevertheless I think learning python before C is the better way to go and learning both is definitely better than just one of them. My personal problem with C as the first language has multiple facets: In C, in your very first program you already have to add `\#include` and `int main(){}` of which you don't know what it means. In C that conditions the student from the start to just accept everything, and don't ask for the why. That's a bad start of learning any subject. If you haven't been exposed to any programming before, you have to first pick up the basics: loops, conditionals... actually the whole idea of translating a vague idea in your head to real code on your screen. If you want to do something simple as resizing an array, you need to know all those things already. I think people who can already program often overlook that first stage of learning to program and assume that students can already think in an algorithmic way. With Python, exercises can focus on the core concepts without the student getting bogged up in side-issues that only distract from the point the exercise is trying to make.
Some people said the same when c++ replaced c of when c replaced assembler, or when assembler replaced punching bezeugen onto cards... 
... said the assembly developer to the Java heretic. 
who throws their kid on the deep end of the pool when teaching swimming?
lisp
You also don't get any money when the open source project gets bought by some big corporate for a million dollars, even if you submitted a PR that was merged
"hashability" means the object's class has a __hash__ method that returns a value. A tuple's hash value is a combination of the hash values of its members. If a tuple contains a non-hashable value, then it is not hashable, but only because it's implemented like that. You can subclass list so that it has a hash value and compares equal using its identity, and put it in a tuple and hash it. Heck, you don't even need the "compares equal" part if you're okay with breaking dicts and sets. ``` class MyList(list): def __hash__(self): return id(self) x = (MyList([1, 2, 3])) y = dict() y[x] = 2 ```
Maybe you could give us these standard meanings for "immutable", "identity", "reference", and "value"?
Python is effective but C++ es more enterprise like. Similar to Java, C# and most OO languajes. I wouldn't change the language, just add python
An introductory class deserves to be taught in an approachable yet powerful language, and Python fits the bill perfectly. It took nearly 10 years to undo the damage done by the intro programming course I took as part of my engineering degree. We learned C++, and it was absolutely dreadful. Rather than teaching us that computers could be effectively tools in problem solving, we learned how to read through convoluted loops filled with deliberately confusing if statements, as though you would do anything upon reading such a piece of code other than finding the person who wrote it and beating some sense into them. I learned that programming was a boring, awful grind that I hated. Now, years later, I read books on OOP and TDD because I've realized how fascinating and versatile a tool programming can be. The path of my career would probably have been different if that one class had been actually designed with students in mind.
You either drown or learn to swim. 
I honestly can't imagine a worse language than C++ to do introductory programming. Python is a good choice, but at some point they will need to use a language that screws with pointers, etc. Every class I had in CS used a different language -- and hopefully that's common.
I first learned C++ and then after 3 years of coding in C++ ,I learnt python. I think being able to code in typical coding standards(syntax and pointers wise) helped me understand data flow better. Learning python as your first language is like learning to draw by simply copying an image , No shading lessons,No contrast knowledge . Creativity comes from confidence , which comes from knowledge, which comes from knowing the basics.
Reminds me of an epic movie's dialogue &gt; "Tumhara naam kya hai Basanti? " Translation "What's your name Basanti' Btw what if I do a = 0 b = a name_of(b) What will it return? 'a' or 'b' ?
That's nice, although I would favor a type-based approach to a functional approach. In a type-base approach the unit is stored in the type itself instead of having to be passed to a "convert" function as a paramenter. Conversions would be done by simple type-casting. For example: import BinaryUnits a = BinaryUnits.Bytes(4096) b = BinaryUnits.Kilobytes(a) print(f"{a}, {b}") outputs: 4096 B, 4 KiB This kind of interface is much less error prone than your `convert_units` function. Moreover, a typed interface let you implement "safe" arithmetic operations: # a and b as above c = a + b # coerces automatically the result to the lower-resolution unit, that is BinaryUnits.Bytes print(c) outputs: 8192 B You could also provide a function to coerce values to their "prettiest" unit, that is the smallest one where the integer part is less than 1000/1024: # c as above d = pretty(c) # d is BinaryUnits.Kilobytes(8) Just my opinion.
Maybe it starts counting at zero ? 
I use python on a daily basis and it is my favourite language. It is very good as an teaching language but I don't think it is best for CS students. You need to understanding of pointers and syscallls to be good at CS. Even in todays world you do need C and assembly. This stuff just makes better programmers even if not used directly anymore. You can take a C programmer and teach him python easily. The other way round is much more difficult.
can't swim if you're dead lol. I get the idea but this is just a terrible way of teaching things. if schools swimming programs did this I guarantee. It'd get shutdown after day one. 
awesome! as far as you know there is a way to integrate also some pure c lines instead of using the viper thing?
What’s the diff between this and redbeat?
I learned VB 2005 in college, Java first year of uni, python first and second, and C third. The only one I really disliked was Java and guess who had the worst instructor? Yes I generally prefer Python but it's too slow for processing long calculation loops. 
The main issue I have with Python as a tool to teach programming fundamentals is that some things are just easier to understand in C because you have to work with pointers, especially data structures classes. You can clobber it together with Python I guess but in C you just have to and it works exactly as it looks and does nothing more. The real difference between a linked list and array is going to be way easier to show in C or C++. Understanding why accessing an element in an array is O(1) versus O(n) in a linked list is going to be obvious, or why inserting an element in a linked list is so quick. Understanding pointers is a big strength in these areas IMO and you're just not going to really get it as well as if you work with them and have to use them. The list primitive in Python hides so much magic that should be understood at a lower level by students. Also, you can't really teach operating system fundamentals without C, so it's got to come in at some point. On the other hand, I think Python is a much better tool to teach OOP and functional programming concepts rather than C++, and it can easily handle 101 style classes that just teach control structures. I think it definitely has a strong place in education, but I don't think it can cover the entire curriculum on its own. C needs to be learnt at some point in the college experience. I don't think C++ needs to be taught, but C for sure. They have to get a taste of low level programming and understand just what's going on under the hood.
Your `MyList` example is not hashable. Your "hashable means it has a `__hash__()` method" definition is wrong. I'm being blunt, but it's because [you're the guy who called me wrong and silly without bothering to explain why](https://www.reddit.com/r/Python/comments/7vhbh8/python_tuples_are_immutable_except_when_theyre/dttbbau/), so I'm a bit salty. &gt; Heck, you don't even need the "compares equal" part if you're okay with breaking dicts and sets. Yeah, but people like things... not broken. So you do need it. If you had `__hash__()` but no `__eq__()`, then hash collisions alone would cause objects to overwrite each other in a dictionary. That's why you need both the hash and the equality comparison. And, since **you're** using a very Python-specific definition for what "hashability" means, the [official Python docs](https://docs.python.org/3/glossary.html#term-hashable) say the `__eq__()` part isn't optional. So you do need it. Your own example has `__eq__()`: it inherits it from `list`. While we're looking at the Python docs, they also say this: "Hashable objects which compare equal must have the same hash value." So you're wrong about the `MyList` class being hashable. Comparing two `MyList` objects with the same value would be `True` (just like the list type they inherit from would) but comparing the hashes of those two `MyList` objects would be `False` since you based it on their id. But I know what you're getting at! You *can* have classes with hashes are based on id! In fact, the Python docs go into this a few sentences later: "Objects which are instances of user-defined classes are hashable by default. They all compare unequal (except with themselves), and their hash value is derived from their id()." (Your `MyLife` example still isn't hashable though: you inherit `__eq__()` from `list` so they don't compare unequal with everything except themselves.) So does this mean you've proven me wrong, and mutable objects can be hashable? No. Because "mutable" refers to the object's value, and the `__eq__()` method defines what counts as the object's value. You can slap on a bunch of mutable state to the object that doesn't get considered by its `__eq__()`method, but then you'd be in the funny position to explain how changing the mutable parts changes the object's value but doesn't affect how the `==` operator works. I dunno, we could have a nuanced discussion about what "value", "mutable", and "hashable" mean (or should mean). But if you [want to say I'm wrong and be condescending about it](https://www.reddit.com/r/Python/comments/7vhbh8/python_tuples_are_immutable_except_when_theyre/dttbbau/), you better do your homework next time and not post half-truths and broken code.
For MusicXML, it wouldn't be too hard to extract a subset of the notation. Just remove the relevant measures from the XML file. Then import that new MusicXML file into Finale and export an image. You might also try dealing directly within Finale, writing a Finale plugin. I don't think Python will be particularly helpful for that. If you want to deal directly in PDF land, you'll need to clearly define which area of the PDF corresponds to the bars you want to export. To state the obvious, a PDF is merely vector data and has no semantic knowledge of "this series of vector lines corresponds to bar 2" — you'd have to deal with that.
&gt; switching languages makes you learn the concepts, not just implementation That's the best thing I'v learned why studying several languages. I learn that python use duck typing, and C++ templates use it too. Python have beautiful `itertools` library, but C++ iterator and algorithm is much more powerful.
**Whoosh**
..?. 
Will definitely check this out, thank you!
Great to hear. Been doing some more digging since I posted this and Airflow seems to be gaining a bit of momentum. Thanks!
Great to hear. Been doing some more digging since I posted this and it seems that a lot of folks are using Luigi. Thanks!
I'm lerning asyncio and aiohttp
This. I can agree on every word. Thanks for sharing!
Sure, I will add an example in the tests. If all the number in series are high then the compression would be pretty high because the algorithm stores the diff from first number onwards.
Pyspark + Hadoop seems like a common toolset used for big data
What I find odd is that so many universities only teach ONE language. Here, we've jumped from Python in the first semester, and now we're onto C++. Next its Java and C# if you're going into Games Tech. Their argument is that employers appreciate people who know languages like C++ (apparently many unis still just do python or java etc.) For their workloads, while teaching languages in a fastpaced environment helps teach learners to pick languages based on the problem to be solved rather than just fear of learning a new syntax. Most of our C++ lectures rely upon translating concepts from Python to the new language, before delving into C++ specific concepts such as streams and structs. We dont get super experienced in any language, but enough to know how to do "anything" once you find the right libraries and resources. I figure the same is for most programmers out there nowadays. 
I want to get into this but can I achieve anything meaningful in a complex game with 1,000 GPUs to train it? I don't really have any interest in the subset of simple games that DeepMind did for Atari like Space Invaders. Something like Snake is probably too hard, judging from what I'm told by someone who's working on it. It's the sort of game that AI doesn't do well on.
Can this library compress numpy arrays (without converting to list)? We do a lot of numerical processing and compressed arrays would be real handy but all our data is in numpy arrays.
With salt alligators
Great, thank you. :-) Definitely giving it a try!
I was taught pure C. It killed the joy of programming for me and I had to learn how to have fun doing it with Python couple of years after the uni. But some stuff is a bit easier to understand. I feel that it would be better to start with Python for me and have fun, while struggling with more complex things here and there.
Counterpoint is that I've never seen anyone who really knows how to teach programming. The hardest part for new programmers is to take the generally vague instructions we work with in real life, and break them down into small enough tasks for a computer to represent, and specific enough for them to be accomplished. I've seen really intelligent people wash out of programming classes because they just didn't get it, and it wasn't anything that was taught. 
I studied in the late 90's, so Java was all the rage. Thus, we mainly studied Java. I'm grateful for that. Java was pretty clean and neat at the time, and it was mind boggling to code and just have it run "everywhere". Even when using GUI's. But especially, I like it for being a typed language and more clear constructs than Python. It can be a pain to type everything, but at least you later innatiely realize why it can be bad to not do so although untyped languages have their uses too.
With enough salt you can't sink.
I learned Java first and moved on to learning other languages like Python, and I always appreciate understand all the extra stuff that came with learning Java, even though it isn't always used.
Splain please? I have extra marbles.
I've been hard at work creating a web spider that will explore and map out Tor's hidden services. I've got it working already, but I keep tacking on new functionality. The primary purpose of my project is to learn new libraries and techniques.
When I'm not working on my Tor spiders, I'm taking a crack at writing a multiplayer, text-based game using curses. If anyone has some good tutorials for how to work with curses, I'd be incredibly grateful.
Is there an alternative to pytorch that runs on windows?
I was unable to enter the required entry level programming class at my University due to the math class I was enrolled in at the time. Instead, I enrolled in an online intro to Python class, and it became the first language I truly learned programming concepts in. The next semester, I had to take the required C intro to programming course. It was amazing how much clearer the concepts were to me after taking the class in Python. C is a very complicated language for a beginner. As a lot of people have pointed out already, it really should be a must-learn language in an academic setting for any student studying computer science. But I think there's a benefit in waiting to do so.
Richard Buckland is probably the best programming teacher I've seen - special mention to David Malan (but may be a bit quick for some intro learners) 
Suggestion: Add your configuration files to `.gitignore` and have the script generate a fresh config file when the user runs it, so that you don't leak usernames and passwords over git. (Check my username.)
The reality is that many more programmers are coding in languages that are not C++ and don't involve memory management. I remember my intro C++ courses and I can't count the number of people who just brute forced their simple C++ programs until they ran, screw proper memory management. Python is a much better language for teaching introductions to computer science, logical deconstruction. If they kept Python for their higher level courses I would have an issue, but for just the intro courses Python is fine. Half the people taking those courses are taking some other major that requires programming, in which case they'll be writing Python for their job probably (or Matlab).
From my brief experience as a CS101 TA: 1. CS has a shockingly high failure rate on introductory courses. It just blows other disciplines out of the water. A lot of people are unable to create fizzbuzz-level programs after months of instruction. Whether it's the fault of the teaching or the material I'm really in favor of anything that lowers the difficulty of the on-ramp rather than trying to throw people in the deep end. 2. A big fraction of people taking intro-CS are actually bio majors or something either getting a one-off credit requirement or because they heard the siren song of 'learn to code'. You want these people to have a take-away even without another CS course. Python excels in this way because you have great libraries like matplotlib and because you can teach them some basic scripting: shuffling files around, sed-like utilities, csv munging, etc. 3. One of the biggest hurdles for people is they view everything as some magic opaque incantation which just can't be debugged. I've seen people have no clue what went wrong when receiving `TypeError: unsupported operand type(s) for +: 'int' and 'str'` and a line-number. C++ is really bad in this respect because you must teach people C++, make, the shell, and gdb in order for them to have basic competency. Add to that the eldritch errors produced by compilers and the weird stuff that you just kind-of have to know like forward declarations, segfaults, or char* vs std::string, and I really think it is a bad language for teaching people that they can actually program, rather than copy their friend's code whenever they give up and just hope the stars align on the final.
That's my point - learning to swim there wouldn't necessarily help you elsewhere.
Good riddance; C++ is too much of a behemoth of a language for a decent programmer to learn in 6 months, let alone be taught as part of an intro class that uses it as a vehicle to introduce programming concepts.
&gt; like to think happened in the olden days. To be fair, that's exactly how I learned to swim in the 90s. It's also how I learned to ride a bike - I sat on i he bike at the top of a hill (a grassy hill, I should add - not on a road) and my dad gave me a push. In both cases it was either sink or swim, ride or fall.
Im in my first year in University for Computer Science and we had python as our first Language too, and I couldn’t be happier with the choice. Really helped me understand some basics. 
There's a missed opportunity here to seamlessly transition from Python through Cython to C/C++. If you do enough Python you end up there yourself when you run into a situation where you need more performance.
I learned C++ in school and python on my own. I would say C++ was the better start particularly for me, as an electrical engineer everything is C/C++. That said, I think python could be a good way to start as it really simplifies a lot of programming and can help teach broad concepts early. 
Of course it is. The technology you use isn’t nearly as important as how good you are at delivering whatever it is the client wants. Very few clients will even know what django is.
Yeah and still the length is 4, not 5. :D
I have been a C++ developer ever since the language came into existence and a Python developer since 20 years now. Also I teach both Python and C++ at the Rotterdam University of Applied Sciences. We use the following sequence of courses: - At first we teach a short C course to familiarize students with the low level, close the iron aspects of programming. They also learn to control hardware (via Arduino). - In the second half year we switch to Python to teach them the basic concepts of object orientation, specifically encapsulation, inheritance and polymorphism (although it's agreed Pythons support for encapsulation depends on good will). - In the second year we teach them the basics of C++ including constructors, destructors and dynamic memory management. - In the third year we complement this by teaching them making template classes with operator overloading etc., in combination with numerical mathematics. In my view Python and C++ are complementary. Starting with C++ is quite feasible, but a generation used to scripting languages will feel quite alienated. So we ease them in with C, no objects, but also not the luxury of a garbage collector. Since we consider OOP mainstream after that we teach them the basics of it in a comparably simple language. After that they're able to handle C++, at least most of them. It should be noted that our department specializes in technical applications: real time controls, AI, numerical simulation etc. This is an area where the combination of Python and C++ currently rules. 
What are the drop out rates in this your CS program? I know many are high so barrier to entry is likely more important.
COBOL.
"Picking up the bass after learning guitar" --- that's just rude.
Yeah my first (and only) formal computer science class was in Java, and I agree with you that there were benefits to learning that first over python. I think it gave me a much better understanding of data types and even things like control flow. Also I think your right that having a language that is a little more strict is good. When I came back to programming a little later, with Python, I wrote really messy code because you can pretty much do whatever you want and the intrepreter will handle it. 
Just to add to this, I am not being disparaging towards CS student that don't go into programming. More that CS is a wide ranging field of study and programming is only 1 part of it. Many students will either not enjoy programming or not be interested in it at all, but will need to do a first year set of classes that include lots of different areas.
Java ... 
Modern C++ is fairly solid. You just have to very very clearly delineate the 80% of the language you will use and the 20% that must not be mentioned. The hard part is that since nobody uses the same 80% and the 80% you will be teaching is biased towards the new features, you effectively aren't teaching the same language. Your students would have no idea how to read the vast majority of programs without further study. 
We started with Haskell which I can say was a real joy to learn, probably nothing I would have looked at otherwise(at least at that time). One of the main reasons was that usually half the class already knew an imperative language so with a functional language most students where at the same level.
Teaching Python would be more inductive, whereas c++ is more deductive I think. My take is to start with python/javascript or else, in high school, to build an intuition for programming and then learn c++ at university.
Your success as a freelancer will depend on ...your success as a freelancer. It rarely will matter what language or framework you use to do something. What's more important is that you know whatever you're attempting to use well, and that you get the job done. If you enjoy working with Django, have examples/proof of your previous Django projects to show to prospective clients, and are excited at the thought of maybe learning new things about Django, then sure, Django is a viable option for you with a freelance career.
richard hendrix is that you
...well? Don't leave us hanging! ^^/s
Whoa buddy. Bass and guitar are two entirely different animals. 
Lisp: () is literally a building block, one symbol for everything is never a good idea. Haskell: I don't know, I just hate it's syntax with passion.
I did my intro with Java. Thought it was good.
Naah....They should start with "Intel® 64 and IA-32 Architectures Software Developer Manuals" it's like children book for me now :D
If you want to learn the underlying hardware, Assempler is most fitting. There are still some abstractions in C.
&gt;I honestly can't imagine a worse language than C++ to do introductory programming. https://en.wikipedia.org/wiki/Brainfuck https://en.wikipedia.org/wiki/LOLCODE https://github.com/Property404/fetlang
&gt; Whether it's the fault of the teaching or the material It's the teaching. Having been in intro programming classes where at least half the class were experienced hobbyists, and half the class were noobs, it was no surprise that the noobs failed. I can't imagine anyone learning anything from a whole week of writing loops. It's like asking people to learn kung fu by practicing punches for 8 hours, with only a description of the punching motion. 
Definitely glad I opened up this thread. Thanks a lot, everyone!
Same. I learned Python in high school and have been learning C++ the last few years in uni. I think the biggest factor for me is that with Python you can really build anything. Using pip install is so much easier than linking DLLs and whatnot. 
https://github.com/pytorch/pytorch/issues/494#issuecomment-350527200
Work continues on filling in a Mysql database with stock data. This week I've been focusing more on news headlines, I.e. gathering new/old stories for each stock and storing their title/summary/keywords/sentiment analysis score. 
I know C (uni course) and python (self taught and language of choice). I learned python by using blender, because that has a python scripting interface. Was I going to sit down and apply my C knowledge to write software? Hell no. Calculators or what? Drivers? Can't do websites either... You can tell me what you use C++ for and I'm going to point out how that's above anyone with ~ 200 hours of experience with programming in general. There was no tangible use to knowing C for me when I learned it and there is nearly none now. Everything I want to do, I can do in python. It's not going to win prizes for efficiency but it works and I'm happy with the output. 
It's all so clear now!
At my school we learn Python or Visual Basic as our absolutely first, no programming experience at all course. Then you have an option of Java or c++ for your major. Not sure how long it's been this way though. 
Excellent question. The sobering truth is that the state-of-the-art is not as advanced as the tech blogs and the aggressive PR departments of some companies make it seem to be. The Atari game set is still considered a "hard" problem in 2018 at 80x80x3 uint4 input. I mainly built Serpent.AI to educate both myself and others (through tutorials and live streams) about the different algorithms and their potential and limitations, all this against subjectively more interesting targets than cartpole or the Atari games. I think the tech in Serpent.AI is already there to support most if not any type of experiments (it's not exclusively tailored to reinforcement learning, unlike other tools)... we are just waiting for breakthroughs in research. In my experience, you don't need 1000 GPUs to get something working with a game of your choice. I seem to remember that DeepMind tested the initial DQN implementations on consumer hardware. This being said, it will take a long time (days, weeks) to get results. Patience is definitely a must in the field of ML/RL at this point in time. I think games on your Steam library remain a great target. Like you said however, if you focus on multi-actor approaches, it's a deal-breaker. Multi-actor is however not the be-all, end-all so my suggestion would be to focus on different approaches. As far as game selection goes, anything with simple rules and not too many inputs is viable. At worst, Serpent.AI is a fun/educational hobbyist set of tools, at best it can be used for / to validate serious research. Time will tell; I'm certainly having fun in the meantime!
It completely depends on what the goal of the education is. Assembly is useful and important to teach in hardware oriented educational programs, but useless for a programmer. Teaching C is good enough to teach the basics of hardware organization and how a computer works, while still providing a lot of value even if people never touch C again.
My project at work is mostly winding down due to me finishing it somewhat ahead of schedule and the end of my contract at the end of the month. Anyone hiring remote or in New York?
Lisp is better, in my opinion. With C++, you automatically have to deal with a lot of "advanced" stuff to do even simple stuff: Namespaces, function declarations, libraries, etc. Most instructors tell students: "Just do it this way, it will all make sense later". Lisp has the annoying parentheses, but that's about it. The learning curve is very shallow. 
It depends on the type of person if you ask me. I learned Python as my first language and it really helped me to understand programming, programming logic, and how to think like a programmer, while still maintaining an easier to read syntax for a first time programmer. I learned Java next, and I was able to build off the knowledge of Python, and read the new syntax after a bit of learning. But I really look back to my python learning as being the stuff that helped push me up. I plan to learn C++ next. 
That's how I was taught.
DAE Turing??? 
I feel similarly. I started with a C/C++ course and then oop C++. When I got to college my DSA class was in Java. I work in python. Understanding core concepts of CS has made me better at programming, no matter the language. 
I picked up C++ first and they got into Python. For work purposes, due to the rapid growth of Python, I use Python practically for everything. Having C++ as an introduction to programming made other languages naturally seem simple. I wouldn't switch the order because for me it seems easier to learn the more involved language first. I'd rather have a downhill battle than an uphill one so to speak. Python is practically everywhere. There's also a major push for more people to learn to write code. Python as you stated offers a lower barrier to entry and thus is analogous with the push for more people to write code. 
With ten thousand arm floaties. 
I dont know how #include is hard to understand. You want a hammer. You must tell your program where to get a hammer. Same with main()... This is the function that runs your program. It returns a number that says if its totally fucked or not. ¯\_(ツ)_/¯
You dropped this \ *** ^^To ^^prevent ^^any ^^more ^^lost ^^limbs ^^throughout ^^Reddit, ^^correctly ^^escape ^^the ^^arms ^^and ^^shoulders ^^by ^^typing ^^the ^^shrug ^^as ^^`¯\\\_(ツ)_/¯`
I would never teach c++ as a first language. I choose python for that. I'll teach c and/or c++ along the way when I'm teaching him about implementing data structures, handling memory and such but not before. Python will be simple and readable enough to let them grasp how to think in programming terms. You can also easily teach unit testing without having to do too much fuss. 
Hm...that's not a bad idea, thankee.
Thanks for suggestion, i ordered the book and look forward to reading it! But i must admit im still not convinced; why not just keep your records in list containers? And swapping variables could be provided as just another part of pythonic syntactical sugar (not sure ive used that term correctly), it seems almost coincidental that tuples are the background mechanism for that. I still dont see get why we need tuples as an alternative container. Thanks for your answer though. 
Interesting for transport planners?
I kinda solved the problem, in a bit of a backwards manner. I loaded the data using JSON.Net (and C#), which can utilize default values and handle missing attributes (using said defaults). Then, I just told it to save the data back to disk. Doesn't solve the underlying issue; I'll try what I've seen here, thus far, but at least I have a working dataset, now...
What CS careers don't include programming?
Good bot.
Thank you IspyAderp for voting on LimbRetrieval-Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
My university in Finland has almost entirely stopped teaching C++ courses. C# courses stopped about 3½ years ago and about 6 months ago C++ courses just disappeared from the course lists. We have 3 Python courses now available in various languages. I think you can still take some kinds of online C++ courses but there are no contact lesson courses for it any more.
From a teaching perspective, C++ is more difficult to teach introductory concepts because of the syntactic baggage. Python isn't perfect either - students will move past those first topics and then it's tough to explain things about memory or binding variables without real pointers. My first programming class used Lisp: would not recommend. 
For intro level classes: I think Python is definitely better. Students can concentrate on thinking about algorithms and spend less time diverted by how format the thing they want to express. For mid level classes: for the love of God, please make them learn pointers. Even if they don't _directly_ use them later, it's critical to know what's going on under the hood. For high level classes: Python again. For instance, I loved studying data structures, but the pain of 1) figuring out how to express somewhat sophisticated ideas in a low-level language while at the same time learning those concepts, and 2) the latency of the edit-compile-run loop made those classes more complicated than they needed to be. Spending an extra 10% more of the semester learning about cool new things rather than helping stuck classmates figure out where they'd typoed the pointer math would have served us better.
That looks great! Glad to help.
I feel like almost all classes have done that lately. Python makes it easier to actually teach concepts because you have less to worry about.
As someone who started with bass, I appreciate someone else nitpicking this point. 
When python is a great first language to learn but for university they should be teaching something like c++
I was thinking about SysAdmin/Network Engineer/Helpdesk type jobs. Half of the SysAdmin team at my company have no need to write code, but they all have CS degrees. The helpdesk guys and gals have CS degrees but no programming involved, granted you probably don't need a CS degree to do this job, but it's surprising how many (anecdotally) helpdesk people have a CS background.
...if you don't understand the maths, how do you even know if the EKF is the right/best solution to the problem? Is this homework or for a job? 
&gt; I dont know how #include is hard to understand. You want a hammer. You must tell your program where to get a hammer. &gt; Same with main()... This is the function that runs your program. It returns a number that says if its totally fucked or not. Ah yes, a "function". I was talking about a course that's the first intro to programming. So the first thing you have to explain becomes functions, that explanation has to be more than just "A function is really simple, it's just some code conveniently bundled so you can reuse it in multiple places". It's not about whether students can understand something, it's about reducing their cognitive load on a newcomer as much as possible. When you're used to programming and intuitively separate the important from the non-important it's easy to underestimate what things people can have trouble with.
That's a good point. I guess id imagined those jobs being a more IT degree, but you're probably right. Lots of CS folks end up there. 
That's basically what what I learned on. https://en.wikipedia.org/wiki/Scheme_(programming_language)
**Scheme (programming language)** Scheme is a functional programming language and one of the two main dialects of the programming language Lisp. Unlike Common Lisp, the other main dialect, Scheme follows a minimalist design philosophy specifying a small standard core with powerful tools for language extension. Scheme was created during the 1970s at the MIT AI Lab and released by its developers, Guy L. Steele and Gerald Jay Sussman, via a series of memos now known as the Lambda Papers. It was the first dialect of Lisp to choose lexical scope and the first to require implementations to perform tail-call optimization, giving stronger support for functional programming and associated techniques such as recursive algorithms. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Not sure if anyone will see my post at this point but here’s my opinion based on how I learned. My path was ideal, and I think luck for that. I just so happened to take classes in this order (I chose them based on what I thought would make sense, but I had no idea what I was doing). First I took C and I made it through the class not really understanding what I was doing. I had somewhat of a foundation though. Next I took C++ and I learned a TON about object oriented programming and many other basics. The class taught me so much, I think, because the assignments were hard. “Write a program that does X, Y and Z”. I was forced to go through my book, YouTube, Stack Overflow, and any other resources I could find. Assignments took me days to complete but I came out on top, lucky to have learned so much. I could have cut corners but I didn’t. I was having too much fun and wanted to know how and why everything worked. I taught myself JavaScript after this (already knew HTML/CSS). After this I took Python and was a little disappointed, mostly because it was an intro class and well below what I was hoping for. However it was sort of refreshing. I’m excited to start some projects in Python because it looks enjoyable to use. I would recommend taking C/C++ first to anyone. Many languages are written in C++ and I think it is a great foundation to have. It’s hard. When you get to other languages that do things like manage memory for you, it is easier to appreciate and grasp, in my opinion. 
Bad bot
Thank you gifgifgifgifgif for voting on Darnit\_Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
In micropython you can decorate functions to get faster performance. # bytecode def foo(x): return x**2 # native @micropython.native def foo(x): return x**2 # viper @micropython.viper def foo(x): return x**2
Separate things that do not change from things that do not change. ... ok?
Maybe his point was that he always enjoyed the guitar but then realized the world of bass is the beautiful one
which end has spikes at the bottom?
Personally, I think C++ is a terrible language to introduce people to programming. The language has a lot of idiosyncrancies and syntax and boilerplate requirements that you really can't escape, even for simple programs. C was the first language I learned and the class was terrible. Granted, the teacher was a grad student that I think barely knew the language herself, which didn't help. It wasn't until later when I learned Visual Basic and eventually python that I really began to grasp programming concepts.
my first course was taught in python and my second was taught in c++. four years of programming and TAing later, I still think that was the right choice. python is easy to grasp when you're just learning basic programming concepts. once you have a foundation, c++ then challenges you to think harder about the details: data types, pointers, etc. thing is, our python course still manages to weed out ~75% of students, who all realize programming is not for them. you don't have to start with a massive learning curve 
I am going to work on a python script that imports cheese information into postgreSQL database (dairy farm, cheese name, animal it came from, location at which it was made).
Have you tried AngelList (angel.co)? Tons of startups based in NYC are hiring software engineers.
The more languages I learn, the more thankful I am that I learned Python first. (For reference I'm not a software engineer, and I just know a hodgepodge of languages useful in science/numerics).
The US Navy
At a previous job, we did this with a couple hundred major online retailers. The difficulty of maintaining custom code for each site (which you are virtually guaranteed to need if you care at all about the accuracy of the data) varied widely between sites, but we had a dedicated team of several junior -&gt; midlevel devs maintaining the codebase just for data extraction. They always had a backlog of years worth of work to triage just to keep up with changes in the existing sites. It's a brittle process and you are completely at the mercy of the sites you are scraping as they can change any time. Also, your traffic is unwanted and there is a whole industry dedicated to implementing technological methods to detect and block your scraping. Basically, I suspect you are dramatically underestimating the difficulty and resources required for what you are describing.
I came from coding in Perl, which I had done for 1 year. I felt I never got better at Perl. Part of that was the lack of good Per code to reference. Within 3 weeks, I was better at coding in Python than I had been in Perl. I had a lot more sample code. You'd figure after 11 years, I'd get to the point of I got it figured out (like I thought I did with Perl). Python encourages you to learn new things.
I wrote avocado.rawhttp.com recently because I can't be motivated to do anything actually productive.
My university starts with python (while explaining the underlying elements of the language and how/why it works), then assembly, and then c++. You're working in Python and ASM for the first year and then it's all c++ from there. While I learned c++ first and it gave me great insight into Python and helped me out a ton, for the majority of people, I think that learning python first is better as it allows you to learn CS concepts before focusing on efficiency and running the most performance. As long as they're teaching how python works rather than "it just works that way", I have no problem with it.
+1. I love C, but when people say that C teaches you how a computer works, it's only half true. Yes you learn about pointers and memory addresses, stacks/heaps, etc. But it's always a bit abstracted. Assembly is better at teaching each of those things imo.
So what you're saying is, one developer couldn't be expected to do it in one or two months?
So you're saying you wouldn't consider this something that one junior level developer could be expected to complete in a month or two? 
You need to run this from the regular command line, not within a Python REPL.
F
Well I guess now it is easier to google myself.
Maybe you can initialize type 'Persona' at runtime like this: with open(data_file, 'r') as in_file: data = json.loads(''.join(in_file.readlines())) personas = [] for k in data: values = ','.join(k.keys()) Persona = namedtuple('Persona', values) personas.append(Persona(**k)) return personas
That would be far prettier, aye. Thankee!
Cool. Could you do some research? Because the person I was replying to is in a position to do so. 
My other car is a cdr
Hi Purplelcy. I have submitted the question as a link. At least that is what I know about links. You click at the link and that will lead you to the question. Correct me if I am wrong
Same with my school! (Are we talking about one in Pennsylvania..?). I think Python would be better. I find myself using it more in real life than C++. 
Obviously you throw them in the middle of the ocean and start with assembly
Maybe you can initialize type 'Persona' at runtime like this: https://pastebin.com/xRNN9F6A 
High dropout rates in computer science seem to be fairly common. What they find is that it does require skill, accuracy, patience, and there really is "science" in computer science, not just programming.
&gt; Every class I had in CS used a different language -- and hopefully that's common. It seems weird to me to learn that according to some people here their program mostly used a single language. I wonder if this is how those people that religiously cite "X is better" are born.
We all float in COBOL land 
In my uni programming I is a mandatory course for everyone and here it too is one of the courses with the highest failure rate. Higher than all the calc and physics courses. I assume that if the course didn't use Python maybe the failure rate would be even higher?
Are you using finviz.com for this? Its a great place to get company specific news to scrape. 
sort of like cheese.com? any ideas as to what you want to do with the data? 
No need understand maths. Just use module for best sensors fusion. Python best machine learning. Use GPU. /s
I nearly missed the /s.
depends on how you feel about drowing.
I assume all sites have different layouts? I am doing somewhat similar for my own SaaS where I need to scrape listings daily from approx 500 sites en it gets tedious complicated. You could DM me with a sample size of the website so I can look if there is any correlation that can be used to extract the data you want without building 6k scrapers. 
Several years ago I had roughly 150-200 sites and widely used CMS frameworks completely automated for creating accounts, building profiles, posting content, and creating networks of friends/followers on social media. I was primarily doing this for SEO &amp; marketing automation, but the same has been done on a larger scale to influence public opinion, spread propaganda, sway elections, etc. Scraping is obviously not as complex, but if each of your target sites are unique (i.e. not all running the same CMS framework), and you only want to scrape certain elements, then there’s still a lot of tedious work involved. There’s no way a single junior dev will be able to do this in a month or two. Alternatively if you only want the raw html for each site, then you don’t need to bother with maintaining selectors for extracting specific elements. This type of app could be done in a few hours. But I’m not sure how useful the output would be to you. 
+1 Username checks out
Realistically, clients can and probably should require people they contract with to use certain technologies. In your Oreo example, if Nabisco ever fucks it up you'll just start buying Hydrox until Oreo gets their shit together. However if the contractor's used some obscure framework (or worse yet, rolled their own) then they're going to be harder to replace and when/if you do then you're in for a long period of just randomly falling off cliffs that the new developer didn't know about because anticipating it required understanding what the last guy did to the nth degree.
Yes, that's the way I understand it. See http://docs.micropython.org/en/v1.8.6/pyboard/reference/speed_python.html
Yeah that was a my bad, good thing it is just a fake account! Thanks for catching that. 
&gt; I've seen some people charging around 120USD an hour for (rather simple) webapps, which seems like a lot as a 20 year old freelance developer from Germany - and then you have those overseas Django developers working for 12 USD an hour, but I don't pay much attention to those since I'm not wasting my time on Upwork and have always been marketing myself rather than relying on any platforms. What you're probably noticing is what's euphemistically termed "industry pricing," Basically that's when the price is affected by the client's overall buying power rather than truly by the supply or cost of production. In your example, the $120 web app might realistically only be worth $40 or $50 to most people, but when your client is a large newspaper or a large regional bank, they're dealing with such large volumes of cash that the differences between $120 and $50 are pretty minimal. The customer can tell the difference obviously but aren't likely to care and so the suppliers tend to go with the higher price.
I played both (started with bass) and I still think it's a fair analogy. Sure, they are both very different in some ways, but they are also very similar in many other ways. If you learn one, you are far closer to understanding the other than if you were a complete beginner. 
During a thunderstorm. With some blood around to lure in the sharks.
I get your point, but I don't think many would argue that intro courses should teach assembly instead of C++ so that students can learn the fundamentals. My background is in the physical sciences, not software. I remember something a professor said on the first day of an inorganic chemistry course that I took late in my undergraduate career. Basically: Without telling you, we've been teaching you chemistry up to this point that mostly applies only to the first row of the periodic table. This class is an introduction to the rest, which is a lot more complicated and interesting. Similarly, the physics curriculum still starts with Newtonian physics, even though we've known for about 100 years that that's only a useful approximation. It would be insane to start with the most fundamental things we know and work up to the simpler stuff.
Yup totally agreed. We also started with Haskell and I knew several imperative languages at the time. Haskell was a very good equalizer. 
It depends on the sites and data. If you need a single piece of text which is easily identified on a single page it would be possible to build in a day. 
You can compile python too with cython. Everything works... Just compiling normal python code will give it a slight boost but if you add type information you'll get additional speedups.
Interesting project, would love to read about it, did it boost your Seo? Why did you stop?
ith it better to teach thwimming by throwing thomeone in the deep end or in the shallow end?
I need several different pieces of information that can be saved for analysis later, and to ensure that they're accurate. The sites have some similarities but not all of them all well formed or even have the information. I guess it would be the dev's job to weed those out too
Went to the readthedocs site, and it says it's baswd on something PyARS. Followed that link, and that does seems to have Windows support. So you could try PyARS instead. 
Infrastructure for the scraper? It's an lxml parser that uses gets text, text_content(), and tail from different sites where it finds specific keywords then breaks it down into the structure I need later on. 
I've got the infrastructure for finding the keywords and information I need. I just need it to work for all or nothing. If they need to go into the source code, find those rules, and then somehow use that configuration for those specific sites, then so be it, I guess. 
Would be helpful to know what you’re trying to monitor. If it’s just request/response logs then the first thing that comes to my mind is define a single schema for your logs, use it across all your different backends, and deploy a monitoring service on ELK stack. I’m sure there are hosted monitoring service options that support polyglot systems out there too. 
Universities, plain and simple, are becoming more and more of a joke. It's really just going down the road of being a milktoast environment for people to perceive challenge without there really being one. If you make a program harder, fewer people want in. It's why you used to (still do in some cases) see so few people in things like chemistry, physics, cs, math, etc. CS is being dumbed down so hard and has been for years. It's part of the reason why we constantly hear/see CS grads not getting jobs, especially if all they have is the degree.
i m pretty proud i solved a tensorflow logging issue i mentioned a few weeks back (in which i couldnt seem to capture tf.logging.info() output to terminal). turns out, after probably 5 hours of subprocess.Popen() and PIPE tweaks and googling, i saw one person off-hand mention that tf.logging goes to stderr not stdout, contrary to other opinions. doh!! three characters of change and now i celebrate! ; )
I am working on an admin script that collects base info from our 1600+ *nix servers.. Ifstat , df, rpm, etc. But it has to figure out first the distro, then if virtual or physical then loads the commands from files executes them captures the output and creates a log file for each server and log the whole process.. 
This is exactly how I would imagine it would go, as well. A huge undertaking to build in the first place, and then you will constantly have a list of fixes that will just continue to pile up as time goes on. Sounds like something a decent sized team could undertake but way beyond one person's capacity. 
I think it's important that university teaches multiple languages. Functional, procedural, OO, dynamic, the whole gamut. 
As a guinea pig volunteer: Does it mean you can’t add an int with a str, or you can’t add either using a plus sign (I’d be surprised if adding integers with a plus sign doesn’t work)? In normal writing you could put quotes around the plus sign to be clear that’s your focal point. Following that method, as far as I knew, “+:” is itself some kind of operand, and my brain said this was no longer wordland. Two colons in one sentence probably didn’t help. Come to think of it I’m not sure an “operand type” here is a type of operand, and that’s likely confusing too. I suspect it means a data type supported by the operand, which is possibly paradoxical then to say that these are unsupported supported data types. I might try, with a bit of daring: &gt; `TypeError: unsupported data type(s) for + ('int' and 'str')` 
You might also want to check out Twitter accounts. They usually post articles that relate to a company too. Just an idea.
The REPL automatically calls the first when you use the second. Therefore in the REPL they are equivalent. However, most programs are not run in the REPL. If you run this normally only the first will print anything to the screen. The second is ignored. --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
They use similar examples to Russ Olsen's Design Patterns in Ruby which is what made 'Composition over Inheritance' really click for me. Would recommend even though it's a Ruby book.
My Dad threw me in the Atlantic
I learned C first, many years before I learned Python (actually before Python existed). So I do appreciate what you're saying. Python was almost effortless to learn after working with lower level languages. But for a lot of what I do now and a lot of what future pure-Python programmers will have to do, C experience isn't really relevant. You don't have to be a good mechanic to drive a car. You don't have to be a luthier to play the bass. And you don't have to understand low level memory management to write a Python app. I'll grant there are some cases where it might help, but more often than not if you try to "help" you'll just overcomplicate it and get in your own way. If you aren't aiming to do any low level programming, then C and its ilk won't help you as much as an equivalent time learning whatever you're actually interested in. And if you are aiming to do that, then Python is definitely an easier and more welcoming first step. Either way starting with Python doesn't hurt. Just the same way that they teach pseudocode as a way to outline the structure of a program, Python is like pseudocode that actually works. Overall I can't see any downside to starting with an easier language like Python.
We threw a fair bit of engineering time and talent at trying to develop generic scraping code that could handle any/most sites and we never got it to work well. You are talking about custom code for thousands of sites. Even if it were a few dozen, this timeline would be challenging for an experienced dev if you don't already have an architecture and infrastructure in place. We had a queue based system involving several moving parts for scraping, data extraction, multiple caches and databases, and of course actual analytics. It represented years of work including some pretty talented people.
CS is not a 'how to program' degree. And learning how to program does not make you a CS major.
Starting with pyhton let's people get their feet wet without first learning all the nitty gritty details of most other high-level languages (i.e. static typing, all methods need classes, etc.) With python you just code, and it's a great way to teach the basics to a computer plebian. Python first, and Java next. Maybe python for term one and then Java / C++ for term two. I think learning Java first would scare off too many students. My uni starts with python (for the first 4 months) and then switches to a "use whatever language you want (except PHP, perl, JavaScript, and a few others.) We are totally encouraged to pick any language we want.
In my opinion, this is spot on. Also, a lot of people never get past that "awful experience" and detest programming for the rest of their life, or avoid working with code. I've seen so many engineers waste countless hours in Excel because they can't code e.g. ```python for line in open(filename): print(sum(line.split(','))) ``` or some equivalent, simple processing. (source: not a software developer, but still write code at work)
Much easier to get a good job with a degree, if you’re looking to turn it into a career.
&gt; Ah yes, a "function". I was talking about a course that's the first intro to programming. So the first thing you have to explain becomes functions Not necessarily. You just have to explain that the program starts at a place called main.. just like a river has an origin somewhere.
In my estimation Python is a terrible language to teach "Computer Science" now a straight up programming class is a different thing. The reason I say this is that I have the expectation that somebody graduating from a Computer Science program will have some idea about how a computer works and that is far easier to explore with C++ and maybe a bit of assembler. In other words a computer science degree shouldn't be about teaching a programming language per say but rather the science behind the technology.
Sorry still can't see code.
I don't see it that way, first off a computer science program shouldn't be about programming per say but rather about the technology that underlies the industry. In that regard C++ offer plenty of flexibility to teach concepts related to computer science. Consider the trial of implementing a list in one of the early comp sci classes. You are seldom expected to implement your own list infrastructure these days, however to really understand what you will be expected to work with implementing your own in a language like C++ is very educational. I look at it as building a skills set one small brick at a time.
Don't get me wrong, it was a great experience. I loved programming in the language. It helps that there was nobody around to tell me it wasn't 'ideal'. For me (over 15 years ago) it was just what the class was taught in!
Yeah, I just noticed we haven't had a lot of progress in a while: https://github.com/tweepy/tweepy/issues/792
Please be mindful of [this](http://idlewords.com/talks/website_obesity.htm) as you read.
You think it’s bad in C, try learning Java first and having to put the main function inside of a class declaration with the main function header being “public static void main(String[] args)”. You have to get through most of the whole intro course before you figure out what all the boilerplate in hello world does.
I learned C++ first, and I would not change it given the option, as I think that having an understanding of what is going on under the hood regarding types, memory, etc is really helpful for writing good Python code. That said, I think Python is both more accessible and, in many fields, more valuable than C++ in terms of fluency and experience. I'm okay with intro classes being taught in Python, but I think it's really important to follow it with some C/C++ afterward to acclimate students to concepts that Python obscures in many ways (typing, memory management, complex scopes, various method types, etc).
maybe you could try fiverr or something. split the work into 10 websites or 5 per person. pay them 5... if the data always looks the same you would know whenever output is not what it's supposed to be. if you are not going to do it yourself youll need at least one person who fixes the scripts when they stop working.
Have you looked into [osquery](https://osquery.io/)?
&gt; Does it mean you can’t add an int with a str, or you can’t add either using a plus sign (I’d be surprised if adding integers with a plus sign doesn’t work)? Basically, yeah. It is meaningful to have int + int, as you know. It is meaningful to have string + string, too, but then `+` means concatenate, not add. Whoever it was tried to use `+` with a number and a string, the language doesn't know what to do with that. (Another language might have a rule that covers it.) &gt; “+:” is itself some kind of operand `+` is an operator. The operands are the things that `+` "acts on," on either side of the operator, which I think might help with your last paragraph, too. &gt; and my brain said this was no longer wordland. I think this is an important pedagogical point. When people who are new to this stuff see a sentence in terse, non-colloquial syntax with a load of technical jargon they are unfamiliar with, lots of them assume they're not going to get much out of looking closely (maybe rightly?), and don't try to hack through and interpret it. In my (fairly limited) experience, a surprising amount of teaching formal stuff to non-technical students seems to be getting them to have the confidence to try taking interpretive and intellectual risks, trying to understand what's written even if it's not immediately parsable, rather than simply assuming that they're not going to be able to deal with something unless someone spells it out for them entirely. 
Can you guess my age? The order of my programming languages I learned (I pretty much still use them except for Pascal, Bliss and Fortran) Basic Pascal Fortran Bliss C C++ Python Java C# 
I learned to program with QBASIC. After about a year of that, I tried C++ and I basically got nowhere and gave up. It took a few more years, and learning some Pascal, before I was able to understand C++. I was in elementary school when I started, but if I had to start with C++ I probably would have never figured it out on my own. This was also before Google, or even AOL, was a thing.
Yeah. Once you build out a Twitter script it's just about adding to the list of companies. I noticed doing that when I was trying to write a Twitter timeline.
I had to take a programming course at uni that was taught with C. I hated it completely, and nearly failed. Later in life I taught myself python. Now I love programming and have built a solid, incredibly profitable career and have written code in a variety of languages including C and python.
I learned C++ for 2 years in my High School computer science.I got confused, felt programming was full of mugging up, less innovative and the programs I did was boring By some luck, I decided to take my undergraduate in CS itself. I had Python in first semester, I loved the language for the easy syntax, Practicallity of coming with solutions (Usually most problems in C++ have one solution) and it's powerful nature. Now it has been more than 20 months since I completed my Python courses.But I learned much more on my own Python Web Development Using Django, Machine Learning and did some hobby projects also.All due to my Love for Python. Check me at: https://github.com/kurianbenoy
 $ pip install help Collecting help Could not find a version that satisfies the requirement help (from versions: ) No matching distribution found for help 
My Uni just switched all of its comp classes from c++ to Java. It’s been a rough transition for both teachers and students. 
This is more like "Is it better to teach someone swimming by first learning how human biomechanics work, the natural properties of water, and the physics of buoyancy, or to just let them ease into the pool directly." The former will take much longer, but prepare the swimmer for a much more advanced swimming career down the line, and perhaps even a run at the olympics. The latter will take much less time, but prepare the swimmer to not drown, handle most swimming-related tasks with relative ability (though not the grace or prowess of an olympiad), and to maybe rescue someone else who might not be as strong a swimmer from drowning someday down the line.
100% this. Learn the basics and start actually doing stuff ASAP. You'll learn by doing personal projects. Automate some tasks you often have to do. Highly recommend Automate The Boring Stuff With Python (https://automatetheboringstuff.com/)
Arnold C https://github.com/lhartikk/ArnoldC/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [lhartikk/ArnoldC/.../**README.md** (master → 3dd905b)](https://github.com/lhartikk/ArnoldC/blob/3dd905be59525f0b9a04e0baa6fd6acab09db8ea/README.md) ---- 
As long as you lean both what is the problem? Please stop all this "language fighting"
Automate the boring stuff is super useful. That's how I started and was quickly able to dive into projects after that. 
Good idea- I'll give it a shot. Thanks for your help!
I learned both. C++ introduced me to some concepts of C so that I could grumble to myself every time I touch kernel code about "how it could be better", but OOP *never* stuck until python. In fact, I would say that if you want people to be interested in programming outside of homework in class, using a language like python is more worth it. The big draw for me to python was the incredible number of libraries available. I didn't have to reinvent the wheel again like I did with C/C++, which meant I could speed up the concept &gt; pseudocode &gt; test &gt; prod process, which meant I finally saw the value in coding stuff outside of bugfixing. Now, I have several python FOSS projects I contribute to, and zero C++ ones. I write the majority of my work software using python as well, because no matter what the task is--middleware, GUI apps for nontechies, static sites, network automation--it can be done in python quickly.
So they'll just float?
YAGNI is so easy to use as an excuse for quick hacks that never get improved. Maybe "Minimal amount of code needed to use the library for the common use cases" is a better target. "Performs well on low end hardware" and "Code is instantly readable to drive-by contributors" might be better goals than "This library has hardly any code at all in it!" The reason to simplify a design is usually because developer time is limited. If your quickly thrown together solution is taking more time than a "You are going to need it" approach than what's the point? 
You can use `get` with a default value pers = p_data.get('personality', '') This returns the first arg, or the second if the first is not found.
Yes
Maybe a dumb question, but which is which in this scenario? Python is the kiddie pool and c++ is the 3 foot? 
Yep, though that’s few and far between. Most people on upwork just want X done. OP is essentially asking “should I do Django or RoR” type of question. That’s definitely two main stream choices. 
Personally I think C++ is a terrible language full stop. It is quite widely used, useful to know, and capable of creating wonderful things.
Yeah let’s usual casual racism instead, that will work 🙄 
Just a heads up, if you're using windows, you probably have to run "py -3.6 -m pip install kplr". And I think all macs ship with python 2 as their default so without changing anything in your path you'll probably have to run "pip3 install kplr". 
Quite frankly I don't give two hoots what the output is for two such trifling pieces of code.
Yes.
I'd have to ask which part was supposed to be racist. The Geordie part? The implication is that it's probably not useful information for a Geordie to have. Not that the Geordie is stupid or something. The Ugandan part definitely isn't racist. That is unless you view the implication that Ugandans have a formal government to be a racist idea.
True, I was mainly just responding to the categorical way you had phrased it in the original comment.
This may actually solve a problem we've been having with our bots in /r/TranscribersOfReddit. I'm at work, so I'll look at the code when I can, but can this tell the difference between user-uploaded captions and machine generated ones? That's functionality we need and haven't figured out a good way of solving.
You can always call a C module from your micropython code: http://micropython-dev-docs.readthedocs.io/en/latest/adding-module.html The other option is to use inline assembler.
Immutable tuples are read-only, which prevents code from accidentally modifying them (or rather, raises an exception if you try instead of silently doing it), so it can prevent bugs. Tuples are also slightly faster to work with and use a few less bytes of memory (this only really matters if you're dealing with large amounts of data though, so backend devs need it by network admins not so much). I think modifying the grammar to make variable swapping just syntactic sugar would be kind of kludgy. It's simple enough for the case of a,b=b,a but remember you can have any number of variables: a,b,c=c,a,b or a,b,c = d,e,f or a,b,c=x, *args or a,b,c=some_list_with_3_elements or whatever. Reusing the tuple unpacking mechanism makes sense rather than complicating the grammar of the language. I'd rather just swap variables using a temp variable before doing that.
How can you do that I tried Tkinter then I switched to ElectronJS because you cannot make Api calls in Tkinter
They are very similar, but slightly different as the REPL calls `IPython.display.display(a)` on line `In[3]` above, which may slightly differ from `print` in the formatting. E.g., if you had a longer list: In [1]: a=list(range(23)) In [2]: print(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] In [3]: a Out[3]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] In [4]: from IPython.display import display In [5]: display(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
I was thinking it might be (maybe not useful) a way to see what the articles are about in general though no? that graph database looks pretty interesting. do you have a site or something that I can see it at work? 
What were the most popular 3 or 4 other languages?
I do that at my work, hos is it a PITA? You can define bitfields with ctypes and live very happily.
At night. From a plane.
Its mostly just "load and analyze," I'm not directly manipulating what I'm loading. Thankfully, I found a way to insert the missing values.
The first two checks in `_update_db` are exactly the same. check = (self._current_track_record is not None # &lt;-- and self._current_track_record is not None # &lt;-- and (len(self.database) == 0 or self.database[-1] != self._current_track_record) and self.is_playing()) 
Oh, this is _fantastic_ news! Thank you very much, I think we definitely have a use for this module. Thanks!!!
1: read the sidebar 2: post in /r/learnpython 3: you should be using a text editor or IDE and saving your code to .py text files.
haha. A typo that doesn't affect the logic of the check in the least. Oops, sorry about that. Thanks for pointing out the error. Fixed in both the post and the code sample :)
"Simple" is a bit of an understatement here. No offense, but this is basically useless to anyone. From a pedagogical standpoint, I am sure you learned a lot while making it, but from a utility standpoint, you didn't add anything other than prompts to request. Speaking of which, I am not super familiar with requests, but considering the following: request.raise_for_status Is that supposed to be a function call? (ending in `( )`)? Unless requests is doing something super anti-pythonic, this is doing nothing. Also: for chunk in request.iter_content(100000): fileHTML.write(chunk) While this works, upon looking at the [API](http://docs.python-requests.org/en/master/api/), this is setting the first keyword `chunk_size`. While that does work, it is against the python idiom: &gt; explicit is better than implicit Upon first read, before looking at the API, it was not clear what this number was doing. One final tip. While in an ideal world, you wouldn't have to worry about python2 vs 3, your code will only run as you expect on python3 (based on `input`). I would add: #!/usr/bin/env python3 to the top. It will still fail if someone calls it via `python` but it at least makes it more clear what this is designed for. Ok, one more thing. This would be better demoed in /r/learnpython
https://mail.python.org/pipermail/python-dev/2016-March/143603.html Hehe
Please let me know your feedback if you used it ;)
I learned C++ first by a long shot, then wound my way through various languages before settling on Python. Learning and embracing Python 6 years earlier is something on my todo list if I go back in time. Python is better for expressing computation. C++ is good for manually managing resources for things that need to occur in realtime. This isn't most things. I wasted so much time as an overwhelmed mediocre C++ programmer. I wish I was learning and solving *more* problems, instead I was trying to throw in every feature (junior mistake) and debugging memory errors. Solve your learning and algorithmic problems in Python, use the extra mental capacity to learn Rust or Haskell. 
I can't count the times I've typed: public static void main(String[] args) { } I agree with you. (BTW in py3 it's print("hello world") )
I'm sorry, but I think you're living in the past. I started on basic, then assembler, then Pascal, then C++, then as much C and C++ for work, then Python. There is no reason to start in anything but Python. Programming is about communicating your ideas to the computer as simply as possible. No one should have to care about null pointer exceptions and extern linkage. There is no justification except historical ones for writing big projects in C. Even Google who needs all the speed in the world writes most of their code in C++. Also, the feature of template classes is terribly designed. It leads to barely legible code and is too limited. Python did it right.
But they also have the opportunity to expand upon their knowledge. 
Tuning a script to analyze an audio stream from a webcam we use as a baby monitor, to send an SMS message when it detects the baby crying. Fourier Transforms and Twilio!
This! Programming is a meta skill. The various languages have their advantages and drawbacks. But if one has understood the fundamentals then it's easy to pick up another language. Anybody who sticks to just one language probably doesn't even deeply understand this one. I learned C first (before Python existed) - but I do think Python makes sense as a first language. It's a great language and very productive. And doing python stuff establishes good practices (e.g. use standard high level collection classes). If one is serious about programming add C later. And it compliments Python in cases where Python is too slow. And the contrast and complimentary strengths of both languages teaches a lot about programming and how computers work. 
For reddit, [Praw](https://praw.readthedocs.io/en/latest/) is really good. I've made some stuff for Instagram with requests + beautifulsoup but you have a quiet interesting bot [InstaPy](https://github.com/timgrossmann/InstaPy) Other than this... I also used tweepy and actually as I often just play with little things I use requests + beautifulsoup a lot
If your re talking about rest micro services, you can make very simple requests (with requests) and assert the response to test all endpoints. Then run the script periodically and record the results and possibly notify something if something wrong happens. I do this with a couple is .net micro services we have. I trust Python way more than I trust .net. 
This project is absolutely mind blowing! I love it! If i can contribute please show me how!! I've been looking for something like this for ages. Thanks for your effort and the great introductory video.
I'm probably more with OP on this one. C/C++ taught me things about underlying architecture that I don't think python alone could ever have done. That said, there are some compelling arguments in this thread. I think that maybe using python to teach you *logic* in a sort of mini course would be wise, before throwing someone into the deep end of C.
&gt; Brainfuck A valuable introduction to pointers. &gt; LOLCODE Meme references keep millennials engaged with the material. &gt; fetlang Great for interdisciplinary studies with the English department! I only see winners here, try again. /s
I wish they did this 10 years ago! We got a Java crash course during Masters 10 years. Undergrad, it was C and C++ which was a lot to grasp. I ended up in the library learning HTML and JavaScript instead. This was 17 years ago!
C++ didn't replace C and C didn't replace Assembler (though it comes close :) ). And for good reasons (there are still valid reasons to use all 3). Cards are gone though - also for good reasons. ;)
I found that more worthwhile than this submission's article... thank you!
/u/asciiascetic_ , No problem, I enjoyed the article and just wanted to mention it so it could get fixed. Also, using `enumerate(self.track_list, start=1)` would allow you to get rid if the `i + 1` for each iteration in the `tracks` method. One question though, is there any particular reason why you use `type(track) is int` instead of `isinstance(track, int)`? 
Assembly is not a prerequisite in order to understand algorithmic complexity. Assembly is important if you want to build compilers, bootstrap an OS etc, but it is a mere curiosity for everyone else. It is more than enough to understand it conceptually. 
In the winter. 
old habits die hard I guess
It looks like you wrote a lowercase I instead of an uppercase I. This has happened 5882 times on Reddit since the launch of this bot.
Thank you null3 for voting on Yasuo\_Spelling\_Bot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
I think it can be argued both ways. Learn C first and you appreciate all the tedious stuff that Python does away with. Learn Python first and then marvel at how C let's you get very close to the bare metal of how a computer works (while still being luxurious compared to Assembler). In the end people differ and a lot depends on teachers. But in general I'd recommend to start with Python because programming throws a lot of abstractions at you at the same time and many people will get overloaded by C and it's toolset. Then later one can do a module in C and hook that into a Python program to get extra speed and build in that - gradually deepening understanding if what's going on and why different tools are best for different tasks.
What a terrible idea. How will the learned professors explain to their students about some of the more unhappy events caused by using c++, e.g. the infamous BSOD?
But what about tuples that contain tuples...are they immutable?
When you're looking at a stack trace, you will indeed see the code with the incorrect addition. It's not as explanatory as your post, but it's also not missing that information.
Python is not that easy when you dig deeper
&gt; it's probably not useful information for a Geordie to have. Not that the Geordie is stupid or something. That's exactly the implication, mate. Otherwise Geordie would be interchangeable with Londoner or anybody from a city that it's not in Uganda - except that sort of expression is never *ever* used with "Londoner", is it? It's always geordies, scousers, mancs, essies and so on. A Londoner might well be interested in foreign affairs; a Geordie simply couldn't, perish the thought. I know it's hard to recognise casual racism and class hatred when one has been surrounded by it for a long time, but that's exactly what it is.
Machine learning is definitely not an overkill! I think linear regression can help you here.
By "replace" I meant as "base" language of choice in universities. 
I don't think that a student's learning will be dependent in any way on the language chosen, it will be on the course(s), teacher(s), and materials used. The language doesn't, or at least shouldn't, matter. ... to an extent. There are some fringe programming languages, but at least any of the top 10 languages should be fine.
You extolled your teaching of a "short C course to familiarize students with the low level, close the iron aspects of programming." I am saying that that is a bad way to start a computer science degree in my opinion.
Either install it as a user: pip install --user bs4 Or install it as an administrator: sudo pip install bs4 --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
I'd say most people knew java, Scala, C, JavaScript with a combination of python, lisp, prolog, c++, vhdl depending on the classes they took.
It’s a uni in Victoria, Australia. I believe the professor sets the language and the OOP professor likes C#
Oh wow thanks a lot! Ill delete this. Appreciate it!
I think he meant it more to get students familiar with how pointers and the stack work than ACTUALLY writing programs in it.
Python isn't a program. It's a language.
Nah you should send them into the maelstrom of 1’s and 0’s with logisim 
Some people have yet to drop Python 2, meanwhile we are living in Python 4.
Why would they? If Python 2 is good enough for their projects why switch to 3,4?
☑ Worthless variable names: `user_input`, `user_input_two`. ☑ Not knowing how functions work: `request.raise_for_status` ☑ Claiming that everything works as expected even though it clearly wasn't tested for when the page is invalid: &gt;Also it works as expected for me so I don't see how it is useless. It downloads the html and sends it to a file as expected. ☑ Thinking that HTML pages will ever be huge (I mean, we are speaking in 10MB max most likely, I never saw that big anyway): &gt;Plus if I don't set the chunk size then what do I do for huge files that will eat up memory ? ☑ Arrogance: u/PythonGod123, &gt;Thanks for attempting to destroy me. ☑ Showcasing what internet explorer 6 is able to do with a simple rightclick on a page. I'd suggest you actually read the post by u/jwink3101 again and think about it, instead of acting like an idiot.
And just in case: REPL stands for ["Read-Eval-Print Loop"](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop), because when you're using a Python interpreter in the interactive mode like this, that's what it does: the interpreter is just carrying out a loop where it reads some code you typed in, evaluates the code, and prints the result.
**Read–eval–print loop** A Read–Eval–Print Loop (REPL), also known as an interactive toplevel or language shell, is a simple, interactive computer programming environment that takes single user inputs (i.e. single expressions), evaluates them, and returns the result to the user; a program written in a REPL environment is executed piecewise. The term is most usually used to refer to programming interfaces similar to the classic Lisp machine interactive environment. Common examples include command line shells and similar environments for programming languages, and is particularly characteristic of scripting languages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/Python/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Why would they use Python 2? Cobol is good enough for projects.
No no no. fuck their mind up with MindFuck.
Yes, it is!
I think it would be easier for students to learn python if they don't know anything about it. Python can be used to do a deep dive also so you have something that's easy to pick up and something that can be used deep.
Well, when I was learning python, my first scraper that downloads all images from a given website, keeps history of things it downloaded so it can resume even if it crashes and etc took me 2 days. Now since they are beginners, let's say they'll take around 10 days. It's safe to say that it would take 60k days minimum for a single programmer.
&gt;python2.7 And old, and nobody likes you.
Name is fitting..?
So am I right in assuming you want to join D and A, and then write the result to the path? try doing just that, use a merge, join, or combine method and call output = D.combine_first(A) output.to_csv(master_path)
Noting that I'm more familiar with the pandas library, and I'm assuming that FILEIO functions are similar
If you want someone to become a great programmer, they will _eventually_ need to learn C/Java to understand the underlying structures of what they are doing. Starting with simple syntax (like Python) is good to get them moving with the field, and understand how to write good code. As long as you have advanced courses that start to dive deeper, I think it's a solid approach. You don't need to understand _why_ your body moves the way it does when learning to run, you just need to learn to run. Later on, you can learn about biomechanics and how to do it more efficiently to become a faster/stronger runner.
I started of with C. Not sure how close to the metal you can get without writing in assembly.
This is Brandon Rhodes' site, so you know the stuff is legit
I regularly work with ~TB scale numeric data, and this is the right approach. To actually compress it, I do three things (via NetCDF / HDF5 file storage options): 1. Break the array into chunks, between 400KB and 100MB each (depending on whether disk or memory is limiting you). This preserves data locality and reduces memory use during analysis - and compression! Later steps are applied to each chunk in turn. 2. (optional) If you don't need full precision, cast to a smaller kind of float (half-precision is a thing), or better yet an integer type (the disk format will conveniently record your scale factor, offset, and magic values for nan/inf/-inf; and IO libraries can apply it automatically on read). 3. "shuffle" the bytes of your data, so (for single precision floats) the first quarter of the chunk is all the first bytes, the second quarter is the second bytes, etc. This makes compression super effective for numbers with similar magnitude. 4. (optional) Apply a general purpose compression library, usually gzip. This can be good or *very* bad for read speed later, depending on the data, but it's always good for size on disk. 
Old codebase?
And, as I was trying to say, a lot of people could benefit from knowing how to write simple scripts or GUIs to automate their daily work. Those people never were remotely interested in CS, they just want to get stuff done. I learned programming while studying physics myself - CS or IT was never my endgame, but programming is still very useful to me.
A lot of people taking intro cs courses don't need to understand the underlying structure of how programming works. Save that for upper level courses.
I think it's fine to start with Python, but if you don't teach C or something like it (C++ being a good choice) you are shortchanging people. Just like how teaching Doctors biology but no chemistry would be shortchanging them. 
I tried starting with Python but it was hard, honestly. Why it behaved the way it did, what object oriented actually was useful for, or a host of other minutiae questions I can't relate anymore since it's all second nature now. After about a year of Python I then learned c++. Let's just say that in 3 months of c++ my eyes were opened and programming just made sense. I then could use Python effortlessly and understood what was going on in the background. It also allowed me to pick up Java with extreme ease. So as a data point of I one, I say C++ is supremely valuable if you want a career in programming so that you understand what the heck is going on. Now to those who want to go all nuts with even lower level languages I argue against it for a very good set of reasons. You won't gain anything for one, as the concepts of C++ encapsulate the simpler logic of lower level language and eliminate the repetitive and verbose complexity that occurs beneath the surface. Lower level isn't necessarily more advanced, it's just closer to the hardware and harder to read. And c++ compiles so you get excellent speed of execution. You really only go below C++ level when you are forced to write firmware. 
Python hands down.
+1 for both counts. even though the 4th quote char has no effect, it has to be there by accident because even though all it does is add a quote mark to the start of the string, a matching quote at the end of the string would be expected. And one doesn't "decrypt" cleartext. 
This. Or at least to the extent of what I think a study of computer science should be starting with. That said, a general intro to "programming" need not be computer science specific as it is bound to be taken by any number of other degrees, and to that end python is by leaps and bounds a better teaching tool than C++. There's also nothing wrong with having a lab-section specific to CS students that focuses on learning C in parallel. My first year CS curriculum involved learning and using 5 different languages for various classes, not counting the mini-assembler-like language used on my professor's custom virtual machine for the first 6 weeks of his operating systems class. I'd argue that choice of language for the intro to programming class doesn't really matter that much because by the time they're taking a class that takes a deep look at the low level bits of programming, they should be expected to pick up an appropriate language suitable for studying that topic in detail. I rather find it a disservice to CS students to have a program of study where they aren't expected to learn new languages on a dime.
I learned Ruby first and then Java second. By the time I had to declare access modifiers and types and import libraries I already had a strong understanding of those topics. That seems better ather than being beaten over the head with everything at once just in order to "hello world". Also it helps only working with a couple data structures to begin.
I think as a way to learn some of the basics of Python i would consider writing your data to a file. That way you can have data that persists even when you turn off the program. I think the absolute easiest way to do something like this would be to: 1. Create a dictionary that has win's, lose's (which both will start at 0 on the first run) and each time you have a win or loss you can update that dictionary. 2. Add into the dictionary a 'streak' counter. There are a ton of ways i can think of to go about this. I would say to go ahead and try making one and if you need help or hints to ask. 3. Use the *pickle* library to write your dictionary to a file and then to also read the file. Doing this will let you keep your data in a dictionary without having to worry about reading or writing into and out of dictionaries. It kind of works by magic. https://wiki.python.org/moin/UsingPickle Let me know if anything i wrote about doesn't make sense!
They are similar for all intents and purposes, but not exactly the same. Think of `print()` as of exactly what you would do in a full-fledged script so that the output gets printed to the terminal. That's what `print()` does, both in the terminal and in Jupyter notebook. But given the visual and exploratory nature of Jupyter, they went further. If you simply write the name of the variable, it will often format it pretty for you: [example](https://i.imgur.com/PpRWlm7.png). It does it because it can. But keep in mind this is just a special use for interactive python.
Some differences: * supports more schedule storages. * has less overrides default celery beat behaviour * schedule storages can be easily extended
This looks great! I don't really know how to make a dictionary but i'll look it up. so far my best attempt to it was something like this win=0 loss=0 def win_loss(x,y): win+x loss+y return win,loss but this doesn't save the value for the wins and losses for the next action but i'm guessing thats where the dictionary comes in so im gonna look up how to do that. I also talked to someone and they recommended defining win and loss as global but im not sure how to do that. Thanks for the help!
Awesome! The genre component of the API would be useful for classification, as you can use it to train a classifier to recognize whether a song or artist is hip hop, country, etc. Let me know if you end up using the API in any of your open source projects, I'd love to see what you do with it!
Oh haha yea i'll check out the /r/learnpython page sorry and thanks for the info!
dictionaries are very very simple stats = {'wins':0, 'loses':0, 'streak':0, 'best streak':0} print('first: ', stats) stats['wins'] += 1 # cause we won a game print('second: ', stats) which outputs: first: {'best streak': 0, 'wins': 0, 'loses': 0, 'streak': 0} second: {'best streak': 0, 'wins': 1, 'loses': 0, 'streak': 0} you'll notice that it doesnt keep the order consistent from how it was typed.You can either just fix that by having it print each piece at a time, or you can explore the ordered dictionary module which is here: https://docs.python.org/2/library/collections.html#ordereddict-objects
That sounds like it would be pretty cool although i feel like im pretty far out from figuring that kind of stuff out though. Thanks for the information though! I'll have to save this so i can refer back to it.
This helps a lot, thank you.
Could you elaborate a bit on cython, please? This sounds like something I could use.
I just implemented the custom exceptions! This is a lot better than the basic try and except setup that I had before and hopefully it also saves time catching errors. Do you have any further suggestions? You've been a great help so far!
If you're using create react app there's a documented option called proxy, basically you can specify that some routes will go to the backend (on another host or port). Even if you're not using check it out, since it should what packages are being used to do proxy, so you can probably implement it in your setup. Let me know if this helps
That was exactly my problem with C++. You can't just take over someone's code unless you knew them personally, you generally had to rewrite the whole thing. There's too many concepts, too many ways to do the same thing. 
How do I invalidate the cache for variables such as name? I've had this problem before but didn't pay much attention to it, thanks for spotting it out!
I tried typing this out in a terminal and it works! I'll have to check out the pickle library that you mentioned so that it keeps all the data saved. Im just pretty happy about the basic function. Reason I was wanting to work on something like this is because I play a game called rocket league and I always seem to forget what my w/l record is for the night and instead of just dong the standard pen and paper I thought it might be cool to try it out this way! Thanks a lot for the great starter, ill continue to work on it and figure out how to polish it to be a nice little GUI and stuff
Security updates stop in 2020 so its a pretty good idea to upgrade by then.
Watch this: https://www.youtube.com/watch?v=2Op3QLzMgSY It's a shame they don't teach it in scheme anymore
They remain immutable because the references do not change. Even if the reference is to a mutable object.
I can not believe you have written all this, that's soo cool. After I asked this question I made a research and found this: https://stackoverflow.com/a/11134772/7582969 Almost what I wanted, but too complex. I'm writing a DBMS (for fun) in Python, that's why I need a parser: https://github.com/jvitoroc/pyngo.py So, I need to eval these expressions (e.g "completed=True"). I have to do the following: name.setParseAction(lambda t: ''.join("data['", t, "']")) # "completed=True" will become data['complete']=True Then I can use the eval function to evaluate the expression at https://github.com/jvitoroc/pyngo.py/blob/master/classes/Collection.py#L27 Sorry for my english, and thanks for the response. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jvitoroc/pyngo.py/.../**Collection.py#L27** (master → 70aba71)](https://github.com/jvitoroc/pyngo.py/blob/70aba71f501a33c056b31162971e2963f1fe2a02/classes/Collection.py#L27) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtumy48.)
Ah I love rocket league. And you can just let the program run on the side with a continuous loop. That would let you type a w for win and a L for loss (or whatever you want) then you could have “quit” to close the program and update the file. It’s petty similar to a classic starting problem (guess the number) so it shouldn’t be hard to find example code 
I guarantee you that if we switch to a mandatory sink or swim method, we will eventually reach a point where 100% of adults know how to swim.
Because all the others would've been dead lmao
Mathematical complexity, perhaps, but on target, not at all. If you use a function that doesn't behave in a way you understand, then your perfect comp sci understanding of the complexity of a task goes out the window. I am not arguing to teach algorithms in assembly, I am arguing that a well rounded education, over multiple subjects, better prepares students for dealing with unforseen difficulties in their work. Or, we could all hyper specialise and end up incapable of broadening our horizons when we decide we are fed up with web programming :-)
I didn't say the outcome would be pretty XD
"DON'T PANIC! You are still able to import your legacy code into Python 8, you just have to rename all your modules to add a "_noqa" suffix to the filename. For example, rename utils.py to utils_noqa.py. A side effect is that you have to update all imports. For example, replace "import django" with "import django_noqa". After a study of the PSF, it's a best option to split again the Python community and make sure that all users are angry." huahuahua
Yeah its a great game, going to try and make a push for diamond in this new season that comes out. Thanks again for the help!
In new tools, yes!...
Yeah, I should have shown using bcrypt or at the very least obfuscation with a creds file... instead of just mentioning that it should be done. I can update the post. Thanks for keeping me on ball.
I had an identical experience as an ME who now works in tech.
`np.matrix` is a 2D array of data values which can only be of `dtype`, i.e. numbers. Numpy is complaining that you're trying to assign other matrices to these numerical slots. What you're looking for is probably `np.ndarray` which is the n-dimensional equivalent of a matrix.
Can you explain how you made this? I'd like to do something similar.
You're thinking of assembly. 
Assembly would be in a sack with some heavy rocks added for good measure
We'll just have Python 2, Python 3, and Python 4 to support, no problem. Who needs backwards compatibility? Just rewrite, rewrite, rewrite!
I started on Java and Python. Kind of wish I started with C or C++, as the magic that some languages do can cause learners to create inaccurate mental models of what's going on. It might be faster to get people up and running, but good things take time. 
Thanks for making it. I’ll look out for your other posts.
I learned Python before starting a C++ class this semester. So far it has been smooth sailing since I understand the logic of everything. I'm really glad I took a Python course before taking this class. C++ is also strengthening my love for Python. 
dude. bro. lmao.
That's how I learned. Although, having done it and now having two kids of my own, I really cannot recommend it. Despite effective results. Whatever happened to starting with Basic, then learning about real languages?
Rust/Haskell or Java/Kotlin is better. Python hide too much. C++ is too complex and should be in level 2 or level 3 prog courses. You can pick up Python in under a week without uni degree.
Same here. Except the first half of the Sem was Haskell, and second half Java. Loved learning Haskell, hated Java (took me ages to wrap my head around it). Also learned a bit of VPython in first year physics for visualisations.
Thanks for this! It's a good read. 
XD
 &gt;like the "data scientists" coming out of these chop shops without knowing the fundamentals of stats What are those?
Started with C++, then C# and VBA on a work term, then C, and worked with other languages in undergrad, like Matlab or Labview. Back then, even though I understood it, I didn't really like programming; it just seemed so tedious. I still wrote an OS, turned an FPGA into an MP3 player, controlled robots, etc. If I didn't specifically like robotics, I don't think I would have continued doing anything with programming for long. Ever since I learned Python, I've been doing it for fun, for work, to help others and automate my life (and others'; I've put some people out of a job.)
I’m 16 years old and I’ve been learning to code since I was 9 or so. My very first program was hello world in Visual Basic. I then moved to C++. I’ve quiet literally experienced starting with both because I lost all programming skill for a few years. What I remember from c++ was that it was less of a quick and easy keyboard to product language but that it had real power. Python is sort of the opposite. It has power also but it’s very easy to type (click click on a keyboard... not ints or floats 😂) something into the shell and immediately have an outcome. Python was a much easier first language for me. 
Cool. You use scraping not api of coinmarketcap.com? If you use scraping you should use SoupStrainer('div', {"class": ... to save on memory(!)
From a pedagogy point of view, python eases you into programming, may reduce drop out rates and incentive learning because you don't have to worry about brackets, pointers and it seems easier to read. That is not to say it will be easy, there are plenty of tricky problems that are challenging on any language. Source: I started with python and moved on to C#, the hardest part for me was to get used with brackets and namespaces, the basics are the same. Albeit, I am not an expert in neither.
Run through this: https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python/blob/master/README.md EKF is Chapter 11, but you'll need the background to build on before that.
Cool. I like that it is responsive -- so far atleast. Responsiveness is basically the only other reason i don't use those other fancy repl's. Not sure im such a fan of the red coloring of json keys though...
During dolphins mating season 
`pip install --help`
I would say python ---&gt;C#---&gt;?(C++ or C) 
this is a great explanation
ill have to Google this.
I did my intro with Java - almost made me quit college.
Great stuff, I was about to embark on something like this. Going through the Python for Data Analysis 2ed atm and this data will be handy to play with.
The website you're on used (uses?) bottle.py on the backend. It's tiny, simple, and fast. My favorite web framework. I highly recommend it.
Lisp is worse..? Are you serious? You can write a Lisp interpreter in 50 lines of Python (http://norvig.com/lispy.html). It basically has no syntax. I think every introduction to programming course should be done in Lisp, then move on to languages like C (to understand low level implementation details about physical machines) or Python (to gain access to amazing libraries and ease of implementation)
Thanks. I'll check this out.
This is just my personal opinion but I would go with a LEMP(linux, nginx, mysql, python) stack with flask and Gunicorn but obviously if you do full stack development that more then just python practice. Check out [full stack python](https://www.fullstackpython.com/table-of-contents.html) if your interested. It also has a part where it explains a lot of python's web frameworks with a little bit about why you would use each one.
Very nice. Do you plan on sharing your code at some point? I'd love to take a look at it. 
Are you site scraping or using an existing module?
Cobal it is then 
exactly what I was looking for. full stack.
I've been playing around with [Dash, from Plotly](https://plot.ly/dash/), a lot in the last couple of days. It's a nice framework for building little dashboards and apps, with a really decent deployment [how-to](https://plot.ly/dash/deployment). Good for a small project. 
&gt; now Agreed. I wasted so much time learning C++ without really accomplishing too much. I wish I found Python way earlier.
Sometimes you have to break things in order to fix them.
Are you teaching them to code or are you teaching them computer science? If people just want to do Python, JavaScript, Ruby, and PHP then that's fine. Don't teach them operating systems, network analysis, finite automata, compilers, assembly, and computer architecture. Honestly you don't need to know any of that if your job is high level and teaching a web developer how multiprocessor cache coherency works is a waste of their time. But if your University is trying to teach computer science then they should learn C or C++. A lot of universities choose to train students in the former but, as a computer engineer working on embedded systems, I personally prefer the later.
My first programming course ever was C++ in first year university (went for IT, before switching to a mixed multimedia program). I absolutely hated it, couldn't figure out pointers or class logic and ultimately never wanted to touch programming again. Fast forward a few years and I've since picked up a number of web languages, Flash ActionScript and C# in Unity and was having fun because I could get results. My point here is that learning Python is better as an introduction because you can actually do something with it more immediately. C++ is a beast better left for intermediate to senior level courses.
you will probably have better success looking for juputer notebook
Trying to get my life back together. Got dumped recently. Trying to make a Django + D3 dashboard to get away from the pain
I am using APIs like coinapi, the problem is I can only get one coin a day. I have no idea how to scrape historical data. I have just been writing APIs to a mysql db
I like your analogy but it really doesn’t answer his questions lol
You mean you are not directed to the stackoverflow question where I have posted it? If you are reading in the mobile app, just clicking the question won't work so there is a button below the question to the extreme right. Please try clicking it. I had no idea about it as I use reddit in my laptop. Sorry
What is that for calculation? 10 days to build a scraper? Not even the first for a beginner and after 20 builds you do them blindfolded.
Are you coming from 2.7? Your statement is using `print` as a statement and in 3+ it's function, so it's doing `print ('price:%.8f time in seconds:%.8f slope: Calculating')` which returns none and then trying `% ((float(lastPrice)), (float(calendar.timegm(gmtime()))))` hence the error. Try `print ('price:%.8f time in seconds:%.8f slope: Calculating' % ((float(lastPrice)), (float(calendar.timegm(gmtime())))))`
I dont have a huge amount of experience in CSE classes, but from what I have had to deal with, it seems like there is a lot of handholding going on. I am a grad student in an undergrad second semester Java class right now (that i had to take for credits) and it blows my mind how much "help" is going on. And frankly, a lot of the time it seems like the "dumbing-down of things" in the end makes concepts more complicated because it adds another level of separation from how the content is actually described. I understand that programming nowadays is everywhere so there is a desire to make it more accessible but part of me wishes they'd start you off in terminal, introduce you to notepad (emacs or vim for the coureagous), and build from there instead of dealing with IDEs. Python makes sense to learn first because of how accessible it is but IMHO I think theyll end up with a bunch of codemonkeys who have only an inkling of understanding of what is going on under the hood,instead of real programmers. Sink or swim. Also, just to clarify, I have no problems with Python. It is awesome that it is that easy to pick up, but easy isn't always better.
The problem is, rendering sheet music is an opinionated domain, and it requires a sophisticated solution to do it properly. No such pure python module exists to my knowledge. At times like these, it is necessary to run programs outside of your python process, and call them at the system level from your code. [LilyPond](http://lilypond.org/) is a program that can render sheet music from MusicXML files. This is not a python program at all, but there is a python library which provides [the appropriate bindings](http://python-ly.readthedocs.io/en/latest/) so that you can [call to LilyPond](https://docs.python.org/3.7/library/subprocess.html#subprocess.run) from within your python code. Your solution will require that LilyPond be installed on the system as a dependency. In your code, you will need to: * Convert MusicXML format to LilyPond format * Recognize measures, since that is the division you've chosen to use as the basis for your excerpts. This is likely going to actually be a slightly novel problem to solve, as I believe LilyPond files do not require explicit representations of measure divisions. Rather, they are imposed at the time the staff is rendered as a function of note duration and time signature. * Extract the measures based on some parameter that you have not specified-- presumably user input, or random, or rule-based. * Save the extracted excerpt to disk * Call to LilyPond to open the excerpt * Call to LilyPond to export the image of the excerpt Once you have converted the file to LilyPond format, I'd recommend using [Abjad](http://abjad.mbrsi.org/index.html) as a means of analyzing the music for measures and manipulating/extracting information from the file. As I mentioned earlier, it doesn't seem to have a direct concept of measures, so you may get to have the fund of defining measures by reading note duration and calculating what constitutes a complete measure, as that data may be absent from your file. 
sublime text popups so many unnecessary errors for built in module better stick with Jupiter nb 
Wow, this is so cool! 
Speaking as someone who used to do PHP professionally and did Python web dev on the side in my spare time... Which do you prefer when doing a web app in PHP? Laravel or Symfony? Lumen or Silex? Do you want something to hold your hand and force a project structure upon you, but give pretty much everything you need out of the box (Laravel/Symfony)? Or do you prefer to have the bare minimum you need to get something running and want ultimate flexibility (Spark/Silex)? If you want an opinionated framework with all the bells and whistles included (like Laravel or Symfony), Django is what you want. If you want a microframework that's very flexible and minimal (but still has a great ecosystem and is easy to extend) like Silex or Lumen, I'd recommend Flask. I personally prefer Flask set up behind Nginx with Gunicorn (think of it as PHP-FPM) and some kind of database server. It's super easy to get a REST API going and you only pull in what you need. There's even a flask-webpack module you can include if you're a fan of Laravel 5's included webpack and Vue integration.
&gt; I develop in php usually but want to take on a small useful project to get some more python experience. Anything that would be a small useful project in PHP will also be a small useful project in Python.
Sure, but while I am considered by some to be a proficient bass player, I'm a noisy, sloppy guitarist at best.
You might not hear us, but you know when you don't feel us.
I started with BASIC. Much better to learn the principles there than in C/C++ with so much to get in the way of "doing what you want." More a software engineering approach than computer science.
This is a math error, not python. You forgot the order of operations. Try this: check = hrs * (rate - (0.12 * rate)) --- If you have more questions like this it's better to post them on /r/learnpython. Be sure to [format your code for reddit](https://www.reddit.com/r/learnpython/wiki/faq#wiki_how_do_i_format_code.3F) or use a site like pastebin. Also, include which version of python and what OS you are using. 
I would probably use jupyter notebook if you're just playing around, the notebook is handy for that sort of trial/experimentation.
Thank you very much for this! 
Thank you so much, sir!
else: check = hrs * rate -(0.12 * rate) is subtracting 12% of the rate, not 12% of the total money maybe you need more brackets?
I don't know whats better in ConfigBase if we have builtin ConfigParser :(
Started on python before university. When I went to university they taught the intro class on python for the very basics. After that it was straight into c++. I honestly dismissed python initially as I thought it was super basic and not used for much other than teaching core concepts. C++ was great to learn pointers and such. Recently I have been digging back into python and it's nice it can do so much of the with for you but unless you learn a language like c++ you really can't appreciate how much it does. Programming is a mindset, not only knowing the syntax of an arbitrary language. We must learn to break down problems into smaller and smaller problems and solve them. Python is exceptionally well used in this regard at my university. Anyway, I could add more but I'm on mobile so reddit is hard right now lol. 
Look into `@property`.
What have you got so far?
I have seen this style in some scripts. Do you think it is better without the comma? 
Breakpoints inside your IDE are also wonderful. Embrace conditional breakpoints and step-debugging for unmodified code.
Wrote [my first blog post](https://bheklilr.github.io/2018/02/06/runtime-type-checking-in-python-3.6/) tonight, and I'm working on ramping up a new project at work that is looking pretty promising in terms of what it'll be able to do vs how much code it's going to take. 
&gt; Is this what sex feels like? Wait until you try ‘import ipdb’...
I was unaware of that style. What is its purpose?
I usually use requests and selenium 
If you're not using the API, then that means you must be manually scraping the rendered video page. This means that your script is fairly brittle and may break often and at any time. Are you prepared to maintain this every time the YT interface changes?
Nice 
3.7 has a built-in `breakpoint()` function. https://docs.python.org/3.7/whatsnew/3.7.html#pep-553-built-in-breakpoint 
That was helpful
A folder cleaner. Currently only available for macOS and Python 2.7 (macOS ships with Python 2)
Thank you
Make sure you never look at PyCharm's debugger. Because if pdb already feels like sex to you, your mind can probably not handle that... :) Oh, and if you can't get enough of sex and want to automate it, have a look at Python's logging module...
To Infinity and Beyond! Explained @ https://app.finxter.com/learn/computer/science/381. 
For some reason you want to use your edtior while using ptpython then you can do that as well, Simpy switch to vi mode and press 'j' twice then press 'v'. ptpython is fun
I sometimes compile to assembly to try to figure out what, e.g. -O3 vs -O1 does. It's hard to tell what the difference is even for a for loop though...
Unfortunately, I don't have time to draft an introductory CS lecture on these concepts. I would suggest watching a video of such a lecture, but again I do not have time to evaluate and recommend a particular video. A good CS book should also suffice; I believe the CS subreddit has a list. Just because I don't as much time as you to write a lengthy blog post is not a valid counterargument; that is an ad hominem logical fallacy.
Python being what it is, you could just commit your .py file or package, have the CI service test it, and then have it deploy it as well, via scp or sftp, to any machine that has the same version of Python installed. But, really, you should probably google **ansible**, **salt**, **chef**, and **puppet**, choose one, and move on.
Ok, in the interest of comedy I'm making some very broad assumptions here about gender, but don't *ever* ask a woman if she feels like a debugger if you want to get to an actual answer to that question. And, for the love of all that's holy, don't ever even mention breakpoints. At least not on the first date.
That's the point. There is no "answer", just different opinions.
u/sentdex, someone is trying to karmafarm your content again. Downvoted
okay I'll cut it in half. Hey guise my scraper got blokd wat do!!!1!!!!!!!!!!
I don't know whether you're stupid or just trolling, but I obviously read your entire question and even other comments which also asked you to post actual code, but seems like you can't open it and read them yourself.
I'll post it on github once it becomes usable mainly with console.
So apparently, usability of a language is defined by how many lines of code you need to write interpreter for it.
Whenever you get some exception in code try out different cases and see what exceptions come up or look up what exceptions a certain method can throw. Also you can change some things in custom exceptions and I really don't know whether class Ex(Exception): pass is enough.
Yes, now I am writing tests to solve this problem.
What are you smoking? Really can't follow you. Do you mean that if you build a scraper in 5 days instead of 10 it gets blocked? Implementing tor or proxy is easy nowadays but would slow the process down. 
I don't believe in using breakpoints. They are against my religion. 
We are talking about beginners to programming, not scrapers. You think they can start out and from day 1 to 5 build a fully working scraper that can scrape entire website without breaking or getting blocked?
The first one would take 10 days to figure everything out and get used to the packages but after that it would obviously get easier with every scraper. 
The brief is telling you that the *answer* should be 12 ... that does not mean you should use 12 in your calculation. Think of it like this: in Year 0 you've got a budget of 42K and an appropriation of 47K. Now, add a year, grow the budget by the tax increase rate, and check if the new budget is &lt; the appropriation ... when it's &gt;=, that's your number of years.
Yeah because writing a fully working scraper takes like 10 minutes amirite.
The comment asked to provide examples on Jan 30 and so I have edited the question to include some examples. I got an answer that seems to work. I can't provide the actual code and I feel its unnecessary. I think the question is now clear enough 
 budget = 4200000000 years = 0 while years &lt;= 11: budget = budget * 1.01 years += 1 print ("Budget is {budget} $ after {years} years.".format(budget=budget, years=years)) 
Let's try [nagare](http://www.nagare.org/doc/description.html)!
I used to use https://github.com/manicmaniac/inline project, but while it has superior performance (the function call overhead was 10x lower than with cffi), it was completely unsafe (no type checking was applied), and I couldn't use structs as far as I recall.
I didn't make a counterargument. You implied that I was using wrong definitions for those four words. I asked what the right definitions were. I'm not trying to pull the "if you don't debate me, that's an admission of defeat" thing. I'm just annoyed because I feel like I'm doing the heavy lifting on my side, and you're just saying "you're wrong and silly, you need to educate yourself". Like, are all four of my definitions for those words wrong? Or just some of them? I don't have anything to go on here. Could you copy/paste a sentence I said that's wrong? We could also just quit.
DragonFFI Usage Examples (from the README) Let's compile a C function that performs an addition: import pydffi # First, declare an FFI context F = pydffi.FFI() # Then, compile a module and get a compilation unit CU = F.compile("int add(int a, int b) { return a+b; }") # And call the function print(int(CU.funcs.add(4, 5))) The compile API exposes every defined functions . Declared-only functions won't be exposed. cdef can be used for this case, like in this example: import pydffi F = pydffi.FFI() CU = F.cdef("#include &lt;stdio.h&gt;") CU.funcs.puts("hello world!") Structures can also be used: import pydffi F = pydffi.FFI() CU = F.compile(''' #include &lt;stdio.h&gt; struct A { int a; int b; }; void print_struct(struct A a) { printf("%d %d\\n", a.a, a.b); } ''') a = CU.types.A(a=1,b=2) CU.funcs.print_struct(a)
Alphavantage let's you get any crypto historical for free and they have a python wrapper.
[import pudb;pudb.set_trace()](https://asmeurersympy.files.wordpress.com/2010/07/screen-shot-2010-07-28-at-12-51-36-pm.png)
I think this is pretty easy and you shouldn't ask for help like this. 1) Learn python - these are basic operations that everyone should know 2) It sounds like you want someone to do it for you instead of you learning it 3) Always share your code ( If you have anything ) 
Probably: while budget &lt; appropriation: You can't use the answer to derive the answer.
Where do people get freelance gigs for devops or CI kinda stuff? I do django stuff, but lately figured out I'm quite good at upgrading dependencies on very outdated Django apps. Not sure if that is a skill that is in need, but yeah it took my quite a while to learn to work with legacy code and how to upgrade the dependencies on an app with many different dependencies.
I appreciate the help. I knew having the answer in my Boolean would complicate things and could have a bad output I just couldn’t pinpoint what exactly to use instead. 
&gt;a thread I had read a few days ago on the most indispensable tools in a programmers toolbox Got a link to this one?
Thanks for the link! I wasn't aware of that package. Looks good. [Quandl](https://github.com/quandl/quandl-python) is another one that provides a similar service. My objective with cryptory is not to compete with these APIs but to combine this type of financial data with social/sentiment data that drives alot of crypto activity.
Thanks for the tip! According to their [webiste](https://coinmarketcap.com/api/), the historical data endpoint is coming soon (no idea how long it has said that).
that's not what they are asking.
If you can't post code, people can't know what you're working with, and so they can't help you, just pointed that out in my first comment here but you simply couldn't grasp it I guess.
Neither are commands. They are both statements
B! 
&gt; breakpoint() Damn.... I'm using 3.7 since June and I didn't know about this. EDIT: it wasn't in the 3.7 version of June, but it has been in the later alphas.
Keep at it. I was depressed for a long time, stopped programming completely. Now that I've started again, I find that it's really helping.
Yeah but he didn't say that he could literally use it without thinking about for the next twenty years.
You make a deal with the author. Hard concept, I know.
yeah theyre also missing marketcap data and supply data from api of many coins when it's available from the website(don't they know this is the age of webscraping anyway? ;))
 I find Pycharm debugger is able to debug things that the built in debugger cannot - though that’s just a small set of cases. Its certainly a nicer experience that built in debugger with its additional UI advantages. 
ah ok. I don't really use vim anymore(and there's no coloring when i try it probably because the files reside in /tmp and vim has some weird permission problem). Well again, not such a fan of the red coloring scheme but i suppose it could be changed. Also you probably don't want to require your user to download &amp; copy a config file first time. Rather just create that config file automatically if it doesn't exist.
Try `ipdb`, feels like improved sex.
Wish I could upvote more
You can use the pandas library to quickly load the data into a datafram. After that you can either work with pandas or convert the data to an numpy array.
You might want to checkout the [csv module](https://docs.python.org/2/library/csv.html), it'll load a CSV and handle a _lot_ of edge cases for you. 
Really cool. I took a brief look on some of the videos. I think I would have loved these, when I had CS101.
I ran "import pubg;pubg.set_trace()"... My computer crashed and asked for a $2.50 key...
Also, if all you need is an interactive promp: import IPython; IPython.embed()
Worth a read, “Become a pdb power user”: https://medium.com/instamojo-matters/become-a-pdb-power-user-e3fc4e2774b2
I have one small and one large project planned for Flask. It looks really easy and fun to use. (I'm planning to avoid most of the plugins.)
...nginx doesn't start with E?
&gt; It's clear you understand what I was saying in the following sentences, but you're pretending not to to discredit me. No, I wasn't pretending to not understand what you were saying. I took a guess about what you meant with your code, but if I assumed you were saying something you weren't saying, I didn't want you to say I was making a straw man argument. So I responded to the actual code you posted. I've rewritten this comment a couple times now. I'm going to skip responding to your MyList stuff because I think I can *guess* what the core of your beef with my blog post and comments is. And if I argue against *that*, we'll get to the heart of our disagreement faster. If I've misidentified the problem, then by all means ditch this comment. I'm still annoyed at you, but this comment is 100% Good Faith Argument TM. 'Cause anything less means we're talking in circles. ~big breath in~ What I assume your main problem with my blog post is this line: &gt; **mutable objects can't be hashable** That's a pretty black and white statement. To refute it, you gave this code as an example: &gt; `class Foo: pass` And to be sure, yes, we agree that `Foo` objects are hashable. Like the [Python glossary](https://docs.python.org/3/glossary.html#term-hashable) says, "Objects which are instances of user-defined classes are hashable by default." And it *seems* like Foo objects are mutable, because you can do stuff like `x = Foo(); x.bar = 5; x.bar = 10`. (I'll get to the "seems" part in a bit, don't ditch yet.) My definition of mutability: *An object is mutability if the object's value can be changed.* If this definition conflicts with something I said before or "violates all common interpretation", ditch this comment. Also (this comes up later): Let's throw in *[All objects have an identity, and the identity of an object never changes.](https://docs.python.org/3/reference/datamodel.html)* (If not, ditch this comment.) Also (this comes up later too): Let's throw in *[An object's hash value never changes during its lifetime.](https://docs.python.org/3/glossary.html#term-hashable)* (Trust me, this next part is relevant for later.) The expression `[1, 2, 3] == [3, 2, 1]` evaluates to `False` because those lists have different values. And the expression `set([1, 2, 3]) == set([3, 2, 1])` evaluates to `True` because those two sets do have the same value. (Ditch if you disagree.) One *could* argue the lists should both be the same value because they all have the same three integers and the order shouldn't matter, but when it comes down to it, it's the `__eq__()` method that determines if two values are equal to each other (and it says that lists with different ordered objects have different values). NOTE: I'm not talking about mutability here. I'm pointing out that what we think the value *should be* equal to is irrelevant; it only matters what `__eq__()` returns. Re-said (and here's a part where we might disagree): The `__eq__()` method defines what the value of an object is. Here's a code example to demonstrate what I mean: class Spam: def __init__(self, a, b): self.a = a # a is immutable and must be hashable self.b = b # b is mutable def __eq__(self, other): return self.a == other.a def __hash__(self): return hash(self.a) # Pretend we have a bunch of code that makes all attributes immutable except for b, and forces a to be hashable. (It's late and I'm tired. The "pretend" stuff would be a bunch of code that raises an exception if we try to change any attribute except b or set a to an unhashable value in `__init__()`.) Let's play with this code: &gt;&gt;&gt; obj1 = Spam(42, 'cats') &gt;&gt;&gt; obj2 = Spam(42, 'dogs') &gt;&gt;&gt; obj1 == obj2 True `obj1` and `obj2` have the same value. It doesn't matter if one thinks they *should* have different values, the `==` operator says they are the same. Now let's check their hashes: &gt;&gt;&gt; hash(obj1) == hash(obj2) True The hashes match. This follows the ["Hashable objects which compare equal must have the same hash value."](https://docs.python.org/3/glossary.html#term-hashable) requirement for hashability, and the hash never changes (because `a` is immutable). So `Spam` objects are hashable. Now let's run this code: &gt;&gt;&gt; obj1.b = 'moose' &gt;&gt;&gt; obj1 == obj2 True One might think we've changed/mutated the value of `obj1`. But if we have, why is it still equal to `obj2`? The `obj1.b = 'moose'` line doesn't change the value of `obj1`. You could argue that changing the `b` attribute should count as changing `obj1`'s value, but that's just like arguing that lists with the same objects in a different order should count as being the same: it comes down to what the `__eq__()` method says. You might say, "So what? Just make the `a` attribute mutable and you'll have a mutable object that is hashable." But if we allowed `a` to change, that means the `__hash__()` method returns a different hash whenever you mutate `a`, and that breaks the requirement that [hashes never change in the lifetime of the object](https://docs.python.org/3/glossary.html#term-hashable) Now to the "seems" part: In your `Foo` object, the `bar` attribute is definitely being changed i.e. mutated. We can both agree on that. (If not, ditch this comment.) Here's the part where we'll disagree: You're not changing the value of the `Foo` object when you change the `bar` attribute. The `bar` attribute has no bearing whatsoever on how `__eq__()` works. Now, two `Foo` objects would compare as unequal before and after one of them has their `bar` attribute mutated, so I can't prove that the "value" hasn't changed; that one object could have just changed to another unequal value. This requires some nuance: It seems like you can't prove it either way, since there's no way to compare `Foo` objects like we did with `Spam` objects. But I would argue (here's where you'll definitely ditch) that when you look at `Foo`'s `__eq__()` method, it is entirely based on identities, and since identities can't change, I'd say that the "value" of `Foo` objects can't change either. And if you think I've failed to prove that `Foo` is immutable, I can flip it on you: You can't prove that `Foo` is mutable, because you can't mutate two `Foo` objects so that they're equal to each other. The identities will always be unique, so `__eq__()` will always return `False` when comparing two `Foo` objects. In other words, your `class Foo: pass` class is hashable and you can mutate attributes on it, but you're not mutating the value. **And an object is mutability if the object's value can be changed.** ~whew~ Hey, you know what? Actually, I realized you're right. You can make a mutable object that's hashable: class Eggs: def __init__(self, a): self.a = a # a is mutable def __eq__(self, other): return self.a == other.a def __hash__(self): return 42 `Eggs` objects can have their value mutated by changing `a`, which is what `__eq__()` uses for it's value. And the hashes never change and the objects which compare equal have the same hash value, so it fits all the requirements for a hash. The hash doesn't *have* to be based off the value (after all, using `id()` doesn't), so `return 42` technically fits the definition of a hash. There's just one problem: if you actually try to use this, the static hash means you **always** get hash collisions and your dictionaries and sets become linked lists. And a hash that doesn't actually work in a hash table is not a hash at all, in my opinion. But that's just my opinion of how real-world computer science should work. I guess you win: technically, you can have mutable objects that are hashable.
Thanks, I did not use it on the advice of Google https://google.github.io/styleguide/pyguide.html?showone=True/False_evaluations#True/False_evaluations
If the nested tuple doesn't only contains immutable objects, then yes. &gt;&gt;&gt; this_is_immutable = (1, 2, ('a', 'b')) &gt;&gt;&gt; this_is_mutable = (1, 2, ('a', ['x', 'y']))
If you’ve been working on Python for 5 years, it should be on your list of things you learned 4.99 years ago, not 3. Just saying. Not using a debugger is crazy talk.
&gt; the first thing that came to my mind was, put a pprint on the object and scrape again simple as does this mean that your scraping app didn't have logging either?
It's pronounced *engine-x*. So the E represents Nginx. LNMP doesn't really roll off the tongue.
I think that you can do that. You have to just rewrite it Everytime something happens.
Yep, definitely possible to do in matplotlib. Going to want to do a linex.set_ydata call on the data you want to update. [This Stack Overflow page gives you a pretty simple look at that.](https://stackoverflow.com/questions/4098131/how-to-update-a-plot-in-matplotlib) However, consider that matplotlib might not be the best option for real-time plotting. There are definitely some performance issues that can prevent you from plotting in real time, depending on how often the plot is updating. If you want to improve performance, I'd recommend you look into blitting.
Not burning out. Think I may focus on reducing complexity where I can and implement docstrings.
Can you please explain what advantages this library has in comparison to SQLAlchemy? 
I second this on the ansible front. Its very easy to get going, and its idempotent (sp?) so you can just keep on running it! All my python code goes out to my servers this way
Thanks, I think we can set the updates to happen every few seconds, so it shouldn't be too much.
Hey you dropped this: map(int, ...)
But you really shouldn't be committed to a degree in computer science until you've tried programming, so then you should start with Python to get the general feel.
&gt; Understanding why accessing an element in an array is O(1) versus O(n) in a linked list is going to be obvious, or why inserting an element in a linked list is so quick. Is this really a good thing to prioritise when someone is learning their first programming language? In a class with mixed levels of ability? Incidentally, I've programmed for years and I've never needed a linked list. There are very few real life occasions where you need it. Hell, it's rare to have a data structure big enough that O(n) anything is a concern.
Also you’ve only asserted that it is intuitive and that it just figures out nested subqueries etc. I assume there is some specific case backing this claim, so showing an example of your library’s python (I.e what I would have to write) and the resulting sql vs sqlalchemy for example could be much more effective. 
And PDB is nowhere near as good as debuggers in most IDEs that will show you all the local vars at each step and let you set up watch expressions and all that good stuff. 
&gt; The biggest hurdle for students is learning to program at all. After that they get by. Doesn't starting with Python help with that?
Or Peewee, which [also has composable queries][1]? &gt; When I began the first rewrite that eventually turned into Peewee 2.0, I discovered a handy technique (using recursive-descent) for turning arbitrarily-nested Python data-structures into SQL. This gave Peewee an API that was both expressive and composable. Combined with operator-overloading, one could now express complex queries in a way that would even be validated by the Python interpreter itself: &gt; class Person(Model): first = TextField() last = TextField() dob = DateField() &gt; # Find adults whose last name starts with "A": eighteen_years_ago = datetime.date.today() - datetime.timedelta(days=18 * 365) a_people = (Person .select() .where((fn.LOWER(fn.SUBSTR(Person.last, 1, 1)) == 'a') &amp; (Person.dob &lt;= eighteen_years_ago))) [1]: http://charlesleifer.com/blog/peewee-3-0-released/
Oh stop it, you
[removed]
Yeah, every few seconds should be ok. Is still recommend looking at blitting, redrawing stuff like the axes every time is pretty costly, and usually unnecessary.
You can open up a console through the debugger. One with iPython even. https://i.imgur.com/avLQKoP.png
&gt; Otherwise Geordie would be interchangeable with Londoner or anybody from a city that is not in Uganda Well minor quibble but it would also need to be something far removed from Uganda, but yeah basically. &gt; except that sort of expression is never ever used with "Londoner", is it? I wouldn't know, I'm an American. I didn't pick Londoner though because Downing Street in London and that would've clouded the message because obviously Downing Street would have a reason to understand Ugandan politics. &gt; A Londoner might well be interested in foreign affairs; a Geordie simply couldn't, perish the thought. Again no the explicit point is that it's _possible_ for the Geordie to have an interest, just not super likely. That's why it was supposed to be an apt analogy for LISP which does have a lot of uses but just isn't seen as widely applicable knowledge. Kind of like Ugandan politics in Newcastle. 
It's not idea. I think C is very basic and good to learn first. Python can be too if you teach it right. 
Why not? Numpy is the de facto standard for any vector computation in python! Better start learning it asap... And if OP has any knowledge about databases or so, learning pandas is quite easy imo.. :)
Yes, that's a point that should be kept in mind like for example if you are evaluating the boolean expression and the value being compared is int, say 0 then it would evaluate to 0 but in the context, that's not going to happen since the API is internally designed which rules out the possibility of evaluating it to False as the same datatype would be used (in this case is string). 
Well this is just peach gravy. pytorch.org says (for my choice): Run these commands: * pip3 install http://download.pytorch.org/whl/cpu/torch-0.3.0.post4-cp35-cp35m-linux_x86_64.whl * pip3 install torchvision Last one gives "RuntimeError: PyTorch does not currently provide packages for PyPI (see status at https://github.com/pytorch/pytorch/issues/566). Please follow the instructions at http://pytorch.org/ to install with miniconda instead." Well thanks a lot... 
He asked about other people’s experiences, not which one was better.
Hey thanks, I'm using flask and MySQL, bootstrap template that I made changes to
Try pdbpp and/or ipdb.
Loading the .csv data into arrays is just the first step. From there I intended to extract that data into a formatted table in a .docx file. Is using Panda something that could achieve this with something like python-docx?
Powerful arguments. RESPECTABLE codes!
HIRING - Dublin, Ohio (Columbus) - Python/SQL/DevOps The Data Quality Developer will plan and execute automation and platform management solutions to integrate medical data into our Business Intelligence and Analytics (BI&amp;A) platform on AWS. This role will be a driver of simplification, automation, and resiliency for the platform. The role spans cloud engineering, data ingestion, and database management capabilities. Responsibilities •Applies advanced knowledge and understanding of concepts, principles, and technical capabilities to manage a wide variety of projects •Works on or may lead complex projects of large scope •Writes programs to manage data quality, audits, and reconciliation of data along with automation for anti-fragility solutions, monitoring, and alerting •Implements continuous integration/continuous deployment solutions, automated testing solutions, and data warehouse platforms as code solutions o Building/improving/documenting processes and workflows o Propels a culture of Agile/DevOps and automation to create speed and efficiency •Performs data modeling and developing scalable solution to extract, transform, load data from the business source systems using AWS tools like Mattilion /Glue to AWS Data warehouse, and creating DB views for users to access the data. Qualifications • Direct experience in programming large, technically complex solutions • Understands complex platforms and translating issues into non-technical terms • Attention to detail and strong written and verbal communication skills • Customer service orientation, and an understanding of the importance of meeting customer needs and maintaining strong customer satisfaction • Demonstrated success and effectiveness working in and promoting a rapidly changing, collaborative, and time-critical work environment • Bachelor’s degree in related field or equivalent work experience • 10+ years’ experience in related field preferred Technical skills • Experience programming with Python, and Bash Shell • Experience working with AWS cloud platforms • Experience with Automation tools (CloudFormation, JSON) • Experience with Continuous Integration tools (Code Pipeline, Jenkins) • Experience with Redshift technologies, Lamba, DynamoDB • Experience with revision control source code repositories (Git, SVN, Mercurial, etc.) • Familiarity with data movement tools (SQL, Matillion, AWS Glue, etc) • Familiarity with SQL and RDBMS concepts (MySQL, Redhshift, PostgreSQL, etc.) • Familiarity with agile methodologies • Familiarity with automated testing tools (ie. Selenium, JMeter, etc.) • Familiarity with data visualization/management tools (Tableau, Alteryx, Business Objects, etc) • General knowledge of IP networking 
You could do something like `self._my_value = self._precompute_my_value()`. This is good for readability, too - it's now clear to whoever's reading your code that the property is initialized there.
if you come here as a beginner to ask how to parse some csv into an array you're not ready for a scientific stack just yet. Definitely not 'quickly' or 'quite easy'.
This did not exist? I'm sure this exists.
Yeah you might be right... I come from a C/C++ background and adopted python later in my career specifically for the easy scientific stack. (Easy as in compared to other languages)
Python's interpreted nature kinda makes it possible to get far without one. You'd look crazier if it was something like C or C++
My client wants to specifically have a 'Scan' button. :( They process hundreds of documents a day and so it's difficult for them to do the Scan &gt; Save to desktop &gt; Upload.
For a moment I said to myself "Yeah, it says y = x \+ 1, so of course y is greater." Then I remembered the comment at the start and it made me smile.
What if you supported batch uploading? Also, see my edit and link to an npm library. 
Good lord, why would I not just do: sql = "select * from Person where ..." dbhandle.exec(sql) ?
Thanks, ill check it out
Why do folk keep on advising the use of a third party module when there is a perfectly adequate solution in the stdlib?
After you've done `pip install pandas`, no `pip install csv` is needed.
That's what it is primarily, but SQLAlchemy is also great for composing queries in a functional manner. Almost all if not all SQL queries can be composed with SQLAlchemy. It also provides a lot of interfaces to the datatabase in an implementation (Postgres vs MySQL vs...) agnostic way.
Must buy a license. It is $3k+. :/
correct. Although in hindsight pandas and numpy may be a tad overkill for someone who is a beginner.
*Beep boop* I am a bot that sniffs out spammers, and this smells like spam. At least 100.0% out of the 6 submissions from /u/Mercuraxx appear to be for Udemy affiliate links. Don't let spam take over Reddit! Throw it out! *Bee bop*
If debugging is like sex, than writing a test suite is like a relationship. There are a lot of benefits, sure, and adding stability is wonderful. But, it's a lot of work, if you fuck up just a little bit there's a lot of cursing and mending to do, and you find yourself always checking in to make sure things are ok.
There is https://pypi.python.org/pypi/python-sql Disclaimer: I'm one of the author.
This wasn't promised. It is a feature that if I provided, I will get the deal. So far the scanning works as expected, for one page. I believe I can manage the rest.
&gt; My only worry is not to stump over the basics in Python. I’m not sure what this means. If the scanning works, exactly what do you need assistance with?
https://github.com/spacemudd/webagent-scanner/blob/master/app.py#L46 - I read online this is considered 'non-thread safe' which I only have a vague idea about. Is it safe to run the application 24/7 with that line?
Well, you could query some soccer profiles and check whether their new tweets include keywords describing a player transfer or not.
Set up a Flask site on pythonanywhere
No, it is not. Please read [the site](http://docs.sqlalchemy.org/en/latest/intro.html).
I’m always ready with a downvote for YATFT which is terribly written and explained, but this is really good!
I’ll check out tensorflow. Just not exactly sure what keywords I’d use to distinguish whether it’s a player transfer or not.
I don't know. If you don't, either, this might be an opportunity to partner with someone else for this client or pass on the contract altogether. If you're having trouble just getting a proof of concept done, the job may not get easier once the client starts using the application. I do know that you should be wary of committing private keys to public repos: https://github.com/spacemudd/webagent-scanner/tree/master/cert.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [spacemudd/webagent-scanner/.../**cert** (master → c22d10f)](https://github.com/spacemudd/webagent-scanner/tree/c22d10fda7d5f8c1604718852da9da3aede35b2d/cert) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dtvur9i.)
Bro, if pdb is sex, then vscode with the Raynald Jemane plugin is like a fully-articulating, five-function sex robot that can read my mind and has feelings.
Definitely partnering with someone. Alright, thank you for your time. And indeed, I missed the cert files! Luckly the certs are just a placeholder. Gotta do some cleanup.
Too advanced for me but nevertheless I really enjoyed it. Will definitely check out your blog again. I hope someone competent will react to your post. Could be an interesting discussion.
Potentially. If you often stop during sex to figure out what is going on.
&gt; Is there an alternative to pytorch that allows me to build neural nets easier than tensorflow? Idk, but there's an alternative to Windows *runs away snickering*
Don’t forget being database-platform agnostic, switching from MySQL to Postgres to whatever without having to rewrite all your queries because of SQL idiosyncrasies. 
Third. /u/kenneho, you should use Ansible just because it's all python and easier for you to implement. Use Ansible-pull to have the servers check in for new updates and pull down new roles when you need to. 
If one is going to use an ORM, sqlalchemy already has a good non-ORM translation layer (core) for building sql intuitively. Personally, I still think the best syntax for generating queries belongs to [Pony](https://ponyorm.com/)
*sharpens pitchfork*
can i get this all in even just in text format like in a simple notepad view that constantly updates every seconds (like a tick format) as long as i have like: Exchange rate GBP/USD: 1:1.5 Time: 15:31:21 Next game date for arsenal game: 14/02/2018 stuff like that webscraped but constantly updated every 1000ms 
A new texture cache viewer for Second Life since changes in the viewer source code caused SLCacheViewer to fail. https://github.com/jspataro791/PySLCacheDebugger
I'm new here but I think if you have 2.7 installed then pip defaults to 2.7 while if you have both 2.7 and 3 installed then it doesn't matter. I'd welcome someone else to weigh in however.
[Running Python in a browser is more awesome than you think - Wired](https://www.wired.com/2015/05/running-python-browser-awesome-think/)
This is true! &gt;#Why LEMP instead of LNMP? [We go with LEMP due to the pronunciation for Nginx: Engine-X (en-juhn-ecks). Think of how in English, the article an is used instead of a for hour even though it begins with a consonant. The importance is the sound of the first letter rather than its written representation. Besides, LEMP is actually pronounceable and doesn’t sound like reciting the alphabet.](https://lemp.io/)
That's definitely a valid criticism. Maybe I should rework the post so that it's more approachable. Were there any parts in particular that you wish were better explained? Thanks for the feedback =)
Could you please provide a link? Can’t find anything about this and very curious. For science. Thank you.
Do not mind me. I am just a python newbie :)
You can also use: python -m pdb myFile.py to start the interpreter in the debugger. 
We need to teach them hardware, software and the interface between the two. So we'd like to get them started on a single board computer as soon as possible, preferably from day one. That's were C comes in handy. But it's only preparatory to C++. In teaching Python I've exerimented with starting with OOD right from the first lesson. It works well (in Python) but in C++ there's too much they have to absorb in a short time. It is a different world from Linux/Windows programming. As soon as the programs get only a little larger C++ is indispensible in my view. I don't think anyone SHOULD CONTINUE programming in C. C++ offers far better structuring capabilities. Personally I never use C. But for the students it's an easy way to learn some low level concepts and control a few leds or a stepper motor. Which motivates them to wonder about program structure in larger applications. Once they have such questions, C++ lands into fertile ground.
Goodbot
It depends on how your environment is setup, but if you have python 2.7 (included with OSX) and an installation of Python 3.x alongside, they’ll use thier respective package managers (pip or pip3) and each interpreter will only access package from its respective pip. 
it's probably part of anaconda, which is available for windows too. It will probably fuck up your current python install tho, so beware
Well... It could be that I'm way too used to dozens of triggers, functions, custom aggregates and other things that don't actually translate well between databases. Does development with SQLite actually work? I believe it doesn't check most things so a lot of things break when they expect exceptions from DB (and even more things break on production when actual database starts complaining). You can fight that with tests, but it's not like you can cover everything.
Why SQL in documentation feels so weird? Why alias tables and use ordinals in group by?
https://github.com/encode/apistar - is a new web framework combining best things from both Django and Flask.
Maybe related: https://github.com/proofit404/dependencies
I don't get the hate for SQL. I'm not saying that this is the case for this library, but so often I see people "abstract away" SQL to do business logic in Python or Java. So instead of writing a query that does the entire thing *in situ* in the DB, they serialize the data, transfer it over the network, massage it, serialize it again, and transfer it back over the network. 
... if it were to say something new, something that could really get people thinking I wouldn't mind, but why simply regurgitate old news? It's also hardly surprising that Haskell is faster when the Python code that is referred to often has four or five name lookups per line, and that is the optimised version, I dread to think what the slow version was like, legless carthorse I'd guess :-(
And if that is not enough: from IPython import embed; embed() 
Ok follow up: 1. cool! 2. doesnt work with nose :( -- a REAL deal breaker
Thanks :) I made it for one of my weakly project for my computer science course. 
Yes, I realized that I will be adding that functionality when I get further along in my computer science course. I'll set the deck to include all cards and suits, then when a card is pulled I define a function to remove that card from the deck. Then depending on the hand, I'll have to write some further code to decide if an ace should be worth 1 or 11. I'll get around to it eventually. It's still a work in progress. 
Oh wow I'll have to check that out
I know, I will be fixing that bug when I get around to having the game use a full deck of cards. 
I know, I will be updating it when I get further along in my comp sci course. 
LOL
Ok. I assumed you were the maintainer.
You gotta love a series with only 1 part started over a year ago
The Old Reddit was written in Lisp, not Python. http://www.aaronsw.com/weblog/rewritingreddit
wait. is that not...that's not the way you're supposed to do it?
Although some variable watches are really nice.
What made you choose Urwid? I have used [asciimatics](https://github.com/peterbrittain/asciimatics), and there was a recent post on [cursebox](https://github.com/Tenchi2xh/cursebox) that you can read [here](https://www.reddit.com/r/unixporn/comments/7l4768/i_found_some_crazy_cool_terminal_action_that_i/). The last link includes a Youtube presentation he did.
Clicking on the link to the home page takes me to your bug tracker, where do we find your docs?
Agreed. The UX/UI is what makes a project a success or failure. To the end-user the UX/UI *is* the project. The end-users don't care about the framework used on the backend. Not that this information is exactly relevant to the OP, I've just been thinking about this this morning.
I haven’t tried it for PyTorch, but Ubuntu for Windows 10 can run standard Linux Python and pip.
Yep. Learning to use a debugger doesn't *take* time, it *saves* time.
Eh, I'm interested in this topic, but you should seed the sub with a lot more posts if you want others to jump on the bandwagon.
Watch this - https://www.youtube.com/watch?v=5BqAeN-F9Qs Glyph - Shipping Software To Users With Python - PyCon 2016 Also found this while searching for the other video but I havent seen it -&gt; Dave Forgac Share Your Code! Python Packaging Without Complication PyCon 2017 https://www.youtube.com/watch?v=qOH-h-EKKac 
Looks similar but more limited in scope than PyDAL.
I will say one thing: the documentation is good and had lots of examples.
The documentation is the long description on PyPI which is the README.
Right, like I said, to speed it up you'll need to use blitting. Making the changes required to make it run for his application could be quite difficult, and he might be better off looking at a different plotting library.
We do not want to manage the database connection (rely on PEP249) but we try to have a complete support of SQL.
this free program could also help your about [Neural Networks](https://getrealdiplomaforlessonline.blogspot.com/2017/12/deep-learning-specialization.html)
Is there anything emacs _can't_ do? :D
If you think pdb is cool, wait until you try the time travel version: https://everythingsysadmin.com/2014/04/time-travel-pdb.html (Yes, this is a real thing that works, despite being announced on April Fool's Day.)
`__add__` defines the behaviour of the addition operator (+) to the objects created from the class. These "magic methods" essentially overload standard Python functionality for new classes.
It cant play videos.....haha But it can read PDF, email, RSS feeder, music player, gaming, Browsing, gitter (magit), organize your agenda, calendar, to-do and task... Oh and eventually it is a text editor! 
Looks very cool. Saved this for whenever I need to do something RDBMS'ey.
1: /r/learnpython 2: read the sidebar 3: we won't do your homework for you
You could brute force it enough times to make a statistically relevant sampling, but that would probably take a very long time and be heavily influenced by your pseudorandom algorithm of choice. Or, forgive me if my stats skills are rusty: # 26P7 permutations of 7 characters before you get the right 7 characters math.factorial(26)/(math.factorial(26-7)) * 7 &gt; 23207184000 The question is asking for "time", and if he types 80 words per minute, 8 hours a day, it will take him 1654 years.
Finally someone else gets it.
Unit tests. This is going to need to be maintained. You need to be sure the change you made won't break anything else. That means testing and unit tests will stop you going mad.
Not my homework, man. http://indianexpress.com/article/trending/trending-in-india/answer-to-donald-trumps-covfefe-question-at-isi-kolkata-4967285/
Neat, neural networks are the future!
"unfair means"
Again, not my homework/exam. http://indianexpress.com/article/trending/trending-in-india/answer-to-donald-trumps-covfefe-question-at-isi-kolkata-4967285/
Ehmm, FYI, the python vs code extension has that as a debug setting, to print the value of the variable in each line.....
Holy shit! You're right, I had no idea 0.o I'm trying it out right now, but it only seems to work on hover (Wolf puts the values on the same line, after the expression). So I think it's different enough to warrant its existence :) Thanks for bump!
"Hey Doc! Yeah, it's me again.. No, it's in the debugger this time."
Please do, I'm curious now. Steps: Went to settings -&gt; set debug.inline... to True -&gt; start debugger. Even with a breakpoint set I could only inspect on hover. Thanks again :beers:
Here is an image of how it looks: https://imgur.com/owaPcuu
I believe I will continue working on this project whether I get the deal or not. It's fun. Unit tests... definitely. Thank you.
Try Adobe Illustator. 
Dynamsoft's SDK is at $1624/license and $16240/year for unlimited. Not too far from your price range.
They mean the same thing, but have some semantic differences. Software developer is a more general phrase than computer programmer. It's rare to find someone who only exclusively programs, as that's only one aspect of the job. Also although phones, tablets, smart watches, etc. are still basically computers, it seems like the public hears computer and thinks big towers/desktops and not a phone. It's hard to say whether one language will rise above the rest. The best approach is to be good at the fundamentals and have the ability to learn and program in any language.
http://www.verydoc.com/pdf-to-vector.html ?
&gt; Is this really a good thing to prioritise when someone is learning their first programming language? In a class with mixed levels of ability? No, definitely not, but I wasn't introduced to data structures class until after the class had been forced to program in earlier semesters. This isn't necessarily a practical thing you learn for programming on a daily basis, but more so theory and background that helps you understand why things are structured a certain way and just how things work and which one to pick for a specific problem. &gt;Incidentally, I've programmed for years and I've never needed a linked list. There are very few real life occasions where you need it. Hell, it's rare to have a data structure big enough that O(n) anything is a concern. Computer Science education in my experience isn't about teaching programming in the context of a career in software dev, but more so a math degree that teaches you theory behind computing, the math of algorithms and their proofs, and fundamentals that are good to know but none of them you work with on a daily basis. We didn't even learn git and that's by far one of the most useful things you need to learn early in your career. You come out without many of the required skills to be a programmer really, just some programming and theory. Maybe you get lucky and have a webapp class or something that teaches you real world skills you might end up using, but there's definitely not a focus in stuff like that, at least in my experience. Otherwise they'd be teaching jenkins, git, test-driven development, agile development, jira, etc. That'd jump start a programming career for sure. No, I have never really needed a linked list, but that's because Python provides them automatically and we're Python programmers. If you want something that is a true linked list in Python, you can use a `deque` which is a doubly-linked list in the C implementation. No need to implement one ever in Python really. That's my argument against Python as a language for a class like data structures, because students should really be looking at code that does it at a low level like [this](https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c#L77) rather than some hacked up python class that has an attribute `next_node` or something like that. You *can* learn it through pure Python, but you should also be telling your students they'll never be implementing it again in Python. But also pointers are core to linked lists and you can use the fact that Python stores references to other objects and it works the same, but a student should understand the difference between something stored by value or a reference in this context. If all you know is Python, that's a very difficult idea to fully grasp I think. In C, it's core to the language, and really it's just core to computing in general. In the context of an education in computer science, I think C represents all of data structures much better than Python and is a much better tool to teach it. But just because we don't implement them doesn't mean we shouldn't understand them. A linked list is the obvious thing to learn about before learning about a tree, and a tree is still useful in Python and you very well might have to work with one. Trees make a lot more sense if you know how a linked list works. Knowing how this works in C will really help you understand why to use different modules and classes in Python. Someone who really knows their data structures might know which Python standard library tool fits the bill the best. I believe the C I've worked with has very much helped me be a better Python programmer. And I have written Python code that interfaces with a C shared library in my career as well. &gt;Hell, it's rare to have a data structure big enough that O(n) anything is a concern. Well, in real world programming O(n) and O(n^2) and O(1) doesn't tell you enough, but that's the nature of Big Oh. You're dropping a constant and coefficient. You could have two O(n) algorithms and one takes a million times longer, because that million constant isn't a part of Big Oh, and O(100000*n) is equivalent to O(n) math wise. You need to do a lot more analysis than calculate Big Oh to make a real choice about performance. But then again, people are changing the Big Oh of their program all the time without thinking about it and it ends up being drastic performance improvements. Could just be refactoring out a for loop and doing things a different way. And whenever someone figures out they need to index a column in their database to speed something up, they're likely changing the Big Oh in a major way. Depending on the implementation of the database, an unindexed query might be O(n) and you will see a huge difference in your webapp after indexing that column. O(n) does matter quite a bit, but often you'll intuitively be making a performance improvement that just seems obvious rather than thinking "I just fixed this O(n) algorithm". Does truly understanding Big Oh matter in real world software dev? Very little IMO. You intuitively figure stuff out and sometimes it's just knowledge you pick up, like how to index a database and when to. But Computer Science degrees are more about understanding the theory and math and not really teaching you real world programming as much.
So is Asprise.com. I don't get your point.
Any more pathetic crap like this?
1. /r/learnpython 2. You have not accurately described what you're doing and the results. `import xy from yz` does not produce `ImportError`, it produces `SyntaxError`. Flipping that around to `from yz import xy` could produce an import error. 3. Neither pyowm or tweepy provide a thing named `yz` having an attribute `xy`. That's uselessly obtuse, but matches what you said.
[https://www.youtube.com/watch?v=q5uM4VKywbA&amp;t=408s](Python Tutorial: CSV Module - How to Read, Parse, and Write CSV Files)
This is less a tutorial and more just example code with comments. I'm interested in learning about ML, neural networks, all that stuff, but almost every resource I've found is much like this one. They all seem to assume some domain knowledge. Can anyone recommend a book or tutorial that starts from zero?
I downloaded Inkscape, looks like this takes some work, rather than a quick export. Not something I will be able to complete on my own.
If you write a python program/library that does this conversion, please post it to /r/python!
It means you are of a superior race and you shouldn't let pleb redditors tell you which pip to use. 
playground.tensorflow.org
I'm in the field, but I'm new so take this all with a grain of salt. In short the way I see the difference between a computer programmer and software engineer is like the difference between a mechanic and an automotive engineer. I know that doesn't really fall into the category of meaningful differences, but I think it does help highlight some of them. In my experience, what's most important is an eagerness to try, a desire to learn, and a set of projects that you find meaningful, motivating, and fun to work on in your free time. I can't speak too much to languages, but I've never been asked to write anything but Java at work. I think that might be because a lot of languages are good at different things, and because Java has been used for a long time to develop enterprise software. If you haven't already, check this out: https://www.tiobe.com/tiobe-index/ Python has moved up since this time last year!
[Python OOP Tutorial 5: Special (Magic/Dunder) Methods](https://www.youtube.com/watch?v=3ohzBxoFHAY). I also recommend [Corey Schafer's](https://www.youtube.com/channel/UCCezIgC97PvUuR4_gbFUs5g) whole [OOP tutorial](https://www.youtube.com/watch?v=ZDa-Z5JzLYM&amp;list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc). It's pretty short and concise (6 videos, hour an 20 mins).
Working on GUI automation for a data-analysis pipeline using `pyautogui` by al.. Great library. But GUI automation seems to be tricky, because it leads to a race between how fast the GUI program reacts and how fast python reacts.. which causes a lot of random bugs. Some knowledgeable people suggested I put the library under unit-testing.. So now I am learning about unit-testing and trying to put the library into a testing framework. Didnt know much about testing.. so that has now opened up a whole new can of bugs :) Fun times.. and I am learning a lot.. but I wish I could make more progress with the app. I initially tried using `pytest`, but the syntax of pytest seemed another learning curve. So for now, I create unit-tests, using the similar framework (using assert), using a similar project structure that `pytest` suggests.. but decided to hand-test them. **Second pain point** has been pythons import system. It seems rather tricky. Does anybody know of any good tutorial on pythons import system and simple unit-testing for beginners?
Did you take any full length courses in python.. or just decided to jump in?
It's a feature, not a bug. I use it all the time instead of triple-quotes to nicely format long strings: print('A long string\n' 'Second line\n' 'Third line') Triple-quotes work, but the formatting is ugly: print('''A long string Second line Third line''')
The bureau of labor statistics (which you mention in your post) defines [computer programmers](https://www.bls.gov/ooh/computer-and-information-technology/computer-programmers.htm): &gt; Computer programmers write and test code that allows computer applications and software programs to function properly. They turn the program designs created by software developers and engineers into instructions that a computer can follow. And [software developers](https://www.bls.gov/ooh/computer-and-information-technology/software-developers.htm): &gt; Software developers are the creative minds behind computer programs. Some develop the applications that allow people to do specific tasks on a computer or another device. Others develop the underlying systems that run the devices or that control networks This aligns pretty well with my experience. The deeper into software development I get, the more I realize that planning is as important as coding. I think a software developer is one who can take requirements and plan code which meets them but is also testable, maintainable, readable, extendable, etc. A software developer also thinks about how the code being written fits as a part of a whole and makes decisions accordingly. By contrast, I feel that a computer programmer is one who is specifically tasked with writing some code, and not thinking about it much further than that. 
Agreed, this is a fantastic feature. 
The early Reddit in python was based on the Pylons web framework. I would suggest at least updating to the Pyramid framework which is a collab with the Pylons project and other projects. Pyramid is a great, lightly opinionated framework that gives you lots of the same power of Django, but more freedom. I often say, with Pyramid you are writing Python, with Django you are writing Django.
For more complex queries, writing out the raw SQL is often easier than writing it in SQL Alchemy, while with LambdaQuery it is very intuitive (for me at least). The syntax is very similar to Quill in Scala. The best demonstration is just looking at the documentation, especially some of the later examples. http://lambdaquery.readthedocs.io/query.html
React Native
Installing py3 overrides your pip to use pip2 to pip3. It gets less confusing just deleting pip alias altogether and just always using either pip2 or pip3 
EVERYONE STOP WHAT YOU'RE DOING AND USE GOOGLE'S COLAB (colab.research.google.com). No more buggy installs, free GPUs, christ almighty stop doing deep learning on your local machine. 
&gt;In short the way I see the difference between a computer programmer and software engineer is like the difference between a mechanic and an automotive engineer. I very much disagree. Many states require people with "engineer" titles to have an engineer license. In Texas, for example, if your job description includes the word engineer, you must hold a professional engineering license in that field. For that very reason, in Texas you'll only find "software engineer" jobs at huge companies who. 
Currently working through ‘learn python the hard way’ it’s well written.
FreeBSD is not dead!
Probably too thin, but you can add the following to the list of links: - https://www.anpylar.com - A Python client side Angular-like web framework And its playground (samples and editor in the browser) - https://playground.anpylar.com
I don't know about that. I work in materials and a competing company I know of out of texas has 10+ "engineer" positions on Indeed that have no experience requirements.
You need to make sure youre three backticks are on separate lines when using them to format code in a reddit post. It looks horrible at the moment. There most definitely isn't a problem with how python 3.5 is supposed to work, otherwise it would've been discussed and fixed years ago. That would be a huge thing to have "break". I would suggest you try running a file from python in the command line, i.e ``` me@comp1:~$ python package/subpackage1/moduleX.py ```
if your script throws an exception in middle of no where, you don't need manually `set_trace()` Just change `python xxx.py` to `python -m pdb xxx.py` Then off you go, debugger stops at right where the exception line. Alternatively, `python -i xxx.py` then `import pdb; pdb.pm()`
Hah, is it in TX too?
What about `textwrap.dedent`? &gt;&gt;&gt; one = '''A long string ... Second line ... Third line''' &gt;&gt;&gt; from textwrap import dedent &gt;&gt;&gt; two = dedent('''\ ... A long string ... Second line ... Third line''') &gt;&gt;&gt; one == two True
Do you think that this is a good example when OP should switch to Apache Spark or something for better utilisation of the memory??
Why import a module to do something simple? The '\n' chars have to be added when concatenating string literals, but I still prefer that to the "one" construct.
 from library import algorithm algorithm()
It's a great language for putting together and delivering payloads, but I wouldn't want to use it for something runtime intensive. I like what one commenter on the site had to say, &gt; I love Python and would like it to have a modern VM, so that all these other project were not necessary. Nuitka, Unladen Swallow, Gilectomy, PyPy, Pyston, stackless, etc. Imagine that all those hours and talent poured into “alternative” solutions were somehow coordinated into next generation standard Python runtime.
Anaconda completely fucked my installation of Python so I just bit the bullet and did a complete uninstall/ fresh install with conda. That's probably their entire business model- don't play nice with other installations to force users to depend entirely on their repos.
I recently had an issue similar to this with a large dataset. I had plenty of memory available but the notebook was having issues loading the data frame. I messed with the buffer size max in the jupyter_notebook_config.py file and it worked. Depends on how you are loading the csv I suppose, is it on your local machine or are you pulling a request?
It might be the CSV loader that's choking here. You could try using an external tool to convert to HDF5 first (and pay attention to data types).
Me too thanks
But the slash itself was a major source of hard-to-find bugs in python 2. To the extent that in python 3 (and later versions of 2) having any whitespace after the \ at the end of a line is a syntax error. After that experience I never used the \. There are better ways to continue lines, and that includes the literal string concatenation.
&gt; Why import a module to do something simple? It may not be the answer in every case but why not? It seems to address your concerns about formatting and it is built-in to the standard library in both Python 2 and 3. For example, `textwrap.dedent` helps with readability when declaring a multi-line string in a section of code that has a few levels of indentation. &gt;&gt;&gt; class Hmm: ... def multi(self): ... return '''\ ... Testing ... 1 ... 2 ... 3''' ... &gt;&gt;&gt; from textwrap import dedent &gt;&gt;&gt; class Dedented: ... def multi(self): ... return dedent('''\ ... Testing ... 1 ... 2 ... 3''') ... &gt;&gt;&gt; Hmm().multi() == Dedented().multi() True Adding newline characters to strings just reminds me of this suggestion from PEP8 about avoiding backslashes in strings. &gt; [When a string contains single or double quote characters, however, use the other one to avoid backslashes in the string. It improves readability.](http://pep8.org/#string-quotes) 
&gt; Adding newline characters to strings just reminds me of this suggestion from PEP8 about avoiding backslashes in strings. Of course, I'd use `'\n'.join(list_of_strings)` if that was a concern, but still there's a string with '\n' so I don't see that's an improvement. It all comes down to "readability" which is, unfortunately, ill-defined and dependant on personal likes. Pep 8 and 20 are only guidelines.
Are you sure it didn't just mess up your PATH? 
It probably feels OK for me as I'm an old C programmer and that sort of thing was part of C :)
Surprised no one has mentioned dask. It’s pandas, but designed for when the data is too large. It doesn’t do quite everything pandas does, but it’s got most of the commonly used functions. It’ll abstract away all the trouble of processing by chunk
&gt; If debugging is like sex, than writing a test suite is like a relationship Quote of the day for me. lol
Try the argument engine='python' in the read_csv function. The 'C' engine is quicker but fails on larger files.
Here is the solution to your problem. https://lab.nexedi.com/nexedi/wendelin.core "Wendelin.core allows you to work with arrays bigger than RAM and local disk. Bigarrays are persisted to storage, and can be changed in transactional manner. In other words bigarrays are something like numpy.memmap for numpy.ndarray and OS files, but support transactions and files bigger than disk. The whole bigarray cannot generally be used as a drop-in replacement for numpy arrays, but bigarray slices are real ndarrays and can be used everywhere ndarray can be used, including in C/Cython/Fortran code. Slice size is limited by virtual address-space size, which is ~ max 127TB on Linux/amd64." 
&gt; They turn the program designs created by software developers and engineers into instructions I have literally never met anybody whose job description is "programmer" because they have "software developers" dictating designs to them. I've met "architects who don't code" (universally terrible at their jobs, mostly java for some reason, but that's another story), but people who write software who can't do testing, CI, git, etc. are not "programmers" instead of software developers, they're just "bad programmers" or "bad software developers".
No meaningful difference. I think the bureau of labor statistics just doesn't understand the industry if they're trying to draw a distinction.
In my experience (admittedly limited), it’s really hard to get a bot functioning on twitter. They really try to make it difficult. If you get this working, please give us update on how you did it!
It is quite common when starting to learn programming to be worried about picking up the wrong language. Do not worry about that. When you get the hang of programming you will be able to switch to other languages. It is normal to have experience in a few languages when you have worked for many years in the industry. Sure, some work with the same all the time too but that is probably just because that is the one they need and if they needed to, they could learn another. Out of experience we can tell that programming languages don't just die. It takes a very long time for languages to fade. If you learn Python now which is very popular, has a big community and lots of cool libraries. You do not have to worry. We can't know the future but we can tell that something with a big community right now has great potential to live for a long time.
The general rule of thumb is you need memory capacity ~3-4x the side of your file for the Pandas DF. For a start, try running your script as a straight Python script, rather than via a jupyter notebook: the notebooks and supporting stuff can take up more memory than you might think, I also find that the kernels run by jupyter (for all its benefits) do tend to die a bit easier than they should. You can try Dask: it replicates a lot of the Pandas API's, so it should be familiar to use and automatically handles parallelisation and chunking, so you just define what you want to happen, and it will execute it. I've used it on files ~20gb, and a directory of files ~100gb without issue. If you don't want to do that, stick it into a db like SQLite. SQLite is seriously a fucking gem: it will happily load up large CSV's directly, and without much effort (setting a couple of indexes) it can be surprisingly fast. Plus Python and Pandas both have nice and simple integrations with it. Continuing down the db route, if you have a GPU I would 100% recommend MapD. It is stupid, stupid fast (but really only when running on a GPU). Don't have a GPU and SQLite can't handle it/isn't doing the job? I haven't played with it yet, but Clickhouse DB is supposed to be *really* fast.
No, I'm upset I have to clean the garbage after someone like you because people who let people like you post garbage to public repositories do their janitor duties poorly. I don't like Python. My favorite languages are in the Lisp / Prolog family. I deal with Python garbage because the history of programming is made buy entrepreneurs and, most of all, dumb luck. Python used to be more on the dumb luck side, but now there are corporations who try to capitalize on its success.
It's very well possible, but I'm pretty sure all the stack overflow threads I found with my error message said it had to do with conflicting installations.
On OSX the easy RAM monitor is called Activity Monitor, can be found with a spotlight search. Additionally, I have been loading a ~4 GB csv consistently with pandas into jupyter for the past few weeks on my Mac with 16GB of RAM, so it sounds like there is some other issue going on here.
"Motivation: shortcomings of SQL : SQL is a pain in the ass to write" Is it though? In my opinion SQL is one of the easiest and even most pleasant languages around, but some programmers just don't bother actually understanding the intricacies, because ..?
The default use of tables aliases I can understand, cause you need them anyway in some of the joins, but I really don't like the GROUP BY 1..
lol 
Making a Twitterbot is fairly easy. I used the tweepy module on github, they have a simple tutorial to get you started. You can use a raspberry pi and set up a cronjob to execute the script once a day. In my case, I made a bot that tweets the weather forecast every morning. If you are interested, I can give you a detailed tutorial as soon as I come home today. ;)
Something like the code you'll find at one of the 130,000 hits that google gives for python + martingale.
&gt; I have literally never met anybody whose job description is "programmer" because they have "software developers" dictating designs to them. Literally everything about programming involves creating designs. I did, ages ago - in places that hired those "architects" you mentioned. It was a miserable place, there were times when you pretty much received instructions on what to type in. Luckily my actual company was just a subcontractor, and there were other bad signs as well, so I advised my boss to jump ship ASAP, and so he did - just before the entire project collapsed because the head "architect" went AWOL. Fun times (for certain definitions of "fun").
Recruitment companies learnt what is the correct title for the job they are offering!
I have a grudge about this. Those are people who have an actual engineering degree, as far as I'm concerned (no, I don't). Whether you care about it is another matter, but we shouldn't run around calling ourselves "engineers" any more than we should call ourselves lawyers or something just because we called a co-workers code "a crime against humanity." Let's take from the ethos all right, though.
use dask, it will distribute the load. Depending on your data types 2gb should come to 8 - 10 gbs in a dataframe. If you computer doesn't have that much memory it could: spill to disk (which will make it slow to work with) or die. Dask could solve your problem. The API is slightly different to the normal pandas api. &gt;&gt;&gt; import dask.dataframe as dd &gt;&gt;&gt; df = dd.read_csv('data*.csv') You could also try partitioning the data, in most cases you are interested in analysing groups of rows not all of them together. If you are using linux, it has, by far, the best and most efficient text manipulation capabilities that can help you do this. - awk - grep - find - parallel - sort - ... to name a few 
the overhead of setting up spark outweighs any gains. I work with 1 - 2 TB of data and can't justify the investment (time and resources) to setup a spark cluster yet. 
Hi, you site not worked.
Flask
I don't know anyone who would refer to themselves as "computer programmer"... That smells very 70s, 80s. I think "software developer" or "software engineer" literally means "computer programmer" but in 2018. When asked I usually refer to myself as "programmer" or "software engineer" or, if asked by someone who knows more about the field, "systems engineer". So, from this extrapolation, all I can infer is that programming jobs have still not peaked, still increasing.
Doesn't make sense to me. I know people who studied Mathematics but even their first internships and jobs had the title "Software Engineer". If you have a math degree and worked as a software engineer for years, you're an engineer in my book. Some piece of paper saying it's a "B.A. in Mathematics" doesn't change anything.
I second the dask suggestion, it will easily scale to tens of GBs and provides a familiar API to work with. 
Agree with the folks suggesting dask. If you load this data frequently I'd also recommend converting it to parquet for much faster loading performance. Both dask and pandas now have parquet file readers via fastparquet or arrow. 
Good job man - just the fact that you have a project and is working on it is a great work. What kind of info is it(/is it going) to be designed to show? I'd really like a dashboard for varies personal metrics (weight, runs, Duolingo exp and so on), but i'm finding it hard to find just the one. Most dashboards seems to be geared towards things like server monitoring and stuff like that.
Make sure you're not using 32bit python. You're limited to 4gb of ram on 32bit.
Hello! Since you are a beginner this: http://pythonhow.com/data-analysis-with-python-pandas/ may help you.
Try this https://twitter.com/ylogx/status/948858317580902400
Thanks, this sound really interesting. I'll watch the video, and see what I come up with. 
You didn't specify what you want to do with the data in the CSV data, but maybe you can use a database? Or more specifically a column store. I would recommend an open source column store like MariaDB Column Store, MonetDB, or Postgresql with CSTORE FDW. * Column stores are fast, especially for aggregate function queries. * Tables have great compression. Save time compressing/decompressing gzipped data files. * No need to create appropriate indexes, not even a primary key. Just need to create the table DDL "CREATE TABLE t (a int, b varchar, etc);" * Loading data into a column store is FAST using the relevant data loader like "LOAD DATA INFILE ..." or "COPY ..." SQL commands. For a smooth introduction, checkout MonetDB Lite, for python. Like SQLite, single file, single process database for your current python process. https://www.monetdb.org/blog/monetdblite-for-python Look at Parallel Data Loading, in the documentation: https://www.monetdb.org/Documentation/Cookbooks/SQLrecipes/LoadingBulkData 
I tell people I program machines. 
http://pyjs.org/
just be grateful they don't list fucking "code ninja" or "rock star whatever" or other hipster startup nonsense.
I've got a few up and running with no problems at all.
I've got a few up and running with no problems at all.
Maybe OP received the data from a 3rd party and is cleaning it before a database load
Hence ops post about the decline of that role.
You haven't listed out the things you think you need to do so it's difficult for someone, not against the idea of lending a hand, to work out what skills and help you are looking for. (You do need to use letsencrypt to sort out the lack of SSL on your demo site)
I'm in a similar situation as OP, do you have any particular DB you would recommend for working with Pandas? I have multiple multigig CSVs that I am cleaning and currently just pickling back to disk.
Is it just me or did that post say absolutely nothing of substance?
No, it's like having a software engineering degree (which isn't really a thing, but let's go with it) but doing statistics for years, then claiming you're a statistician. And you'd be correct. I have a neuroscience degree, my job title is software engineer. I don't tell people I'm a neuroscientist...because I'm not. A degree doesn't define you outside of college.
Hi everyone! I'm the author of this post, if you have any questions please post them here, on our mailing list or on IRC, and I'll be glad to help!
"Engineer" is a degree, though. Statistician isn't.
Is there a reason you're using Basemap, which is EOL? Assuming you're unconstrained in your choice of library, use [Cartopy](http://scitools.org.uk/cartopy/docs/latest/matplotlib/intro.html) instead, which you can [easily add images to](https://matplotlib.org/examples/pylab_examples/demo_annotation_box.html).
404 page
There aren't blank engineering degrees. There are statistics degrees. And again - your job defines your job, not your degree.
I'm using basemap because of the shape plot of cities and the ease of plotting the satellite data I'm using.
My view is similar go Gandhi's when asked what he thought about Western Civilization: "I think it would be a good idea." I call myself a software engineer, but I won't call anyone else that unless they exhibit some engineering principles: KISS, redundancy, planning, iteration, design, analysis, etc.
PSA to all pandas users: As [explained by a lead pandas developer](http://wesmckinney.com/blog/apache-arrow-pandas-internals/), the safe rule of thumb for pandas is 5-10 times the ram as the size of your data set. So I'd say lack of ram is definitely your problem. For all it's great functionality, pandas does have some resource issues. As others have suggested, you could read and process just chunks at a time, or you could try a different technology. Or of course if you have access you could get a machine with more ram
TwitterAPI is closest to Twitter's actual API. You pretty much can just go to Twitter's own API docs to use to use the TwitterAPI package. Also, whether you do REST or Streaming, it's the same function to iterate through tweets, so it's easy to go back and forth between the different endpoints and not change code. Lastly, there are good examples for writing REST or Streaming requests that handle all exception cases, so it is possible to write code that keeps running as long as possible.
Pandas seems to work quite nicely with SQLite.
There are a handful of [micro]frameworks for that in python. I just find that unnecessarily verbose and complex. My approach is meant for those which do not need to keep fancy separate injection contexts. As a bonus you get seamless support for lazy dependency init. In the end just using Injectable's @autowired decorator will solve some problems for you without the need to change much of your code beyond decorating functions and turning some arguments to keyword-only args.
I'm working on some performance improvements for [a stateful data streaming framework](https://wallaroolabs.com). We wrote the system in a language called Pony, but we expose a Python API that developers can use to create applications. We're using an embedded Python interpreter, and consequently we're figuring out how to make the Python and Pony runtimes work together. Pony is actor-based, and the runtime basically manages a thread pool, which is great for writing actors, but a little tricky for things like Python that make strong assumptions about threading.
Nope, Utah. I've honestly never used my stamp, thinking maybe I'll just start selling blank pieces of paper with my stamp and signature for $5k, good business plan right ;)
Heh, it's extremely easy. You just get tokens and private keys that you enter to your script and then you can use a library like tweepy to do almost anything. ( Just Google it please. )
my implementation is in python, so i used python-mysql
Yes, but why reinvent the wheel at all? There's a premade tool that ships with MySQL and does the exact same thing your code does, and is probably faster at it.
yes you are correct, but this can be used in python based application where you want to automate the import process through hard core coding..
Full disclose: my experience with Haskell has so far been limited, but it's next on my list of languages to learn after I get to grips with Rust, so what I know it's based off some basic experience, reading guides, articles and Reddit discussions. Basically, it has some disadvantages: full immutability means you can't mutate/change arrays in place, it's also not a very beginner -&gt; intermediate friendly language (but I understand the community is working on this). If you're unfamiliar with static typing, it can feel weird, but you get used to that really quickly. However, the language design makes it really, really easy to write code that acts on your data in a way that is very close to how you tend to think about processing your data in a mathematical sense: like a flow of data. This is cool because your code becomes a lot closer to looking like just the transformations/actions you're actually applying to your data. Lazy evaluation also comes with a bunch of benefits: it becomes trivial to write streaming solutions and combined with the type system the compiler can do cool things like figuring out that that it might not actually need to perform X/y/z operation on the full matrix, instead it only needs to act on a subset, which can alleviate the issue with immutable arrays I mentioned earlier (obviously sometimes you do need the whole array though). It's got a bit of stigma for being a weird language, and there's plenty of weird terminology, because in many ways it's actually a lot closer to it's mathematical underpinnings than many other languages, but once you get used to that, it can come with a lot of advantages. My favourite example of this is this: http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html It's also been around for quite a while, so it's very mature, package and feature wise. If you're interested, it might be worth poking around the subreddit for data science related topics because there's some interesting links and discussion. Don't be put off by the jargon.
I've yet to run into issues with a psql database. 
It does, because I used them in the comment you just replied to
From Wes McKinney, Pandas creator: &gt; pandas rule of thumb: have 5 to 10 times as much RAM as the size of your dataset [Apache Arrow and the "10 Things I Hate About pandas"](http://wesmckinney.com/blog/apache-arrow-pandas-internals/)
Honestly, Ansible is also my recommend because unlike all of the other configuration management suites, you can deploy it within an hour and be running right then and there. I've used two approaches with deployments in the past. The first, code we wrote was bundled into "releases" on an internal gitlab instance and deployed with the instance specified in the playbook. The second, you can wrap the code into an rpm in a localized repository and deploy it with versioning that way. Both accomplish the same thing in the end, it just depends on what you have and how you handle updates.
My favorite is [postgresql.](https://www.postgresql.org/) If I can't use that one, I will generally use [mariadb](https://mariadb.org/) (which is mysql).
What do you want to do with the data? As long as you're not doing anything too crazy, I wouldn't switch to a database or some fancy distributed solution (it's only 1G after all). For example, if you just need something like the sum, mean, max, etc of a column, just iterate line by line. This is a tough question to answer without knowing your specific needs.
once you have it working, you could also host it for free at https://www.pythonanywhere.com if you dont have/want to host it from your laptop/raspberry pi, etc i havent used them, but i thought about it for a twitterbot 
Load up some technical data from your job and make some plots for visualization 
I think writing a program that will make your life easier is the best way to start. It will retain your interest and it will make your life easier. Maybe automate a boring aspect of work.
Is that possible with Excel based work?
at first i thought you tweaked something at my repo (https://github.com/mariochampion/roboflow) and i was all "whoo, someone else resolved an issue for me!" but i think you mean to TF's repo... intriguing. i wonder if they think of going to stderr as a feature or a bug. i m going to have to look that up! and at the least it should be way more clear. good idea. 
For everything a place. Without knowing the requirements it’s hard to say. 
Not sure what my end goal is... somehow incorporate usage of the language to visualize financial data? Help amplify financial analysis and reporting?
The OP hasn't said what he plans to do with the data, or what resources he or she has available. So, the solution might be spark, dask, buying a larger machine, uploading into a database or massive hadoop cluster. Or...if all he's doing is simple exploratory analysis, data profiling, data transformation, or building a simple aggregate - then use the csv module and read &amp; process one row at a time. It's the simple, inexpensive &amp; fast solution.
Take a look at [bokeh](https://bokeh.pydata.org/en/latest/). Play around with it, create a few basic graphs that mock up what you want to see from your actual data, then work on importing the actual data into the script. Grow from there.
hello, k900! nice to see you again!
Extremely viable solution for package management : conda (https://conda.io/docs/). In addition to dealing with package management and their dependencies (including binaries for all targets), conda is also an environment manager. Try it once and you will not regret it. 
Why 3.3.3 specifically, especially on Windows?
`more -c1` should do exactly that. What terminal emulator are you using?
Pythonanywhere is good for this, it's what I use for my twitter bot. If you want multiple bots in the future, you'll need to pay. 
No need to use cat, you can just pass it straight into more.
What did you use to generate sentences and do those sentences make sense?
Didn't I just read somewhere in this sub last week that Pandas requires nearly ten times as much available memory as the largest array that you are trying to process? If so, this operation may require up to 10GB. I think I bookmarked that thread, but I don't have time to go look for it now. When I get to work I will see if I can find it. On the other hand I am saying that I may be wrong ...
Also true. 
I've been structuring projects following http://docs.python-guide.org/en/latest/writing/structure/
"Engineering" is a degree "Engineer" is a license
Hii guyss m yash . i really need some money for my operation in next two months so i am earning via youtube please help me to get views and subscribers it will be great help my video link https://youtu.be/OjlsVWeYS40 
Yep, I tried a few queries and nothing worked
I tried basic ubuntu terminal plus about 10 downloaded with KDE etc. but all of them shows file from the beginning and a string More in the bottom
Can you post the exact command you're running and the output of `more --version`?
Post the exact command please. 
It's `-c1`, with the digit one, not the letter L. 
that is exactly what I was looking for. sorry, i couldn’t just copy paste it
Or do you mean that this works and you couldn't copy/paste it into the terminal? FYI, you can press Ctrl+Shift+V to paste in the default Kubuntu terminal application, Konsole.
Then try Boost - it's a great Reddit client that uses a different font for code blocks, making 1 and lower case L a lot more distinct :)
Maybe this https://github.com/LevPasha/Instagram-API-python ?
You should be able to load bigger than that in pandas without issue. I had to load 34M rows at around 6-7GB in recently. Took a minute or so to do the initial read, and then pandas was slicing the data with no problem. And I was doing it all inside pycharm.
Basic courses don't cover linting tools because linting is not important when you don't even know the language.
Especially since Kubernetes is built with Go and GKE is a pretty big product. I'm more than sure that they use Go in production.
can u help me subscribe to the current price I have no idea how to work this code? very new to all this and YT isnt helping
Also the part about Quore where: &gt; At the time, Java was also in its infancy,... But then &gt; Another key consideration for using Python was the existence of several good frameworks at the time including Django and Pylons... Java being released in 1996 and Django in 2003...
I am still learning too but for me what I found good was reading up on an area of interest like right now I'm learning about web-scraping and then using that knowledge to make something useful for me, even if it has already been done that doesn't matter, because you have never done it before so you will learn a lot from making it :)
A million rows is not usually enough to need a solution like spark, especially if his problem is loading data into memory. I would start by only loading columns I need. If he having trouble with a million rows I'd assume he has very many columns or fields with memory expensive data types (lots of strings, mixed types, etc.).
I think pandas had a huge overhead, uses ram for several x the size of the data.
financial analyst... Mine!! :-D https://github.com/tg12/FAIG 
Python is so easy to read and write that it makes sense why a bunch of companies that rely on the developer ecosystem use it. A lot of people in my area use Python to learn to code so we use a lot of Python here when developing our web applications.
Better template won't harm a novice programmer. Look at the Django quickstart that covered project structure, writing tests... and never mentioned that whole example project could be packed in one module.
Django is a framework that has a generally-accepted file structure. I agree that a template will help, but that level of detail may not be the focus of every tutorial.
amateur
Yeah I suppose I don't mind the multi-line literal string concatenation, it's the "same line" literal string concatenation that is the source of potential bugs.
Hello, here is something I wrote that logs all the data it can from gdax: https://github.com/petertrotman/gdax-scraper It's written in Go but I think you should be able to make sense of it. It's using the websocket API. Of particular note is the subscribe function in https://github.com/petertrotman/gdax-scraper/blob/master/gdax/gdax.go It uses this library for parsing the responses so that is worth a look as well: https://github.com/preichenberger/go-gdax In particular: https://github.com/preichenberger/go-gdax/blob/master/message.go is the struct with all the possible returns from the API. I'm sure there is a Python equivalent if you search for it. 
It's not: Go is the fourth canonical server side language, and has been for years. Javascript and Typescript have been canonized for client side development, while Dart is supported by the Ads org. Specialty languages like Swift are allowed in their respective domains.
Interesting task and probably a great learning experience, but if you wan't some infrastructure, check out [Ansible](https://www.ansible.com/). It does exactly what you're looking for. 
If you need suggestions, check out BeautifulSoup4 :)
I can't figure out why MacOS still comes with Python2. Also Debian. It causes all sorts of trouble. How long is it going to take them to catch up?
Still, it literally takes 5 seconds to install Python3
pip install catboost
Use bash: ``` cat myfile.txt | while read line; do echo $line read -r -n 1 done ```
Something like this? https://pastebin.com/Kem96qP1
i need 3.3.3 because a need to match the same version that my collage has. 
&gt; reddit &gt; spotify &gt; software companies
Backwards compatibility. The problem isn't upgrading python it's upgrading all of the tools which depend upon it which are required in order to make the OS function.
it scrolls with supersonic speed through the document. I barrely can see any words
yep, that works great!
OCaml / ReasonML are getting a lot of traction at Facebook. They have basically ported Messenger to ReasonML with more planned migrations. Just watch a few of Cheng Lou's talks.
Couldn't you use selenium to fairly easily download any song you want from YouTube and play it when you want, and delete it and everything after? How do companies manage to make people pay for music? We should stop wasting money on preventing people from downloading good music, the endowment for the arts should be expanded dramatically, it should switch with the military budget
Are you running Debian Stable? If so, that's not a great place to wait for timely updates. KDE Neon loads py3 automatically
I'd say train a ML algo to recognize the X's in a pop-up and click it
In order to get "count" to +/-3, it will always take an odd number of runs through your while loop. So subtract an odd number from 10, and you get an odd number. And then add 8 to an odd number, and you get an odd number. The only exception is if the count never reaches +/-3 and exits when purse=0. Also, r/learnpython
But nothing can compete with one line of bash
I think VLC has a special RC (remote control) interface that would at least remove the requirement to simulate keypresses
What do you mean what did i use. I used python. Mostly the sentences are just goofy but sometimes it spits out a good one. Ex: "The attorney separately overawed unpleasant budgets." 
What process do you use to build the sentences? Markov strings or something?
This is great Olav! Thank you for explaining even the basic parts of Blender. For someone not coming from a 3D background, this is a huge help.
Top secret bro, sorry 
You can't. The frontend must be HTML, CSS, and JavaScript. The backend can be python or anything else that you like, like Flask. But all the sites you listed are very heavy on the JavaScript side for their frontends.
JP Morgan has over 25 million lines of Python in production used mostly for data analysis. And, at this point it would be easier to name big enough shop that *doesn't* use Python for something.
&gt; I'm more than sure that they use Go in production. They do. The end.
I've dealt with way worse logical errors and this is like something that I'd get stuck on only during my first year of introductory programming.
Imagine you have a 3x3 matrix. It's not an integer and it's not a float, yet you can add, subtract, and multiply another matrix or integer/float with it and get a new matrix. Python does not have a matrix class built in, so I could either use numpy or I could code my own with lists of integers/floats. Strings don't fundamentally have an add or multiply method either. We define add as concatenation and multiply as repeat this string x times (but only for integer values of x). Why make me type `string1.concatenate(string2)` or `string2.repeat(5)`.
Depends on what the popups look like. You could open a bunch of pages on the sites you wanna use and put like a purple dot or something wherever you need to click in order to delete the pop-up. If you can figure out the code behind the popups, you can train your algo on the code itself, so the coordinates of where you need to click to rid the screen of a pop-up should just be some x,y coordinates. But if you're gonna use pixel data, you'd have to put like a thousand purple dots where the X's are so that you have like a thousand examples of where to click, slap some autoML on there and reward the algo for decreasing the distance between the purple dot and where it clicks. 
Or Dart?
Added to [the DI section of the Python OOP list](https://github.com/metaperl/python-oop/blob/master/README.md#dependency-injection). 
Well, emacs would be a good OS if it just had a decent text editor
Why does this article not mention Instagram which is build from front- to backend in Python/Django?
Yes, I have thought of that lol! Thanks, I know it need to do that. It works well though. 
&gt;Because of Ubuntu and Debian coming with python standard... yes... No, because Python is the official language of the Raspberry Pi. "The Raspberry Pi Foundation recommends Python as a language for learners. " &gt;And I mean, you shouldn't pick a language because some company picks &gt;a language. Yes, you should. &gt;You should pick a language because it's best suited for what you're doing &gt;and your time constraints. Does this language have any users? Are there any libraries available for it? Does it get bug fixes and other support? If a major company uses a language, they've no doubt weighed these considerations and many more. The language should be well-supported. They may have billions of dollars on the line. That they've opted to use a particular language is an expert endorsement. 
It is my understanding that the Raspberry PI organization has focused on Python as a primary language. I could be wrong of course but there is a heavy emphasis on Python in that community.
I've been so frustrated of late with Apple I went out an bought a Windows machine with the eventual goal of running Linux on it. It is absolutely pathetic that Mac OS is still on Python2
That's one of the best ideas you can have nowadays. What I described to you isn't the way to do it, though, it's probably not even close. So yeah, you'll have to look into ML
Exactly. I myself studied computer science and I have a "B.A. in Computer Science" because my school (UC Berkeley) gives B.A. to all degrees (so does Harvard, old schools tend to do this). But starting from my first job, all my jobs had the title "systems engineer". This is what I applied for, what I interviewed for, and what I'm paid for. I don't go around claiming I'm a "computer scientist" because I studied "computer science" instead I claim I'm a "systems engineer" because that's literally my job title. It makes sense to me idk.
cool. post back if you try it out. good luck!
Fair enough! I have not used Urwid before, that is why I was curious what led you to it. The "right" tool is whichever one you're comfortable with that does the job :)
I don't think it's something where you just have to get over a plateau and then you've made it. The best programmers might never be caught up to, even by the second best programmers. I think it's really valuable for anyone to think the way a coder does, if only for a few months. Don't waste your time on anything you find boring, find interesting online projects in medium articles, and check out Google's and OpenAI's information on machine learning. Selenium is a great tool, it's exactly the kind of thing that if you put it with machine learning there's code you could write that would cause problems. Coding isn't about finding a way to make money, it's about finding a way to not have to make money. And the one everyone is working on is AI. Don't waste your time with websites, java, apps, games, anything like that. Use frameworks like Google's PWA framework if you want to convey information from a computer. Coding isn't fun, the fun part is the design. And more and more, our designs are becoming the label data for AI. 
What i love is that they absolutely do not use angular in their stack at all... talk about not dogfooding your own shit.
If it ain't broke don't fix it?
Word. There are times to use python, bash, node, go, lisp, clojure, etc etc. Use case over personal preference makes for long lived and hardy infra and software. tho php needs to die, lets be honest.
Jesus, you sound like and altcoin shiller. Rofl.
Just be weary of ORMs if you are gonna work with large relational datasets. They are aok for PoCs but will fuck you up in the long run. 
Could not agree more about PHP. Pretty horrible process. That's what that stands for.
Frameworks can reach maturity much more easily than languages.
If Basemap is EOL why is there no big warning here [Welcome to the Matplotlib Basemap Toolkit documentation](https://matplotlib.org/basemap/)?
Maybe, but that was not the case for Java nor Django in that time line. 