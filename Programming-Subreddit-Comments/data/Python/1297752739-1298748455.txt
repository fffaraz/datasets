As someone who writes Python every day at work, I probably spend as much time typing in (i)python as I do in vim. Often the code I write is purposefully structured to be easy to use from the REPL. And the best part? That usually means I'm writing better code: * shorter, single purpose, side effect free functions * fewer dependencies * straightforward code flow The added bonus is that also makes writing tests easier, and I've probably already got snippets in my REPL to copy &amp; paste into my unittests. That being said it's not for everyone. Some people prefer just working away in more full featured IDEs instead of experimenting in REPLs. Some of the python best coders I know use pdb to drop straight into a specific spot in their code instead of messing around with long REPL sessions. REPLs may be the easiest way to write a tutorial but don't think it's the only way to write Python.
Matplotlib is a very specialized library that doesn't have a lot of mainstream use - I'd suggest posting to the matplotlib mailing list. I've found them to be very responsive, and have seen simple fixes and patches posted within a few hours of asking them about various bugs or issues I've found.
1. doctests.... in python there is the general idea that you can move fluidly from any interpreter session to a test. The format of a doctest and an interpretter setter are more or less synonymous. 2. from readline import write_history_file . It's trivial to go from interpretter session to script. 
I don't see what's stopping you from typing the code in the tutorial into a file instead of into the interpreter.
I'll give that a shot thank you
And me. *type one error in line while using interpreter* *type everything over again* (or press up-enter multiple times, still annoying)
ctrl+r FTW!
Agreed. Also trying to do OOP in the interpretor directly is bound to fail...
With a virtualhost on apache, maybe you don't even have to buy an additional IP
Really? Do you have any useful links?
Even "simple" functions are a PITA. A function with some kind of a loop that contains a conditional of some kind inside, is a recipe for troubles in the interpreter. 
Unless you're hosting extremely popular sites, you've probably already got enough bandwidth with your single Linode VPS that you can host multiple sites from the one VPS. With a little work, you can use nginx to hand requests over to fastCGI. I've blogged about this a couple of times: http://demongin.org/blog/846 and http://demongin.org/blog/847 PM me or email me (contact page) if you have any specific questions; the first post is about setting up fastCGI and the second one is about writing an init script to start multiple sites on boot.
Django is pretty much designed from the ground up to host multiple sites/projects on a single server and share apps &amp; models between them, that's one of its major selling points. Do a search for 'django multiple sites' or 'django virtualhosts'. I'm sure there are plenty of tutorials &amp; threads discussing it.
Potassium to you too..
There's also [/r/django](/r/django) for another resource.
http://httpd.apache.org/docs/2.0/vhosts/examples.html The idea is that you dispatch request according to the url requested.
I'm guessing 2.7 compatibility will help pypy 3 support in the end. Many of the features in 2.7 are backports from py3k to ease the transition from 2to3. And pypy must support the industry standard in order to be relevant. Sadly, today the industry standard is still python 2.7.
Because they bothered with 2.7 in the first place. [It's exactly as I said it would be.](http://www.reddit.com/r/Python/comments/amrdf/pros_and_cons_about_python_3/c0ie9pd) 2.7 is slowing down adoption of 3. Everybody stuck with using old code would have no problems whatsoever with 2.6.
You can do a virtual host with nginx and it's even easier too, http://wiki.nginx.org/VirtualHostExample And then dispatch to different apache instances / ports / etc ...
Or HAProxy, since it's bordering what you want to do. Unless you want to do static files with nginx, in which case carry on. Personally I'd do HAP -&gt; Varnish -&gt; Django
For a Perl 5 repl, install Devel::REPL, then run the included `re.pl` script. Perl 6 has a built-in repl just like Python. 
I think you should have a *taste* of everything. A bit of C, Ruby, Java etc. Even if it's only a single tutorial. So yes, learn some python, it won't be any harm. PHP has a few things in favour of it: * Easy to host which means there are popular content management systems for it. * Many people know it, so companies find it easy to hire. Python is easier to read and more powerful (less lines), which generally means fewer bugs and easier maintenance. Not only this but the standard libraries are truly object oriented which you won't find in PHP. That alone encourages a different way of thinking than PHP does. It goes a lot deeper than "*a lot more readable* as there are features available in python which you will not see in PHP. List comprehensions, itorators, generators, closures... I would suggest you learn python first so PHP doesn't rot your brain too much. Since you say it's for personal projects I would recommend a python framework. You don't need to worry about the above. There might be few hosts for Django, but you only need one. Web faction and Djangy seem to be taking away most of the hassle. It comes with a built in development server, so you don't need to set up apache on your local environment. Anyway, don't let anyone sell you on a programming language, you need to test drive it. Dive into python (http://diveintopython.org/ or http://diveintopython3.org/), and the Django polls tutorial (http://docs.djangoproject.com/en/dev/intro/tutorial01/) should get you started. 
For a lack of vision, the people perish. Python2 will be relegated to security fixes only at some point with *all* core development going to Python3. Python3 **is** the future whether they like it or not.
Thanks - that's great - got it working
There are other uses for _ as well. It can be used as throwaway variable name in your code.
We are only half way through a five year plan. Relax a little please.
For the time being Python 2.7 will give them plenty of mileage (many people are still on 2.5 and 2.6) and by the time Python 3.3 comes out they should start to see the light and see how easy it is to switch __future__ proofed 2.7 code to 3.2. Protip: Add the following lines at the top of your 2.6/2.7 code: from __future__ import division from __future__ import absolute_import from __future__ import print_function from __future__ import unicode_literals from future_builtins import ascii, hex, oct, filter, map, zip 
One vhost approach I use if I'm using one centralized django is to make a middleware class. That class examines the vhost and then prefixes the path with something like /vhost/NAME/.... That path enters the routing phase which can dispatch as needed via the main url.py into several host specific url configurations.
for magento you should check out : http://www.satchmoproject.com/
Don't give up on the shell until you've experienced ipython.
dir() and help() rock. Use them and you'll understand why the interpreter is such a good way to get familiar with the language.
Christoph Gohlke rules for doing this.
I didn't say it was good Python, it's just the kind of crappy code I write when I want to do something quick in the REPL ;) That's one of my reasons for suggesting people learning to program shy away from using an interactive environment at least some of the time - good code is meant to be *read* not written. def gimme_files( basedir, extension ): files = [ os.path.join( root, filename ) for root, dirnames, filenames in os.walk( basedir ) for filename in filenames if filename.lower().endswith( extension ) ] return files and in this case, no, you don't need to create strings as files is already a list of strings. it's just a habit I've got into because I'm often working with lists of integers or other objects where joining requires a list of strings. 
Can you repeat yourself again?
Yes exactly. The Python3 faction knows what is best for us. We should be more than happy to be a test user base for all their cool new ideas...
Dunno, it seems to me that Python 2.7 adoption isn't all that high. I notice that Debian for example does not have 2.7 anywhere (not even in experimental) while they have Python 3.1 in stable. In that particular ecosystem would it perhaps make more sense to go directly to 3 if that is your eventual target? IOW if 2.7 with the future stuff is just 3 then why bother with it?
I'm not knocking it -- I'm just looking at it from a developer/sysadmin standpoint.
I would think because 2.7 is the latest version that is fully backwards compatible with all the 2.x stuff and should get patched for a longer time. It also allows you to start writing in 3.x style without having to change any of the existing stuff that has already been written in the old style. Hopefully by the time 2.7 gets deprecated half of your code is already good enough style to make the transition easy.
I could, but if you haven't got it by the second time I doubt there's really much point. \*grin\*
[Hmm?](http://i.imgur.com/UBiCN.png) I assume you're on linux?
I personally feel the same way. Currently just beginning Python programming myself and whenever I see a tutorial using the interpreter, I just write the code inside VIM instead. Plus, you can map a key to execute the code inside of VIM (**map &lt;F5&gt; :!python3 %&lt;CR&gt;**) the 3 signifies the interpreter version to execute the code on, which is currently the newest version; if you're using an older version (2.5, 2.6, 2.7), leave the 3 out). And no, you don't have to save the file; after you run the code (via f5 for me); you can press ENTER or CTRL+C and it brings you back into your editor. You can continue editing and repeat this process until you're satisfied. I get instant feedback just like I would via the interpreter. If everything runs great, then I'm done evaluating the code and can continue moving on, if not; then back to work and figuring out what went wrong. That's good enough feedback for me. I'm sure with a little more research, one could also map the help() and dir() keys inside VIM; which would totally make the interpreter (for me) pointless. **EDIT::** [Access Python in VIM](http://vim.wikia.com/wiki/Access_Python_Help) -- Pretty good link to help get more out of Python inside VIM.
This would be a workaround, not a solution to your problem: * install [Macports](http://www.macports.org/install.php) * install python 2.7: `sudo port install python27` * run IDLE from Macports: `/opt/local/bin/idle` * optionally, uninstall Python.org's python distribution I like macports, because all the software is stored in `/opt/local`, and so doesn't conflict with Apple's base system. Also, you can easily update everything with: sudo port selfupdate &amp;&amp; sudo port upgrade outdated and switch between python versions with `python_select`: sudo python_select
By convention or does it act differently there? I think I've seen it used in list assignment for un-important vars. 
I don't know exactly what IDLE does for you- can she just use the interactive prompt from the terminal, or run a file from the terminal?
Edit and change `Python27\Lib\idlelib\config-keys.def` or the other config file(s) for IDLE. I'm guessing where your global `config-keys.def` file lives for idlelib, but I'm sure you can find it. There are also local (per user) files that might have been created as well: `~/.idlerc/config-keys.cfg` and `~/.idlerc/config-main.cfg`. Remove or adjust the offending entry mentioned in the error message. Once it works and you can open IDLE, change the key bindings from within the IDE and you're all good.
[flask.py](http://flask.pocoo.org/docs/quickstart/) 
The terminal does work, but both me and my students prefer the IDLE because of the reserved-word identifiers (colors) and the ability to adjust the settings (font size, etc). This is a 101 course.
Will try tonight - thank you!
Will try tonight - thank you!
Thing is, most of those who have taught Python think its a great way to encourage you to play with the language; make mistakes, and learn from them. Being a Perl convert you might view the Python shell as being no better than the Perl shell but this is wrong. Most people new to programming want a sense of achievement up-front which the shell can give. Scripts and the shell are both good in Python and both have their uses. Some, such as scientists and engineers may spend most of their time trying things out in a more shell-like environment such as Ipython or Sage. In a nutshell, these types of tutorials work for a lot of people. I am curious, you don't state your reasons for disliking shell-based tutorials neither do you state what you gain by rejecting the format of, in your words, the majority of the tutorial formats for Python. You might want to take the view that you are trying to learn something new, and, because you already know a scripting language, you might have to adapt somewhat to Pythons way of learning the language to better pick up Pythons way of doing things.
+1 for creativity, but remember that a writer of a tutorial cannot assume that the audience can do as you have done. Python comes with idle and a lot of tutorials are written so they can use the idle shell or the python shell.
Enterprisey as in late, bloated, and wrong?
Python makes it easy to explore. That exploration of, for example, different algorithms might look like throwing away code, but if you are using idle or the up-arrow works to bring past lines back, then things aren't totally lost.
Oh I agree and I totally understand why someone new would want to use the interpreter, but I just find that I too (like others here) learn more by writing the actual script inside the editor instead of "testing" it out first on the interpreter. Plus, there's always that question...if you're always testing your code, are you actually programming? It's something along those lines, lol. To each, his own.
I'd recommend [Homebrew](https://github.com/mxcl/homebrew) over Macports.
It depends if they are similar websites. Do they share the same database? If not you'll want separate instances. A good case for multi-site might be a company which has slightly different sites depending on country. Or a restaurant chain that wants to have a different website for each location. These are cookie cutter type sites.
The IDLE preference file probably has a bad value in it. It wont be touched when you reinstall, explaining the persistence. The preferences should be stored in `~/.idlerc` (a hidden .idlerc file in your home directory) - remove or edit that, and it should launch..
1996 called, they want their web designs back.
They're two separate sites. One for my 'freelance' site and one as a blog/tech site with some personal bits and photos.
I found these a couple of months ago when I need matplotlib for windows.
I still don't have the time or the money. But I'm looking forward to watching the videos online afterwards! =)
For learning, web2py (which was built for teaching) may be worth a look. I particularly like the web2py templating language, as it's just python (no more magic to learn). Depending on where your general skill level is, you might prefer the component aspect of django (for example, bring up mingus - virtually all built from components). If this suites you, then look at djangopackages.com, and dive in. Pinax (django) has some templates to start from you might find useful. Both web2py and django (django-nonrel for now) can readily be served off of App Engine. If you like to understand how everything its working, and not have background magic going on, then look at flask.
This or use twisted I wrote a bot in twisted and it was nice, https://github.com/jrabbit/trbot/blob/master/transtwisted.py
Satchmo requires quite a bit of work to match the slickness of Magento.
THIS WAS EPIC. Well done - this is exactly what we did and after two weeks of trying, it worked! On the plus side, I also showed my student Reddit. Thanks!
Thanks to all who responded. Fancy_pantser's suggestion worked and she's back up and running.
There's also http://enthought.com/products/epd.php w/ some non-commercial restrictions. 
Since not everyone here will necessarily know "well-known" PHP packages it's probably worth giving a bit more info. I presume you're referring to the CMS http://modx.com/ and ecommerce software, http://www.magentocommerce.com/ ? If you're considering using a python web framework and that framework is django, I'd suggest you start here: http://djangopackages.com/ for alternatives.
If you can write a caching load balancing app in python, you could probably apply for that reddit job in the sponsored ads banner. :P ... Seriously, though, I'd recommend three things: 1. build a portfolio of small (small enough to complete, that is) apps on your own time; 2. seek opportunities to use python at work; and 3. talk to recruiters and other sources for small contracts where you can develop your skills.
One word: dev ops. As more companies move to the cloud, there's a huge need for people who know how to code and can deploy and manage an app on AWS. Almost every startup I know is looking for dev ops engineers. As a sysadmin who knows a little python you're already halfway there. 
While i have absolutely no advice to offer about finding a job with an established company, don't rule out the idea of doing your own development or working on your own. The guy who started threewords.me just sold it for what i can only assume is a tidy sum of money. It's not unreasonable to go into business for yourself, either as an independent startup or doing consulting/contract work.
Where do you find those videos? I've been trying to get the videos from past pycons and I've found a few clips but nothing like the complete conferences.
Where do you find those videos? I've been trying to get the videos from past pycons and I've found a few clips but nothing like the complete conferences.
This is interesting as the catalyst for this career change was "cloud computing". The dream is to work on a team that builds cloud apps. 
http://pycon.blip.tv/
Keeping an eye out on how I can automate anything at work using python. But the ultimate goal is to built cloud apps. Baby steps I guess :)
Closest I could find in 30s was [this](http://pycon.blip.tv/posts?view=archive&amp;nsfw=dc). (BTW, you seem to have triple-posted.)
Please list your skills as a sysadmin. Your current domain knowledge as a sysadmin may allow you to easily bridge that gap into a programming position. Programming is a relatively easy skill to learn. But what you do with it depends on your domain knowledge. Leverage what you have to get where you want to go. Post your short resume here; people will give you better advise. 
&gt; Don't rule out the idea of doing your own development or working on your own. See also: open source projects. Get involved, learn from more experienced coders *and* contribute, thus building experience. Do this for a little bit and you'll be marketable and a better coder. 
Right. Or, you can also use [httplib2](http://code.google.com/p/httplib2/) that has been around for years.
No whitespace padding inside parenthesis and brackets. Apparently your code could use a little PEP8, too.
Volunteer for a non-profit, or charitable organisation. They have tech-needs, too, and won't be picky if you're a volunteer.
It's not just the cloud. I was just bemoaning the fact the other day that despite being a developer, I'm ending up doing so much sysadmin despite it not being my strength. Based on that I'd say exploit your sysadmin strengths. Right now I'd like to have better knowledge on how to monitor, benchmark, load balance, configure the several servers I've ended up having to look after to cope with the load from the web applications I work on. Just to underline the growth in the need for devops there was even a conference down here in Aus on the subject: http://devopsdownunder.org/
Agreed, httplib2 do all what this library does and it can even caches what it download.
Thanks for filling this out for me. Yes, I'm referring to those two packages. I understand that they both have very active communities and both have many plugins/extensions, which made me wonder whethere there are any similar Python packages which have had as much community support and have as much diversity.
I'm not sure what's wrong with exec, but it's definitely not elegant. What about a function that takes the type as an argument and return the desired function ? You could then use globals in order to populate the module with these functions (not sure about this part) EDIT : listen to Ronny, partial looks like a much better way to do so.
All over the place ? I don't see how pyramid's documentation is all over the place : http://docs.pylonsproject.org/projects/pyramid/1.0/
very bad idea try functools.partial(input, type='something') instead
more synchronous IO? why won't anyone ever learn what twisted has tried to teach us?
care to elaborate? I'm new at this...what's wrong with synchronous IO on a website?
For the long technical see the [C10K](http://www.kegel.com/c10k.html) problem. The idea is that if you are blocking the thread handling one user's IO, you can't be doing anything else for that user or other users on that thread. You can spin up more threads but then your kernel's scheduler gets thrashed (context switches pretty expensive and the more you do for the more threads you have, you degrade performance quickly). In many situations this isn't possible and if it's a webapp, it probably means 500 errors if you run out of threads (sort of like reddit sometimes). Also Python has [never been particularly good](http://python.mirocommunity.org/video/1101/mindblowing-python-gil) at threading because of the [GIL](http://en.wikipedia.org/wiki/Global_Interpreter_Lock) and other oddities. Handling IO async, you can free up the current thread to do other things. This is really important if the IO you are handing is not local but network but the idea is still the same if it's from disk or remote. Event pumps and async IO are more efficient at the cost of added complexity (you'll probably end up writing state machines and other fun code). Twisted Python tries to make this easier but it takes sometimes rethinking everything your app. This is the same principle in FriendFeed's Tornado, and Ruby's eventmachine, and Node.js. By all means if you are writing something small and simple, ignore me and happy coding. It just may hurt you when you scale up as nicely if you grow. 
That everything needs to be factories and reactors and oh god am I suddenly trapped in Javaland?! Twisted may be a swiss-army knife of networking stuff, but about half of the tools are chainsaws which will kill you :-\
doesn't take factories and reactors to be async. for a python example, see [Tornado](http://www.tornadoweb.org/). 
You might enjoy the [topic](http://www.reddit.com/r/Python/comments/fl0uc/new_requests_module_for_super_simple_http_requests/) posted by the author of requests, two days ago (currently still on the frontpage of /r/python).
As Ronny Pfannschmidt says, in this case, the right answer is to use `functools.partial`. In general, you need to think about making a function that returns a new function before you start thinking about clobbling together code with `exec`. Try something like: def function_maker(parameter): def new_function(arg): return do_stuff(arg, key=parameter) return new_function widgety = function_maker("widget") For your specific case, you would write something like: def input_customizer(type): def customized_input(*args, **kwargs): kwargs['type'] = type return input(*args, **kwargs) return customized_input password = input_customizer("password") `functools.partial` is a way of doing this same thing more quickly and automatically. I think it might also have a slight speed edge, because it's probably written in C. But conceptually, what you need to think in terms of is "factory"-like functions that make new, customized functions for you.
Shame on them.
 0.2.2 (2011-02-14) * Eventlet and Gevent Monkeypatch support. 
OH DEAR GOD NO
I don't think you noticed that the OP is proposing a simple HTTP *client* library, for making requests to services.
pip supports uninstall and --user easy_install did not include uninstall yet. and I don't know how to use --user with easy_install yet.
To be clearer, this is never a solution, not ever. There's many mechanisms to provide the level of abstraction you're looking for, I'm not exactly sure why you're going for the design you are, and the other solutions posted here are clean and Pythonic, but one possible example would be this. In Python, everything is an object, including functions. A 'function', as you traditionally think of it, is an object which implements the _ _ call _ _ method. So you can create an object which implements that interface and then treat it later as a function. So to solve your problem, you would say class InputGenerator: def __init__(self, tag): self.tag = tag def __call__(self, attribute, *args, **kwargs): kwargs['type'] = self.tag return input(attribute, *args, **kwargs) or whatever according to your needs. Then you can just say password = InputGenerator('password') text = InputGenerator('text') and so on. Whether this is appropriate in this situation is uncertain, but I like to use this pattern in other situations where another solution doesn't easily present itself.
Ooh! I didn't know Python allowed currying!
I mean, obviously it's trivial to implement, I just didn't know it came built in like that. Is there anything functools can't do?
Also this.
A lot of videos from pycon and other python conferences is available at the [Python Miro Community](http://python.mirocommunity.org/).
answers your question: http://pypi.python.org/pypi/pip 
Async IO ≠ callback programming model → go educate yourself and stop spreading FUD.
Here's a comparison of the differences: http://pip.openplans.org/#pip-compared-to-easy-install
What's wrong with easy_install?
`pip`. On some weird packages it doesn't work (and in that case `easy_install` is half/half: it's has special case for some stuff shittily packaged, but chances are you'll have to install by hand). Why pip is better: * The command is simpler, shorter * First-class support of virtualenv * More commands than just `install`, including `uninstall`. `pip bundle`, `pip freeze` and `pip search` are pretty nice as well. * Can install from a VCS (via `-e`), or from source * Requirements files are easy to use, clearly describes what happens in its process * If it can not download all the dependencies, it will not install anything (though I don't think it rolls stuff back if an installation fails)
coffee
note that distriubte's easy_install supports --user (i implemented --user for both pip and distribute)
+1 for requirements files! I don't know if easy_install has them because I don't use it much, but they are great and very easy to use in pip.
Requests is a wrapper around httplib2 that takes all the boiler plate code needed to make requests a much simpler. When using urllib2, I had to spend a lot of time in documentation, and the entire experience wasn't very intuitive at all. For certain types of requests, I even had to overload methods. This is not the way it should be. When I wanted to write a scraper or api wrapper or something, I would have to spend a chunk of my time in the urllib2 documentation, becoming frustrated. Requests does the hard work for you. It won't give you the mighty power that urllib2 itself does (e.g. caching, proxies, etc), but instead focus on the "90% of the time" use case. 
Well. I guess pip is better, but the last time I tried on Ubuntu, pip failed, so I used easy_install which worked. Don't remember what was it.
It seems to me that using the iPython shell is argued in this thread as heavily used to 'learn' Python, but not actually **use** it for anything extensible. Don't get me wrong, with Perl you can write a one-liner and do some pretty useful stuff. You can't write a GUI in the interactive mode, one line at a time. I can't see anyone wanting to, at least. I suppose for tinkering and playing around, the interactive shell may have its uses...I just find it annoying that I have to do that small bit of translation before I understand the code the tutorial laid out.
Author of the library here. Active State's scraped release is a little out of date. v0.2.3 is out now and gives some good HTTPError features. - PyPi: http://pypi.python.org/pypi/requests/0.2.3 - GitHub: https://github.com/kennethreitz/requests/
i think your emphasis should be on simple not client a client needs async IO as well, it likely just isn't needed by everyone
I wrote that line/library. I'm really glad to see this reaction. It's exactly why I wrote it like that. :)
I only use easy_install to install pip :-)
Please do consider following the link I provided. It seems you're confusing urllib2 and httplib2.
zbowling specifically referenced the C10K problem, which applies to web-servers. HTTP clients that need that kind of scalability are rare. I guess in most cases it would not be worth it to move your whole program to async programming style. Had I put the emphasis on "simple", I'd have downvoted myself since async libs can very well be simple. :)
See 'pip compared to easy_install': http://pypi.python.org/pypi/pip
The larger companies have hiring people who will look through your CV/resume to see if you have X years of skill Y etc so you'll have a hard time with them as you'll be filtered out long before the team sees you. For smaller companies where the team sees your CV/resume you'll need to have experience on it, which means personal and open source projects. Although this may not seem like much it is a huge head start over most others since it is possible to actually see your work. Most people without that claim all sorts of things in their corporate life but it is very hard to find out how much they actually contributed, how good a coder they actually are etc since that is all confidential and you only have their word for it. For your cloud app interests what I'd like to see is that you can automate things. For example if you helped an open source project so that they run one command and the project is deployed to several cloud servers, a test suite run, the instances stopped and a test summary shown then it would be perfect. Almost everyone doing cloud stuff has a need like this, plus you'll combine your sys admin talents with the other pieces. 
This is a "feature" of setuptools that I've been complaining about for years (and is the reason why Django doesn't put alpha/beta/RC packages on PyPI). I look forward to the day when more intelligent tools fix this.
easy_install can also install from a Subversion checkout or URL or local non-svn directory. Don't know about other VCSs.
I agree with what others said - dev ops roles might be a good target for getting your foot in the door somewhere. In the meantime community participation will help you get your name out there and form good connections. For instance, familiarize yourself with the Python EC2/Rackspace clients, figure out who is using them. There's a lot of interest in automating deployments with Fabric, Chef, Puppet, etc. Write a couple blog posts and/or throw a few useful utilities onto Github. If you're in or near a big city, it's not unusual that Django meetups have recruiters or companies looking for talent. Also, a lot of the Django Illuminati are hanging out in Convore right now so that's a good place to strike up some conversations and get some leads. 
I use easy_install with virtualenv. pip might be easier and better, but it is possible to do so with easy_install as well.
I've been using easy_install --prefix with no problems. Last time I tried pip, it didn't work.
I prefer [mechanize](http://wwwsearch.sourceforge.net/mechanize/)
PageRank is weird. It assumes that randomly clicking links on relevant terms (a "random walk") is likely to yield relevant pages. But that isn't really how relevancy is determined. Memes, for example, are as relevant as they are reproduced. Reddited links are as relevant as they are up-voted. Relevancy depends on an individual's specific fields of interests, and each community has different mechanisms for ranking. Google, for example, has its own concept of relevancy. PageRank's algorithm is perfectly happy with "google bombs" and "search engine optimized" results. Google, however, is not, and they will manually edit results when they discover attempts to "game" the algorithm. Isn't it ironic? We trust Google's rankings because they're supposedly objective &amp; True, but really there's a team of people combing them over to make sure they're "true". tl;dr; people determine relevancy, not algorithms like PageRank.
You should start working on an easy project. Something you know you will be able to finish in not so much time. Then you can judge your code and try to improve it.
If you want to learn Computer Science + Python: [MIT 6.00 Introduction to Computer Science and Programming, Fall 2008](http://www.youtube.com/watch?v=k6U-i4gXkLM) This entire [MIT course is online](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/)! [Python Programming: An Introduction to Computer Science ](http://www.amazon.com/Python-Programming-Introduction-Computer-Science/dp/1887902996) Both sources start easy and get more advanced. Both are excellent resources to learn programming practices and ideas that can be applied to any programming language. ----------------- Also good / short read with plenty of exercies: http://learnpythonthehardway.org/ 
You'll find little projects for Python. I did some really simple little cli drills for my daughter (kind of like math flash cards and things) and wrote some scripts to simplify some bulk file creation for where I work (generating .csv files for creating Google email accounts). I've been working on some simple little card games (no graphics, just text) and such. The best thing to do is keep reading books or tutorials so that it's always fresh in your mind even when you're not actively coding.
&gt; It doesn’t understand Setuptools extras That makes it completely unusable to me.
Despite what other people are saying, it's not that bad of an idea. Look at the implementation of namedtuple in the standard library (search for `template` and `exec`): http://svn.python.org/view/python/trunk/Lib/collections.py?view=markup&amp;pathrev=79962 `partial` is another good solution. Or you can use an object, and intercept method lookups (using `__getattribute__`) to return the HTML element (e.g. forms.input, forms.password, forms.textarea, etc.), similar to what [stan](http://www.kieranholland.com/code/documentation/nevow-stan/) does.
Isn't it more likely that PyPy **is** the future of Python - at least within the same time frame as Python 3 i.e. in the next 2-3 years? When this is going to happen, Python might become a significantly different language because CPython can't catch up with e.g. domain specific syntax implemented in pure Python, improved concurrency, optional static types and so on. Python 3 might become one Python dialect among several others.
[Relationship between pip, easy_install and PyPM](http://code.activestate.com/help/faq/#how-is-pypm-related-to-pip-and-easy_install): &gt; pip and easy_install are mostly source-based installers (similar to Gentoo Portage and Arch's Packman, while PyPM is a binary-based installer (similar to RPM and apt-get). We recommend ActivePython users to install packages using PyPM, and only if that fails (usually it doesn't), attempt the same using pip/easy_install. PyPM supports a very similar command interface and features to pip, examples: install, uninstall and requirements (install -r requirements.txt and freeze).
&gt; ActiveState's scraped release is a little out of date. Not anymore. There is usually a day's delay in building packages released to PyPI.
Oh please, that's hyperbole. 
Never have a problem with easy_install. It does not support uninstall, ok, but i don't need this feature yet. It's like, don't use apt-get, prefer aptitude, Or worst, Don't use ubuntu, use debian. Keep in mind you are free.
Exactly it’s not a currying but a partial application.
I recently made the switch from easy_install to pip... when you need pip, you'll ditch easy_install. That is to say easy_install works great for what it does... pip fills in the missing pieces once you need easy_install to do more.
You would design a new language that has the type system of Haskell (including monads, of course) and the syntax of Python.
Yes. I also suspect that the 'exec way' is faster, since there's no extra function call to a third party function. Somebody even submitted "a better way" to implement namedtuple without exec and was rejected: http://bugs.python.org/issue3974 exec seems to be Python's goto. 99% of the time there's a better way, but it can still be useful. I'll stick to the globals/ functools.partial solution I've posted at the end though. It looks less quirky.
Also check out [Project Euler](http://projecteuler.net/) for some great ways to use all that stuff you learned in the tutorial. It starts off easy and then gets harder as you go up. I have been able to use a ton of the things I learned in tutorials that I never would have known how to use in real life (such as tuples).
These little projects are rewarding for the hobbyist (like me) because they are doable in an afternoon or two and have actual relevance to my life. I've written lots of python that simply scrapes some stuff out of a webpage and formats it for some other program or purpose. 
Maybe you could add a link in that documentation to a succinct explanation for the statement. Not everyone who uses your library will have the balls to ask - especially if they've ever had a bad experience with some of the community resources out there - and it's good to get this message out.
Plus you get Zed's commentary as well which is often amusing
Another good site for programming exercises is [Programming Praxis](http://programmingpraxis.com). The exercises have varying levels of difficulty, but you should find some for your current level of development.
Django is what I'm using to learn python on. I'm really enjoying it. Im in San Francisco so I imagine there are plenty of meetups that I could get to from here.
&amp;#3232;\_&amp;#3232; perhaps you need a lesson. Here you go: http://en.wikipedia.org/wiki/Asynchronous_I/O It's a little difficult to be async without callbacks with the usual programming (see Stackless Python and Erlang for languages that handle it better). Even in Node.js, which makes use of callbacks everywhere, but it makes it dramatically easier thanks to anonymous functions and closures (far less state machines since you can use scope instead of classes to manage state). Again, I may be wrong. I only wrote event library that wraps epoll/select/kqueue and is used by several commercial and OSS apps and I've only written a framework on top of it, so I'm clearly uneducated and just winging it. 
The PyPy website is going to have the best information on PyPy, so you're going to want to look there for more answers. From the wikipedia page on PyPY &gt; The interpreter implements the full Python language in a restricted subset, called RPython (Restricted Python). Unlike standard Python, RPython is statically typed, to allow efficient compilation.[2] In other words, it's not straight out python, but something quite similar. Not all libraries are written in python. Many are written in C/C++, so they don't translate the same as "pure python" (python written in python, which basically will run in any interpreter which supports the syntax). Basically, CPython is the standard, and deviating from it may cause issues. There are a fairly large number of alternative python implementations, so you're probably going to need to cross reference your requirements with what is supported, and maybe do some testing from there. If you're just getting started there is no reason you must start with CPython, and migrating from PyPy to CPython should be quite painless as long as you migrate to a similar version (you can't go from PyPy to CPython 3.2, but you probably can migrate to CPython 2.7) There isn't necessarily a time to say goodbye to CPython. Some people leave for speed, some for the platform (e.g., IronPython fit's quite well for MS shops, Jython for many java shops). I believe most leave for speed, but one can just write C code and stay on CPython
Try Forth for a real blast!
Thanks, the PyPy page is indeed more insightful than the wiki's. As i gather, it is not possible or necessary to "dive into C" with PyPy. But also, the libraries not following the RPython language are out of the question for use with PyPY. And the default CPython implementation is not going anywhere soon. Why was the Python language not originally run with a Python interpreter, or would that just have the job more complicated? edit: &gt;"Writing new software development tools "from the metal" (that is, without using another host system) is rare and in many cases impractical."
http://www.pythonchallenge.com/ Can also be entertaining, although some of the answers remind me of the more frustrating adventure games from the early 90s.
Just remember that computer science != programming
&gt; see Stackless Python *coroutines*; btw. available in greenlet form also in CPython &amp; PyPy &gt; and Erlang *selective message queues* for isolated processes (actors) Other notable approaches are for example *reactive programming* (F#) and *lazy execution* (Haskell). You clearly understand that async I/O does not equal callback programming, regardless if that is the way you're most likely to talk with your OS (epoll/select/kqueue), so I don't understand why did you assert something like that (and then go and post contradicting examples in your rebuttal...). I've acted on good faith and assumed ignorance rather than malice. And, please, I don't care who you are. I know some security experts that got hacked by 16yo girl. 
I know what you mean by frustrating, some of the clues are so incredibly obtuse, its hard to figure out where to go/what to do. 
Write something for App Engine. It'll give you an intro to web programming, a free platform to play with, easy deploy tools, and the ability to show anyone what you've created by simply giving them a link. One of my first python [projects](https://github.com/mrsteveman1/aeservmon) was an App Engine system for checking my own servers and telling me if they were up or down (along with the http status code), via email and Prowl. It gave me something with a real world goal to work toward and in the end it proved very useful to myself and others as well. When i started writing that project, i had almost no clue what i was doing, but quickly picked up on the concepts and how everything worked, because i'm the type of person who learns by simply jumping in and trying things.
Infocom and Magnetic Scrolls.
"A Foolish Consistency is the Hobgoblin of Little Minds" who's to say what's foolish? (I like a bit of white space)
That is exactly why PageRank only forms one (of about 200?) feature Google uses to calculate where pages are on its search. However, for its time, the concept was amazing and revolutionised searching the web.
Yeah, the choice between having a function that returns a customized function or a class that acts as a customized function can come down to taste a lot of the time. For my purposes, I tend to start with a function that returns a function and then when it begins to get too complicated I'll refactor it as a class instance. But it all just depends on how you feel like doing it.
Some modules in Cpython are written as pure Python. The reason that many of them are written in C is A) the whole circular dependencies thing that you get into with self-hosting B) speed. PyPy is a project to get around the circular dependencies thing (which has basically succeeded by this point) as a way of fixing the speed thing (which is in the process of succeeding just now). It would have been weird though for GvR to have started out with the PyPy approach when first making Python. Most new languages never go anywhere, so it's not worth taking up the major headache of writing your own self-hosting interpreter, especially when you're still experimenting with language syntax, features, etc.
The only use of easy_install is to get pip 
In Junior College it is
Have you gotten to list comprehensions yet? They're my favorite.
Seriously, this is what I miss the most when I have to code in Java. 
you can use all the synchronous libraries with the efficiency of async event loop: [gevent](http://gevent.org)
Maybe. PyPy was on 2.5 though (did you *read* the article?) A lot of Python 3 compatibility features are in the 2.5 -&gt; 2.7 transition as it happens...
In Junior College, student teaches you!
why not use something designed for it, like [WTForms](http://wtforms.simplecodes.com/) 
Ha, nice to see someone else who started with *A Byte of Python*. I will warn you that when I read it in 2008, it was a nice primer...but was only a primer. He's very concise (which is either good or bad...), and he addresses the key features of the language. But you don't really get a sense of How To Program by the end of it. See if you can think up some exercises to do while you work through it. Once you're done, it wouldn't be a bad idea to work through a more complex tutorial (I've heard good things about *Learn Python the Hard Way* and *Dive into Python*). Alternatively (or additionally), just try to do something that's entirely too hard for you, make a fool of yourself on a forum (/r/learnpython or /r/learnprogramming, probably. I used the Ubuntu Forums Programming Talk, but I think that's declined in quality after some controversial admin decisions, among other things), and after you make a fool of yourself *learn from your mistakes*. Good luck and happy hacking! 
if you have a special case, it's not hard to just build with setuptools for that one case -- a good majority of packages work fine with pip.
Unfortunately true.
I know it works with git too at least. I believe hg also.
No, I'm not, I'm going to enterprise
I see your MIT Python class and I raise you - [MIT 6.00 Intro to CS and programming...on curiousreef](http://curiousreef.com/class/mit-opencourseware-600-introduction/) It has links to everything on the MIT site (which you can just go to the MIT site if you want) but it actually has a great discussion board where people can post their solutions to the homework problems, ask questions etc and get rated. I found it incredibly beneficial when (as a novice programmer) I finished a program assignment I could look how other people thought through the process and evaluate my technique etc.
Python was not originally run with a "pure python" interpreter because writing that was more difficult than writing it in C (or really any other language if you want it badly enough, but C/C++ are pretty popular for this)
Hey mom, I am going to MIT!
You sir, are a genius! 
&gt; As i gather, it is not possible or necessary to "dive into C" with PyPy. But also, the libraries not following the RPython language are out of the question for use with PyPY. This is not right. PyPy is working to get full compatibility with Python C extensions. See: http://pypy.org/compat.html Which says: &gt; PyPy has alpha-level support for the CPython C API, however, as of 1.4.1 release this feature is not yet complete. Most libraries will require a bit of effort to work, but there are known success stories. Check out PyPy blog for updates. As I see it, PyPy is the future of Python. CPython has a grave implementation mistake: the Global Interpreter Lock (GIL). It doesn't let it run real multithread programs (instead, all threads run sequentially). PyPy also brings great speed upgrades with it's JIT. Being self-hosting (running Python in Python, no need for other languages) is also often seen as a milestone in a language.
I took a class last semester on the Google App Engine and my professor has his book for free online if you want to check it out: [Using Google App Engine](http://proquest.safaribooksonline.com.proxy.lib.umich.edu/9780596802462/)
PyPy *currently* uses a GIL-based implementation. That may change, but for now the threading problem remains. Apparently the lack of refcounting makes a switch easier than in CPython. I may have everything totally wrong there
Hmm, good suggestion. Now it's a ticket on the bug tracker: http://code.google.com/p/beets/issues/detail?id=141
Very cool, didn't know about that.
For what it's worth, I started learning Django and their docs failed me. I walked over to the Turbogears 2 docs and they got me started. I mussed with that before deciding I liked Pylons better. Stuck with Pylons for about a year, then heard about repoze.bfg. Had a hard time, since I was kinda early but I'll say this. repoze.bfg was awesome. Now it's teamed up with Pylons and formed into Pyramid which is by far the best web framework I have used. Why? Because it does it's job and goes away. It feels utterly fluid, I don't get constrained by the framework itself. Django? I'd recommend not too. It has it's fans, but I personally dislike it's style. I'm much happier being able to mix/match as I need to get the job done right. To put it simply, I believe Pyramid is the future of Python Web Development. They have an awesome framework and a totally amazing community that I am proud to be a part of.
if you activate your virtualenv, easy_install will properly install any packages into it. So far it worked great for me.
This is my experience as well. But that's been a long time... so maybe pip is now better?
Now... for something else entirely: the pip homepage states the following: &gt; * It doesn’t understand Setuptools extras (like package[test]). This should be added eventually. &gt; * It is incompatible with some packages that extensively customize distutils or setuptools in their setup.py files. Is there no "pip wall of shame" yet? Like the [Py3k wall of shame][1]? [1]: http://python3wos.appspot.com/
Python is a *language* CPython is the most common *implementation* of the Python language; it's the one you can download from www.python.org. It's written in C and offers the widest ecosystem of packages and 3rd-party libs. PyPy is an alternative implementation of the python language. This is a relatively new one and it features Just in Time compilation for faster python code execution. RPython is the language (different from Python) used to implement the internals of PyPy Cython is a different (but similar) language which is specifically designed for making it easy to write CPython extension modules in C. You write code in Cython (a superset of Python + C type declarations) and Cython converts this into fast C-code which you can load up with CPython. Jython and IronPython are further python language implementations which have been implemented on the Java and .Net runtime environments (VMs) respectively.
Thanks for that link!
 C:\Windows\System32&gt;pip install adodbapi Downloading/unpacking adodbapi Exception: Traceback (most recent call last): File "D:\apps\Python26\lib\site-packages\pip-0.8.2-py2.6.egg\pip\basecommand.py", line 130, in main self.run(options, args) File "D:\apps\Python26\lib\site-packages\pip-0.8.2-py2.6.egg\pip\commands\install.py", line 223, in run requirement_set.prepare_files(finder, force_root_egg_info=self.bundle, bundle=self.bundle) File "D:\apps\Python26\lib\site-packages\pip-0.8.2-py2.6.egg\pip\req.py", line 904, in prepare_files location = req_to_install.build_location(self.build_dir, not self.is_download) File "D:\apps\Python26\lib\site-packages\pip-0.8.2-py2.6.egg\pip\req.py", line 147, in build_location _make_build_dir(build_dir) File "D:\apps\Python26\lib\site-packages\pip-0.8.2-py2.6.egg\pip\req.py", line 1140, in _make_build_dir os.makedirs(build_dir) File "D:\apps\Python26\lib\os.py", line 157, in makedirs mkdir(name, mode) WindowsError: [Error 5] AccÞs refus: 'C:\\Windows\\System32\\build' Storing complete log in C:\Users\gauvrit\AppData\Roaming\pip\pip.log C:\Windows\System32&gt;easy_install adodbapi Searching for adodbapi Reading http://pypi.python.org/simple/adodbapi/ Reading http://sourceforge.net/projects/adodbapi Reading http://sourceforge.net/project/showfiles.php?group_id=63427 Reading http://adodbapi.sourceforge.net Best match: adodbapi 2.4.2.1 Downloading http://sourceforge.net/projects/adodbapi/files/adodbapi/2.4.2/adodbapi-2.4.2.1.zip/download Processing download Running adodbapi-2.4.2.1\setup.py -q bdist_egg --dist-dir c:\users\gauvrit\appdata\local\temp\easy_install-7olphf\adodbapi-2.4.2.1\egg-dist-tmp-0ac5cu adodbapi version="2.4.2.1" zip_safe flag not set; analyzing archive contents... Adding adodbapi 2.4.2.1 to easy-install.pth file Installed d:\apps\python26\lib\site-packages\adodbapi-2.4.2.1-py2.6.egg Processing dependencies for adodbapi Finished processing dependencies for adodbapi 
The documentation at http://docs.python.org/ is surprisingly good. It's not just API reference and syntax. I've found some interesting stuff in there - check out the [HOWTO section](http://docs.python.org/howto/index.html). It's also really up to date, which is important to keep in mind since there's always new things showing up in the latest versions.
You must be an engineer ;) import random, time pick = lambda s: random.choice(s.split(", ")) while not time.sleep(5): print("Place {} on {}.".format( pick("left foot, right foot, left hand, right hand"), pick("red, yellow, green, blue")))
Multithreading is overrated, just use multiprocessing.
Since Python is Object Oriented, you should look into the concepts of OO design, such as Abstract Data Types, Trees, Linked Lists, and inheritance. 
Or, if you're using Python2.*... import random, time pick = lambda items: random.choice(items) while not time.sleep(5): print "Place %s %s on %s" % ( pick(("left", "right")), pick(("foot", "hand")), pick(("red", "green", "blue", "yellow"))) However, I got 6 "Place left hand on green" in a row, so maybe adding the number of players and ensuring that you don't get that many repetitions would help keep things more interesting...
PyPy doesn't have Numpy or mathplotlib.
That's correct.
Hes pre-banned from any conference I ever have, because of the comic.
This is PyCon 09 and I'm pretty sure it was posted to /r/Python when it happened. I wonder if he'll ever try to sneak in though.
I thought so too. I just wanted to butt in with a short suggestion because I think a lot of new programmers come to python thinking they need to write *PROGRAMS*, but the beauty of python is its simplicity. Perl rules for flexibility, but python keeps things simple.
Link doesn't work?
I downvoted you because this is 2 years old. Mr. OhHai, where are you?
I am hoping the author of the new mode takes the gnu folks up on their offer to be the maintainer for the current python.el mode.
Do what `zope` does on PyPI - release each individually useful library, e.g., `zope.interface`. If there are dependencies, there are packaging tools to help that. I'm not too familiar in this area as I haven't done much with PyPI, but you could look into the `requires` keyword to `distutils.core.setup`. That might be obsolete, though. [PEP-345](http://www.python.org/dev/peps/pep-0345/) appears to be the new way, but I have no clue of its implementation anywhere (probably [distutils2](https://bitbucket.org/tarek/distutils2/wiki/Home)).
Great idea. Hope that it works. 
Please make the bad man stop saying scary things.
Havent gotten there yet. I am a college student so I have to balance my biology major, learning python, working, and drinking beer, so sometimes my progress is slowed due to studying, a job, or mind jerking hangover
I go as far as designing my code so that I can easily run parts of it, instead of all of it, from the REPL. It's invaluable to debugging. So that might mean splitting a function in two, just so that I can call the right part of the code, or temporarily modifying a function so that it stores an intermediate result in a global or instance variable. I'd rather live without an IDE that coughs up symbol names for me than live without a REPL.
I changed the easy_install per pip long time, but they always need the Python library setup
Yay!
that and first class functions.
Because re-implementing something that's already been done 100 times can be fun.
Love PyCharm, but I'd like the ability to colorize method calls.
I thought that one of the big issues was that no WSGI module is available for Python 3 yet. 
Some ideas?
I know what you mean about this being a primer. I am using to just get a sense of how programming works. A lot of the examples he gives i try and manipulate to see if i can use them in some context outside of what he is showing.
Is it weird that since I have started Ive begun to look at problems in the outside world as a programmer would? I think thats one of the reasons I started initially is because I like expanding my toolbox of problem solving skills
Huh, previous code by @imisunderstandyou runs fine on python 2.7+; No change needed. 
This. Try to package the common parts sensibly and make your libraries depend on that. It avoids duplication even when the common code isn't terribly useful to anybody else.
&gt; Being self-hosting (running Python in Python, no need for other languages) is also often seen as a milestone in a language. Any good examples of popular languages that have achieved that? I'm morbidly curious whether there were any attempts at creating a self-hosted PHP.
It was the wsgi *spec* not the module that was missing for Python 3. PEP 3333 fixes this: http://www.python.org/dev/peps/pep-3333/ 
That I know of: C, Smalltalk, Lisp and, of course, Python.
pip won't do binary installs on Windows, where most users don't have a compiler [suitable for Python] installed. For other platforms pip is usually better.
This whole thread makes no sense to me. I understood that the guy wrote a near complete replacement for an outdated and abandoned mode because the code was too shitty to be updated and yet they insist that he submits patch after patch until the old python.el has been completely converted into his all the while mentioning that they don't care about feature equivalence and backward compatibility. why‽ Is it some kind of fetish for version control history?
Very much agree. His best bet is to make his current code better and better and advertise the crap out of it. Then when it's for all intents and purposes the defacto python mode, the maintainers will have no choice but to drop his old mode and include his.
His solution isn't *too* much longer (maybe less pythonic), once you pull out the imports, speech code, and and spacing code (in the wait function). Of course, no one wants to look up at the screen every 5 seconds when you're in the middle of a session of naked crisco twister with your ladyfriend.
1. I don't see how it's "dangerous". 2. Nope, these are all core Python semantics, any compliant Python interpreter will support this. 3. That depends what "this" is, you've given us an approach, but not the problem itself :) However my approach would be to have each child call `super` as the first thing it does, that way it'll be the base class who's implementation really does anything first, any level can raise an exception, and you'd just need to catch it in the caller.
All the classes C* will be implemented by other developers. I want to make it simpler for them so they don't have to manually call super(). Also I don't see how I could use super() to walk the class hierarchy in reverse. I want to go from C1 to C5, not from C5 to C1. AFAIK super() only goes in one direction. I could go into more details about what the "real" problem is, but it would take quite a while to write it down and I don't think it would help much. 
Why do you want this?
A few years ago I have made open source a relatively large project which is comprised of many independent modules, but because I did not post them separately, almost nobody knows they can be used outside the global context (even if the docs say so). I have been publicly criticized for making the modules too tightly coupled (which is not true). If you want to encourage people to use parts instead of the whole, post the parts separately. Most people are too lazy to look into the box, they just read the label.
Until some [freakshow CS czar](http://www.reddit.com/r/programming/comments/fkt7t/nemerle_factor_alice_ml_and_other_programming/c1go9cg) deletes it.
it's probably to guard against regressions. i would assume that one reason the python mode distributed with emacs is shitty to look at is because it's been evolving for a while through many releases and bug fixes. Though it may be shitty to read there is likely stuff there that works and shouldn't be lost unknowingly. The emacs devs are just playing it safe as they should. They are the shepherds of a code base that is decades old and distributed widely. I think their proposal is reasonable. And its not like their limiting anyone else from using the new python mode, just putting conditions on distributing it with emacs. Anyone is free to pull it from github if they want. I think I'll do that now. :)
oops, sorry didn't realize it was only for students. Well my prof has a lot of the information from the book here: http://www.appenginelearn.com/
I'd like to plug another free book (Creative Commons-licensed) for Python called Invent Your Own Computer Games with Python: http://inventwithpython.com
I disagree. Every Wikipedia entry about an algorithm should include a clean implementation in a language of the proper paradigm. Pseudo-code is probably *the* language-neutral best description of an algorithm.
Untested: def find_div(i=0, div=20): while True: i += 1 if not any(i%d for d in xrange(1,div)): return i 
Yeah, I thought the timer was overkill for naked twisted people.
If you want the elegant solution, see if you can find the way to solve it with multiplication instead of the division or modulus operations. 
You can use mod_wsgi's daemon mode where you can control how many many server resources (processes/threads) each app will use. If you have performance issues you can always move the second app to another server.
Here is a naïve, brute-force approach in Python 3: def lcm(integers): val = max(integers) while True: if all(val % i == 0 for i in integers): return val else: val += 1 print(lcm(range(1, 21))) Of course, this takes really long to terminate. There are much faster ways, which you can learn about [here](http://en.wikipedia.org/wiki/Least_common_multiple#Finding_least_common_multiples_by_prime_factorization). EDIT: Using *any* instead of *all* may be more efficient. That is, you may change the appropriate lines to if any(val % i != 0 for i in integers): val += 1 else: return val And of course, the precondition in both cases is that *len(integers) &gt; 0*.
It can't handle chunked request body, doesn't seem overly extensible (no hook or signals), no logging at all, the bundled tests are practically useless and I bet exception handling is something that has problems - what's so great about it?
Certainly you mean MIX assembly.
Here's how I did it. #!/usr/bin/env python -tt import functools def gcd(a, b): if not b: return a else: return gcd(b, a % b) def lcm(a, b): return abs(a * b) // gcd(a, b) print(functools.reduce(lcm, range(2,21))) A little math, a little functional programming goes a long way! 
While this solution is still as ugly as all the rest posted here, the following will show you how to use the xrange(1,21) to make the code slightly less verbose. i = 1 while any((i % x &gt; 0 for x in range(1,11))): i += 1 print i However, this is a very poor way to solve this problem, you can write a much more elegant solution if you notice that you are really solving the lowest common multiple problem for these numbers, and that LCM(1, 2, 3) = LCM(LCM(1,2), 3)... Good Luck :). edit: Fixed code formatting.
Here's a shorter one: from itertools import dropwhile, count def lcm(integers): return next(dropwhile(lambda n: any(n % i != 0 for i in integers), count(max(integers))))
Why?
Interesting you should say that given that one of Python's goals is often stated as "executable pseudo-code".
but pseudocode is often very close to python anyway
Here's my soln: def candidates(): primemult = 19*17*13*11*7*5*3*2 #all the primes below 20 i = 0 while True: i += primemult yield i test = candidates() #nums = (4,6,8,9,10,12,14,15,16,18,20) all non-primes below 20 nums = (20,18,16,15,14,12) #all non-primes that don't go into each other result = 0 for t in test: if not any([t%i for i in nums]): result = t break print result I can get my head around these low number problems, but I don't really like to think about the 1-1,000,000 kind of problems. Edit: fine-tuning the nums, used to just be range(1,21)
Thanks for all the replies guys. Some solutions are a bit over my head at the moment, but I'll be studying each one and will try to grasp the alternate solutions. You all rock &lt;3
instead of using porn[randint(0,19)], you can use random.choice(porn) and it will pick one from the list for you, then you don't have to update things if you add more to your list. Also, instead of escaping your newlines, you can encase the whole giant string at the bottom in triple quotes like this string = ''' blah blah blah blah blah ''' You'll have to stop the triple quotes, add in your variables, and start it again though.
to be fair, that girl was no ordinary girl...
Is it supposed to be unclear what the A and B buttons do? Maybe you could label them porn and nonporn.
what, about the word psychic, confuses you?
Yes, and please rip all Jessica Alba Blu Rays for me... Man, what should I say to your request ... don't you think that hundreds of professional investigators are already on this topic? What do you think is it worth for the political opponents to prove plagiarism of a minister? Hey, they'll pay hundreds of thousands, if not millions for stuff like that. And you suggesting in a Python forum to illegally and unnecessarily rip something that's published for years and available for everyone freely anyway (except for a drm free pdf or what ever document) ? Look, I've worked my butt off for my own doctoral degree and it frustrates me seeing people cheating and getting away with it. But this is chicken crap compared to the usual bullshitting happening everyday all around the world. But what's your motivation? ~~ If it was purely moral based you would probably support some more important stuff. If you're politically motivated you're at the wrong place. ~~ (EDITED: I don't want to doubt you, only your request. No personal offense meant.) Addition: Don't get me wrong. He should hand back his title or get it deprieved. What I've seen so far: At least one paragraph is taken almost word by word from another thesis without referencing. That's prove enough. And don't let someone fool you about moral and integrety of **any** politician or ceo or someone at the top. Rules are the same everywhere. 99 % have had to be real assholes to get there, regardless of what political oppinion.
Using your link, I get "A B NEXT" buttons but the actual image window is just a broken image.
Score: 16 out of 20 tries or 80.0% Haha that's pretty neat!
You don't have to stop the triple quotes, you can use a format string.
A real python programmer would have programmed it to give himself 'optimum viewing angles' during the game. 
Well...I didn't download the pdf, because it's impossible to decode without the private key of the pair it was encoded with. The script you link to relies on extracting your Adobe private key from the registry of a windows machine that is running Adobe Digital Editions. The Adobe Digital Editions software MUST be "registered" to the original owner of the DRM. Basically, you would need to have someone who *already* had DRM access to this PDF file run the key extraction script on *their* windows machine with ADE installed and registered to get the key. Once you have the key, anyone can decrypt it with the other script. I assume whomever owned this copy of the file hasn't published their private key, so you're probably shit outta luck.
Just at first glance, it seems to me that the answer is the minimum set of prime factors (not unique prime factors) that covers all of the required numbers, eg if the set was [12,7,6,4] then the prime factors are {3,2,2}, {7}, {3,2}, {2,2} so the solution is {7,3,2,2} = 84. Your solution will get there simply by doing {7,3,2} = 42 and adding to itself effectively is just brute forcing the rest of the terms that you are multiplying it by (in this case, the last 2). In the case above, if you don't want to get the prime factors directly you can immediately take some obvious extra terms and put them into primemult, eg that 9={3,3}, 16={2,2,2,2} to reduce your search time by 24x.
When posting source either use backticks around it (for inline) or indent it four spaces (for blocks). I've taken the liberty of reproducing your comment's code: #!/usr/bin/env python -tt import functools def gcd(a, b): if not b: return a else: return gcd(b, a % b) def lcm(a, b): return abs(a * b) // gcd(a, b) print(functools.reduce(lcm, range(2,21))) 
When posting source code, you can use backticks around it (for inline) or indent it four spaces (for blocks). 
Do you plan on covering session management during the tutorial? I've done a little experimenting with App Engine using the Tipfy framework, but got a bit hung up when I tried to figure out session management.
I got cute kitties!! If it's either cat pictures or porn I'm going to be a bad test subject since I win either way.
Green threads or non blocking socket loops are great but they don't come without drawbacks. Providing modules with this type of networking can particularly be problematic because as soon as you try doing any blocking operation or intensive calculations all the benefits go out of the window and your code breaks pretty hard. It's far safer releasing modules that use synchronous IO, for these reasons, because the developer doesn't have to think about these implications.
Because Python is a specific paradigm. Specifically, it is an imperative object-oriented paradigm. Python's specification (well, Guido van Rossum's word) does not allow it to be used in something like a functional paradigm, as such, it is not a fix-all language, especially for recursive algorithms that could overflow the stack (or crash the C stack if this restriction is lifted). Furthermore, while basic Python language features are easily readable, one must be careful not to use more advanced features like lambdas or generators, though I admit that this problem is and will be largely non-existent. That said, if possible, placing problems in a clean domain-specific language, I think, it better, because such languages are built for the problem domain. For recursive solutions, for example, Haskell or Lisp seem to be popular, though adding a lot of parentheses to pseudo-code is arguably better (parentheses and recursion seem to go together for me, personally, what about you?). All-in-all, it's mostly a stylistic thing. I just think showing examples of other languages would help to spread the use of more paradigms, and not have anyone thing one paradigm is a fix-all, like object-oriented programming currently is.
Git submodules http://book.git-scm.com/5_submodules.html
After you get your bearings in programming, and decide you want to go further, also take a moment and learn another language of a different paradigm. Python is object-oriented/imperative paradigm. I'd most recommend a functional language. That stuff will change the way you think. And don't limit it to just that, either. That's if you want to go farther, though, but I can't think that a good programmer would limit theirself.
&gt; if i % 19 == 0 and i % 18 == 0 and i % 17 == 0 and i % 16 == 0\ and i % 15 == 0 and i % 14 == 0 and i % 13 == 0 and i % 20 == 0\ and i % 12 == 0 and i % 11 == 0: Here's a friendly tip: You will rarely have to write code like this in almost any language. Usually you only have to do this while hardcoding data. While you probably know it's bad, I'm just reinforcing your intuitions, and the thought about the range(...) was along the right track, though other solutions here are obviously helpful, too. But, the best way to go is the way you see it first. Keep at it!
At work so can't test it. But obviously you need to make sure your PRNG is working. I read about the story, (which is obviously BS). What would be nice is for you to save the average results and the standard deviation.
You must be lucky. I got like 8 guesses before I struck!
I think the idea is to have one reward option, Porn supposedly being a powerful reward (honestly I'm so desensitized that unless something with tenti-nevermind), so having rewarding humorous pictures as an option may be skewing the validity of the results. Edit: But awesome job doing this. I want to play with this when I'm sober. TLDR, I kept trying to find the smiling dog.
No, people don't state that as its goals, they state that Python is, as in *equals*, executable pseudo code. However, they get this wrong, since, while Python does abstract a vast majority of anal things that people tend to do, it still has hurdles that need to be overcome, i.e. restrictions of the language, and they are mostly confusing it with "thinking in language P". One specific problem is that pseudo-code doesn't care about the implementing language's restrictions, i.e. when people write pseudo code, it's a "do what I mean" (DWIM) process. With Python, there are a few things wrong with that. One, its way of doing things doesn't really allow me to insert an indent in a random spot, use brackets, or use an English sentence wherever I want, sans comments. Two, I am not necessarily going to program in Python for my project I am using. Three, for recursive algorithms and algorithms of a declarative nature, Python simply is not suited for displaying them. That said, with CS curricula the way they are, I expect Python to be a very popular choice for algorithmic representation. However, some features of the language still make it a requirement to learn them to understand them. For example: for i in L: pass To a first-time reader, what does "in" mean" Oh, maybe "input". Okay, not too hard. Oh, what types are "i" and "L"? Python is not really obsessed with the details, but depending on what the algorithm is, the types could be important, which dynamic typing in Python loses. Also, if I need a homogeneous array, I don't get a homogeneous array, unless I use Hungarian Notation, which could muddy things up. The declaration of "`L = []`" wouldn't make sense to someone unfamiliar with Python (I'm of the opinion that pseudo-code shouldn't need comments, especially for demonstration). We'll ignore the "`pass`", since that's largely my OCPD of having bad Python code floating around. Now, zoom to a different semantic with similar syntax: if i in L: pass For someone not experienced in Python, they're probably pulling hairs out here and there. What's this mean? I've already figured out that "`for i in L: pass`" means "for each element in L, put it to i, and do nothing", but this is what?! "for each element in L, put it to i is true and do nothing? Wait, what?". Or, go for list comprehensions: L = [x for x in range(1,20)] That will take a little thinking, especially for someone that's rusty on their set theory, but this is mainly minor. However, Python doesn't really allow any notation or type checking to happen, either. For example, in an algorithm, it might want something like "L := {x | x &lt;- R, x &gt;= 0}, where '&lt;-' is 'exists within', 'R' is the Real Numbers". Really obscure places, but this is where Python can fall apart. Then you get bigger list comprehensions. Sure, I can probably go and look at a library that provides real numbers, but I kind of don't want to do that when I'm thinking about implementation, at least not before I do the implementation. I can't really do such things in Python. And then lambdas. Ew. But I'd assume anyone aiming for readability for the language agnostic would hopefully avoid those gooey tidbits. Don't get "pseudo-code" confused with "prototyping language" or "a language you can think in", because I can straight write out easy-ish things in Python, Java, and C pretty darn well with few bugs, but for more complex things, realistic pseudo-code is still needed, for me. Sometimes I need to paint out object diagrams and functional diagrams to understand certain things. All these tools help me implement. But that's tangential. The discussion is about algorithmic representation. My main point is that if you can cleanly display it in Python, do so. But a free-form pseudo-code will make up for what things Python lacks, either little anal things like static typing and variable declarations (which, arguably, need sometimes to be known) or lack of clean functional representation.
Maybe your pseudo code is, but my pseudo code is mostly a mix of Java, Python, C, common set theory notation, English, and maybe a little bit of swearing.
Bug: Incorrect score Replicate: Guess the porn image first, then click the other image button to see the funny picture. No matter what sequence of button presses (ending in next) the score for guessing porn first will not go through.
And for those that don't know what a format string looks like: print """Welcome %s please insert %d coins""" % ("nemec", 9)
8/10!
If you don't add swearing it is just jibberish.
Naturally, that type of format string is obsolete in python3. If you don't need to support 2.5 or earlier: print """Welcome {0} please insert {1} coins""".format("nemec", 9) 
 import subprocess args = ['chromium','--incognito',''] for p in porn: args[2] = p subprocess.Popen(args) EDIT: Who can do better/faster/harder/stronger? 
&gt; PHP on the other hand needs everything written in the template, which sucks, and is the reason why there are templating engines for PHP. Nonsense. Typically you write your controller without any view logic, and simply include a PHP file that acts as the "view", passing it a model. Thus, your view has all the power PHP has, and extra parsing overhead by a template engine is eliminated. The real problem in this approach is that you are *able* to do much more in your view than is needed - there are no enforcing limitations. Thus, it requires more discipline. The same problem is there for JSP, which allows you to use native Java code as well (which is of course frowned upon by most people). So whether a limited templating engine is better than having the whole language available to you in your view - it's a tradeoff: do you want enforced discipline or speed and power?
Using classes for handlers is not unpythonic. It is just a matter of taste or style. web.py, Tornado, webapp, Pyramid and CherryPy are a few other Python frameworks that also prefer classes. Disclaimer: I'm tipfy author. ;) edit: added Pyramid.
Score: 32 out of 50 tries or 64.0% Huh, not a large data set but still interesting.
Coming from a C background, they will never be obsolete for me.
Maybe my mind is irreversibly warped by Python, but I perceive "for item in collection, print item" and "if item in collection, print item" as perfectly cromulent English sentences. The articles, the "each" and the "is [contained]" parts are omitted, but that's OK. I don't believe that any English speaker could be confused by this. It looks like you tried hard and finally managed to confuse yourself by approaching the code from the parser writer's perspective, giving up all hope of matching the natural language in advance and artificially restricting yourself to the syntactic structure only. That's your personal problem that doesn't affect other people, especially non-programmers. 
And in 2.7 you can omit the indexes, using just `"{}"`!
Build something. Web2py is an easy to use python framework for building database-driven web sites. It includes everything you need to code and serve a web site right from your Mac, windows or *nix computer.
I've got this, I'm certain I can read his mind.
Hmmm... I can't top 40%. I don't think any of those chicks in the pictures have ESP. Maybe if they were asians. Or midgets.
Works fine now from here (Denmark, TDC)
Or, you could reference to some other site like RosettaCode that has implementations in a bunch of languages. Of course, Rosetta doesn't have an implementation for a kd tree at the moment, but it could be added at any time.
…bitten by a radioactive spider a century ago, Ada Lovelace comes back to fight crime for teh lulz. Her first target? Evil security researcher, mad scientist, Aaron Barr…
it was only down for about five minutes, that i noticed, I was halfway through updating django on a bunch of sites, worked fine in test, worked fine in staging, got to production then: Could not find any downloads that satisfy the requirement django took me a while to stop wondering what the hell was wrong with that servers dns and read the prior line about getting the index failing ;) anyway, yay!
16.666667%
Doesn't run on 2.6&lt;
I will show how you use sessions but in web2py sessions are completely atomated. You just store stuff into the session object attributes and you find the stuff later when you access it. The session object is already defined in the web2py context. There is no setup or configuration. Here for example is a complete counter program: def index(): session.c = (session.c or 0)+1 return dict(counter = session.c) I will show how this works under the hood but from a programmer's point of view there is nothing else to know. It is not as complex as with other frameworks.
I vaguely remember something about it. I think it's a standing joke amongst con organizers.
same here.
No, it's not. I wanted to get the subimg 'algorithm' so that I could get a larger data set. You know, x in and subimg.net/z1AbyT.jpg out. It seems to be Base-62 URL shortening, but still couldn't crack it.
What browser are you using? I only ask because I tried to replicate that before releasing it and wasn't able.
Or you could make it more readable like this: print ""Welcome {name} please insert {num} coins.""".format(name=nemec, num=9)
Yeah, you know, I *do* get the feeling that the random number generator is frequently picking the same numbers. Mostly from the start of the array. Yes, that would be nice, but I'm not sure I'm going to do it. I might, I mean, the weekend is here. But I want to get my feet wet with python, see what the buzz is about.
You have to pick A or B first. The image window should be empty, not showing a broken image link. Once you pick A or B, it shows you the pic behind A or B and when you click next it scores you.
Yes. It is supposed to be unclear. Cause it's testing your psychic ability. You're supposed to pick one based on the potential reward of porn. The porn is behind one or the other, but it's random.
Thank you! It was a pain in the ass to maintain that. \" didn't always behave as expected and neither did "". And I think in my head \ is related to \" which just confuses me.
I tried both of them ... I'm using python 2.7. Neither of them worked, though to be fair, I might have been doing it wrong. The interpreter gives out "Incorrect http header" errors like Microsoft gives out "Object or with block variable not set" errors.
Yep, I thought of that. For instance, gay dudes are not going to be into it. I'm just trying to figure out why so much hype over Python. And trying to get out of a Microsoft World. Every company I've ever worked at has been "a Microsoft Shop" ... and it's really fucking boring sometimes. 
Thanks, fixed :).
On the 2 or 3 question, I didn't make this up, but I always say "3 where you can, 2 where you need to". As you'll find out, some of the things you'll want to use will only be supported on 2.x, so you'll probably use 2 more than 3 right now. However, in places where 3.x libraries are available for your project, I'd say jump in and use 3.x there. As for your bullet points: 1. The [What's New in Python 2.7](http://docs.python.org/dev/whatsnew/2.7.html) document will fill you in on 2.6-2.7 differences. Ordered dictionaries, the `argparse` module, and a bunch of 3.x backported features are on the list, plus many bug fixes. 2. You can install any and all versions you want. I don't follow Debian, but maybe they don't have 2.7 in their repo. You could always install it from source if you needed to, or some Debian user might be able to chime in with another way to get it. 3. Source code. Lots of it. If you already know the basics, all of these online games and beginner books aren't going to push you to the next level. Find the source of projects you are using, or even the Python standard library, and observe. You might even end up finding bugs and fixing them. 4. I'm a fan of the [ActiveState](http://www.activestate.com/) [Komodo IDE](http://www.activestate.com/komodo-ide). It's not free, but I'm happy with the investment and have been a user since mid-2006.
From what I understand 2.7 is another step towards the transition to 3.x. 2.6 and 2.7 are meant to be transitional as more things move forwards to the new era. As for having 2.6 and 2.7 installed at the same time, it should be doable. I've got 2.6, 2.7 and 3.1 installed on Ubuntu. I just go to the Applications menu and choose which version of IDLE I want to run. You should also be able to specify which Python you want to run in the terminal as well or by using the !# to specify the path.
I think @briancurtin has it right. If you find that you absolutely have to use 2.x, fine. But for new projects I really think 3 is the way to go. I also recommend doing the investigation for yourself rather than blindly listening to people who will tell you something like "2.x, without question". If you plan to use something as enormous as Django, which isn't ported to 3 yet, they're obviously right, but there *are* other perfectly viable options out there that are 3-ready today, and Django will get there sooner than later. "3 'til it hurts, 2 'til it works" is my motto. 
KISS - Use 2.6 or 2.7. Django is the most popular option for web frameworks these days. IDE is the most important question? I don't know about that. Personally, I prefer [Wing IDE](http://www.wingware.com/) for any Python tasks and it has been nice for me. There are Trial and Free versions available. Apparently, it can be configured to [develop against Django](http://www.wingware.com/doc/howtos/django) as well, though I haven't tried that yet.
I think your quote of "3 where you can, 2 where you need to" hits it spot on, but doesn't take into account cases where "personal hack" projects turn into code you need to distribute. I started a parser for a collection of files I have, and was going along fine in 3. I had to change back to 2.6 since we wanted the code to run on stock OS X machines. I'm still keeping the code as close to 3 as I can, so the eventual conversion will be as painless as possible.
Your first program, it's not necessary to get everything perfect. But for the sake of science it would be interesting. I personally (in research) know how terrible the consequences can be of using a bad PRNG (and have published on it), which is why I am particularly interested. PRNGs have evolved tremendously, but the standard ones that come (I havent checked which one python uses) are usually terrible. Anyway, glad to see you're having fun with programming! Look forward to seeing your next project.
It depends (don't you love those cop outs :-)). Personally I would use the newest stable version that is most compatible with the frameworks and libraries I want to use. The difference between versions is usually exaggerated on internet forums because people tend to focus on the new shiny stuff. In practice if you use modern idioms your code will probably look pretty similar from 2.6 to 3.1 most of the time.
&gt; stock OS X Ain't that still Python 2.epsilon?
I did, that's why I mentioned it.
Please remove this reddit... first piracy is not the kind of stuff we pythonista really do and second trust me that whole Germany is going to analyze Gutenberg's thesis word by word, there is no need for help from the python dudes here, they have better and legal things to do...
&gt; Maybe my mind is irreversibly warped by Python, but I perceive "for item in collection, print item" and "if item in collection, print item" as perfectly cromulent English sentences. The articles, the "each" and the "is [contained]" parts are omitted, but that's OK. I don't believe that any English speaker could be confused by this. No. Someone has to sit down and learn the language before they understand it. You might not think it's a big deal, as Python is easy, especially once learned, but having to go and look up language features and syntax for a possible unknown language can be a bane to understanding a language-neutral algorithm. Sure, many people can probably understand somewhat what a piece of Python code represents, but that also assumes one is also thinking in Python's language domain. I also don't think people with only a rudimentary understanding of English could necessarily grasp the code fully. &gt; It looks like you tried hard and finally managed to confuse yourself by approaching the code from the parser writer's perspective, giving up all hope of matching the natural language in advance and artificially restricting yourself to the syntactic structure only. That's your personal problem that doesn't affect other people, especially non-programmers. No, I am perfectly able to write an algorithm in a natural language. However, I find it easier to use rigid statements to outline what I want. This varies from person to person, especially across fields. Someone grounded well in mathematics would be understanding quite a lot of symbolic dumps vs. someone grounded well in English would definitely find natural language to be the easiest way. This isn't a "problem". This is a fact that everyone thinks differently, and thus it does affect other people. Lastly, the issue is largely non-existent with non-programmers, since they are rarely finding themselves in need of writing code (depending on the scope of "programmer" to include "anyone who will ever want to program a little or not, like Biologists").
They aren't obsolete! Both can still be used. And most of the times, the old way looks better.
&gt; Someone has to sit down and learn the language before they understand it. I don't disagree in general, but your particular examples clearly go against the point you are making. "`for item in collection:`" and "`if item in collection:`" are as close to natural language as it gets, it is *the* best pseudocode one can come up with for these concepts, ever.
I'm also a newbie and have found python to be much more satisfying. Try the web2py framework which is even easier and more productive than django. You can run it entirely from your pc (Mac, windows, *nix) or put it on server. The documentation even includes a summary of python. I was able to learn a sufficient amount of python and web2py in 1 day.
+1 for web2py. The MVC doesn't get in the way (you an skip the views and the models really help out with the db). You can write you're own SQL but web2py's data access layer is really easy and convenient.
or 2.5 if you want to develop on appengine (lame)
 &gt;&gt;python --version Python 2.6.1 
The only time I'd write "pseudocode" in something besides Python, it'd be when I want to write it declaratively, so I'd use Haskell. Pseudo-code is a thing of the past. If you're gonna write "code", then just suck it up and pick a real language. Use stubs / unimplemented methods if need be for high-levelness and/or clarity, but seriously.
Instead of scraping Google you could have used the [Google Search API](http://code.google.com/apis/customsearch/docs/dev_guide.html).
any code of mine has a bit of swearing. especially homework.
Even in Mac OS X 10.5 it's Python 2.5. I think If you have Mac OS X 10.n you get Python 2.n, at least for the last few versions.
I would go as far as saying Mako provides more speed and power than PHP does. Many Python templating engines support features such as filters, extensions, inheritance. And, if you don't like a particular templating engine, switch! PHP does not have that luxury. And this is just discussion of PHP as a templating engine (of which it does a passable job), as a programming language it is pretty awful, for an object-oriented language, it's stdlib is rather strange... HERP DERP http://www.php.net/manual/en/types.comparisons.php
Or in generally, it depends of your dependencies. most popular projects don't support python 3. Maybe in year 3000 :-)
Thank you all for your comments. After reading all of your comments and reading some more on the internetz, I have decided to dive into Python 3.x. I don't know why but I'm kind of excited about learning Python, finally some break from .net development! I'm not sure about web frameworks though ;(. I'll just dive in and see where things go from there. For now I will use NotePad++ and I will be solving the Python challenges. That should be a fun way to learn Python =). The online Python documentation is frigging great! That's it for now. I'm not sure if I need to edit my post or reply to it. Thanks again everyone =).
I am guessing your pseudocodes have curly brackets. Yes?
I think [Pygame](http://www.pygame.org/news.html) would be helpful for you.
Hey you :)
What you linked is the documentation for creating site-specific google searches. Not quite what the OP was doing.
This, simple wrapper around SDL which provides all the services you listed.
2.x for the time being for the simple reason that pypy is way more interesting than Python 3 and the former won't do the latter for a while. However I would like to point to my article about [writing forward compatible Python](http://lucumr.pocoo.org/2011/1/22/forwards-compatible-python) as it might be helpful.
Listen to me. Look into pyglet. It's *amazing*.
Ah, yeah... I am more concerned with finding evidence for or against psychic porn. Oh ah, nice work.
[Panda3d](http://www.panda3d.org/) is pretty good
Seconded
Yep, pygame does everything listed, and even better it also makes using OpenGL very easy if/when you want to move on to that. 
I happen to love [Panda3d](http://www.panda3d.org/) - it's a free, open source engine co-developed by Disney (for some of their games) and Carnegie Mellon. They have quite an active community on their forums, and the library is very simple and easy to use (and has a good number of advanced features too). I'm working on a barebones, sample FPS right now to learn the ropes, and I have projectiles, animated sprites, a 3d world with collisions, and UDP networking in about 1.3K lines of code. It's free for non-commercial and commercial projects alike (except for their sound library, but that's easily replaced). I've also heard good things about [PyOgre](http://www.ogre3d.org/tikiwiki/PyOgre), but have no experience with it.
Thanks. My personal stance is that I believe in psychic ability ("greater things are there in the heavens and the earth than are dreamt of in your imagination, Horatio"), but that I also respect science. As well as philosophy. Anyone who is educated knows about superstition and its dangers. So the experiment interested me ([he](http://en.wikipedia.org/wiki/Daryl_Bem) was on [Colbert](http://www.disinfo.com/2011/01/stephen-colbert-discusses-time-traveling-porn-with-professor-daryl-bem-video/)) because it seems more like it would work, offering motivation (reward). I think it would be *really* interesting if it could be $100 for every right answer and -$100 for every wrong answer. I think *that* would show really interesting results, however, I don't roll like that ($). I think for the 2nd version, I'm going to have to show some statistics as well as reporting, aspect ratios and all of that.
I've used [Komodo Edit](http://www.activestate.com/komodo-edit) for a couple of years now, and it's been quite handy. For learning and simpler things it's a good start, plus it's free.
so don't overwrite /usr/bin/python with /usr/local/bin/python2.7 or whatever; if you install easy_install with /usr/local/bin/python2.x it will be smart about using that version of python. See http://packages.python.org/distribute/easy_install.html#multiple-python-versions
Yes. Helps a lot when I forget something and I don't want to re-indent an entire block, because I forgot something.
At first glance, I find you've commented/documented way more than you need to. Document important decisions and things that need to be documented, don't just explain what its doing... it obvious what its doing if you know how to read code. You should be use docstrings for things that describe the function itself. Instead of having to comment what arguments are: def csv(f, l): # First elements to print followed by list of elements def google(q): # Query string (will be URL quoted by this function) use descriptive names: def csv(first_element, list_of_elements): def google(querystring): # Query string (will be URL quoted by this function) When you comment functions, you should comment *why* something is doing a certain task, not just what it does: # All the queries have 'whizz bang' appended to the end of # them qu = "%s whizz bang" % t This comment isn't needed because its obvious what its doing... but you could say # All queries have whizz bang appended to the end of them because we only care about results with those key words. 
The great thing that if you just need to get (or post) something with authorization, Requests provides a simple syntax. build_opener/install_opener no more :-)
Nothing loads for me.
Why? If I am writing a low-level system driver, the last thing I really want to do is to write unimplemented methods in C, since Python is obviously not going to help. Pseudo code is a good scratch work, even if I need to test some quick logic. Do I plan out my entire application or library in pseudo code before I screw around with implementation? Not really. But I'm also not aimless, and those late nights when I'm staying up and can't figure out some off-by-one error that happens in a for-loop, pseudo code is at least helpful as a debugging tool to write what you need, for other stuff (like logging mechanisms and error checking) will usually muddy up the code just a little bit. Not everyone does high-level stuff, nor should everyone. This is where writing something in a language such as Python will not help.
it makes it easy to use opengl, but opengl is not exactly easy. :)
Wow, I've heard that session management is easier in web2py but I didn't realize it was **that** easy. Unfortunately attending the tutorial at PyCon is way out of my budget, but I'm going to take a look at the web2py Book and probably migrate my GAE project to it. Thanks for all of the work you (and everyone else!) puts into web2py!
That is what I meant, but admittedly I didn't phrase it very well!
I LOVE pyglet. So simple, so powerful. 
have you ever used google?
Thanks! I shall have a go. 
WORRA! :D
I will :) Thanks.
 I'll have a go! Found PyOgre first but it's a bastard to install and does far too much, I have no need of a graphics library so powerful it comes with procedural trees and its own download-and-build system!
Thanks, I'll try it :)
Yep, 2.5 is what I use mainly on my work MacBook. I did install 3.1 from ActiveState but the bulk of my coding is still in the default version.
Here is my solution, (as referred to in my reply to 'acct_rdt') : from operator import mul # assume this should be a generator that yields successive primes, # (and that the first value yielded is '2') def nextprime(): # this is just an incomplete implementation primes = (2,3,5,7,11,13,17,19,23) # primes up to maxnum for n in primes: yield n prime = nextprime() maxnum = 20 # we are interested in the interval [2,maxnum] numlist = list() while True: currentprime = prime.next() atleastonce = False p = 1 while p * currentprime &lt;= maxnum: atleastonce = True # some p^n is is in the interval p *= currentprime if atleastonce: numlist.append(p) # largest p^n in the interval else: break print reduce(mul, numlist) I got the answer: 232792560 Which is 2^4 * 3^2 * 5 * 7 * 11 * 13 * 17 * 19.
Heck, you don't even have to leave .Net. Once you get your Python chops down, you can use IronPython to develop Python based .Net apps. http://ironpython.codeplex.com/ 
Though I don't really know what % does, I expect it's repeated subtraction, so this may is right: I've posted my own solution above/in reply to OP. I've convinced myself that it's mathematically correct, though I haven't put any proofs on it, so feel free to ask why I think it works.
An improvement, minus the definition of 'nextprime' : prime = nextprime() maxnum = 20 # we are interested in the interval [2,maxnum] finalnum = 1 while True: currentprime = prime.next() p = 1 while p * currentprime &lt;= maxnum: p *= currentprime if p == 1: break finalnum *= p # largest p^n in the interval print finalnum 
Does anyone else do: username = 'nemec' ncoins = 9 print """Welcome {username} please insert {ncoins}""".format(**locals()) 
I was thinking more along the line of a super Barbie. That's what I picture her in my head anyways.
crap, I'm using 2.6.6. I thought even 2.7 was too close to 3.x.
For the cases where you need to distribute to older versions hopefully you can use [3to2](http://pypi.python.org/pypi/3to2). But that is a fairly new development so it may have not been an option for you at the time.
Just remember there are other platforms out there!
Or: #! /usr/bin/env python3 import urllib.request import os # Copied list from source code. porn = ["http://i.imgur.com/locV6.jpg", "http://images.phapit.com/uploaded_pics/phap38309.jpg", "http://images.phapit.com/uploaded_pics/phap35251.jpg", "http://i.imgur.com/KBhWM.jpg", "http://subimg.net/2uY7460.jpg", "http://i.imgur.com/Q2Pqz.jpg", "http://subimg.net/coo1.jpg", "http://subimg.net/1hlX.jpg", "http://i.imgur.com/fzn0c.jpg", "http://i.imgur.com/OToxR.jpg", "http://pussyimg.com/wp-content/original/2010_11/Knee-socks-and-camel-toe.-NSFW.jpg", "http://i.imgur.com/I6kCm.jpg", "http://i.imgur.com/fsFBd.jpg", "http://i.imgur.com/MrQBV.jpg", "http://www.nonnudepix.com/wp-content/uploads/2007/11/teen-sarah-jeans-topless.jpg", "http://images.phapit.com/uploaded_pics/phap38417.jpg", "http://subimg.net/64f3856.jpg", "http://subimg.net/9sa05A3601.jpg", "http://subimg.net/6Ept7723.jpg", "http://subimg.net/4ugKKz6613.jpg"] for x in porn: os.system('wget ' + x) Now, I'm always a winner! :-D And who says python is not elegant?
you linked to the wrong thing, but the javascript api will do this, but only 8 results per request, so you'd need to do 3 requests to get the maximum number of requests supported via that api (24). The way he linked does get up to 100 results, but its more likely to change and more likely to be highly rate limited as google isn't really encouraging users to do it this way. (I believe checking rank via the javascript api is likely against TOS, but so is the OP's post)
Have you? Google will give you a list of engines, but it doesn't necessarily help you to identify them as "good". That "good" in the title indicates he's looking for opinions from general folk, like redditors, the kinds of people who fiddle about with a few things, and have an opinion rather than the "Sun shine's out its arse" or "It's Satan Re-incarnated" reviews that most searches come up with (most people need to be sufficiently motivated to post a review on line, which tends to suggest one extreme or the other)
I don't see how you can compare radioactive Ada Lovelace with… Barbie. Anyway, I just meant they were hacked by kids, the “16yo girl” part wasn't really important. 
Pygame is precious but Pyglet is for bacon. (I'm tired, but this is a way of saying I like Pyglet more.)
The free "academic" version of the [Wing IDE](http://www.wingware.com/) is quite adequate for exploration work. I had exactly the same question (which version to explore) and opted to go with 3.x, however the drawbacks have become quite clear: the "big" libraries aren't there yet. In particular the Python Image lib and NumPy aren't ready, so no graphics or math (at least, on OS X). This is supposed to change RSN. Had I known then, I'd have used 2.6 with "from \_\_future\_\_ import *" in every program to get the print() function etc.
taking Python classes ? where ? which one ?
&gt; from \_\_future\_\_ import * If only...
I am use to programming in PHP and Drupal, but lately I been looking into Python and maybe Django, they seem pretty interesting. If only people at my work place used Python instead of Java or C#, we might have some fun instead of being bored.
Python really does need more recognition. I don't believe there is a better designed language out there with such perfect documentation.
Try checking through the dictionary the locals() function returns. It will contain information about all the variables and objects that are currently live in the interpreter. Files are entered into the dictionary with the file path and whether they are open or not.
I'm all for more publicity for Python, and I appreciate that the author took the time to contribute to the movement. I was a little disappointed with the FUD in the article, though, even if it was mostly about other languages. It doesn't look very good for people who know better and are looking for good reasons to use Python. Also, it's "Django" not "DJango"
&gt; better designed Haskell. &gt; perfect documentation You got me there.
3.x; don't do what I did and get stuck in the past. It only makes it harder to keep up.
Also profiling python -m cProfile script.py 
I reckon you might like the [pyFilesystem](http://code.google.com/p/pyfilesystem/) module. How about this as an alternative to SimpleHTTPServer, to serve the current worling directory: fsserve .
Sweet! Although the benefit to the ones in the standard library is they're often already on the machine without any extra effort (especially good when there's no Internet, or you can't mess with a machine's configuration, etc.)
Isn't the point of this post to show the python standard library commands?
Doug Hellman wrote a blog called [Python Module of the Week](http://www.doughellmann.com/PyMOTW/contents.html), which provides additional documentation beyond the standard docs (lots of good examples). The [eff-bot guide](http://effbot.org/zone/librarybook-index.htm) by Fredrik Lundh is good as well.
'better designed' is subjective. Haskell may be pretty, but it isn't very practical (at least compared to a language lik Python), it is a research language, with a lot of interesting ideas coming out from it. With Haskell you have to be *too good* at it (as in, knowing GHC's - the main implementation - behaviour very well, not just having good style) to be able to do anything non-trivial. Python is not near perfect, I consider it part of the "ugly languages", but it is very practical, has a lot of good quality libraries, is probably one of the best documented languages and the community is mature. It is also constantly getting better, I didn't even consider it a language worth using before 2.4 came out, and it has improved a lot since. ^-- someone who didn't appreciate those qualities of Python until he got a job where the main language being used is Ruby (which is years behind in terms of community, documentation and matureness)
&gt; &gt; better designed &gt; Haskell. SPJ said that the "next Haskell" would be strict. Like, there's this little feature that needs fixing, kind of. Also, wtf are you smoking anyway? Why on Earth `foldl` isn't `foldl'` -- any reason at all, aside from "we made a mistake, too late to fix"? Also, this shit: Prelude&gt; maximum [1..4000000] *** Exception: stack overflow That's your Haskell in a nutshell. Well-designed, my ass.
3.x is the future of python. Use it if you can. It's a better language. Module compatibility is the only thing which might hold you back with 2.x. If you know that the packages you need are 3.x-compatible, then go with it. If you don't know what packages you're going to need, learn 3.x anyway. If you find you have to move back to 2.x, it's not so different. If you conclude you need the 2.x series, go with 2.7 unless your distro comes with something else. 2.6 is close enough to 2.7 that it's not worth the trouble of installing another version, just go with 2.6. There are loads of python resources on the web. just google for it. My prefered IDE for python is eclipse+pydev. It's got more features than just about anything else but it's not so good on low-spec machines. IDLE, the default out-the-box IDE which comes with python has some nice features, even if the UI is dated/basic. IDLE runs great on low-spec machines.Also, Editra (http://editra.org/) works well in my experience. There are many many more options so don't sweat the choice of editor/IDE; whatever works for you...
Speech module only runs on 2.4 and 2.5 and has a few dependancies. 
I absolutely love Python, it is exceptionally well designed and orthogonal however it is not the omega of programming languages just a well designed general purpose programming language. 
What's info-zip?
Info-ZIP's purpose is to provide free, portable, high-quality versions of the Zip and UnZip compressor-archiver utilities that are compatible with the DOS-based PKZIP by PKWARE, Inc. – http://www.info-zip.org It's the "zip" and "unzip" command on Linux.
SimpleHTTPServer has become http.server in Python 3 i.e. put this: **alias serveme='python3 -m http.server 12345'** in your .bashrc and you'll have a nice HTTP server at your fingertips at all times :)
True, but you kind of are missing the intent of the exercise. Does cProfile provide any functionality if you do 'python -m cProfile' without passing it a script...
no idea why the downvotes. it's true, multithreading has very limited potential to scale(one machine) where as multiprocessing can scale to as many computers that you can get your hands on. 
Yes she is. She's my future wife. 
I thought it was some zip-information program or something.
&gt; True, but you kind of are missing the intent of the exercise. He's not, you are. &gt; Does cProfile provide any functionality if you do 'python -m cProfile' without passing it a script... doesn't matter. `urllib` doesn't do anything either if you don't give it a URL; there's no point in `python -m timeit` without providing python code snippets; ...
I'll make this blog post if at least three people here promise to link to it. (normally my blog posts never get read by anyone and I get sad :-(
Also: easy_install oo Python -moo
I will read it only if you do not write it.
Some more: * `aifc` dumps some info about the provided `aiff` file (if given two paths, also copies path1 to path2) * `calendar`, does default to displaying a yearly calendar, but it has a bunch of options (args are `year` or `year month`, options are HTML output, calendar locale, encoding, and some type-specific stuff, see `python -m calendar -h`) * `cgi`, dumps a bunch of information as HTML to stdout * `CGIHTTPRequestHandler`, same as `SimpleHTTPServer` except via the `CGIHTTPRequestHandler`: it will executes scripts it recognizes as CGI, instead of just sending them over (has not survived the transition to Python 3) * `compileall`, compiles a tree of Python files to bytecode, has a bunch of options. Does not compile to stripped files (`pyo`) * `cProfiler`, runs the provided script file (argument) under `cProfiler` * `dis`, disassembles a python script * `doctest`, runs doctests on the provided files (which can be python scripts or doctest files) * `encodings.rot_13`, rot13 encodes stdin to stdout (has not survived the transition to Python 3) * `fileinput`, some kind of ghetto pseudo-annotate. No idea what use that thing might be of * `formatter`, reformats the provided file argument (or stdin) to stdout: 80c paragraphs &amp;etc * `gzip`, ghetto `gzip` (or `gunzip` with `-d`), can only compress and decompress, does not delete the archive file * `htmllib`, strips HTML tags off of an HTML file * `imaplib`, ghetto IMAP client * `locale`, displays current locale information * `mimify`, converts (mail) messages to and from MIME format * `modulefinder`, lists the modules imported by the provided script argument, and their location * `pdb scriptfile.py`, automatically enters PDB post-mortem mode if the script crashes * `platform`, displays the platform string * `poplib`, dumps a bunch of info on a POP mailbox * `profile`, see `cProfile` * `pstats`, opens a statistics browser (for profile files) * `pydoc`, same as the `pydoc` command * `sgmllib`, see `htmllib` (as far as I can tell) * `shlex`, displays tokenization result of the provided file argument (one token per line prefixed with `Token: `) * `SimpleXMLRPCServer`, XMLRPC server for power and addition * `telnetlib`, telnet client * `tokenize`, dumps tokenization result of a Python file * `webbrowser`, opens provided URL in your default web browser (options: in a new window, in a new tab) * `whichdb`, tries to guess which db package (for db format nobody cares about) can be used to read a db file And the biggest missed opportunity: `wsgiref.simple_server` launches a demo application instead of mounting an application you provide
Alright. That's not creepy at all. 
As a CS student who just dove right in Python (via the excellent workbook "Learn Python the Hard Way" and O'Reily's equally fantastic "Learning Python") two months ago, am I wrong in thinking that Python is more suited for web development than big, enterprise-level applications? Or is it just underused in that regard? Looking at [this](http://en.wikipedia.org/wiki/List_of_Python_software#Video_games) makes me think how little Python has infiltrated large development compared to C++ or even Java. 
what are the "beautiful languages" just out of curiosity? 
Dunno what's wrong with your repl. Prelude&gt; maximum [1..4000000] 4000000 Besides, you're talking about *library* functions, not the language itself.
So I've started playing around with [Flask](http://flask.pocoo.org/) and really like it. Is there something I'm missing out on with django that I should really consider? I like Flask because it seems rather lightweight but I don't want to start on a path where I want to reinvent the wheel.
&gt; With Haskell you have to be *too good* at it (as in, knowing GHC's - the main implementation - behaviour very well, not just having good style) to be able to do anything on-trivial I heartily disagree. Who here has done anything "non-trivial" with Haskell that *required* knowledge of GHC's implementation? As for practicality, [RWH](http://book.realworldhaskell.org/read/) disagrees with your assessment. All this being said, I have to agree that Python is indeed very practical and has a lot of good libs/docs.
Using the right tools and development process it is perfectly usable in an enterprise environment while still being fun :)
You can't do much with just a language. If you want to do anything useful library and runtime are more important than the language (unless you have infinite time and resources to build everything from scratch).
There are no "beautiful languages" on my list, just less ugly ones, some examples of such languages are Haskell, Scheme, Factor, languages from the ML family (OCaml, SML, F#), Oz, and even Lua.
How does Real World Haskell disagrees with that? Yes, it has a bunch of examples, you can write such a book using pretty much any language, that doesn't make the language practical for use daily (of course "practical" is subjective too and depends a lot on what you do and what you are expecting, on this case I'm talking about Python-level-practical)
[Proofpic!](http://i.imgur.com/T484j.png) Maybe they've finally fixed this in a more recent version, or enabled optimizations in repl, or you have a bigger default stack size, I don't know. &gt; Besides, you're talking about library functions, not the language itself. Well, you see, it's kind of like vomiting. By itself it can be a result of an infection or a food poisoning, but imagine that you are trying to convince a friend that he has had enough, while he slurs about how he is absolutely sober, and how he can outdrink anyone, and then suddenly BLARGH -- he vomits all over himself. Obviously, this ends the discussion. Likewise this stack overflow is the closest thing a programming language can do to vomiting all over itself, and in case of Haskell it's not some isolated, inconsequential random bug, it's the apotheosis of its design, a well-deserved fruit of the fundamental design choice. If the standard library implementors can't write the simplest one-liner correctly, how can anyone be expected to reason about the performance characteristics of real programs? By the way, while we are at it, why Monad's `unit` is called `return`? Why does `Monad` have `fail`? Why is it not a subclass of `Applicative`? I mean, I kinda know the answer -- monads were initially used strictly for IO and then it was too late to fix the interface, but you won't call it good design, I hope. And it's not _some library_, it's the standard library and the core part of it, which is essential to any Haskell program functioning. You want to pretend that its design is not a part of Haskell design, you have no Haskell remaining, the bare idea of call-by-need lambda calculus is not a programming language.
For the record, my favourite language for working one when there are no have-to-get-things-done-really constraints is Scheme, but most of the time I need to do something for real, I pick Python or C because they get the job done, even if they are not as enjoyable for me.
You forgot one thing: "hey, good luck debugging that thing!"
Is it cross platform? On Linux, you would probably use inotify to implement this.
Do you use nagios? You could write some useful nagios plugins.
All use callbacks under the hood.
It's used pretty extensively in AI development and game AI and programming. Of course, it's not always used to make game engines etc, because it needs to be extremely efficient to run smoothly in an operating system. Python could theoretically slow things down since it's interpreted. That's why many games are compiled with C/C++.
I don't know about you guys, but some of the images it counted as "porn" were merely images of ladies, fully clothed, in regular pictures.
Yeah, there's a disclaimer in my post, see where it says "pretty soft" ... Do you know where to find python error messages in IIS? For some reason, iml = Image.open(urllib2.urlopen('http://subimg.net/2uY7460.jpg')) doesn't seem to be working.
They all manage memory manually under the hood as well. That doesn't mean you have to bother with that in your high-level language. Actually, for example, Erlang is very happy to use synchronous OS I/O API in dedicated threads and processes to get better I/O performance. So yeah if you meant that they all use epoll/select/kqueue/etc API then it's not necessarily true. The whole point is mutt anyway because there is *no synchronous I/O* going on in any modern operating system. All you have is synchronous I/O *API* offered by OS. Once you understand that, it's just a question of how to schedule your I/O across processing nodes and what level of security do you need.
It's not currently cross-platform, but I've planned to implement Mac/Linux support via `inotify`. I messed around with that a few months ago -- shouldn't be too hard, just need to get back on my macbook for a bit.
[Models](http://docs.djangoproject.com/en/1.2/topics/db/models/) in django. I checked out Flask's [view](http://flask.pocoo.org/docs/tutorial/views/) functions - no thanks - that's why I starting using Django in the first place - to get away from that stuff!
The Windows dependency made me sad so I made a few changes. Should be cross platform now, though I have only tried it on OSX. import random, time, pyttsx tts = pyttsx.init() pick = lambda items: random.choice(items) while not time.sleep(5): line = "Place %s %s on %s" % ( pick(("left", "right")), pick(("foot", "hand")), pick(("red", "green", "blue", "yellow"))) print line tts.say(line) tts.runAndWait()
You might want to look into [audiolab](http://cournape.github.com/audiolab/overview.html), if only to reduce loc count 
Flask is great fun, but after having made it 4/5s through developing a community website in it, I have to agree that the module structure in Pylons and Django has its advantages. It probably just takes a bit more learning to understand how to develop major apps in Flask, though. My biggest problem with Django is that its assumptions don't work for the kind of websites I write. The modular nature of Django apps is great in theory, but in practice I often found myself having to mess so much with third party apps that it was easier to write them myself. I guess Django's biggest advantage is that it is a great RAD tools if you can live with its limitations -- kinda like the big CMSes in PHP (e.g. Drupal or Wordpress). You just pick a few third party apps, write your own glue code and then can focus on tweaking the templates -- the Admin tool already provides a solid CMS, too.
Can there be a beautiful language?
I came from PHP via Java. Java taught me why PHP is a bad language. Python taught me programming can be fun. I still write PHP on occasion. I don't touch Java anymore. I try to do use Python whenever I can. Take from that what you want.
thanks, I will
well put and I agree. where I may have used drupal in the past, I would use django. But now a days I prefer to do things more interesting than another website. 
This is the only reasonable solution for an ideal world.
I honestly think python would be pretty tricky for projects developed by large teams(100's) I guess I would call that the enterprise-level. I also find enterprise-level projects boring and unnecessarily complicated. Having worked on teams that big for java projects and C# projects, and realizing that most people doing that consider it a day job, don't care and push out shitty code and would rather play fantasy football, I can't really see how the project would deliver without compile time type checking. I don't need the compile time type checking, but the moron in the next cube sure does :P
I'm no expert on this, but I have had fairly good luck with [WebTest](http://pythonpaste.org/webtest/) It's fine if you want to test your app through straight http requests and asserting values in the responses. All Webtest requires is a wsgi app, which I'll assume flask can be. If not you can serve up your app on a port like you normally would doing manual testing, and then use paste.proxy.TransparentProxy from webtest import TestApp from myapplication import wsgiapp testapp = TestApp(wsgiapp) res = testapp.get("/index.html") # webob.Response assert res.status=="200 OK","failure....." or with TransparentProxy.... from paste.proxy import TransparentProxy from myapplication import wsgiapp testapp = TestApp(TransparentProxy()) res = testapp.get("http://localhost:8080/index.html") # webob.Response assert res.status=="200 OK","failure....." If you need to test the ui via a browser, there are plenty of tools for that. Selenium, Windmill are 2 that come to mind, and I'm currently getting up to speed on Robot Framework which looks very promising. 
Sweet! Definitely remembering the `htmllib` one, pity it doesn't strip &lt;script&gt; tags though
For what you want, virtual environements and https://github.com/bretth/woven is pretty much all you need. Some peer review of your code can't harm your project either but of course, doesn't replace unittests.
Curse you and your facts.
Well, you weren't kidding. That **is** high-quality extreme sound stretching. What is it for?
Looks like you have more than one interpreter. Open terminal and call `python` to open the interactive shell. Look after the version (2.5, 2.6 or 2.7). This should be the python interpreter you used to install the library. If you call `/usr/bin/python` too you should notice a different version (thus a different set of libraries). 
I can only imagine it as a '*make-anything-sound-like-sigur-rós-atron*'.
Wow, this is really awesome, I am using your app as I write. Good luck with further development :)
Here is how we do it: * we chose RHEL and CentOS as our target OSes only. * package everything as RPMs. You can just do setup.py build_rpm. Because there is already a mature packaging systems with dependency management, uninstall, post,pre-install/uninstall scripts,verifications,repositories etc. * tests are of 3 kind: - *unit tests* : these run from the source tree and are limited to just the modules they test. they rely on relative imports. - *integration tests*: unit-tests that run and depend an a set of packages working together. These run after packages have been created, and installed on a clean base OS image. Here we test how application components fit together - *production tests*: these are more like black-box tests. Also installed ona clean, just installed, base OS of a known version. We test the system by activating it the way an end-user would. Click this button on a page =&gt; Get this response. Send this xml-rpc command, end up with the file at this path that looks like this. Etc There are grey areas between them but we find we need all these levels of tests. You might only need some. It is definitely nice to just execute the test-runner at the top of your source-tree without having to build &amp; install anything. But as the system gets more complicated it is becoming harder and harder to manage a lot of mock and shim objects.
Ahh, that's it! calling python reveals 2.7.1, and calling /usr/bin/python reveals 2.5.1 . The library is installed on 2.7.1. Is there some way I can get rid of 2.5.1 or should I just leave it? 
is there anyway to convert a address to its timezone? say Lyon in France, there is only one timezone in France which is Europe/Paris, but how to convert a city like Lyon or even a small town into its timezone? cause there might be multiple timezones in a country...
I bet there's a way to look up approximate GPS coordinates for a given zip code, say, and then use that to figure out what timezone one is in?
well, the problem is that a pair of coordinates and a timezone, for the most time, there is no direct relationship between them, i suppose.
*shrug* Maybe there's a site that can look up the timezone for a city or zipcode or whatever?
Never saw that library before - thanks!
yes! I just hope someone here could know such a site :-)
What you are truing to do is more of a forensics topic than a python one. I suggest you define what you need before you try and implement. 
I would look into something similar to Bayesian spam analysis. What it does is it takes words and scores them based on their usage. If a word is often used in spam, it gets a spammy score, while if it is rarely used in spam it gets a not spammy score. So to adapt it to your problem, if a particular gamer uses a word more often than a normal gamer, then the gamer would get an entry for that word with a score based on how often they used it. You run through many messages from many gamers and put them in a database using the technique. To try matching a new message you then iterate through the words/tokens in the chat, discarding the ones that are too common to be useful until you have the less common words. Check each of the uncommon words against the database, retrieving the gamers who had previously used the uncommon words and keeping a running tally of the scores. At the end you would get a list of gamers who used the uncommon words in the new message more often than an average gamer.
There was a bit of a fad recently of slowing down songs by around 800%, started by [this](http://www.youtube.com/watch?v=QspuCt1FM9M) "slow-down" of a Justin Beiber song. Almost anything sounds like an epic ambient soundscape at that speed. One of my personal favourites is [Istanbul (Not Constantinople)](http://soundcloud.com/captaincaustic/istanbul-not-constantinople-slowed-down-800-the-bierberization-of) by They Might Be Giants, which sounds as hellish as the Beiber slowdown sounds heavenly.
There is most certainly a difference between softcore porn or "pretty soft" and normal pictures of women. Society these days...
wow, that Beiber slowdown is insane.
You probably know about that but when porting .NET stuff, I like looking at how Mono has implemented a feature. Might be useful to you. https://github.com/mono/mono/blob/master/mcs/class/System/System.IO/FileSystemWatcher.cs
From the example, it looks like authentication data is stored globally. It would seem much cleaner to me to have a session andle of some sort tht you attach such things to.
check out the nltk which has some useful tools for working with linguistics
The fast way is to call `which python` and look where the right interpreter (2.7) is, then use this path in your script.
Here you go: http://pytz.sourceforge.net/
You can use it, of course to stretch music. But, also you can smear the spectrum of music by using very large window (like 30 seconds) and 1.0x stretching (no stretching).
Sounds a lot like the website does not have to do anything actually. Why not generate static files and upload them? I wrote [rstblog](https://github.com/mitsuhiko/rstblog) for situations like that and use it for my blog: http://lucumr.pocoo.org/
That would be an idea, yes. Another idea would also plug in some kind of searching through the snippets published, but I guess a search index generated statically on update would also do. However, I may also be interested in some parts being dynamic - namely to handle some non-snippet stuff (data about the writings, characters, etc...). This doesn't make your suggestion less valid, however. I've updated the post just in case to clarify.
Any audio examples of the stretch in action?
Like the comments on the blog said, how is this better than httplib2? Does it support gzip compression? Does it support If-Modified-Since and If-None-Match? Have you read http://diveintopython.org/http_web_services/review.html ? Did you just do the same thing that people have been telling you not to do since year 2000? Do you want your user's IP to be banned by servers for being a bozo? If you only meant the code to be used between two end-points both of which are under the user's control, the user hardly needs your code. Or HTTP, actually.
I think that sounds like a good approach. I'd like an easy-ish way to make a certain word part of a class. ex. "his" and "her" treated the same.
really? again? [4 days ago](http://www.reddit.com/r/Python/comments/fmbk8/requests_awesome_python_http_library_thats/) [6 days ago](http://www.reddit.com/r/Python/comments/fl0uc/new_requests_module_for_super_simple_http_requests/)
what happens when you are sitting behind a proxy? 
For static sites use Blogofile.
Cherrypy or Flask
nginx
I just had to tackle this exact problem for an embedded linux distro called [Plugapps](http://plugapps.com). I'm writing a WebUI for the project ( out of date info &amp; screenshot [here](http://plugapps.com/index.php5?title=Plugapps_WebUI) ) using python &amp; django. Originally it was written with ruby/rails, then i ported to python using web2py, then ported that to django for flexibility among other things. Django stays out of the way for the most part, and I really like their ORM, the template language and the URL routing. If you start using a framework and decide you don't like it or you hit unexpected problems, it's entirely possible to port the code to another one in a short time. In any case, the WebUI had to run on systems with as little as 128mb of ram, and couldn't rely on there even being a webserver installed, certainly I didn't want to have to configure one during deployment. I originally was using [FAPWS](http://www.fapws.org/) which worked very well. It's actually written in C but it allows you to start an http &amp; python application server within your application using python calls I also experimented with nginx+uwsgi since nginx supports sendfile and i needed a solution for carefully controlled large file downloads, but that setup just caused headaches and made deployment more complicated. Now i've settled on using a custom cherrypy script that starts the WebUI as a standalone program during system startup (acts as an init script). Works great, and i'm fairly sure you could make it open an SSL port at the same time within the same code, though the script i'm using would require modification to do that. If you'd like to see the [code i've already written](https://github.com/plugapps/PlugUI), perhaps you can rip off some of it that you find useful, or get some tips or something, or hey if you just want to use it as-is, go for it. Some of the code is specific to the plugapps distro, like the software management and the code i've written to control the LEDs on the target devices (little plug servers like the sheevaplug, dockstar and pogoplug), but otherwise it's just another Django app.
https://github.com/jonashaag/bjoern
Have you used any of the frameworks you mentioned before? It's easier to use something you've already learned how to work with than to look for the perfect tool for the job.
A thowsand times yes. It's *very* pythonic, the event system is just dreamy. It also doesn't try to do anything that it should not do. 
I use [Bottle](http://pypi.python.org/pypi/bottle) for my app framework and [Rocket](http://pypi.python.org/pypi/rocket) for the web server. I like that both are available as single files and thus make it trivial to bundle with my app and they're both lightweight enough that I can focus on my code and not have to worry about adapting to their constraints. 
Definitely tornado: http://tornadoweb.org Its lightweight and extremely fast and its easy enough to package it with your application.
That's optional. You can also just pass AuthObjects in with each call.
As I stated in the introduction, I've done mostly non-web development (with the exception of an internal, minimal application with Flask). So I don't have a clear idea of what's better for this.
I wonder if the bayesian suggestion by ackondro might not be better. The submitter is not trying to glean any semantic meaning from the text, rather they want to try to bin new messages according to patterns from old messages. 
Sorry I spaced out on that part :) I'm partial to Django since i've already learned the ropes with it, and i like the database layer and the other stuff they build in, but in your case you might be better off with a micro framework.
That's more or less it. I never put my approach into code, I just worked out the numbers on paper and plugged them into a calculator.
If you want to create a completely standalone application, you might consider the [web2py](http://www.web2py.com) framework. It is bundled with the [Rocket](https://launchpad.net/rocket) web server (includes SSL support), has no dependencies (the Windows and Mac binaries even include their own Python interpreter), and requires no installation or configuration. You can run it from a thumb drive, and you can even [distribute web2py applications as binaries](http://web2py.com/book/default/chapter/12#How-to-Distribute-your-Applications-as-Binaries), which can run on the user's local machine with a single click if desired. web2py is simple and easy to use, but is also a full-stack framework with lots of features and flexibility. If you have any questions, the [mailing list](https://groups.google.com/forum/?fromgroups#!forum/web2py) will be very helpful.
Seems like this isn't much better than the usual HTTP libs: no connection pooling, no thread safety, etc. Looks like a collection of aliases and helpers, that's all. A friend of mine wrote [urllib3](http://code.google.com/p/urllib3/) which actually is an improvement over the standard library stuff, I suggest people check that out.
Audiolab is pretty awesome. Some minor pet peeves: * the "play" command will usually only work with certain sample rates. Apparently this is a limitation of the underlying audio hardware, but there are clearly workarounds. * (at least last time I checked,) there is no built-in re-sampling support. This would make dealing with my first issue much less of a headache.
I'm giving a try right now, using YAML files for the "dynamic" part of the page. If that doesn't work out I'll move to something more complex.
I got this bug in firefox 3.6.13 for Ubuntu.
http://www.twistedmatrix.com
I have samples for the [c++ version](http://hypermammut.sourceforge.net/paulstretch/) which uses the same algorithm for stretching: [Original ogg-vorbis](http://hypermammut.sourceforge.net/paulstretch/original.ogg) and [20x stretched ogg-vorbis](http://hypermammut.sourceforge.net/paulstretch/20x.ogg)
This would be my vote as well.
I recommend you [Diesel](https://github.com/jamwt/diesel). Actually, I use it not only for UI but also as framework for my application (task management, event handling, network). Using wsgi protocol module you could easily use for example Django as template language.
Interesting. I want to use a dockstar + USB-RS232 adapter to act as a water bath controller with a web interface (temperature set points, maybe some temperature graphs). Plugapps could be just the ticket!
Rocket is great and pure python (both 2.x and 3.x). It is very fast. 
CherryPy would be a good choice. You may consider Tornado as well but the question is; "do you really need tornado?" Tornado is a solution to a certain problem. You may also consider [FAPWS](http://www.fapws.org/). &gt; PS: would you use any web framework for creatig a web UI? (configuration pages for some software). If so - which one? I found web.py to be pretty simple and small. I'd use web.py (or Flask). As a side note, web.py bundles with CherryPy. 
That's much better. Really wish that the tutorial didn't teach you bad habits like that, though.
If you have databases, need to support multiple (human) languages, have to distinguish between multiple users, have pages composed of multiple distinct items of content then using one of the "big" Python web frameworks is a very good idea. For work we had none of those needs and so I use bare WSGI which means it can be frontended by Apache, Nginx or anything else. The best Python WSGI server I have found is the one from [CherryPy](http://www.cherrypy.org/browser/trunk/cherrypy/wsgiserver) which supports SSL and does things right. For example it correctly supports chunked uploads while the builtin [wsgiref](http://docs.python.org/library/wsgiref.html#module-wsgiref.simple_server) screws them up big time. For actual WSGI interfacing I use [webob](http://pythonpaste.org/webob/) as it is pretty much the minimal amount of code to take the actual WSGI spec and environment and make it object oriented. My output is selectable as text, json, csv and html depending on the request. For HTML and text I use [genshi](http://genshi.edgewall.org/) as it is by far the best templating engine out there. You cannot produce invalid output and it escapes content by default so the chances of an XSS attack are far lower.
If Sean's running the network again this year, it'll work. If it doesn't, he'll get it fixed and it'll work. I have that much faith in him based on what I've seen him do in the past. The years the network has gone down in flames are the years we tried to subcontract it out so that Sean could enjoy the conference. Looks like we'll need to clone the man to get both a working wifi setup and a conference he can enjoy in peace...
Unless his project already uses twisted (which I doubt if he's asking this question), I'd say twisted might be too big. Especially if he's bundling the app for a Windows deployment.
2nding CherryPy. There's probably a good reason every web based app I use uses it.
The sad thing is that I'm going to go download and install this, but probably not wind up using it for anything. WSGI2 (or whatever's blocking WebOb for Python3) needs to happen ~~soon~~ *last year*.
 * have a look at PEP 3333 * things are looking way better than you hint e.g. http://alexgaynor.net/2011/feb/17/django-and-python-3-take-2/
* [highlights](http://www.python.org/download/releases/3.2/) * [whats new](http://docs.python.org/dev/whatsnew/3.2.html) * [changelog](http://svn.python.org/projects/python/tags/r32/Misc/NEWS)
Interesting, thanks.
I just updated the post. Thanks for the feedback!
Cool fonts, but none is usable enough in current days...
You still need an scgi or fastcgi application server with nginx...
I would start with the emacs tutorial. I'm just learning emacs now, and I'm finding it best to let my workflow develop more organically. Essentially, I'm just using what I know how to use, and then if I can't find a feature that would be handy, I start searching for it (google, /r/emacs, and #emacs on freenode)
Any documentation for rstblog? I might just be missing it, but I was looking into using it a few weeks ago, but I couldn't find an example or just which command to run.
/r/emacs, excellent, why did I not think of this first.
I haven't written any documentation so far. my blog (mitsuhiko/lucumr on github) and the source is what I have for documentation currently. I wrote that thing for myself mostly but it's quite easy to customize.
&gt; * an overhauled GIL implementation that reduces contention I didn't believe the hype on how old GIL was so bad until I benchmarked and saw a 4 times performance increase by just moving my the script from a quad core machine to a single core VM on the same physical computer. I am curious to see the GIL improvements.
How were you going to handle ipc?
Hmm. That sounds like a great idea for my home brewery. Been wanting to hack hardware w/ Python for sooooo long. 
That's part of what I'm still trying to work out. The way I picture it is that the socket-server process would be collating and queuing the client commands as they come in (in a separate thread) and the game loop process would empty that queue at the start of each iteration and prepare messages to send back to the clients at the end. I guess one question to answer is whether using multiprocessing's Queue will block the other process's event loop. In that case the processes might need to communicate using sockets as well (or just give up on multiprocessing and use gevent for everything).
It's not clear to me how segregating the network and CPU components would help much -- IPC is basically the same thing as networking. And games generally have a lot of global state, which makes threads sort of horrible. I'm pretty sure most game servers use a single process, sometimes farming work off to other threads/processes when the state they work with can be isolated.
I hope Matplotlib adds Python 3 support soon.
The GIL is a fucking tragedy in a modern world with several cores. It's really turning me off Python. CPython needs JIT and real threading.
In my tests most of multiprocessing's synchronization isn't green compat. Not sure if you'd want the performance hit but using zeromq might make things a bit easier than going raw sockets (and let you move more expensive bits into c more easily, probably).
Can anyone enlighten me if it is worth it to learn 3 over 2? I've heard (LPTHW) that I should stick to 2.
Maybe give [Go](/r/golang/) a go ;)
You're right, it's in the [new 3.2 release](http://docs.python.org/dev/whatsnew/3.2.html#optimizations).
Cool, thanks!
FWIW lots of the 3 syntax and such has been backported to 2. I'm just learning it right now, and am going through tutorials on 3, but "using" and entering examples into 2. There is a lot, lot more out there on 2... advanced tutorials, Django guides, etc. 
I can always PM you my pyserial code. Although it's just a dozen lines long, it might give you some ideas :) Also, I noticed last night that the iomega iconnect has 256MB RAM and onboard wireless. Might be better hardware to tinker with than the dockstar, but not sure if people have already mapped the JTAG / serial ports. I personally wouldn't try anything without knowing where these are.
I don't want to offend anyone, but that is a terrible name, IMO.
You were being lazy
3 and 2 are almost identical. To be frank, you can't truthfully claim to know one well without knowing the other also.
Thanks ! As for the play command, I programmed it quickly, and it certainly is not great (alsa is PITA to program for, too). The reason I don't do resampling is that doing it right and online is quite difficult, and I don't want to add a dependency on another library. I could optionally import samplerate, though (but I would need to add online resampling support to it - the underlying library in C supports it). It should be a couple of hours max for someone interested in the feature.
If you're new to Python then certainly, start with Python 3 right away as it is without doubth the better language. * sane unicode handling * do away with odd naming cruft of libs and overlapping functionality http://diveintopython3.org/porting-code-to-python-3-with-2to3.html * etc.
If you're new to Python and want to use a lot of libraries that provide cool features, and you're interested in building real-world applications, you may want to consider using Python 2 instead. Libraries are being slowly ported over to Python 3, but there's still an awful lot more available for Python 2. 
Depends a lot on the kind of game. If we're talking a long-term, slowly developing game with a lot of state it might make sense to use a backend database. Or memcached, etc. If we're talking quicker and more ephemeral, multiprocessing.managers might be worth a look. Also, worth considering if you can divide the game into "areas" or whatever to split the network up.
I think the main job is to transform the untrusted networking between user and frontend into trusted IPC between frontend and backend. 
I like it, I was thinking of something similar, but more like a Makefile with some helper scripts :-). Also wanted it to process LyX :-). 
Actually, the [Google Web Search API is deprecated, and Custom Search is the recommended alternative](http://code.google.com/apis/websearch/). Presumably, this means you can customise the Custom search to provide results from all of Google, but have to pay for the privilege. This does make sense, since Google understandably don't want you to circumvent their own display of search results, because of the embedded revenue-generating ads.
If you mean the Google Web Search API, [it's deprecated](http://code.google.com/apis/websearch/).
I did not downvote nor did I upvote your comment.
Does it have support for https? Didn't find anything when I skimmed throuh documentation.
Python is a total match for the Enterprise. Please look at the https://code.google.com/p/ncc1701/ project, which provides the necessary enterprise functions. 
How exactly is shed skin coming along? Last I attempted messing with it, it was at 0.3 and wasn't very useful for...well, anything really. Has it gotten to the point where you might actually be able to get something serious done with it?
&gt; I didn't believe the hype on how old GIL was so bad until I benchmarked and saw a 4 times performance increase by just moving my the script from a quad core machine to a single core VM on the same physical computer. That has nothing to do with the GIL, you'd see the exact same thing with any single threaded script. Removing the GIL doesn't magically make your program multithreaded.
It's really not that simple. Python 3 *is* a better language, but there are tons more projects in, and tons more support for, Python 2.x. Also, if you want to get a job working with Python any time within the next three years (and that might even be optimistic), Python 2.x is the way to go. But learn Python 3 as well.
Oh look, builtin format, str.format, and str.format_map! str.format_map is going to have the hell abused out of it, until magic dictionary classes are considered pythonic. Mark my words. What we **NEED** are *string* comprehensions and unquoted literal strings, and, crap I just became a perl programmer again.
I think you may be misunderstanding. My multi threaded programs run faster on single core systems, due to less need for GIL locking. http://www.dabeaz.com/GIL/ (page 33 goes into this I believe)
I've used it for things since 0.4, and it's come quite a ways. I was using 0.6 regularly for some internal code, and I'm going to switch the process to use 0.7.1. Every once &amp; a while, I'd bump into something that didn't work, or was slow, but overall it was pretty good, especially since it doesn't require too much of either the programmer or the sysadmin (i.e. you don't have to modify your code overly much, and you don't have to install a great deal of things in order to get it to work).
Horrible, horrible syntax IMO. It's like having my eyes stabbed with blunt razors.
The content is good, but there are many grammatical errors that need to be fixed. For example, &gt; What value a Python function returns when return statements are omitted?
You clearly have not read or written much Go... it has way cleaner syntax than C, not to mention Java, C++, Perl, Ruby... 
[gevent](http://www.gevent.org/)'s WSGI/HTTP server is solid. We're using it in a project that uses [Flask](http://flask.pocoo.org) for the web framework bit. It had to be deployed on Windows (we usually deploy on Linux) and it Just Works. Seems to support SSL as well, so all good there.
Subjective. Please note that I clearly stated it was *my* opinion.
Feel free to have a look at removing the GIL. It's probably harder than posting on Reddit.
The Cape Town Python Users Group is going to sprint on finishing the Matplotlib py3k branch [on March 5](http://pythonsprints.com/2011/02/9/matplotlib-porting-cape-town/). Who knows how much they'll get done, but 5-6 people getting together for a day should be able to hack out a good amount of progress, at least getting the wheels in motion.
Well, now I think it might be worthwhile if you had multiple areas of the game world implemented as separate processes, and then you could just start talking to a different backend server.
OK. I thought you had a single threaded program, saw that perform faster with 1 CPU, and thought that was a reason to hate on the GIL.
Each game is going to be pretty small (no more than 1000 total game objects, ~10 players maximum) and short (5-10 minutes), so I was hoping to keep everything in-memory. multiprocessing.managers looks very promising, I'll look into it further. thanks!
A lot of researchers I know write code first in R, and then in Fortran and C when they want to speed it up. Thats a pretty big jump readability wise.
Very nice. I really like where the Python community is headed now that it's sitting at #4 on the Tiobe index. We have a lot more focus on speeding up Python than we did in the past (PyPy, Shedskin, etc) and not to sound like one of "those guys" but eventually we'll have a reasonable solution for replacing the GIL and adding some much needed options for concurrency; Hopefully without making things overly complex in the process.
when I went from threads to multiprocessing I saw comparable improvement on my quad core. 
Based on this and some other suggestions, I think I will start with a single-process pure gevent implementation instead, and move into the multiprocessing plan mentioned above only if the benchmarks for the game loop make it seem worthwhile. In that case I will definitely try out this suggestion as well as the multiprocesing.managers packaged mentioned elsewhere. Thanks!
it's not webob's fault that PEP 3333 wasn't solidified till like last month. these things take time I would recommend you put your license subscription fees for webob in escrow until you get what you want, it's the only way they'll learn. 
Awesome!
I'm looking forwards to argparse and concurrent.
Do you think 3rd party modules in Flask or Pylons/Pyramid don't have this issue or do you find that you prefer something other than Django if you're going to build everything yourself anyway? 
should link to the [demo site](http://hg.python-works.com/). It looks pretty slick. built on pylons yay.
Based on the size you mentioned below I think single proc will be fine. 
HTTPServer can serve HTTPS (SSL) traffic with Python 2.6+ and OpenSSL. To make this server serve SSL traffic, send the ssl_options dictionary argument with the arguments required for the ssl.wrap_socket() method, including "certfile" and "keyfile": HTTPServer(applicaton, ssl_options={ "certfile": os.path.join(data_dir, "mydomain.crt"), "keyfile": os.path.join(data_dir, "mydomain.key"), }) source: https://github.com/facebook/tornado/blob/master/tornado/httpserver.py
The problem is that 3rd party modules require certain assumptions. For example, suppose you want a "comments" plugin that allows you to attach comments and comment forms to an arbitrary bit of content, such as a blog post. With Django, or a CMS like Drupal, you can make certain assumptions - for example, that you have not only an RDBMS, but an ORM, and that the "author" of the comment will be of type "User". You even have a framework for attaching arbitrary content to models, such as Django's contenttypes. A more low-level framework like Pyramid or Flask cannot make these assumptions. Pyramid for example is DB-agnostic: you might use SQLAlchemy, someone else is using ZODB, and another project has MongoDB. Although Pyramid does have an authentication framework, you cannot attach an "author" entity to a comment in a generic way. Any Pyramid "comments" plugin would have to make too many assumptions to be practical. This is not saying Pyramid is better than Django or vice-versa; they have different approaches, either works better depending on the project. Having used both, I'd say Django gives you a quicker start, but you have to make a lot of compromises to get the most out of the framework, while Pyramid lets you build something more fine-tuned to your requirements but you take more time getting started, structuring your project, choosing low-level components etc. Django has a bigger ecosystem, and is more standardized, which makes it easier to jump between projects (good for contractors), while I would imagine that Pylons/Pyramid teams each have their own favourite stack/patterns that will differ quite a bit from one another, but within which they are extremely productive. 
did you read the what's new in Python 3.2?? that thing blocking web development for python 3 is fixed with WSGI 1.0.1
The reason I asked is that this exact issue is something that the Django community is working to improve, and for which Flask and Pyramid have different approaches. Pyramid has "add-ons" (and uses a plugin system internally) and Flask has curated extensions. I'm interested if anyone has had experience enough to compare the approaches.
In retrospect, it's such an obvious detail. But that's usually how obvious goes.
You just want to be able to say that your web application runs on bottle rockets.
If you're a vim user and want to have this all the time, put the following in your vimrc: set list set listchars=tab:»·,trail:· I've grown to depend on having this, especially when working on python code collaboratively. I can always tell immediately who's not following our indentation rules (namely, no indenting tabs ever).
The shade of gray he uses is totally invisible in the upper part of an average quality LCD monitor. But becomes somewhat visible towards the bottom. The overall effect defies description! Also, what about not using hacks like inserting a half-visible character at all, but for example draw some nice thin L-shaped lines to show block structure instead? Maybe with the lower bar of "L" being really short instead of going all the way to the right...
It depends what you mean by "add-ons". Pyramid, Flask and Django all have low-level plugins for low level things like template engines or form libraries, for example. That's relatively straightforward and is mostly glue code to allow e.g. template engine X to work with configuration setup Y. Higher level plugins for adding constructs like "comments", "users" and "blogs" are another matter, because they rely on buy-in at a correspondingly higher level. While Django may improve on this front - for example having a better way to swap out foreign keys to custom User models - there's still a requirement for a given ORM. However I'm not sure that's really what a framework should be doing - that's maybe something that's more the responsibility of a CMS.
Alright, good enough for me. Thanks
I think I'll try learning 2 first and then move up to 3 after.
Thanks, I might stick to learning 2 then.
ok thanks. will fix that.
I see. Since there was only one image frame, I thought the test was to identify what image was being obscured. I should have read more closely.
the old python.exe must be in your path somewhere go to control panel-&gt;system-&gt;advanced-&gt;environment variables and check for PATH on both. Make sure the only python installations in your path are 2.5, and not 2.7 Knowing the standard python install, it should be C:\Python25. (Did you extract that rar from 2.7 over the 2.5 version? That won't work, python modules are often specific to a version of python)
You might want to check out Jenkins (was: Hudson): http://jenkins-ci.org/. Continuous integration server. You can configure it so that upon pushing to a specified git branch, it will pull the code, build an environment, run the tests, and then (if and only if the tests pass) trigger a script on your production server to deploy.
How about adding comments at the end of the block? e.g. # endfor, endif, enddef, endclass, etc.
Ah, ok, I get it. But that wouldn't be as good a test, because the "reward" (porn) would always be forthcoming when a porn pic was randomly selected, ie, the subject would have no self-determination. The basis of this experiment is that you don't care about scores. The old tests used to be cards face down and one had a star, one had a circle, one had wavy lines. But they found that the subjects could give two shits about being "right". Because there was no gratification in getting a wavy line card right or a star or whatever. You weren't going to make more money at your job, or get laid more, or have a prettier wife or girlfriend, etc. What makes this experiment interesting is that people actually did better with the psychological reward of porn, as fleeting as it is. I wish I could do the experiment with the reward of $100 for every right answer and -$100 for every wrong answer so that if you took the test randomly guessing, your probable outcome would be $0.00. But I don't have that kind of money. I bet that experiment would yield *very* interesting results.
The font on this site made me cry. I couldn't read most of it, plus missing picture...
Python 2.7 is completely backwards compatible...
No worries. Yeah, it looks nice, although I haven't used it myself (yet). I was looking at it at one point for a web-based game (using AJAX long polling). The alternative, given the small number of players, is to write the entire thing asynchronously, with each game running on a single process. asyncore looks nice, there's also more complicated things around like Twisted, but I never got around to looking at those in detail. EDIT: Or gevent, as you say ...
Alternatively use the [Indent Guides](http://www.vim.org/scripts/script.php?script_id=3361) vim script. I have recently started using this and it is invaluable for Python code. There are screenshots of it in action [here](http://nathanaelkane.imgur.com/indent_guides#ONgoj).
I find that if I ask the people "in the know" before thrashing around on the web for hours, I have a considerably less frustrating and rewarding experience. So like most programmers Lazy=Smart
That would be bad for publishing since it would add a lot of extra lines.
Can't we just agree that indentation-as-syntax is a stupid idea?
no
Buddy, I don't think you're in the right subreddit.
Some of the questions feel ambiguous, at least to me. I answered: &gt; Where does Python keep a list of locations where module names are searched for? with "PYTHON_PATH". I do realize that I am probably wrong, because it is not python keeping modules in there, but rather the environment and python then populates sys.path from there, it still feels ambiguous what you want. I'd rather ask "How can you programatically access the module search path" or something along these lines. Also note that the name "simple statements" is grossly misleading. Something about the module search path or the number of initialized modules (heck, I didn't even know that before this quiz) does not really qualify as "simple statements". "if is_dead(bear): eat(bear) else: shoot(bear)" would be a simple statement.
I haven't seen or tried any third party "apps" (Django-style) for Flask. The flaskext extensions seem to generally work by importing them and passing them your app object, which works quite nicely for the ones I've tried so far (Babel, CouchDBKit, Mail). My problem with Django's apps is that they are supposed to be used as full pluggable content modules. In practice, they aren't quite so reusable unless you write very generic and loosely coupled web apps. The magic breaks down as soon as you try to do something Django wasn't built for. As long as you stay within its boundaries, it's eternal bliss, though. The thing is, Flask and Pylons/Pyramid don't really have an equivalent. While Flask has Modules and Pylons has a class based controller architecture, the entire "pluggable" concept isn't quite as clear. I don't consider that much of a loss, but if you make extensive use of it in Django, you'll probably miss it.
I like WingIDE, unfortunate the Pro version is $95. I do a bit of work that the Personal version doesn't cover, and I don't make money off my projects (and the 101 version is pretty much crippleware). I also do not qualify for the free license =/
well worth the money if your coding python day and night like myself
This is the 100 doors routine off of Rosetta Code. These are the unoptimized versions. I don't think Go has a cleaner syntax than either. Go: package main import "fmt" func main() { doors := make([]bool, 100) for pass := 0; pass &lt;= 100; pass++ { for door := pass; door &lt; 100; door += pass + 1 { doors[door] = !doors[door] } } for i, v := range doors { if v { fmt.Printf("1") } else { fmt.Printf("0") } if i%10 == 9 { fmt.Printf("\n") } else { fmt.Printf(" ") } } } Ruby: n = 100 Open = "open" Closed = "closed" def Open.f Closed end def Closed.f Open end doors = [Closed] * (n+1) for mul in 1..n for x in 1..n doors[mul*x] = (doors[mul*x] || break).f end end doors.each_with_index { |b, i| puts "Door #{i} is #{b}" if i&gt;0 } Python: close = 0 open = 1 doors = [close] * 100 for i in range(100): for j in range(i, 100, i+1): doors[j] = open if doors[j] is close else close print "Door %d:" % (i+1), 'open' if doors[i] else 'close'
There's plenty to like about python without accepting every design decision dogmatically. The niggling annoyances don't justify dropping the whole language.
Better than PyDev?
WingIDE is my favorite Python IDE, the code auto completion and debugger is really impressive. the new Matplotlib support feature is very useful too (to me).
Try a sandbox environment like virtualenv. It's easier than worrying about your distro's python requirements.
I hope there will be videos available.
If something in a useful tool is flawed then you should make noise about it, regardless of how stubborn the tool's maintainers are about doing nothing about it. I would consider that to be common sense. Not to bring it up tangentially in every topic of course, but if there were a relevant place to point it out, an article about the problems it causes in being able to understand Python code in a given context seems to be it.
you can find PyCon 2009 and PyCon 2010 videos on [http://pycon.blip.tv/](http://pycon.blip.tv/) and there will be PyCon 2011 video too.
Yes I do good sir. 
You're a rube and you can't read.
Did it get color themes yet?
no
Ended up just compiling from sauce and hacking together some libraries. 
It's a lot better than PyDev. Eclipse is big and messy.
WinIDE is great. It was one of the first IDE to support web2py, since 2009: http://www.wingware.com/doc/howtos/web2py
what makes django special? as in what support does it need that a python ide alone does not provide?
Well, I have to admit that there is a sort of karmic justice to using that stack in an otherwise exclusively Java shop. Behold disruptive Python! =P
I don't know why you're getting downvotes when those people with one word answers "no" are getting upvotes. I don't agree that indentation-as-syntax is stupid (although I would like to see it as optional, there are situations where it's bad), but it's a perfectly legitimate complaint.
May be useless for a compiler/interpreter, but is certainly useful for humans.
Have you ever played with PyCharm? That's by far my favorite, but then I was a big IDEA fan when I did Java stuff.
WingIDE supports [Debug Django Templates](http://www.wingware.com/wingide/whatsnew) 
Any chance of running your script against the new Python and comparing results? I also had no idea how bad the GIL problems were until reading your comment and following up with a bit of Googling. 
is that a pic of you on that page? :)
I've talked to Kenneth and I can confirm this.
I assumed that it was a fairly common feature for text editors / IDEs. I've used those options in Vim before, and Komodo has a similar option (not quite as flexible though). Edit -&gt; Preferences -&gt; Editor -&gt; Show Whitespace Characters You can change the color via: Edit -&gt; Preferences -&gt; Fonts and Colors -&gt; Colors -&gt; Whitespace Foreground Color
Am I a jerk if I ask the new GIL to be back-ported to Python 2.x?
I'll plug my own Pythonic way of using Hadoop (Cython code, TypedBytes serialization, nothing is faster at the moment) http://brandynwhite.com/hadoopy-cython-based-mapreduce-library-for-py
Head over to r/redditgamejam and write a game in C++ in 48h! :) 
you bet! :),I'm just a WingIDE user and has nothing to do with the picture.
[it has been already posted here:](http://www.reddit.com/r/Python/comments/fpnve/wing_ide_40_released_adds_refactoring_find_uses/)
Never used it, so here's a question. When you use Wing IDE, do you really have all those debug windows open and a Windows-95-esque pileup of toolbars surrounding 12 lines of code, or did Wingware turn all that on just so they could have the most unappealing screenshot possible? 
How is that Pythonic?
"she", not "he". Judging from the end of her post, anyway. (I do otherwise agree entirely with your post, though.)
Wow, that python code is awful. i = 1; for score in scores: Really? ;? And what's wrong with enumerate()? if (score.user is not None): Why are there brackets? GqlQuery Nope.avi
Wow, the algorithm is a lot simpler than the C++ implementation led me to believe. **EDIT**: I don't mean that negatively either - it's elegantly simple.
Your problems sound very similar to the ones I've had in the past. I found too that creating deeply nested categories quickly became unmanageable. Furthermore, I could never remember where I had put certain projects because they could have easily gone in three different categories. I've now switched to a very flat directory structure, with every project living in ~/projects. I have a separate git repo for each of my projects. I really don't see the advantage of putting all your projects in the same repository, but others may disagree. I user a combination of Dropbox and Github for storing my git repositories. Bitbucket is also a great choice, as they offer an unlimited number of private repos. The great things about git is that you can easily add and remove remote branches, so there's no reason why you couldn't use all three. 
What's wrong with using parenthetical conditionals like that? I find it helps me keep the logic more organized in my code, but then again Discrete Math 143 habits die hard...
Flat hierarchy and I use an indexed search like google or Windows 7 in-built search to find things years later. It pays to sprinkle your files with key words though to act as tags/mnemonics in future searches. - Paddy. 
Interesting. Though, wouldn't reasonably well-written code already have enough keywords in it due to variable names and comments? Although I agree that it can't hurt to add a couple more, it's good advice. I do the same thing with my bookmarks already (in the description field) and indeed it works wonders. 
Yes, because it's easier in Python than in C++. For example, in Python/Numpy multiplication of two arrays of numbers is a single instruction, while in C++ I have to use for instruction. Also, the Python function does only a base stretching without processing effects.
Ah, I see. It probably doesn't help that I don't understand C++ well enough to pick apart what is/isn't the base stretching. Still, this is very good to see, especially since it's now in a language I can get my head round. Thanks again! :)
I'd be curious to hear the thoughts of the three downmodding redditors who are perhaps in the "no, *don't* put version info in your python packages" camp.
eh, I just realized, I figured I'd post this in r/Python cause the stuff I wanted to sort out are mostly Python programs--which only makes sense until you think about it. Would it be proper reddittequetette to xpost this to r/Programming?
Never mind, r/Programming doesn't allow text posts :-/
**Organize as best you can and when you need to find stuff --&gt; grep.** What projects hold value to you most? I think over time your old test projects should become less valuable to you and the act of organizing them might not be worth it.
Several of those are optional/close-able. I think they were just showing off a good chunk of the feature set, and layout. Also, that screenshot is about 800x600. As with many IDEs, the more screen real estate you have, the less cluttered it will look.
I organise mine in ~/Projects/&lt;language&gt;/&lt;projectname&gt;/ where ~/Projects/ is a mount bind of my programming drive. I don't need to search for stuff as long as i know what language it was written in.
Agree with Flat being better than Nested, and separate repos for each project, especially now that Bitbucket has unlimited private repos. (!)
"I wanted to do in boxing what Bruce Lee was able to do in karate. Lee was an artist, and, like him, I try to get beyond the fundamentals of my sport. I want my fights to be seen as plays." - Sugar Ray Leonard Don't you just love all those nintendo games on the Xbox?
* [NetworkX](http://networkx.lanl.gov/) * [graph-tool](http://projects.skewed.de/graph-tool/) * [Twitter in 3D](http://pyevolve.sourceforge.net/wordpress/?p=203) * [CLiPS Pattern](http://www.clips.ua.ac.be/pages/pattern) + [NodeBox](http://nodebox.net/code/index.php/Home) 
30 days is kind of long for something like this don'tya think.....
I like the look of the third link, although i don't like the fact that it uses RPC. I'm currently looking into the second link, and will look at the first afterwards. Thanks. EDIT: The third one, Ubigraph, looks good, except i can't get it to set the font color or background color. This is the only thing stopping this program being awesome.
I think that might be related to the fact that the post lacks of why it's useful, how it's used.
I'm imagining a world without rhetorical questions.
I'm not sure exactly what you're trying to do (as I can't read perl), but [subprocess](http://docs.python.org/library/subprocess.html) is likely the module you're looking for.
Yes. Given your specific example, you want [os.popen](http://docs.python.org/library/os.html#os.popen). However this has be deprecated and what you really should be using is the [subprocess module](http://docs.python.org/library/subprocess.html#module-subprocess) Enjoy! 
Great, thanks! Looking into this now :)
Looking now, thanks! :)
sir please give me your codes !
After the good suggestions about the subprocess module, I figured I'd let everyone know how I accomplished this same thing, in case anyone else searches and wants to know the exact answer: from subprocess import * p = Popen(["/usr/bin/mail", "-s", "test message", "email@address.com"], stdin=PIPE) p.stdin.write("This is a test e-mail\n") p.stdin.close() 
I prepend most of my projects with a date yyyymm, I usually find that I have a good idea of how old a project is, and makes it quicker to find. I have a hard time remembering what I called a project. 
I do this as well. I have ~/dev with a big single layer of directories inside of it, each directory being a project. Each project has its own version control repo contained inside (well, except old ones), and the important ones are on github too. Want to sort them by last-modified date? `ls -ltr`.
You could try /r/coding instead of /r/programming.
Hi. I just released another python version with a new algorithm which is transient friendly. Check the file "paulstretch_newmethod.py" from https://github.com/paulnasca/paulstretch_python
github.com or bitbucket.org I've recently moved to mercurial, since I find it "simpler" to use.
This. Obvious point in title linking to a blog article that only minimally elaborates on that point. Downvoted.
&gt; It pays to sprinkle your files with key words though to act as tags/mnemonics in future searches. It's called commenting your code. &gt;_&gt;
try `print obj1.test`. You'll see that it's a bound method. It's essentially a function with the self argument "saved", so that even if you assign it to `obj2`, it still has a reference to `obj1`, and `obj1` will be `self` when the method is called. When an object is instantiated, Python goes through the methods defined for that class, and for each one, creates a bound method with a reference to the appropriate `self`, and then attaches it to the new instantiated object. Notice the difference between `X.foo` and `x.foo` here: &gt;&gt;&gt; class X(object): ... def foo(self):pass ... &gt;&gt;&gt; x=X() &gt;&gt;&gt; x.foo &lt;bound method X.foo of &lt;__main__.X object at 0xb76f1fcc&gt;&gt; &gt;&gt;&gt; X.foo &lt;unbound method X.foo&gt; &gt;&gt;&gt; print x.foo.im_self &lt;__main__.X object at 0xb76f1fcc&gt; &gt;&gt;&gt; print X.foo.im_self None 
A couple things: 1) In the example you gave, x is a class/static variable, not a member field. If you want a member field, set things up in the constructor class SomeClass: def __init__(): self.x = 5 Sure, it seems to work OK for something simple but if x were mutable, you'd run into problems: &gt;&gt;&gt; class SomeClass: &gt;&gt;&gt; x = [] &gt;&gt;&gt; a = SomeClass() &gt;&gt;&gt; b = SomeClass() &gt;&gt;&gt; a.x.append(1) &gt;&gt;&gt; print b.x [1] 2) For a static method, use the `@staticmethod` decorator: class SomeClass: @staticmethod def some_method(): print "Hello" SomeClass.some_method()
8 points and no comment: so the plan is continue waiting, i guess.
My plan is to ignore it until such a time that every package I use supports it.
Not sure if this helps, but here's how my company has it... We've got a subversion repository set up with the following directories: apps, libs, upstream, websites, hosts, personal; and each of those directories then contains projects by name; under which is then the typically subversion trunk/tags/branches directories. (Upstream is for stuff like archives sets of installers for windows build environments, or patches being kept around; hosts is for archiving server-specific config &amp; scripts, personal is per employee stuff). We tried categorizing things further, and it proved tricky as projects changed meaning, but those generic project types rarely did. For pre-svn projects, etc, I untarred any backups I could find, and pushed them into subversion as tagged versions of a project, so that everything is accessible. For checkouts, I try to keep project checkouts in the same structure as the svn repository, so that things are easy to locate. Regarding large files &amp; backups - the svn repo stores all changesets in separate dirs, and i've set it up so it has nightly backups that are transferred as diffs (using spideroak.com to namedrop them). Thus even when comitting graphics assets to svn, while the archive grows, the backup xfer costs scale with the # bytes added since the last backups, and the backup storage is linear with the repo size. Hope that helps. 
Thanks for the tip. I tried making x a list and editing it and sure enough, it changed for both objects.
Sweet. Thanks for a good answer, just what I needed to know. I'll read up on bound methods :)
One can use hotkey(shift+F2, F1, F2, etc) to flip between these different views(some view mode gives the biggest visualization area for editor, some view mode provides more IDE support such as DEBUG I/O, DEBUG probe, Source Assistant)
The closest analogy to static functions in other languages is to use the [staticmethod](http://docs.python.org/library/functions.html#staticmethod) and [classmethod](http://docs.python.org/library/functions.html#classmethod) decorators.
The binding of the first argument of a method happens when the instance is created, not when the method is called. `obj1.test` fails because it is a function whose first argument has already been set to `obj1`, and when you reassigned it to `obj2` that didn't change. `obj1.anotherTest` fails for a similar reason; `anotherTest was not part of the class object when `obj1` was instantiated so it's first argument wasn't bound to `obj1` and has to be passed explicitly just like with `test2`. The relevant googlejuice is "bound method".
When you define a class, the functions are defined as normal functions, and become part of a dictionary that is eventually turned into a class. Try doing the following: &gt;&gt;&gt; class SomeClass(object): &gt;&gt;&gt; def test(self): &gt;&gt;&gt; pass &gt;&gt;&gt; print locals() Now 'test' is stored in the **class**. Have a look at the following: &gt;&gt;&gt; SomeClass.__dict__['test'] There is your plain old function object. If, however, you do: &gt;&gt;&gt; obj1.test You get something different - a bound method (whatever that is - to be explained). However, when you did `obj1.anotherTest = test2`, something different happens - the function object ends up in the **instance's** data dictionary - have a look at: &gt;&gt;&gt; obj.__dict__ Now, the question you should be asking is: in the case of 'test', how does the function get turned into a bound method? As it happens, the mechanics for this are not magical processes inside Python, they are things you can use yourself. Functions are not just plain objects. They are **descriptors** - they implement the `__get__` method. Now, you have to understand some of the lookup process. When an attribute is looked up on an object, first Python looks in the instance's data dictionary (`obj.__dict__`) for an object of that name. If it finds it, it returns it - this is what happens when you do 'obj.anotherTest' - the function 'test2' is returned, just as you defined it. If an attribute is not found in the instance's dictionary, however, Python looks in the objects **class**. And this time, it does something more complicated. If it finds the object in the class dictionary, it checks to see if that object defines a method called `__get__`. If it does, it calls **that** method, passing in first the instance and second the class as the arguments. Whatever is returned from **that** call is the thing that is finally returned as the result of the attribute lookup. Now, functions have a `__get__` method defined in such a way as they will return a 'bound method' object if the instance is passed in. This bound method object stores a reference to the instance, and can therefore supply it as the first argument. If it were implemented in Python, it might look something like this: class Function(object): def __get__(self, instance, cls): if instance is not None: return BoundMethod(self, instance) else: return UnboundMethod(self) def __call__(self, *args, **kwargs): # Some magic here that calls the actual function with *args and **kwargs class BoundMethod(object): def __init__(self, function, instance): self.function = function self.instance = instance def __call__(self, *arg, **kwargs): # Here is the bit where the instance gets passed # to the function as the first argument: return self.function(self.instance, *args, **kwargs) I'm pretty sure this explains all the behaviour you highlighted. So, the reason why 'obj2.test()' prints 5, is because **after** you assign to 'obj2.test', the 'bound method' 'obj.test' is stored in the **instance** dictionary of 'obj2'. So, by the above process, doing 'obj2.test()' then doesn't do any binding of the method - it returns the already bound method from the instance dictionary, and executes it. To get your 'anotherTest' example to work as expected, so: &gt;&gt;&gt; SomeClass.anotherTest = test2 Hope that helps! See http://docs.python.org/reference/datamodel.html for more about descriptors. The full lookup process for attributes is very complicated, so I tried to distill just the details you needed here. BTW, you should make your classes inherit from 'object', otherwise you will get 'old style classes', which further complicates and confuses things. The above description is true for 'new style classes', I'm not quite sure how old style classes work.
I'm mostly an artist; I just dabble in code. My code projects directory is a horrible mess but my art directory is pretty neatly organized, with a decade of stuff I can find pretty quickly. The method that works for me is to have a directory for every year. One-off pieces of art just live in the directory for the year I started them in; bigger projects (comics! websites!) have a subdirectory in the year they began. I do NOT move things around if I keep working on them into the new year. I do, however, have symlinks to the large projects that are still active. Once the list of years went past what would fit in the default size of a Finder window, I added a symlink to this year's directory, as well. All these symlinks have spaces at the front of their name to sort them to the top. Anything text-oriented (websites, the book for a Tarot deck I just finished, etc) gets checked into Mercurial for tight control of version rollbacks when necessary. Each of these things has its own repo; they're spread out across the filesystem. I also have a directory elsewhere on my system with the final web-res images of my standalone art; I'll use this to quickly shuffle through and figure out what year and month to look for to find the source file. Which usually has a very different filename. I let Time Machine handle backup and versioning of my art files; version control really kinda sucks major ass for anything that's not text IMHO.
Planning to start coding in a forward compatible way... PyCharm IDE upcoming 1.2 promises to help with that: [version-compatibility-inspection](http://blogs.jetbrains.com/pycharm/2011/02/pycharm-1-2-eap-build-105-13-python-version-compatibility-inspection/)
No, methods are bound as part of the attribute lookup process. See my explanation below. 
Yeah, I think that is really cool to add to PyCharm. I can't wait to try it out.
Make sure you let all those package maintainers know. That way they can cater to your needs.
I am learning Python now with Python 3. All the major players have plans at some level to go to P3. These comments though are getting annoying. Guido laid out a 5 year plan of adoption and we are only half way there.
I don't see how I'd use a patched version of fabric where the author of the patches didn't even bother to make a proper fork to submit to the upstream. Also, the changes aren't documented.
Wow, reddit never ceases to amaze! :) Thanks for a great answer, you just saved me 2 hours of reading right there!
My pleasure. I love this stuff about Python - in the end, it's all just functions and dictionaries and lists, with some attribute lookup rules. Once you understand this, 'self' stops being magical (it's just another argument), and having explicit self seems like a very good design decision - it keeps things simple.
But are we living on a prayer? Sorry :)
Cogito ergo sum. Knowing others is wisdom. Knowing the self is enlightenment. Mastering others requires force. Mastering the self requires strength. I'd try asking in r/philosophy, though.
Had to uninstall cause pygame wont work with 64 bit. Was told to just use 2.6 unless I had a significant reason to use 3.x
At least try to write your code to be forward-compatible, or else your code could end up being on the packages that you or someone else is waiting on.
lol
I'll move when Ubuntu changes the default to 3.X.
Pretty much the same thing as a curried function. You can use *functools.partial* for a more general version.
I'm sorry you have bad eyes?
To avoid it until they add the print statement back in
That will never happen. Ever.
Once BeautifulSoup supports pluggable parsers and truly works on 3.x—I understand people liking lxml, but I'm still a huge fan of BeautifulSoup—I'll seriously consider upgrading. As long as I have that and Django (which Alex Gaynor is planning on porting this summer), then I'll move on to Python 3.
Can't tell if you're being sarcastic. Suffice it to say, I'm happy to keep using Python 2.x indefinitely, until such a time as a) there are no more barriers to upgrading, or b) Python 2.x is no longer being maintained even from the perspective of security updates, or c) I find something else that suits my needs. To this date, I've never heard a compelling argument for why Python 3 is anything but a minor improvement in some niche aspects in exchange for a major upgrade headache. Not to mention that 3.0 was noticeably slower than 2.5, and in my domain, speed actually matters.
If you asked yourself what comments are for then "As an aid to future searches" is one more reason to add to the list. Sites like stackoverflow separate out and have special handling for tags for example.
"reasonably well written code". Its a laudable goal, but I reserve the right to have non-reasonably commented code in my 'repository' for dead-ends; what-ifs; deliberate examples of badly commented code and other peregrinations :-) You are right. Mostly it is there already, but it can get better if you remember that you may need search tags in the future. - Paddy. 
I think 3.0 was known to be slow and wasn't necessarily meant for widespread adoption. I'm pretty sure 3.2 is much improved in that regard. [3.1 in particular added some big optimizations](http://docs.python.org/dev/whatsnew/3.1.html#optimizations). 
In C, the parentheses are required. In Python they're allowed but ugly. Don't use them.
We ported our mixed Python and C++ code base from Python 2.6 to Python 3.1 without difficulty. This week we're running internal training in programming in Python 3.
When CPython has a JIT, I will make the switch. 
Why are they ugly? it makes the code easier to read, if you ask me
I haven't tried it, but here is an idea: use virtualenv5 (http://virtualenv.openplans.org/#making-environments-relocatable) and create a relocateable python virtualenv
 *this
Well that sucks then, I like using python because its the most elegant and enjoyable language to program in. Every step they take away from that is an error in my opinion. Guess I'll be on 2.x for a while then
I'll use it when it's available (CentOS has 2.6) and I don't need any 2.x site-packages.
Python 2.X for life. 
Stuck making shit python 2.4 compatible because centos blows.
from google import search search("Portable Python")
I would just go with Django. If you enjoy Python, you'll inevitably have to work on a Django site in the future, so the experience may pay off.
This seems to work and takes the least effort. Thanks.
If you loved the language and wanted to support it, you'd invest some of your own time into upgrading the libraries you use, instead of hoping somebody else will do it for you. If everyone did this, there's no reason why Python 3 wouldn't be the de-facto version this time next year.
Fabric is awesome. Just came here to say that. sudo fab -R linux -- 'df -h /home'
Like many others, I'm waiting for the larger projects to move over. Specifically nose, fabric, mock, and django.
Looks like nose supports python3 : http://somethingaboutorange.com/mrl/projects/nose/1.0.0/#python3
Swan dive?
Actually I've been thinking about this print() is not so bad, if they would only return the % operator.
One word: virtualenv.
This is the most confusing article I have read in a while. Can someone please post a complete example?
Into the best code of your life!
this is something that every Python programmer should know. explained really, really, badly.
Separate your elementary and advanced concepts, expand on the advanced ones with CPython implementation details, double the length once a week and consider yourself a famous python blogger. Please?
I like http://code.google.com/p/yapgvb/ ;-)
Graphs generated with Graphviz look soooooo ugly. Graphviz is for graphs what [epydoc](http://epydoc.sourceforge.net) is for Python documentation. Developers find it cool because it is automatic. For documentation I take seriously I use [yEd](http://www.yworks.com/en/products_yed_about.html).
Depends. In my Arch box it's actually the default interpreter, but python2 is right there next to it, so in need of quick hack I will probably still use 2.x. At my work I'm stuck with 2.6 and there is no good reason to update and test everything -- it works, is IO bound on one part etc. Other than that I'm moving away from Python to Clojure.
I'll switch as soon as GAE does.
&gt; When an attribute is looked up on an object, first Python looks in the instance's data dictionary (obj.__dict__) for an object of that name. A technicality here: in fact Python always first looks in the class hierarchy. If the attribute is found there and is a _data descriptor_ (defines `__set__`, functions don't) then it is used unconditionally. By the way you can do strange things like define `__set__` but not `__get__`, then the class attribute is returned itself but still shadows instance attributes. Then if the class attribute does not exist or doesn't define `__set__`, Python looks in the instance dictionary, returns the value it found there, or returns the value it found in the class dictionary, or tries to find `__getattr__`/ `__setattr__`/`__delattr__`, or throws AttributeError. Oh, by the way, all of the above applies only to ordinary attribute accesses, most special methods (like `__len__` too) are never looked up in the instance dictionary at all, both for performance reasons and to avoid all kinds of weird chicken and egg problems -- what happens if you do "`x.__dict__['__dict__'] = None`"?
I checked out Python 3.2 last week on an old Windows XP box and it failed with the venerable `UnicodeDecodeError` at the the first `print()` on a string which contained a Kanji symbol I've chosen for testing purposes . A newer Win7 computer printed gibberish but at least didn't crash the script on a mere `print()`. What that means is that the Python 3 core, not just dedicated packages, is essentially platform dependent. 
First thing I noticed in the first paragraph: &gt; Note: this option is somewhat experimental, and there are probably caveats that have not yet been identified. Also this does not currently work on Windows.
You mean this? "%s %s" % ("hurf", "durf") If so, it's not gone and it's probably never leaving.
And with that attitude, everyone would still be using the 1.x branch. Breakage in major releases is fine if it improves the language.
Just wanted to come back here and say thanks. I'm on page 9 now :)
Have you looked at the Google maps API? * http://code.google.com/apis/maps/documentation/geocoding/ It'll allow you to convert freeform address strings into an exact location so you can at least confirm the address parses into a location according to Google. Then I think the docs there suggest the response will come back with parsed information on the location, so that's a step closer to mapping that to timezone.
I second yEd for so many reasons that I'm too lazy to list.
OmniGraffle (Mac)
Hey, [Bottle](http://bottle.paws.de/) is mentioned in the release notes :)
Oh right .. I read everything before 3.0 came out that they planned to remove it... never mind then.. 
[Django and the Django logo are registered trademarks of Django Software Foundation.](http://www.djangoproject.com/community/logos/#trademark) I wonder if D.S.F. is going to have to address this in defense of trademark. 
Maybe they are using it under license.
Maybe. I haven't been able to find any further info about it.
That may have been in the plans, but it came up yesterday on the python-dev mailing list and it seems doubtful if it'll come out any time in the 3.x series, if ever. I doubt the functionality will evolve with the `{}` getting focus, but you'll still have `%` for the foreseeable future.
I'd understand the multiple library structure if he had a collection of commits on a branch or something but... [damn](https://github.com/tav/pylibs/commit/ae3a6ac47f38fe08b630d8de8596a2020d62581c), guess the guy has never heard of documenting his commits?
They always nicknamed releases after Jazz composers. Also they changed the nickname for the release to ”Reinhardt“.
It would appear they changed it to Reinhardt. Probably a good call. &gt; The long-awaited fourteenth release of WordPress is now available. WordPress 3.1 “Reinhardt” is named in honor of the jazz guitarist Django Reinhardt. Version 3.1 is available for download, or you can update from within your dashboard.
| WordPress 3.1 “Reinhardt” is named in honor of the jazz guitarist Django Reinhardt. Misleading title much?
woops. 
It's codenamed "Reinhardt" not "Django." Misleading much?
You're right, although I deliberately missed out a lot of those details for simplicity. There is also `__getattribute__` to add to the mix!
It just got changed within the last few minutes.
It was changed to "Reinhardt" this morning.
I talked to one of the board members, and he seemed to mostly want to resolve it otherwise as one OSS project going after another is bad blood.
Since they just changed it, it looks like this is going to be an "Ooops, our bad." with a side of "No harm, no foul." Civility is a wonderful thing. 
Yeah, also if understand correctly, the caching mechanism, which stores some of these double-underscore methods directly in the each class's structure and propagates new value to all subclasses on assignment. Or something like that. Which again is kinda important for avoiding chicken and egg problem. Also the whole metaclass thing, with `type` being its own metaclass. Python's apparent simplicity is one of the most deceptive things ever! :D
"Reinhardt". Yep, they changed after pressure from the Django Software Foundation (and before I posted this).
Apparently the Django team [have politely requested](https://twitter.com/jacobian/status/40440612679458816) that Wordpress change the name of their 3.1 release, and the codename has changed from "Django" to "Reinhardt", the title codename been changed in the linked release blog entry too. EDIT: Nice exchange about it [on HN too](http://news.ycombinator.com/item?id=2254466)
“Reinhardt”. :) And it was not pressure, it was Jacob nicely asking. And Matt was kind enough to change it. No harm done anywhere. Move along now.
I avoid diagrams ;)
Generally I don't worry about it too much these days (I have obsessed about this subject a lot in the past), but more or less: - Stuff that has clear categories, goes into a categorized sub-directory structure, whatever makes sense at the time, and with occasional moves/renames to keep things tidy. - Stuff that doesn't have a clear category, or is cross-category, goes somewhere under a misc directory (have a couple of different "misc" directories, in various parts of my source code trees). - Generally I use the linux "find' (and grep/less) command to look for source code, if I know the project name. - When there's a lot of older projects and random bits piling up, my spring-cleaning is to move everything besides current projects, under an "old" folder (and "old" often has sub-folders based on date when I moved things in). Generally I forget about those projects, and don't care much about their organization in the future, unless I feel like digging/borrowing code. Basically a massive attic/garage. - When I do find myself hunting for old code to re-use, after finding the code, I update a set of text files listing directories/source code files containing examples of code which do X, so I can find it quickly again next time (I find this a lot easier than trying to maintain an updated central location of snippets, or making massive god-like libraries for reuse between between all my projects. Been there, done that). - If it's important to keep track of random misc projects/be able to find them quickly later, you can keep a text file (or personal wiki) which summarizes your projects, eg name, short summary and directory. Split that up into year sub-sections (when you started the project), and add entries to the top of the file. Later you can skim through that doc to help track down your misc projects (even if the directory got moved, it should still have a similar name to before, and then you can update your index text file later. If it bothers you, you can make some Python scripts which help you keep that list up to date). - Most projects have their own separate git history in their sub-directories (if they get to the point where I may need to start backtracking to older versions), set to ignore various things. - Random: If you want to combine project's git history later (you decide to change your git layout after starting separate git repos), then you can take a look at this tool: https://github.com/apenwarr/git-subtree - Make sure you have a somewhat automated/easy-to-run backup system, that copies your entire harddrive over to an external (eg: with rsync, with syntax to keep locally-deleted/edited/etc files on the backup media, in time-stamped "old file versions" directories until you manually remove them later). PS: This is my first post on Reddit, since this is a topic close to my heart :P. But I have been lurking around the programming and linux-related sub-reddits for a couple of months. *goes back into lurk mode* 
It is in the repo. I just was going through PyPM online to see what was in there.
Maybe you guys should have read the link. It's not actually codenamed "Django".
Wordpress 3.1 is codenamed "Reinhardt" not "Django". Read the link.
It *was*, when first announced. 
I'm upvoting you not because I agree but because I want to thank you for taking the time to write python 2 code. Personally, I think it's ok if people leave their packages at 2.x as long as the rest of us make sure a python3 version is built in their place. It's not ok to demand work for free from people "just because it's a better language".
Pencil and paper.
i have my own personal wrapper for httplib2 that is very similar. kudos
In my case, it's proprietary code I'm writing for my employer, so no one is depending on a library I'm writing or anything like that, but when it comes to stuff that's more widely used, I can see more of an argument for contributing by making sure stuff is up to date. For me, as someone who writes some code at home because he wants to, and a whole lot more at work because he has to, the python 3 transition is nothing but headaches.
I preferred the multiple choice questions over the write in ones, as it was easier to infer what you were talking about. Often it seemed there wasn't quite enough context to answer the fill in the blank. Of course, I'm no python master, just a regular guy who uses it most days.
Agreed. The majority of Python documentation I read doesn't have diagrams. I think diagrams should only be used in the most extreme cases.
Is the speed of the http-server every the performance limiting factor?
"As you can see Go implementations of Web application wins in almost all test cases." Isn't this a bit unfair?
Tags are great for a general-purpose document database. You don't know the sort of content your documents will have beforehand so you attach some metadata in the form of tags. That way you can try to make sure you have sensible search results in the future. But with code we how it will be structured beforehand. There will be module/class/function/variables names and if those are not enough docstrings should contain a lot of useful "keywords". If those things are missing or are insufficient to produce search results those files wouldn't be worth reading anyway ;) 
Xfig
His idea to remap the default key binding (C-x, C-o) to (C-space) might be enough to get me to remember to use this more often.
Unrealistic scenario makes a poor conclusion for sure. But then again, aren't all webapps out there echoing numbers? As a side note, I notice there is a try/except in the web.py app but not on the Tornado's one. I think to remember that try/except are notably slow, aren't they? That would clearly not explain the difference obviously, just curious.
Do you *know* or do you *guess*? It's not as far as I know (and I *know*).
Go is an interesting language, but it's lacking a lot of libraries before I will consider it a useful language.
I haven't said I knew. I said I thought to remember, apparently from your tone, I remembered wrongly. Obviously I would be pleased if you could share where this is explained.
Long story short: You can abuse `__get__` to monkey patch bound methods into objects: &gt;&gt;&gt; class MyClass(object): ... pass ... &gt;&gt;&gt; obj = MyClass() &gt;&gt;&gt; def my_func(self): ... print self.__class__ ... &gt;&gt;&gt; obj.my_func = my_func.__get__(obj, MyClass) &gt;&gt;&gt; obj.my_func &lt;bound method MyClass.my_func of &lt;__main__.MyClass object at 0x...&gt; &gt;&gt;&gt; obj.my_func() &lt;class '__main__.MyClass'&gt; &gt;&gt;&gt; MyClass.my_func Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; AttributeError: type object 'MyClass' has no attribute 'my_func' &gt;&gt;&gt; This is probably a terrible idea, though. To make it worse, here's a quick helper function: def bind(func, obj): """Binds a function to an object.""" return func.__get__(obj, obj.__class__) You can abuse it like so: &gt;&gt;&gt; my_obj.my_func = bind(my_func, my_obj) I'll spend the rest of my lifetime hiding from Guido now, I think.
No. That means your STDIO doesn't have a character encoding set in Python. Also, if you entered the string manually, your shell may lack proper Unicode support, too.
IIRC try/excepts in Python are only slow when an exception is actually thrown.
It's being deprecated, I think, but removal won't happen soon, it seems. That said, I prefer `str.format`.
To be clear, `print` is a function in Py3k. It's not _gone_. The benefit is that it takes keyword arguments now, meaning you don't have to rely on the magical comma to use spaces instead of linebreaks. The drawback is that you need to add a pair of parentheses.
A caucasian board and a coloured marker.
Why was CherryPy used with web.py rather than run on its own?
No, but it seems to be some sort of modern cultural right of passage to do one of these benchmarks. It's like an "I'm a modern programming geek blogger" badge of pride, or something. For bonus points this guy's hosting it on Github (the "I'm obsessed with novelty syntactic hacks in my language of choice and feign software engineering professionalism by forking others' pointless web frameworks and making 1 line changes" badge). It makes a great way to figure out which domains not to click on in future. Sorry, I'm turning into a right grumpy old bastard
I ran a quick test, and it looks like 7x slower if an error is raised and caught: no try/except: 0.326646089554 w/o error: 0.338667869568 w/ error: 2.29993700981 Test source: from timeit import timeit def h(): return ValueError() def g(): try: return ValueError() except ValueError: return None def j(): try: raise ValueError except ValueError: return None print "no try/except:", timeit(h) print " w/o error:", timeit(g) print " w/ error:", timeit(j) 
To be fair, shouldn't you compare to an `if`? The alternative to `try`/`except` isn't doing nothing, it's `if`-testing what you do.
A bored caucasian and a coloured marker?
Why did he only test with 4 concurrent processes/threads?!?... seems sort of demented... and by sort of, I mean completely.
I'd like to see tests with high numbers of concurrent threads/processes... also a comparison with some of the other python servers would be nice. Eventlet, gevent, etc... Though my guess is he did test with high concurrency, and was just disappointed that the results didn't confirm his bias. *edit:threads/processes, not connections
I ran the same benchmark (same code, I used ab), using CPython (2.6.5) and PyPy (fresh from trunk). Here were my results (first one is PyPy, second is CPython, both truncated to show relevant values): alex@alex-laptop:/tmp$ ab -c200 -n50000 http://localhost:8000/Hello/100 Concurrency Level: 200 Time taken for tests: 20.114 seconds Complete requests: 50000 Failed requests: 0 Write errors: 0 Total transferred: 57350000 bytes HTML transferred: 49500000 bytes Requests per second: 2485.80 [#/sec] (mean) Time per request: 80.457 [ms] (mean) Time per request: 0.402 [ms] (mean, across all concurrent requests) Transfer rate: 2784.38 [Kbytes/sec] received alex@alex-laptop:/tmp$ ab -c200 -n50000 http://localhost:8001/Hello/100 Concurrency Level: 200 Time taken for tests: 42.483 seconds Complete requests: 50000 Failed requests: 0 Write errors: 0 Total transferred: 57350000 bytes HTML transferred: 49500000 bytes Requests per second: 1176.94 [#/sec] (mean) Time per request: 169.932 [ms] (mean) Time per request: 0.850 [ms] (mean, across all concurrent requests) Transfer rate: 1318.31 [Kbytes/sec] received Edit: This is running the tornado code.
As a proxy, go's benchmark come nowhere near as far as I can see.
Good point. I modified the 'h' function to: def h(): if isinstance(ValueError(), ValueError): return True else: return False That bumped the first time up to 0.58. I guess the conclusion is that try/except is faster if your error case occurs at most 1 out of 4 times, which seems pretty reasonable, errors aren't supposed to be the common case.
Seems like not having diagrams is very unpopular. Yet there are very few Python documentations out there with diagrams. What gives?
Please don't say "no" when it's not clear what you intend to negate. It is not in Pythons responsibility to display the unicode character. It only hands it over to some device which can display it correctly or not. So why does Python raise an exception? When Win XP is asked to print a hiragana character using the following batch script: echo め it will display some gibberish. Nothing exceptional has happened. The OS doesn't issue an error, not even a warning. It will use some default encoding. No reason for the script to get stuck at that point. Python gets stuck because the shell can't display a character, something the shell doesn't care about. This is not a bug in Python, it is a design mistake. It has been there all the time but with Python 3 and unicode-by-default it is now straight in the users face. 
virtualenv does not solve at all for compatibility between python versions. It may help, but that's like saying that an assembler helps you building an OS.
Breakage is fine only if the improvements outweight the advantages for the user. Whether this is true depends on many parameters and personal appreciation. For example, everybody would agree it would be nuts to have python 3 breaking as it does today just to get a print function. OTOH, everybody would agree python3 worth it if it were 10 times faster, no GIL and would automatically convert python 2 code transparantly. Since it is neither on thoses extremes, different people draw different conclusions based on their own context.
Just because python lib documentation doesn't tend to require diagrams it doesn't mean the people who use Python don't use diagrams. Deployment documentation relies heavily on diagrams for instance. Interoperability between different systems can often best be conveyed with a diagram for example. [David Beazley's document describing GIL](http://www.dabeaz.com/python/UnderstandingGIL.pdf) from last year's PyCon does a good job with diagrams. If all you have is a hammer, everything looks like a nail.
web.py uses CherryPy's WSGI server as development web server.
Right, that is why I'm confused he didn't just use CherryPy. I must have a different perspective on what people actually use.
thanks for posting to r/python :) +frontpaged
I would benchmark a real-world setup. Python HTTP servers are usually best behind a proxy server like nginx or lighttpd. So compare CPU usage/memory usage/response time of tornado, paster, Apache (various plugins), CherryPy, nginx (with uWSGI) behind a proxy while varying request concurrency. A real benchmark is a lot of work to set up.
Pydoc picks up on double-underscore names in your module/package code, such as `__version__` and `__author__`. But only one of the examples in the article, OpenSSL, uses the `__version__` convention (`sys.version` notwithstanding). 
Thank you for mentioning yEd!! It looks very useful.
Nothing stopping you from installing Python2.6 or 2.7 on a CentOS machine though (provided you have the right permissions). This is what I do at work, I just ignore the ancient system Python.
It's also moving too quickly right now, pick any random Go repository on github and it probably won't compile with the current release. Speaking of releases, there is no stable release, only trunk.
For Go, it makes sense, given my understanding of how goroutines work. There was also no change in performance going from 2 to 4 cores for any of the Python frameworks, so I don't see why going to 16 would help.
The slowness you're seeing is not from the `isinstance` check, per-se, but rather from the 3 `LOAD_GLOBALs` you've introduced into your code.
`str.format` is definitely the best. [Just look at all the cool stuff you can do with it.](http://docs.python.org/library/string.html#format-examples)
You could treat this as testing one server in a load balanced set. One would not, as far as I can tell, just stick a Go, or most any other web server for that matter, out on the net. 
I'll do feedback on the UI. I don't like the look of the box. It feels too "noisy", and helps give me a headache. Luckily most of it isn't visible when the quiz starts. Softer colors would be good.
Please don't argue when you're ignorant of the underlying mechanics. Strings in python 3 are unicode objects. In order to output them, they need to be converted into bytestrings. That means they need to be encoded. If a unicode codepoint cannot be encoded in the target encoding, Python will raise an exception because that's the right thing to do. Think about the alternatives: how do you output higher codepoints to ASCII? you could drop them or replace them, both of which is possible when calling the encoding function -- if you leave it to Python, it refuses the temptation to guess. If the shell supports, say, UTF-8 and Python's print statement nevertheless thinks it has to convert all output to ASCII, that's a problem indeed. Either the shell doesn't communicate its encoding properly or Python doesn't recognize it. In either case, you can fix it by modifying STDOUT. You could argue that Python should drop the incompatible codepoints or replace them with questionmarks or just pretend the shell always understands UTF-8 (or UTF-16 or ...), but that's not the Python way. If end users see unicode decoding errors, it's the programmer that is at fault. As for your bash script -- that's inane. Bash doesn't have a concept of unicode. It just juggles bytes around. It doesn't have to do more than that because it _is_ the shell and its main concern is matching filenames. IIRC Java is similar in that it only knows UTF-16 (or whatever it uses).
What's the benefit outside of using Activestate's packaged bundle?
Why use `print` so much? There must be a better way to send the body of the response in cherrypy. Using `print` reminds me of CGI. Why make the class `OpIDHelper` have only `classmethod`s? Why not just put that functionality in a new module and import it instead of using a class to simulate the same thing? broken closing tag: print "No Openid services found for &lt;code&gt;%s&lt;/code" % openid_url 
ActivePython is the equivalent of an enterprice linux distribution. You get well packaged open source stuff for free and can pay for technical support and guaranteed intellectual property indemnification.
A very nice API. Would be nice for someone to write up a comparison between pattern and NLTK (http://nltk.org).
what do you mean? python libraries are all installed in the version-specific lib folder, so easy_install will upgrade/install libraries to whatever version of python easy_install is set to run with. if you have python2.6 and use easy_install to install something, and then upgrade to python2.7 (and subsequently update easy_install), of course easy_install wont upgrade your python2.6 libraries, you'll need to reinstall them. but once you have the python2.7 libraries installed, if one of them is updated, easy_install will happily upgrade /usr/local/lib/python2.7/site-packages/whatever 
Omg, a compiled language ran faster than python! Mind=blown &lt;/sarcasm&gt;
I use NLTK pretty heavily right now. I'll be looking at this package in the near future probably as a comparison. A couple things worth pointing out though: * It uses NLTK * No setup.py, so involving it in deployments means you'll have to do that yourself. * Is it open source? I didn't see a link to a repo or anything. I'm interested, but it smells heavily of being an academic project. I just always worry about those being abandoned. Cautiously optimistic currently. Maybe after I get a chance to play with it, I'll blog about it.
Is there a natural language processing system which can be used for other languages (especially german)? Thanks a lot.
&gt;Is it open source? I didn't see a link to a repo or anything. The linked page says it's licensed under BSD.
&gt; Is it open source? I didn't see a link to a repo or anything. BSD licensed, so yes, but I also do not see a public repository (yet?).
Right, I get that, but if I use it I'd like to be able to contribute back. I should have worded that better I suppose. I get that it's open source, but I'm more concerned about this being a "release and forget" academic project that I can't contribute back to. 
Convert my code with 2to3, and we'll make it I swear!
It's not even true. It only wins with CPython. Look down for PyPy comparisons
&gt; If end users see unicode decoding errors, it's the programmer that is at fault. The programmer might not see them either. As I pointed out, the behaviour is not OS invariant. &gt; If a unicode codepoint cannot be encoded in the target encoding, Python will raise an exception because that's the right thing to do. That's where I disagree. Issuing a warning is good enough and still nothing is "passed silently". There is also no guessing involved when a default value is specified in cases a codepoint can't be encoded. &gt; Bash doesn't have a concept of unicode. It just juggles bytes around. It doesn't have to do more than that because it is the shell and its main concern is matching filenames. Running a Python script from a shell is not totally inconvenient and when it dumps a file name which contains unicode characters it can't encode, I don't want to see it terminate. 
The openid implementation I used as reference was a CGI script, so that partially explains the abundance of prints while I was also trying to avoid using templates or external views so I could keep all dependencies in one file. Also, almost all of the print statements are there for debugging/informational insight to try and expose more of what OpenID is doing behind the scenes. As for OpIDHelper, I tried extending some of the openid classes to add that functionality but it seemed somewhat odd or out of place. 
if your OS python is an older version than the later version you have additionally installed, easy_install (or pip for that matter) won't touch your OS python libraries. if your OS python is the same version as the version easy_install is using, and upgrading a library results in the library being broken, it wouldn't matter whether you upgraded that library with easy_install or manually, you would still experience the same end-result. 
I just committed the source to Google Code. There are other things I need to do (like setup.py) but the buzz is beating me to it. I intend to use the software myself for mining so there will be a steady flow of updates for at least two years. Best, T
Awesome. Got a link handy, by chance? :) We're building something somewhat similar to what you have here, so I could see us possibly leveraging and contributing back if everything works out. 
thats evil and that kind of code is bad for jit's
os.system is considered bad, also there are python libs to do the downloads a lot more direct
nltk has different [corpa](http://nltk.googlecode.com/svn/trunk/doc/api/nltk.corpus.europarl_raw-module.html) for euro languages. 
My naive solution would look like this: intlens, declens = zip(*[(len(i), len(d)) for i,d in [str(f).split('.') for f in yourlist]]) max(intlens) max(declens) Starting with your list, split each decimal number on the decimal. For each of these, record the str len. zip this list to get a list of all integer part lengths and a list of all decimal part lengths. Edit: Avoiding an unnecessary list traversal: zip(*[(len(str(f).split('.')[0]), len(str(f).split('.')[1])) for f in yourlist]) The one-liner: intl, decl = [max(li) for li in zip(*[(len(str(f).split('.')[0]), len(str(f).split('.')[1])) for f in yourlist])] with `intl` being the maxinum number of decimals you'll need for the integer part, `decl` for the decimals
I'm not sure of any built-in method of doing this. I saw something on stackoverflow once, and have been using a modified version ever since: import re ut0 = re.compile(r'(\d)0+$') NEW_LIST = [ut0.sub(r'\1', "%12f" % x) for x in OLD_LIST] you can then do something like print '\n'.join(NEW_LIST) or for number in NEW_LIST: print number That will create one column, though, and your "example" shows four. It's a start. Good luck, and let us know what solution you come up with.
Over here: http://code.google.com/p/pattern-for-python/ Let me know if you have any feedback or remarks.
Thanks, I'll be keeping an eye on the project. It looks really cool.
I ran several of these on a fresh large ami instance and was not getting numbers as purported.
Nice. Do you have a generalized version of this, say, to align text by some arbitrary character? input: var=something town=sente youget=theidea output: var=something town=sente youget=theidea 
This is based on python 2.7 so you may have to use the print() function for 3 (don't remember). nums = [123.456, 1.2, 23.45, 1444.23] cols = 2 for num in xrange(len(nums)): w,f = str(nums[num]).split('.') print "%10s.%s\t" % (w,f), if (num+1)%cols == 0: print My only gripe with this solution is that it relies on tab to align each column correctly (remove it to see what I mean). This means that the first amount of whitespace isn't consistent with the whitespace between the columns. edit: oh right, change the cols variable to adjust the number of columns.
Please explain, I don't understand.
will purchase
I use .format instead of % for alignment stuff without tabs. print "{0:20}.{1} ".format(w,f)
&gt; I'd like to see tests with high numbers of concurrent threads/processes Add good threading (aka goroutines) and Go will totally kick Python's ass. Go was designed for servers, which means efficiently supporting lots of cores.
&gt; Speaking of releases, there is no stable release, only trunk. Not quite true. There are Mercurial release tags. Compile using those.
hehe nailed. in other news i have the maturity of a 9 year old.
There's a new tag every 1-2 weeks, and people writing libraries aren't usually noting which releases they work with. It's still moving really fast.
Issuing a warning? We're talking about invalid data being passed. It _should_ raise an exception. What we can disagree about is whether `print` should catch it itself. As I said, the biggest problem is that there's no graceful way to handle a unicode decoding error automatically. I already said there are at least three ways to handle it (replace, strip or just send UTF-8), none of which is really satisfactory. Actually, what would you suggest it _should_ do when the shell doesn't support all of Unicode? Most single-byte encodings conflict for every character outside the ASCII range, some don't even have that much in common; so it's not as easy as just dumping all the characters that can't be encoded as UTF-8 instead. Even worse: the receiving end (whatever STDOUT is pointed at) may expect pure ASCII and react badly when it is presented with something in the higher ranges. It's not as easy as checking what STDOUT is pointing at either. The output of the script may be piped to another application. Dropping characters, replacing them with questionmarks or mangling them may create in problems further down the line outside the script itself. In other words: just because the resulting mess wouldn't be a problem in your use cases doesn't mean it won't ruin someone else's day eventually. Python is generally held in high regard for being predictable and unsurprising (even its critics agree on that). Guessing in this case would be a clear violation of that principle. If you have unicode characters outside the ASCII range that you want to print to a shell that doesn't support a full unicode encoding, either override STDOUT or clean up your strings before printing them. Of course it is not OS invariant -- it's not even locale invariant.
Yes, definitely an issue. And they still don't have support for true generic (interface{} doesn't count). :(
Excellent!
Very good! I loved following PyMOTW. 
I wrote a similar system for my AI thesis back in '98. This is much more advanced and finished, but it's cool to see the idea out there. http://zhar.net/projects/thesis/ 
It's about time!
This is great news. I've taught a few Python classes, and inevitably the question comes up: "How do I know what to import to do *x*?" I tell people to check out PyMOTW. It's a great resource, even after several years of experience with Python.
Hi, So the dollar signs represents a non user entering the command on the command line. The only thing that you really have to do is, install the package. Most package will include a setup script which will dump it into the appropriate dirs. The "python -c 'import googlemaps'" Is telling the interpreter to load the googlemaps package and enter the shell. Are you working in linux/mac/bsd or windows?
Please pay for your ads here. Thanks.
I'm working in windows. I think I've done something wrong cause there is an error when I try running the executable that came with the google maps package. "No Python installation found in directory" although I do have Python installed along with the IDLE.
gevent, eventlet, twisted... nginx, varnish ... were also "designed for servers" ... and will very likely "totally kick go's ass".
A virtual machine emulates another computer inside the running operating system. Virtualenv is for installing Python packages to segregated directories. One of the uses of virtualenv is testing packages with different versions without having to install and reinstall and muck up the Python installation.
Generalized? Let's try this: def align(a, d='.'): a = [str(x).split(d) for x in a] m,n = max([(len(x),len(y)) for (x,y) in a]) return [("{0:&gt;%d}%s{1:&lt;%d}"%(m,d,n)).format(x,y) for (x,y) in a] where a is your array of "words" and d is your "arbitrary character". The first line splits each "word" at the split character. The second line counts the max width needed for both sides of the "word". The third line reassembles the two parts with the necessary padding and returns the array. In [1]: foo = "var=something","town=sente","youget=theidea" In [2]: print "\n".join(align(foo,"=")) var=something town=sente youget=theidea The nice thing about doing it this way is you can make multiple columns, as per the OP's sample output. 
This guy is one hell of a man. ;-)
Writing `for num in xrange(len(nums)): nums[num]` is not Python. Write `for item in nums: item`. If you absolutely must know the index of the items (and this is rare), use `for index, item in enumerate(items):`.
`$` is the default command prompt in many Unix-like systems (Linux, OS X). Writing `$ ls` is basically the equivalent of `C:\&gt; dir` if you're familiar with the Windows command line.
Don't get me wrong, I like Python more than I like Go. It's just that when it comes to speed, Go beats the crap out of Python. Very fast native code, real multithreading, structs instead of dicts, etc. make for a much faster environment.
Hi, have a look at http://www.markus-gattol.name/ws/python.html#virtualenv_virtualenvwrapper which shows you what commands you need to issue on the command line too. Plus it explains everything very well imo.
I'm not sure if this is the issue, but I suspect that there is a some threading issue with `bonobo_factory` lazily loading the `ConfigParser` module. Try moving these lines outside of the `factory` function. import ConfigParser config = ConfigParser.ConfigParser()
Thanks. I'm back at work just now but will try this later.
I have updated the list.
Thanks, but it's already been posted [here](http://www.reddit.com/r/Python/comments/fs2r7/hey_guys_exciting_news_pymotw_is_coming_in_a_nice/).
i know it's beating a dead house but can't we all agree on either Git or Mercurial? This is getting annoying. Almost everyone picked SVN when it came out (or at least stuck with CVS like Mozilla). Now half are going GIT and the other half are a mix of HG, monotone, and bazarr. 
I don't think Git had a clear edge when the Python community settled on Mercurial but in the intervening time I believe it has 'won'.
Personally I prefer Git, and Git has essentially won the distributed SCM war, but I think Mercurial makes sense for Python. (While Bazaar is also written in Python, it's terrible by comparison, so I wouldn't say the same for it.) 
That was so awful it gets an upvote.
I think you give too much credit to monotone and bazaar. I think the big two are Mercurial and Git. However, it is too late for "one DVCS to rule them all", I think. Git is probably the dominant player over Hg but Hg users aren't going to move at this point. Who knows about the future.
Not useful for me, but could be for someone.
thanks! While I know of str.format() but for whatever reason I tend not to use it and I so add clutter with unnecessary prep work to get the same type of the results with a basic print. 
&gt; Does anyone have a suggestion on how to do it? Not with a list comprehension. When my list comprehensions get too complicated, I either use a generator or a good-ol' `for` loop.
And the code is under a [CC-BY-SA 2.5 license](http://creativecommons.org/licenses/by-sa/2.5/) per SO terms of use for posting.
I'm more impressed with the amount of documentation than anything else.
Not really related, but does anyone else find "Go" to be a really bad name for a programming language? Try googling for information about it, or doing a job search with the keyword "go." You'd think Google, of all companies, would have considered the SEO value of their programming language names. Otherwise I think it's interesting.
Isn't the last *if* clause redundant? It's obviously true for all n &gt; 2.
It's not redundant, the list is changed while operating on it.
The goal is to make it less comprehensible, not more...
hg has much better tools for Windows.
I don't think it's the nastiest ever. But certainly nasty enough to be a good example of terrible smart-ass code. Talking about smart-ass ;-) ... &gt;a = list(range(n)) shouldn't a = range(n) do the job? Also, in the original post (it has been changed, probably due to a hint), there was a probably unnecessary copying of the list (a[:][2:]) &gt; def mystery(n): &gt; a = list(range(n)) &gt; return [[i for a[::i] in [a[::i][::-1]]][0] for &gt; i in a[:][2:] if a[i] == i] 
benchmarks please.
Regarding the `list(range(n))`: It's for Python 3 compatibility. Regarding `[:]`, yeah, indeed redundant and was removed when someone pointed it out.
One I saw the other day: z = [l[a:b] for a,b in zip(l[0::max_size], l[max_size::max_size] + [None]) Here's one of my own: output_dict = dict((tuple(tup[key] for key in keys), dict((column_names[ind], val) for ind, val in enumerate(tup) if ind not in keys)) for tup in list_of_tuples)
Respect, also very terrible ;-) 
Ahh, I see. Thanks for clarification.
Here is one that I wrote to solve problem 42 on Project Euler: print len([x for x in map(lambda x: sum([ord(letter) - 64 for letter in x]), open("words.txt").read().replace("\"", "").split(",")) if x in [(.5) * i * (i + 1) for i in range(1, 100)]]) It is long, but for the most part you can follow along what it does. [Link to the "problem" this solves.](http://projecteuler.net/index.php?section=problems&amp;id=42) 
Have you ever checked out some of the submissions for the [The International Obfuscated C Code Contest](http://www.ioccc.org/)? If you haven't, you should. You'd love [some of them](http://www.de.ioccc.org/2004/anonymous.c)... Eventually.
That's a good hack. Instead of using 20 whole number, and 1 decimal, mix in a search for the largest needed sizes: &gt;&gt;&gt; l = [123456.78, 123456.7893, 123456.78, 123456.78, 1212123456.78, 123456.78, 123456.78, 123456.78] &gt;&gt;&gt; len(max([ str(int(whole)) for whole in l])) 6 &gt;&gt;&gt; max([ len(str(num)) - str(num).rindex('.') - 1 for num in l ]) 4 You can use that to find the max values for widths of the strings on either side of the period. 
Jesus. This is already bad and you want suggestions on making it worse? &gt; "Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it." --Brian Kernighan 
I tried really hard to understand this :( 
Who cares? It doesn't even work (assuming the goal was to return primes, which is frankly an open question because the post is mind numbingly confusing, much like the code).
Is it considered nasty because it doesn't work properly?
I'm fairly new to Python myself, but I don't see how you're not receiving error messages about the multiple import statements you have on the same line, with no semi-colon separating them. For instance, On line 5, you have this: "import gnomeapplet import gtk" Maybe the problem is that the second module is not getting imported because it's on the same line as the other import statement.
No, because it uses Python in extremely non-idiomatic ways.
there's no DSCM war
you are going to have some additional overhead developing in windows. #1 you need to have the python executable on the path, that would be enough to make the above work up until the last line. which I would assume would need to be pulled down from pypy via pip or easy_install first which is not a step in the OP's question #2 you are going to run into having to build c extensions in some packages when you are installing in a virtualenv, since windows sucks and doesn't have a compiler environment on the path, you have to set one up like mingw, then you have to tell setup tools to use it, and you may as well put that on the path as well. When I used to develop in windows I documented the steps and put it on my blog so I could refer other team members to it when they were setting up there environments. I've since moved on to *Nix environment because I can't deal with the windows hassle anymore, and I have one of those jobs that doesn't require that I use it(yay me) Anyway, If you want to review that information, it's here. http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-1installing-python.html http://blog.sadphaeton.com/2009/01/20/python-development-windows-part-2-installing-easyinstallcould-be-easier.html those 2 articles will get you a fairly decent environment on windows. 
That's cool, but i would be a little skittish about guessing the length of the decimal place. it's always better to know how accurate your stuff is and enforce that precision. Also, why not just do len(str(int(max(l))))? As far as I can tell, that would only mess up on negative numbers.
e.g., as Perl.
D-D-D-Dickhead.
I started with using len(str(int(max()))) but since the string version was more useful in finding the length of the decimal I decided that it was clearer to use the same method to do both. I'm not sure what you mean by guessing at the length of the decimal place. I'm not a numbers person, but in this case the purpose is for aligned display. I don't get how to determine a significant digit without knowing the relationship between the numbers - it seems like for display the important point is to not modify anything but the formatting.
I do a lot of Python XMPP work on a daily basis. SleekXMPP is the cleanest and most recently maintained, but is not completely mature. Pyxmpp is the probably the most stable and robust but it is rather large and cumbersome sometimes. Personally I avoid xmpppy and twisted xmpp. Grab the program "Psi", add a Jabber account and just start viewing the xmpp traffic in the XML console. You will learn a lot there. As you see stanzas come and go, look them up in the specs to see exactly what they mean. After a week or two of this, you should have most of the knowledge you need to get something useful up and running.
+1 for "read the raw protocol pass you by". I can't offer much help specifically with XMPP and Python, but a while ago I was in a similar position with IRC and C#. The way I picked up most of what I now know was by watching sessions go by in plain-text in the console. It's daunting at first, but a little understanding at a lower level can have profound effects when dealing with things at later layers of abstraction.
Yeah, there isn't one because it's already over. :-) Here's a list of all the (free) DSCM's I'm aware of, and their initial release date. * GNU arch (2001) * monotone (2002) * darcs (2003) * Bazaar (2005) * Git (2005) * Mercurial (2005) * fossil (2007) arch and darcs were more like experiments in DSCMs, not sparking any major followings. Until 2005, monotone was the sole practical DSCM, but its complexity kept it from really gaining popularity (in my opinion anyway). After the BitKeeper fiasco in 2005, both Git and Mercurial were started simultaneously with the intention of supporting kernel development, and triggered what I would call the "DSCM war," involving mostly Bazaar, Mercurial, and Git. Like the various "format wars," and for many of the same reasons, there was a period of uncertainty about which system would reach critical mass first and become the prominent DSCM. More important than each developer having to invest time learning multiple SCMs is that the SCMs can't really interact with each other very well. If everyone's using their own SCM, it becomes harder to work together. Also like the format wars, established projects started using one of the DSCMs, pumping up its appeal. The DSCMs themselves at the time maintained a list of major projects that had switched to them, advertising it proudly. Ubuntu and the GNU project threw their weight behind Bazaar. The Python community, Mozilla, and Sun jumped on with Mercurial. Linux, the Perl community, and the Ruby community got on board with Git -- and over the years most everyone else has gone on board with Git (the reason, I'd say, because it's the most powerful one). 
Thanks for the advice guys! @message, have you worked with anything having to do with Facebook?
don't know what that means, but http://www.python.org/community/jobs/ is a thing.
Wow...is that first one a really complicated way of cutting a list into slices of size max_size?
would help later on if you let us know your findings. I also would like to know how to transfer a file with xmpp.
In Python 3.2, `range` is nearly a drop in replacement for a list, since it can be sliced. I can't test it ATM, but I think you don't need to cast to `list` here.
psi is terrible, use Miranda IM instead. its much more stable (it doesnt crash if you disconnect from the internet for example. and then you will also be able to sign back in right away) 
most computer systems use binary to represent floating point numbers. this makes it difficult for software to be aware of how many decimal digits go into the fractional part of floating point number. Python is no exception (do str(0.4-0.1)). I tend to stay away from floating point numbers as much as I can (use fixed point if I have to), and I always hardcode the number of digits to show as the fractional part when displaying them. I think if you want to make some sort of generic table of numbers display, then sure, go ahead and determine the number of digits in the whole part, but take in the number of digits for the fraction as an input, don't try to determine it yourself.
You should point out more clearly that this is a fun competition for writing horrible smart-ass code! I really, really, really hope that this is your goal ;-))). Some people seem to take this seriously. Never ever write something like this in real world!
100 % agreed, but I think (hope ;-)) it's meant to be for entertainment, not for a real purpose. Some call code like this "smart-ass code".
Dude, you certainly don't have any neighbors who know programming and own axes.
I modified an xmpp client to connect to facebook chat at my last company if you have any questions. They have a blog post where it details whats different from normal XMPP and how to implement their custom auth.
That was just reddit mangling up my code. Someone helped me to locate the error. See here for code and solution. http://www.reddit.com/r/gnome/comments/fse1f/problem_creating_applet_hope_you_can_help/c1ibits Didn't expect something so simple to throw an exception, nor for an exception error to allow a single pixel applet to populate the taskbar. 
http://pastebin.com/GsKjfUmM Here is a bastebin if you would like to see for yourself. problem was that emabling the config.get line killed the applet but only when running as an applet, if run-in-window command line was enabled for debug mode, then all was ok. It seems the 2 modes had a different default path, so when run-in-window was used an exeption was not thrown, but when run as applet, path was different by default, exception thrown, result was a single pixel displayed on taskbar that could only be cleared by restarting xserver. 
Does Miranda IM let you watch XMPP traffic live?
Why don't you read an installation tutorial?
Hell yea! I would really appreciate this and any other resources you can point out. Like I said, I'm new to this and am willing to take any advise I can. Thanks again!
I did a quick search and found this:: http://xmpp.org/extensions/xep-0234.html Also, Jingle was designed by Google, so you know it's reliable! :)
thanks
Sure, no problem.
I learned IRC mostly from the RFC. Wireshark was useful too, but optional.
Since I actually change the list, I must have a list and not a `range` object.
You might want to use http://xmpp.org/extensions/xep-0065.html
Well, GTalk is also by google, and it’s crap (not even secure s2s connections).
Gtalk is pretty much standard xmpp. Facebook has some relevant docs: http://developers.facebook.com/docs/chat/ XMPP RFC's are also a great resource to understand what's happening beneath the wires: http://xmpp.org/rfcs/rfc3921.html
GTalk is a client, it's not responsible for s2s connections. Whether Google enables s2s on their servers is their choice, but it is neither a design nor software limitation.
That should be a second choice, as it goes through a proxy instead of a direct connection. See xep-0234 for the latter.
You can already access MSN on XMPP using transports, although they are no longer being developed. Basic functionality works though. You can't enable transports using the gtalk client, but once you do it with a client supporting service discovery, it works in gtalk as well. You go to service discovery and then enter the address of a public transport, usually of the form msn.example.com. Personally I prefer multi-protocol clients, or even just Meebo.
it's clear you know a lot about dscm's, but the notion that it was ever a war is still pretty silly. competition? sure. war? no. 
Calling these types of market-share competitions a "war" is common, so I'm just using a commonly used term. * [Editor wars](http://en.wikipedia.org/wiki/Editor_wars) * [Format war](http://en.wikipedia.org/wiki/Format_war) * [Browser wars](http://en.wikipedia.org/wiki/Browser_wars) 
yeah I know. I'm just refusing to call it a war. :) i assert the term is stupid in that context with the exception of the "browser wars"(though that is a stretch too), at least as far as IE vs Netscape is concerned, because Netscape as a company was clearly defeated at least short term and they had to dramatically change their business model as a result. the term "war" that gets tossed around for our development tools is blog fodder for fanboi's(fuck 'em). it's counter productive to advancing our craft. I get the impression that Git doesn't consider being [at war with Mercurial](http://python.mirocommunity.org/video/1634/pycon-2010-hg-and-git-cant-we-) But rather [cvs/subversion](http://www.youtube.com/watch?v=4XpnKHJAok8) are clearly identified as enemies. 
yes i believe it does, been awhile since i did that
The OP didn't ask about floats, the question was about decimal numbers. [float](http://docs.python.org/library/stdtypes.html#numeric-types-int-float-long-complex) vs [decimal](http://docs.python.org/library/decimal.html#module-decimal). Decimal doesn't suffer from the same ambiguities as floats, so I think inferring the number of places after the decimal point is valid. 
&gt; There is a brand-new doc effort underway in the repo itself. You can read it online at http://docs.cherrypy.org/dev/index.html , or check out the source code and help us improve it! Super good to hear. I love CherryPy but while some documentation existed it has always been ... awkward. Edit: had comma in link