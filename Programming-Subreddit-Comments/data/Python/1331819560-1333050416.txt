I wonder what Guido thinks of CoffeeScript as a way of sanitizing the development of JavaScript and if that should be the model for how to "put Python in the browser"
I appreciate your perspective, but part of the reason I write open source code is for the idea that it should be free forver :)
I think your post is amongst the most rational and useful on this thread. I think I'll change the license in this instance, but if anything my pro-GPL stance as a whole has been strengthened by this debate. Thanks a lot for your input!
My perspective is that I don't especially want the copyright, indeed I'm quite happy passing it along to a militant organisation that is supporting what I see as an excellent cause in favour of freedom. I don't feel that your example is really appropriate, either, given both xiongchiamiov's reply and the fact that the Gimp is GNU through and through, and doesn't exhibit the licensing behaviour you mention (I understand that I've taken your example too far, but this does explore its logical conclusion and I don't think it's unfair to highlight that in disagreeing with you!)
I've (slowly) come to a similar conclusion, and I think that I'll take a more case-by-case approach, whilst massively prefering the AGPLv3. In this particular case I think I will swap to MIT.
I'm glad! Yes, I saw that someone else noted that the FSF suggested a different license for this situation, so I wouldn't worry too much about it. Using the AGPL goes a long way towards you being a force for good, so thanks for being awesome. Cheers!
That's effing awesome. :)
Wow that's fast! Can you explain why one would prefer using `sdict.Dict` over the built-in? Looking at the [implementation of Dict in \_\_init\_\_.py][1], it seems one could achieve the same by sub-classing dict like this: class SortedDict(dict): def prefix(self, key): """Returns a sequence of keys matching the prefix.""" return [k for k in self if k.startswith(key)] def greater(self, key): """Returns a sequence of keys greater than or equal to the given key.""" return [k for k in self if k &gt;= key] def less(self, key): """Returns a sequence of keys less than or equal to the given key.""" return [k for k in self if k &lt;= key] [1]: http://code.google.com/p/sdict/source/browse/trunk/sdict/sdict/__init__.py
Way to get your panties in a knot. At this point I'm a scientist first and a software developer second. I'm generally *not* developing for end-users, and even when I kind of am, they are end-users that speak English because English is the lingua franca of science. The majority of the people in my lab are not native English speakers, and guess what? They write all of their documentation in English anyway, because that's what's going to be the most useful to their scientist peers. I've read Spolsky's article and understood it, but *you* should understand that in certain domains, especially where any form of UI is a distant second to the actual algorithmics of the problem, ASCII suffices.
Did this post just argue for a non-standard dependency in the browser? Browsers converging on the standardized webstack is the best thing that has happened to the web. Some new non-standard dependency isn't going to go anywhere anytime soon, and will only fragment the web if not adopted as a standard.
Is the point to write client-side scripting for web apps in python instead of JavaScript, or to have a standardized UI markup language that you can use to write front-ends for python apps? Or both?
&gt; My issue with it is that it is too far removed from the javascript, so you can't have a mental model of both the python you're writing and the javascript that it will become. Fair point, but it's as close to "Python in the browser" as you're likely to come. It works very well in my experience and makes it quite doable to write your own client-side framework. The widget set is based on GWT so it's very full-featured.
No, it's not. It's just saying that a browser with a built-in Python interpreter would be a great platform for developing on - not that it should become part of the Web with a capital 'W'. 
You are missing the point with pyjamas: You are not even supposed to THINK about the JS side. Just think python and pyjamas does the rest.
Mentioned elsewhere, but hey! [Pyjamas](http://pyjs.org). 
Ah, well I could see that as being quite valuable, and a great platform for delivering an application.
Well as long as it is isolated.
&gt; It's just saying that a browser with a built-in Python interpreter would be a great platform for developing on - not that it should become part of the Web with a capital 'W'. How about a Python with a built-in GUI toolkit instead? Oh, wait... I mean, it's kinda weird to say that if all browser vendors bloat their browser distributions by 12Mb and go through the trouble of integrating Python with it, then Python would become a zero-install solution, albeit only suitable for corporate intranets where they don't actually need proper security. "What the fuck" kind of weird, in fact. There are no non-weird parts in this proposition.
Id settle for using python to filter my exchange mail. Outlooks filters suck.
&gt; I really don't see the benefits, especiall when JavaScript is a powerful, elegant, and robust language and worth learning on its own merit even if you never do much client-side scripting. I did learn Javascript and I think it's great, but I still prefer Python. In just about every way (except one) that Javascript and Python are different, I prefer Python's way. And I think it would be worth it just to have a language without the quirks of Javascript that have been grandfathered in. I would also support a rewrite of Javascript that didn't have to maintain backward compatibility. I like to think Javascript could have been every bit as awesome as Python if it hadn't been an early victim of its own success.
Thats a bit like saying: which was your favorite injury? PDF generation is a pain. PDF parsing is a nightmare. Sorry I can't help, but good luck.
Django, and if you happen to be using Python 3, Django 1.5 will feature experimental support for (hopefully) up to Python 3.3. Of course, it's all a matter of personal opinion...
Then don't use a proprietary mail server and client. 
Here's a nice list of pdf parsers: http://css.dzone.com/articles/pdf-reading ...but PDF Miner is probably the best I've found so far.
thanks for the help. Do you know anything that has similiar functions for python 3 because I won't install 2.7 for two reasons: I already started learning 3.0 and I usually always use the latest.
Yeah, Not really my choice. I personally don't use exchange for anything but work stuff.
I have a radical idea. Firefox (and a few other browsers) are already open source. Why don't a few developers create a proof-of-concept fork project with an implementation of Python built in. I think if people had something they could play around with the idea would more quickly gain traction.
Just go for Python 2.7. Pretty much everyone still runs 2.7 (and therefore most 3rd party modules are only available for Python 2.x) and the difference between 2.7 and 3.x is really not that big.
&gt;Id settle for using python to filter my exchange mail. Outlooks filters suck. Is Python the only language you know?
I'm enjoying them, but I'll never get around to all of them. Have any favorites?
If it's not in the standard library, then it's not standard. That's okay. Python's a language. It doesn't need to have a canonical web framework.
Nope, Java, Javascript, C, C++, Perl, Python, Enough VB to know writing them in VBA is a pain in the Arse.
I have to disagree with this part: "those that come from a fundamental misunderstanding of why Python is wonderful (e.g. whitespace)". Whitespace has nothing to do with the wonderfulness of Python, but it's a wart on an otherwise beautiful body of work that I can live with. 
Agreed. The best thing to do is get in the habit of writing code as compatible with Python 3 now as possible, to get those good habits in place. I found [this guide to writing Python 2 and 3 compatible code](http://python3porting.com/noconv.html) in a [free book on porting to Python 3](http://python3porting.com/bookindex.html), from [this question on Stack Overflow about writing Python 3 compatible code in Python 2.7](http://stackoverflow.com/questions/5937251/writing-python-2-7-code-that-is-as-close-to-python-3-x-syntax-as-possible).
You should look at the SpamBayes project. It is written in python and includes a plugin for Outlook.
If it were to ever happen, Python would need better anonymous closure syntax. This: def foo(arg): ... bar(foo) ... is not nearly as nice/readable as the more JS-like: bar(fn(arg): ... ) Similar to the lambda syntax but with support for multiple lines (which would no doubt be more difficult to parse). This is particularly useful for event-driven and asynchronous programming, which is the majority of client-side web programming.
If you're interested, have a look at the [Python XPCOM extension](http://code.google.com/p/pythonext/). But it's not very active.
&gt;Python 2 or Python 3 Either, preferably 3. Internationalization/Unicode is especially important in a global (web) context. &gt;You mean C? No. Developer's are not productive in C. It is just too time-consuming and low level for most developers.
No no no. Please god no. The web isn't your little local development box. Language fragmentation would be awful. Much of the progress in Web tech over the past 15 years has come from people building on top of each other and having only one simple language to learn greatly facilitated this. I also love the idea of having python available everywhere, but having more than one script language on the web is really really bad. Wait until you see the havoc Native Client and Dart will create if they become popular.
I've started them for "Designing Embedded Systems with Linux and Python". Is there any way of tracking if anyone is currently subtitling a video? My worry is to spend time on subtitling, just to have it be completed by someone else before I finished.
Your response here is just ignorant and sexist. Seriously nobody in their right mind would be here complaining about a bit of software named waiter, which is the mail counterpart to waitress. If you want balance get off your dead liberal ass and deliver something to the community. There is nothing worst than somebody complaining about the abuse of their group (in this case a figment of your imagination) instead of doing something constructive. As to your complaints about the fem aspect of this piece of softwares name, what in the hell do you expect? If it is written by a normal healthy male it isn't going to be a tribute to another male by any measure. Get a group of guys together to go out to a restaurant and they will look for and prefer a restaurant with female waitresses. This may shock you but your idealistic whining will change nothing as it is in fact normal. You may not like that males see females as subordinate to them but really you are fighting biology here. 
I'm also wondering how you deal with all the multiple release versions of python, libararies written in these different versions and whatnot. I don't do a lot of javascript, though I know the basics. From my understanding, the different versions have more or less been kind of like other web standards: adding features and deprecating some others. The standard is eventually adopted by a web browser. With Python, what are the browsers going to choose when code becomes non-compatible?
Dear Mr. Stop Liking Things I Don't Like, **JavaScript is actually awesome.** - closures - prototypal inheritance - first-class functions - immediately-invoked function expressions **You're pretty much totally wrong.** &gt; The only reason people use JavaScript at all is because they have to [Nice try.](http://www.flickr.com/photos/54644045@N08/5055032357/) - How it's use of `this` "crazy"? You sure you didn't mean "different"? - Is there any justification for weak typing being a flaw other than "waaa"? - No int type? Seriously? - Has semi-colon insertion *ever* screwed your code up? - If it has, how many times? - If it's more than one, how much time have you spent tracking down these errors? - If it's a lot of time, have you ever considered, you know, actually *learning* JS? But yeah, "lack of non-string keys" actually is really annoying. **Full Disclosure** JavaScript was the first language I learned. PHP was the *second* language I learned. I never studied computer science; I'm just some nobody self-taught web dev. So what the hell could I know? **In Closing** If JavaScript is a "toy" (talk about kind of meaningless), then so is the Internet that runs on it. Sincerely, [Yup, I Mad](http://www.flickr.com/photos/40227343@N02/5046091402/)
Geniuses at work ... 
Duped on the front page...
py.test is awesome (no boiler plates and smart assert a la sunit) - nose is very good too
I choose to use coffeescript for most things these days, whether in the browser or out of it. It fixes most of the problems you listed. I think it's a good language because it makes it very easy to work with functions.
In that case, you seem to be more of a free-software guy, rather than an open-sourcer like me, so there's not much use in my trying to convince you, since our reasoning for opening up software is completely different - mine is pragmatic, while yours is ethical.
&gt; closures &gt; prototypal inheritance &gt; first-class functions &gt; immediately-invoked function expressions Closures and first class functions are nice. These are the "very few redeeming features" I was referring to. Prototypal inheritance was a neat idea back in the 90s when nobody had actually tried using it. In practice, it kind of sucks because it doesn't really fit the way humans think or reason about things. You can argue that I don't really "know" JavaScript if I feel that way, but the fact is that most experienced JavaScript programmers end up trying to simulate class-based objects. I can't think of a language that has closures without the equivalent of "immediately-invoked function expressions". &gt;How it's use of this "crazy"? Every JavaScript programmer I know thinks the way `this` works in JS is broken. For example, getting its value reset to the "global context", and the fact that it even has a value when calling a function not as a method. &gt; Is there any justification for weak typing being a flaw I'm guessing you don't know the distinction between weak/strong and static/dynamic types. Lots of people get these confused, so you aren't alone. Weak types are generally a bad idea because they make reasoning about code more difficult. For example, [`==` isn't even transitive in JavaScript](http://stackoverflow.com/questions/5447153/javascript-equality-transitivity-is-weird). For a toy language that's okay: everything you're building is small enough to fit entirely in your head or throwaway code so who cares about being able to reason about it. It you want to build large systems that can actually be maintained, however, being able to reason about code is critical. &gt;No int type? Seriously? Yes. This wouldn't be bad if JS actually used some sort of arbitrary precision type for numbers, but it doesn't. They're just doubles. &gt;Has semi-colon insertion ever screwed your code up? You may not realize this, but you're making a pretty good argument for why JavaScript should not be written by fallible humans and should instead only be machine generated. &gt;JavaScript was the first language I learned. PHP was the second language I learned. I never studied computer science; I'm just some nobody self-taught web dev. So what the hell could I know? You're able to do useful stuff despite how bad JavaScript is. Why get angry when it's pointed out that you'd probably be able to do even more if browsers supported a better language? FWIW: I've used probably around a dozen languages and studied a couple of dozen more. I have written JavaScript code "professionally". While pretty much every language has "warts", JavaScript has far more than its share, and (unlike the many warts in other languages) they're pervasive. Note that most other languages don't need a book called "... The Good Parts", and even if they had one, they wouldn't spend more than half of the book telling you what parts of the language to avoid. &gt;If JavaScript is a "toy" (talk about kind of meaningless), then so is the Internet that runs on it. The internet "runs on" JavaScript? [Ahem.](http://www.flickr.com/photos/54644045@N08/5055032357/)
- `this` refers to either the global object or is undefined (depending on whether or not you're in strict mode) - `this` refers to a node if the function is executed from an event handler or a W3C event listener - `this` refers to an object if the function is executed with `new` or as a method - `this` can be changed with call/apply THIS IS MADNESS!
Saying that's a python exploit is like saying it's the syringe that cures smallpox.
Back when I first bought my nokia n95 8gb, I wrote a program that I used as a todo list for school assignments, tests, exams etc. The code at the time was really bad, but the overall experience was pretty nice. Was able to draw out my own gui on the canvas and everything. Thinking back, it was pretty impressive for how little I knew about programming at the time. Very easy to get into. I thought symbian died once it went opensource?
&gt; In practice, it kind of sucks because it doesn't really fit the way humans think or reason about things. Here, let me fix that for you: "It doesn't really fit the way *I* think or reason about things." &gt; the fact is that most experienced JavaScript programmers end up trying to simulate class-based objects. And by experienced, of course, you mean "programmers who are used to thinking one way and don't want to put in the effort to learn to think a different way." Excellent programmers who produce amazing code? Of course! Proof that prototypal inheritance is inferior? BWAHAHAHAHA &gt; You may not realize this, but you're making a pretty good argument for why JavaScript should not be written by fallible humans and should instead only be machine generated. I guess you missed the point, so let me try again. First: I don't rely on semi-colon insertion. Because when I learn a language, I like to learn how to do things right. After all of the languages you've studied, you've probably started doing this, too. (Good for you, by the way! Most people don't!) Second: If you're really writing organized and maintainable code (given your impressive experience, I think we can assume you are), *when is ASI going to make a difference?* Maybe you have a certain style, so that it breaks when a semi-colon gets inserted (such as putting return on a line of its own, etc). And if that's the case, then guess what? It's not a wart. That's you wanting to format your code the way you want, regardless of the language you're in. inb4 "formatting things this way instead of that way makes it easier to reason about code and maintain large projects &amp;c" That being said, here's the biggest problem: &gt; Weak types are generally a bad idea because they make reasoning about code more difficult. For example, == isn't even transitive in JavaScript. For a toy language that's okay: everything you're building is small enough to fit entirely in your head or throwaway code so who cares about being able to reason about it. It you want to build large systems that can actually be maintained, however, being able to reason about code is critical. All you're advocating is laziness as opposed to discomfort, both in the smallest measurable amount. Again: When has this *ever* made a difference in your code? In all seriousness! You want to throw in my face that == isn't even transitive? (For shame!) When has that bitten you in the ass? When have *any* of these "warts" actually messed up your code? I'm going to go out on a limb and say they haven't. I'm going to guess that you're such an amazing coder, you learned about these situations and know to watch out for them. "But now I have to think about things! Maintainability!" I feel for you, buddy. And while JS is 8th on the TIOBE index, and being expanded to be used on the server and Windows apps, you can go ahead and keep whining about how no one actually chooses to code with it, or it's just a toy, or good things are only capable in spite of it. Also: &gt; I can't think of a language that has closures without the equivalent of "immediately-invoked function expressions". ActionScript 3, for one, iirc.
If we are given downvotes, we're enough To do our Reddit loss; and if vote up, The fewer men, the greater share of honour. God's will! I pray thee, wish not one man more. By Jove, I am not covetous for points, Nor care I who doth comment on my post; It yearns me not if trolls my 'pinions mock; Such outward things dwell not in my desires: But if it be a sin to covet honour, I am the most offending soul alive. No, faith, wish not a man from other reddits: God's peace! I would not lose so great an honour As one man more, methinks, would share from me For the best hope I have. O, do not wish one more! Rather proclaim it, freshwire, through my host, That he which hath no stomach to this fight, Let him depart; his passport shall be made And crowns for convoy put into his purse: We would not fail in that man's company That fears his fellowship to fail with us. This day is called the Ides of March, my coz: He that outlives this day, and comes safe home, Will stand a tip-toe when the day is named, And rouse him at the name of Ides of March. He that shall live this day, and see old age, Will yearly on the vigil feast his neighbours, And say 'To-morrow is the Ides of March:' Then his account will he open, his posts. And say 'These flames I had on Ides of March.' Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names. Familiar in his mouth as household words sdleihssirhc and freshwire, Be in their flowing cups freshly remember'd. This story shall the good man teach his son; And the Ides of March shall never go by, From this day to the ending of the world, But we in it shall be remember'd; We few, we happy few, we band of brothers; For he to-day that feeds the trolls with me Shall be my brother; be he ne'er so vile, This day shall gentle his condition: And those in other reddits now a-bed Shall think themselves accursed they were not here, And hold their manhoods cheap whiles any speaks That fought with us upon the Ides of March!
The exploit is in machine code, the conveyance to inject the exploit is a python wrapper and could have been written in any language. Hence my comparison of python to the syringe. They both deliver the payload, but are generally unrelated to it. 
Can you be more specific about the benefits of py.test?
There are basically three options. `1`. **unittest** (aka PyUnit, sometimes): import unittest class TestMyStuff(unittest.TestCase): def test_when_x_then_y(self): result = MyStuff().y() self.assertEqual(result, 'x') `2`. the looser form of **nose**/**py.test** def test_when_x_then_y(): assert MyStuff().y() == 'x' `3.` **doctests** import doctest def doctest_when_x_then_y(): """Tests for MyStuff: When you do y(), you get 'x' &gt;&gt;&gt; MyStuff().y() 'x' """ def test_suite(): return doctest.DocTestSuite() Each way has its own set of advantages and disadvantages. And then there are test runners. You can use nose, py.test, or zope.testrunner. You can convince them to understand whatever test style you prefer (although so far I haven't seen anyone try to run nose/py.test-style tests with zope.testrunner). **NINJA EDIT**: fixed formatting.
&gt;if you actually attempted to run what was posted you could have put yourself into a world of hurt, as it did not appear to be a working exploit of MS12-020, but instead had traces to an Apache exploit from 2008. So this somehow compromises the local machine... by attempting to send data to a remote one? Wat? Anyway, Windows Update automatically patched MS12-020 (with KB2621440), so I don't see why there seems to be so much concern that people will get exploited...
You wouldn't download a banana.
The Mozilla flavor of ECMAScript (ie, JavaScript) supports some Pythonesque idioms. For example, open the Web Console (under the `Web Developer` menu (either in the Firefox menu if you have the single-button menu, or under `Tools` (or just Ctrl+Shift+K to open the Web Console))) and try this (for the current page): let f = [link.href for each (link in document.links) if (link.host == "www.reddit.com")]; `f` is an array containing the URLs on the current page that are to the `www.reddit.com` domain. Not as clean as regular Python, but still useful. See [MDN: New in JavaScript 1.7](https://developer.mozilla.org/en/New_in_JavaScript_1.7) (which was introduced back with Firefox 2), particularly for details on array comprehensions, destructured assignment, iterators, and generators. 
Is the Unicode talk by Ned Batchelder going to be posted?
I, uh, think this, uh, guy, uh, kinda says, uh, uh, uh, too ,uh, much uh
I'm cross posting this because I think Python folk might find this useful. Also, I wanted to get ideas for improvements, etc.
nope.
Why one? If I'm building a content-oriented social networking site then Django sounds great. But probably not if I'm doing analytics where I probably want to be closer to the metal with a legacy database, and vendor-specific SQL extentions for partitioning, table functions, windowing functions, etc. And if I just need a web service framework or small, embedded web client for admin then perhaps Bottle or Flask would be better. 
[Interesting](http://pastie.org/private/4egcqt9nucxnsiksudy5dw) [links](http://pastebin.com/jzQxvnpj) come out of the topic of freenode #ms12-020 though... Wish I had time to play with this at the moment. :)
[http://IsTheRDPexploitOutYet.com/](http://istherdpexploitoutyet.com/)
in all fairness it doesn't say "python exploit" it says "python code to exploit"
&gt; I can't think of a language that has closures without the equivalent of "immediately-invoked function expressions". Minor point, but if I'm understanding what's meant here, python is like that. You can immediately invoke lambdas, but not multi-line functions.
So, cgi then? :)
So? Dude wrote a fun talk and got up on stage to present it at a conference. What's your presentation resume like?
because he's my brother, so I put it up in here for family pride. I am sorry to say I am a failure as a nerdette, my forte is sales-slime, not code. I am glad this got some upvotes. That is all. My work is done here.
Just most of Zope and related packages. zope.testbrowser-based functional doctests are actually rather nice. The good thing about doctests is that they look wrong without English text explaining what the test does. So programmers write that text. The bad thing about doctests is ... almost everything else.
Over my vacation during Christmas time, I decided to write a 6502 emulator in Python (actually an Atari 2600 emulator, but I got disinterested after the 6502 part). When I first ran it, I was benchmarking about 300KHz effective on my 3GHz machine. I tweaked and fiddled the code, but the best I could get was 350KHz. The first time I ran it in PyPy it ran at 3MHz effective on the same machine. I've loved PyPy ever since.
it would be exactly like how you dealt with differing implementations on webkit, firefox, and IE
You would be surprised how many machines are left online unpatched for years, even in businesses.
Assuming that you're talking about the python command line..there's a couple ways of going about it. If you're at the command interpreter. You COULD just type in: a = 1 b = 2 x = a + b print x You mentioning running a script..so we'll do that, too. First..write your script! Open up a text editor..any text editor will do. Although, I'd stay away from a word processor like "Word"...notepad perhaps? Don't know if you're coming from Windows or Linux or..whatever. Anyway, for what you just described..you'll want to write a *function*. A function is a way to capture a procedure--a set of instructions. They're useful because instead of typing the above code out each time you want to add, you can do this: def add(a, b): return a + b Once this is imported (will talk about that in a moment) you can just call something like "print add(1, 2)" and if will return 3 and print that on your screen. Write the above in a textfile, and then label it add.py..or whatever. Just make sure it ends with .py Next, through your terminal go to the directory with the .py file and enter the python interpreter. Type: import add That *should* be enough so that you can now use add(a, b) from the python shell. If you have any other questions feel free to PM me. Community: please call out anything I may be incorrect about. I'm new here. 
Fuck, scripts, modules, functions, the interpreter and the command line.. it's hard to tell what's what haha. Okay, does the .py file have to be saved somewhere special? I can't find a way to direct it to my script so I can run it.
Okay, so that I don't use the incorrect terminology I'll just say it in layman's terms: I want to make a .py file that contains a set of instructions that make use of variables it is given, like a function in maths. In this example, I give the 'function' 2 variables, a and b, and tell them to add them together, and store (and I guess display) the result. Using the IDLE GUI which is basically just a command line type thing and text editor, how EXACTLY can I do this, and where does the .py file have to be saved in order to run it? Also, how do I go about running it with say, a=5 and b=2.
Ah, ok, you're using IDLE. Thanks for the other clarifications, too. first off, I really suspect you don't want to do that! I'm 99% sure that you want to define a function! When you talk about creating a .py file, what that would do is define a module. Modules are not normally 'called'. Rather, either you import functions, classes, constants, and other neat stuff which have been defined inside them, and call those functions, etc... or you invoke the module from the commandline -- which I'll say no more about here, see my other comment. It is my belief that what telestrial said is the closest thing to what you want ( I say 'closest' because you seem to have some somewhat off-kilter understandings of some key concepts, so when you talk to me about it, it comes across like 'I want to dig a hole using my chainsaw' -- as being a result of a misunderstanding.) For a beginner, like you, I suggest putting your module in a directory you created for your modules to live in. Then, you need to make sure that the 'current working directory' that IDLE is using, is that directory you created. This is easy to do if you run IDLE from the commandline -- just change to that directory immediately before running IDLE. I believe that what you need to do is: 1. Create your .py file, with the function defined as either telestrial or I suggested. 2. Save it in your modules directory (the one I suggested creating, above) as .. let's say 'add.py' 3. Start IDLE from that directory 4. type 'from add import add' into IDLE and hit Enter (this instruction is based on telestrial's example, in which the function is named 'add'. In my example, the function is named 'samesum', so that you would instead type 'from add import samesum') 5. call the function. eg 'add(5,99)' You CAN invoke a script from the shell commandline (not IDLE's commandline). However I believe that in this case that would just be an obstacle to learning while also gaining you nothing in terms of what you can do. If you are 100% sure that you do actually want to do things that way, I've provided some instructions in my earlier post on how to do that. I am assuming your OS is some flavour of Linux; please inform us if that is not the case.
Another XML toolkit is called [Amara](http://wiki.xml3k.org/Amara). It's more natural than ElementTree or lxml in my book but sadly the doc isn't really good. Some might like it.
add.py import sys if __name__ == "__main__": if len(sys.argv) &gt;= 3: print int(sys.argv[1]) + int(sys.argv[2]) Start -&gt; cmd cd "path to add.py" add.py a b
Now, my 'comment above' could not be posted cause you deleted your comment. So I'll post it here.. ... First, please let me clarify that IDLE is not a command shell. Typing in 'python myscript.py' in IDLE will get you nowhere; IDLE is designed to execute python, not handle the execution of system commands. The command I gave needs to be typed in a command shell (eg. dash, sh, bash, zsh -- these are some popular ones). Secondly, yes, it works FOR python 3.0 (not IN python 3.0; it's not Python code, as I mention above.). However, usually the binary is called 'python3' (or even something like 'python3.0','python3.1','python3.2') The file has to be located in the place that you tell it that the file is located in :) If you don't specify a path, it will look in the current directory. if you do specify a path, it looks there. If you don't know what I mean by a path, you likely don't know enough to deal with the commandline invocation method that I'm talking about. **That's fine**; I'm 99% certain that it's *not* what you actually want to do here anyway. At this point, I think I should ask -- have you tried any Python tutorials?. Diveintopython was great, IMO, it certainly taught me a lot; and [there's a Python 3 version, too](http://diveintopython3.ep.io/). It goes right from the start, writing a simple program, and builds up to more complex subjects such as classes, all the way up to packaging libraries.
If you code in python 2 you code in an arcane and dead language, might as well go with B. If you code in Java your code will work for the forseeable future and will still be supported. C is unproductive if you use only C, but there are libraries and frameworks for C just as for any other language. The problem is most developers dont know their head from their ass and cant tell the difference between * and &amp;. 
... so what's with the coding style of all these hackers, anyway? buf = '' buf += 'bunch of hex' buf += 'moar hex' Ugh. data = ''.join( 'bunch of hex', 'moar hex' ) Much better IMO. DRY wrt the identifier name.
Define replace. It is replacing cpython to run python programs 'as we speak'. PyPy will probably be, perhaps is being, used to create proofs-of-concept for new PEPs. It might even, one day, replace CPython as the 'reference implementation'. That day is years away though. Perhaps decades: think python 4000.
&gt; There are tons of libraries for XML processing out there. Yeap but as complete as Amara or lxml, not really. ElementTree is good enough for parsing and writing but doesn't do much else. lxml and Amara provide the complete list of tools: xslt, relaxng, xpath, schematron, etc.
guido pretty much hinted at it in his keynote to archive replacing cpython, a lot more adoption for production setups and a lot more c-based extensions need to be supported reasonably given the fact that this is "only" a lot of hard work, im sure the pypy team will provide, since "lots of hard work" is basically what they do
A very interesting talk that confirms my feelings about PyPy: I'm curious but frightened by its complexity. I also have a strong feeling that a lot of cheering on reddit is done by coders who haven't been burned by the fire of complexity. I put the question "Will PyPy replace CPython?" in the same jar as "When will be the year of the Linux desktop?" (I'm a Linux user btw.). However, I'm fully aware that Assembly coders must have felt the same way when the first C compilers came around. It's a matter of trust and I just don't trust PyPy enough yet to depend on it. I expect it to get there eventually though.
&gt; No framework is best framework. So you enjoy writing boilerplate?
Actually, quite right... adjacent literals are joined at compile time, just like in C. Well spotted :)
Wait so what's the difference between Pylons and Pyramid?
The RuPy 2011 talk he mentions at the end * http://youtu.be/5jbG7UKT1l4
Thanks for the explanation. Ignoring any speed difference, am I right in thinking one could implement this using a dict type which kept the keys sorted in a list on insertion? Would be interesting to see if using bisect with a regular list would improve speed significantly.
Very good tutorial. Would really benefit from a section on handling namespaces in tag and attribute names. My impression is people find it confusing when there's no obvious way to tell ElementTree that you don't care about namespaces. They don't get why that "feature" isn't easy. Of course not understanding why you have to deal with namespaces indicates a limitation in the developer's knowledge of XML, rather than a limitation in ElementTree.
No, you have a good point. The idea is reasonably sound (although the designers of Python made a conscious decision to use a hash approach rather than a tree approach for the built-in `dict`, for good reasons), but the implementation is needlessly limited. Any comparable type should logically work here.
Oh I wasn't trying to make a point, rather hoping to learn. I don't know what the common intended applications are for this module. *If only there were some way the author could tell us...*
There is a difference. You can actually find the first edition online for free, but the second, not. The questions differ from the ones in the first edition.
Yeah. That was my problem with amstan's post. Hoping to get some clarification. 
Doctest is fantastic for testing your documentation. It is horrible for testing your code.
Java coding for the web is terrible. Have you made web applets? The horrible loading times, shoddy appearance, and frequent JVM bugs made it impossible to use professionally. &gt;C If they can't tell the difference then that is how it is. The people have to use these languages.
woo! He mentions the tutorial I wrote at 14:40. I feel sort of famous by proxy.
The hope is that you do not need to grok the compete system to make some kinds of interesting changes.
Yepp, that is where I see the real value of PyPy. It's (IMO) meant to tame the inherent complexity of language design and its implementation. A compiler compiler. It makes it possible to try out ideas that are just impractical to try today. Like writing a feature complete Python interpreter in a college seminar. I also like to see PyPy accel at this rather than trying to win over the scientific community by implementing their own (incompatible) version of numpy: * http://technicaldiscovery.blogspot.com/2011/10/thoughts-on-porting-numpy-to-pypy.html It's hard to admit it, since I'm part of this community, but we are as conservative as it gets. We really love our old and new Fortran/C code and we love Python for making it easy to glue it together.
I liked this post, but I wanted to share a thought on the poster printing point. A lot of people did indeed have giant and presumably expensive-to-print posters. I also had a [poster](https://us.pycon.org/2012/schedule/presentation/89/) at the poster session, and mine was printed. Traveling from Ohio, though, I had certain restrictions, namely it had to fit in my suitcase. I first determined that the biggest I could fit was 2 feet wide rolled up. Looking at Kinkos and some office supply stores, 2 foot by 3 foot posters were crazy-expensive. However, I was surprised to find that almost any place that prints photographs will print poster-sized photos as well. I drew up my poster, converted it to a giant jpeg, and sent it to my local Walgreens for printing in 2 foot by 3 foot format for only $35. It was ready 3 hours later too! While it's not pennies to print, I was extra happy with how it looked. I have no problem with people printing their own. I just thought that some people might find this tip helpful.
The way he talks and moves makes me nervous! I guess he was really nervous in the talk.
there should be a standard abstraction layer in the middle so it doesn't matter what you use and end this fucked up inconsistencies with web technologies.
So, for the most part, people who use it only use it for small-scale unit testing, and not more comprehensive testing, like integration tests? Seems to me like you could really make your documentation ugly by putting a lot of tests in it. Then again, maybe your tests help document the code? The nice thing about it is that the test and the code are close to each other. That's a good idea. I saw the other day that the D programming language has [unittest functions](http://dlang.org/unittest.html).
Python 4000 will implement itself.
That's awesome! Thanks for the link. I've been watching a lot of the PyCon videos, and am amazed by some of the presentations. This one was particularly interesting!
I wouldn't argue that unittest is that great. I guess I am just wondering how people really use doctest. To me it seems that a) writing code in doc strings is a little sketchy, b) tests in documentation could make the documentation ugly or too verbose or confusing, and c) it doesn't seem like it would be limited to very small unit tests, and couldn't scale up to things like integration tests, or complex tests with databases and whatnot. That said, I like the idea that doctest enables you to write unit tests close to the code being tested. That seems like a good idea. I'm sure Tim Peters is a very smart guy, and I didn't mean to dis his work, of course. Needless to say, you shouldn't pay too much attention to trolls like me.
:D
Wow. I didn't know that! TIL! Thank you.
You seem severely msinformed about how an OS works. Fedora is GNU/Linux based which is mostly C to begin with. But yes a lot of their tools are written in Python. You'd have to write your own hardware drivers, bootloader, etc. and a whole slew of other things, not even getting started on actual getting Python to compile and run on it. To get an idea of what an immense task this is, see the [OSDev Wiki](http://wiki.osdev.org/Expanded_Main_Page). Unless you mean something else entirely, then please explain in more detail what it is you're trying to achieve.
I am thinking my first project will be an RDBMS monitoring system, so it won't really be about content as much as it is about gathering data and displaying near real time charts. To be honest the only thing I really want the framework to do is give me a crud interface for the admin. To be honest it might be quicker to code it all by hand, but I am doing it more for a learning experience than anything else.
Way to completely miss my point. And I disagree ASCII suffices even in those circumstances, because as I said, I ran into exactly that problem. Nor do I see what having any form of UI has to do with using ASCII vs Unicode. What if you want to properly cite one of your foreign colleagues who happens to have a non-ASCII character in their name? Being Python, this would occur in the doc string, which would have to be a Unicode string for Python 2 and have a good chance of breaking IDEs and doc generators and whatnot if they only expect a specific encoding. Even if you're just crunching numbers, you're going to write text *somewhere* and ASCII only "suffices" if you explicitly set yourself up to be limited to it.
actually i think CPython is remakably simple internally, but i have nothing to compare it against.
in python 4000 the white space will be so significant that most programs will just be spaces, newlines, and the occasional tab.
&gt; *Pyed Pyper was developed at Sony Pictures Imageworks to facilitate the construction of complex image manipulation "one-liner" commands during visual effects work on Alice in Wonderland, Green Lantern, and the upcoming The Amazing Spiderman.* What the? I, for one, would love some examples of how they used it in these movies...
Python 3 will be here for the foreseeable future as well and is much much nicer than Java.
This reminds me of [Pype](http://arvindn.livejournal.com/68137.html)
Can't wait to try it, although it makes me appreciate powershell. I wonder what an ironpythonpowershell hybrid would look like. (crazytalk, I know).
J'assume it's supposed to imply that what you seek fits py.test?
Good point. Done!
This is already [a thing](http://en.wikipedia.org/wiki/Whitespace_\(programming_language\)).
Yes, well, nobody is using it not even "python" people. Django? No. Scipy? No. numPy? No. pyqt? no.
It's not obvious from looking at the file how this is hierarchical. One answer is to munge it into xml with regexes, and use an xml parser.
Another approach might be to use the `csv` module (with tab as the delimiter character) and then key off of the appropriate column to find the related records. This assumes that the file is small enough to read entirely into memory, however (I'm not sure how big the file is and dropbox is blocked for me at work).
I used to agree with you on all these points. However, once you understand what's going on, Javascript's "this" semantics are actually quite powerful, even elegant. Writing callback heavy code would be more painful in Python than Javascript: deferred = $.loadJSON("/some/url") deffered.success( function () { 
You know, if you do that, you'll end up putting XML in XML. That won't be very fun.
Fortunately the XML data isn't needed.
In the foreseeable future, this will change.
&gt; As to your complaints about the fem aspect of this piece of softwares name, what in the hell do you expect? ... You may not like that males see females as subordinate to them but really you are fighting biology here. So you agree that the software's name is sexist, but that is okay because you, as a man, consider women subordinate. Why do you consider women subordinate? &gt; If it is written by a normal healthy male it isn't going to be a tribute to another male by any measure. Are you homophobic?
Like blatheringDolt said, [`import sqlite3`](http://docs.python.org/library/sqlite3.html) should take care of it for you on any vaguely modern version of Python. Assuming you already know a bit of SQL, it works like any other SQL database and supports DB-API just like any other database adapter in python. You can create a sqlite database on the filesystem or in memory, whichever is more suitable for your purposes.
I'd like to see the PEP for that...
The "Poster Session" was also recorded. They gave each of us a few minutes to discuss our poster since that event usually goes uncovered and unexposed to anyone who wasn't there.
I finished "Stop Writing Classes." It took much longer than I expected/hoped it would.
The tool only lets one person subtitle a video at a time. Once you save your work in progress and exit, the captions go up and the menu frame defaults to "English Subtitles" and anyone can use "Improve these subtitles" to edit. SA, you work will never be wasted.
Just keep going down the list. The talks with numbers are the poster sessions.
I can see where you're coming from, but just keep in mind that the (A)GPL community is simply _a_ community. So -- for better or worse -- making something an (A)GPL community good is something completely different from making it common good. At the end of the day, it's your code and therefore your choice which license to publish it under -- as long as your code isn't affected by another license (i.e. (A)GPL or proprietary), of course.
How do I start using it? What would be the preferred way to download it?
Note: in this particular example it would be much better to fix `__getattr__('deepcopy')` to raise AttributeError, instead of reimplementing `__deepcopy__`: def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(key) Personally I would be inclined to go one step further and protect against accidentally defining `__magic__` double-underscored names at the beginning of any custom `__getattr__`: if key.startswith('__'): raise AttributeError(key) (I commented on the site yesterday, but it appears my comment is still stuck in the moderation queue.)
I can vouch for this.
Added "What you need to know about datetimes"
I might be way off here, but how is this kind of development “native“? As far as I understood this app is an IDE you can use to write code on iOS but in the case of Python not for iOS.
over specific exceptions migth be pain and even more so if you don't have sane base type for them. but I still prefer that any day to people raising a basic Exception with only a message or some silly stuff like error codes that find out what actually went wrong.
They should show this on every CS course.
"Stop abusing classes" would be better title. Classes are useful, if you abuse them... well, yeah, it's going to turn bad design. 
&gt; I've only seen the first problem in people who learned to code in Java. Unfortunately the majority of people learn to code in Java these days, if typical college syllabuses are anything to go by.
Love how fast this project is moving. There are at least two other Python iOS apps, but none have added significant features in a long time.
Why not [link directly to Youtube](https://www.youtube.com/watch?v=o9pEzgHorH0)?
I started learning to code before I learned Java but high school and college didn't really leave me any other options. I took a perl/python class in college only to find out the asshole teacher lied about teaching python in the course to sucker people into taking the course.
I failed my Java course, switched out of computer science, jumped into biology, found python great, now doing biological modeling with it. 
If, for whatever reason, the youtube video is deleted, then the pyvideo guys can update the page for this talk with a new link.
This is one of the places where I really hope people don't do that. I get when you do it with blog spam and link shorteners, but the pyvideo site nicely curates several years worth of PyCon videos. In the linked video's case, you can easily go back and see Jack's talks in 2011 and 2010 by clicking on his name on the right. The page is ad-free, well organized, and gives nice benefits. Let's not sidestep all of that just to get a direct link.
Any chance you missed the joke?
I wasn't convinced by this presentation. It should have been called "Stop writing crappy java-style code in python". There are also lots of times when a class with two methods is appropriate in python (to create a decorator that takes arguments, WSGI middleware, context managers.... all kinds of stuff).
Better idea : Stop making screencasts for everything when you should be writing articles. I have enough of an attention span to read something, but I can't sit through 30 minutes of some unrehearsed, unedited, "ummm..."ing crap.
Because you can reach to other interesting videos by their Pycon dates and categories in a cohesive manner?
Your pygame has to match your python install. I for instance use 2.7. On top of that pygame has really been updating to much, so it hard to say what is out of date. Also pygame version number is separate of python's version number. You can have pygame 1.9 on python 3.2 or 2.7. That being said you just install pygame and other dependencies and run the code. It not like java where there is a jar. Instead you download the source code and run it from you IDE or the command line. Kind of annoying if you ask me. I would love to impede my game on web game sites.
That sounds awesome. I kinda wish I had done that. I'm often caught by the fact that I'm not doing anything to advance our understanding of the real world. Real science and even math is so much more rewarding. You're reverse engineering God's work. Me, at best I'm building an application used by millions of people, but so what. You know? Even if I go academic I'd have to go pretty far for to get to anything fundamental. I think the term is natural science? I mean, a binary tree, let's say I invented that. Is that real? Or is it just applied? Is it as real as discovering the connection between electricity and magnetism? Even if you go mathematical, the math that describes electricity seems so much more real than the math that describes, say, algorithmic complexity. I suppose boolean logic and combinatorial math and math if sets and stuff is all pretty fundamental, but, I don't know... I'm rambling now, but im not the first to question where the science in computer science is, or in my case where the nature is. I will say that quantum computing really appeals to mw because something about having all those states in a system at the same time really sounds like what real life must be like (if that makes any sense). Tl;dr: I bet there was a better female/male ratio in the School of Biology.
None of my professors actually knew when to stop with classes either (to be fair, neither did 99% of the industry). We all had a class hammer. Speaking honestly, I recently acquired a function hammer. Map and lambda all the things! (seriously, if someone has good advice on when to stop mapping and use an old fashioned loop, hook me up. I know I'm doing it because i can and not for a good reason)
Or use [google-code-prettify](http://code.google.com/p/google-code-prettify/) and do it in Javascript. This actually seems like a good tool too. I'm currently writing, or wrote, a program that also needs something like this. I did it with the above.
Using JavaScript (I've used in the past SyntaxHighlighter from WordPress) to highlight your text definitely works, but it doesn't always look good on tablets for example. The approach presented here will look the same on desktops, phone and tablets.
:)
[Speak for yourself.](http://www.youtube.com/watch?v=piWCBOsJr-w)
 class Tilder: """ A class to wrap returning the TL;DR for the PyCon 2012 talk you asked for a TL;DR on.""" def __init__(self): pass def call(self): return "KISS" tldr = Tilder() print(tldr.call()) To go slightly longer: 1. Don't use a class unless you really need one 2. [This item reserved for future use...] 3. Don't leave seed classes (or other "future-proof" things) that you might (read: won't) need for future versions 4. Don't use custom exception types unless you really need one 
Can you clarify what you mean by 'easier'?
You should probably watch the talk, you'll probably understand what you are doing wrong.
No, I'm pretty sure I didn't. He seemed quite clear in his implication that these are buzzwords taught at school that encourage complex class-based systems, yet which are irrelevant in practice.
Also, Larry Hastings has a very good podcast called 'Radio Free Python' that you totally should go listen to.
Wow. I got similar story. I hated my 4 years of Java computer science, did Math minor to drown my sorrow. Discovered Python there, now live happily ever after.
I usually listen to all tech talk by treating them like radio. I listen to them while coding and never paid any attention to the ummm... at all.
I think one time in this subreddit or maybe /r/learnprogramming, someone advocated the creation of a class so that the OP could reuse his code. Specifically, I think OP just wanted to find the square root of a number or some other simple calculation, and this guy decided OP should make a class that does computations, so that another function other than square root could be used instead. Seriously, WTF?
Hi Brian, are you one of the community member who curates pyvideo.org? If so, I have 1 small feature request. If you don't mind. Is it possible for you guys to organize the videos using YouTube shows? YouTube shows is nice because it provides playlist and it auto plays to the next video. I'd love to listen/watch the whole pycon videos back-to-back.
You know you can *temporarily* allow pages... right?
The object religion preaches the object as the right solution to every problem. the Oo priest argues that oo defines the quality of a language, and that the best solutions to problems are always in the oo scope. That is religious, and wrong. . . Not every programmer feels that way, but some professors teach that way and many programmers blog along those lines. Many junior programmers see oo as the naturally evolution of programming 
Because Java fits exactly how people want to teach. That or they teach C# which is basically Java and the same sort of mentality.
For context managers, contextlib.contextmanager is pretty useful, and avoids the need for a class definition. I like it for simple cases.
This, I think, is the point he should have gotten to: don't *start* with classes unless you see an immediate need. Move to classes when those needs arise, and not before. It comes across as: "Avoid classes at all costs." I think we have all seen cases of premature abstraction, and it can be *horrible* in Python (without IDE help.)
Classes with just `__init__` and `__call__` are definitely the thing for decorators. Beats thrice nested functions any day.
a python recipe by Raymond Hettinger. Full-featured O(1) LRU cache backported from Python3.3. The full Py3.3 API is supported (thread safety, maxsize, keyword args, type checking, _ _wrapped_ _, and cache_info). Includes Py3.3 optimizations for better memory utilization, fewer dependencies, and fewer dict lookups. Documentation and examples: http://docs.python.org/dev/library/functools.html#functools.lru_cache
&gt; =1 Actually, it's ordered on key hashes. [Though it won’t be anymore.](http://bugs.python.org/issue13703)
Mapping in terms of `map`? Most of the time list comprehensions are better, since while there may be a _slight_ speedup with `map`, list comprehensions are infinitely more readable (especially to those unfamiliar with the code they're reading). http://stackoverflow.com/questions/1247486/python-list-comprehension-vs-map
I think a better example would be: class Tilder: """ A class to wrap returning the TL;DR for the PyCon 2012 talk you asked for a TL;DR on.""" def __init__(self, name): self.name = name def call(self): return "KISS, " + self.name tldr = Tilder("this") print(tldr.call()) Should be refactored into just a function: def tilder(name): return "KISS, " + name If you want to reuse the same name without having to explicitly provide it, that's what `functools.partial` is for.
2 is spot on. wait..Did you ever fork a rhythmbox plugin?
&gt;not many people use Python Actually a **lot** of people use python (and also pygame). It's one of the most popular languages out there. Pygame is the most popular game development module for python
These things are also about making code that is easily maintainable. For example, I built a set of automation tools that make managing a cluster of servers a lot easier. Every few months my boss will ask for a new feature or a slightly different behavior out of the tools. Because my original design was, more or less, loosely coupled and encapsulated I am able to create new features or change existing ones with very little pain. You can absolutely over-engineer things. I always try to balance design with "done."
...I stand corrected. Thank you. =) And now one last thing...(Well I might first have to ask if you ever used Java because it would make my other question useless) Which one do you think is better? Or do they just have differences that make them unique in their own way and are both useful once you know them? 
&gt; Which one do you think is better? You shouldn't ask me because I'm fairly anti-java. The fairest answer I can give, as with most things, is that it depends on what you want to do. If one were markedly better than the other, the lesser of the two would probably cease to exist.
Haha, why are you anti-java, if you don't mind me asking? 
I had difficulty deciding whether to vote your comment up or down. I ended up choosing down, because AFAICS what you state is not what is outlined in the bug report, and in the [docs](http://docs.python.org/dev/using/cmdline.html#envvar-PYTHONHASHSEED); it will still be ordered on key hashes, it's simply that the value those hashes are initialized from may be randomized.
Hah that's awesome! I was the original author of the plugin. Thanks for improving it!
I was just going to post a link to my review on Amazon, but figured some folks would think I was doing that for an affiliate link. Maybe I'll post it on my blog next time...
Somewhat similar circumstance. I am first year, and hating java, so I am picking up C and python. Hoping good things will ensue.
Thank you! :D
Computer science-wise, C is pretty horrible, though.. Try ML.
In C#, you'd stick free functions into a static class which you can think of as simply a namespace. I don't see why this is a problem.
you did not say "incomplete", which is trivially true, you said "incompatible". If you meant incomplete than indeed, it is completely true. I'm not really up to discussing how much effort it is to reimplement numpy, the full proposal states completely how much of effort I think it is. As far as burnout goes, at least personally I work a lot less than an average bay area drone.
Oops, no clue why I mixed up incompatible and incomplete. I actually do think that it's unlikely that the PyPy version of numpy will achieve compatibility in regards to the C-API. However, why are you insulting bay area coders all of the sudden? Fijal, this is exactly what I meant by "Internet hate machine". As I said before, I won't be part of it. Have a nice day.
Ordinary programmers (who learned OOP from Java) define classes to use objects. In Python, like Smalltalk, everything is object already. So you can treat everything as object including functions.
&gt;you don't want your server patching itself and breaking your e-commerce server on the busiest day of the year for a patch that isn't actually relevant to you Doesn't it schedule itself for like 3AM by default?
And what if that utility-class-namespace needs to go in an actual namespace. You now have a 2-deep namespace for a generic function. Classes represent a single object. Namespaces contain various data, classes, ... related only by the group they belong to. Classes support inheritance. Classes are instantiated and have separate state for each instantiation. 
3AM is 3PM somewhere else.
3AM local time, I thought. Patch Tuesday isn't staggered around the world?
Well, with a review like that, I wouldn't mind a affiliate link ;)
 1. Boring business of using namespace prefixes when selecting / finding nodes. 2. How to strip namespaces, i.e. shove every tag into the same namespace. 3. How to force the namespace prefixes on output (instead of ET's `ns0` defaults) either to make things pretty or because some other XML processor relies on the prefix being just so (even though it shouldn't). The hideous horror of SOAP could provide examples of this in practise.
Awesome thanks for the review. Curious - what version of python is covered? I've been spending most of my time in 3.2.2 since that's all I can use at work (our environments are extremely locked down for security reasons) but obviously most of the stuff out there seems to be for 2.6 and there doesn't seem to be a huge migration. 
He guides you through Python 3 but also provides some info on keeping it compatible with both versions.
I claim they work a lot. judge yourself if this is insulting :) have a nice day as well.
Then you would be creating a new form of money, which the article writer believes is apparently vulgar. Edit: I'm a dick, ya'll.
The last part was a bit silly. I'll remove it.
Have you found that a lack of a CS degree makes it much harder to get into a domain like biology and still get the opportunity to do some programming?
You could use eval to do that if you really wanted to, it is just a bad idea in general for readability. 
The notion of YAGNI is an over-simplification. It's the equiv of telling people to stop eating butter, meat, sugar, etc. The reality is that people are poorly served with over-simplified recommendations. So, sometimes you're 95% or 100% sure you're going to need something, but can't get it all in immediately. If putting place-holders in now will save dramatic time on converting to that later - then just do it.
Good topic and some useful examples, but terrible talk. You never start with "listen to this guy, he is smarter than all of us." How exactly does he know that? A good talk doesn't tell people what to do, it tells then why you think something is better, but leaves the ultimate decision to the listener. In this talk he is really clear that he feels he is right and everyone else is wrong. Yes, I agree with him on most of the talk, but that still isn't the right way to present it. Very arrogant overall. I have listened to some amazingly accomplished and smart people that were FAR less arrogant, despite having every reason to be.
throwing a stack trace in the face of your user is not going to be considered good UX, ever. And if you have no intention of you (or someone else) catching the exception, why even use one? a nice message and to stderr and sys.exit() with a proper code is the well behaved thing to do.
I had the same reaction. I think without understanding decoupling and separation of concerns, it is really difficult to develop a large and easy to maintain code base. Contrary to what he says if someone is trying to explain what decoupling is or how it works you should listen. I don't think he was joking, was he?
No, that's not true. I've spent hours reading about this shit, but nowhere is there any good example of how the hell you do something as simple as u'whatever' on s = "whatever".
I think it would be hard to call it a barter exchange. Although I am not a lawyer. I will check out the tax laws in the UK though, just in case. Not that I'm planning on charging for the service.
congrats, you have achieved the same functionality as nose with one additional import :P
Even people who primarily program in Java, IME, generally agree that 'easiness' is not one of it's virtues, except in the rather superficial case where it's easier because you know it and you don't know whatever other language you're comparing it to :) What you are talking about later is the difference between static and dynamic typing (which is what one of the articles I linked describes). Java is like C, in that variables have an explicit type, that cannot change. That's the most salient aspect of static typing. In Python, the type model is different from that -- when you write 'int a=1;' in C, you are saying 'allocate some memory for an int on the stack; then immediately store the value 1 into it' -- whereas when you write 'a=1' in Python, you are saying 'create an int with value 1; then create the name 'a' and point it at that int.'; and a is just a named label; you can reassign it to, for instance, point at a list, eg. 'a = [1, 1, 1, 2, 8]' or any other type of object -- a class, a function, an instance of a class... When Python needs to know what type a value is, it does so by inspecting the object (hopefully for conformance to an interface/ subclassing a abstract base class, rather than being an instance of a specific concrete class) -- this is one of the main aspects of 'Duck typing' (which is the other main aspect of Python's type system). In general I expect you will find that this is one aspect of Python that helps you think more about how you want to solve the problem, rather than about the exact way the computer will implement all the details. Hope that's clarified some of the differences, because understanding the broad differences between typing systems can prevent you from committing a lot of strange (and not immediately apparent) errors due to holding mistaken expectations.
How much vegetable do you need to eat to program? More than you would think.
tbh, I think you only need to import pytest if you're going to decorate tests with things like expected failures.
My response is : I like this article, and I think it's worth clarifying that while programming is strictly a subset of math, the common perception of 'math' covers only the 'numbery' things. It's been my experience that "arithmetic + basic trigonometry + understanding of binary and hex" covers 99% of what I end up programming, in terms of math. If you're doing 3d programming, obviously matrixes and algebra are also helpful. If you're randomly generating stuff, a basic understanding of probability helps. However it's probably fair to say that programming also often includes some of the areas in math that are not actually perceived as 'mathy', for example set theory and combinatorics.
Code is protected by copyrights.
I appreciate your thorough explanations. =) And yes it does clarify some differences because I know I might do things I normally do in Java, in Python, and it won't work. Lol Also, I have been using Google to search for opinions on Python's capabilities. Do you mind giving your thoughts about these two statements? &gt; python can do both, it can do anything really (not necessarily well though). Its more suited to smaller applications since its slower than a compiled language like C++ but its very popular on the web. &gt;It's just a programming language made 'simple', though it's not very good for advanced work. But for example, if you've ever heard of the game Minecraft, python is one (I'm pretty sure) the libraries that was used to code it, other than the main one of Java. I don't think you can do apps with python alone, it's more of an 'addon' language. Also used a ton for first time programers, because the syntax is a bit less confusing, in my opinion.
You want this: foo = [[False for _ in range(cols)] for _ in range(rows)] Note that this will appear to work: foo = [[False] * cols] * rows However, that will result in all the rows being the same array, such that if you modify a value in one it will be reflected in all of them. The \* operator does not do deep copying. 
What's the point in the example given? You do not need to know much maths to program *this trivial program*. No shit.
Alternatively, you could consider using numpy, which has a whole list of [array creation routines] (http://docs.scipy.org/doc/numpy/reference/routines.array-creation.html) among which [numpy.zeros] (http://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html#numpy.zeros) which effectively is a False array.
A few of the stated things are true (it -is- slower than say, C++ or C, if you're not using something like PyPy or Psyco to speed it up; it has much more straightforward syntax than most comparable languages, so it -is- a good language for beginners). Most of them are false -- for example, there are absolutely truckloads of apps written in Python, see [this link](http://www.python.org/about/success/) for an overview of all the different areas Python is used in. Some people claim that Python is not suited for large projects because it's not statically typed, but a) experts no longer agree that static typing is necessarily a beneficial aspect to have in a language, b) there are a number of big projects using Python (SciPy and Zope come to mind; Mercurial is another one; SAGE most definitely qualifies; and there are more that you can find within [this list](http://en.wikipedia.org/wiki/Python_software)) http://stackoverflow.com/questions/35753/is-python-good-for-big-software-projects-not-web-based gives some good commentary on this subject The 'simplified' point just makes me laugh -- has this person ever programmed in Python seriously?!? Python makes it easy to implement things quickly, and that is partially because the core syntax *is* simple; however the actual amount of functionality available through that syntax is huge -- I've been using Python for 10 years and I, for example, this week discovered that it's possible to store some of your library modules in a non-Python format (whatever you want,really) and use import hooks to compile that into a working Python module. The practical simplicity of use of Python boils down to this: *the language is simply good at getting out of your way*, so, you tend to not need to think about aspects of the language that you don't use. IMO, If you want to really learn what Python is and isn't good at, going through a tutorial such as Dive Into Python 3 (you can find a link on the sidebar) is the only real solution; you can only discuss so much before you need to test things out, to get a feel for how they actually work in practice. 
It's cool I've been reading the py.test docs. and it looks like there's some good stuff there. I really just wanted to see if 3KWA was capable of elaborating since the comment was rather vague and certainly not worthy of all the upvotes it got(IMO). 
BTW, the second link in [my previous comment](http://www.reddit.com/r/Python/comments/r12c6/how_do_i_play_pythonbased_games_from_sites_like/c4276rt) goes into much more detail on the difference between static and dynamic typing than I do here.
No worries, its fun to explain too :)
Meanwhile mathematicians are laughing because the very nature of programming is mathematics, and arithmetic is probably the least interesting part.
I note the humour and well-intentioned sarcasm in your reply. I was curious if true "commercial" (ie, closed-source). desk-top apps are possible with python. Perhaps I should have re-worded my question. :)
I'd agree with this. We also need to remember that we really are doing discrete math. So in order to full understand the math involved (minus the basic operations) is discrete.
this particular example also requires you know enough probability theory to realize that you can't replace a 2d4 with a random value uniformly distributed between 2 and 8. which i've seen done in simple dice rollers. "X is all you need to know" is well and good when somebody who knows X+Y is there to tell you that Y isn't relevant.
"you can't replace a 2d4 with a random value uniformly distributed between 2 and 8" As far as I can tell, this is false. Can you please elaborate on the reasons you say that?
A friendly note, a better place to post this type of question might be http://www.reddit.com/r/learnpython
Not to mention that Adium is written in Objective-C, not Python.
Are you using matrix operations? Are you trying to do some enterprise speed calculation? Use a library then! Otherwise, why not instead just use a set of tuples. `set()` will be the matrix with all `False`s. To set something to true, just add it to the set. Maybe `True` and `False` aren't enough, so use a dictionary where the keys are the nonfalse elements. names = {(1,2): 'George'} Then you can test `(1,2) in names` or names.get((1,2)). The burden of keeping the values within the square limits should be on the user, not the datatype, but if you want many of these things floating arround, you can even make your own class that extends `set` and enforces the limit.
When you say *advanced math*, what do you really mean? Numerical analysis? Integral transforms? I'm having a hard time understanding what kind of "advanced math" one could be led into thinking is required for programming. Algorithms?
It's not what you know. It's how you think. You don't need to *know* math, but you have to be able to do it. Mathematicians (at least, math students) follow rules and manipulate symbols in a legal way to get their desired result. Programmers do exactly the same thing, with different rules and symbols. They think about "what is this string of obscure symbols saying, and how can I manipulate it to make it do something useful". It's the logical, systematic outlook that's important, not just the theorems. Of course, some mathematical knowledge is important if you are modelling any non-trivial systems. But as long as you know how to do math, you can just look it up. 
Because there are multiple ways to get 5 (4+1, 1+4, 2+3, 3+2), but only one to get 2 or 8 (1+1 or 4+4, respectively), you're far more likely to get a 5 under 2d4 than a 2 or 8. Whereas you're equally likely to get each number with a 1d7.
Nice diagram, easy to understand. +Upvote.
The streaming API can generate incoming traffic in excess of 1MB per second. You are probably missing a whole shit ton of tweets with a typical consumer level internet connection and processor setup. You will need to decouple your code so that the tweets are not parsed in the main event loop for receiving the tweets. You are going to miss a lot otherwise. Even when you do that, you'll not likely to be able to keep up without some fairly significant hardware.
&gt;Javascript's 'this' can be used to implement traditional forms of object oriented structures fairly easily. You can build object systems based single inheritance, multiple inheritance, mixins, and probably other structures. I've even seen functional style, multiple dispatch systems though I am not familiar enough with that style of programming to fully understand it. From what I've seen, this has nothing to do with JavaScript's weird `this` semantics, and more to do with the fact that it has lexical closures. Scheme, for example, if often touted for having all of the same things, yet it does it all without the weird `this`. &gt;I think the use of this to refer to the button makes sense and saves you from having to look up the function signature every time you write handler or callback code. Except `this` could be bound to anything, so you still have to look up what they're binding `this` to. Since it isn't an explicit parameter, there's a good chance the documentation will be hard to find, if it's documented at all. &gt; Another powerful use of 'this' in a functional context is for providing access to a large number of variables to functions will normally use a subset. Yeah, the "globals" object. You can do the same thing with an explicit parameter. If the JS convention is to have `this` be the globals-object, then the sane-language convention could be to have the first parameter be the globals-object.
&gt; Javascript's 'this' and fun.call/fun.apply is actually quite unique and powerful once you grok what's going on. All they've done is take one parameter and make it behave in a different way from all of the others. It isn't any more powerful than just having an explicit parameter, it just makes a lot of things much more clumsy than they could be. I'll give you the fact that it's unique, though I'd argue that there's a good reason no other language does it that way.
Yeah, but everything can easily be de-compiled, right? I thought that's how cracks and mods for software are made. The only you can do to keep your code a little safer is to make it is hard as possible to get it, but it's never impossible.
Sorry about posting in the wrong sub-reddit. Didn't know [/r/learnpython](/r/learnpython) existed. Here's the finished product: print "Prime test." print x = input("Enter number for prime test: ") print y = 1 z = x % y w = 1 while y &lt; x - 1: y += 1 z = x % y if z == 0: print "Divides by:" print y print else: w += 1 if w == y: print "Prime." else: print "Not prime." 
Yes you are correct, I will once again try this with code change. Thanks. 
no, .pyc are easier than assembler executable. .py -&gt; .pyc is mostly a lossless process which can be easily reversible, .c -&gt; .exe is not, it losses some information.
Lists are mutable. By using the flawed approach, you will not use copies but simply references to the same object over and over. If you really need 2D arrays, you might want to analyze your requirements further. If it's matrices you want, consider NumPy. The reason this is difficult to do with lists is that nested lists are likely the wrong way to do this in Python.
No explanation? Besides, I don't care much about the VM as about the language, and Java is ages behind Python in that regard. Also, PyPy is coming along nicely.
[This link](http://stackoverflow.com/questions/5497399/can-exe-generated-by-cx-freeze-be-completely-decompiled-back-to-readable-python) seems relevant. TL;DR: CX Freeze and py2exe store the PYC version of your code. Currently there are no working viable PYC decompilers that will give you the actual Python source code. The low-level code stored in PYC is hard to analyze.
[He wrote today about it.](http://www.paulgraham.com/speak.html) &gt; I'm not a very good speaker. I say "um" a lot.
I've been using [workflowy](http://workflowy.com) ASCII maths diagrams are my new favourite thing.
Very much this. Math departments seem very geared to teaching math majors rather than the various fields that require math.
It's funny, I absolutely agree that math should be a prerequisite for programming. There's a certain structure and ordering of things that one gets from STEM classes. There's a joke among physicists, what kind of job is a physicist suited for? Any. That's saying once one understand how to break apart a problem logically and analyze it, there's no limit to what the brain can produce. Everything becomes another math problem. If it wasn't for my math prereq for computer science, I wouldn't know where I'd be today. I originally majored in CS and had to take some prerequisite math classes. Calc I, II, and an optional class. After taking calc II, I had such an appreciation for mathematics, I took every math course the college offered. Which led me into chemistry and physics. I eventually got a AS in CS and a BA in mathematics. Even after all that math, I still do programming as a profession.
For certain values of "programming", some amount of type theory is also quite useful. Understanding f.x. the variance annotations in C#.
Thank you
You question doesn't have anything to do with `copy.copy`. Consider this: &gt;&gt;&gt; a_list = [] &gt;&gt;&gt; for i in range(3): ... a_list.append(lambda: i) &gt;&gt;&gt; print [fn() for fn in a_list] You will see [2, 2, 2] because the lambda doesn't capture the *value* of `i`, it captures the *name* and evaluates it when you call the lambda. And since all three lambdas refer to the same `i`, they all see the current value, which is 2. The usual trick to make lambdas "freeze" the value of your free variable at the time of definition is to use default function arguments like this: &gt;&gt;&gt; a_list = [] &gt;&gt;&gt; for i in range(3): ... a_list.append(lambda i=i: i) &gt;&gt;&gt; print [fn() for fn in a_list] [0, 1, 2] 
Interesting. It is too bad Dave didn't give us a glimpse of that perspective as well. I came away with the impression that PyPy is some sort of fell magic that I use to make my programs faster but dare not touch.
Maybe because copying and pasting random modules leads to difficulties when you later have to maintain them?
Also, at least in 10.7 (and I think 10.6) multiple versions of Python are actually already installed. Look at `ls /usr/bin/python*`. I still prefer having completely separate interpreters installed with MacPorts though, so I can ignore the possibility that an OS update will break something.
The most interesting thing in this presentation to my mind was the comparison of CPython and PyPy's memory use when multiple processes are running the same code. It would seem PyPy will save gobs of memory for a typical web server running the same application with several python processes.
I've actually tried to write a D&amp;D simulator and it's harder than you'd think. The part where things get tricky is when you try to set up a reasonably intelligent AI. Of course, you want the NPCs to be able to figure out when they're out of their league so that they'll start running away. But just looking at relative levels isn't good enough. A first level half-orc fighter with 20 strength and heavy armor is so ridiculously overpowered that even animals should be smart enough to run away. How do you determine the danger of an opponent? By combining probabilities in a simulated fight. In any given fight, you usually know who will attack first as soon as both opponents are aware of each other. Let's say the half-orc will attack first, and you're a goblin. There's a chance that he misses (so damage is 0) or there's a chance that he hits and rolls 2d6+7 (included in the chance to hit should be the chance of a crit for 4d6+7). So, you create a weighted probability table where you assign the likelihood of each amount of damage dealt. This is a little bit tricky, so I'll explain the process. Just take things a step at a time. How much damage will 1d6 do? Okay, now you make a table where you count how many ways you can roll the dice to end up with each possible outcome. table_1d6 = {1:1, 2:1, 3:1, 4:1, 5:1, 6:1} What this means is that there is exactly one way to roll a six sided dice to end up with each of those possible outcomes. The keys range from 1 to 6, but the values are all 1, so they're equally weighted. For a 2d6 table, you say "table_2d6 = {}. For each key 'K' on the 1d6 table, and for the values 'V' 1 through 6, get K+V then verify that this number is on table_2d6. Then, at table_2d6 [K+V] add table_1d6 [K] to indicate the number of ways of reaching this outcome." You can repeat this process for 3d6 and so on. You're basically just adding up how many different ways you can get to the same result, and then using that to determine the likelihood of the results. Okay, so now we that can handle combining probabilities, we can go ahead and see how to do a few other things. To attack, you roll two d20 (Why? Because you might need to know if you got a crit.) Build a table based on your opponent's AC. You have three possible outcomes - miss, hit or crit. Your keys would be 0 (for miss), 1 (for hit) and 3 (for crit, assuming you have a crit x3). You have 400 different ways to roll the dice to get these outcomes, so you need to assign the likelihood of each outcome. With this table, you can now build a table which combines your attack roll with the damage rolls for a hit and a crit. Very quickly, in just one attack, the number of possible ways to roll the dice have spiraled out of control. If you were attacking with a scythe (2d4 damage, x4 crit), there are now 26 million ways you could have rolled the dice, but the amount of damage that you can do is limited to a tiny table with just 32 outcomes (0 if you miss, 2-8 for a hit, 8-32 for a crit). When you need to add two attacks together, you follow essentially the same procedure as adding dice together. The only difference is that now you need to multiply instead of just adding. If you look at the informal code three paragraphs before this one, just change that last sentence to say "Then, at table_2d6 [K+V] add table_1d6 *[K times V]* to indicate the number of ways of reaching this outcome." To see why you do this, imagine you have a biased coin which you flip twice. If your results on flip have the following probability: {heads:3, tails:1}, then the results on two flips will be {two_heads:9, two_tails:1, heads/tails:3 tails/heads:3}. You multiply because the second coin toss offers extra probability of some outcomes. You can repeat this process, making attacks, assessing the odds of death, missing, hitting, and making a crit and so on repeatedly until you pass some threshold. For example, you might say that when you reach a point where the defender is more likely to be dead than the attacker, and at least 90% likely to be dead, then you've determined that the defender will most likely lose. You could adjust the exact percentage based on how much risk the NPC might be willing to take. Before a fight starts, you just do this evaluation and let the NPCs decide to either run away or stand and fight. It gets more complicated still if you want the NPCs to avoid cheating. In that case, you need to decide how visible attributes are. Strength, for example, usually means big muscles. An NPC with a decent spot check ought to be able to guess strength, and a better spot check ought to get closer to the right answer, and with less uncertainty. Based on how the opponent moves, the NPC ought to be able to guess their dexterity. Based on armor and weapons and the guesses about attributes, the NPC should be able to build a probability table of the opponent's attack bonus, damage bonus, armor class, hitpoints and so on. This has the added advantage of making illusory armor and weapons potentially threatening enough to scare NPCs away. Players could also use this method to evaluate the danger of fighting NPCs, but with all of the same vulnerabilities to illusion magic. Does that basically answer your question about why random numbers aren't good enough?
I use homebrew when i use my mac. i got tired of macports. for different versions i call them explicitly with the shebang. #!/usr/bin/env python2.7 #!/usr/bin/env python2.6 #!/usr/bin/env pypy #!/usr/bin/env python3 etc 
I have multiple python versions (2.5, 2.7, 3) on OS 10.5.8 using [ActiveState](http://www.activestate.com/activepython). 
[someone](http://stackoverflow.com/questions/1933766/fonts-clipping-with-pil) else had this problem
You might want to give [pythonbrew](https://github.com/utahta/pythonbrew) a shot! It's very easy to manage multiple pythons. If you have used perlbrew, then it is basically the same concept. pythonbrew install 2.7.2 The best part is that you can test code against all the versions of Python you have installed. For example: pythonbrew py test.py 
Seems a lot like [RVM](http://beginrescueend.com/), which is a *really* good thing.
You can switch between your default version with macports as well. Use a command of the form (sudo) port select python python25
&gt;You don't even need to be open source for this to be a problem. This can be a problem in 100% closed-source apps as well. exactly.
In general I think the answer is "a cross-compatible code base is going to look worse than one that is not cross-compatible". This indeed sucks. That said, without any major sea changes in Python core developer intent, if we want Python to continue to be relevant in the future, I don't think we don't have much choice; it's Python 3 or bust. Bust is not out of the question eventually, but I think we should give it our best shot before giving up. This means accepting a codebase that is at least slightly less pretty than it could otherwise be and coding in a kinda shitty subset for some period of time. You might or might not already know about [six](http://packages.python.org/six/), which is another library that does what you're trying to do. 
macports will both break the default python instalation and also by default install non framework versions of python wich will pretty much not work well with gui and osx native stuff. Stay away from macports if possible, homebrew and the default python are much much better (default python has dtrace support for example)
Maybe the truth lies in the middle: PyPy source is cleaner, but it could be made more approachable that it is today. Having new contributors only prove that it is not impossible to learn, but maybe with some effort it can attract many more people.
Python 3000 FAQ by Guido van van Rossum Q. I prefer to use the same source code for 2.x and 3.0; I really don't want to have to use the 2to3 source conversion tool. Why can't you make that work? A. Suit yourself. The intersection of 2.6 and 3.0 is large, but there are several things you can't do: you can't use Unicode literals (2.6 only), nor bytes literals (3.0 only). The only print syntax that works the same in both versions is print(x). When you catch exceptions you can't inspect their values, because the 2.6 syntax uses , while 3.0 uses as. You can't use .iterkeys(), but .keys() works differently in 2.6 and 3.0. You can't use xrange(), but range() works differently. You can't use metaclasses, as the syntax for specifying a metaclass is completely changed in 3.0. And so on. **Restricting yourself to the intersection of the two versions is very painful and limited.** We're not introducing backwards compatibility syntax in 3.0, because that would defeat the purpose (we've had backwards compatibility forever in 2.x, and the whole point of 3.0 is to clean up the mess). Disclaimer: I'm not much of a python programmer and still use 2.6. 
None of what this person says about MacPorts is true. https://trac.macports.org/wiki/Python#PythoninMacPorts
1) use [six](http://packages.python.org/six/) 2) yes, this is somewhat painful. Requiring python 2.7+ helps. There are essentially three general porting strategies: 1) develop in py2, but in such a way that 2to3 creates a meaningful py3 version 2) run 2to3 once, and maintain two seperate branches 3) use six and use the intersection between the two languages See also: [the python 3 porting guide](http://python3porting.com/)
Note Guido stepped back from this position in his PyCon keynote.
I think both pypy can be made more approachable *and* pypy approach simply does not work if you don't do TDD. With stuff like GIL, you actually *don't touch* the interpreter by one bit. It's both a beauty of design and a problem if you want to just jump in. This piece can definitely be documented better.
I don't know a better way than these hacks personally but in the example you provided are you in essence checking the python version each time you call the function? If so there is a better way to do it. I'm on my phone so I won't type it up in case I misunderstood your example. 
Is there any reason you're not using 2to3? It's designed to solve precisely the problems you describe. You can easily enable 2to3, if your code is already reasonably packaged: just add `use_2to3=True` to your `setup.py`, and it will be applied during installation for 3.x. ([documentation](http://packages.python.org/distribute/python3.html)) Once you've done this, you probably want to automate testing under both 2.x and 3.x: [Tox](http://tox.testrun.org/) is a good tool for this. See Kumar McMillan's tutorial: [Supporting All Versions of Python All The Time With Tox](http://farmdev.com/talks/tox/).
So, I've been subscribed to this since it first came out--it's really great. As far as I know, this is the second python weekly newsletter out there. They essentially include a lot of stuff: * New open source python projects that look cool. * Articles related to python stuff. * Discussions about python topics (and links to proggit as well). Overall, it's a really nice newsletter to get every week. I've discovered several really neat python projects through it :)
I've never experienced any kind of breakage like you describe, and I've been using MacPorts since before it was called MacPorts.
Sadly I already reviewed that thread. Nobody reports a python 3 solution. Did you read the link?
&gt; Scheme doesn't have objects, so I'm not sure what you're referring to... http://community.schemewiki.org/?object-systems &gt; When using good libraries, I have never had a problem with figuring out what 'this' refers to. Only by convention, not by a language feature. What's to stop a similar convention from being used in other languages? &gt;&gt;Yeah, the "globals" object. You can do the same thing with an explicit parameter. If the JS convention is to have this be the globals-object, then the sane-language convention could be to have the first parameter be the globals-object. &gt; &gt;Of course you can, but I find that to be ugly and inconvenient. Python's explicit "self" parameter is one of its more annoying design decisions. It's always specified and always called "self," so having to write it over and over is just a waste in my opinion. I know "explicit is better implicit," but a self keyword would serve the same purpose. For methods on objects I can see your point. That isn't what we're talking about here, though. We're talking about passing an "environment object" to your callbacks. Using `this` for this purpose is kind of perverse. I'd muck rather have it be named something like "`env`" or "`request`" or something... descriptive. It's also kind of funny that you make the argument against explicit `self`, and for an implicit `this` when javaScript is only half-way implicit. It's implicit only in function signatures: you're going to get a `this` parameter (whether you want one or not) without typing anything. It isn't implicit when one method calls another, however. For example: int method1() { method2(); } int method2() { return 42; } in C++ or Java, the `method2()` invocation calls `method2` on `this`. The equivalent code in JavaScript would require that you actually spell out `this.method2()` explicitly. JavaScript can't even decide whether `this` should be implicit or explicit. &gt;What is so "weird" about 'this,' except that it doesn't work like 'self' and 'this' in other programming languages? Erm... "doesn't work like everything else" is pretty much the definition of "weird". I think what you're really asking is why I don't *like* its weird semantics. (FWIW: I don't mind things that are "weird" if they're actually better than the alternatives...) One reason I don't like the JS `this` semantics is WTF-ery like this: &gt; var x = "wtf"; &gt; x "wtf" &gt; var o = {x: "ok"} &gt; o.f = function () { return this.x; } function () { return this.x; } &gt; o.f(); "ok" &gt; (o.f)(); "ok" &gt; var g = o.f; &gt; g(); "wtf" If factoring out a sub-expression yields different results then your language design is broken, end of story. Also annoying, the way `Function.apply` has `thisArg` as a separate parameter. Since JS binds `this` like an implicitly passed parameter it should be an element of `argsArray` like all of the other parameters. Then there's the way functions in JS are written with the intent that they be called in only one of three possible contexts (`Date` is an interesting counterexample): - function call. Expects `this` to be the "global object". Often doesn't even want `this`, but too bad, you get one anyway. - method call. Expects `this` to be the object it was called on. - constructor (ie: `new` operator). Expects `this` to be a newly constructed object. Calling as a function is likely to bork global state. Returning something is allowed, but pointless. ...but the language provides *no way to state which context a function is intended for*. Invoking a function in the wrong way won't cause a runtime error, it'll just result in bad/broken behavior. So you end up needing to have conventions about what's supposed to be called in what way to work around the fact that the language doesn't give you a way to tell it what you mean. It's sort of like a grocery store that sells cheese and rat poison that both look the same, and in the same aisle. This is the same kind of fuzzy-headed design that resulted in `==` and the ability to call a function with more arguments than its definition allows.
couldn't make it make it passed "ruby gems" there's an npm for node.js, I don't need ruby in my build setup 
Going back to this since I'm now at a keyboard, from what I understand you've done this: def iteritems(mydict): if sys.version &gt;= (3, 0): return mydict.items() else: return mydict.iteritems() Were I in your situation, I wouldn't even bother with this for a couple reasons: - Python 2.x supports the dictionary.items() call and returns a list of tuples so you can iterate that like [1] Note that this also works in python 3. - If you're insistent upon doing it your way, you can do [2] Because this should improve your performance minimally. You define a function but ignore the control statements. [1] for (key, val) in mydict.items(): print "{0} =&gt; {1}".format(key, val) [2] if sys.version &gt;= (3,0): def iteritems(mydict): return mydict.items() else: def iteritems(mydict): return mydict.iteritems() **Edit** Damned markdown doesn't like mixing code blocks inside of bullets. Had to 'footnote' them for proper formatting.
&gt; This is a huge pain in the ass, as python3 has some stupid differences. For example, you can't call iteritems() on a py3 dict, as items() now assumes the behavior. Just call `items` on both? Sure, it's operationally different, but is that your major performance bottleneck to the point where the distinction matters?
Based on your comment, I'm subscribing too.
What's the other one? Is it any good?
That could be a step forward. I find it a little bit scary to be using an automated tool to convert my code. I'm thorough with my unit tests but it seems to be a scary extreme to start writing unit tests to account for ways in which automated conversion could go wrong. Or, at least, that's my fear right now.
Heroku Toolbelt is a simple way of installing all of the Heroku dependencies, and it's available for Linux, OSX and Windows. From what I understand it sets up it's own Ruby interpreter and uses that internally. https://toolbelt.heroku.com/
To me it seems *off* to favor the old version. From what I hear, the gripe usually goes "oh, I can't move to 3.x yet because nobody's using 3.x yet because nobody's using 3.x yet."
It may be "off", but it's the best way to do it as long as dictionary iteration isn't the central point to your application. I'm not saying the suggestion is without fault, because it operates slightly different, but it's not likely to change what you're actually doing.
If you can get it all done in one SQL statement, you should be OK. The trouble come when two assignments are happening simultaneously. Say A is 10, and you try to subtract 5 and 3 at the same time. If the variable isn't locked, you can end up with one thread setting it to 5 and then the other thread setting it to 7 because both threads were subtracting from 10.
&gt; A nice compromise would be something like: `from __future__ import dict` This is effectively what 2to3 gives you, for all the the language features it handles: it lets you stick to writing idiomatic Python 2 (`iteritems()`) to be turned into semantically equivalent Python 3 (`items()`).
Barter systems aren't illegal in the US. It's just that they are taxed and regulated like any other form of contractual trade. 
doesn't PIL not really support python3 at the moment?
Minor improvement: if you're only working with builtin dicts, you can use unbound methods and avoid the unnecessary Python function call cost: if sys.version &gt;= (3, 0): iteritems = dict.items else: iteritems = dict.iteritems This doesn't work if you have to support dict-like classes via duck typing, of course.
I think the only reason you *wouldn't* trust an automated tool was because your testing was *not* thorough.
yeah sorry, was in a hurry! anyway, im just saying that here on their website: http://www.pythonware.com/products/pil/ they do not list a python 3 version, and are saying that it will "come later", so i was just thinking you were using an unofficial port (probably through 2to3) that is having some problems like you are experiencing
This link makes me glad I'm using webfaction ;-).
Ah, thanks. Yeah, I should have double indented before getting annoyed.
Give a look at: https://github.com/luispedro/imread/ 
2to3 does that because it is a very conservative script, and it doesn't know if you're going to be using it as a list or not. You can use your own judgment.
Yeah, I hear you. The reality is that we're going to be developing cross-compatible software in that subset language for about 5-6 years. And that blows. But the alternatives (maintain 2 branches, drop 2.X compat entirely, don't support Python 3, switch to a different language) are all marginally worse. Over the next 2-3 years, one or more of those alternatives may become more attractive; in the meantime, right now, how you're doing it seems to be the least worst option.
Thanks for taking the time to post this review - very helpful - I'm definitely going the check the book out now! Also, next time - just do whatever you want - posting it to reddit like this is great, as far as I'm concerned.
It depends what the goal is. I would guess the goal is to not reveal some algorithm. As in someone taking it, tweaking it and then re-releasing as their own. In that case if you compile C, it will be quite hard for them to look at assembler and figure out the details. While decompiled Python code looks very much like the original. So the level needed to reverse engineer goes from 14 year old script kiddie to seasoned professional engineer.
CoffeeScript doesn't fix JavaScript, it just gives it a slightly less verbose syntax. The behavior of the language is identical under the hood (obviously, since it compiles to JS). Furthermore, CoffeeScript introduces strange ambiguities that require you to look up their operator precedence rules. What happens when you want to pass the return value of a function call as a parameter to another function? func1 func2 "foo" To someone that doesn't know, this could be `func1(func2("foo"))` or `func1(func2, "foo")` or even (depending on the context) `bar(func1, func2, "foo")` (where bar is a function that you didn't see on first glance). I'll probably get downvoted for this, but frankly, CoffeeScript is a tool for your average hacker that just wants to type fewer curly braces (or the word "function"). It doesn't fix or change [any of the major problems with JS](http://wtfjs.com), it just masks them over with some "cool" syntax/candy.
Threading. If I weren't on my phone I would elaborate. 
&gt;Only by convention, not by a language feature. I am fine with conventions. Python's version of private variables is based on convention, for example. &gt;Also annoying, the way Function.apply has thisArg as a separate parameter. Since JS binds this like an implicitly passed parameter it should be an element of argsArray like all of the other parameters. Why? It has a totally different meaning than the other parameters. If you want consistency, you can use fn.call obj, arg1, arg2, etc. &gt;* function call. Expects this to be the "global object". Often doesn't even want this, but too bad, you get one anyway. &gt;* method call. Expects this to be the object it was called on. &gt;* constructor (ie: new operator). Expects this to be a newly constructed object. Calling as a function is likely to bork global state. Returning something is allowed, but pointless. In the default context (not inside a function). f() has the the meaning as f.apply(this) but inside a function, it does not. I agree that is piss poor language design and is the source of most of the other problems with 'this', like smashing the default namespace if you accidentally call a constructor as a function. I rarely run into this problem in practice, but it's certainly very stupid. EDIT: it's worse than I thought. I think I may have concede this point. The way 'this' is handled with naked function calls is downright asinine. The second two are conceptually the same thing, except 'new' passes in an empty object. That doesn't seem like an issue to me. Python does the same thing with \_\_init\_\_(self). &gt; This is the same kind of fuzzy-headed design that resulted in == and the ability to call a function with more arguments than its definition allows. I agree on the first point, but *arguments* isn't that bad. It's not as convenient as default arguments, \*largs, and \*\*kwargs in python, but at least it's better than Java. Javascript is far from perfect, but I see way too many programmers attacking it without understanding it, myself included until recently. You seem to know what you're talking about and I think your opinion is totally valid. Now that I am using it more often, I actually enjoy its semantics, but I use coffeescript about 50-60% of the time, so most of the warts annoy me less than someone stuck in raw javascript. IMO, browsers should develop a standard bytecode for the web, so that we all could use your favorite language and this whole discussion would be moot.
There's a much longer and much more complicated explanation out there, so there's no single best answer, but here's a brief example: from threading import Thread def thing1(name): print 'hi', name def thing2(): print 'hello' Thread(target=thing1, args=('PatAunches',)).start() thing2() Try it out! On my system, I get: hihello PatAunces which is jumbled, but the jumbled-ness speaks to the fact that both functions are happening at the 'same' time. (In order to avoid this, look into using the 'with' statement and threading.Lock) What graphics library are you using to make the menu?
All the math is done on the DB so it should all be serialized. Here's what I'm doing in Django: Account.objects.filter(pk=destination_account.pk).update(amount=F('amount') + amount) Account.objects.filter(pk=source_account.pk).update(amount=F('amount') - amount)
Why shouldn't they be? History departments are geared to teaching history students, and so on.
It was an off-the-cuff remark about the jargon and how rarely it cropped up in real-world coding. You can tell the man is a fairly talented developer. "Now I'm just glad I don't have to work on a code base with the speaker." was rather an overreaction to a flippant comment.
&gt;there is an incredibly high correlation between good at programming and being good at math This is true, though it's worth noting this works both ways. Ultimately, I think maths should no more be considered a prerequisite for programming than programming is for maths. They both can serve to reinforce each other. I was programming *long* before I came across algebra, and being familiar with the notion of variables etc probably served as much to help me grasp the mathematics as learning it the other way round would. &gt;Graphical mathematics (geometry, trigonometry, calculus) are admittedly less important (though certainly help) for most programming domains. Though it's actually a pretty important problem domain for some practical educational reasons. If you want to get someone *interested* in programming, teach them to do something cool. And graphics are one of the easiest ways of doing so (or at least were when I was growing up - possibly web programming has taken some of this domain these days.). A lot of the coding I did back in school was noodling about with neat graphical tricks, which provided reason to be interested both in mathematics and programming. There's a lot of benefit to be derived from seeing some concrete *use* of it all.
I disagree with this article. You can program a fair deal without maths, but the code will suck for the most part. For example, you shouldn't always use the same two data structures, but learn about others and their time/memory complexities. Also, this attitude is not going to get you far: &gt; 3D games and 3D graphics – 3D stuff will usually involve knowing trigonometry and linear algebra (that is, math dealing with matrices). **Of course, there are many 3D graphics libraries that implement all this math programming for you, so you don’t need to know the math.** You absolutely do need to know the math if you want to reach your goal in any other way than some sort of guesswork or copying of tutorial code. 
&gt; For example, how could I play a song from within my program, and still be able to navigate menus? You don't need multiple processes or multiple threads for most of these problems. The traditional way to handle this was as follows: while 1: play_a_bit_of_a_song() check_for_UI_changes() In fact this is still how most games handle networking, audio, AI, input, and graphics - just interleave them.
The original was written in Cython. &lt;https://github.com/reddit/reddit/blob/master/r2/r2/lib/db/_sorts.pyx&gt;
&gt; sign = 1 if s &gt; 0 else -1 if s &lt; 0 else 0 one of those days where Python is not the most readable I think.
 if s &gt; 0: sign = 1 elif s &lt; 0: sign = -1 else: sign = 0 Is that more clear for you?
Looking forward to reading this! I've been really enjoying following along!
What is it? a blog engine?
 (s &gt; 0) - (s &lt; 0) :P Edit: fixed typo. I tested it in my console window and copied it down wrong somehow instead of copy-pasting. Either that or I somehow read an incorrect test result as a correct one.
dude that's even less readable though quite beautiful to look at :)
Glad you're enjoying it! Thanks for following the series :)
Perhaps a recent submission like [this one](http://www.reddit.com/r/Python/comments/r4yoc/mynt_v02_now_with_a_default_theme_and_init_watch/): mynt.
This is one of those cases where classes are a good idea. Especially since you can overload operations.
I should have just copied it straight from http://docs.python.org/release/3.0.1/whatsnew/3.0.html : &gt;(If you really need the `cmp()` functionality, you could use the expression `(a &gt; b) - (a &lt; b)` as the equivalent for `cmp(a, b)`.)
I use Blogofile for at least five sites including my own blog and IMHO it is the simplest and most well designed and easily extensible static generator for Python.
Might check out Pelican. My co-founder did a post on it here: http://wadefoster.net/creating-a-blog-in-python-hosted-on-github-using-pelican.html It seems pretty straightforward (though more blog based).
Tried messing around with blogofile, but it appeared to be quite dormant (old version without features, new version annoying in that it required Python 3). Finally committed treason and went with Octopress. After the initial install it doesn't matter that it is written in Ruby cause I'm using the command line rake controls. 
I like [poole](https://bitbucket.org/obensonne/poole).
&gt; I read it as pure english Best way to read python. 
&gt;&gt; Also annoying, the way Function.apply has thisArg as a separate parameter. Since JS binds this like an implicitly passed parameter it should be an element of argsArray like all of the other parameters. &gt; &gt;Why? It has a totally different meaning than the other parameters. If you want consistency, you can use fn.call obj, arg1, arg2, etc. The purpose of `apply` in languages that have it is to let you take a collection (or two, if keyword arguments are supported) of arguments and pass them to a function. `Function.call` can't do this. So you're left with having to store the value for `this` alongside your collection of arguments. This isn't a huge issue, it's just yet another irritation with the way `this` works in JavaScript, and it kind of compounds with the fact that `object.method` doesn't bind `object` to the method's `this`. &gt;The second two are conceptually the same thing, except 'new' passes in an empty object. That doesn't seem like an issue to me. Python does the same thing with `__init__`(self). Yes, I agree that the `new` case and the method-call case are closely related. The differences in Python are: - It's 100% clear when you're writing a constructor or a method versus a normal function. A method is in a class definition, and a constructor is a method called `__init__`. In JavaScript all three cases look identical. - In Python it's kind of hard to accidentally call a method without passing the self parameter, or to call `__init__` at any point other than during construction. &gt;Javascript is far from perfect, but I see way too many programmers attacking it without understanding it, myself included until recently. You seem to know what you're talking about and I think your opinion is totally valid. Yes, there are a lot of people who dislike things just because they don't understand them, and so it makes sense to assume that someone who doesn't like a programming language has that opinion due to lack of understanding. Before I knew it well, I used to think JS was just misunderstood (as Python often was, years ago). As I used it more and stumbled over its crazy `this` semantics and many other annoyances, and eventually learned the intricacies of how they work my contempt for it grew. My feeling is that a language that intentionally makes things hard to understand without actually providing some benefit isn't worth using. "Don't be weird unless the weirdness makes you better." Much of the weirdness in JS is there for no good reason, and much of it is actively bad. &gt;I use coffeescript about 50-60% of the time, so most of the warts annoy me less than someone stuck in raw javascript. I've heard mostly good things about coffeescript, so I'll have to check it out the next time I need to do in-browser coding. &gt;IMO, browsers should develop a standard bytecode for the web, so that we all could use your favorite language and this whole discussion would be moot. Agreed. JavaScript should just be another language that runs on a common browser-VM.
That's not ambiguity. It works in a particular way and it is predictable. It's better than the JavaScript syntax gotchas anyway. The optional parenthesis work like they do in Ruby and Haskell. It is intuitive if you think about it like this: whitespace is the function call operator and comma with optional whitespace is the argument separator. Anyway, thanks for giving me a list of problems with JavaScript so I can demonstrate how CoffeeScript fixes things. I'll take a look through the first few pages. "all your commas are belong to Array" and "i am myself but also not myself" are fixed in CoffeeScript because it's not possible to produce a ==. It gets replaced with ===. One thing I've found from most of these WTFs is that if you never use the == operator, the number of WTFs out there is significantly decreased. The rest of them work as I'd expect them to. "min less max": works as I'd expect it to, and it's not really a core language problem if one function doesn't do what you'd expect because you can write your own functions. "convert to integer": Not sure what is so strange about this one. Couldn't repro "ie 754" or "eval changes". "im not a number really": First one makes sense. CoffeeScript fixes the second one. "Magic Increasing Number": Floating point precision problem. Exists in other languages. "false advertising" I was just experimenting with this one last week. Pretty weird, yes. This weirdness still exists in CoffeeScript, even in classes, but it requires an explicit "return" statement, so it wont happen by accident.
I saw that post, which is what got me looking into static site generators in the first place.
I like everything about you so far.
Ah very nice, thank you!
I've moved the overview page back to being the front page.
Looks cool. Does "serve" use CherryPy behind the scenes? Is there an example site anywhere? I'm curious what the default site looks like.
I wouldn't learn that way, because it is *too* big. I would pick a web framework and work up from small examples. If you want to use the same web framework that reddit uses, look at small Pyramid (reddit was built with Pylons, which was re-branded) examples. Reddit itself is just too big, though.
Thanks for the correction. I've never used Pylons or Pyramid, so I'm mostly talking out of my ass. I only suggested it because I knew they were somehow related.
I think [scraper.py](https://github.com/reddit/reddit/blob/master/r2/r2/lib/scraper.py) is a pretty interesting read. It's the code that creates thumbnails and embedded videos.
Use [nanoc](http://nanoc.stoneship.org/), embrace the polyglot.
I use my own. Probably is not good as all others but works for me.
Could you elaborate on the ways that you found Blogofile to be annoying?
[rstblog](https://github.com/mitsuhiko/rstblog) is very simple but "does the trick for me". [Pretty straightforward rstblog howto](http://sbhr.dk/2010/11/30/using_rstblog/)
I've migrated my personal website from Zope 2 (Through-The-Web content with some dynamic bits) to Blogofile recently. So far I'm satisfied. I like that I can use Blogofile for websites that are not blogs. I like Mako templates that Blogofile uses.
TBH, full-blown applications are a bad place to start learning. A site as big as Reddit, with as many developer hours put into it, is not going to be straightforward. There'll be a lot of special cases, performance optimizations and stuff that was just cranked out in a hurry. We're talking about an application that has been designed to scale across hundreds of servers with multiple layers of persistence and caching. While all of these ideas are important to understand, trying to model any site that doesn't have *very similar* requirements after it would give you an overengineered mess. If you wanted to learn from Reddit, you'd be better off with a high-level block diagram explaining how the system works &amp; how the pieces interact than actually looking at any of the code.
I use my own as well. Definitely not as good as most others. I also wrote it so long ago that I've forgotten how it works. I remember that I was experimenting with plugins...
Is there a demo of it somewhere? I'd like to play around with it, if that's possible.
&gt; Can it be done with one program, for instance calling two functions at the same time? Yes &gt; Or do I separate the code into different programs, and have one call the other one? Depending on what you want to do, this strategy can be a good one or a bad one. As for the long answer, here it is. Depending on what you want to do, there are multiple ways to achieve multiple parallel execution threads. Depending on the situation, you might want to use threads (see [Threading](http://docs.python.org/library/threading.html)). Threads offer the possibility for a single process to have multiple parallel execution threads. Your program could literally run two instructions at the same time depending on your physical infrastructure (a multiple core CPU would do this for instance). Threads are great for doing multiple IO blocking calls at the same time. For example, you could have a thread waiting for a user input in your console (the common standard in or stdin), while another thread is writing on a socket. Threads are bad for parallel computation and for most other parallel use cases. Threads share the same memory space since it is the same process and could simplify the use of the same data in some cases. Because of the [GIL](http://wiki.python.org/moin/GlobalInterpreterLock), you are protected from having different threads modifying the same data at the same time (resulting in potentially wrong states) but you are also limited in the overall potential processing power you could extract using threads because the GIL is a blocking mechanism uses for many data structures that form the core of python. Depending on the situation, you might want to use multiple processes (see [multiprocessing](http://docs.python.org/library/multiprocessing.html)). Multiprocessing is almost a drop in replacement from Threading. You have multiple processes that are spawned from your main process that can share state by communicating between processes. Since communication is not free, you do have a cost when you want to share state or data between processes. Depending on the situation, you might want to use light threads or micro-threads based on Stackless or greenlet. I'm not that familiar with how they execute, but I'm sure you can find out. Depending on the situation, you might want to have your computation distributed on many different physical machines. In those cases, you will most likely need a good plan to execute it well. There are many pitfalls in doing parallel executions. You can have an execution thread which is waiting for another execution thread which is waiting for the first execution thread. You can find yourself in a deadlock situation which might be hard to diagnosis. You can have an execution thread which is not letting go of a resource that other threads need to use to complete. It is often a hard problem. There are multiple models to view the concurrency problems and solve them in an elegant way. This include actor model, tuple spaces, remote procedure calls and many more. As of today, none of them have reached a status of [silver bullet](https://en.wikipedia.org/wiki/Silver_bullet). Parallel execution is a deep and interesting field of computer science. There are books, blogs, articles, reviews and a vast amount of resources about it. You can start by reading Operating System Concepts by Silberschatz, Galvin and Gagne. It was my reference when I was doing my degree. You can also have a look at the [concurrency page](https://en.wikipedia.org/wiki/Concurrency_%28computer_science%29) on wikipedia. I hope this can help you out.
Ah, mynt is a static blog generator. There are no admin pages or anything done via a web interface. Everything is done locally then compiled into a static HTML website that you then upload wherever you want to host it. As far as what it looks like, the mynt site it's self is using the default theme.
Haven't used it, but I know a bunch of [OSU OSL](http://osuosl.org/) people wrote and use [wok](https://github.com/mythmon/wok). Just mentioning for completeness.
The most interesting thing about this talk was the mention of Python on Android. Apparently, there are no technical barriers to adding a Python wrapper around the NDK (Native Development Kit).
The lead engineer of the original Reddit is actually instructing an online class at Udacity called "Web Application Engineering". Check it out, it could be exactly what you're looking for. http://www.udacity.com/overview/Course/cs253 
Saving this for later, fantastic find, thanks!
&gt; It works in a particular way and it is predictable. Not for a beginner. Even for experienced programmers that deal with lots of languages, it's going to require a lot of checks to the documentation. Even for experienced CoffeeScript developers, dense CS is virtually impossible to read at first glance because of its distinct lack of visual cues or "logical punctuation". &gt; It's better than the JavaScript syntax gotchas anyway. Like what? JS is verbose enough that you can't really make any big mistakes (aside from automatic semicolons...don't even get me started). &gt; it's not possible to produce a ==. It gets replaced with ===. Disabling a feature does not necessarily "fix" a language. Perhaps it makes the "default" syntax better, but this isn't something that's "broken" with JavaScript. The fact of the matter is, CoffeeScript **can't** be better than JavaScript in terms of being inherently less WTF, because at the end of the day, you're still writing JavaScript. It may have some handy things (list comprehensions, for one), but it still doesn't fix the problem(s) that JS has at the its core.
Nice write-up. The only thing you missed was using [subprocess](http://docs.python.org/library/subprocess.html)/popen to simply execute a separate program - probably the crudest of all the solutions.
OpenSuSE Tumbleweed, Python 2.7.2, mynt v0.1.7... OK, now I know what happened. I already had it installed (I was playing with idea of migrating my WP blog into it) and then I typed easy_install without watching. Fixed in now with -U and it works as it should. Thanks.
NodeBox http://nodebox.net/ is also very cool (and really doesn't get enough mention)
https://github.com/kracekumar/blaze, I am the author of it. 
How the fuck can people watch videos this long and not go crazy? I want a transcription &gt;_&lt;
I'm running out of reasons for not learning python 3. Congrats guys. 
You might like Haskell even more for things like this.
I don't know Pyramid but I'm looking at documentation right now but I don't understand this; class RESTView(object): def __init__(self, request): self.request = request @view_config(route_name='rest', request_method='GET') def get(self): return Response('get') Is there a specific reason why you need to explicitly define `request_method='GET'`? Shouldn't it be enough just to define a `get` function? I don't know, maybe I look at the things from Tornado/web.py perspective too much (I think Tornado/web.py approach looks more clean and simple).
Pyramid has almost no "magic". A method or function is just a block of code that may be called, then name or object it is attached to has no meaning. The "@view_config" decorator or declarative route configs is how the application server will map a request to the function or method.
&gt;Is there a specific reason why you need to explicitly define request_method='GET' You don't, but sometimes you want to. Like when you want that view to answer to only POST or PUT or DELETE, if you don't specify request_method, then the view will answer to any HTTP verb. which is what is called in the biz "a sane default" :) It might help to start at the beginning of the docs. And evaluate without the django goggles(unless you want to be disappointed). 
It is not my intention to hijack this thread, but being a n00b, I'm curious is there an equivalent to this in Django? from pyramid.view import view_defaults from pyramid.view import view_config from pyramid.response import Response @view_defaults(route_name='rest') class RESTView(object): def __init__(self, request): self.request = request @view_config(request_method='GET') def get(self): return Response('get') @view_config(request_method='POST') def post(self): return Response('post') @view_config(request_method='DELETE') def delete(self): return Response('delete') If not, I need to do something exactly like this (at least this is how I imagined it (being new to REST)) and this seems fairly intuitive (at least for my mind). 
Take a look at Django's class based views: https://docs.djangoproject.com/en/dev/topics/class-based-views/ They're basically an additional dispatch step on http verb, rather than just url. I prefer pyramid's solution - django's class views have some limitations. 
Actually, and irritatingly, that's the outdated version of Hyde. The active version is [here](http://hyde.github.com). I've been working with I for a while, and it's got a fairly robust featureset, but the documentation is abysmal. It is very easily extensible, though, which is juice. 
Yes, I still use % for some shorter stuff. But what I find really useful is: 'Hello {username}, inbox for your email {email} contains {unread} unread messages'.format(**some_dictionary)
I really can't speak to the benefits of Django, but I jumped into Python by working through developing a webapp in Pyramid 1.3 (though using python 2.7) and would heartily recommend it.
&gt; Given the time the entry was posted *A* and the time of 7:46:43 a.m. December 8, 2005 *B*... What? Where is that date coming from? I see a number of references to 1970, UNIX epoch, but nothing for this 2005 thing. The rest of the article seemed fine to me, and this isn't a big deal, but how do you miss such a basic thing, right at the beginning? It sort of makes me question the rest of the analysis (and why wouldn't you explain where that number is coming from--unless you have no idea because you did the math wrong). Edit: Back to reading it closely, &gt; x = U - D *U* and *D* are both natural numbers (non-negative integers). Thus, *x* comes from the set *{...,-2,-1,0,1,2,...}* and therefore *|x|* comes from the set *{0,1,2,...}*. The value for *z* is either 1 or *|x|*; it is 1 if *|x| &lt; 1*, if and only if *|x|* is 0. Otherwise, *z = |x|*. Obviously I could write this more concisely using mathematical notation, but it is still more clear (to me) than the author's explanation of *z*. Nonetheless, the visualizations are the important part, and they seem solid to me. However, why is it labelled as "Reddit's ranking algorithms" when the analysis appears to be centered entirely on Reddit's 'hot' ranking, when there are 5 available rankings? It looks like this was posted in 11/2010, did Reddit not have 'best' at that time?
?? How is that better than the Python 2 equivalent: 'Hello %(username)s, inbox for your email %(email)s contains %(unread)s unread messages' % some_dictionary The new syntax is great, so is the old one. But most of the time, the old syntax is a few key presses shorter. 
Huh, I did not know that you can reference dictionary keys with the old syntax. I rest my case :)
&gt; All the while Django has been teasing us for the 1.4 release... which doesn't even support Python 3. They received a port to Python 3 which still needs to be reviewed before being accepted, and then it has to fit in a release cycle.
Good luck. I've been looking one that matches your description for ages; they're either paid, or they're written in Perl.
Almost verbatim what I put in my personal ad.
Hmm.. Why don't we just write one? I have a growing project list, but I do need this and will probably eventually get to it.
I've been using [pywinauto](http://code.google.com/p/pywinauto/) to automate some of the tedium at work. I don't know if it allows you to control the mouse, but it is definitely useful for automating actions like clicking buttons, and creating new documents in Windows applications.
I don't know how well is fits your requirement for 'user feedback' but take a look at [The Bug Genie](http://thebuggenie.com/). It's unfortunately not written in Python but it's well designed and is working well for me.
For the user feedback part there are (at least) two decent looking ones built using Django that might work for you: [django-knowledge](https://github.com/zapier/django-knowledge) and [django-voice](http://code.google.com/p/django-voice/). There are some decent, and reasonably easy to skin, forum bits on Django if you need that. Bugtracker piece is tough, and I would love to have something Python based and nice UI. I use [Redmine](http://www.redmine.org/) at the moment for some projects and like it a lot, but even with nicer theme I don't think I would want customers using it directly.
That will be very difficult and you'll probably need to write some facades. Controlling the mouse is platform specific.
There are a few decent Python options that have popped up recently, but none that are perfect yet. I just went through this process recently as well. * Django Voice: http://code.google.com/p/django-voice/ * Django Knowledge: https://github.com/zapier/django-knowledge * Django Helpdesk: https://github.com/rossp/django-helpdesk For now I have gone with YouTrack: http://www.jetbrains.com/youtrack/ It's free up to 10 users, and created by JetBrains. They're a good company and make great software for developers. You may have heard of PyCharm (worth the cost). If you're interested in something more user forum like, there are a couple good Python options also: * OSQA: http://www.osqa.net/ * AskBot: http://askbot.com/
Yeah, this is what I was worried about. Maybe we'll just have to test drag and drop manually. :(
I would personally suggested picking up a micro framework like [Bottle.py](http://bottlepy.org/docs/dev/) and starting with some basic webpages and working your way up to something bigger.
It's great, but it's not "new". It's been up since Fall 2008. I've used the course material teaching a drop-in python class at my local hackerspace.
Ty for the post taking python right now and love more resources!!
Extending the system wasn't part of your requirements, so why does it matter what language it's written in?
I'm getting up to speed on Python for an upcoming (CRUD) web project. I have not yet selected a web framework to use, but just as importantly, I don't want to select one and then months down the road wish I had selected another. From the little research I've done thus far, I'm leaning toward CherryPy. But might I end up being sorry I didn't go with Pyramid instead?
It is a code that is worth reading and studying. Chris McDonough, you are a top one.
http://docs.pylonsproject.org/projects/pyramid/en/1.3-branch/#tutorials
I use hyde. Documentation is a bit lacking, but if you put some time into learning, it's a great solution.
[Redmine](http://www.redmine.org/) may not be the quickest to get set up, and may be a bit overkill for what you're looking for, but it's a fairly polished open source ruby solution. If you're flexible on the self hosted/open-source part, [PivotalTracker](http://www.pivotaltracker.com/) is very polished and easy to use. It's quite friendly towards open sourced projects.
[Redmine](http://www.redmine.org/) may not be the quickest to get set up, and may be a bit overkill for what you're looking for, but it's a fairly polished open source ruby solution. If you're flexible on the self hosted/open-source part, [PivotalTracker](http://www.pivotaltracker.com/) is very polished and easy to use. It's quite friendly towards open sourced projects.
So, why not use Jira? In what way doesn't Jira fit your requirements?
The code: https://github.com/bryanhelmig/emailpie Happy to answer any questions!
Why in Hell should i use it? If you need an email address send a verification, if you don't, don't ask for a email. It's annoying. As hell. And point less. Wikipedia and reddit are doing it right.
That's just the problem: the stuff that's out there offers way more than I need. After watching for a while, I think django-knowledge covers 95% of what I need.
Well, I recently started learning Python (that#s why I'm new in this subreddit). And I learned it from [udacity](http://www.udacity.com) It's really great there, better than most of my university-classes and right now it's free (because it's kind of a beta-test)
I'm looking for something clean, open source, free, and written in Python and/or PHP. JIRA fulfills only one requirement: it's clean. 
You coded this in a functional style and Haskell is a functional language, coding like that is the only way to get things done in Haskell.
Likewise, but I have been wishing I had access to the recitations, so that is a plus at least.
That is one of the two professors who teach the 08 course. He doesn't give a lecture until the 5th one.
The Django port runs on 2.6 and 3.x with the same codebase. After Django 1.4, they are dropping Python 2.5 support, and can consider more options for Python 3 support.
for Linux, there is also xdotool! It is not in python but it is easy to use subprocess to wrap functions around it: import subprocess subprocess.Popen(['xdotool', 'mousemove', '100', '100']) You can do everything you can do with your mouse and keyboard: * click (dragging would be to mouse down without mouse up...) * type sentences * specific keys * move the mouse to a certain spot on screen anyways, hope this helps
I've create Tacot : http://packages.python.org/tacot/en/ This project is born from simple need : « I look for web site generator in Python, like Blogofile, Pelicon or Sphinx but with very low level feature ». With Tacot you can generate easily static web sites (generate .html files) from templates files writed in Mako. Q. Why do that compared with writing raw .html files ? R. With Tacot you can easily share common content betwen your pages (examples : header, footer, navigation...) without to duplicate this content in all your files. Q. There are already many Python static web site generator, like Sphinx, pelican... why reinvent the wheel ? R. With Tacot I don’t reinventing the wheel… when I searched a tool like Tacot, I found nothing. I don’t need ReStructredText parser, I don’t want blog generator, I don’t want documentation generator, I don’t want theme feature… I want only a very simple (low level) tool to convert simple html template files… and I found nothing.
I know, but are there advantages to using that over a multi-paradigm language like Python?
I'm torn. On the one hand, don't validate email addresses. On the other hand, if you really think you want to, use this so you don't invent your own dumb mistakes.
I wrote a Java class that is effectively a command line argument interpreter around Java's Robot class and can then be run in Python using subprocess. For example, in the language I came up with this command moves the mouse to 100,100, clicks, then types "Hello, world!" java RemoteControlRobot m100,100 . tHello,%20world! I wrote some Python functions to generate the command strings, translate spaces into %20, etc. There is a bit of delay firing up the JVM so I group many commands into one line, but it works well and on any OS.
Don't use it. :-)
Just a comment to save this.
This sounds like exactly what I need! I'll give it a spin and let you know how it works. 
Try Fossil: http://fossil-scm.org/ It's by one of the chaps that does SQLite, is self-hosted &amp; self-contained.
CherryPy is great, and I've used it several times in the past. Never had a problem with it. On the other hand, these days, for new projects, I think I'd choose pyramid. I like the way everything fits together in pyramid... that's not to say CherryPy is poorly laid out, it's just doesn't feel as comprehensive to me.
Question: would it be terribly hard to upgrade this so it actually sees if an email exists or not?
I would love to take this project with you. I'm an okay Python/Django developer and I stumbled upon the exact same idea a while ago but dropped it because I couldn't find anyone and I hate working alone. Let us start?
What classes of email address can't it validate?
Never said that the whole Python 3 boils down to a second redundant string formating systems, you're putting words in my mouth there. I said that was one of the results of Python 3.
Perhaps because it's not multiplatform
Redmine is my favourite open source bug tracker, but it's still very clunky compared to JIRA unfortunately. 
a really bad thing about the new string formatting: when programatically creating Javascript, { and } are neaded a lot. It's really not nice to deal with them when using the new style formatting.
Very, very easy to see that these are some very clever people, but they do need some training to become good public speakers. I wonder if the fact that Guido has such a relaxed stage presence is relevant to the success of Python?
Have a look at django-knowledge first - at this point, I may add some functionality to it, but I don't think I'll be writing this from scratch.
Thanks for the info!
I would recommend going through the Flask documentation and source, it's not too big. I'm a newbie when it comes to python but I was still able to understand and follow along the source in about a week or two of reading I would highly suggest you read up on meta programming: things like decorators and context managers they seem to be all over the place in python projects
Yes, OpenCourseWare is quite old and massive, and MITx is new and there is only one course available right now. Another difference is that OCW is passive, you can't enrol for a class and there is no official grading or certification. The list of open course offerings is growing, and [class-central](http://www.class-central.com/) hopes to keep up with it.
Does anyone know of a module that can move the mouse while in a directX game? I have tried Ctypes and win32 modules and they don't work due to directInput blocking the OS layer from accessing the mouse.
There are some instances where it will fail. It might give false positives when a domain doesn't have an MX record though the A record fills in in that case. Also, jibberish emails at good domains (dha8tashd8fagd@gmail.com) will validate fine. The best way is to just email them a link and validate, but sometimes a library like this can help catch misspellings or other honest mistakes.
Where is your privacy policy? And on a side note - you should fix your license: "Neither the name of the &lt;organization&gt;" doesn't make much sense ;-)
Two that might interest you: This one is a lightweight bug tracker that integrates with mercurial http://www.mrzv.org/software/artemis/ This one integrates with most distributed source control (git or bzr or what have you) http://bugseverywhere.org/
Just out of curiosity, how did you end up implementing for both platforms? I've never done something like that before. I'd imagine that I'd create a framework that would use a linux program or windows program (xdotool/windowsTool) depending on the platform that the software is being written on?
Have you looked at [bugzilla](http://www.bugzilla.org/download/)?
Bugzilla is functional, but it is the antithesis to quick and elegant.
What I'd like to do, is write my own version of AHK. I'm the OP by the way.
That date is from the second-to-last line in the definition of `hot()`: seconds = epoch_seconds(date) - 1134028003 1134028003 corresponds to Thu, 08 Dec 2005 07:46:43 GMT.
I'm pretty sure that's what you have to do - write an intercessor that checks what platform it's in and calls the correct functions. I think i'm going to go with [this guy's](http://www.reddit.com/r/Python/comments/r6s1l/can_someone_help_me_find_a_module_that_can_script/c43i6r3) suggestion and use [autopy](http://www.autopy.org/).
Pywinauto.
main() is just the entry point for java programs. python is different in it can either be loaded as a library (import blah) or it can be run as the main file (python blah.py), thats what the 'if `__name__ == "__main__"` thing is for. 
omg... I LOVE YOU
It doesn't have a name, as far as I know, but it's a consequence (or maybe the cause) of the fact that function and class definitions are themselves executable statements. That is, a module is always read and executed from top to bottom: it's just that most of the code that is executed initially just defines functions to be called later.
I can't help you with tutoring, but you may want to visit some of the regular London Python events - in particular, the Python coding dojo that happens once a month. It doesn't have a home page AFAIK, but you can find details on the Python-UK mailing list: http://mail.python.org/mailman/listinfo/python-uk
Thanks for your replies; they cleared things up for me.
Example: &gt;&gt;&gt; def hello(thing): ... print 'Hello,', thing ... &gt;&gt;&gt; hello('World') Hello, World &gt;&gt;&gt; hi = hello &gt;&gt;&gt; hi('World') &gt;&gt;&gt; del hello &gt;&gt;&gt; hi('World') Hello, World &gt;&gt;&gt; hello('World') Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; NameError: name 'hello' is not defined
To be fair, everything starting at the top of the program is 'executed' in the sense that the interpreter interprets every line regardless if there is an 'if __name__....' line near the bottom. A common pattern is to assign a global somewhere above the if statement line: MY_VARIABLE = 'some value' This does get executed even if there is an 'if __name__' statement later. The difference between the two is that above that if statement is executed if the python file is imported from another file. Below that statement is executed if the file is called directly.
[PyMouse](https://github.com/pepijndevos/PyMouse) ???
&gt; My advice is to really go through the documentation and follow the tutorials. Don't just copy and paste code, but try to understand how/why each part works. Good advice, thanks. &gt; The best part of Pyramid is its interchangeability. You can hook up all sorts of resources to it and you're not forced to use any part. Templates, ORM, authen/author, etc are all up to you. From where I'm standing, this is actually a liability. Someone like yourself would have an informed opinion about the different 'parts' and would be able to pick and choose reliably. As a noob with zero experience, I am leaning towards Django because it makes a lot of those decisions for me.
I'm not going to sway your hand towards one framework or another. I'll just try to explain my experiences and reasoning. You're absolutely right that Django makes a lot of decisions for you. That is one of it's strongest points. You can download Django and have a working site within minutes. It's well documented and supported by a very large number of people. But it also does a lot of magic to get that quick setup. That magic can prevent you from doing more complex operations. For example, the ORM. Django's ORM is very simple and pretty much maps models directly to SQL queries. SQLAlchemy, at first glance, looks like it does the same thing. But, it works on many layers with the top layer resembling Django's. Just try out different frameworks. Make sure to give microframeworks a try (Flask has excellent documentation). They make even less decisions for you, but it's easier to digest what's really going on.
Its called REPL. 
REPL is Read-Execute-Print-Loop, it has nothing to do with how python works. IDLE and many other tools provide a python REPL, but there are tools that provide REPLs for many languages, including C (and probably Java) which doesn't allow for the execution of code outside of functions.
[nodebox](http://wwwnodebox.net). Also written in Python.
the [Beta](http://beta.nodebox.net) is jython based, and it can be run on Windows.
Good advice again, thank you. I appreciate you taking the time to provide it. Makes sense to me and I'll definitely play with Pyramid, Flask, etc once I've developed my first Django app.
Maybe it's just me, but that's one weird looking function you have for argparser. You're setting up default arguments before you determine if it's a test_args bound or not? Maybe I don't understand what you're doing -- hopefully someone else does, or if you can give more information maybe I can help. You might want to look into doctest as well, so you can write your command line arguments from the actual command line and document the output for analysis later.
If you don't call `parse_args` without any arguments, it uses `sys.argv`. So I guess he's setting up the argument structure for a script, but leaving the option to specify the input from a test, without having to modify `sys.argv`.
Awesome! Thanks.
This is exactly what I'm doing, and exactly what I think is problematic and trying to fix. My question might be better phrased as "to unit test argparse, should I be somehow manually setting sys.argv in my test suite? Or is there a better method?" 
I usually mock sys.argv to achieve that (as far as I understood what you're doing). It's really easy: import mock with mock.patch('sys.argv', ['whatever', 'I', 'wanna', 'test']): pass # do whatever you want
 pip install -U mock It's really a great library, quite well documented, and that'll become `unittest.mock` (i.e., part of the standard library) from python 3.3
Didn't realize how many 'magic numbers' the reddit code included. I feel like it should really be explained...of course, the post did say that was a rewrite of the original code. I just still don't understand why? UNIX epoch is basically an arbitrary date to use as a reference point, why shift to a different arbitrary reference point? I'm guessing it corresponds to when ~~Skynet~~ Reddit went online? And if this code is written in Pyrex for speed purposes, why would you include any unnecessary calculations? Re-reading the post again, it still really bothers me that the discussion has an in-depth argument for why the 'hot' algorithm isn't the best for non-time based rankings...but the 'hot' algorithm isn't **supposed** to do that! The 'best' algorithm (I beleive) is supposed to give a better overall ranking, 'hot' is intended to show what's recently popular. My real problem is that the article presents the 'hot' algorithm as reddit's only algorithm, with no discussion of the other algorithms... Again though, this article was written in 2010, and I really don't know, maybe 'hot' was reddit's only ranking system then?
Completely agree. But instead of starting from scratch when you quickly need administrative interface, this library will provide some foundation to build it. Like, if you use SQLAlchemy, you can use built-in SQLAlchemy model view, which will give CRUD interface for your models. If you need file management interface (upload, delete, etc) - you can use built-in file manager, etc. But you're not limited by the provided functionality - you can write your own or extend existing administrative pieces and then plug them into the common administrative UI. That's pretty much it. 
I don't know. I didn't read very closely, saw the stuff about a Python autohotkey and replied.
Okay cheers for the feedback. I'll see at giving it a try :)
json is no prob, import appropriat_json_lib as json and go. Challenge is things like "depending on the backend situation, decide for the renderer to use in this jqrid for those values". Same stuff or other bracy data as i.e. .css, when css is supposed to be programatically created. A lot of bracy data is better created by a Python script ... Javascript was just an example. 
I wish the real-world students I've dealt with were so perceptive. :/ In practice, the Socratic method is a lot harder to apply than illustrations of it would lead you to believe.
The guy in question is actually a good engineer - he just has very little experience with functional-style (and Python).
Or, for a more graphics/game centric audience, try [http://gamedev.stackexchange.com/](http://gamedev.stackexchange.com/).
Why would anyone use ```reduce()``` nowadays? Comprehensions/generators seem much more elegant.
To be honest I have no idea what your friend is trying to do.
Comprehensions don't really do anything to replace reduce, just map/filter. Ie. a list/generator comprehensions still always operates on each member individually. Though, admittedly, this is a bit of an icky use of reduce, since it's doing in-place updates on the accumulating dict (and working around python's attempt to warn against this style with the `or c`) , which moves away from a functional style somewhat. I'd actually consider the for loop syntax better for this, since it's doing stateful modifications as a side-effect (or else an approach like farsightxr20's that constructs a new dict from the concatenated tuples of the items).
Can anyone read the line: reduce(lambda a,b: a.update(b) or a, c, {}) and understand without some small degree of mental gymnastics? Surely it's unpythonic on readability grounds alone? Not saying it's not a fun little exercise but - good style?
Oh god damn. It. Not another bootstrap looking web site. 
You're off to a pretty good start, and actually defined a function. A couple points though. 1. You never actually _call_ this function, using the syntax `start()`. So far you've defined the function, but it won't execute until you tell it to. 2. Same thing with your line `newGame`. That isn't actually calling the function, you have to write `newGame()`. Same goes for `choice1`. 3. Don't submit pictures of code, use pastebin or a similar site Good luck
Unfortunately mutating methods returning None don't mix very well with functional style. In this particular case the plain for loop and update is the clearest IMHO.
He calls start() after he defines it.
Please ask your question in [r/learnpython](http://www.reddit.com/r/learnpython).
I'm assuming you're running this from IDLE then? If you're using Python 3, `raw_input` doesn't exist anymore. Python 2's `raw_input` was renamed `input` and Python 2's `input` was removed, so if you're using Python 3, `input` is fine. Any other details about the environment you're running this in you can give?
You're welcome :)
reduce() is, for all intents and purposes, equivalent to 'foldl' in most functional languages. Lists/generators are somewhat analogous to map/filter. Fold functions are designed to *reduce* something from one type to another; hence the name. This cannot be done with comprehensions/generators alone. For example, if one wants to reduce a list to the sum of its elements: reduce(lambda sum, a: sum + a, [1, 2, 3, 4, 5]) You might argue that this is clearer: sum([1, 2, 3, 4, 5]) And I'd agree. But 'sum' is a special (and common) case. What happens when the operation to reduce isn't as simple? reduce(lambda inverseProd, a: inverseProd * (1.0 / a), [1, 2, 3, 4, 5]) Which isn't so easily captured as a special case with the Python standard library. (You can of course argue that a for loop is clearer, and I wouldn't necessarily disagree in Python. But you said "comprehensions/generators", not for loops :-)) My thoughts on the matter are this: A lot of people using Python haven't experienced functional programming too much, and 'fold' related functions are a bit difficult to wrap your head around if you haven't used them in practice frequently. Moreover, they are *very* easy to use incorrectly and introduce added complexity to your code when used poorly. Particularly in Python, because many of the cases where you'd use 'fold' in a functional language are covered by special cases in Python (like reversing a list, summing, etc.)
You have to get used to reading and writing folds before one can read them without gymnastics.
I think the best one is roger_'s: {k:v for d in x for k, v in d.items()} Clear and concise.
Dear prefetch_related(), my M2M-relationships have been waiting for you for soo long, glad you are finally with us. 
Good to know, twillis1973. 
[AWS](http://aws.amazon.com/) is great. You can launch a Linux micro server for free (first year) and install whatever python modules you'd like. Great way to play around and then easily scale.
Heroku might also be an option.
3 words for you: IRC.
This is rather a problem in your server (probably bad memory management). You should post this else where (with code) since it's not python related.
I read in forums that using the new CS courses(maybe cs101) from udacity/coursera are much better than web tutorials. Also when you sign such a class you can easily find other people to learn with.
Just like a 16 year old who just got their license doesn't need to be bothered understanding all the mechanics of an internal combustion engine, they should concentrate on avoiding other cars and staying on the road. But, someone out there does need to know the mechanics of an internal combustion engine, and they need the appropriate tools.
Just to update on this: this issue has now been fixed (it took some while to get the bytes/unicode distinction correctly through the serialisation - even with pickle, due to [this](http://bugs.python.org/issue6784) issue. In addition, I've added a module that allows you to simply do this: &gt;&gt;&gt; from py2 import py2 &gt;&gt;&gt; py2.rimport("sys").version b'2.6.5 (r265:79063, Apr 16 2010, 13:09:56) \n[GCC 4.4.3]'
Yep, this is a good place to start. It's basically like having a free VPS (but with not much RAM).
Thanks!
Correct. It was a presentation given at the Boston Python Meetup.
It basically enables what previously has only been available to ForeignKey relationships using [select_related()](https://docs.djangoproject.com/en/dev/ref/models/querysets/#django.db.models.query.QuerySet.select_related). It returns a QuerySet that reduces roundtrips to the database by issueing a large query upfront rather then lots of small queries for each field access in your code. The docs illustrate it with the following sample: # Hits the database. e = Entry.objects.get(id=5) # Hits the database again to get the related Blog object. b = e.blog in contrast to that: # Hits the database. e = Entry.objects.select_related().get(id=5) # Doesn't hit the database, because e.blog has been prepopulated # in the previous query. b = e.blog prefetch_related() gives you this behaviour for M2M-relationships in similiar way to django_batch_select only as part of the framework API instead of an external module. 
TCP is a stream, not packet protocol. If you call send twice with 500 bytes of data on the client, you CANNOT depend on receiving 500 bytes twice on the server. You can only depend on reading a total of 1000 bytes -- eventually. This may be 1 1000-byte read. It could be 4 * 250 byte reads. It will depend on what happened on the underlying levels while in transit. Maybe due to retransmissions it will take 2 minutes for the data to get there. The retransmissions happen on the OS networking layer, not in Python. TCP will guarantee you that the data arrives in the same order and correct, but does not guarantee that each read will correspond exactly to each write. For that you need to introduce your own packet discipline. For example, start each write with a 16 or 32 bit packet size, then when receiving the data on the server you'll know how to break it up. There may well be some easy pygame wrapper to do that, or if you want to be more extreme you can use a library like ZeroMQ. 
I still think it's very hard to read. Comprehensions with multiple 'for' clauses should be avoided. Your first version in the article (with for item in: update) was the best Python.
Your root might have been weakened by a previous battle.
It's probably me, but without explanation I don't understand what this presentation is about. Looks nice though :-).
I havent decided wether to make it open source yet or not. The client is about 750 lines of code and uses standard JSONRPC to communicate with the server. Ive spent a bit over a month on it. (i am only a hobby pythoneer) Server code is about 500lines. Not sure what else you want to know?
Go look at the Pyjamas examples, you might be surprised a webapp could be written like that.
Everything qiwi said is true. Also, you do not need to acknowledge data receipt or have your app resend data over TCP - the protocol will do this and resend it itself if it has to. (Which it often will, over wireless.) If somehow data isn't arriving on the server after a reasonable length of time (ie. a second or two) but the connection isn't dropped then it's probably a bug with the server not detecting the incoming data properly. (Which is almost certain to exist, given that you are looking for packets, which don't exist at the TCP level.)
Great piece of game ! Congrats dude
Fun. Inspiring. Thanks.
Does not work with DirectX games.
 class MultiplicationMonoidWrapper(object): def __init__(self, obj): self.obj = obj def __add__(self, other): return MultiplicationMonoidWrapper(self.obj * other.obj) MultiplicationMonoidWrapper.unit = MultiplicationMonoidWrapper(1) def fac(n): return sum(map(MultiplicationMonoidWrapper, xrange(2, n + 1)), MultiplicationMonoidWrapper.unit).obj print fac(6)
Or use fabric, it has a sweet get method
Can't find part 1
Nice to hear about two packages I didn't know, but: - any specific reason you use 2.5? - using a config file rather than a command line option (that will be visible during the call) for the password would make more sense.
Use paramiko much better and easier
but why can i insert php into html, but cant python ?????
[Pyfilesystem](http://code.google.com/p/pyfilesystem/) supports SFTP. It also comes with a handy command line app (fscp) which I think does what the script in the post does. Works something like this (from memory): fscp ssh://root:mypassword@somesite.com/dir/file .
Check out Coffeescript. It compiles into javascript which you can use on web pages. The syntax is very pythonic. If thats not what you want, pick up a python web framework like Bottle or Flask and start with that. 
so all the html code and css code I have to put it in my python code ? but is html and css written in the same way inside python py ? or the syntax is difference ?
There are two places you can add code - to the client (which runs in their browser) or the server (which runs on your machine). Javascript (plus HTML and CSS) is basically the only language which runs in the client. You can use pyjamas to convert python into javascript, but it's very tricky. PHP is the most common server side programming language. PHP is an example of a templating language - PHP code *looks* like HTML, but has special PHP bits in it. Python web frameworks try to separate the HTML and Python code. You can still have templates (HTML with bits of python) if you use a templating engine that allows it, but you aren't meant to do too much in the template - that's like putting all your CSS in the HTML file. 
Exactly this, though if you are using Python with a web server, it's recommended to use [WSGI](http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface) over plain CGI.
Yeah, I left out the part where "old school" CGI has been supplanted by all these other things, but the *basic* idea is essentially the same. One program (Apache) handles the networking, and some other program or programs handles content generation.
The short answer is that you almost certainly will not be doing any website work using python unless you choose one of the popular python-based web frameworks, like Django.
I wrote this a while ago, a wrapper for the paramiko SFTP that takes most of the work out, and makes it so you can just put/get files or whole directories. [https://gist.github.com/2190472](https://gist.github.com/2190472)
Doesn't IronPython require Silverlight? (that is, it's not really a runs-in-any-browser thing)
A Python translator running on Silverlight? Which means no Linux or other FOSS OS support of any kind? That's the dumbest thing I've seen today.
From what I've read [here:](http://ironpython.net/browser/download.html) &gt;No downloads are required to develop and deploy Python applications for the browser, though you can always download the pieces hosted online (for working without a network connection).
Um ... silverlight is all over that page. I looked harder, every IronPython example I tried asked me to update my silverlight plugin.
If you don't have reservations about using the peewee orm, might I humbly proffer my own flask admin: https://github.com/coleifer/flask-peewee -- has admin, rest api, auth, and moar
&gt; The differences are minimal and mostly stylistic. Okay, that's comforting and helpful to know. I use these two books: http://openbookproject.net/thinkcs/python/english3e/ http://www.djangobook.com/en/2.0/ And I plan to buy this one: http://shop.oreilly.com/product/9780596158118.do So I should just keep doing what I'm doing I guess. :) Thanks for answering.
"A language for hippies who are scared of real OO languages" [Jack Deidrich - You Don't need Classes](http://pyvideo.org/video/880/stop-writing-classes)
Not particularly, we've been gradually checking them off our lists.
The points he mentioned, and their status (to the best of my knowledge) of them in Django 1.4: * The ability to have multiple DBs. - Yes, added in 1.2. * Intelligently selecting which database (or DB cluster) to use for operations. - Sort of. Django allows you to specify which DBs to use for reading/writing, but not all of the features he mentioned are present. * Sharding - Nope. * Denormalization - Nope. * ~~Thin sessions (i.e. sessions that only involve a client cookie) - Nope. I understand that django sessions use cookies, but he was talking about being able to set explicit signed cookies in the browser instead of using a server-side DB/FS/cache based session.~~ Edit: As others pointed out, I missed this part of the 1.4 notes, cookie based sessions [actually do exist](https://docs.djangoproject.com/en/dev/topics/http/sessions/#cookie-session-backend). * Dumb SQL is generated by the ORM - Still happens. I can confirm that user.username in a template generates SQL that queries for all fields in the user model individually. * Verbose template syntax - Hasn't changed. (Though IMO this was one of his silly points) * Lack of good debugging tools - Not part of core, but what he described sounds a lot like django-debug-toolbar. * Not smug enough - I suppose this hasn't changed, since Rails is still the most smug framework out there. * No mascot - Yep, Django has no official* logo or mascot, just the wordmark. Edit: However, there seems to be an [unofficial](http://djangopony.com/) one. * No deployment system - Deployment is still a nightmare. * Model migration - Still not a part of core, though South exists and is quite useful. Also of note, this talk was given a few days after Django 1.0 was released. 
Either. The differences are not significant and it's relatively easy to transition from one to another. My information may be already a bit outdated but I'd recommend Python 2.7 if you want compatibility with existing libraries.
Deployment isn't a nightmare with git, fabric and virtualenv. It's quite good, I thought. 
&gt;To answer your other question; there is no simple way to (ab)use Python and make it act in this way. Ha. You just have to get creative! #&lt;!python doctype=megalithic_hiccup&amp;&amp;coding:utf-8 '''&gt; &lt;html&gt; &lt;blah/&gt; &lt;script type="text/python"&gt; def header(txt): print("&lt;h1&gt;{}&lt;/h1&gt;".format(txt)) for i in range(100): header("suck it, php!") &lt;/script&gt; &lt;/html&gt; &lt;/python'''-someMassiveHackImplementing__rsub__()#!&gt;
My point (and the point of this talk) was related to what exists only in Django core. But you're right, deployment isn't so bad when using other tools.
You don't have a mascot yet, start it nao!
* Thin sessions - I believe this is what cookie-based[1] sessions in 1.4 are? [1] https://docs.djangoproject.com/en/dev/releases/1.4/#cookie-based-session-backend
&gt; Thin sessions (i.e. sessions that only involve a client cookie) - Nope. Schrute says false. Check out the docs on [cookies based sessions](https://docs.djangoproject.com/en/dev/topics/http/sessions/#cookie-session-backend) and [Cryptographic signing](https://docs.djangoproject.com/en/dev/topics/signing/)
&gt;No mascot - Yep, Django has no logo or mascot, just the wordmark. http://djangopony.com/ '___'
&gt;(for example use `print("something")` instead of `print "something"`) Incidentally, `print("something")` is valid in both python 2 and 3, and produces identical output. This is generally true for whatever operands you care to give it, unless they are Python3-specific kwargs like `sep` and `end`, controlling exactly how it's formatted.
Better. I'd spell 'k' as key and 'v' as value. (Why save a few characters and hurt legibility?) However - two separate dict comprehensions would be even clearer. And then you're at the 'might as well use an explicit loop' stage. Which is probably correct.
Have another look at the calculation of the bodies' new speeds and coordinates. The units literally don't add up.
0) Your (mathematical) method looks sound. Your implementation is almost a textbook example of all of the common pitfalls of numerical integration :). 1) The lines kot=math.acos(rx/r) # ... Fx=float((F*math.cos(kot))) Could be replaced by Fx = F*(float(rx)/r) Since cos(acos(foo)) == foo. Similarly, Fy = F*(float(ry)/r) 2) Don't use ints to store location. Store location as floats and convert to ints when plotting. Quantised storage + 2 chained integrations == pain. 3) Two forward difference integrations like this in an inherently unstable way to do numerical integration. Google "implicit integration" for a more stable method. 4) The instability of your integration method plus your quantising of state after each iteration will lead to instability as soon as the masses start to approach. I've not run the code, but I imagine "not moving as they should" means that they very rapidly approach and then fly off to infinity? 5) Numerical methods in computing is hard. Get hold of Numerical Recipes (http://www.nr.com/). Read it. Learn. Gain enlightenment. **edit:** 6) Without any initial (relative) velocity, the masses will just fall towards each other. If you want to have interesting motion give them *different* starting velocities.
yes, but first id like to learn how is done, is like doing mysql form the console, and then later use myphpadmin.
what i cant picture is how to make python create the html-css. 
ok
can i use python with apache?
You could implement much of the logic in Python, then use native C when needed for the slower parts. In reality, you'd likely push much of the graphics out to C, and some of that to Assembly. Most real projects are made of a mixture of languages, used when each is appropriate.
 rx=int(px2-px1) ry=int(py2-py1) r=math.sqrt((rx**2)+(ry**2)) #force kot=math.acos(rx/r) F=float((masa1*masa2*gravit)/(r**2)) Fx=float((F*math.cos(kot))) Fy=float((F*math.sin(kot))) #acceleration ax1=float(Fx/masa1) ax2=float(-Fx/masa2) ay1=float(Fy/masa1) ay2=float(-Fy/masa2) `math.acos()` returns values in the range 0 &lt; x &lt; pi; therefore `ay1` is always positive, `ay2` is always negative. When `py1&gt;py2` the two objects will accelerate *away* from each other on the y axis. In general, it is best to not calculate angles unless you *must* have them; just use vectors for everything. In your case, you do not need to calculate `kot`. Just do: fx = F*rx/r fy = F*ry/r If you must calculate the angle between two objects, use atan2; do not acos or asin or atan. It will return an angle in `0 &lt; x &lt; 2pi` which is what you want. Also, do *all* your math in floating point or fixed point, and only convert to display space integers when you need to display them. Converting between floating point and integer math willie nillie like that is a recipe for pain. Also, your integration is fast, but inaccurate. It might be worth looking into a better method.
One of the popular Minecraft map mods/apps, which allows you to explore your maps and make all kinds of changes, uses Pygame. Its name eludes me, though. **Edit:** Looked it up, was thinking of [MCEdit](http://www.minecraftforum.net/topic/13807-mcedit-minecraft-world-editor-now-open-source/).
Well, to be fair, the pony is not the official logo. However, if you count Alex Gaynor, Django _does_ indeed have at least two mascots now.
The problem is that various projects have adopted ponies as their mascots independently, so it's become a somewhat ambiguous mascot of nerd culture in general. Alex Gaynor is still unique, though.
great point about frameworks in general at the 19 minute mark. 
&gt; Dumb SQL is generated by the ORM - Still happens. I can confirm that user.username in a template generates SQL that queries for all fields in the user model individually. FWIW, using * instead of individual column names is a tiny performance hit, so I can see why the core devs would want to do the latter by default. It does make debugging more cumbersome though...
That was the same question i was asking myself some time ago. I really love Python, but sadly you can't do everything in it, your alternatives would be Cython or PyGame, but as other people said, you would use Python for logic and and C/C++ for game engine or any stuff that needs to be run faster. I decided i will learn C++ since it's a useful language anyhow, and will see where i go from there.
EVE Online. Look up the dev diaries.
Eve online is made in python http://community.eveonline.com/devblog.asp?a=blog&amp;bid=786 if you find bottlenecks you can always write them in C.
I didn't say there was no way to do it - I said no simple way. I've done things that implemented in-browser python before. It's tons of fun. But it's not simple.
And this is the default behavior, but you can tell a query set only to retrieve specific fields. 
They're just two different Python interpreters. You almost certainly use CPython, which is a python interpreter written in C. Pypy is an Python interpreter actually written in Python, which performs much better than CPython in certain cases. I would suggest sticking with CPython for the time being, unless you decide to learn more about the Pypy project.
Yeah. I do love pygame though! Its great for simple stuff like snake, pac man, etc.
Yeah, there's barely any lighting going on though (at least compared to Minecraft) which would be the most difficult part. Speaking of MCEdit, the source code was realized awhile ago and I've been looking through it, its fascinating!
Not sure about the frontend, but most (all?) of the backend is written in Python. They have a fair amount of entries on their devblog if you are interested, they go into a lot of detail about the intricates.
Yeah, I mean you shoulda at least told him what the opening &amp; closing tags are. :) That answer is right-on though, and sadly I must confess to once wondering the same thing as the OP. For me, the turning moment was when I was introduced to an MVC (CodeIgniter, fwiw). Once I could see, code, and appreciate the abstraction between controllers &amp; views, it was a short leap to understanding how Python could be used to deliver web content. But it really took me like 18 months of fiddling on my own (after discovering VirtualBox), before I started to feel some shreds of confidence w/Python, Linux, and the web.
And I'm pretty sure also for less simple stuff, as it's a wrapper around C ;-). It's less suitable for Minecraft and Skyrim, though, as its focus is on 2D games.
The MMORPG game Eve Online is written in python for example. [just google "Eve Online python" instead of asking for citations please] If you were to do something like these, you would probably be implementing the graphics engine using pyOgre http://www.ogre3d.org/tikiwiki/PyOgre which is realy just a python binding for the c/c++ graphics engine. For the physics engine you would use the python wrapper for physX, and for collition detection you would use another library written in C or C++ and the rest of the game logic you write it in python. Note that since you are using python wrapper for the libraries, you end up coding only in python 100% of the time. 
Don't forget: * Writen in Python, which has significant white-space, which is evil for some reason and prevents you from writing illegible programs in cutesy geometric shapes. * Django team members don't have beards, which invalids all their accomplishments. If I'm not mistaken, these bugs have not been fixed in Django 1.4
One of the many nice things about Python is how well it embeds into C/C++ projects. As a result, you can script all your game logic in Python and let C(++) do the heavy lifting for graphics and such.
Cython (a compiler for python) does add c like features in that you can declare types for variables and precompile code to get some speed ups. It is confusing that it is named so closely to cpython, which as others have explained, is just the default python interpreter which happens to be written in C.
The Blender Game Engine also has Python integration. Also, there are compiled implementations of Python; any complications building a large scale game would be with the way you implement it, not the language.
No, I think only Pirates of the Caribbean Online was made with Panda3D
The client is at least partially python. Parts of the client source code (or it was just decompiled, I do not know) was put up on pirate bay in 2007-ish.
Anything that allows me to rapidly prototype and idea is a major win. If my application gets to the point where there is a influx of demand, I'd be ecstatic. At that point, I can throw money at the problem and rewrite it for the demand. Zuckerberg did not spend time in his Harvard dormroom on Haystack or NoSQL. Larry and Sergey didn't implement a massive distributed architecture from day one. 
Except for the game engine, which you consider a minor component? &amp;#3232;\_&amp;#3232;
I was trying to point out the coincidence, maybe even a little bit of irony, between Cal's sarcastic comment and Jack's talk. Is being scared of real OO languages while simultaneously overusing Classes at least slightly ironic to you?
Keep in mind that an alternative Python implementation such as PyPy compiles at least some parts of your program during runtime, which makes it substantially faster (5x or so on average at the moment).
 from __future__ import * Learn both. Use the above to decrease the differences that your Python 2.7 code has from your Python 3. **Most** beginner stuff should be backwards compatible if you use that.
 from __future__ import * and Python 2 now has the identical print function from python 3.
word :)
Not all responses on Reddit is confrontational. But I admit I do have a first instinct of "defending" my comments when I see a reply. :-) 
Wow. Being able to run all Python's libraries in CL completely removes one of the reasons why I personally can't get into CL. Will have to look at it again :-)
That works too. The format-string technique is useful to know in case you need to support Python 2.5, though.
18 months is pretty good. I started fiddling with web development in the late 90s, and it took a heck of a long time before I was really confident in things.
So if you wanted to eventually (mainly) go into programming games, wouldn't you just want to go straight to C/C++ or Java? Not that I wouldn't not use Python occasionally :)
Python is also actually compiled, but in a different way to java and C. It's important to keep this straight (words like "interpreted" and "scripting languages" come from olden days where things were different, so they have pretty much no sensible meaning anymore nowadays), so here's the deal: * Native compilation: The compiler takes your code and converts it to efficient machine code (assembly), which can run natively and stand-alone (no interpreter needed.) To do this efficiently, you typically need a statically typed language. This is traditionally the fastest, 1) because, well, it's easy to optimize this really well, and 2) because we've been doing it for many decades now, and have become quite efficient at it. Languages that do this: C, C++, fortran, Cython (to some degree, but with many gotchas) * Interpreted languages: The compiler takes your code and converts it to "machine code", but not machine code that your CPU understands. instead, it's machine code that a "hypothetical" machine can understand (I'll refer to this as "bytecode" from here on). This hypothetical machine (also called "virtual machine") is then implemented by an interpreter, for instance the python interpreter. The interpreter then chugs through this bytecode and executes it bit by bit. Languages that do this: python, (all other "scripting languages" like perl, ruby, php, ...), java (with a gotcha, see the next point). Has the advantage that this bytecode is independent of the actual CPU you use, and that it's much more high-level, easier to understand/debug/implement, ... * JITted languages: This is an "add-on" to the previous point. Some languages (like java and python) can't be compiled down all the way to "independent", "stand-alone" machine code, because of various constraints and restrictions. So this is a compromise that you can make if you want the implementation still to be fast: You run the language in the interpreter, but while it's running, you analyze smaller (or larger) chunks of the instructions, and realize "hey, I can optimize this, and re-write it as pure, low-level machine code". For instance you could look at some function and say "okay, I understand what this function does, and I have control over how it's executed, so now I'll replace this function which is written in bytecode, with an equivalent function that does the exact same in assembly". The advantage is that you can get pretty speedy code with this, the drawback is that it needs to steal some CPU time from you while you're running to perform the replacement, performance is highly unpredictable, and it's typically still not as good as native compilers, because it can't allow itself to analyze and optimize the code as deeply (too little time). Languages that do this: Java, lua (with lua-jit). CPython doesn't currently do this, but there is for instance pypy, which can do this, and will at some point hopefully become the standard python * "interpreted languages" in the old meaning of the sense (what you mentioned) -- languages that are interpreted line-by-line, by having the compiler just read, parse and execute every line as it goes along. This used to be a standard way of doing things for languages in the olden days, like BASIC, but virtually no language does this anymore (except maybe shellscripts), because it's very much inferior in terms of speed to all the other ways. Note that some implementations like Cython blur the boundaries between these ways of doing things. This got a bit long, but unfortunately the situation just is that complex (and has even more complex aspects to it that I haven't even touched upon) :)
Not true. Just high level scripting and modding is in Python. The game engine is all C++.
It isn't about being too complicated, it is all about performance. You would start with a library to help you render 3D scenes, like [PyOpenGL](http://pyopengl.sourceforge.net/). The routines will be performed in C, but the returns will come back into Python and will be 'wrapped' with Python support (error checking, coercing types, etc.) which slows all the calls down. If you were to implement an OpenGL demo in C and then the same demo in Python using the library, it would probably be 30-50% slower (on very complex 3d scenes). But what you are talking about is implementing a game engine, and it is easier to just use one of the existing engines which have been written in C or C++ and have been heavily optimized. C/C++ allow a developer to make much better use of memory and routines carry out far fewer instructions. Python will never approach the performance characteristics of implementing a gaming engine in C and that is fine ([some benchmarks](http://graphcomp.com/pogl.cgi?v=0111s3B1&amp;r=s3m3) will claim that a scripting environment can be as fast as C with rendering 3d, but don't believe them, that only works for simple 3d models). Most games have a scripting environment, where everything above the game engine (which is responsible for rendering scenes, collision detection, etc.) is implementing in a friendlier developer language such as Python (or more commonly, Lua). On most modern big budget games there are more scripting developers writing Lua or something similar than there are C/C++ developers. You license the engine (or use one of the many open source engines) and implement the game in the scripting environment. There is no reason to be pushing polygons and pixels around using a scripting language. Blender [has a Python interpreter built into it](http://www.cgmasters.net/free-tutorials/python-scripting/) and is the most common answer when developers ask for a gaming engine that supports Python as a scripting environment. The other is [Panda3d](http://www.panda3d.org/). [This is](http://kalogirou.net/2005/08/10/multithreaded-game-scripting-with-stackless-python/) a good intro to Python scripting in a C++ gaming engine. So, yes, it is *very* possible to write complex games in Python, and almost every popular game has a large element of scripting in it - its just that you won't get a very efficient complex 3d gaming engine out of Python. As for Minecraft-level 3d, you could get pretty close in Python to its Java implementation but there would still be a delta (there are all sorts of other reasons why a lot of developers prefer Java). For simpler 2d games, checkout [PyGame](http://www.pygame.org/news.html), which is very popular for creating platform games.
wasn't the civilization series written in python?
Can anyone explain how PyPy is written in Python? Does that mean PyPy is running on a Python virtual machine? How can that be faster?
Apparently, I thought an interpreter was just something that... Oh wait. As soon as I thought it out loud to my self it made perfect sense xD
Sorry, I wasn't saying "Java is total crap and nobody should ever use it because it is slow!" I was just saying that because it is an interpreted language, it is by default slower to execute than a compiled language due to that two step process you mentioned. Python is the same way. The OP wanted to know if the Python interpreter precluded Python from being used to write a game like Minecraft, so I thought it was worth pointing out that Minecraft is in fact written in Java, an interpreted language. I honestly don't know much about Java, but I know I'd rather write something in Python than C/C++ if I had the option, even if it ran slightly slower. I'm sure Java is the same way. Unless you're dealing with some super complicated stuff, it's a lot easier to write in something like Python and try to optimize it to be comparable to C/C++ than write C/C++ from the ground up. The simplicity of those languages usually outweighs any performance loss you get from using an interpreter.
Skyrim with CLI? Interesting xD
Yeah, it used Twisted. I didn't write the entire thing by myself either, there were several people involved in the project at first, but I have written well over 50% of the current code. 
Nice, one of the first programs I wrote was a REALY simple one about a dragon cave... It was the first time I had used randint!
Just looked it up, seems like a much better alternative to sockets
Yeah, it's been a fun little side project, as I don't really do much coding anymore. Thinking about being able to explore a world the size and scale of Skyrim from a 80x25 char virtual terminal makes me geek out on the inside ;)
Nice, does it use any ascii images?
Vampire The Masquerade was also notoriously buggy and slow, so it might not be the best example :)
Those weren't bugs and sluggish performance, they were features and bullet time!
It was unoptimized and buggy because it was made almost entirely unpaid because Troika went under during development and the devs finished it because it's a kickass project. That made it somewhat rushed, I imagine. Also being a diehard VtM fanboy, I probably ignored a lot of the load time issues and crashes because I got so into the plot and how much loyalty to the RPG franchise that game showed.
If you use web2py you simply move your static file into applications/yourapp/views/default/yourfile.css and in applications/yourapp/default.py you create a line that says: def yourfile(): return dict() Now your file is accessible at http://localhost/yourapp/default/yourfile.css You can edit your file and insert python code in {{...}} for example: {{for tag in ['header','content','footer']:}} {{=tag}} { color: red } {{pass}} ({{pass}} closes blocks). Anyway, almost any framework allows you to promote a static file to a dynamic file (as in the case of web2py) and in every case you pay a small performance penalty, unless you cache it. Web2py allows you to use pure python code in the view/template. Other frameworks require that you use some pythonish language which is not actually python.
Not yet :D
Sure, it was a great game - I loved it and finished it (despite the crashes every 20 minutes or so) - and it's such a shame that it wasn't a bit more polished. 
I only had one crash on my playthroughs: The consistent one in the part where I won't spoil that was fixed by the official patch. I did have some freezes though. And the hilarious visual bug where Smiling Jack's face disappears (the facial texture, that is. Not his teeth and eyes).
Eh, maybe. I have a feeling it's going to be one of those projects that's never finished, as coding is getting phased out of my life and I really haven't touched the project about a month.
Ah, thats too bad.
IDK if you're the author, but the link to Win32api should be http://msdn.microsoft.com/en-gb/en-us/library/windows/desktop/hh447209(v=vs.85).aspx
Hey, I'm actually the author. Thanks for pointing that out. I'll see if they can update the link. 
Spelling.. My greatest foe. &gt;_&lt; 
always best to ask a duck.
IIRC, they have moved a lot of that out of python though, due to some speed issues, but having played it within the past few months, some parts were clearly written in python, based upon performance...... lists......
The lighting in Minecraft isn't really so much done with Java as it is done with a Java library which interfaces with the glsl and stuff. In fact, all the graphics are done with a library which interfaces with OpenGL as I understand it.
The actual graphics stuff you'd be doing in C/C++ or Java or Python would probably be simply interfacing with a library that just wraps OpenGL stuff, which is how you'd do graphics if you want to do cross-platform. And you should be able to mix Python and C/C++ as necessary, if you're careful, and so Python with possible extensions (and an openGL library, which is needed no matter what language you choose) should get you well on your way.
Interesting, it there a way to use the java lib in python with Jython? Or would you use a completely different python version instead?
Um, you probably could do things that way, afaik.
They've done a TON of back-end updates over the past couple of years and while they still use stackless python, I'm not sure you can get a whole lot of up-to-date info on how they've redone the python and C/C++ code interactions.
This is exactly the sort of thing I like to see when picking up a new language: it's an interesting task to take on, you document your workflow, and you seem to follow reasonable coding habits. Wish I'd caught this when first picking up Python. BTW, is box ever used in your initial screenshot function? Looks like you initialize it but never use it. 
The right tool for the right job, of course.
I highly doubt you could render the graphics in CPython. It simply isn't possible for it to move fast enough to do complex 3D with any sort of efficiency. You might get a handful of frames per second, max. To implement things like hit testing, collision detection, and other physics, you're also probably going to have to talk to C or C++ code. I've written a game server in Python, and hit testing alone with only 20 entities at about 25 hertz will blow a CPU to 100%. Numpy hasn't helped especially for small numbers of entities. Since you can't do proper multithreading in Python (in CPython or PyPy), you can't take advantage of multiple cores. Granted, Minecraft is single-threaded for virtually everything it does, but Minecraft suffers from some pretty serious performance issues because of it. Combined with CPython's general performance issues, a lack of proper multiprocessing would incur a very significant amount of overhead. I'd speak about PyPy, but I don't have enough experience to talk about it with a great amount of in-depth knowledge.
What about if you use one of the Python game engines where the GLSL and high efficiency C code has already been written by one of the game engine developers? Would it be possible then to create a game of similar complexity to minecraft or skyrim with knowledge of only python and the engine?
No, you can't really write a game of the complexity of skyrim while not 1) being super-amazingly awesome at all the things up and down your software-stack, including (but not limited to) GLSL. 2) using some "worry-free framework" that just abstracts things for you -- if you want to create something that grande (And I have no clue how many lines of code skyrim is, but I'm sure it reaches into the millions), you will need to either write your own engine/framework (which makes most sense) or, if you use some sort of framework, know every single line of it in and out, forwards and backwards, and you'll be likely to also make heavy modifications, extensions and improvements to said framework. If you look around, you will find that most "big" games don't really use a whole lot of frameworks (mostly small libraries that do specialized, simple tasks for them, like loading images, ...), because (at least this is the conventional wisdom in game programming, whether you agree with it or not) if you want to create something truly unique, you need full control over every aspect. How much of the code you are going to have to write yourself to get this level of control might vary, but most game programmers opt for "pretty much everything". If you find some pre-made engine or framework that happens to suit you, that's a good thing, of course, but it definitely won't happen for something like skyrim.
Windows only :(
A game ceases to be a game when you go from frames per second to seconds per frame. I don't think it's actually helpful to point out the fact that all turing complete languages are perfectly translatable with each other. The question is if one can make comparable games in python, not if python can represent the same numerical calculations then run them at entirely useless speeds.
This works only in windows. If anyone is interested [here](https://github.com/Ttl/bot.py) is similar python code that works in linux. Should also work in windows, but it's untested.
Sigh. Django STILL doesn't pluralize 'octopus' correctly unless you tell it to :(
No it isn't a developer issue, the *default* is to be insecure. As one of the comments on the original bug thread pointed out, it is in every way as if php had register_globals on by default.
They are indeed very similar. One difference is Bottle is a single module with no dependencies outside the standard library. I'm using Bottle for an internal company app. IT constraints means it has to run as an old-fashioned CGI (I wish I were joking), and minimizing the number of files involved helps keep the launch time down.
An interesting project for this sort of thing is [sikuli](http://sikuli.org/). It uses screenshots to identify elements. They have an angry birds demo http://sikuli.org/blog/2011/08/15/sikuli-plays-angry-birds-on-google-games/ *uses jython, crossplatform
Really interesting and useful info here! The answer seems to be: yes, if you use OpenGL, but you might still want to write performance-critical parts in C. This makes me wonder: how about a modern 2D game like Terraria?
The main code is entirely in Python, with some parts written in C or C++ as optimisations.
Depends what you mean by 'programming games'. If you mean AAA titles that get shipped on consoles, then yes - they use C or C++, almost nothing else. But games can run on PC, or iOS, or the web, and they can and do often use other languages. Unfortunately Python is poorly represented due to having no simple web player and having historically neglected multimedia in its standard (and 3rd party) libraries.
Think that you will not regret a thing if you choose pacifichost.com. These guys know how to keep everything working and their clients satisfied. It is powerful enough for your business applications to run fast and efficiently. Hope it will help!
Unfortunately :( My OS world view is very narrow. Get outta here, mac users! *grumble grumble* However! A couple of other redditors have posted some cool cross-platform tools: [sikuli](http://sikuli.org/blog/2011/08/15/sikuli-plays-angry-birds-on-google-games/) [autopy](http://www.autopy.org/) [autoit](http://www.autoitscript.com/site/autoit/)
Just to note: *please* don't really use `from __future__ import *`. That affects all sorts of things without giving you an obvious marker for any of them. You also risk unpredictable effects if new Python versions add things to `__future__`. Imagine if you'd written that when Python 2.5 was new, and someone later ran your code on Python 2.6 - all sorts of things might go wrong. 'explicit is better than implicit': If you want to use future imports, explicitly write out each one you need, like `from __future__ import print_function`.
A... *long* time :) I didn't keep an exact log, but many, many hours. Editing all the snapshots/videos and whatnot was a pretty big time sink. 
I hate to be *that guy*, but the whole tutorial uses poorly written Python. I understand it is for learning purposes, but part of learning to program is actually designing efficient, non-repeating, code. No loops, no function arguments, no use of any data structures? It pretty much ignores every major feature of every programming language (not just Python). It's great to see how *easy* writing a bot can be, but it shouldn't stress that you have to think like a moron to write one...
http://pypi.python.org/pypi/scipy/
Thanks!!!
It's back up now. I've noticed scipy.org does seem to have irregular downtime.
no, but this does https://github.com/halgari/clojure-py
How does pyglet differ?
Well, that's what I'm wondering. Can it run clojure-py?
This looks pretty sweet seems even easier to plug apps into than django.
Was there a purpose to this other than posting a 4 year old talk, it's title, and author on r/Python and hoping to get some karma from Django-hate?
Yep, just tried it. had to install `python-dev` and `libxtst-dev` from the repositories, seems to work fine after that.
The Quick Start link was... surprising
Please post your question to [/r/learnpython](/r/learnpython).
Use a hashmap, with the words as keys.
It was down this morning as takluyver said, but is back up now.
Sure, but any significantly complex game (e.g.: Skyrim) simply can't be done with a single core. Minecraft might get away with it because there are some pretty restrictive constraints on physics and game mechanics, but any game that does a great deal of number crunching almost certainly needs the capacity of a second core. You could nit-pick further and say that hardware acceleration of graphics (is it even possible in Python without using some sort of C library?) inherently uses extra cores because the GPU is fundamentally based on the concept of multiprocessing. You couldn't do any real graphics rendering in CPython alone: texturing, shading, and lighting (not to mention the volume of polygons introduced by meshes) simply become intractable without being able to use a GPU. Even most of the highest performance "single-threaded games in history" have taken advantage of the GPU to perform rendering.
Ironically named because Bottle is the only web framework that doesn't drive me to drink.
With this you can click and drag. import time import autopy as ap from autopy.mouse import LEFT_BUTTON def leftClick(): ap.mouse.click(LEFT_BUTTON) time.sleep(.1) print "# click" def leftDown(): ap.mouse.toggle(True, LEFT_BUTTON) time.sleep(.1) print '# left down' def leftUp(): ap.mouse.toggle(False, LEFT_BUTTON) time.sleep(.1) print '# left release' ###### if __name__ == "__main__": time.sleep(1) leftClick() leftDown() time.sleep(3) leftUp() Edit: `sleep(.1)`'s added.
There's also a limit on the amount of C++ graphics stuff actually needed in a project. The vast amount of this work in most projects will be done by people whose full time job is writing graphic engines that other developers then bolt their game logic on to.
Agreed. It effectively becomes a kind of library. 
&gt; Sure, but any significantly complex game (e.g.: Skyrim) simply can't be done with a single core. This is really just a comment that started to be made once dual core processors became widely available. If your task is parallelisable **and** you can expect there to be a second core sitting around on computers that will run it then great, it will run better with a second thread. There's nothing particularly magical about multi-threading but it's a good technique to use when it's appropriate.
Of course multiprocessing is nothing magical, but the volume of work that many games today require is simply intractable with the horsepower of a single core. There are plenty of different kinds of calculations that need to take place, and there are plenty of ways to architecture a game to take advantage of the extra processing power. Games today are in many cases much more complex than games from ten years ago, and in order to handle the sheer volume of work that needs to be done, multiprocessing is in many cases a requirement. Bear in mind also that with the advent of multi-core low-power CPUs, it's (in some case) entirely necessary to multithread code because the amount of work that can be done per core per second is "decreasing."
I think it's interesting to note that Django doesn't use SqlAlchemy and that the largest number of bug defects are against Django's ORM. Not that using SqlAlchemy would fix all of their problems, but wouldn't it be nice if it integrated seamlessly.
That is exactly what he said...
Usually software metrics focus on measuring complexity of single functions as if they were isolated from each other. IMO the biggest complexity of large projects comes from the inter-dependencies of functions and modules.
Yays baas, I was just adding corroboration....
That's unfortunate for you.
So you really find it interesting that the most complex part of a software project has the most defects?
Ahhhh thanks so much I was banging my head trying to get it to work and didn't have python-dev installed for some reason!!
DRY.
Seems that for making an app that is just a JSON API, Bottle makes things a fair bit easier. For one it includes `@get`, `@post`, `@put` and `@delete` decorators out of the box, and it also converts Python dicts returned from functions directly to JSON strings. Of course you could implement the same concepts in Flask without too much trouble, but the fact that they're already included is nice :)
In general, `self` is the object that the method is being invoked on. It is automatically added to the argument list when you invoke a (bound) method, so you would call this with two arguments e.g. `foo = Person('Bob', '$10000')` and the `self` would be automatically supplied. In the `__init__` method, `self` is the object that's being initialized, and `__init__` is sometimes referred to as the constructor. The period is used to reference attributes of an object, so the left hand side of the assignment is the `salary` attribute of the object that's being constructed. The right hand side is the `salary` parameter of the constructor. That these two things happened to have the same identifier is just convention; there is nothing special about them having the same identifier. The method would be exactly the same^1 if it had been written like: def __init__(self, foo, bar): self.name = foo self.salary = bar self.pet = None Except that the original version is much easier to read. You see this in constructors because you generally want to initialize new object instances with some values, which are passed as parameters to the constructor which stores them in the newly minted instance. [1] Except when calling it with named parameters, of course.
Python is able to [import modules and packages from zip files][1]. [Setuptools][2] takes advantage of this to create egg distributions, which are [zips containing one or more modules and packages][3] (and other stuff). So one file (a zip) may contain more than one module. Although with the gradual adoption of [distribute][4] / [packaging][5] I think the egg format will finally die. [1]: http://www.doughellmann.com/PyMOTW/zipimport/ [2]: http://peak.telecommunity.com/DevCenter/setuptools [3]: http://mxm-mad-science.blogspot.co.uk/2008/02/python-eggs-simple-introduction.html [4]: http://packages.python.org/distribute/ [5]: http://docs.python.org/dev/packaging/
From the website: &gt;Currently, TextMate support in IPython is broken. It used to work well, but the code has been moved to IPython.quarantine until it is updated. Sounds like we're SOL.
Just tested it: Added c.TerminalInteractiveShell.editor = 'sublime' to ~/.ipython/profile_default/ipython_config.py Started up ipython and did %edit with sublime!
Oh. Good!
PyCon! SciPy(Con) is good too. I 'm not in the United States though.
Last I checked (at PyCon 2012), at least three of the creators now sport beards. One of them could even host a small family of wrens.
I don't know your game, but where is the difference between a player and a monster dealing at the behaviour level? I would believe that it is more flexible to have a common base class for all "actors" and write things like "fights" based upon that.
Doesn't seem like something very much needed, or in any other language that I know of.
Oh nope. You misunderstand my fascination. I am glad you are still curious, though, because I mistook you for trolling. I would ask the question of: Why doesn't Django spend it's effort on creating a standardized way to integrate SqlAlchemy (which has better flexibility and power) into Django's ORM (which has better user-friendly features)? I like evolution. I think the marriage of the two would be better for both projects. I don't like violating DRY, which is something I feel that Django has done by continuing their effort to maintain their ORM depth. I do think that Django is a great project, but I feel that their largest contribution to the python community has been their backend/administration dashboard. Their continued prominence in python's ecology has more to do with their documentation and the contribution of the community than Django's technology evolution. I would acknowledge that part of the reason Django is so successful is because they were able to control every aspect of the integration of various components. And I understand that SqlAlchemy prominence came after Django's ORM. However, that is in the past. Moving forward, I feel that projects should be evolving to take advantage of each other rather than compete with each other.
I know, it just seems missing since getting iso weekday and calendar is just a matter of calling: date.isoweekday() and date.isocalendar() 
Why would you? It could help if you explain your motivation. It's not trivial, and it's easy to do wrong actually. (I've found bugs in the SciPy implementations, for instance, at the extremes of some distributions.) One possible reference would be the R source code (in C). The distributions that form the basis of most statistical tests are separated out into their own library (look for "nmath"). Just reading some of the comments in this code will give you an idea how complex it is to do it *right*, and how experts are still debating implementations. I quickly gave up on porting this code wholesale to Python -- there's too much, and it's too intertwined (but with good reason). However, it's designed to be compiled into a standalone shared library (without the rest of R), and I've had good luck calling that using ctypes. Just a thought.
PyCon, of course. Other suggestions really depend on what sort of work you do; no point in going to unrelated specialistic conferences, as "good" as they might be in a generic sense, if you don't work in the same field. Your handle on twitter is a "director of marketing at Tracelytics", is that you ?
At this point, I'm keeping them separate, because I may have things that alter the player's fighting. The key word there is 'may.' Once I have a functional game, I'm going to review the code and rebuild it from scratch. I may find that I can make it more generic, or I may find that doing so makes things more complicated for me as I add in things like potions, weapons, and alternate fighting styles. 
This reminds me of the algorithm to determine the day of the week from an arbitrary date, which is a fairly common into to programming assignment. 
I'd love to do Djangocon but judging by the prices, they are trying to make profit. As a single developer there's no way I can fathom paying for the ticket, plus the cost of the flight from Canada. I've basically given up on going.
Go for it, it should be a good exercise. There's a built in `sum()` function that takes a list. You might also want to use list comprehensions, like: diffs_from_mean = [x-mean for x in somelist]
Well, you just missed LibrePlanet! Bad timing :)
Can you point me to a reference or guide for using those three together? I hadn't heard of fabric but I'm poking around with it now, but I don't want to miss anything!
yes, but somehow i feel it's missing from the datetime module, as a compliment to the date.isoweekday() and date.isocalendar() methods.
PyCon. Definitely PyCon.
I've been working my way through all of the PyCon 2012 videos, and watched this one the other day. It's pretty entertaining, but I was disappointed with his lack of details in some areas, and particularly not getting to see any video of the turret in action :( (that is, video of the device itself - streams of water flying into the air were not that impressive, plus it could have easily been faked...)
Oh, whoops.
hmm... I already knew about `__version__` from pep8. I was hoping there were more. I have also seen `__author__` a great many times. So often even, that I believed they were standardised somewhere. But so far, I have never tripped over a list of these variables :(
I would like to see the source on Github as well. 
So for Europe, what would you recommend? - Europython? - EuroSciPy? - anything else?
Which!?
Thanks! Hope you find the time :)
ok, I have cloned cpython, and are following the [patch guide](http://docs.python.org/devguide/patch.html), do you think that a method signature of: def iso_week_start(year, week, isoweekday=1): would be a good idea, sice you could easyly get eg tuesday of week 5 as: date.iso_week_start(2012, 5, 2) and any start of a week as: date.iso_week_start(2012, 5)
That makes sense to me. Keep me updated on the progress of your patch too. I'm curious to see how long it takes to be accepted.
I like the diversity of the HackerNews community. People who like Ada and Fortran read the site as well as those who like Python, Ruby and JavaScript.
/r/python is not surprised by this.
[issue 14423](http://bugs.python.org/issue14423#) Thanks for the encouragement. 
OOOO vast generalizations :D Yay!
I think you should tell us how you really feel about PHP.
see how successful they have been for the government and mainstream media? get with the program dude. you won't get very far if you don't accept your state assigned category. 
TIL there's a language more disliked than PHP. I also did not expect the negativity towards C++.
I can't help (still a newbie myself) but don't rule alternatives to face to face tutoring for python. You can do pretty well over phone, Skype or just email.
Could you point me at some clarification of this point (or joke, if its)? I've heard it a few times but have no idea what it's referring to :(
... given this is going a bit off topic, and as it seems that there is no formal standard for these meta-variables, I consider my question answered ;) Also, I believe that most of the fields mentioned by sylvain_soliman duplicate information found in `setup.py`, and should, in my opinion be kept therein ;)
You know, I have a hunch he doesn't like it... I don't know, though.
You would be *shocked* at the amount of fanboys that Objective-C has. It puts RoR fans to shame. Otherwise normally intelligent people are actually convinced that it is one of the best languages in years and can't wait until enterprise apps are being developed in it. Ugh. 
Actually, it's *other* *peoples* use of the language that you end up loathing. You eventually make peace with a subset of C++ that you think is just right. The problem is that everybody seems to find a different subset... The language is just too damn big!
Unfortunately, not really. I got familiar with them separately and just put them together for great justice.
Anyone got a link to the presentation?
After the Stanford /r/aiclass I ended up putting some time into going [*the other way*](http://code-by-code.tumblr.com/post/15226719929/nltk-ai-class-shredder) and rewriting stuff I'd done in raw python using NLTK instead; you might find the "before" cases there useful - I also recall the NLTK implementation itself being pretty clearly commented and readable, so you might look at their python code for ideas: [`nltk.metrics.association`](http://nltk.googlecode.com/svn/trunk/doc/api/nltk.metrics.association-pysrc.html) `NgramAssocMeasures.student_t` might be a little too dense, but see if you can unwind it from there...)
Ok, that's a point :-) I always like to separate most things that are different from "AI"-played actors (almost certain it is the user-input at all kind of actions) via Controller-Objects for example. This way I can implement a human player later on and test the basic game logic in an early state without having to code too much :-)
Swanky! Laggy.. but swanky!
That's an interesting observation. What is Ruby without Rails, and Obj-C without Cocoa? By many accounts it is much easier to develop for Cocoa in iOS and OS X than it is to develop in Java (IIRC) for Android. But you wouldn't use Obj-C to develop a web site.
Yeah it seems like adding the left comment marker made it a bit sluggish. I'll optimize the js for that and hopefully that will improve things.
One of those 3000 votes is mine! I feel so significant now! :)
Octopus is pluralized as octopuses. Django by default just adds s.
Would have thought more people disliked javascript.
thanks, can't say it made much sense. I will read it again in the morning I guess. :)
I can't understand why they would just pull all that stuff down. It was really simple before then. Thanks for the reply sir!
Maybe I wasn't clear. In what crazy combination of setup/settings/site/life would you have an octopus in your django in the first place? O_O
Your guess is as good as mine.
-
fwiw enterprise apps use XML for everything because, in my experience, enterprise development involves making a bunch of shitty programs your company/institution bought play nice together. XML seems to fit the bill for a thing that is flexible enough and mutable enough to make that happen in a reasonably reliable way.
Rexx's still around!!!
Flask and jQuery would be great for this.
Naw, we'd just prefer to make money coding in a language that doesn't make our eyes bleed.
Thanks. I do plan on offering some additional filtering options in future releases.
Kind of off-topic, but where would you get your stats?
Or write.
there is at the very least a plan to make stuff like SciPy, matplotlib and friends working, by whatever hacks necessary. Chances are it'll mean embedding libpython as a "translation-layer"
1. What platform are you using? 2. What have you tried (exact commands)? 3. What was the result (exact output)? 
Java versus Python?
C is nice. Very simple, not at all like C++.
You don't, they're not part of a default Python installation. Install distribute and pip following [these instructions](http://www.pip-installer.org/en/latest/installing.html#prerequisites). Aside: you don't need to install simplejson - it's included with recent versions of Python as `json`.
Python would be a great language to do this in. There are a number of different web development frameworks written in Python. Personally I'm fond of Django - it's *extremely* well-documented, has a great community and loads of resources out there for learning it. It also ships with a lot of the functionality you need out of the box, such as an admin interface, and a flatpage application.
Or read.
You should gamify your application. Something similar to stackoverflow with ranks, achievements, levels, feats, hidden pages, etc. Everyone loves games and this could be a nice one.
Went to PyCon, going to EuroPython. 
Don't forget about XML schemas and the ability to validate unknown data in an incredibly effective manner. That's very important for finance/oil industries.
Eeeiinnteresting. If you don't mind me asking, what do you like in 3.x that's not available in 2.x? What 3.x stuff can't you live without anymore? 
Django. Or are we discounting that because it's (much) more than a templating engine?
-
You definitely can and Python is very well suited to the back-end of such a website. Basically what you want is a website that acts as an app allowing users to interact with a database. For that, there are many "web frameworks" written in and for Python. My favorite and the best to start with, in my opinion, is Django. It makes a lot of decisions for you and gets you going quickly towards having a website that interacts with a database easily and without worrying about the difficult aspects, even SQL (at first.) However, if you are a python newb, I would recommend that you spend a little time working your way through one of the Python tutorials and working on a few small, silly, non-web projects first, so that you aren't learning both a new language and a web framework for that language at the same time when you move into Django.
Django is pull-style templating. 
Can you give an example of something impossibly hard in C? If what you mean is type-safety, I agree C++ adds a lot over C in that regard.
Nothing, I still do 2.x as I said; but print function, true division, simplified types, cleanup of operators, standard library cleanup, .pyc repo directories, and unicode/bytes are nice. It's also a lot easier to teach Python 3, since it has less inconsistencies and edge cases. Mainly, there is no good reason to stay in 2.x, which will not get the benefit of the new PEPs; it's just clinging to the past. 
You can certainly do that with Python, and in particular, you should use one of the many excellent web frameworks available. In addition to those already mentioned, you would do well to check out [web2py](http://web2py.com). Like Django, it is a full-stack framework, but I think you will find it easier to learn and use. There's an excellent [online book](http://web2py.com/book) (which even includes a brief intro to Python), and you'll get lots of friendly help from the [Google Group](https://groups.google.com/forum/?fromgroups#!forum/web2py). Give it a quick try -- just [download](http://web2py.com/examples/default/download), unzip, and click to get it running. You can use the built-in web-based IDE ([demo](http://web2py.com/demo_admin/default/site)) to start playing around. It also includes a mobile-friendly scaffolding app ([demo](http://web2py.com/welcome)) to get you started. Here's a [video](http://pyvideo.org/video/714/web2py-ideas-we-stole-and-ideas-we-had) from PyCon 2012. You might also find [this](http://www.quora.com/What-are-the-advantages-of-web2py-over-Django/answer/Anthony-Bastardi) helpful.
PySerial
Create a better implementation of std::sort in C. That's pretty damn difficult.
The main reason for sticking with 2.x is add-on compatibility and Django. Although add-on compatibility is getting better for py3k, it's still not as good as 2.x. Plus, I'd have to port my codebase to py3k, and since I do a lot of binary reading that's gonna be a huge PITA to do.
if you need to cite Chomsky to explain how your template engine works, you're off to a bad start...
it means template engines that have no logic in them (or at least seem to have very little logic, of course it's still there), the shape of the incoming data forms how the HTML is rendered. By far the nicest presentation of this style are the docs for [mustache](http://mustache.github.com/mustache.5.html).
That's a good idea. I haven't put as much effort into the karma side of things as I should. Thanks for the tip.
&gt;it means template engines that have no logic in them actually the template "file" has no control structures in it. again, Terence parr's paper is the definitive reference on it. &gt; the shape of the incoming data forms how the HTML is rendered. actually the program code decides how to manipulate the HTML. "shape of the incoming data" is what mustache does &gt; By far the nicest presentation of this style are the docs for mustache. I just stared at mustache and it reminds me of [Template::Simple](http://search.cpan.org/dist/Template-Simple/lib/Template/Simple.pm#SYNOPSIS) and neither is genuinely push-style in my eyes. They are minimalist templates which attempt to limit the amount of markup and control HTML generation just like you say. 
&gt; the shape of the incoming data forms how the HTML is rendered. yes, if you think about it, Mustache is trying to effect all programming by reformatting their data, possibly through multiple passes in order to effect programming. I personally would just rather do programming. 
I'm not ruling them out at all. It would just be a lot easier to learn Python with someone helping you out in person, you know?
Good news, the Django guys revealed at PyCon that they will have experimental support for 3.something in their next release - but yes, using major third-party software that is not yet ported is a good reason to wait. Still, you'll have to do that port eventually since the 2.x line has reached the end, and the porting might not get easier with time (although 3.3 adds u"" notation back for ease of porting...)
I might be missing the point, but isn't midiox strictly win*?
1. get sense of humor it's the internet 2. fuck off, it's the internet (free speech) 3. die
portmidi is actively maintained, and it's reason for being is to be cross-platform and the simplest thing that works. So I'd focus on that. Talk to the maintainers if you're having compilation issues under C; and John Harrison of pyportmidi is approachable, too.
It is necessary for women to include that fact in their usernames because the default user is male, and some find it irritating to have that assumption all the time. Note that this post in particular did not object to gender bias, but to a particular joke that she found offensive. She had no comment on gender bias that I could see. What would your response be to a bot that you found offensive (for example one that added random quotes by women)? Many people just suck it up and try to forget it, others don't.
Great that someone is using Python to solve a problem, but I think once again the main issue is being brushed aside. I'm sure I'll get down modded for this, but someone has to keep saying it. But I don't get why people find this kind of thing acceptable in a modern workplace. Jokes that offend colleagues should simply stop. She asked for it to be turned off and I think that's a legitimate request. This is about respect, not being politically correct. If two colleagues want to have a private joke together and say this kind of thing, fine, as long as it's acceptable to both of them. Anything more public though should take into account how acceptable it is to everybody. Flirty banter vs. sexual harassment is another example, one is welcome and pretty much mutual and the other is unwelcome, but there is an extremely fine line between the two. None of us want to work in a sterile feeling workplace, but we're all entitled to be respected. To the poster who is saying that it is hard to take someone seriously because their handle isn't gender neutral, that's ridiculous. We don't need to be gender blind, we just need to be fair and respectful. It's like suggesting that if women don't dress in an androgynous manner then it is fair game to make comments on their appearance that you wouldn't make to your male co-workers. Equality and diversity aren't incompatible.
&gt; there is an extremely fine line between the two. That's what he said. 
It's not that the phrase itself is sexist, it's that throwing it around all the time highlights sexual difference constantly in a way that's uncomfortable. Plus, once the programmer asked for the bot to be turned off, she was ignored. Why? We can't know that it was because she was a woman, but maybe that led to the guy thinking, "Oh, whatever. Women just don't get jokes." Anyway, if it's making someone feel bad, why is it so important to keep the bot running? Isn't the point of jokes to make people feel good?
&gt; actually the template "file" has no control structures in it. again, Terence parr's paper is the definitive reference on it. not sure if the purpose of this webpage is to evangelize the "push" model, if so, you really need to have a description formatted for non-academics, with simple, concise, to the point explanations, substantial and complete examples. The PDF document as well as that other blog post are for most people unreadable.
I think people have a right to go about their workday without having anything sexual highlighted, man or woman.
I think Selenium is your best bet, regardless of documentation. It's designed for exactly what you want, and is by far the most prominent of such tools.
As a C programmer, I have to admit this is true.
Yeah, but how to overcome this limits?
If you feel disrespected because someone made a joke that has nothing to do with you, then it's not their problem. It's your problem. You can't expect the world to sterilize itself in the off chance that some remark offends someone somewhere. No one has the right to not be offended.
The ignore command is an imperfect tool. People will still reference what the bot said, making the flow of conversation awkward.
&gt;it's that throwing it around all the time highlights sexual difference constantly in a way that's uncomfortable. Is it uncomfortable for a reason other than being constant? Why is it sexist to "highlight sexual difference"? (Except that isn't really what's going on; it's highlighting *innuendo*.) It *is* kind of sexist in that it's based in the assumption of a predominantly male environment; the idea is that the speaker is implying that the innuendo is similar to something that was said by a partner in a former sexual context. So it's also heteronormative to that extent.
There's overt sexism, and then there's just having a hostile environment. In an mostly-male environment, where statistically most people are straight, it stands to reason that women may feel intimidated if the environment is sexualized. And after all, who are they going to complain to - a man?
Documentation is not a joke.
It's kinda weird how C is apparently so much more liked than C++. I suspect that many of the misconceptions about what C and C++ really are (and how they relate) play into this.
Type safety.
Being able to set up a web server quickly in javascript doesn't make the language's core WTFs disappear. It's also really hard to get stuff done client-side without jQuery.
http://code.google.com/p/pywebkitgtk/
Every time a C program segfaults on me, I'm usually quite surprised. I rarely had the same problem in the equivalent C++ program. Classes, templates, and better memory management made C++ infinitely more enjoyable to program in than C for me personally.
I don't want to come off as a fanboy or anything, but you'll have a lot easier time working in Python under Linux. What I generally recommend to the Windows folks is to set yourself up a Linux VM. [Virtualbox](https://www.virtualbox.org/wiki/Downloads) will get you going quickly and easily. Then just grab a copy of [Ubuntu](http://www.ubuntu.com/download) and you're on your way. Actually, now that I'm looking at the site, it looks like Wubi has evolved to where it'll run as an app. I'll leave that to you to figure out, if you care to. The VM route has the added benefit of being fully isolated from the rest of your workstation, so nothing you do in Python will bork any other work/games/movies/whatever you have going on.
How about http://splinter.cobrateam.info/ Will this do the trick?
 sudo make me a sandwich Humorless fucks.
&gt;Why is it sexist to "highlight sexual difference"? It's more than that. It forces women to be viewed in a strictly sexual sense. The joke is just, "Haha! That's what a woman you are having sex with would say!"
Yup, the stats is really the absolute killer when developing any kind of Fantasy app. I made a specialized app for fantasy football last year (I actually used Python and served a simple front end using Django), and getting and organizing the stats was by far the hardest part. I ended up scraping ESPN's fantasy web site.
-
I have tried Dive and Hard Way. I have not gotten into them or Python real extensively, but enough to know I really like it. What I did not know is if it would be a good application for this example. Where do you think I will need the JavaScript? Thanks!
I think that's an outdated way of thinking, based in religious values. I mean, sex ain't nothing but a thing, and it shouldn't be taboo.
I think my HTML and CSS skills are already high enough to make a decent front end, but where do you think JavaScript will come in? Thanks!
I think it's rather unfair to prejudge someone in that manner. You don't even know the chap or the group and already you're jumping to 'possible' conclusions with tenuous evidence.
&gt; I don't see anything too remarkable in writing IRC bots Yup, I feel the same about building paper planes. I'm a rocket scientist.
No problem. 
There's a difference between something being taboo and bringing it up in contexts that are focused on other things. I don't stop my Tai Chi class to have a discussion about Microeconomics. I'm into both, neither one considers the other "taboo," but at they same time people go to Tai Chi to do Tai Chi. They go to work to do work, not to highlight sexuality. And when something is taking away from people's ability to do what they came there to do, it's a problem.
&gt;Well sure, a dude probably wouldn't have sex with a dude Roughly [8 percent of men](http://en.wikipedia.org/wiki/LGBT_demographics_of_the_United_States) are gay or bisexual.
Because it treats women as solely a sexual object.
The graph, in my opinion, shows the more vociferous opinions about programming languages. And it makes sense. Perhaps Java is widely used, but that doesn't mean everybody who uses it likes it. (I've used it several times, but never by choice and hopefully never will.)
Well expressed (and I agree and was sort of trying to get at the same thing), thank you.
So does having sex, by that logic. A one liner doesn't have to have a long story in order to flesh out the character at all. TWSS is literally what a girl might say in bed. It says *nothing* of her competence as a parent, a worker, or a friend. This absence does not mean there's nothing else to the average women, it just means the joke does not need to go into anything but the sexual side of a woman. 
This may be a bit more than I am looking to take on but will definitely check it out.
&gt; if you're disrupting the ability of people to do their jobs, you need to leave. In other words, people who can't control their own emotions, so I need to control them for them? You must be fun at parties.
I will probably do a little of both: Going through the tutorials again and biting off more than I can chew in trying to make the minimum product. I know, it's normally a bad idea but I learn a bit better when I am under a trial by fire. Also since this is not a business per se, I am not under pressure to make money, just get it up and running. I promise to try and be smart about how far ahead of myself I will get. Thanks!
No. No it doesn't. TWSS doesn't have anything to do with women, but rather the sexual prawess of the man. Except since it's always feciously, it's sort of the opposite. Juvenile? Sure. Inappropriate? Yes. Sexist? No. Let's not call any joke that involves sex sexism. It desensitizes us to real Rush Limbaugh style sexism. I'm glad Rush is around to help us understand what real sexism is, because TWSS jokes are not sexist, just lame. 
&gt; It sexually objectified her gender and made her uncomfortable. It had a lot to do with her. So eliminate all jokes that objectify gender from public places? Yeah, right, OK. &gt; She's not asking for that. She's asking for her coworkers to silence a bot that spams sexist, middle school jokes. Not really. The OP seemed more like she was just annoyed at a joke that got old fast. She even admitted to using the joke several times as well.
I don't think it's sexist either. My friends and I use "that's what she said," but we also use "that's what he said." We also use both variants in their hetero- and homosexual forms. It actually gets pretty confusing, but it is equal opportunity offense. Of course, if someone were to hear us in isolation, we'd be branded as "sexist" by some people here.
Aren't you really just saying that people shouldn't be annoying? Yeah, that'd be great, but I don't think it needs to be branded as sexism against females.
&gt; And after all, who are they going to complain to - a man? Yeah, why not? Did it ever occur to you that maybe they didn't know they were making [insert minority here] uncomfortable?
&gt; Plus, once the programmer asked for the bot to be turned off, she was ignored. Why? We can't know that it was because she was a woman, but maybe that led to the guy thinking, "Oh, whatever. Women just don't get jokes." We also can't know if the OP constantly and consistently complains about offensive jokes. If that were true, I'd consider ignoring her in this case completely reasonable. Otherwise, yeah, I'd agree---they were douchebags.
Since you're willing to switch from tkinter to pygtk, you might as well give PySide or PyQt a try. Qt 4 ships with a webkit component that both [PySide](http://www.pyside.org/docs/pyside/PySide/QtWebKit/index.html) and [PyQt](http://www.rkblog.rk.edu.pl/w/p/webkit-pyqt-rendering-web-pages/) expose.
Ok I've only got to the part about the bot &amp; I've had a few dark beers.... But seriously that's hilarious having a bot at work that interjects that's what she said in an IRC channel. Is this something that can be downloaded somewhere?
&gt;So does having sex, by that logic. I don't believe so. &gt;TWSS is literally what a girl might say in bed. Do you see why this might be a problem in the larger context of our society? Women are constantly treated like sex objects, so having a joke be only what a woman would say before/during/after sex is a bit of a problem.
Okay, cool. It has been one of the languages I want to get a real basic understanding of. Thanks!
As I said in a comment I just left to another user, I'm sure there have been some funny TWSS jokes, and I'm not saying you can't quip "That's what she said!" with your friends. Having a bot spam TWSS in a work chatroom and refusing to turn it off when someone says they're uncomfortable is what I have issue with.
And I'm talking about how when you assume "the average dude" will be straight, you're marginalizing others.
You know what 'average' means right? I'm just going to have to assume you're being an ass or just looking to get offended.
What is my assumption then? My comment says "a dude is probably not banging another dude". You brought in the statistics which support my point. There are no assumptions.
Technically speaking, it could be "That's What He Said" in the context of a male-male relationship (bi/gay). It's basically what someone would say about their partners penis size or amount of arousal during sex. &lt;/overanalysis&gt;
&gt;that's just stating fact, there's no assumption there. No. Like I said, you're using the statistical likelihood of the average person being straight to assume everyone is straight. &gt;Otherwise though, I don't think you're trying to prove anything at all here. I'm trying to prove the joke is sexist.
Funny enough, I'm having an argument about orientation stereotypes in another comment thread here!
I was going to use 'troll' but I try to avoid using words like that. It seems like you're not trying to though, after this post. It really seems like you have the impression that 8 percent of people is more than it is then, if you have a problem with me assuming most people are. &gt;The whole joke is assuming the woman is one you're having sex with. Because it's a joke told by men. Men mostly have sex with women, so there's no problem with it. &gt;Because that's not what was said. It wasn't said, because if a dude is talking about having sex, he's probably having sex with a woman. If it was a chick talking about having sex, she's probably refer to the mate as a male. But then the joke loses some of its identity as a male spoken joke. That's still not sexist. I don't mean to offend you though. We're just not going to agree. I apologize for suggesting that you were being an ass.
&gt;But then the joke loses some of its identity as a male spoken joke. That would be part of what I'm referring to. The joke becomes unfunny when the genders are switched. The other part is the meat of the joke reduces women to a cliché sex partner. It's rather subtle, but that doesn't mean it's not just as problematic as a blatantly sexist joke.
Okay... so how would one guy make a joke to another which demeans his sexual prowess by referring to what his girlfriend, but not necessarily all women, would say?
Why does this one guy need to demean another's sexual prowess specifically via this other guy's girlfriend? Can't he insult him some other way?
Pretending like programming isn't male dominated does not make you post-sexist. It's like closing your eyes so the room isn't dark anymore. Yes, the vast majority of programmers are male. Acknowledging that is the first step to fixing it.
&gt; It forces women to be viewed in a strictly sexual sense. It boggles my mind that people can actually believe that - that people's minds are so flimsy that they can be "forced" by such a trivial thing.
Not true. I've only heard this phrase used in conversation between men. I'm not trying to dismiss your personal experience, but your personal experience isn't "the truth" - just your experience. Edit: BTW, it sounds like you are dealing with disrespectful and rude coworkers.
I'm the last person to suggest that this industry isn't male-dominated, but to assume that someone who would write/control a TWSS bot must be male is sexist in itself. Hell, the first time I ever heard that joke was from a feminist woman.
&gt; Why is that not offensive, but sex is? TWSS isn't gossip. If you were to have a discussion on... favourite things to do with rope during sex, that would be fine. You could probably even work in a couple of jokes that would be incredibly offensive if said during other discussions. TWSS, on the other hand, is a quick quip, the effect of which is to reduce women down to what they do in the bedroom.
You have to use the '&amp;' operator because 'and' is ambiguous in this case. 'and' could also mean *are all* of the elements in array1 and array2 true, *are any* or *which ones.* The last case is the one we're interested in. I wouldn't be upset if this was the default behavior, because I stumbled on it to. import numpy as np x = np.random.rand(300) y = np.random.rand(300) x[(x &gt;= .5) &amp; (y &gt;= .5)]
It's really not. I'm a white male, and I work in IT and I can assure you that sexism is indeed rampant in the industry. I would suggest that you check out an [excellent talk](http://webchick.net/comment/978) by Drupal's webchick ([pdf](http://webchick.net/files/presentations/women-in-open-source-owv09-2009-06.pdf)), ([flv](http://webchick.net/files/videos/women-in-open-source-owv09.flv)). Specifically, I suggest scrolling down to the "Horror Stories". Sexism is there, and it's rampant. Now this is not to say that I agree with the OP in this case. Personally, I think that claiming this joke to be sexist and combating it in this way is a little selfish but that doesn't negate the fact that she likely runs into sexism on a daily basis.
Yes, let's insult people in a way you specifically approve of. Just find "some other way" that doesn't offend you specifically and it's completely OK. That's why no one takes people like you seriously.
Yes you can complain to a man? Do you think they're all the same? &amp;#3232;\_&amp;#3232;
perhaps non optimal without dicts, but here is a straight forward means if you are looking to get your logic sorted. A very simple way of separating data into an array: data_array=[] file = open("filepath","r") for line in file: data=line.split("\t") data_array.append(data) column naming is a matter of array formatting, going so far as per entry tuples based on data indices if you really wanted the field name in every entry instead of just the first row of the array. e.g. col_names=["name1","name2",..] for i,item in enumerate(data): data[i]=(data[i],col_names[i]) and implemented with the first snippet: col_names=["name1","name2",..] data_array=[] file = open("filepath","r") for line in file: data=line.split("\t") for i,item in enumerate(data): data[i]=(data[i],col_names[i]) data_array.append(data) If the names *were* given in the first line of the file then you could set col_names simply: col_names=file[0].split('\t') Depending on the formatting of the names it may be necessary to use str(col_names[i]) in the future though.
 &gt;&gt;&gt; xyz_there("x.xyzyz") True oops
&gt; OP customized the solution to exactly what was asked -- nothing more and nothing less. no, definitely not (see my previous comment).
 def xyz_there(str): return any('xyz' in s for s in str.split('.xyz'))
This misunderstands the meaning of the word "rampant". Rampant is a movie with Woody Harrelson in it. I kid. Rampant just means something (usually unwelcome) spreads unchecked in an area. There's a lot of it and, for one example, you clearly aren't checking it.
&gt; Is it uncomfortable for a reason other than being constant? I think it being constant is quite a big deal. This is what separates it from just being off the cuff quips. This business has *automated* its That's What She Said jokes. Even very, very innocuous things take on a different character when they're repeated constantly and people *have* to be there because it's an essential communication channel for their workplace.
That's pretty tenuous. Edit: The deleted post was an argument that "that's what she said" was actually *blasphemous*.
&gt; Freedom of Speech isn't supposed to protect me asking my brother what he had for dinner, it is supposed to protect controversial speech. You can speak controversially. Have you ever read the Daily Mail's articles on various minorities? The difference is that they're vaguely based in fact and logic. "Fuck black people, full stop" is not. Free speech is intended to prevent the Government from censoring *political* speech. Despite having hate speech laws, we still have entire newspapers dedicated to controversial political opinions, and you're definitely allowed to petition the Government to keep gay marriage banned, talk about that with your peers, etc etc. It happens every day. You could even say "all gay people should be put in mental hospitals" if you could make a vaguely valid case for it. We had a party that made a big splash a couple of years ago, I believe, who based their platform on kicking everybody who's not "true British" out of the country. They got prime TV time to discuss their views. As far as I'm aware, they were not disbanded, and none of their members or supporters were arrested simply for supporting their views. Come back to me with a source of someone making a valid political statement without harming anyone significantly in the process of doing so, and managing to get convicted for it. EDIT: I didn't downvote you, for the record.
&gt; You know what 'average' means right? If we're making it a *statistical* argument, I think this is one of these times the article described as: "To me, all of this seems like typical geek behaviour: something is making them uncomfortable, and so they attack it on “rational” grounds. Most likely, they aren’t even aware of the gut reaction fueling their logic."
Especially something rather challenging like a programming language.
While intention is definitely important, one should think about what they're saying and how it'll be received; and if something seems to be being received badly or considered by a particular individual or subgroup of people, especially if that individual or subgroup is a minority, it's probably a good idea to think about exactly why they would consider it offensive, and possibly tone it down a bit even if you disagree. That that didn't happen is the problem here, more than anything else. Personally, as a transgender person, if the people in my workplace were cracking jokes about "woman who has a penis", I'd find that offensive and ask them to stop; I'd also expect them to ask why I consider it offensive in return. It's a part of communication and socialising and learning. Unfortunately, this is the real world and that probably wouldn't happen, but I can dream. Basically, this revolves around public spaces and respecting others, even if you personally do not consider it sexist and never intended it to be. Given that this is the company-wide IRC channel and she doesn't have much of a choice whether to be in it or not, one would expect this sort of thing to be kept to a minimum; I expect that she wouldn't mind so much if it was just an occasional quip between friends in PM. Public spaces in general have a much different set of rules. Anyway, this person managed to turn it into what she considers a more welcoming environment, even without removing the bot, so all is well, at least for now.
Definitely, although I think the most important thing is to find an excellent tutor/mentor figure. It's better to deal with an engaged, enthusiastic and knowledgable tutor by postal mail than to have face to face tutorials three times a day with a bored, ignorant one. The holy grail is to combine both.
With all due respect, I think you're way over-complicating this. The following is all you need to read the complete contents of a tab-delimited file without regard for naming the columns: from csv import reader data = [] with open('filename', newline='') as f: for row in reader(f, delimiter='\t'): data.append(row) That's it. `data` contains a list of lists, so `data[0][0]` is the first column of the first row, `data[0][1]` is the second column of the first row, `data[0]` is a list of all the columns in the first row, `data[1][0]` is the first column of the second row, and so on. You can do whatever you want with this very easily, for example to print the second column of every row: for row in data: print(row[1]) Or: print('\n'.join(row[1] for row in data)) To print the third column sorted: print('\n'.join(sorted(row[2] for row in data))) By the way, this is a waste of time: path = os.path.join(os.getcwd(), 'so.txt') If you open a bare filename (e.g. `f = open('foobar.txt')`) it will default to looking in the current working directory, so this `getcwd()` tedium is not doing anything useful. 
I wouldn't call them rude - just misguided. I work with a lot of transplants from other countries who are new to the whole TWSS thing, and BOY do they love it and, given the whole 'she' thing, think its only meant to be said after a female says something. I've been waiting for it to run its course, but damn is it annoying.
Fair enough.
Oh really... No.
They should use randomized tests à la QuickCheck.
I was kind of joking. 
Are you saying that you're unable to control what comes out of your mouth, and unable to think of others before you speak?
&gt; you really need to have a description formatted for non-academics, with simple, concise, to the point explanations, substantial and complete examples. ah, ok well [here](https://docs.google.com/spreadsheet/ccc?key=0AuxxPVc-8jyBdHVQUjBoUjhPUWJINE1XckpJZWJwRlE&amp;hl=en#gid=0) is my paring down of the academic information into something simple: 1. modify model directly or via methods with side-effects? For example: [% controller.age = 55 %] If your template can contain that, then it loses 1 point 2. perform computations on data? For example: Your new age is [! controller.age + 12 !] -1 point if your template system can do that 3. perform comparisons of data? For example: [% IF age &lt; 10 %] Hello [% name %], does your mother know you're using her AOL account? [% ELSIF age &lt; 18 %] Sorry, you're not old enough to enter (and too dumb to lie about your age) [% ELSE %] Welcome [% name %]. [% END %] -1 point if your template system can do that... Therefore I have to concede that Mustache is in fact push-style, because it does not lose any points for these issues. 
I'm not sure. Do I need to have an answer to your question to prove this joke is sexist?
I think it would be best to start looking into PyGame [1]. There's a great abundance of tutorial material available,[2] some of it specifically aimed at beginners with no previous knowledge of Python. Over the last few weeks, Katie Cunningham made a great series of blog posts about creating a game similar to the one you have in mind using PyGame. [3] See also her talk from this year's PyCon on the same topic [4] If you already know some Java, Python will be very refreshing for you, while the basic OOP concepts are similar (but you can actually do multiple inheritance, yay!), you are far less restricted in Python and require much less boilerplate code to achieve what you want. Pushing things out to C/C++ is mostly handled transparently by the libraries you'll be using (e.g. PyGame will use SDL), so you actually don't have to worry about the specifis of that. [1] http://pygame.org [2] http://pygame.org/wiki/tutorials [3] http://therealkatie.net/blog/tags/pygame/ [4] http://therealkatie.net/talks/pygameintro/
It looks more like losing to sexist to me. 
&gt; the effect of which is to reduce women down to what they do in the bedroom. It implies both sexes are equally in the bedroom. So it equally reduces men. 
[Pygame](http://www.pygame.org) is what you need. The graphics pushing is done automatically, so you don't even have to worry about that. You can also use [pyglet](http://www.pyglet.org/) if you want OpenGL instead of SDL (OpenGL is faster on more fancy projects). Also, see [/r/learnpython](http://www.reddit.com/r/learnpython).
Nerdy guys normally tend to be at least a little obnoxious towards women. It is a way of causing them to keep their distance. Serious relationships can often be destructive to the nerdy set. I suppose one could argue that women should be more respectful of nerdy peoples innate need to piss them off... :)
Maybe, except that it's almost always the woman commenting on the man's sexual prowess; only rarely is it a "small penis" joke or similar, and it's almost never turned into "that's what he said" where the man comments on the woman's sexual prowess.
School project, have to write it in either Python or java.
How is talking about what woman said in bed makes them sex object? If I say something during sex, does that makes me a sex object, too? 
[Sort of Relevant SMBC](http://www.smbc-comics.com/index.php?db=comics&amp;id=1883) (can we not have anymore bizarre social issue tangent threads?)
Men and women often view sexualization of environments differently. If I put a man in a room with fifteen women who are all making alluring looks at him, chances are, he's going to find it a positive experience (at least, that's how most men think they're going to react). If I put a women in a room with fifteen men who are all making alluring looks at her, it's a threatening environment. In the case of the bot, this was a case of the little yes. She was okay with the occasional TWSS joke, so she should be okay with a few more from a bot. She was okay with that, so why is she complaining that the bot has gone mad and is spamming the channel? She said yes to the little thing earlier, so her change in opinion is invalid. 
&gt; Aren't you really just saying that people shouldn't be annoying? I believe that bots shouldn't.
Liberals in menopause. 
This is actually very close to how emotions work in the human body. Chemicals are released, which our brain then interprets in layers, from the lizard to the forebrain. 
Space Time Energy Matter? I'm seriously curious as to what STEM stands for, and what it represents.
That would probably be a good idea! They could add those as extra tests that are initially hidden.
Because nerdy men can't learn appropriate behavior? 
Could someone (perhaps you) explain (like I'm 5) why calling something like this 'manly' is now sexist? I mean, maybe it always was.. but from what I can see, if any sexism was going on, it was against men (which is still sexist, granted). Maybe I misread the vibe, but calling your program "manly" seems more like a joke on men to me, than anything saying "no women allowed" or "women need not apply." Maybe I just don't get it?
An alternative to Pygame is [pyglet](http://www.pyglet.org/) which uses OpenGL; see also [here](http://wiki.python.org/moin/PythonGameLibraries) for a broader list.
'Manly' is often used as a way to say 'No women allowed'. Perhaps a better way to phrase it would be 'No nasty girls tainted this awesome thing! It's just for you DUDES!' Often, if something has feminine overtones, its value falls, whereas if it has masculine overtones, its value rises. No one blinks at giving a girl a set of masculinely colored Legos, because stuff for boys is automatically better. Should someone give a boy a set of Legos with girly colors, however, someone would speak up. The same blocks, with a slightly different color scheme, now have less value because they are associated with a woman.
I'm surprised people don't understand the problem with describing something like curses as "manly". What if he had called it "Caucasone: interface with your tests like a white person"? EDIT: But also I'm sure it was just an honest mistake, and good for you for admitting it!
Can you please elaborate on how OP's solution is incorrect for the problem? I would genuinely like to know - maybe I have missed a case as well. Thanks.
latex isn't manly, it's masochistic.
http://www.reddit.com/r/Python/comments/ri871/i_saw_the_link_to_exercises_on_codingbat_in_the/c466w1i
The make the joke work you have to assume that the nerdy behaviour is innate. Then it becomes a matter of balancing two innate needs. I often do wonder if such behaviour *is* built in. I have personally exhibited a wide and clever range of avoidance behaviours. Eventually I *did* learn to suppress some of the more obnoxious things but it is not really all that easy... 
An innate behavior is one that you can't control. Refining social graces is something that anyone can learn to do. My son has Asperger's, and even though he has trouble reading social situations, he's learned not to say hurtful things in them. Calling hurtful behavior 'innate' is just an excuse. 
 from __future__ import andropause
Here's the thing: If it were a girly program and they had the exact conversation, I can guarantee you she wouldn't say "Sorry for the sexism." next day. edit: I'm saying this for the first time; could a downvoter explain the downvote? I guess it's not sexist as long as it's against men.
I´ve never used PyGame before. But, for making a 16-bit RPG game, are not the low level parts of PyGame enough?
[Not news.](http://imgur.com/gallery/FiBjX) Hey guys I'm totally not sexist anymore! Can I haz attention now?
Hypothetically, one you've written yourself that fulfils all of your specific needs perfectly.
Everyone else seems to be hitting on pygame, but an alternative is [kivy](http://kivy.org/) which is built on top of pygame (and a few other packages). It was designed for rapid development of touch/multitouch apps, but has plenty widgets with built-in support for click, drag, etc.
Let's say I got this friend who hasn't written an IDE for Python. What can he use? 
Science Technology Engineering and Maths; It's a division of subjects often used in higher education to distinguish these fields from "humanities" or "arts."
I think that's the key here -- that it's when it's used in a sexist manner, it's sexist, but the joke isn't inherently sexist or heterosexist. In her work environment, it was pretty clearly not only sexist, but horribly overused.
Why yes of course. That doesn't mean we should not try to understand people and be sensitive to their natures. Otherwise we are effectively telling people to "Just get over it" which is a phrase that a woman battling a disrespectful workplace gets to hear at some point. Remember that I was originally trying to answer the question of *why* people act the way they do. That is different than the question of *how* people should act.
Thanks, I'd heard of the other two, but never that one. 
&gt;The point is that by allowing the singular pronoun 'she' to generalize to all women, you have made it such that there is no way to make such a comment about another guy's sexual prowess without being sexist. You can comment on another's sexual prowess without dragging hypothetical women into the fray. &gt;You have made that impossible. Really? There is absolutely no way to joke about someone else's sex life without using a strawwoman?
Tell me about it. I spent half the night getting these docs to build, here in 2012: http://whit537.github.com/assertEquals/ First I downloaded the [Python 2.4 source](http://www.python.org/ftp/python/2.4.2/Python-2.4.2.tar.bz2). That was the easy part. Then I installed [MacTeX](http://www.tug.org/mactex/2011/)--the default installer is 1.8 GIGABYTES; the [basic one](http://www.tug.org/mactex/2011/morepackages.html) is ~2,500% smaller, so I went for, um, that. Now I have `latex`. I installed the 182-meg `mactex-additions` package while trying to get images working (see below), which may or may not have been superfluous; the world may never know. Next I needed [latex2html](http://www.latex2html.org/). I installed [half a dozen versions](http://www.latex2html.org/~latex2ht/current/) (let's just say latex2html doesn't follow [semver](http://semver.org/)) before realizing the problem was that my `perl` install was too new (yes, Python's old doc pipeline depends on Perl); `latex2html` uses the [$* feature that was removed in Perl 5.9](http://stackoverflow.com/questions/1782015/what-did-perls-variable-used-to-do). The current stable version is 5.14.2 as of this writing, and my `/usr/bin/perl` is 5.10.0. I'm thinking of starting a kickstarter to come up with a joke about backwards incompatibility in Perl vis-a-vis Python 2/3. In the mean time I tried modifying line 10,550 of `/usr/local/bin/latex2html` to use `\m` instead of `$*` (?!), but my Perl-fu is weak. I tried source compiling Perl 5.8, and was eaten by a grue during `./configure`. I tried [perlbrew](http://cpansearch.perl.org/src/GUGOD/App-perlbrew-0.42/README), which made my lap super hot before failing somehow-sorry-that-part-is-a-blur-because-it-turns ... out ... that ... I ... have ... `/usr/bin/perl5.8.9` ... after ... all. Yay! I tweaked the hashbang in `/usr/local/bin/latex2html` and it works. BTW, the 2008 version of `latex2html` targets Perl 5.003, which is older than Amandla Stenberg. Okay! Fonts! The basic distribution of MacTeX doesn't include Courier and effing Helvetica, which Python's old doc pipeline effing wants, so I manually effing downloaded four [individual](http://www.tug.org/texlive/Contents/live/texmf-dist/fonts/tfm/adobe/courier/pcrr7t.tfm) [effing](http://www.tug.org/texlive/Contents/live/texmf-dist/fonts/tfm/adobe/helvetic/phvb7t.tfm) [font](http://www.tug.org/texlive/Contents/live/texmf-dist/fonts/tfm/adobe/helvetic/phvr7t.tfm) [files](http://www.tug.org/texlive/Contents/live/texmf-dist/fonts/tfm/adobe/helvetic/phvro7t.tfm) and [updated the effing "TeX filename database"](http://www.tug.org/fonts/fontinstall.html) with effing `mktexlsr`. Nothing to see here, move along. Now I needed image support. At this point I could smell the birds about to chirp, which sent me into a berserker rage from which I emerged with a baling twine and papier-mâché frankinstall of [libpng](http://www.libpng.org/pub/png/libpng.html), [libjpeg](http://www.ijg.org/), and [Netpbm](http://netpbm.sourceforge.net/) that ... worked! Huzzah! I spent some time with [Big Data](http://b.igdata.co/) to cool off, and from there it was relatively smooth sailing to [re-root-branch my repo for Github Pages](http://pages.github.com/#project_pages) and get this crazy daughter of a golem on the Internet. [Blam](http://whit537.github.com/assertEquals/).
Bottle has been around for a long time. I briefly wrote for Flask, but quickly discovered Bottle and have been using it for over a year now. It's also easier to get a bottle app onto GAE. Now my main dev/deploy environment consists of the latest PyPy+Bottle+Paste+mongoengine+others. The only advantage Flask has over Bottle is that there are fewer modules available for Bottle... I don't find this to be true, I've found every extension I've ever tried to track down (mostly on git-hub).
I was looking into this a year or two ago for NFL. If you don't need to have live stats, just end of day dumps, then there are sites that have fairly cheap ($50ish/year) subscriptions. Can't find the link right now but they do exist.
Eclipse is a pretty good IDE and its free.
So you're doing this for a school project, but your teacher isn't providing you with the tools you need to do it? That's a social problem, not a technological one. You just need to convince your teacher to give you the access to the tools you need.
For an IDE, I like Komodo IDE and for a nice text editor Sublime Text is great.
P.S. It looks like `latex2html` v2008 drops `$*` after all. Oops!
Erm, it doesn't. I'm running python 2.x here, but I don't believe 3 changed this (anyone confirm?): &gt;&gt;&gt; print '"Isn\'t," she said.' "Isn't," she said. However, in the spirit of your question, here's what you need to remember. What you use to tell python you're creating a string literal is called a "delimiter". Python gives you two options for a delimiter, single quote (') or double quote ("). Python knows the string starts when it sees one, and it ends when it sees another. But what if you want to include the delimiter character in your string? You can "escape" it, meaning that the character following the escape character does not have the special meaning, and should be inserted as that plain character (exactly what you did in the first example). (For the record, python also provides the triple-quote and triple-double-quote delimiter for long strings, and a variety of string prefixes including 'r' to turn off escapes... but don't worry about that now ;)
Actually, I want your money, not just your attention. https://www.IHasAMoney.com/
touche
&gt;Person A says something that's insensitive to Person B. Person B should now spend effort trying to understand why Person A isn't Not even close. This is about trying to understand *why* the people act as they do. &gt;Person A is acting from a position of privilege. See above. It is sort of like you are arguing with someone else about something else. 
I thought "testrogen" was hilarious.
I'm running 2.5, and the documentation is for 2.7.2. Is this a bug in version 2.x? Note (unlike WaffleLight thought) I didn't put "print" in front of what I typed.
The PEP for overriding `and` was rejected.
Then let me try to rephrase: Why, when someone says something hurtful to me, is the responsibility on me to figure out why they would do such a thing? I'm supposed to put effort into making an excuse for them?
[Spyder](http://code.google.com/p/spyderlib/) is powerful and helps a noob and/or the elite programmer with it's "Object Inspector" and "Online help" windows. They're there when you need them and somehow out of the way so you can concentrate on coding Vs Alt+Tabbing, etc. [get Spyder](http://code.google.com/p/spyderlib/)
Depends on exactly what you want out of an IDE. Python isn't Java, the included IDE IDLE is surprisingly good and covers most of what you need to develop for Python. On the other hand, if you want more advanced features like CVS integration and refactoring support, grab Eclipse and install PyDev. It's bigger and a good bit unwieldier, but it's extendable to the point it's very nearly an operating system in its own right. Main takeaway: there's no best IDE, just the best ones for certain problems. I use both depending on what, exactly, I'm looking to do at the moment.
Right, so if I have it right, it's because the output has to follow the same rules about escaping quotes when they match the delimiting quotes. Python uses single quotes for the output so it needs to escape any single quotes in the string.
They used to just call it "hard sciences," but I guess the Tech folks wanted more headlines.
Excellent summary.
Next, they'll be telling me that Django doesn't have something to do with guitarists, and they've renamed it "hostsWebpages" to encourage use by people who play different instruments. Its a gorram name. If you're looking to avoid being sexist, maybe tone down the comments about it being a 'manly' test suite. assertEquals sounds like a function call, not the module that would include a bunch of tools like this.
No mouse for you!
(not trolling, trying to understand) The conversation seemed to imply that the name was related to how writing the project made the author (I assume a him) feel — I don't think it made any claims about "the nature of programming". Am I wrong in that? Or is that implied because testosterone is so fundamentally masculine? **Edit**: on my first read (which skimmed the header) I missed the project's old tagline - "the manly testing framework" (or similar). I can definitely understand how *that* would be an issue.
How come the lack of hardware acceleration hasn't gotten in the way of performance?
Python development on Windows is really a pain. Why not install some flavor of Linux in VirtualBox or even just dual boot?
I was under the impression that you could use the source script in anything that is python capable. But now that I look at it again, I do believe you are right.
&gt; so being able to do things like establishing call hierarchies and defining subroutines are still OK in push style ? sure [my spreadsheet](https://docs.google.com/spreadsheet/ccc?key=0AuxxPVc-8jyBdHVQUjBoUjhPUWJINE1XckpJZWJwRlE&amp;hl=en#gid=0) evaluates templating systems and that is not a criteria. You can do call hierarchies, but you do so using standard object-oriented technology in a standard language. So, using python, you would use classes and methods to do that. 
After four years of writing Python on Windows: is not that bad at all.
In other words, That is basically jut generating some html tree and then placing it another HTML tree via a simple DOM node replacement. That can be done using standard programming mechanisms in Python. I authored HTML::Seamstress, a push-style system [and discussed that here](http://search.cpan.org/~tbone/HTML-Seamstress-6.112830/lib/HTML/Seamstress.pm#The_meat-skeleton_paradigm) 
That's all I've ever needed, or wanted, with Python as well. Though, I prefer emacs with python.el.
Yes. It's because the interactive prompt shows the repr() of the result of what you typed, the "representation". An object's repr() usually tries to get close to being working Python itself. If you were to use ``print`` instead, you'd see the actual content of the string: &gt;&gt;&gt; print "\"Yes,\" he said." "Yes," he said. &gt;&gt;&gt; print '"Isn\'t," she said.' "Isn't," she said.
Part of how I analyze it is that there's a split between the "cultural" and the "interpersonal" levels. I can be snarky or tangy in bits of culture that I build, but that can sometimes land me in awkward situations with real people, like Barbie, whom I know from real life, or any of the women I hung out with at PyCon. I actually broached the testosterone project in mixed company in person at PyCon and it was interpersonally awkward--not terrible, but certainly not epic (which is the new manly, btw). The interpersonal level is more important to me than the cultural, because I am deeply satisfied by the serendipity I find there. I'll happily neuter some cultural artifact if that's what interpersonal relationships require. I want more diversity in tech because it heightens the serendipity. To heck with brands like He-Man.
So why is the issue with the name, and not with the statement about how it's manly?
Why do people even bother typing out these unhelpful answers? The question is about Windows IDEs, not what huge diversion you could create to get to Linux and then still have to write software for Windows. What is your specific pain issue with Python development on Windows? As one of the Windows maintainers, I'm all ears.
Technically this is sexism, but really it's just mildly offensive. I can make a project called Fucking_Metal_Fever, and I'm sure I would offend just as many people. The point is calling your projects these dumb names is going to be off-putting, and if you want your code to be used / respected by all then you're going to have to be more accommodating with a proper name / theme. 
I've had great success with the built-in Sublime Text 2 auto complete based on a fuzzy matching algorithm since build 2165. I do not even see the point of getting an additional plugin for this ever since.
Time to unpack **something**. What is it? Does it seem?
I also don't find it particularly sexist. It definitely has no place in the workplace (as with most things sexual). I frequently have the joke thrown at me in an insulting fashion by women more frequently than men :(. E.g. I would say "Oh, wow this is tiny" with someone responding with TWSS. 
It's hard to know what "some of the biggest databases are dropped every other month" might mean.
The two ways I'm trying to make sense of this are: - Entities are losing data due to problems with their database software. - Database software vendors are dropping support for their products.
To heck with He-Man in general? Or He-Man branding in tech? I think renaming the project is a good choice, especially given your reasoning, but the new name is not as memorable as testosterone or testrogen.
That is, the referent of "databases" seems to me to be either database software, or the data managed by instances of database software. The fundamental problem is that these databases (whether software or data) are "dropped." Dropping software means to discontinue it, to stop supporting it. Dropping data means to lose it, to destroy it accidentally.
And so we have a question: Is sexism "exactly the biggest problem" in the tech industry in a possible world in which *either* the biggest database software vendors discontinue support for their products every other month, *or* the biggest stores of data are accidentally destroyed every other month? Let's take it for granted that both database software vendors and stores of data are constituent parts of the tech industry.
Do you ever expect to be having the conversation about why puns involving chemicals important to the functioning of mammals should be avoided? The odd thing I found about the article is that whilst the "the manly testing interface for Python" description bothered me a little bit, the name of the project itself seemed completely innocuous. 
So we have these two: - sexism ("the word 'manly'") - one of these ("some of the biggest databases are dropped"): - the biggest database software discontinued every other month - the biggest data stores destroyed every other month
It's interesting to see the [performances](http://www.defuze.org/oss/ws4py/testreports/servers/0.2.1/) between Python and PyPy.
I have to say, for a feminist, the guy suggesting a sexist name in order to fix the sexist name is probably not the best way to do things. The feminist responding to him, in favor of the other sexist name, should probably reconsider her reasons for being a feminist--i.e., are you a feminist because you think both genders are equal, or do you think that women are better?
Though it should be mentioned that the world in which vendors discontinue support for the biggest database software every other month is orders of magnitude less worse than the world in which the biggest data stores are destroyed every other month. Unsupported software can be re-supported at near-infinitely less cost than destroyed data can be recovered.
A very, very severe form of sexism *might* be "exactly the worst problem" in a world in which the biggest database software went unsupported every other month. But even then I doubt it.
I thought it was a pun on the idea that cursing isn't ladylike.
The most severe form of sexism I can imagine is gendercide: the annihilation of all other genders by one dominant gender.
This looks great. Definitely going to use it on my current project, which just about now came into need for background workers.
And how does it unilaterally disrupt my co-workers work?