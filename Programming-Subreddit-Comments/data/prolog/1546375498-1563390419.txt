Wait! Stop! Hold the presses! Turns out I'm just rather dumb. :) My implementation of the "length" predicate does not, it seems, work at all. Apparently, naming a local predicate won't cause Prolog to override the built-in predicate of the same name. It seems Prolog was using its version of "length" instead of mine. When I renamed mine to "my\_len", I suddenly started getting errors, namely that members of my list don't exist. &amp;#x200B; Well, my joy and satisfaction were nice while they lasted. Now it's back to the drawing board, with the knowledge that I should never try to override default predicates.
OK, I see now. It is not at all contrived, it is interesting.
Props for the right attitude. Hit us up if you need help!
Whenever you find yourself incrementing by one or decrementing by one, consider using `succ/2` instead, since it unifies in other directions. Keep at it, friend, you’ll crack this nut!
Just a side note, browsers now understand WebAssembly too. The interpreter doesn't have to be written in JavaScript. For instance, you can write it in C and compile to work in browser.
I know and I have already integrated warm lua into Klipse (http://blog.klipse.tech/lua/2017/03/19/blog-lua.html) Are you aware of other compilers that have been ported to wasm?
Thank you for the detailed response. I'm still working on understanding all this, but hopefully I'll get there, Example 1 makes sense, but 2 and 3 not so much. Not yet, at least. 
I've always found the "length of null-terminated string in C" a very useful exercise. C is an imperative language and I know it, so some of the cognitive load is relieved. It goes like this: When a string has no characters in it, it has only a null character and its length is 0. If the string has characters, they all come before the null character, and every character makes the string one longer: int len(char* s) { if (*s == '\0') return 0; return 1 + len(s + 1); } A list in Prolog is the same as a null-terminated string, kinda, because the empty list is `[]` and any non-empty list is `[_|L]`, where `_` stands for "First element of list" and `L` is the rest. You can use `succ(N0, N)` to get the next integer (successor). If you re-write the definition from above in Prolog, you get: len([], 0). len([_|L], N) :- len(L, N0), succ(N0, N). This is only one way to write it. You can figure out how to do it in constant memory (using tail-recursion). You maybe noticed that `length(List, 3)` unifies `List` with a list with 3 variables in it. How can you make your `len` do that?
Your proposal is actually quite close to existing XML/HTML libraries -- see, e.g., [http://ciao-lang.org/ciao/build/doc/ciao.html/pillow\_doc.html](http://ciao-lang.org/ciao/build/doc/ciao.html/pillow_doc.html)
Hmm, I'm stuck on giving my Count variable an initial value. My current code: &amp;#x200B; \`\`\` /\*base predicate: when there is nothing in the list apart from the head, we must have counted all the elements, so stop\*/ my\_len(\[\_|Items\], Count) :- Items = \[\]. &amp;#x200B; /\*recursive predicate: if we're not at base yet, the list has at least one more element in it, so add 1 to the Count and then call length with the tail of the list\*/ my\_len(\[\_|Items\], Count) :- Count is Count + 1, my\_len(Items, Count). \`\`\` &amp;#x200B; Prolog, rightly, tells me "arguments are not sufficiently instantiated", referring to &amp;#x200B; Count is Count + 1, &amp;#x200B; On the first run, Count has no value yet. It didn't match the base predicate, so it enters the recursive one, but it was never set to 0. You can't add 1 to null, hence the error. At least, that's what I \*think\* is happening. &amp;#x200B; How do I give Count its first value? I can't set it in my question, because I need that variable to fill with the length of the list. How would I kick this off, defining Count as 0 once but then letting it increment thereafter?
(This is about code formatting, not about recursion: if you are editing your comment, on the lower right, there are two links in small letters, "content policy" and "formatting help". Check out how to format code. In a sentence, code blocks have 4 or more spaces at the beginning of lines; code block **are not** delimited by three backticks.)
The length of a list is 0 when the list is empty. Just write it down: len([], 0). When the list is not empty, you don't know how long it is. Use a variable: len([_|L], N) :- ... but you know that if you had the length of the rest of the list, you have to add one to it. See my other comment.
Sorry about that. I'm using the Markdown editor, not what Reddit calls their Fancypants editor. I thought Markdown used the three \` characters to denote a block that wouldn't be interpreted by Markdown, thus preserving my new lines and tabs. &amp;#x200B; I should also say that I'm using a screen reader, since I can't see my screen. In fact, the computer I'm using now doesn't even have a monitor attached. To the screen reader, the code seemed okay, so I never thought about checking that it was formatted correctly for sighted users. Sorry for any confusion.
Okay, this makes more sense. The below code fails, but now with "false" rather than any errors. I'm not sure whats wrong with it, but this is progress at least. I did as you said with my_len(p[, 0). I also swapped the two lines in my recursive predicate so that the base case would be found before any math was attempted. This gives Count the value of 0 when the base is found, I think. my_len([], 0). my_len([_|Items], Count) :- my_len(Items, Count), Count is Count + 1. 
This line: Count is Count + 1 This is always false in Prolog. You cannot change the value of a bound variable. You need to use a new variable for the length of the rest of the list, then add that to 1 to obtain the full length.
There are too many markdowns. They are all a bit different from each other. The four spaces is indeed annoying to type, but it is one of the more widely recognized "pre-formatted" styles.
The below code works, finally. I'm not getting how Temp is allowed to exist, though, when Count isn't. my_len([], 0). my_len([_|Tail], Count) :- my_len(Tail, Temp), Count is Temp + 1. The first line specifies that en empty list has a length of zero, and acts as the base. Once Prolog hits the point of getting the length of an empty string, it will know that the length is zero. Next is the recursive bit, taking the head and tail of the list, plus the Count variable, and then calling itself with the tail and... Temp. Why can Temp exist? If you replace all instances of Temp with Count, Prolog says not all variables were instantiated. I never instantiated Temp, though, did I? No more so than I did Count, it seems. Eventually, my_len(Tail, Temp) will match my_len([], 0), at which point Temp will resolve to zero. Then, the magic of recursion happens, and Prolog adds 1 to Temp for each call as it move back up the stack. Each time, Count is set to the result of this addition. Finally, the stack is exhausted and Count holds the final sum. But why can Temp do this, while Count can't? I don't get what makes the two different. Would Count not eventually get set to zero, then added to? In either case, an unknown variable gets the value zero, then gets assigned itself+1. Until it hits zero, such assignment can't happen, but Prolog wouldn't even try the assignment until it resolved my_len([Tail, Count) to my_len([], 0) anyway. What am I missing here? Also, I wish I could take credit for cracking this nut, even if I don't get why it works this way. But I was trying to find the answer to instantiating variables, and ran across [this Stackoverflow post about a sum predicate](https://stackoverflow.com/questions/15391598/prolog-sum-predicate-when-is-the-temp-variable-instantiated). The question let me see what I was doing wrong in my code, but the single answer didn't explain the point where I'm now stuck. Yes, I traced the progress of my own code, but that didn't make anything more clear. Sorry for the continued questions, and thanks for your patience.
Great! Thank you!
Try starting with a base case first! So, if your list is empty: &gt; translate([],[]). To recursively handle the case when there are more elements in the list: &gt; translate([X1|Y1], [X2|Y2]) :- &gt;&gt; eng(X1,X2), &gt;&gt; translate(Y1,Y2). This is assuming that you want to end up with a list of French words from the original English. Let me know if you want a more detailed explanation!
That’s exactly what I’m trying to do! A more detailed explanation would be brilliant, if you don’t mind. 
You can also just use ˋmaplist`, unless you’re intentionally trying to understand recursion better.
I’m on mobile, but I’ll try my best! So the base case is just saying that if you have an empty list of English words, you’re going to end up with an empty list of French words - pretty straightforward. What the second predicate does, is it handles the case when you have more than zero elements in the English list. It grabs the corresponding French translation for the first element, then delegates the rest of the work to a second translate call. &gt; X1 = first element in the English list &gt; X2 = corresponding French term to X1 &gt; Y1 = the rest of the English list &gt; Y2 = French translation of Y1 For example, if you had the query translate([hello], F). &gt; X1 = hello &gt; Y1 = [] Then, eng(hello, X2) would give: &gt; X2 = bonjour. While translate([], Y2) would give: &gt; Y2 = [] (as per the base case) Then, your F would be [X2|Y2], or simply: &gt; F = [bonjour] Hopefully that made sense! Try working through the above with 2 list elements and see what you get! 
Thank you so much! It all makes sense now 
 translate(English, French) :- maplist(eng, English, French).
&gt; Next is the recursive bit, taking the head and tail of the list, plus the Count variable, and then calling itself with the tail and... Temp. Why can Temp exist? If you replace all instances of Temp with Count, Prolog says not all variables were instantiated. I never instantiated Temp, though, did I? No more so than I did Count, it seems. Your second clause says that a list of at least one element `[_|Tail]` has a length `Count` **if** the sublist `Tail` has a length `Temp` **and** `Count` is the successor of `Temp`. If you replace all instances of `Temp` with `Count`, the result will always be `false` because of the line `Count is Count + 1` where the unification fails. `Count` is already assigned and you're trying to unify it with its successor (e.g like asking `1 = 2`). &gt; Eventually, my_len(Tail, Temp) will match my_len([], 0), at which point Temp will resolve to zero. Then, the magic of recursion happens, and Prolog adds 1 to Temp for each call as it move back up the stack. Each time, Count is set to the result of this addition. Finally, the stack is exhausted and Count holds the final sum. But why can Temp do this, while Count can't? I don't get what makes the two different. Would Count not eventually get set to zero, then added to? In either case, an unknown variable gets the value zero, then gets assigned itself+1. Until it hits zero, such assignment can't happen, but Prolog wouldn't even try the assignment until it resolved my_len([Tail, Count) to my_len([], 0) anyway. What am I missing here? Well, you can try trace a call to `my_len`: my_len([a,b],Count). &gt; Tail = [b], &gt; my_len(Tail,Temp), &gt;&gt; Tail0 = [], &gt;&gt; my_len(Tail0,Temp0), &gt;&gt;&gt; Temp0 = 0. % Temp0 was free but is now unified with 0 &gt;&gt; Temp is Temp0 + 1. % Temp was free but is now unified with 1 &gt; Count is Temp + 1. % Count was free but is now unified with 2 Now you can see that if you replace `Temp` with `Count`, the 2nd unification fails because you're essentially writing `1 is 2` which is false. 
The dropbox link is working again. Thanks! [https://www.dropbox.com/s/5pilbnmlx5nypmh/1408.pdf?dl=1](https://www.dropbox.com/s/5pilbnmlx5nypmh/1408.pdf?dl=1)
Sounds cool! Good luck!
Tip: to format your post as code, you have to prepend each line with four spaces. The triple-backtick notation doesn’t work (at least not with old reddit or most mobile clients?)
I guess this depends on your IDE.... But usually it means it's an unused variable.
im using the one that can be downloaded from the swi-prolog site
There is also [SWISH](https://swish.swi-prolog.org/) to try out code online. When I pasted your code there, and hovered with the mouse pointer over the underlined `np`, it says: &gt; "Recursive call" I don't know for sure if this is why it is underlined, but probably yes.
It sounds like you have the output of the parser already, and all you need to extract the values from the output structure. You could do something like: parts(sentence(_,VP)), P) :- parts(VP, P). parts(vp(V), P) :- parts(V, P). parts(vp(verb(V), np(_, np2(_, np2(noun(N)))), [likes(V), what(N)]). I'm on my phone so a bit messy but this should extract the two values a list and you can access using member/2.
Also you could do this by using a DCG, which is how I would do most likely, but that is a bit hard to explain without seeing your grammar.
hi, thanks for the help just wanting to make sure add your code correctly. i want to create the 'parts' predicates and then call them with in the predicate in which i need the values? &amp;#x200B; parts(sentence(_,VP), P) :- parts(VP, P). parts(vp(V), P) :- parts(V, P). parts(vp(verb(V), np,( np2,( np2(noun(N)))), [likes(V), what(N)])). input(In):- sentence(In, Out), parts(Out), member(V,parts), member(N,parts), recommend(V,N,R). something like this?
Not quite but close, parts has two parameters, and now I see how you are planning to use it you can use: input(In) :- sentence(In, Out), parts(Out, [V, N]), recommend(V, N, R). Assuming that recommend does something meaningful. 
should 'parts' loop indefinitely or do i need to add something to prevent this, as it seems to be crashing the program. (sorry for the constant questions)
It's pretty common for DCG natural language parsing tutorials to have you parse into a structure that reflects the grammar, which is what looks like has happened here. You don't have to limit yourself to this, since the actual parse tree for a natural language is kind of nasty to navigate, and anyway you're essentially going to have to traverse it twice this way (once when parsing into the structure, and then a second time using the structure). The books on Prolog natural language parsing recommend going for a logical structure so phrases like "an old father likes a good book" get parsed into lambda expressions like `forall(X, (father(X), old(X), forall(Y, (book(Y), good(Y), likes(X,Y)))))` which you can then evaluate much more easily from Prolog.
please help guys
What you have written, is it correct? But why so difficult anyway? "Insert X into List sorted" insert(X, List, Sorted) :- sort([X|List], Sorted). And why do you have 4 arguments?
It's to insert the element in a way that doesn't ruin the sorted list 
And I don't know if it's correct or no that's what I'm trying to figure out 
Well does it do what it should? Did you try running the code? What happened? What magic powers does reddit have that should help it answer these questions if you cannot answer them?
Do you mean that the 4th argument is there so that it doesn't ruin the sorted list?
Yes, can you tell me if the syntaxe is right?
No. Syntax is right if you compile it without errors. Did you try to compile it, btw?
That's the thing, the compiler doesn't say it's wrong but when I ask a ?- question it either replies with true or with error
Obviously the idea in my head and to my understanding of lists in prolog, this has to work. But the compiler says it doesn't and returns "true" and not the new list. I was hoping to get help here because I thought that something might be wrong with my compiler
OK, we are getting somewhere. If you ask programming questions, you really need to show _what you have done_ so that whoever is trying to help knows _where to start_. I hope you understand me. There are mistakes in your code. It seems to compile, but you cannot run it. I strongly recommend that you show how you compile and run the code you have in your question; what you get, and what you expect, and point out the exact problem that you cannot solve. You can edit your submission!
I would strongly recommend you ask on Stack Overflow. Or search there first, because almost all Prolog homework assignments have solutions on Stack Overflow. I don't see why you need four arguments here. insert(X, [], [X]). insert(X, [L|Ls], [X,L|Ls]) :- X &lt; L. insert(X, [L|Ls], [L|Result]) :- X &gt; L, insert(X, Ls, Result).
Let's take apart your code for a second. insert(X, [], R, Z) :- !. In this, you're effectively saying `insert(bread, [], lightning, [the,universe])` is true, so true you should quit looking for other solutions. I find this proposition unlikely to be true. insert(X, [Y|L], R, 0) :- X&gt;=Y, insert(X,L,[R|Y],0). Here you have clearly gotten quite confused about what your arguments are doing for you. In the head, `X` and `[Y|L]` are clearly the item-to-insert and the list-to-insert-into. R and 0 mean what exactly? And then in the body, you are saying, insert X into the remaining list, now R will become R with a Y on the end (this will fail as Y is not a list so `[R|Y]` is nonsense), and again, 0 in the fourth position for no particular reason. insert(X, [Y|L], R, 0) :- X&lt;Y, insert(X,L,[R|X,Y],1). You have gotten your list-building quite backwards, but what you should see here is simply that your result becomes `[X,Y|L]`. Why do you have a recursive call here? You shouldn't need one. What is going on with R here? `[R|X,Y]` is a syntax error, what would it even mean? Something like `append(R, [X,Y], ?)` I suppose but this is certainly not what you intend. `[X|Y]` means the list whose head is the value X and whose tail is the list Y. `[X,Y|Z]` is shorthand for the list whose first two values are X and Y and whose tail list is Z. There is no way to make sense of `[X|Y,Z]` because a list only has one tail. Next question. What is your fourth argument for? You don't know what it should be going in, and it never changes from one call to the next. So get rid of it, it's not doing anything for you. Also, forget about the cut operator. You can uses the cut operator again in two months.
If your Programming Languages course has lectures and workshops, try going to those. Maybe even try reading the textbook. Most of us managed to pass it without begging on the Internet.
Ah, the taste of selection bias early in the morning. How refreshing!
Random people on the internet should be a last resort. There are people at the university who are being paid to help OP, but they're sulking on the internet from their dorm room primarily because they want to be able to plagiarize. That's probably why they asked on reddit instead of SO: I can have a bad question with the answer in it undeleted there, but nobody can do that for you on reddit, so your academic dishonesty cannot be detected if it happens here.
By calling it "plagiarize", you're basically saying that random lines of code have owners, which I find pretty disturbing.
&gt; There are people at the university who are being paid to help OP, but they're sulking on the internet from their dorm room primarily because they want to be able to plagiarize. Well, you are making assumptions now. Unless you know OP personally of course. And no, there is no such thing as plagiarizing solutions to programming problems (like the sibling comment already pointed out).
Re-start with a better base case at least. This will hopefully be the first step amongst many: %base case- if element gets inserted into empty list. May not even be necessary but cannot hurt insert(X, [],[X]). 
If your homework says "implement `insert/4`" and you copy some implementation of `insert/4` from the internet and submit it, it's plagiarism.
I probably shouldn't have posted it; it's not doing the community a favour. But I am getting a bit annoyed about nearly every post on /r/prolog being questions from the first chapter of a Prolog book. Programming Language course student or not, OP asked a really trivial question. FFS, read the chapter before the question; it explains it!
What is the question here?
dating is like in red, this is a problem off of youtube and for some reason when I do the rule it dosent let me compile it. I'm completely new to prolog started it at school this week and I dont understand what the problem is here
I assume you're using SWISH? This isn't an error, it's just letting you know that the predicate isn't being called anywhere in the file. If you run a query, it will work as expected.
See I'm using swish and I ran it and said it's not working this is my problem I don't think I have any syntax errors
I just ran it and it works fine: https://i.imgur.com/iNjY46I.png
yeah I just noticed my bad, I think I changed the syntax thank you anyway
Except that the program assumes that because two people like each other that they must be dating, quite unrealistic...
[This](https://stackoverflow.com/a/20251636/812818) is one of my all-time favorites, in which @false shows how to determine if something is a substring by defining a `...` operator to signify zero or more arbitrary characters in a list. To snip it out: ... --&gt; [] | [_], ... . seq_substring(S, Sub) :- phrase((..., seq(Sub), ...), S).
[An in-depth explanation of `if_/3`](https://stackoverflow.com/a/39834015/812818) by @mat is another classic. I still have not made using `if_/3` a routine part of my Prolog programming, but this answer makes the case for it quite succinctly.
An essential but seldom-discussed debugging technique pioneered by @false is the _failure slice_. I think he must be particularly proud of [this answer](https://stackoverflow.com/a/10141181/812818) as he links it from his user page, in which the case for failure slices is made and a nice worked example is given.
I have been surprised at the quality of answers on stack overflow for prolog TBH, very helpful so far. 
If you can think of a few that were particularly nice, please link them over here so we can all enjoy them!
I hate to rain on your parade, but this is the only thing I can do well, so there it goes. The Prolog tag is not much different from the rest of Stackoverflow: a torrent of absolutely shit questions. So maybe you should be celebrating the 10 to 100 good questions somewhere in there? If only there would be a way to identify them, of course. Apart from that, of the few people who actually answer questions, there are a couple with an agenda, plus a couple of fan-boys who have decided they want to join the declarative holly war. Forget about solving problems, as long as there is enough phrase and dif and if_. Oh, you don't need this shit to solve your problem? Well, sorry, I am too busy feeling good about how clever I am, peasant. So, to summarize, the Prolog tag on Stackoverflow is a good example of why Prolog is a fringe language. It doesn't deserve it, so this state of affairs saddens me, but that's just how it is.
I hate to rain on your parade, but this is the only thing I can do well, so there it goes. The Prolog tag is not much different from the rest of Stackoverflow: a torrent of absolutely shit questions. So maybe you should be celebrating the 10 to 100 good questions somewhere in there? If only there would be a way to identify them, of course. Apart from that, of the few people who actually answer questions, there are a couple with an agenda, plus a couple of fan-boys who have decided they want to join the declarative holly war. Forget about solving problems, as long as there is enough phrase and dif and if_. Oh, you don't need this shit to solve your problem? Well, sorry, I am too busy feeling good about how clever I am, peasant. So, to summarize, the Prolog tag on Stackoverflow is a good example of why Prolog is a fringe language. It doesn't deserve it, so this state of affairs saddens me, but that's just how it is.
Double post
I am in the top 10 answerers there, I know this as well as you do. If you try hard, you may even find a blog post or two I've written about the eternal September there. But I think it is worth taking a moment to appreciate the good answers, some of which are truly great and required a significant outlay of work, and the genuine inquirers who really want to understand Prolog for its own sake. This would have been a good opportunity for you to apply the maxim "if you don't have anything nice to say, don't say anything at all." Your comment adds nothing constructive. Sometimes you should just keep it to yourself.
In [this answer](https://stackoverflow.com/a/50715917/812818), Paulo Moura shows how to use DCGs to solve a problem with generating valid computer configurations, a very surprising but beautiful solution! computer --&gt; monitor, keyboard, mouse, motherboard. is read "a computer consists of a monitor, keyboard, mouse and motherboard."
No, I really wanted to be negative on this specific occasion. I am glad I achieved it. And no, I don't believe there is only one road to "understanding Prolog", and I am convinced that the path that @mat and @false have taken is not a very useful one.
In [this answer](https://stackoverflow.com/a/46799245/812818), Jan Wielemaker gives an excellent, terse solution to a small planning problem. &gt; Next, we must make multiple moves. We must be careful not to get into a state we have seen before: moves(State, [], _Visited, State). moves(State0, [Move|T], Visited, State) :- move(State0, Move, State1), \+ ( member(V, Visited), same_state(State1, V) ), moves(State1, T, [State1|Visited], State). ...
I mostly agree with you, for what it's worth.
This particular gem found its way into Michael T. Richter's pack `evil`. You can see it here: http://www.swi-prolog.org/pack/file_details/evil/prolog/evil.pl I _think_ that in the pack, it is wrongfully attributed to Jan Wielemaker. I am too lazy to do the footwork but I suspect it was contributed by Ulrich Neumerkel himself, while showing off his `library(pio)`. If I remember correctly, he withdrew his contributions when SWI-Prolog stopped being "free" and became "open source". All "pure input" code is now written by Jan Wielemaker. Michael T. Richer, on the other hand, wrote a somewhat popular article once: ["Why I no Longer contribute to StackOverflow"](https://www.google.com/search?num=20&amp;q=michael+t+richter+why+i+no+longer+contribute). Due to bitrot you can only find reflections of it these days; but the fact that there are reflections tells me it did have a bit of impact.
Jan’s the man. 
It is possible to be negative and constructive and you achieved that on your second post. Suboptimal. 
I didn't see anything constructive in my post but thank you?
YW. It was constructive criticism of how some operate on SO. Needed saying. :) 
Hehe... I used to be in the first ten, or maybe even first five, judging by karma points, in Common Lisp SO's tag. Then I quit, deleted profile and also tried to delete my posts. Funny thing: you can only delete as many as 4 (four) per day... Being a drama queen as I apparently am, this resulted in some personal interactions with moderators and some people who actually make policies about this site. Truth be told, I thoroughly hate it, especially the people running the show. Few years later I created a new SO account because they opened an Emacs SE site, and... well, I thought it would be worth stepping over my personal preferences, if it's for greater good. But, Emacs SE, slow but steady, follows the general trend. I, kind of, admire LaTeX SE. Somehow they seem to be unaffected by the same dynamics which turn SO into a Lord of the flies community. I don't think I ever red any Prolog questions or answers on SO. I don't know if the tag is all that different from the rest, but I have very serious doubts...
With some metaprogramming, not necessarily exceptionally correct in all cases, but seems like it would work for your case: tree( sentence( np(np(det(an), np2(adj(old), np2(noun(father))))), vp(vp(verb(likes), np(det(a), np2(adj(good), np2(noun(book)))))))). find_in_tree(Tree, Pattern, Match) :- copy_term(Pattern, PatternCopy), copy_term(Tree, TreeCopy), TreeCopy = PatternCopy, Match = TreeCopy. find_in_tree(Tree, Pattern, Match) :- compound(Tree), arg(_, Tree, Branch), find_in_tree(Branch, Pattern, Match). ?- tree(T), find_in_tree(T, verb(X), Y). T = sentence(...), Y = verb(likes) ; false. ?- tree(T), find_in_tree(T, np2(X), Y). T = sentence(...), Y = np2(noun(father)) ; T = sentence(...), Y = np2(noun(book)) ; false. 
ps. Im using Win Prolog
I was about to help but then I realized I have no freakin idea what it is you are trying to achieve.
Hahha I'm sorry, the problem I'm trying to solve is, returning the last n elements of a list into a new list. I'm stuck because I can't figure out how to append the variable Head2 into a new list. 
Just use: `length(Suffix, X), append(_, Suffix, List)` where N is the number of last elements and List is the original list. For example, "last 3 elements of list `[a,b,c,d,e,f]` is: ?- length(X, 3), append(_, X, [a,b,c,d,e,f]). X = [d, e, f] . 
I was active on the Prolog sub for a few years, not any more. This is what I observed back then: - The huge majority of questions were terrible, so basically about the same as what you see anywhere on SO, or here on this sub; however, very difficult to help anyone because just as bad questions are immediately downvoted, trying to help them is frowned upon, too. - There was one very active contributor who cheerfully answered every question using a findall one-liner that would fill up your memory and choke your computer on any non-trivial problem. - There was a core of a few people who very aggressively turned every question into a discussion about failure slices, constraint logic programming, and DCGs. You observe some of it here on the sub as well, but not as prominent. Trying to offer a solution that does not use `if_` is ignored, as the few enlightened ones wax poetical about purity and monotonicity and give each other taps on their virtual shoulders. The circle jerk atmosphere is demonstrated nicely by highly upvoted questions that are patently impossible to answer. Here are two examples: [Definition of a path/trail/walk](https://stackoverflow.com/q/30328433) [Sorting](https://stackoverflow.com/q/31573197) I remember those because it was around the time when it got unbearable. Now, I am going to make a bold claim, but first I want you to look at [this question that has nothing to do with Prolog](https://stackoverflow.com/q/10176601). In the comments to the "wrong-but-upvoted" answer is hidden (literally, you need to show all comments to see it) [this little gem](https://stackoverflow.com/questions/10176601/git-diff-file-against-its-last-change/22412252#comment67119677_10176736). Here is the full text: &gt; kind of strange/amazing that a question like this took two whole years to answer. also strange that the "close enough" but... IMO wrong answer got soo many upvotes. The bold claim is that most questions on SO have popular answers that are just like this, only that they haven't gotten their correction yet. The Prolog tag is the same, too.
Prolog is used to make expert systems. But you probably won't find anything ready-made for using your phone to enter and query such a thing, in Prolog or anywhere else.
I think jekejeke prolog is for android. 
And is it useful for that purpose ?
It's a programming language so basically everything is possible. For your suggested use, I'd set up a prolog web server receiving querys and returning the result. Make sure it's in a safe environment or you'll have to deal with authentication and input sanitation. Then you can access that page and call like asser(your new rule) and your querys from your phone. And of course build the underlying rule based expert system I have no knowledge about.
Hey, my first education was in typography, and my first real paid job was printing business cards, stuff on lighters, ashtrays, cups, pens... yeah, you guessed, screen printing! Good times... Of course I'm biased towards Prolog (since I'm reading this sub), but, really, from how you describe it, you might not *need* an entire expert system, you mostly need a database helper that would allow somewhat more robust queries than what you'd have to do if you were to use a typical database system, be it SQL or any alternative. And, in this sense, Prolog, could accomplish this goal *relatively* easily. You would have to solve a question of persistence, since `assert(fact)` doesn't persist a new fact, and it only stays in memory as long as the program runs. On the other hand, creating persistent layer is more straight-forward: you could just write facts to a file the same way they are passed to `assert`. Or maybe, dump the database to a file every now and then. The more difficult task would be to organize the knowledge. Not impossible, but this would require a lot of planning, and, quite likely, re-doing it over and over. However, it seems like Prolog would be able to handle that task, if you will be willing to put up with the amount of work it will require. That is to say, this is not an insurmountable obstacle. The most difficult part would be the input part. After all, phones are intended to be used with speech, and transforming speech into predicates of pre-defined shape is... well, hard. I'm not aware of anything in Prolog that would simplify this process. I'd imagine that Android has some basic API that provide speech recognition, but how and if it is at all possible to interface with them from a Prolog program -- my guess would be, that it's probably not possible right away, and will require writing some Java / C glue code to do so...
Doesn't Google provide a speech recognition REST API?
I searched for it, and it seems like it's a paid service. Well, maybe it's worth it, but I never used it. But, having it as a cloud service comes with another limitations: you don't really want your phone to go online every time you want to update local database.
&gt; You would have to solve a question of persistence, since assert(fact) doesn't persist a new fact, and it only stays in memory as long as the program runs. On the other hand, creating persistent layer is more straight-forward: you could just write facts to a file the same way they are passed to assert. Or maybe, dump the database to a file every now and then. I have a feeling you're really going to enjoy [library(persistency)](http://www.swi-prolog.org/pldoc/man?section=persistency).
On 2nd thoughts maybe not - searching around, tuProlog looks more promising. There's also CLIPS for Android ( an expert system language )
Thank you , I'll look into that
Bonus question : How does one troubleshoot his Prolog code ? Using SWI-Prolog if that matters.
Type in: ?-trace. to get a line by line debug of your program. You have created far too much complexity and redundancy in your program by not exploiting all the features of sudoku and prolog. By debugging it, line by line, you'll see that you are not testing all the numbers. Take a look at the permutation/2 predicate, that is better than your current way of testing the sequences of numbers. You don't have to use it but it should give you insights.
What this person said. The complexity of this kind of generate-and-test logic program is why constraint logic programming can be so useful.
https://www.metalevel.at/prolog/debugging 
This is just an opinion, but what is inherently wrong is the way it is written. Since my opinions are mine, and are opinions, here is some background: I am a hobby Prolog programmer who does software development for a living. A program that looks like yours is very, _very_ difficult to get right. It is too big; and, the opportunity for mistakes too high. So you are attempting to write a program that is error-prone in two orthogonal dimensions: length, and style. "I'll work on making it prettier once it works" is just.... frustrating to even read. You might not get it right because it is too damn long (for what it does) and too error prone. Especially for hobby programming, and especially for Prolog, it is too easy to put a bit of thinking into it and try to solve these problems. You are not writing it in a hurry, nothing is burning in production, you are not in the danger of not fulfilling contractual obligations, and you don't have to think about the intern that might have to "maintain" it once you're gone. And Prolog is a very high-level language with very nice abstractions, and tools to help with developing shorter, less error prone code. The two nice solutions I have seen both involve constraints in some way. The obvious modern approach is to use CLP(FD), and if you are interested in looking, here is a worked out solution: https://swish.swi-prolog.org/example/clpfd_sudoku.pl And you are half-way there for the "manual" solution. But instead of saying: possible_value(1). possible_value(2). ... possible_value(9). why not: possible_value(X) :- between(1, 9, X). This is not cheating. Anyway, if for some reason this is not good, you can use _compile time term expansion_ to take a list of integers and turn them into a table of facts. But this is not important right now, ask if you can't figure out yourself how to do it. You can find an example on the bottom of this page: http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation Similarly, instead of: is_ok(X1, X2, ..., X9) :- possible_value(X1), possible_value(X2), ... possible_value(X9) why not: list_ok(List) :- maplist(possible_value, List). or even: list_ok(List) :- maplist(between(1, 9), List). What is happening here is that you now can concentrate on the difficult parts, instead of spending time and effort of writing and debugging (so also reading again and again!) absolutely trivial code. This comment is too long already.
Thank you for taking the time! &amp;#x200B; I do agree with you to some extent. And I had come across using CLP(FD) as an option, but decided against it, because I wanted to better understand the basics before moving to higher level abstractions which are helpful to get working code faster, but also tend to mask the underneath workings. I agree this is not cheating, but only if you would know how to do without it. And so far I don't :) &amp;#x200B; That being said, you say my code is too complex and while I do agree it is certainly too long, it is not very complex. The only "real coding" here is the \`isOK\` function. The rest is block copy pasting + search and replace. Definitely not elegant! But I did triple check that ugly "matrix" looking thing before copy pasting. &amp;#x200B; If I can't make it work, I think I'll reduce complexity by reducing the side of the Sudoku grid first. Then when it will work, I'll move to the much better alternatives you mentioned, and then back to a 9x9 sudoku. &amp;#x200B; Thank you for your honest opinion, and for the many pointers. I appreciate it! &amp;#x200B; &amp;#x200B;
You' re completely right. I'll try that. Thank you!
In case you need some ideas, here's a similar game I did once as an example: https://gist.github.com/wvxvw/530db8b77ab06aea108c39ec65128e94
This is very cool, but I'd still like to know if there is a simple and practical way of parsing free (or mostly free) word order languages like Latin, or agglutinating/polysynthetic languages that have a lot of complexity in word derivation. The DCG technique seems to be great for languages with strong word order constraints, but it leaves a lot to be desired in these other languages. I guess as an English speaker I'm probably not seeing much of the work done in this area, but the technique I found before (permutation grammars) just didn't seem like it would perform all that well.
 possible_value(X) :- between(1, 9, X).
I also avoid CLP(FD), especially for fairly simple arithmetic calculations. I guess I feel like 1980s Prolog was complete without it, so I ought to be able to survive without it. Meanwhile, in reality, 1980s Prolog _sucks_ for modeling mathematical _relations_ because all you really have that works relationally is `succ/2`, which is not sufficient for solving Sudoku. For Sudoku, you really do need to be able to say, the sum of these variables is 15 or whatever, and now you're asking Prolog to _generate_ inputs to an arithmetic relation, and without CLP(FD), this just doesn't happen. CLP(FD) is definitely a thick abstraction. But it also "just works" to a level that is completely astonishing. I wouldn't avoid it for situations that absolutely call for it, and this is one of those situations. &gt; The rest is block copy pasting + search and replace. I think this is antithetical to programming _in any language_. I understand why you did it, but copy-paste almost always introduces errors, and once they're there, they're nearly impossible to find. The static analyzer PVS-Studio found so many of them in their checks they named it "the last line effect" and [wrote a special article just highlighting some](https://www.viva64.com/en/b/0260/).
Yeah, but from a list you can select with `select/3`. 
This is an alternative to using `numlist/3` or `member/2` for implementing `possible_value/1`. Bigger changes are of course better.
Yeah, but if you make a list with `numlist/3` you can use `member/2` **and** you can use `select/3`. This is useful because the numbers in a column/row/square are "all different". One cheap easy way to implement this is to make a list of the different numbers and _remove_ from it one by one. I can't think of an easy way to use `between/3` for this.
I think you've forgotten the code you wrote above. You gave two implementations of `possible_value/1`, I was just giving a third. There's no way a caller of `possible_value/1` could tell whether a list was involved in generating its results.
I think you've forgotten that OP is trying to solve a sudoku puzzle.
In your comment [here](https://www.reddit.com/r/prolog/comments/am2ox0/sudoku_solver_noob_in_need_of_help/efkt2z3/) you give two versions of `possible_value/1`. I'm just giving a third.
Yes, I understand. But `between/3` is a shortened way to write the same useless code.
It’s always good to see backtracking exploited in different use-cases. 
The main problem is that you don't have enough variables. For example, I assume this clause: ``` location_access(sahasrahla) :- item_access(green_pendant). ``` means that, if I have access to `sahasrahla`, I have access to the `green_pendant` (if you meant it the other way around, then that's another problem). However, this is not actually what this predicate does. What it really says is that `location_access(sahasrahla)` is true, given that `item_access(green_pendant)` is true--which is **always** true. What you need to do is essentially add more variables. For example: ``` location_access(MyLoc, sahasrahla) :- item_access(MyLoc, sahasrahla). ``` This rule is different: it says "I can access `sahasrahla` from `MyLoc`, if I can access the `green_pendant` from `MyLoc`".
Thanks. I wasn't aware that variables in my query don't unify with those in the KB, I guess I'll have to look for another solution to the uniqueness problem then (and given that my last attempt failed miserably, I'm quite open to suggestions). Could you explain what you mean by "if you meant it the other way around, then that's another problem"? Because that's exactly what I mean. My understanding is that `a :- b.` expresses "b implies a", so the clause `location_access(sahasrahla) :- item_access(green_pendant).` should mean that if I have the green pendant, I can access Sahasrahla. Your suggestion of introducing a second variable to `item_access`and `location_access`makes a lot of sense to me, I'm going to try that way next.
As far as the uniqueness thing goes, I would suggest first solving the problem of putting items in valid locations, then assigning the rest of the items locations, not the other way around. Also, sorry, yes, I wrote that little thing about the "b implies a" thing backwards.
I don't get it :-(
Despite writing that I probably use coroutining, did examine the paper further and spotted it's got translations for the constructs that turn bounded quantifiers into horn clauses. paper_rock_scissors :- (∐ X ∈ [paper, rock, scissors]) (∏ Y ∈ [paper, rock, scissors]) X = scissors, Y = paper; X = paper, Y = rock; X = rock, Y = scissors. Turns into this: paper_rock_scissors :- turn1([paper, rock, scissors]). turn1([X|_]) :- turn2(X, [paper, rock, scissors]). turn2([_|Z]) :- turn1(Z). turn2(_, []). turn2(X, [Y|Z]) :- turn3(X, Y), turn2(X, Z). turn3(X, Y) :- X = scissors, Y = paper; X = paper, Y = rock; X = rock, Y = scissors. If you do a query for this, it tells you that the `?- paper_rock_scissors.` is false. The meaning of that result is that there's not a strategy that would always win this kind of a game when you have to do your move first. easy_paper_rock_scissors :- turn4([paper, rock, scissors]). turn4([]). turn4([Y|Z]) :- turn5([paper, rock, scissors], Y), turn4(Z). turn5([X|_], Y) :- turn3(X, Y), report_strategy(X, Y). turn5([_|Z], Y) :- turn5(Z, Y). report_strategy(X, Y) :- write(Y), write(': respond with '), write(X), nl. Here the quantifiers are turned around, so it models a game where you know what choice the opponent did before yours. I added a way for it to report the strategy. The response is something like this: ?- easy_paper_rock_scissors. paper: respond with scissors rock: respond with paper scissors: respond with rock true ; false. This response means that the interpreter found a strategy to win. The writeout shows what that strategy is. This way you can probably represent any interactive program in Prolog. If we add some heuristics, then the decision making may start before the proof search is completed.
Oh, I remember learning this technique for a proof of comparison-based sorting cannot be implemented in better than O(n log n) time. The idea was that the verifier on his move would present a new permutation of array elements to falsifier, while falsifier on her move would have to accept or reject the change made compared to the previous permutation. The proof then shows that it's not possible to do better than in O(n log n) time... but I don't remember the details since the lecturer got sidetracked into Abelard and hEloise story :D
Could you give some examples to go along with this post? 
For reference, [this is the r/lisp post](https://www.reddit.com/r/lisp/comments/ap6kxa/why_dont_lisp_programmers_just_use_prolog/?st=JS0JPDMD&amp;sh=5735584c).
Haha, obviously this is a very troll-y approach to asking the question ;-) I wonder what kind of answer you expected. The reason is that they don't know about Prolog nearly as much as they know about Lisp (while I have to admit that I don't know much about nothing, which apparently doesn't disqualify me from making money programming.....). Funnily, I had a similar conversation with an old-time lisper just the other day. We are both "software developers" and we write boring code in standard command-line utilities (awk, sed and the like) as well as a lot of Java, Python, and the Oracle DB stack. We eventually got to the topic of code that generates code, and apparently, he didn't realize how easy it is to do that with Prolog (even though he knows of Prolog, he is very far from having any real experience with it). After I showed him a couple of small things, he exclaimed, I quote, "But obviously, Prolog has much higher-level abstractions!". (It is still an open question, at least to me, what exactly this means. Intuitively it kinda makes sense, but this is not good enough for me). This itself was a bit surprising to me: I really haven't written much Lisp (like, maybe, 500 lines altogether? mostly following tutorials) and never got to the exciting stuff, so his comment actually caught me a bit by surprise. While talking about the reasons for writing macros in Lisp and compile-time term expansion for Prolog, he said, if I understood correctly, that macros are most useful for defining DSLs, in the sense that you can make the user-facing interface as you best see fit, then use the macro to turn this into efficient and executable List code (he mentioned control structures that work around the eager evaluation model of Lisp). At that point I said that in my (limited) experience you use Prolog compile-term expansion in a similar way, and that while it is usually easier to write a run-time interpreter for your DSL, sometimes you get interesting advantages of compiling to Prolog code instead (I had [this particular code](https://www.reddit.com/r/prolog/comments/8hmaw3/dfa_in_prolog_avoiding_choice_points_and_fixing/dyvj7mg/) in mind). I might be making it up, but there was a bit of shock when I said that "it is easier to write an interpreter": it is indeed ridiculously easy in Prolog, but apparently, not in most other languages.
[Triska discusses](https://www.metalevel.at/prolog/macros) how `goal_expansion/2` and `term_expansion/2`. And [this section of Learn Prolog Now! discusses](http://cs.union.edu/~striegnk/learn-prolog-now/html/node84.html) how you can define your own operators in prolog. 
The section on compile-time term expansion is spartan, to say the least, esp. when you consider that (as far as I can tell) this is what is used in his own clp(fd) library.
Mmm... no, it would be imprecise. Common Lisp (unlike, say, Scheme) has reader-macros. Prolog doesn't have anything that's like reader macro. I'll try to explain. Common Lisp formalizes the implementation of its own parser to the level of the parser mechanics, and the interesting thing about this codification is that this makes the parser itself very malleable. With some work you could make Common Lisp parser parse other languages, like, say, Python or JavaScript or maybe even C++. This works because Common Lisp requires that the parser be implemented in a particular way: it should have read-table, which is a hash-table which has an entry for each character you can parse. Each such character can invoke a particular handler function, which will put the parser in a particular state. However the standard prescribes that you have some default implementations for certain characters (i.e. an open parenthesis starts parsing S-expression, alphanumeric characters start parsing word token etc.) nothing prevents you from overriding that functionality. So, in Common Lisp, in principle, you could have altered the parser in such a way that it would say, treat square brackets as if those were parenthesis, but not assign any special meaning to parenthesis. Unfortunately, the system isn't really prepared for such dramatic changes, and this would most likely just destroy your Lisp system altogether because it would no longer able to read any more of traditional Lisp code.
Why won't you show the code? Is it a secret? Here is one way to ask a question that doesn't make you sound like a n00b: ---- I wrote a predicate that succeeds if a list has an element in it. I put it in a file called lists. Here are the file contents: $ cat lists.pl list_element([X|Xs], X). list_element([X|Xs], Y) :- list_element(Xs, Y). Then, I started Prolog and loaded the file. It looks fine to me, but I see "Singleton variable" warnings, like this: $ swipl -q ?- [lists]. Warning: /home/boris/code/prolog/lists.pl:1: Singleton variables: [Xs] Warning: /home/boris/code/prolog/lists.pl:2: Singleton variables: [X] true. What does that mean? ---- Then someone would come along and tell you what this means.
Gotta love the faux tuple in the first code example ;-) But I don't quite understand how the final solution is about _state_. Is this a functional programming way of using the word?
What do you think a state is? It's something that can be updated right? Well, we're updating the state of the variables as we interpret the language. We've got a monadically threaded state variable, sequenced between the various operations. Hence "monad" and "state". 
OK but nothing is really updated. In every rule that I see, there is no updating of any state taking place, at least not in the traditional meaning of the word. I honestly haven't seen "state" used like this. If you look at this page: https://www.metalevel.at/prolog/dcg ... and go to the "Implicitly passing states around" subsection, you can see an example of something that looks a bit more like "state" to me. Sorry if I am missing the point.
A singleton variable is a variable that is only used once in a predicate, and therefore whose value doesn't actually matter. For example, consider the simple predicate foo(X,Y):- bar(X). Y is a singleton variable, since its value doesn't have any effect on whether or not foo(X,Y) succeeds. It shouldn't really matter for the code you're writing, but if the warning annoys you, you can simply replace any singleton variables with the anonymous variable underscore ( _ ), which basically says 'I don't care about this value' to your interpreter.
I care
Well clearly you're not a Prolog interpreter, icarebot.
do you have erectile dysfunction or are you just a dick cause you like it ?
Something is being updated. In the interpreter, every time you get to an assignment, you update the state.
Specifically this line updates the state, setting the new value of the variable V to be equal to the results of the evaluation of an expression. ` interpret(V:=Exp) --&gt; eval(Exp,Val), update(V=_,V=Val).`
 return(S0,_,S0). What is this for? 
Yes
I missed this one because it is very strangely programmed. This piece of code is using a predicate inside a DCG, which is not a crime but it is definitely a very unnecessary hack. I will try to look at this more carefully and show a more standard way to write it.
I didn't end up using it in the example, but it allows you to construct a new state to be used. It could have been used instead of explicitly passing the intiialisation to zero values for instance.
eval//2 has to thread the current state through it so it can find the current value of variables. update//2 then performs the update on the variable. Both of them are typical DCG type predicates, so I've really no idea what you are talking about.
No need to get your panties in a bunch. Are you the author of the code? If so, I can address you more directly, but either way, in the linked blog, there is the paragraph which goes, I quote: &gt; We can then introduce a couple of handy helper functions: and then the code I see there goes: update(C0,C1,S0,S1) :- select(C0,S0,C1,S1). view(C0,S0,S0) :- member(C0,S0). return(S0,_,S0). Those are not function those are predicates why on earth "return" bla bla bla. Anyway. Those are indeed normal predicates, but then, later in the code, I read, for example: eval(A, V) --&gt; {atom(A)}, view(A=V). and I also read: interpret(V:=Exp) --&gt; eval(Exp,Val), update(V=_,V=Val). What happens here is that a predicate defined as `Head :- Body` is dropped in the middle of a DCG. As I tried to say above, this is fine but it is a code smell, and an unnecessary hack. It makes assumptions about how the Prolog you are using re-writes the DCGs to predicates (so argument order, number of arguments, that kind of stuff). If the Prolog changes that (for whatever reason) then the code is broken. I can try and show how it would normally be done, if anyone is interested. I haven't even yet ran this code (I would have to assemble it from what I see, since I couldn't find a full listing). Are we looking at the same page? I am looking at the code at this link: https://rubrication.blogspot.com/2019/02/managing-state-in-prolog-monadically.html
Alright, so you are the author of the code. Do you care for constructive feedback or not? I don't want to put effort in it just to piss you off.
In terms of "helper functions", it should definitely be "helper predicates". A linguistic tick due to my background. Dropping predicates in DCGs is both normal and necessary, that's why they have the {} syntax! As per return//1, I didn't use it here, but it's handy in larger examples. I eagerly await your examples.
[https://github.com/GavinMendelGleason/code/blob/master/prolog/state/state.pl](https://github.com/GavinMendelGleason/code/blob/master/prolog/state/state.pl)
&gt; that's why they have the {} syntax! YES! Then, the compiler _knows_ that this is a normal predicate inside a DCG production rule and takes care of it. But what you've done is use it **without** wrapping it in {}!
I'm getting a feeling that your nickname is a cheeky hint. If you have some examples of how to do things better, have away, but I haven't seen anything constructive from you as yet, just a misunderstanding of what a 30 line program was doing, followed by some vague gesticulations about purity which didn't make any sense.
Alright, "vague gesticulation about purity" was uncalled for ;-) I hate it when people start waving around their purity as much as the next guy.
Thanks!
` update(C0,C1,S0,S1) :- select(C0,S0,C1,S1). view(C0,S0,S0) :- member(C0,S0). return(S0,\_,S0).` I'd be curious to know if any compilers are actually making use of the distinction and would be very pleasantly surprised if they did. Can you give an example where such a distinction is utilised by an available compiler? In any event, it's trivial to write them as a DCG, I didn't do it because it's less transparent than showing that update//2 is just a permutation of the arguments of select/4. ` run :- Term=( v := 1 + 3 ; w := v + v ; w := w + 1), interpret(Term,[[v=0,w=0]],Result), write(Result). update(C0,C1), [S1] --&gt; [S0], { select(C0,S0,C1,S1) }. view(C0), [S0] --&gt; [S0], { member(C0,S0) }. return(S0), [S0] --&gt; [_]. `
It's also the case that the compiler is aware that anything defined as `Head :- Body` is not a DCG, so I'm unsure as to where the advantage would come from.
Start your Prolog and try the following: ?- [user]. |: foo --&gt; [bar]. |: ^D% user://1 compiled 0.00 sec, 1 clauses true. ?- listing(foo). foo([bar|A], A). true. Here you see how a 0-argument DCG rule is re-written to a predicate. This is what the compiler sees. You can make a Prolog that is aware that something was defined originally as a DCG, and even take advantage of that knowledge, but as far as I know, this is not the case normally. It would make things complicated, while now things are easy.
This is a good question. I would suggest you ask it on a forum where people who implement Prolog tend to hang out (so definitely not reddit). The SWI-Prolog mailing list is one such place (now on Discourse I think). On SO there are a few users who would be able to give you useful information if you can handle all the purity.
&gt;I mean, I am trying to be civil and help and ask questions to figure out what is up You're precisely the kind of faker that pollutes communities making it hard for people to learn. You know just enough that you can pretend to give advice, but in point of fact are utterly and completely incompetent. A more vibrant community would have to run you out before you did more damage to the newbies. 
And you genuinely think it's fine to insult me just because I am interested in what you did and how you did it and have questions? (I am the only idiot who engaged you, btw... how fucking stupid I am, really....) What is the point of sharing code on the internets if you get so goddam defensive about it? It is code, it sometimes does what we wish but most code is still shit in some respect and could get better if someone else bothered to put some effort in it.
I've got to hand it to you, having a synonym for "concern troll" as your nick is impressive.
this is hinting at a very deep question, I think, and so I think there's a lot of directions that you can take this sort of study. 1 axis along which you could look is: what form of consequence, implication, should the system support? If this system support some form of deduction, what kind of deductions should we be able to draw? In what sounds like your first option we just write down a straight list of facts. In a flat book pros system than all the deduction based on those facts is manual on the part of the user. With a prolog like system the system itself can deduce new facts from the facts that are given. But, the mechanisms of deduction then raised a whole lot of questions. If a false statement somehow gets into your list of facts, what should happen? Further work in the field of non monotonic reasoning gives some interesting thoughts about how to cope with ambiguities or domains where we don't have written down a complete picture of how it works. 
The limitations aren't in the medium, but the programmer/writer. You can write a book that is perfectly clear and unambiguous. But it would be a massive undertaking. A program is simpler, but still non-trivial, and some things will be harder to encode. It's all about finding the right medium for your particular problem.
Well, there are two major problems with knowledge that I know of: 1. Gettier Problem: https://www.iep.utm.edu/gettier/ . This problem is about whether any justification we provide to an observation can count as knowledge. 2. Absence of satisfactory theory of meaning: https://plato.stanford.edu/entries/meaning/ . In short, this problem is about not being able to say what meaning is, and, as a result, not being able to say if the form captures the meaning (adequately). Of course, this list is anything but exhaustive. It's also unlikely that either problem with have a solution. So, it will not be possible to really answer your question in general. But, in special cases, I guess is that you will have some very pragmatic concerns that will override everything else. Like, for example, suddenly you discover that your intended audience runs away screaming when they hear the word "Prolog".
One way to do this is to give a recursive definition. Recursion has a small step and a big step. The small step can be expressed as a predicate that doesn't call itself, while the big step would be the predicate that does call itself. So, you'll get something like this: path(X, Y) :- edge(X, Y). path(X, Y) :- edge(X, Z), path(Z, Y). Notice, however, that if your graph is circular, then this predicate will also succeed multiple (in fact infinitely many) times. I'm not sure if that's what you want to express (pragmatically, you probably wouldn't want that). There could be different solutions to this problem: you could either remove edges as you traverse them, or you could keep a cache of edges you visited so far and verify that you aren't going to visit them on your next recursion step. 
Are you familiar with the concept of [Controlled Natural Language](https://en.wikipedia.org/wiki/Controlled_natural_language? https://sites.google.com/site/controllednaturallanguage/
**Controlled natural language** Controlled natural languages (CNLs) are subsets of natural languages that are obtained by restricting the grammar and vocabulary in order to reduce or eliminate ambiguity and complexity. Traditionally, controlled languages fall into two major types: those that improve readability for human readers (e.g. non-native speakers), and those that enable reliable automatic semantic analysis of the language. The first type of languages (often called "simplified" or "technical" languages), for example ASD Simplified Technical English, Caterpillar Technical English, IBM's Easy English, are used in the industry to increase the quality of technical documentation, and possibly simplify the (semi-)automatic translation of the documentation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/prolog/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
This line of questioning is what lead me to programming and then to programming language theory. It is still what guides my studies and drives my ambitions. Your questions, appearing in this forum, reminds me of the mottoes from Streling &amp; Shapiro's *The Art of Prolog*: &gt;We believe that programming can be, and should be, an intellectually rewarding activity; that a good programming language is a powerful conceptual tool — a tool for organizing, expressing, experimenting with, and even communicating one's thoughts ... we think that programming can be, and should be, part of the problem solving process itself; that thoughts should be organized as programs, so that consequences of a complex set of assumptions can be investigated by "running" the assumptions; that a conceptual solution to a problem should be developed hand-in-hand with a working program that demonstrates it and exposes its different aspects. I find this passage to be a constant encouragement to persue the interplay of thought and programming beyond the confines of encoding business logic and solving puzzles. Here are my current (tentative) thoughts expanding on your questions: &gt; where is the dividing line between traditional books, Prolog programs, and other means of encoding knowledge? In short, how should we consider how knowledge ought to be encoded to make it completely unambiguous and perfectly clear? What are the limits of each medium? Like a novel, poem, or technical tract, a program is a piece of writing. The dividing line between other written forms and programs is executability: a program can be executed. The difference between an informal program (like a bullet pointed list outlining a plan of action) and a computer program is that the latter can be executed *automatically*. Automatic execution is made possible by the unambiguous encoding of information (e.g., a set of instructions). But what are the limits here? The halting problem indicates that any program written in a language sufficiently expressive for general computation will also be liable to ambiguity (i.e., will it execute the intended actions or not)? This is a correlate of the fact that (without additional constraints) formal systems beyond a certain rudimentary level of expressiveness are incomplete. Some ambiguity is Different media (and the different genera within each medium) encourage and facilitate different forms of communication with different tendencies and capabilities: Poetry is home to linguistic invention, leaps of insight, and playful and productive polysemy. Narrative prose is suited to continuous exposition of a more or less linear sequence of thoughts. Programs demand and reward precision and exactitude, and drive us to confront the limits of our own fuzzy understanding. But things really aren't so clear cut. Rather than dividing lines, more careful consideration finds continua of difference and interweaving strands of similarity. A play is an (informal) program, and a performance of it an execution of its plan. A poem could be composed as a set of instructions and then executed with great precision. In generative poetics one writes programs that compose poems. Work in game design is advancing narrative fiction into programmed (and programmable) non-linear and multi branching plots. Many finely wrought programs are wonderfully poetic. In my estimation, the absolute properties of *complete unambiguousness* and *perfect clarity* are as impossible for human being as omnipotence and omnipresence. Under the assumption that the scientific project is essentially concerned with relatedness and coherence in a continuous world, Quine argued that superlatives and absolute properties are inherently unscientific: there is no *biggest* or *best* but only a relatively *bigger* or *better*. We continue to press the boundaries of ambiguity in communication (in both directions, by the way!) and to innovate techniques to improve the clarity of our expression, but I think we can only strive for for absolute clarity or univocity as guiding, but inherently unobtainable ideals. Practically speaking, we should keep these problematics close to heart and always in view, while we strive to make incremental improvements in the craft of thought and expression, so that our actions and communications might be better suited for the needs of our place and time. (In particular, we desperately need to become less selfish and wasteful, more careful and caring.) Both in terms of technique an theory, there are heaps of great writing on this topic, and I think there is still much to do. ime, it cuts to the core of computer science (and information theory) and the science of logic, and it has roots going back to the earliest works of philosophy. The current work in this direction which I find most exciting generally falls under the umbrellas of proof theory and categorical logic. I would be happy to continue the conversion and to stay linked up to learn what you discover as you investigate further.
Instead of modeling an edge between A and B as edge(A, B) and edge(B, A), try canonicalizing the vertex order so that the query must be in ascending or descending order. This models each edge with a unique pair.
I wrote continuation to this post. It describes a resolution algorithm along these ideas that should have sound negation: [http://boxbase.org/entries/2019/feb/18/dialogical-resolution-algorithm/](http://boxbase.org/entries/2019/feb/18/dialogical-resolution-algorithm/)
&gt; untill i tried ?- whatisthis([]). and it returned true, but I don't understand why.... Because of this rule: whatisthis([]). That rule indicates that `whatisthis([])` is true, axiomatically. No inference needs to be made to prove it to be true; it's asserted to be true. 
Ohh that makes sense yeah! but that is only using the first line, I should be able to return true with the second line as well correct? &amp;#x200B; another question if you don't mind, &amp;#x200B; what is the difference between 'b' and '\_' in this example, i thought if you used variables only once you always have to name them '\_' or does b mean something special in prolog?
 whatisthis([]) true whatisthis([a,b]) true whatisthis([a,b,c]) false Does this give you more ideas?
&gt; So I am guessing my predicate would be called by checker(and(propositional(X), true) ) and return yes? From what you've described, yes, that's basically how I would expect you to invoke your predicate. One caveat is that you would want to be careful with that `X` variable. For one thing, you would want to be sure that it's not bound at the moment that you call `checker`. Consider this: ?- var(X). true. ?- X = 5, var(X). false. In the second case, because `X` is currently bound to `5`, that's equivalent to: ?- X = 5, var(5). false. You also have to be careful as you recursively process the top-level term. As you break the top-level term down into smaller and smaller pieces, you will eventually want to evaluate `checker(X)`, and that will tend to want to backtrack in order to find multiple solutions. You're not interested in backtracking in such a situation. There are a couple of ways to suppress backtracking. You will want to familiarize yourself with the [type test predicates](http://www.swi-prolog.org/pldoc/man?section=typetest). You may also consider using the cut operator [`!/0`](http://www.swi-prolog.org/pldoc/doc_for?object=!/0), though it's not necessary. But your predicate is I think going to be nonrelational anyway (due to the special handling of unbound variable terms), so I don't think you lose anything by using [red cuts](https://en.wikipedia.org/wiki/Cut_\(logic_programming\)). Perhaps try doing it without using the cut operator, then consider how you could instead to it *with* the cut operator. --- And just to clarify, Prolog predicates don't "return" values per se. In the case of your `checker` predicate, it should produce a solution if the one argument is a term representing a boolean formula, and should fail to produce a solution if the one argument is not a boolean formula. When SWI-Prolog runs a query and the query produces a solution with no top-level variable bindings, it reports that solution as `true`. When it fails to produce a solution (either up front or after backtracking), it reports that failure as `false`. But these are not being "returned" from the predicate per se. This can also lead to strange results. Check out the SWI-Prolog output for this query: ?- length([], 99); length([], 0); length([], 1); length([], 2); length([], 3). true ; false. It seems to say that the query is both true *and* false. Really, though, it found one "path" that produced a solution, but then it could find no more "paths" that produced any solutions. (The query has 5 top-level clauses, of which only the second one succeeds. All others fail. The `false` in the solution set represents Prolog attempting all subsequent clauses and failing on all of them.) --- FWIW, I know the Prolog basics *reasonably* well, and it still took me a few attempts to get the predicate to work (I threw it together for fun). This strikes me as surprisingly challenging to be a second Prolog assignment. The end result is fairly short, but it can be hard to know *why* the pieces all need to be there. 
A list of somethings alternating with bs
I think you've solved a different problem to the one I was asking about, I was trying to come up with a way of modelling undirected graphs. Specifically creating a predicate that understands that if there's an edge from X to Y, you can infer there's an edge from Y to X. 
as in, the atoms representing the nodes must be in alphabetical order in the functor?
Oh, I see, well... one way to go about it would be to inspect the stack of the program, and prevent infinite recursion. Here's some info on SWI: http://www.swi-prolog.org/pldoc/man?section=manipstack . Another way is to maintain some other global state in which to register the fact that some predicate was already entered. Another way is to have an extra argument, essentially capturing this part of the state. Yet another way is to have a special helper predicate: edge_helper(1, 2). edge_helper(2, 3). edge(X, Y) :- edge_helper(X, Y) ; edge_helper(Y, X). %% ?- findall([X, Y], edge(X, Y), Edges). %% Edges = [[1, 2], [2, 3], [2, 1], [3, 2]].
SWI manual page on finite domains has a solver written as an example: http://www.swi-prolog.org/pldoc/man?section=clpfd (towards the bottom). You could start by benchmarking it against your problem. If it outperforms your solution, compare SWI implementation to yours piece-wise. This will probably give you an insight as to where your code is doing something that could be improved.
Yes.
That one takes 3/100 seconds. Twice as fast as mine with the above sudoku, and infinite times as fast with the assignment's sudoku. I have no idea how I could improve mine using this, though... It uses multiple libraries, the functions of some of which I can approximate (like all_distinct), but likely with loss of performance. It also uses domains, and I have no clue at all how I could even begin implement something like that...
All this code is open-sourced. You can find the sources here: https://github.com/SWI-Prolog Perhaps the best approach would be to take their code and try to replace the predicates they used with your own? Or maybe the other way around? Until you find the one that seems to impact performance the most, and then figure out how they did it, and how it is different from how you did it. Finite domains library is, at least partially, implemented as "macros", so, by just calling `list` on your predicate using this library, you'd be able to see what Prolog code it translated to.
Oh, that's pretty helpful, thanks! That said, there is absolutely no way I'm going to be able to rewrite a library, as well as the libraries that library depends on, before today ends... What do you mean by 'calling list on my predicate'? It's not recognizing it as a procedure.
CLPFD is a library that ships with most Prolog implementations, so it would be considered "internal" I'm guessing. I think it would be fair game for this assignment.
It's a horribly vague term, sadly. CLPFD was asked about specifically, upon which the TA responded something along the lines of "Absolutely no libraries". So while I still don't know what we *are* allwoed to use, CLPFD is a no-go.
Ouch. Prolog doesn't have logically pure math without CLP so writing a Sudoku solver is necessarily going to be extremely inefficient or just a mangled non-logical unidiomatic mess.
&gt; What do you mean by 'calling list on my predicate'? It's not recognizing it as a procedure. In interactive shell, you can examine the source of loaded predicates by doing: ?- listing(predicate/arity). This will print the source of the `predicate` (`/arity` is optional).
Alright thanks for the reply. To break it down, I meant for the "X" to be a variable which is the convention as I learned in class. I read your response and I'm still not sure how to start because I dont think I have the basic syntax down since this is a first assignment. It sounds little like an interpreter. Like I think in the example checker(and(propositional(X), true) ) I have to check if the first thing in the argument is "and" then make a recursive call to check if its a propositional variable? If this is right, how would i do this syntactically? 
Yes, that's the approach you'd want to take. Consider that you define `checker` like this: checker(X) :- ?. At the topmost level, `X` would be bound to `and(propositional(X), true)`. You need a way to see what you got in `X` and take appropriate action. I'll refer you again to the type test predicates. They have most of what you need. The only other thing you'll need are the [predicates to break down a compound term](http://www.swi-prolog.org/pldoc/man?section=manipterm). I don't want to just give away the solution, but I'd be happy to answer specific questions as they come up. If you're not sure where to start, it might be worthwhile to just play around with those type test predicates and term manipulation predicates. Play around in the Prolog REPL and build up an intuition about how the pieces work. 
I think you're also missing an `, job(Job)` There are activities that are fun and pay well but aren't jobs. But really it depends on what you're doing (eg, do you have a job concept at all)
Ok thanks that link helped a bit. So I looked into the built in predicate functor which is supposed to give me the name and the arity. Specifically I did `checker(X) :- functor(X, Name, Arity).` which returns true when I do `checker(and(propositional(X), true))` . I was able to print the arity and I looked into structures for if statements in prolog but I'm a bit stuck on how to check that the arity is 2. Any ideas?
Prolog doesn't have `if`s per se - at least, not like you see in other languages. On the other hand, `if`s are part of the fabric of logic programming. Consider this predicate: iflike(X, Y) :- X = 1, Y = one; X = 2, Y = two; X = 3, Y = three. This predicate has three clauses. The first clause is trying to unify `X` with `1` and unify `Y` with the atom `one`. The second clause is trying to unify `X` with `2` and `Y` with `two`, and the third clause is similar. So I can call that predicate like this: ?- iflike(2, R). R = two; false. Prolog tried all three clauses, one-at-a-time. For each clause, it tried the individual goals one-at-a-time. If all goals in a clause succeeds, then the clause itself is a success, and the other clauses can be attempted upon backtracking. If any goal fails, then the whole clause fails and Prolog immediately tries working on the next clause. In this case, on the first and third clauses, it wasn't able to get past the `X = ?` goal. For the second clause, it was able to get through both goals, and so that clause is the one success that you see in the output. Note that because Prolog is generally relational (and this particular predicate doesn't stray into the nonrelational world), I could equally call it like this: ?- iflike(R, two). R = 2; false. or like this: ?- iflike(2, two). true; false. ?- iflike(2, three). false. ?- iflike(A, B). A = 1, B = one; A = 2, B = two; A = 3; B = three. There are also other ways to write that same predicate. One way is to write the clauses as a sequence of top-level definitions instead of joining the clauses together with semicolons: iflike(X, Y) :- X = 1, Y = one. iflike(X, Y) :- X = 2, Y = two. iflike(X, Y) :- X = 3, Y = three. Also, since we're simply trying to unify the arguments with other terms, we can write that unification in a different way: iflike(1, one). iflike(2, two). iflike(3, three). All three formulations are logically equivalent. Finally, pattern matching can be even more powerful. Unification can be used to decompose compound terms: ?- foo(X, Y) = foo(1, 2). X = 1, Y = 2. ?- foo(X, Y) = bar(1, 2). false.
true. 
Have never heard of this before- could someone describe its speciality? Is it meant to be small and fast? 
I am supposed that OPL mainly used on Raspberry Pi 3. Because OPL has a translator from Prolog to C. This allows you to control the GPIO.
1. What do you mean by “level” 2. What is the purpose of this exercise? 3. Do you think there might be some significance in the fact that or(P, or(Q,true)) is always true (technically: it’s a tautology)? 
Oh! Nice - would be good to control RPi through prolog. 
Yeah, it has Wiring Pi bindings by default.
It prep for a principles of programming languages class. By level I mean for the predicate or(P, or(Q,true)), or would be the first level, followed by p, or, followed by Q, true. I thought of it as a tree rooted at the outer or. I thought there would be a significance but I wasn't able to see how that would help me with the syntax
I think "level" means "depth" of the functor in the syntax tree or / \ P or / \ Q true
Yes this is what I mean
Ok, I get it now. So, as prep after your first week of prolog, you want to write your own proposition resolver?! 
If you specifically want to find lists of `"u"` strings, you can continually move the first element of the `String` argument to the `Leftover` list and check that it is in fact a `"u"`. This fails as soon as it finds a different entry. After you have reached the end of the list, all elements are now in `Leftover`, and you can just return its length: uA(L, [], Ls) :- length(Ls, L). uA(L, [S|Strs], Ls) :- S = "u", uA(L, Strs, [S|Ls]). You can also "cheat" a bit by using the [`forall/2`](http://www.swi-prolog.org/pldoc/man?section=forall2) predicate to do the iteration for you: uA2(L, Strs, _) :- forall(member(Str, Strs), Str = "u"), length(Strs, L). If To check if all elements of `String` are *equal* but you do not care about their actual value, you can just check if all consecutive pairs are equal: uA3(L, [], Ls) :- length(Ls, L). uA3(L, [S], Ls) :- uA3(L, [], [S|Ls]). uA3(L, [A,B|Strs], Ls) :- A = B, uA3(L, [B|Strs], [A|Ls]). You can also compare the first element to all the other ones, I use `forall/2` again: # in the empty input all elements are the same and the length is 0 uA4(0, [], _). # if there is at least on element, we make sure that all elements # of the rest of the list are the same and hte length is one more # than the length of the rest uA4(L, [S|Strs], _) :- forall(member(T, Strs), S = T), length(Strs, L1), succ(L1, L). 
This: uA3(L, [A,B|Strs], Ls) :- A = B, uA3(L, [B|Strs], [A|Ls]). Could be written as: uA3(L, [A,A|Strs], Ls) :- uA3(L, [A|Strs], [A|Ls]). Also, strictly speaking, this doesn't test if they are equal, it tests whether they unify, with the side effect of: if `A` was ground and `B` was not, then `B` will become ground (same as `A`). I know that prototype says you shouldn't use variables in that position, but prototype doesn't prevent such usages.
Spi prolog would probably be easier to get running and use. But I believe with some deviations that Mercury can work for that purpose. I don't think they make a lot of binary releases. 
Learn vanilla prolog first. Mercury shares a similar syntax but has a lot more built on top. I heard somewhere (and this might be incorrect) that Mercury doesn't support logical variables in which case Prolog is definitely the better first choice.
Definitely start with good, old Prolog. You don’t need the (excellent) safety and purer logic features when you are just starting out. 
You can see Mercury as reflection on Prolog. I actually started with Mercury, but very quickly realized that I both lack in terminology and in general conceptual understanding of how such language would work. Just to give you an example: Mercury formalizes the notion of determinism. I.e. the language can express ideas s.a. "this predicate succeeds at most once" or "this predicates succeeds multiple times" etc. This is hard to wrap your head around if you never worked with Prolog: without seeing how it works, it would just sound like some bizarre terminology to you. Mercury doesn't have an interpreter / an easy way to verify your program (you must go through compilation cycle), which makes exploration hard. Also, Mercury has a very peculiar approach to all I/O (which also hampers your ability to add diagnostic messages in your code). This may speak to a purist nature of some programmers, but it makes initial steps in understanding the language very hard. Debugging, introspecting your program -- all this stuff, which makes understanding, especially at initial stage easy, none of that works / works well in Mercury.
It seems appropriate for the material we are covering. But not from a syntactic point of view.
If there are &gt;3 items in the list, only the second rule matches and recurses on the tail. If there are 2 items in the list, both rules match - the first rule unifies the first of two items as Penultimate, and the second recurses on the tail. As the tail is only 1 item, neither rule matches and the query completes.
Hahaha, a fellow UvA applicant I see. You can see it as follows: the first line sets up a template for finding the penultimate item: when you have a list of two items, the first item is the penultimate item. If a list has only two items this is the only relevant line. But when a list has more than two items, the second line states that the penultimate item of the tail is also the penultimate member of the list itself. So when you have the list [jan, kees, piet, harry, peter], it might not fit the template, but the Tail of the Tail of the Tail, [harry,peter] does, and since the penultimate item of Tail of the Tail of the Tail is the same as the penultimate item of the list, this is the item you were looking for. Good luck with the selection!
The problem with `lonely` is that you X hasn't been instantiated to anything yes before you check if `lonely` must be true for X. To correct this, both lonely and notlonely have an implied clause, namely that everyone involved are persons. So if you rewrite `lonely` as `lonely(X) :- person(X), \+ notlonely(X).` Now the prover will first instantiate X as one of your persons, and then it will check if that person can be shown to be notlonely, and if not then it will return that the person is indeed lonely.
thanks!
hahaha, i was wondering when i would find someone who is also applying here, thanks for the explanation and good luck!
Could something like this work? lonely(X) :- findall(N, person(N), NS), findall(NL, ( member(N, NS), notlonely(N) ), NLs), member(N,Ns), nonmember(N, NLs). The idea is to, get a list of all the names, get a list of all the notlonely people, then get prolog to only match and return the names of people who are not in the list of not lonely people
Thanks! It works now!
Web scraping. xpath works better in prolog than any other language, as the idea of generators fits very naturally with the usual prolog execution model.
But why would X need to be instantiated as one of the persons in this line but not in the notlonely rule?
This is because `notlonely` instantiates its variables *not* from `person` but from `knows` and you have *coincidentally* made every argument satisfying `knows` also be an argument satisfying `person`, but not the other way around. Another way to understand this is that if you look at what `lonely` and `notlonely` rely on, they only ever call `knows` and never `person`, so how is the information about what `person` you have defined ever supposed to reach `lonely` or `notlonely`? (Answer, information about `person` can't reach the `lonely` and `notlonely` because those predicates never call `person` nor call any predicates that call `person`. `notlonely` works because you happened to repeat all the knowledge about notlonely persons in the `knows` predicate that `notlonely` calls, though you didn't put any information about other persons there. `lonely` and `notlonely` are cutoff from knowledge of `person` entirely, so `person` needs to be put *somewhere* in their execution path if you want knowledge of persons to be propagated to them. Right now `lonely` and `notlonely` only have knowledge about "what" knows "what". So if you have people who don't know anyone or who aren't known by anyone (which is what `lonely` is trying to figure out) then you're going to have to rely also on facts about `person` that are outside the facts about `knows`)).
The metainterpreter section is fantastic.
It this but is the actual code, check the right hand side of each of your dfaAccept’s. You have a misnamed rule in two of them. I may have missed something but other than that i think this would work. (Only read, haven’t run it)
I'm afraid that is not possible, to quote SWI documentation: &gt; Behaves as call/1 if no exception is raised when executing Goal. If an exception is raised using throw/1 while Goal executes, and the Goal is the innermost goal for which Catcher unifies with the argument of throw/1, **all choice points generated by Goal are cut,** the system backtracks to the start of catch/3 while preserving the thrown exception term, and Recover is called as in call/1. Emphasis added. I.e. the choice point that you would want to continue from is cut at the time `catch` is executed.
Not exactly a routine. I needed to parse something for what I didn't have a decent parser, so I used Prolog to hack one together. (It was some Ruby code comments that would later translate into description of HTTP endpoints). I had few similar cases.
Of course it doesn't. It escapes to the next available handler context. That's the whole point of catch/throw. You could just remove the throw and proceed with \`test(X)\` without enclosing it in a \`catch\`. It will backtrack over all clauses then.
Are you trying to hire someone to do your homework?
Let's actually work our way up to that. Let's say that we add another predicate to your system: notperson(X) :- \+ person(X). For specific values, it behaves as you might expect: ?- notperson(bennie). false. ?- notperson(c3p0). true. But what happens if we send in a variable: ?- notperson(X). false. Good, this is the same as what you're seeing in your more complex example. Maybe we can figure out what's happening here and apply that same reasoning to your more complex example. First, let's talk about what you would expect. You'd expect that `notperson(...)` would be false for any of the 8 people that you listed in your program, and true for any other term. So you would expect `notperson(X)` to, what, produce infinitely many terms? That would be kinda neat, actually, but would probably not be very useful. OK, what does `\+` actually mean? You should read `\+` as "is not provable". In other words, `\+ person(bennie)` should be read as "it is not provable that `bennie` is a person" (which is false; `bennie` is clearly a person), and `\+ person(c3p0)` should be read as "it is not provable that `c3p0` is a person" (which is true; given all our facts and rules, there is no way to prove that `c3p0` is a person). But `\+ person(X)` is read as "it is not provable that there is an `X` that satisfies `person(X)`" or, more simply, that "`person(X)` fails for all `X`". And clearly, since `bennie` is a person, there *is* some `X` for which `person(X)` passes, and therefore `\+ person(X)` fails. This is the danger of `\+`. Prolog is a truth-oriented system. When you define a fact, Prolog accepts it as true. When you define an inference rule, Prolog can combine that rule with things that are already known to be true (either stated as true or inferred to be true) to generate additional truths. But this means that Prolog has a hard time telling you what *isn't* true. Prolog operates according to the closed-world assumption: everything not provably true is assumed to be false. So because truth is determined via construction, the set of things that are false is vastly larger than the set of things that are true (even if the set of true things is infinite, there are infinitely many falsehoods for each truth). It's easy to mistakenly think of `\+` as "generate a relation that is the mirror of the given relation". But Prolog can't really do that. --- OK, back to your case. `\+ notlonely(X)` should be read as "it is not probable that there is an `X` that satisfies `notlonely(X)`" or, more simply, "`notlonely(X)` fails for all `X`". And since `bennie` knows himself, he's not lonely, and so `notlonely(X)` is true in at least one case and `lonely(X)` therefore fails.
It's a formative assignment for 'personal learning', so not really. I find it easier to learn when I have a reference however, thus the posting. 
This is a more complex control flow than exceptions were designed for. Continuations may line up more naturally with the kind of control flow you are imagining. [http://www.swi-prolog.org/download/publications/iclp2013.pdf](http://www.swi-prolog.org/download/publications/iclp2013.pdf)
Yeah, for complex but relatively small parsing tasks, DCGs are amazing. I wrote a parser which assigned "weights" to the quality of a parse using a DCG in order to automatically ingest press releases from web-pages and it did very well at extracting date, title etc. with very little work.
What is this? 
hahahaha
It’s a semicolon.
The syntax \[\_|\_\] does not mean 'or', but rather is a way to compose and decompose lists. If you type X = \[a,\[b,|\[\]\]. into the repl you might get a better understanding of this. What you want to do here is state that Y is not equal to anna and Y is not equal to alex. This can get tedious, so an other approach is to say that Y should not be a member of a list containing anna and alex. You already know how to do most of this, what remains is to know that in Prolog the operator \\+ means not provable and is the preferred way to state negation. If I wanted to say that X is not a person in Prolog I would type \\+ person(X). For the record ; means or, but like most programming languages you can't say that a variable should not be equal to this or that, instead you have to say that Y is not a member of \[anna,alex\]. Although since there are only two cases in your program it might be best to go with Y \\= anna, Y \\= alex. as this is arguably the most clear approach.
[| actually does do or](http://www.swi-prolog.org/pldoc/doc_for?object=(%27%7C%27)/2), but it’s legacy notation (though still kinda popular in DCGs?), and most code would use ; instead. But it will mean OR when composing goals, not as part of [list notation.](http://www.swi-prolog.org/pldoc/man?section=ext-list-motivation)
Yes. It doesn't evaluate by default. The JSON of prolog is the expression. 1 + 3 in prolog is basically a POD structure.
Can't you use [library(assoc) from SWI-Prolog](https://github.com/SWI-Prolog/swipl-devel/blob/master/library/assoc.pl)? It's licensed under 2-clause BSD.
Yes, that appears to be what I want. I don't know why I didn't think of that. Thanks!
rust and wam, what could be better
Very nice project! About this: &gt; The question of how to get assembly from WAM code is something I'm still considering. Have you looked how GNU Prolog does this? They have a nice overview paper, [On the Implementation of GNU Prolog](https://arxiv.org/pdf/1012.2496v2.pdf). By their own admission, the generated code is not as fast as possible (outperformed by Yap, which is a fast interpreter, not a compiler), but their approach looks wonderfully simple to me. If I ever write my optimizing Prolog compiler, it won't be WAM based. I would follow WAM for an interpreter or if I were to design the perfect hardware for executing Prolog, but my feeling is that for conventional hardware, you want a higher level intermediate representation for optimization before lowering to something at the level of WAM. I think that's more or less what Van Roy showed with Aquarius.
Thank you! I did read one of the GNU Prolog papers on WAM-&gt;assembly generation a year ago. Then I turned away from the idea of writing assembly by hand. I'm leaning more toward using a pre-existing JIT toolkit like LLVM or Eclipse OMR to produce assembly from WAM code now. Van Roy's thesis is something I still need to explore fully, but the gist I took from what I read of it was that he starts with Prolog as a high-level intermediate representation, and it's only later that it's compiled down to instructions that look an awful lot like WAM code. Perhaps the WAM interpreter I've got now could serve as the basis for that approach.. only then would I consider how to compile to native code. &amp;#x200B;
Thanks! This is really comprehensive, I understand it now.
How many times did you run it? The number is huge for a single run. But the code itself doesn't do anything remarkably computationally intensive... which makes me wonder if what you were timing wasn't actually the interpreter's start time or something like that.
For the swi-prolog I put the code in `myfile.pl` and ran this: ``` $swipl myfile.pl Welcome to SWI-Prolog (threaded, 64 bits, version 7.7.17) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). Cannot read termcap database; using dumb terminal settings. ?- time(test). ``` and the python program I tested in an ipython console like this: ``` $ipython Python 3.6.5 (default, Jun 17 2018, 12:13:06) Type 'copyright', 'credits' or 'license' for more information IPython 7.0.1 -- An enhanced Interactive Python. Type '?' for help. In [1]: normal_leap_year = lambda Y: 0 == Y%4 ...: exception = lambda Y: 0==Y%100 ...: exception_to_exception = lambda Y: (Y%900) in (200,600) ...: leap_year = lambda Y: (normal_leap_year(Y) and not exception(Y)) or (norm ...: al_leap_year(Y) and exception(Y) and exception_to_exception(Y)) ...: leaps = lambda Y1, Y2: len(list(filter(leap_year, range(Y1, Y2)))) ...: def test(): ...: return ( ...: leaps(2019, 2020) == 0 ...: and leaps(1900, 1901) == 0 ...: and leaps(2000, 2001) == 1 ...: and leaps(2800, 2801) == 0 ...: and leaps(123456, 123456) == 0 ...: and leaps(1234, 5678) == 1077 ...: and leaps(123456, 7891011) == 1881475 ...: ) ...: In [2]: %time test() In [3]: %timeit test() ``` Note on python version: lines 2 and 3 are slightly different ways of measuring speed but they came out the same in this instance. As far as I can tell, both interpreters have analyzed the relevant code before the test is timed. Feedback very welcome though, thanks!
I'm not at a computer where I can run your code, but... 3.5 *secons* is an insanely long time for this kind of calculation. Even 3.5 millisecons would be a very long time. Are you sure those are seconds? Just to put this in perspective: typical consumer-grade CPU is capable of ~3GHz, this means that your test would have performed 10 000 000 000 000 operations to get the result (ten billions).
I'm not saying it's an efficient algorithm (this could be why it's surprisingly long?), but yes it's absolutely 3+ seconds on my MBP at home, around 3 at my MBP at work.
Are you really not noticing that using three backticks for codeblocks does NOT work on reddit? Most text editors would insert the necessary indent if you just select all the text and press tab once. This of course means you should have already told your editor that indent is 4 spaces big and tabs should be replaced with spaces. Either way, please format code as code as code, pretty please?
_All_ the time goes into the last "test": ?- leaps(123456, 7891011, 1881475). The astute reader will notice that `between(123456, 7891010, X)` succeeds almost 8 million times, this is 8 with 6 zeroes.
First of all, here is the program as I have it on my computer (since you didn't manage to post it as a codeblock, the formatting was all over the place and one backslash was missing): $ cat revjulcal.pl normal_leap_year(Y) :- 0 is Y mod 4. exception(Y) :- 0 is Y mod 100. exception_to_exception(Y) :- R is Y mod 900, (200 is R; 600 is R). leap_year(Y) :- normal_leap_year(Y), \+ exception(Y), !. leap_year(Y) :- normal_leap_year(Y), exception(Y), exception_to_exception(Y). leaps(Y1, Y2, N) :- Y2prime is Y2 - 1, findall(X, (between(Y1, Y2prime, X), leap_year(X)), L), length(L, N). test :- leaps(2016, 2017, 1), leaps(2019, 2020, 0), leaps(1900, 1901, 0), leaps(2000, 2001, 1), leaps(2800, 2801, 0), leaps(123456, 123456, 0), leaps(1234, 5678, 1077). leaps(123456, 7891011, 1881475). I will only use the last test since it is the only one that actually takes any measurable amount of time. $ swipl -q ?- [revjulcal]. true. ?- time( leaps(123456, 7891011, X) ). % 51,050,118 inferences, 3.394 CPU in 3.396 seconds (100% CPU, 15042948 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 51,050,116 inferences, 3.382 CPU in 3.385 seconds (100% CPU, 15092552 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 51,050,116 inferences, 3.376 CPU in 3.378 seconds (100% CPU, 15121773 Lips) X = 1881475. So basically I see exactly the same as you do. Now I do the easiest thing I can come up with and turn on "optimization". Read about it, but my impression is that it is mostly about arithmetic (aha!): $ swipl -q -O ?- [revjulcal]. true. ?- time( leaps(123456, 7891011, X) ). % 35,057,583 inferences, 2.347 CPU in 2.349 seconds (100% CPU, 14934846 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 35,057,581 inferences, 2.337 CPU in 2.338 seconds (100% CPU, 15002371 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 35,057,581 inferences, 2.330 CPU in 2.332 seconds (100% CPU, 15044752 Lips) X = 1881475. Great, this shaved off one third of the time. Big if true. I would probably compare it to the Python solution, but I am too lazy to now start indenting your Python code :-( Now, instead of using `is/2`, I will use `=:=/2` for comparisons. Too lazy to show the code, you need to judicially replace for `is`s with `=:=`s. $ swipl -q -O ?- [revjulcal]. true. ?- time( leaps(123456, 7891011, X) ). % 35,057,583 inferences, 2.263 CPU in 2.264 seconds (100% CPU, 15493637 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 35,057,581 inferences, 2.250 CPU in 2.255 seconds (100% CPU, 15582921 Lips) X = 1881475. ?- time( leaps(123456, 7891011, X) ). % 35,057,581 inferences, 2.245 CPU in 2.247 seconds (100% CPU, 15615929 Lips) X = 1881475. Tiny, but measurable difference of about 5%. At this point I realize I have other stuff to do, so I will let you absorb this. I suspect you can get even more time off by avoiding the cut somehow.
Hi, I wish I could see what it looks like for you because it comes up as a proper code block for me. Are you using a mobile app or the website? I'm using the website.
Update: I've created pastebins with the two codes: &amp;#x200B; Prolog: [https://pastebin.com/t1j0gdKW](https://pastebin.com/t1j0gdKW) &amp;#x200B; Python [https://pastebin.com/A41kZZ0i](https://pastebin.com/A41kZZ0i)
I see. I am using the old website because I am an old fuck who hates change. I'm sorry. FYI, on the old site, the three ticks don't work. Maybe it is time to take the plunge and stop using it.
I also suspect that it is easier to optimize better when using \`=:=\` instead of \`is\`. With \`is\`, the compiler would have to make certain that the left-hand side \_cannot\_ be a variable. I don't even know if it is possible to know this at compile time in the general case.
Oh, I didn't see that...
Nah, nevermind, Just didn't occur to me that someone would look for leap years that far into the future, so I though that intervals were small.
I did not know about -O, that's great for anything!
Haha, now that you mention it I think it's the ability to render three back tick code blocks that finally got me to switch over to the new site. The 4 spaces code blocks on the old site were a pain to write
I work with Prolog since I deal with [Inductive Logic Programming](https://en.wikipedia.org/wiki/Inductive_logic_programming) (ILP) in my scientific work. There is a community of Prolog programmers around ILP. People develop and improve ILP solvers ([Metagol](https://github.com/metagol/metagol) for example). I have never seen Prolog out of academic researches. If you want to deal with ILP as researcher you have to know Prolog and maybe you will have a long career around it.
Queries are the same structure as clauses so you can put them in the body of a predicate. So, if the queries that gave you the solutions were, for example: query1(X),query2(Y) then you have the answer already: myAnswer:-query1(X),write(X),nl,query2(Y),write(Y),nl. % nl means write a new line
Ahh so if my queries are in the format setof(X,Y,Z) I just do myAnswer :- setof(X,Y,Z), write(Z), nl...and so on? Thanks for the quick response!
Prolog is cool, isn’t it. :). 
Need to have another method where one element you have to check for atom or variable. 
Add a condition of X being in an atom in the 3rd rule, and add another rule for list that applies that rule recursively. 
According to your second clause, `sum([H|T], Total)` is always fails when `H` is odd. It should rather succeed and add nothing to the total, so you either need an additional clause or if-then-else. For the latter, replace iseven(H), Total is SubTotal + H*H. with ( iseven(H) -&gt; Total is SubTotal + H*H ; Total = SubTotal ).
Hey thanks for your reply. The solution works perfectly. Just wondering when you said a second clause, how would that be?
in recursion, a call or a predicate is a state. So you could implement this in terms of predicates skip/3 and noskip/3. Or one predicate actual\_skip/4 that accepts one more parameter (your "A" variable that came out of nowhere) Try to 1. decompose your example into example calls of skip/3 and noskip/3. 2. Write down the end cases for each of skip/3 and noskip/3 3. Write down the recursion steps for each of skip/3 and noskip/3 - probably this will involve one case where skip recurses to noskip and one where skip recurses to skip, and similarly for noskip...
I would break the problem into two. First consider `permutation(A, B)` that succeeds when `A` is a permutation of `B`. This can be implemented in full generality, where neither `A` nor `B` need to be instantiated. All Prologs should provide this in their standard library. Then consider a predicate `acceptable(A, B)` that succeeds when `A` and `B` don't have any elements in the same place. Finally, you can combine the two: acceptable_permutation(A, B) :- permutation (A, B), acceptable(A, B).
This whole situation smells like cheating on homework, but I'll go ahead and spell it out. All of this is most easily implemented in terms of the predicate `select/3`: %% select(X, List1, List2) % True when List1 with the element X removed is List2. select(X, [X|Rest], Rest). select(X, [Y|List1], [Y|List2]) :- select(X, List1, List2). With that we can get `permutation/2`: %% permutation(List1, List2) % True when List1 is a permutation of List2. permutation([], []). permutation(List1, List2) :- select(X, List1, Rest1), select(X, List2, Rest2), permutation(Rest1, Rest2). Also `acceptable/2` is straight forward: %% acceptable(List1, List2) % List1 is acceptable w.r.t. List2 if they are the same length and % neither contain the same element at the same position. acceptable([], []). acceptable([X|List1], [Y|List2]) :- X \= Y, acceptable(List1, List2). So finally: acceptable_permutation(List1, List2) :- permutation(List1, List2), acceptable(List1, List2).
You may wish to compare this with some implementations is the meta:: library of Logtalk. PS are you using Mercury? 
in programming paradigms? The problem with skip([H|T], S, L), A=1 :- not(member(H, S)), skip(T, S, L). What is A here? A solution to this is to introduce something like backend_skip([H|T], Switches, Result, 1) :- ... and simply calls them like so: skip([H|T], S, L) :- backend_skip([H|T], Switches, Result, 1). This way, you don't change the interface while maintaining sanity. Then, inside the function, use `-&gt;` to do the rest.
I think this is quite reasonable. I had the same idea a while back and wrote some code using assert/retract for portability. I'll post it if I find it - hope I didn't accidentally delete it. My thinking was/is that this folding over solutions is a good candidate for a fast, native built-in predicate because you can implement many things in terms of it, like `findall/3`, finding the first n solutions and all the stuff in `library(aggregate)`.
Not currently using Mercury, I opted for swipl because of the nice library support and larger community. I really like Mercury a lot though, and I'm a bit unhappy that it's not more popular.
It's like being on archaeological track. All thanks to cvs2svn.
No, I was looking on the wrong computer. Here it is u/RowanDuffy, FWIW, along with sample definitions of finding all and finding \`n\` solutions: foldall(P, Template, Goal, X0, X) :- setup_call_cleanup(asserta('$foldall'(X0)), ( foldall(P, Template, Goal) ; true % foldall/3 always fails ), retract('$foldall'(X))). foldall(P, Template, Goal) :- call(Goal), once('$foldall'(X1)), ( call(P, Template, X1, X2) -&gt; once(retract('$foldall'(X1))), asserta('$foldall'(X2)) ; ! ), fail. my_findall(Template, Goal, List) :- foldall(my_findall_comb, Template, Goal, X-X, List-[]). find_n(N, Template, Goal, List) :- foldall(find_n_comb, Template, Goal, (N,X-X), (_,List-[])). my_findall_comb(X, Y-[X|Ys], Y-Ys). find_n_comb(Y, (N0,X0), (N,X)) :- N0 &gt; 0, N is N0 - 1, my_findall_comb(Y, X0, X). &amp;#x200B;
Use this book: https://mitpress.mit.edu/books/art-prolog You can download the PDF at the link. `append/3` in particular is explained somewhere around page 60 but you might need to read a bit of what comes before that.
As you becomw more familiar with various technics for recursion, you’ll find this easier to read. As I recall, the hardest part for me in prolog was combination of recursion and unification, if I can give you an advice, start with functional language. For example book Little Schemer teaches you all important things about recursion. Then this should be easier to read, because you’ll notices the patterns. Then you can jump on any book about prolog and learn about unification.
/u/jibbit I second this recommendation. We program in Prolog upon a quite simple computation model. Once you understand the model, reading these kinds of definitions becomes second nature. Reading up through Chapter 4 of the *The Art of Prolog* should give you everything you need in this regard, and it is a really lovely book. 
I read it thus: * \`append\` is a relation between three lists. * It is a \*\*fact\*\* that when the first list is empty, the second two lists are the same, i.e. \`append(\[\], A, A).\` * As a \*\*rule\*\*, head of the first list is the tail of the third (i.e. — ignoring the variables which are not repeated in the head for now — \`append(\[A|\_\], \_, \[A|\_\])\` ) \*\*if\*\* (\`:-\`) the append relation holds between the tail of the first, the entirety of the second, and the tail of the third (i.e., \`append(B, C, D)\`, given the context of our head \`append(\[\_|B\], C, \[\_|D) :-\`. For this to provide clarity, we must think think through unification, recursion, and horn clause logic. Once these are understand, Prolog becomes a very perspicuous means of communicating programs. Fortunately, the basics of these concepts can be mastered in a fairly short time.
Trace through both: append([a],[b,c],X). And append([a,b],[c],Y). Notice the difference and that should give you a little insight. 
What OS are you on?
I am on MAC OS X Lion 
Cool that helps thanks. 1. How did you install swipl, and 2. When you run `which swipl` in the terminal, do you get any output? If so can you post it here (erasing your personal name if it appears)
Sounds like swipl is not on your PATH. I believe there is an option to add it during installation, otherwise it isn't hard to add it to your path yourself.
How to design programs is a good read on modern racket https://www.htdp.org/2019-02-24/
Try to install it through Homebrew. brew install swi-prolog
How would I do that exactly?
Thank you this worked!! 
Thank you both, I will give it a go
Thank you, that is extremely helpful. It is similar to how I’m reading it, and the bit that I’m struggling with - the bit that seems ‘emergent’ - is that that reading ‘results’ in ‘appending’. The more I dwell it the clearer it gets. It still seems like a difficult ‘definition’ of appending, but you’ve helped a lot.
Step 1: In a terminal, run: export PATH=$PATH:/path/to/swipl Where /path/to/swipl is the path to the folder containing the executable swipl file in your file system. Step 2: Verify that this works. Using the same terminal session, navigate to a .pl file elsewhere in your file system. Try to run it using: swipl FILENAME.pl Where FILENAME is the name of the prolog file you want to run. If this doesn't open the file, you probably made a mistake somewhere in step 1. Step 3: If the file is now open, do the following things to add the export command to your bash profile. 3.1 In the terminal, run: vim ~/.bash_profile To create or open the bash_profile file located in your home folder with vim 3.2 In this text editor, type: i To start inserting 3.3 And then type: export PATH=$PATH:/path/to/swipl 3.4 Hit ESC to stop inserting 3.5 Type: :wq And hit enter to write and quit. Any command in the bash profile script will be executed automatically at the beginning of every terminal session. 
Thanks!
Sounds like a healthy process of developing understanding to me :) &gt; the bit that seems ‘emergent’ - that that reading ‘results’ in ‘appending’. This is true when we query the predicate thus ``` ?- append([1,2,3], [4,5], C). C = [1, 2, 3, 4, 5]. ``` and we think of the value instantiated for `C` as being the "result". I.e., if we think of the `append/3` predicate is an idiosyncratic way of writing the function `append: List A, List B) -&gt; List C`, which takes a pair of lists to a list with the second member of the pair appended to the first. However, generally speaking, the reading given here does *not* "result in appending": it describes a relation between three lists, and it will have different "results" depending on how the predicate is queried. Successive queries of `?- append(A, B, [1,2,3,4]).` will generate all prefix-suffix pairs of the given list. Querying `?- append(A, [5,4,3], [1,2,3,4]).` will simply fail, telling us that `[5,4,3` is not a suffix of the given list. And there are more uses besides. I suspect that a fair amount of the difficulty of good Prolog definitions is that, ideally, they should define relations that can be "run in all directions" to compute all members and aspects of the defined relation. A good exercise might be: come up with an informal definition that you think is less difficult to understand, then see if this definition can also be run backwards to obtain all the prefixes of a list. If not, why not? Similarly, can you explain why your informal reading of the Prolog definition does allow this? 
It's not clear to me when you check if something is zero or not. Here's one implementation that's similar to yours: count([], 0). count([0|T], N) :- count(T, N). count([H|T], N) :- dif(H, 0), count(T, N1), N is 1+N1.
You should exchange `{code_type(Code, alnum)}` and `[Code]`, otherwise you are enumerating every `alnum` code until you find the one in the link. You can also write the code for a character by prepending `0'`, so `0'/` is 47.
Are uninstantiated variables different from zero?
I’m not too sure what “dif” does but would you place it on the same level as “not”? I’m not allowed to use built in methods equivalent to mod for this. 
I’m not quite sure truth be told, I’m not sure what the issue itself is. After it finishes at the end of the list I get junk data which I’m now starting to think is because I don’t give it a case when things are zero. 
Well, to give you an example, say, you have this list: `X = [1, 0, 0, Y]`. What would you get if you queried `?- count(X, N)`. Would it be 2 or 3? I mean, nobody really knows if `Y` is zero or not, there's just not enough information to deduce that, so, it's up for you to decide. Now, imagine an even worse conundrum: `X = [1, 0, 0 | X]` -- how many zeros do you think this list has? :) (sorry, this is more of a joke question).
Perfect thank you very much! I'm still getting the hand of DCGs' execution order, I thought \`Code\` would have been grounded at that point. Now I'm getting sub-millisecond times: &amp;#x200B; link(Protocol, Host, [0'/|Path]) --&gt; protocol(Protocol), "://", host(Host), "/", path(Path). protocol(http) --&gt; "http". protocol(https) --&gt; "https". protocol(ftp) --&gt; "ftp". host([Code|Codes]) --&gt; [Code], {code_type(Code, alnum)}, host(Codes). host([Code|Codes]) --&gt; ".", {Code=0'.} , host(Codes). host([]) --&gt; []. path([Code|Codes]) --&gt; [Code], path(Codes). path([]) --&gt; []. &amp;#x200B; ?- time(phrase(link(Pr, _Ho, _Pa), `https://google.com/my404page.html`)), string_codes(Host, _Ho), string_codes(Path, _Pa). &amp;#x200B; 38 inferences, 0.000 CPU in 0.000 seconds (100% CPU, 380712 Lips) Host = "google.com", Path = "/my404page.html", Pr = https ; 4 inferences, 0.000 CPU in 0.000 seconds (100% CPU, 199283 Lips) false And thanks for the \`0'\` tip, that's very handy!
Hm, I don't understand the distinction between built-ins like `not` and built-ins like `mod`, but `dif` is a built-in in almost all Prolog systems though it's not ISO I believe. ([Here's how you can implement `dif` in three lines of ISO Prolog](https://stackoverflow.com/questions/20223390/prolog-a-person-is-a-sibling-of-himself/20238931#20238931) if that's your concern.)
This is fantastic, thank you for your help. If you don't mind me asking would it be okay for me to try and understand your function and you explain anywhere I might be misunderstanding? From the provided function: This line serves as our base case, if we are given an empty list then we simply get 0. count([], 0). Our next case is if the first entry in the list (the head) is 0, if it is then we don't want to add 1 to our counter but rather keep traversing through our list. count([0|T], N) :- count(T, N). This is our final case where it matches what we'd like. If the head of the list is not a 0 then we want to keep traversing through the list while adding 1 to our counter. count([H|T], N) :- dif(H, 0), count(T, N1), N is 1+N1. Are all recursive functions in Prolog going to be broken down like this? Our first case is our base case where we are essentially left with nothing. Our second case where we are given items for our predicate but in our given step we don't have what we want (in our case it's a 0). Lastly, a final case where it satisfies what we want (where it's not a 0 so we count 1)?
So because Y hasn't been instantiated with an assigned value the program will fall over on itself? Also I worry I'm gonna derp out on the joke question but will the result be infinite? I'm not sure what the ending notation means (the "| X]" but I assume Prolog will keep going through the list forever and ever? Thank you again for your time.
&gt;Are all recursive functions in Prolog going to be broken down like this? Our first case is our base case where we are essentially left with nothing. Our second case where we are given items for our predicate but in our given step we don't have what we want (in our case it's a 0). Lastly, a final case where it satisfies what we want (where it's not a 0 so we count 1)? Well, *all* recursive functions depends. What *all* recursive functions have is a base case and a recursive case. So `count([], 0).` is the base case here. Then the recursive case for this *particular* predicate is broken into two sub-cases: the case when the head of the list is zero, and the case when it's not.
Ah I see. Clearly I need more practice haha, I fear my next step might be a little too ambitious then. I'd like to also ensure values like "103" do not get counted as a value without a zero, so in a list like [1,3,103] the predicate would only evaluate true if a value of 2 is passed (the 103 contains a 0). I'm not sure how I'd achieve it in Prolog, I managed it in Haskell however.
Interesting puzzle :) &amp;#x200B; So referring to the code I wrote above, the two recursive subcases are divided along the line of "meets a condition" and "doesn't meet a condition". `count([0|T], N :-...` is a common way to say "This is the case when the head of the list is 0." It could have been replaced with something like `count([H|T], N) :- H=0,...` So that the code would look like count([], 0). count([H|T], N) :- H=0, count(T, N). count([H|T], N) :- dif(H, 0), count(T, N1), N is 1+N1. This makes much more apparent the dichotomy of `H=0` meets the condition vs. `dif(H, 0)` doesn't meet the condition. &amp;#x200B; To adapt the code to your next step, suppose you have a predicate `has_a_zero(X)` that succeeds only when `X` has a zero, then you could write the code like this: count([], 0). count([H|T], N) :- has_a_zero(H), count(T, N). count([H|T], N) :- \+has_a_zero(H), count(T, N1), N is 1+N1. `\+` meaning `not`. &amp;#x200B; One more thing, an astute prolog programmer would probably look at my latest iteration of the code and note that in the case where something doesn't match, `has_a_zero(H)` is being evaluated twice, once to see if `H` satisfies the condition (and failing) and then again to check if `H` *doesn't* satisfy the condition, which is redundant. There's a few ways to rewrite this, ideally so `has_a_zero(H)` is only evaluated once. One way is to use an `if` statement: &amp;#x200B; count([], 0). count([H|T], N) :- count(T, N1), (has_a_zero(H) -&gt; Delta is 0; Delta is 1), N is Delta + N1. 
No, it won't fall over, it just might do the thing you con't expect. It might count uninstantiated variable as a zero, whereas you didn't want it to, or the other way around.
So I've successfully figured out a predicate that can achieve what I'd like and am now at the final step which I hope is the simplest step. I'd like to do a basic comparison now where the user will pass in the list and then pass in another argument being the number of zero free numbers they expect. For example: foo ([1,2,3,103],3). Would return true. This will probably require a comparision but how is that achieved in Prolog? Odds are I'd require my predicate for counting the number of zero free values to return that value but I'm not sure how to do it. Here's what I'm hoping to do: foo(List, NumZeroFree) :- countzerofree(List, 0) == NumZeroFree..
It’s because of the order in which the facts are tested. By the time you’ve got to lalaland, stone there are no more casting facts to test. 
So I got it. But how can I solve it? Or is it normal?
This is expected behaviour. What were you expecting? 
I thought that there was a way to let the "false" not showing also in the first result as in the second.
`false` doesn't mean what you think it means in Prolog. In a set of results, `false` means "there we no more results". If it's the first result, then that means that the query was not provable. Otherwise, it merely marks the end. `false` is sometimes omitted when the Prolog engine realizes that there is no way for it to produce any additional results. But that should be considered to be the odd case, rather than the trailing `false` being treated as weird. 
I see. Thank you very much :D
If you take a look at findall/3 and what it does, it overcomes this behaviour in a more consistent way. 
I will try that. Of course i knew that it should run in all directions but it was far from my mind when trying to parse it.
How about a prolog to “SQL” translation layer? There aren’t enough options available to prolog programmers who want to either persist their data in RDMS tables or perform queries on existing databases. 
Welcome! Here are some of my favorite starter resources for Prolog: * [Adventure in Prolog](http://www.amzi.com/AdventureInProlog/a1start.php) by Dennis Merritt is a whole tutorial series to teach you prolog while building a text adventure game. It's also recently been published as a book you can purchase on Amazon. (Side note: the series is written with the AMZI Prolog interpreter in mind. To run the code on SWI-Prolog you may occasionally need to add `:- discontiguous(my_predicate).` directives to the code. The SWI-Prolog interpreter will inform you about when and where you need to do this at runtime.) * [Jolly Roger](https://github.com/gkallergis/Jolly-Roger/blob/master/Jolly-Roger.pro) "A simple, natural language based, pirate adventure game in Prolog." I found playing this game and then reading the source code to be fun and informative. * [The Playing with Prolog Youtube Channel](https://www.youtube.com/channel/UCfWpIHmy5MEx2p9c_GJrE_g) has a lot of videos going through various trendy projects you can do with Prolog such as building an Alexa skill, making a 3D animation, providing a Prolog-based service to node-red, many videos on prolog-based web services, and the channel has interviews and instructional videos as well. * [The SWISH directory of example programs using the SWISH interface](https://swish.swi-prolog.org/example/examples.swinb) is invaluable to learn and read simplified examples of popular applications of Prolog from beginner to advanced levels. For learning Prolog concepts I recommend: * [Prolog Under the Hood: an Honest Look](http://www.amzi.com/articles/prolog_under_the_hood.htm) an essay by the same writer as the Adventure in Prolog series above. When I was first introduced to Prolog (admittedly not from the book you read which I heard is very popular) I found a lot of noise promising things in Prolog that I could not get to work in practice. (There was a bit of an exuberant hype cycle in the 80s for anything related to AI.) The author wrote this article in response to that and it helped me understand a lot better Prolog's underlying execution mechanisms. * [The Power of Prolog website](https://www.metalevel.at/prolog) run by Markus Triska has given me the clearest and most succinct understandings of pure and declarative Prolog concepts. The author has also written example applications related to web servers, bitcoin addresses, cryptography, business apps, and other things off the top of my head. And I may be burying the lede here but he also runs the [Power of Prolog Youtube Channel](https://www.youtube.com/channel/UCFFeNyzCEQDS4KCecugmotg) which quite honestly I just listen to the videos on repeat over and over and over because they're so informative and clear. This is most of the best stuff that took me a while to find but has been hugely influential to my programming in Prolog.
that sounds pretty cool, thanks
wow, this is an amazing answer. thank you for taking out the time for writing such a detailed write up.
Window manager
I really get you. I am a huge fan of the language but get very frustrated at the lack of good example code and the lack of good example use-cases out there. But, having persisted, I’m pretty sure I have found the sweet spot and, from what I can see, my take is original (which is both flattering and depressing at the same time). I feel I could write a book on this subject but, to give you a taste, here is what I have found: Prolog is ideally suited for: - recursive data structures - transforming state but not creating state Hence I have used it for translating between different schemas such as one XML format into another. This is what I found out by myself. Other people (more prominent in the P. Community than I) have argued that Prolog is ideally suited to websites (both static and active, I think) and, in my limited experience, would agree. In the near future, I would like to investigate it’s use for replacing SQL and RDBMs’. I encourage you to keep trying! 
I think it's too easy to find misleading hype about Prolog and distinguishing it from actually using Prolog. Earlier today I wrote [this post](https://www.reddit.com/r/prolog/comments/ba4hn3/beginner_to_intermediate_project_ideas/ek93s69/) showing what I think are the best resources introducing and discussing Prolog and applications written in prolog. I hate hype too, personally. [Prolog Under the Hood: An Honest Look](http://www.amzi.com/articles/prolog_under_the_hood.htm) is an essay written by Dennis Merritt, (also author of the great [Adventure in Prolog series](http://www.amzi.com/AdventureInProlog/a1start.php)) that responds to similar hype about prolog in the late 80s/early 90s. It clarifies a lot of what is and isn't going on in Prolog. &gt;But I'm sure that's not all there is to it, it's just hidden under pages and pages of unintelligibile PhD research. So what is it? What modern problems are being solved by Prolog that can't be solved as easily in a functional language? I've noticed this a lot as well, if you don't find the right authors then there's a ton of hype to wade through. For someone explaining *for real* the more declarative tools Prolog programmers have that other languages may not I recommend Markus Triska's [Power of Prolog website](https://www.metalevel.at/prolog), which discusses declarative programming, constraint solvers, other prolog concepts and lots of applications including expert systems.
I think the Watson system from IBM, which played jeopardy successfully a few years ago, used prolog for some things. I also recall reading that (around 2014, I think) a major part of the world's airline journeys (finding routes) were planned by prolog systems My own experience is that it's a natural for business rules. Also, the structure and the relative simplicity of the syntax makes it easy to automatically construct from flowcharts.
That all sounds very interesting. Especially converting flowcharts to Prolog, it seems like it could be a good asset for implementing a Finite State Machine for the AI in a game. Can you please elaborate a bit more? Do you have a UI in which you design and export the flowchart?
I must say, Prolog Under The Hood just demystified a bunch of things. It's written clearly, and, most importantly, honestly. And it contains the line which I was looking for: &gt; Just about anything you want to do in AI requires pattern-matching and search, and that is what Prolog does best. Natural language parsing, game playing, expert system building, frame and object implementation, simulations--all are easy in Prolog. Game playing and simulations are definitely up there for me, but I'm still in that rough spot where I've been programming in imperative languages for many years and toyed with Haskell and APL for a few days in total, so I'm still pretty ignorant about _not_ doing things procedurally, apart from what little modern C# and Python taught me in that regard. I think I'll follow along Adventure in Prolog and make a tiny adventure game to familiarize myself with the built-ins and with the control flow in general. As for Power of Prolog, that's what I've been reading so far and it's been a great resource. I just noticed there's a section on AI, so I'm going to read it. Thank you!
I made an entire IDE for a prolog-based advisory/ configuration system at my previous job. Works great :) - Several banks are using it, and seem happy as pigs in shit, if you excuse the expression. Product owners are using it to define their own rules, with us popping in at times to help them putting up some special architecture-stuff for different kinds of reasoning they want to do. It also includes an Excel-like part for integrating tabular data, integration with native .Net data structures, and the decision-models are deployable in a service. Prolog expressions are very easy to treat as Lego pieces, and easy to work with for stuff like this, IMO. I had a little article about it on the Google+ Prolog group, but Google seems to have terminated g+, and I don't have any screenshots available on my phone. The company doesn't seem good at advertising it, as I can find no screenshots of it online. I found something called visirules, but that looks a bit like a toy in comparison :) If you're interested I could see if i vann dig up some screenshots? Making my own version is in my hobby-project pipeline, and I found some promising methods of constructing the flowchart-shapes in WPF when I took a stab at it last week
&gt; are there use cases where the unification engine would be better suited than newer tools such as, for example, a neural network? Yup. Here's one case I'm working on: there's a bunch of chest X-rays and the analysis of the images given by the radiologist who processed them. My goal is to label images according to certain categories they might belong to. For example, the images may be rated on urgency scale, or they can be categorized as having medical equipment in the patient's body, besides the obvious diagnosis-related labels. Neural network is a poor match for this task because, even though I have few thousands of images, the categories are rather small, but precision is very important. Neural network would've been a rather blunt tool, while requiring orders of magnitude larger dataset. However, the analysis given by radiologists is typically very short, the language used to describe images is very regimented. So, I have high hopes for something like Prolog (combined with a POS parser) for extracting the information I need. I may end up not using Prolog (because it's hard to convince others to give it a try), but, essentially, the solution will be very much like Prolog, in the sense that it will do something similar to unification and nothing like NN.
You're welcome! Prolog Under the Hood is the article that brought me back to Prolog after being disillusioned with hype that never delivered.
exercism.io
What you are describing in the special case of Prolog (and I mostly agree with you) is very common. You can find examples anywhere: OOP, Java, functional programming, Haskell, "muh better C" like Nim, and so on, and so forth. In happens in several steps. First, we need a hard, ill-defined problem that no one yet understands (even though many will argue with with on that point, because they are convinced _they_ understand it better than you and most other people). Then, we need to collectively, in our minds, _substitute_ the problem with something much easier that we think we understand and are able to solve. Then, we make an informed yet arbitrary decision about how the problem ought to be solved. It is very important that the problem is to be solved through _technology_. Not any solution will do; we are looking for a solution that will be enabled through a technology that we are going to develop with the clear goal of solving the problem. Finally, we need to produce a lot of written word that forcefully explains how this new technology is better than the other technology. There are many ways to do it, but they all involve choosing the examples carefully, not showing how things break, and generally spending unproportionate amount of time on the nice bits. This is how hyped technology works. People buy it because the hard, ill-defined problem usually boils down to "how do we make machines do 'the right thing' (tm)" or "how do we make two or more people make machines do 'the right thing' (tm) at least as fast as one person alone". Those are important questions and any attempt at answering them is worth the effort. "AI" is supposed to somehow be one answer to these questions, and when you then ask "but how do I make an AI" then somehow Prolog _was_ supposed to be the answer. This was recently yet ages ago, since the field is still so young. We have learned to ask the more pragmatic questions like "how do we make it slightly less difficult to write seemingly correct programs", then substituted the question with "how do we write programs in a functional style, with types" and decided that the answer is "Haskell". The rant is over. A warning: some of the textbooks on Prolog are showing their age. For example, I strongly suspect that the style of programming seen in textbooks about "Expert Systems" is a result of the lack of garbage collection for Prolog implementations of the time. This kinda forces you to use the database instead of large data structures. 
Ideally your first predicate (flatten/3) could be seen as using one "input" parameter, one "working list" parameter (supposedly it is the already flattened list) and one "output" parameter. The first rule will deal with the base case where the input list is empty, the second rule will deal with the general case (in which you have a list composed by element H and "rest of the list" T), while the third rule will deal with the base case in which X is a non-list element. The first rule says that if you have no more elements in the input list to flatten, you can output the second parameter (R) which should contain the flattened list. The second rule says that if you have a (non-flat) list on the left (with element H and "rest of the list" T) and a (flat) list A on the right, * first of all you can flatten T and A obtaining X (inductively X is a flat list), * and then you can flatten H and X obtaining the final output R. The third rule says that if on the left you have a non-list element X and a list A, you can easily obtain a flat list joining X and A together. Last rule simply says that if you call flatten/3 passing your input (non flat) list and a empty list (which is flat) and if you obtain output (flat list) R, then flattening (with flatten/2) L you obtain R.
Firstly, the variables in Prolog are constant, you cannot unify W with a list withou X and then unify it with a list with X as a member, so those have to be different variables. So, let’s say you can rewrite your predicates as follows: updatingList(X, W, W) :- member(X, W). That means if X already is member of W, we don’t have to append anything. You almost had it. Second case can be written like this: updatingList(X, W, [X|W]) :- \+ member(X, W). See? If X is not member of W, we want a list, that has X in head and tail is W (the old list). But you’ve clearly proven that you don’t understand prolog at all, maybe try reading some book, tutorials again. Otherwise you will have problems to implement anything more complex.
Thanksss!!
&gt; I have a function You don't, you also don't 'call' anything, thinking about things in these terms is likely inhibiting your understanding.
A make utility. With backtracking you might be able to skip configuration scripts. Place all fallbacks in user or library code instead of generated code. Might be fun to experiment with.
&gt; I had a little article about it on the Google+ Prolog group, but Google seems to have terminated g+ It may still be possible to [download an archive of your posts](https://support.google.com/plus/answer/1045788?hl=en-GB).
&gt;My issue is, that if it is not a member, I need to add it as a member, so how does that work? I think this is the main issue you are having. You don't add elements to a list, instead you define a new list that has all the elements of the list you passed in plus the new thing. So you'd have: updated_list(X, List, UpdatedList) :- \+member(X, List), append([X], List, UpdatedList). updated_list(X, List, UpdatedList) :- member(X, List), UpdatedList=List.
The thing with Prolog is that everything is immutable. You can't add to a list. You can't even change a variable once it's been set. Consider this example: X = [A, B]. Now the variable `X` is set or "bound" to a list containing two things, `A` and `B`. We can't change `X`; it is always a list with two things. BUT both `A` and `B` are unbound variables. Essentially, we've said that `X` is a list of two things, but we haven't said what those two things are. We could instead say something like this: X = [A, B], A = 1, B = 2. The first line again tells us that `X` is a list of two things, and the next two lines tell us that the first thing is `1` and the second thing is `2`. This doesn't answer your question, but hopefully it fills in some holes in your understanding.
As a general programming language it's quite nice: Unification on the head clause is, bar none, the best multi-dispatch mechanism. Data structures are just expressions. There is no constructor abstraction. Immutability. Success/failure resembles C "if (error) { ... } else.." control flow but it's more concise. Backtracking makes it even more powerful and provides an exception-like rewind for normal control flow. Have you ever wanted to use exceptions to backtrack a parser, for example, but knew it was immoral. It's easy to reason about relations. It's easy to reason about logic and constraints. You can write relations as if you were expecting backtracking to solve them in exponential time, and if there is a solution with better big O, you can implement it that way with the same structure in user code. e.g. cplfd. Libary code such as clpfd manages to implement a very natural DSL and yet not fuck up other programs. This is typical. The NLP/AI aptitude, while useless for NLP and very limited for AI, basically means that prolog is simply the best language for embedded DSLs.
I think that's why there's `call` predicate, right? Recently there was an article posted to this subredit where the author was making a very good argument about procedural approach to explaining how something works, and how it helps understanding. And... let's be honest, you do call things in Prolog, and you get results from those calls, and it makes sense to talk about the order in which calls are made etc.
The second `updated_list` could have been written: updated_list(X, List, List) :- member(X, List).
So true, a more experienced Prolog programmer would have written it that way. Just to explain why I wrote it the way I did, since OP was trying to mutate data structures I assume they are coming from an imperative background so I wrote my code in an imperative style.
(AI) Winter is not coming. :)
As I understand it, ~ means not and &lt;--&gt; means if and only if, right? I wouldn't say "X is not provable if and only if X is true".
Prolog queries return "Yes" when-so-ever an expression is provable on the basis of the Facts and Rules in its database and returns "No" otherwise. In other words a queried expression is only true if it is provable. So if we can find some way to encode the above logic expression in Prolog, then Prolog should return: "No". I don't know how to encode the above logic expression in Prolog.
I see, so you were saying `~(Provable(x) &lt;--&gt; True(x))`. I'll think about it, but I think the answer is that this statement isn't true in constructivist logic (since it requires proof by contradiction) and therefore isn't true in Prolog either.
Great, now how do we encode that in Prolog so that Prolog can tell us itself?
I would definitely agree that it is not true. Now I need to know how to encode it in Prolog so that Prolog itself can confirm what we both agree on.
Welcome! Here are some of my favorite starter resources for Prolog: * [Adventure in Prolog](http://www.amzi.com/AdventureInProlog/a1start.php) by Dennis Merritt is a whole tutorial series to teach you prolog while building a text adventure game. It's also recently been published as a book you can purchase on Amazon. (Side note: the series is written with the AMZI Prolog interpreter in mind. To run the code on SWI-Prolog you may occasionally need to add `:- discontiguous(my_predicate).` directives to the code. The SWI-Prolog interpreter will inform you about when and where you need to do this at runtime.) * [Jolly Roger](https://github.com/gkallergis/Jolly-Roger/blob/master/Jolly-Roger.pro) "A simple, natural language based, pirate adventure game in Prolog." I found playing this game and then reading the source code to be fun and informative. * [The Playing with Prolog Youtube Channel](https://www.youtube.com/channel/UCfWpIHmy5MEx2p9c_GJrE_g) has a lot of videos going through various trendy projects you can do with Prolog such as building an Alexa skill, making a 3D animation, providing a Prolog-based service to node-red, many videos on prolog-based web services, and the channel has interviews and instructional videos as well. * [The SWISH directory of example programs using the SWISH interface](https://swish.swi-prolog.org/example/examples.swinb) is invaluable to learn and read simplified examples of popular applications of Prolog from beginner to advanced levels. For learning Prolog concepts I recommend: * [Prolog Under the Hood: an Honest Look](http://www.amzi.com/articles/prolog_under_the_hood.htm) an essay by the same writer as the Adventure in Prolog series above. When I was first introduced to Prolog (admittedly not from the book you read which I heard is very popular) I found a lot of noise promising things in Prolog that I could not get to work in practice. (There was a bit of an exuberant hype cycle in the 80s for anything related to AI.) The author wrote this article in response to that and it helped me understand a lot better Prolog's underlying execution mechanisms. * [The Power of Prolog website](https://www.metalevel.at/prolog) run by Markus Triska has given me the clearest and most succinct understandings of pure and declarative Prolog concepts. The author has also written example applications related to web servers, bitcoin addresses, cryptography, business apps, and other things off the top of my head. And I may be burying the lede here but he also runs the [Power of Prolog Youtube Channel](https://www.youtube.com/channel/UCFFeNyzCEQDS4KCecugmotg) which quite honestly I just listen to the videos on repeat over and over and over because they're so informative and clear. This is most of the best stuff that took me a while to find but has been hugely influential to my programming in Prolog.
What are you favorite resources for the next steps ?
After all these then I would start to focus on more and more pure/declarative prolog by using things like constraint solvers. At some point you should learn DCGs for parsing as well.
thanks
I strongly disagree with the suggestions in the other comment, sorry, u/living_the_Pi_life :-( If your goal is to bring yourself up to speed and start writing useful programs, the only book I can recommend in good faith is "The Art of Prolog". It doesn't have any obvious deficiencies, apart from being a bit outdated (more on that later). I have read some of the recommendations and tried to suffer through others, but in short: "Adventure in Prolog" is very outdated. It is written for a Prolog that doesn't have garbage collection. It uses predicates that are non-standard and only available for Amzi Prolog. It will teach you stuff but I don't know if you want to know it. "The Power of Prolog" is too terse, a bit preachy, and skips over many truths about Prolog that the author dislikes. At the end of it, you still don't know how to do pragmatic stuff, and feel stupid for not "getting it". I know the attitude comes with the territory but man does it bugger me.... ;-) You need at least an year of Prolog experience before "The Power of Prolog" is truly useful; at that point, go ahead and read it, you will definitely learn a lot. One way or another, Prolog suffers from MID (Miltiple Implementations Disease). For a start, stick to one Prolog and just keep reading its documentation. From what I have seen, SWI-Prolog has the most accessible online documentation of the open source implementations. Start reading the library code as soon as you can, you will learn a lot from it. SWISH (recommended by u/living_the_Pi_life as well) is definitely a great resource as well. Other Prologs have a lot going on for them, based on the use case, but the documentation is not nearly as beginner-friendly. And a word of warning: there is a lot of very strong and incompatible opinions about what "Prolog programming" is or ought to be. None is "wrong" as such, they just start from completely different premises. It is the exact opposite of Python, which is (or at least was, until a couple of years back) a language with well-defined goals and "one obvious way to do it." So be patient and use your judgment. Good luck on the journey! Learning Prolog made me a better programmer in general; if this is what you want out of it, you won't regret it. It is also fun to write, but then again, most languages, outside of Java, are fun to write.
Just don't do the "Adventure in Prolog". The only thing I learned was how to not write useful Prolog programs and still keep my sanity.
I'd say: not really. I mean, it's certainly possible, but here are few tings that would not work to your advantage: 1. Arrays. Languages like Go and Python have a very straight-forward way of working with arrays (well, technically, vectors). Also, they work with them (lists in Python, slices in Go) in such a way that you can replace elements in them, add more elements, remove etc. All of this is possible in Prolog, but it's not on the surface / you'd have to figure out some way of doing it. 2. Prolog is good at answering questions. Game of life doesn't really pose any questions, it just sits there and generates new map every iteration... I mean, if you had a question to ask about its properties, like, "will it ever fill up more than 50% of its cells?" or "will it form a perfect rectangle 4x4 big?", then, Prolog might have offered an interesting way to solve this problem, but if you just want to generate an image of GoL iterating through its permutations, then it just won't teach you much of useful stuff about Prolog.
Asked on StackOverflow [here](https://stackoverflow.com/questions/55700015/instantiation-issue-when-solving-this-prolog-caliban-problem). You'll probably get an answer there, although people won't be motivated to help unless you put in some effort yourself. The code you found isn't great, even aside from the fact that it doesn't work.
My advice- learn how to use trace/0. You will be able to step through each line and see the exact point where you have not instantiated sufficiently. You will become better at prolog as a consequence. Try to understand rather than ask other people what the “answer” is.
Works for me: ``` ?- [user]. |: within(A,B,W,H) :- ( A =&lt; W,B =&lt; H -&gt; write('coordinates are within rectangle') ; write('coordinates are not within rectangle') ). |: ^D% user://1 compiled 0.01 sec, 1 clauses true. ?- within(1,2,3,4). coordinates are within rectangle true. ?- within(4,3,2,1). coordinates are not within rectangle true. ```
Wow, I'm using SWI-Prolog and it gives me that error, tried an online compiler as well and still gave me the error. Thanks for responding
I can only imagine that you forgot a parenthesis or something when you were trying it. I copied exactly what you had and it worked for me.
I think so, just put a list of clauses as the second argument in term_expansion/2.
thank you very much, that's what I was looking for
I would also add: https://www.amazon.co.uk/Clause-Effect-Programming-Working-Programmer/dp/3540629718 very practical to get you started or https://book.simply-logical.space/about.html if you want to do AI but is less immediately practical.
Here’s an answer by way of a question. How do you expect the environment to know what add/3 does?
You’ve done everything right except compile the program. :))
Wouldn't the easiest way be just do this: triple([0,0,1],[0,0,1]). triple([0,1,0],[0,1,0]). triple([0,1,1],[0,1,1]). triple([1,0,0],[1,0,0]). triple([1,0,1],[1,0,1]). triple([1,1,0],[1,1,0]). ?
Good suggestion. It remains a mystery why two arguments are needed. Since even the simplest exercises confuse OP, this might remain a mystery forever.
The other post explicitly enumerating the possibilities is the right way to go. But you don't need two arguments. In Prolog, a predicate is kinda like an assertion: it asserts that something is true of its arguments. If that something _could_ be true but isn't necessarily true, the variables in it's arguments are further restricted to ensure that it is true going forwards. (This is the case for idiomatic Prolog, but it is possible to fudge the analogy.) So just create a predicate for valid values: triple([0,0,1]). triple([0,1,0]). triple([1,0,0]). triple([0,1,1]). triple([1,0,1]). triple([1,1,0]). The only functional difference between this version and your example is that your version allows `R` to not be fully instantiated after the call to triple. But unless you do something fancy to ensure that `R` can only contain zeros and ones in the future, you could run into unfavorable results, e.g.: ?- triple([1,_,0], R), R = [1,2,0]. R = [1, 2, 0].
What we are dealing with here is a typical case of an "instructor" who doesn't know better, coupled with a student that is too confused to understand the incoherent ramblings of the instructor. I used to have a hobby of getting to the bottom of such questions, over on Stackoverflow. Man was that a waste of my life. The only thing I got out of it was positive reinforcement of my cynicism, like I ever needed it....
What do you mean by “check it’s arguments”?
Sorry I didn't mean arguments but rather what's inside the parantheses
I don't fully understand what you're asking, but it seems like you want to create a higher order predicate, or "metapredicate." Basically you can use `call/3` to do something like this: g1(1,2). g1(2,2). g2(1,2). g2(2,2). test(F, X, Y) :- call(F, X, Y). ?- test(g1, X, Y). X = 1, Y = 2 ; X = Y, Y = 2. ?- test(g2, X, Y). X = 1, Y = 2 ; X = Y, Y = 2.
If you wrote down code that I can copy-paste and compile; then showed how you are going to run this code and what results you expect -- well, at this point it becomes a joy to try and help. At the moment I have to look at meaningless, syntactically wrong code (won't compile) and I have to use my crystal ball to try and pierce through the mists and find out what you might fancy. Not easy to help at all.
yes this is what I was looking for, sorry for asking such a confusing question. Thank you.
Why not just query g? Just type g(X,Y). On the query line. You get the first answer then type “;” (without quotes) to get the next answer. That’s the basis on which prolog works.
This is what you were looking for, but is it what you really wanted? Or needed? Difficult to know.
Instead of deleting the file could you open the file using write mode instead of append? Write mode will replace the contents of the file.
Great, it worked! Thanks for the suggestion!
What operating system are you on? What are your user permissions and what are the file's permissions? Also, note that the message might be misleading, I believe that on Windows, there's no way to tell the difference between the case when you don't have permission to delete a file and when an application is holding a lock on a file. (If you are on Windows, I'd check if the file is open in another application, if you are on Linux, you could do `lslocks | grep facts.pl` to try to figure out who might be potentially holding the lock on your file.)
Added automatic installation of packs in the SWI-prolog nix derviation. Now everything can be installed automatically in a reproducible manner from a single configuration. https://github.com/Atidot/PrologNixDocker/blob/0a5b5745dd879ecb483fb8942bb0e07e25e05fd7/swipl.nix#L3 https://github.com/Atidot/PrologNixDocker/blob/0a5b5745dd879ecb483fb8942bb0e07e25e05fd7/docker.nix#L7
What kind of school are you going to? Is this higher education? Like, "college" in the US? University? Is it in Europe or maybe Australia? The reason I am asking, of all the different exam styles I have been subjected to, this kind of "mechanical" evaluation is by far the worse..... :-( Have you tried evaluating this code, either manually (with a pencil on a piece of paper) or using a computer and tracing? If you did that, you will be much better prepared to answer exam questions than if I just wrote some random shit here. Here is how I would approach it (taking the first example). Using a bit more extended [terminology](http://www.swi-prolog.org/pldoc/man?section=glossary), and re-formatting a bit to follow modern conventions. What we have is a _predicate_ with a _functor_ `fun/2` (so, the name is `fun` and the _arity_ is 2). It has two _clauses_. The first clause has only a _head_, which makes it a _fact_: fun(2, 2). The second clause has a head and a _body_. The second clause is defined recursively. Note that this is not _tail-recursive_. fun(N, F) :- N &gt; 0, N1 is N - 1, fun(N1, F1), F is N * F1. Your query is `?- fun(2, 2).` Again, this is fucked up slightly, because the "extra spaces added to facilitate reading" make it syntactically incorrect, but well. Anyway, this predicate takes two arguments (this is why the arity is 2). The predicate clauses will be matched from top to bottom, so first, there will be an attempt to match it to `fun(1, 2).` Since the first argument in your query is 2, and 1 does not _unify_ with 2, it will _fail_ and _backtrack_ to the second clause. The second clause has _variables_ in the head, and variable always unify. After the unification of the two arguments, `N = 2` and `F = 2`. Now you go into the body of the second clause. The first sub-goal is `N &gt; 0`, and `N = 2`, so this will be evaluated as `2 &gt; 0`, which will succeed. You proceed to the next subgoal. The next subgoal is `N1 is N - 1`. `N1` is a fresh variable, so when `is/2` is evaluated, the _arithmetic expression_ `N - 1` is evaluated as `2 - 1`, and the resulting 1 is unified with `N1`. Now `N1 = 1`. The next subgoal is `fun(N1, F1)`. Here, `N1 = 1` (from the previous step) and `F1` is a fresh variable. So now you enter a new frame and have to start from the beginning. Now the first clause is again considered, with the first argument 1 and the second argument a free variable. 1 unifies with 1, and the free variable always unifies, in this case with 2. It will now succeed and you pop out of the recursive call with `F1 = 2`. And so on. If you are paying money for your education, you are being scammed.
Well, the easy way is to recognise it as a fibonacci variant with multiplication. Otherwise... You just write it out. Just substitute in new unique variable names so you don't confuse yourself. fun(4, X) :- 4&gt;0, 3 is 4 - 1, fun(3, A1), X is 4 * A1. Now, we need to know fun(3, A1)... fun(3, A1) :- 3&gt;0, 2 is 3-1, fun(2, A2), A1 is 3*A2. etc. fun(2, A2) :- 2&gt;0, 1 is 2-1, fun(1, A3), A2 is 2*A3. fun(1, 2), so we work out the missing variables above: fun(2, A2) :- 2&gt;0, 1 is 2-1, fun(1, 2), A2 is 2*2. fun(2, 4) :- 2&gt;0, 1 is 2-1, fun(1, 2), 4 is 2*2. fun(3, 12) :- 3&gt;0, 2 is 3-1, fun(2, 4), 12 is 3*4. fun(4, 48) :- 4&gt;0, 3 is 4 - 1, fun(3, 12), 48 is 4 * 12. X=48.
Thanks for the detailed explanation. And yes it's a university in the U.S. The professor is known for throwing trick questions at us that is not industry standard but still work. I keep getting confused because some questions on the exam that are technically right, are really the wrong way of doing it. But again thanks!
Thanks for the tip. I think I did get confused using the same variable.
One thing that is not about "technically right". This: ?- fun (2, 2). is not and will never be correct. It is just wrong Prolog syntax.
The Practice of Prolog The Craft of Prolog
From memory you have to define the higher order predicate as a meta predicate in the module it is defined. This allows you to use other modeled predicates. You might also need to prefix the module name when calling e.g.: higher_order(module_name:callee, ...) I've done it swi-prolog and here are the relevant docs. http://www.swi-prolog.org/pldoc/doc_for?object=(meta_predicate)/1 I'm on my phone otherwise would give an example, but that is a good place to start.
Before reading more books, you should really try to write some none-trivial programs. Just program in Prolog for a while. In order to do that properly, you'd have to also read the documentation of the Prolog you are using, which itself is a lot of written material and it's all useful/necessary information. Once you have enough practical experience: - The Craft of Prolog - The Power of Prolog And absolutely go ahead and read the library code of your Prolog.
Thanks a lot! It actually works when using: :- meta_predicate bar(1, ?). at the beginning of higher_order_utility.pl
Thank you for the suggestions. What would you suggest as an introductory Prolog book on the same level as 'The Art of Prolog'? I feel like I would greatly benefit from reading something else at approximately the same level as 'The Art of Prolog'.
Depending on your background, [The Art of Prolog](https://www.amazon.com/Art-Prolog-Second-Programming-Techniques/dp/0262691639) by Leon Sterling and Ehud Shapiro might be a good choice. It is freely available as a PDF under open access by the publisher (MIT Press).
You might also want to mention that the book is freely available as a PDF from the publisher (MIT Press).
I really think that "The Art of Prolog" plus the documentation of the Prolog of your choice is more than enough to start writing programs. Really, read the standard library of your Prolog (the part implemented in Prolog, of course). Like, go ahead and see how `append/3` is implemented, or how `nth1/3` is implemented, and so on. "The Power of Prolog" attempts to be a book for beginners, so go ahead and read it. But really, try to write useful non-trivial programs along with reading.
:-) I have been mentioning it so many times here on this subreddit that I annoy myself by now.
I am afraid that's the only way to go, _unless_ you want to do compile-time term/goal expansion (which is somewhat similar to Lisp macros). Another option is to pass the name of the predicate and use `call/N+1` inside your meta-predicate. For some use cases it might be good enough but it is not exactly the same.
Not sure... did you try giving the fully-qualified name of `foo` to `bar`? I.e. `utility:foo` instead of `foo`?
The solution is to declare the edcg:pred_info as a multi_file predicate: :- multi_file edcg:pred_info.
Yeah you need to probably read the documentation? And don't use SWI-Prolog from the command line on Windows, either get a Mac or use Linux or use the GUI on Windows.
You need to set the path to the bin directory of swi-prolog to run swipl directly from the command line, or use the full path to the exe.
If u dont mind can you specify how one would go about doing this?
Cd "pathdirectorytoexe?"
assuming that your swi-prolog is installed in the same place as mine then using a cmd prompt you can run: &amp;#x200B; C:\\Progra\~1\\swipl\\bin\\swipl &amp;#x200B; or using powershell run: &amp;#x200B; &amp; "C:\\Program Files\\swipl\\bin\\swipl.exe" &amp;#x200B; There are plenty of google posts about how to add a directory to the path in windows which do a better job of describing the task than I could. The directory you need to add is C:\\Program Files\\swipl\\bin &amp;#x200B; good luck!
Does the GUI do everything the command line swipl does?
Between the GUI and the built-in Prolog source code editor, you don't need anything else for most use cases.
thank you it worked!
I think this is a case where the `-&gt;/2` operator is useful: is_leap(Year) :- 0 is Year mod 100 -&gt; 0 is Year mod 400; 0 is Year mod 4.
A gui that does less? My phone has 8 CPUs? time((concurrent(2,[perfect_range(1,10000),perfect_range(10001,20000)],[]), fail; true)).
Why don't you start by describing your input values, your desired result, and the algorithm you are planning to use. This will provide context for the question "how do I prove three statements with an or" which now just hangs in the air.
There is this great guide to writing a text adventure in Prolog. Because of its different presentation focus, it was what finally made prolog 'click' in my mind.
[Adventure in Prolog](https://www.amzi.com/AdventureInProlog/a1start.php)?
Yes, that one! (apologies for not posting a link myself right away; I was on mobile).
Another possibility, and maybe easier for a beginner, is to have two clauses: is_leap(Year) :- 0 is Year mod 100, ... . is_leap(Year) :- R is Year mod 100, R =\= 0, ... . At most one clause can be true; if the first clause makes it past that first predicate, then the second clause would fail; if the second clause makes it past the first two predicates, then the first clause couldn't have succeeded. `-&gt;` is almost certainly more efficient at runtime, but I think the multi-clause approach helps you start to think in a Prolog-y way.
&gt; Do you have any ideas? Yes
Unfortunatelly I really don't know where to start.
Algorithm before code. Desired behaviour before algorithm. Use cases before desired behaviour. You've probably done the work already but if you want help you should share it. It makes it easier to help.
I edited my answer with the code I did.
Do what I did. Ignore the professor. Read the textbook at the back of the class. They often cover material far too slowly and simply, or they are just bad teachers.
You need to make a predicate, sselect(Item, List, ListWithItem). List is sorted. ListWithItem is sorted. ListWithItem is List with Item put in it. So basically, translate that from English to Prolog: sselect(Item, List, ListWithItem) :- sorted(List), sorted(ListWithItem), addItemToList(Item, List, ListWithItem). This won't work, but it gives you an idea of where to start.
we have no textbook assigned it's his lecture notes and they're very confusing
thank you i appreciate the help
There's a lot of material available on the Internet. Prolog appears in every programming languages course. https://staff.fnwi.uva.nl/u.endriss/teaching/pss/prolog.pdf
I am willing to help you with this. Is it OK if the help is public (here on this thread) or is that going to get you in trouble with your professor if they find out that you got too much help online? Then, please consider carefully what are the actual constraints for this assignment. The "signature" of the predicate you are supposed to implement: sselect(?Item, ?List, ?ListWithItem). suggests that the predicate can be called as: ?- sselect(X, L0, L). but the "four modes" that are demonstrated by example tell me that at least one of the two lists (second and third argument) *must be ground* when you call the predicate. What should happen when you call it as shown above? Next question: are the elements integers, natural numbers (0, 1, 2, ...), ground terms, or just terms? This is important for the ordering. Can you have duplicates in any of the two lists? What should happen if you call it like this: ?- sselect(Item, [1,1], [1,1,1]). One more question: are you allowed to or supposed to use predicates like `ground/1`, `sort/2`, and such? Does it need to throw errors if you don't use it in one of the four modes, or can you just ignore such cases?
This sounds like a good suggestion but I am not sure it is what the professor expects. I strongly suspect that the expectation is that this is a pimped up version of the [textbook `select/3`](https://github.com/SWI-Prolog/swipl-devel/blob/0d95d378c5bf7e71d3c6bec3ef67af7eccc08bfd/library/lists.pl#L153-L164) which additionally checks that `List` and `ListWithItem` are sorted lists without duplicates in the spirit of [library(ordsets)](https://github.com/SWI-Prolog/swipl-devel/blob/0d95d378c5bf7e71d3c6bec3ef67af7eccc08bfd/library/ordsets.pl).
\`I may actually get in trouble, also since it is not specified I'd assume duplicates are allowed in a sort list. As we wrote a previous function that checks if a list is non descending list, which allowed duplicates. We can use any default predicates or from library clpfd. Do you have a discord account? or can you create one, it's an online app that you can access through your browser and it is really good for chatting. Or you can pm on Reddit?
I have played this game before. The deal is, you are paying for your education. It is not OK (with me) that I'd be giving you _free_ education in private. In public it is fine, since others can benefit from it as well. Good luck.
Its okay. Its your point is valid. And thanks!
Can you show how you run the code?
What do you mean? &amp;#x200B; Also, I updated my code a bit so that it looks like the following: perfect(tip, 0). perfect(bin(X,\_,Y), N) :- ((X=tip,Y=tip);(X\\=tip,Y\\=tip)),perfect(X,N1), perfect(Y,N1), N is N1+1. &amp;#x200B; However, I still don't know if this is the correct implementation of a perfect binary tree in prolog.
Your correction does not look good at all. Your original version looks much better. I mean, can you show how you query the predicate `perfect`? How do you call it?
I added the correction as a check to make sure that each node has either 0 or 2 children, but you're right it may not be the best way to do so. It got rid of the "out of local stack" error, however. But I still don't think my code is correct. Here are a few tests I ran with it which seem to be correct: &amp;#x200B; 2 ?- perfect(tip,0). true. 3 ?- perfect(bin(tip,X,tip),1). true . 4 ?- perfect(bin(tip,X,tip),N). N = 1 .
The original code enters an infinite loop however if I run the following test: 7 ?- perfect(T,0). T = tip ; ERROR: Out of local stack
Yes. You get the correct answer, and then on backtracking, you generate a "perfect" tree of depth 1, but then you evaluate `0 is 0 + 1` (from the last subgoal of the second clause) and this fails; then you generate a perfect tree of depth 2, and `0 is 0 + 1 + 1` fails, and so on. Eventually you get the "out of local stack" error.
But I think there should be a way to write the predicate without this error. For example, it should simply return the following: perfect(T,0). T = tip; false Unfortunately, even though it returns the right answer, the error causes it to fail when I run my professor's test case file.
Can you show what your professor's test case file looks like? It would also be nice to know how you are expected to solve this kind of problem. Have you been using predicates like `var/1` or maybe a library like `CLP(FD)`?
I _think_ one way to do it would be to use a predicate like `succ/2` that can count down safely: perfect(tip, 0). perfect(bin(L, _, R), N) :- succ(N0, N), perfect(L, N0), perfect(R, N0). But please run this against your test file!
What would this predicate do? Like how would it be implemented/what would it consist of?
Sorry, what do you mean? `succ/2` is a built-in, you don't need to define it.
We are using library(clpfd)! The four test cases mine does not work for are the following: 1. perfect(T, 0). 2. perfect(T, 1), T \=@= bin(tip,_,tip). 3. findnsols(5, T-N, perfect(T, N), Sols),length(Sols, N). % should be 5 solutions 4. findnsols(5, L-X-R-H, perfect(bin(L,X,R), H), Sols), length(Sols, N), exclude(check_perfect, Sols, Bad). % should also have 5 solutions All give the same "out of local stack" error.
Just tried this and it unfortunately still gives the same error :(
I have to get going now. I suspect you can use library(clpfd) to solve this. The other option is to have two separate cases: on for testing a tree, and one for generating a tree of increasing depth. You can use `var/1` to detect if the second argument (the depth) is a free variable, or `N &gt;= 0` to see if it is a non-negative integer.
Try following the failure slicing technique from https://www.metalevel.at/prolog/nontermination. The idea is it put a `false` after each clause one by one until you find exactly which call causes the non termination.
Your definition of the predicate is tempting, but considering the huge number of backtracking this will do if the tree isn't actually "perfect"... I'd not do it like this. Instead, I'd do it in two steps: 1. Find all leaf nodes (tip nodes as you call them). 2. Calculate depth for every one of those, until it is equal (and fail, when it's not). The above may do more work in the case the tree is in fact "perfect", but will do a lot less work in the case it's not. PS. You can calculate the depth as you traverse the tree in order to find the nodes, something along the lines of: leafs(tip, DepthSoFar, [ActualDepths]) :- ActualDepth is DepthSoFar + 1. leafs(bin(X, _, Y), DepthSoFar, ActualDepth) :- NextDepth is DepthSoFar + 1, leafs(X, NextDepth, XDepths), leafs(Y, NextDepth, YDepths), append([XDepths, YDepths], ActualDepths). % and then all_equal([]). all_equal([_]). all_equal([X, Y | Xs]) :- X is Y, all_equal(Xs). This was typed straight into the browser, so might contain various errors, but the idea should be obvious.
Well, if you want to keep track of the places you visited, then you'll have to keep the state of your algorithm somehow. One way to do this would be to represent your database as, say a list (this is just to make an example easier, you'd probably want a more performant datatastructure, a tree or a hash-table, whatever's available in your Prolog). Next, you would pass this datastructure along with the query, where, at each step of computing the answer to the query, you'd remove an arc from your database, eg. find_in_db(Db, Constraint, Found, NewDb) :- findall(X, (member(X, Db), call(Constraint, X)), Y), member(Found, Y), append([Prefix, Y, Suffix], Db), append([Prefix, Suffix], NewDb). Which you'd call something like: find_in_db([connection(london, paris, 250), ...], connected(madrid), Found, NewDb). With `connected` defined something like this: connected(City, connection(X, Y, Distance)) :- X = City ; Y = City. This is just a rough outline of how I'd approach the problem, not a concrete solution.
Thanks for your input, but I'm trying to find a simpler solution because this is a task from my AI class where we barely scratched the surface in Prolog.
I found a solution online but I'm struggling to understand it, specifically the part with reverse. edge(3,5,2). edge(4,5,1). connected(X,Y,L) :- edge(X,Y,L) ; edge(Y,X,L). path(A,B,Path,Len) :- travel(A,B,[A],Q,Len), reverse(Q,Path). travel(A,B,P,[B|P],L) :- connected(A,B,L). travel(A,B,Visited,Path,L) :- connected(A,C,D), C \== B, \+member(C,Visited), travel(C,B,[C|Visited],Path,L1), L is D+L1.
This is a similar approach, but instead of removing found eges, it checks for the existence of a possibly visited edge in `Visited`. Each one is a valid approach, one would be preferable if a chance of trying the same edge are small, while paths are generally short, while the first approach would be preferable where paths might be quite long and the chance of trying the same path are high. As to your question about `reverse` -- you don't really need it (unless your question was actually different, and you want to know both the path and its length). But, the solution you posted needs to use reverse because of how it generates `Q` list, which is created in such a way that edges are collected in the order `B` to `A`, while you probably want them in order `A` to `B`.
You probably need quotes around the filename (single quotes)
Oh, thank you.
The text of the tweet: &gt; SWI-Prolog Hack Day! Sunday, May 12. &gt; &gt; Whenever is 'May 12' for you, we're going to give [@ShonFeder](https://twitter.com/ShonFeder)'s [`pack(tokenize)`](https://github.com/shonfeder/tokenize) the love! &gt; &gt; Organizing will take place on ##prolog on [freenode.net](http://freenode.net ) IRC. Ping Shon to participate (or just show up). Beginners most welcome! It will be a low-key collaboration to build out a more fully featured lexing library on top of the meager (but effective) foundations of the library I published several years ago.
Sounds cool
It’s probably because of stream buffering. Printing a newline causes the stream to flush. This isn’t a prolog specific thing, in fact.
You are right, using `flush_output/1` solves the issue
Fun fact: stdout is buffered; stderr is not.
Not sure I understood your question. But `(X,benfica,Y,3,0).` is exactly what you would type at prolog prompt to get the answer (X &amp; Y pair).
You need to learn to write better, this is almost incomprehensable. Like, I get the words, but the sentences don't make any sense. You probably know what you are talking about but you also have to tell others, it's not enough to just dump your inner monologue.
Break the problem down; solve each sub-problem- the scope is waaaaay too large.
Exactly! It is just too large. Is there a source I can get some help from to atleast start off with the assignment?
jeez, stop the downvotes this wasn't that bad of a question. learn about PATH environment variable on both Windows and Linux
There’s a small handful of good sites that give general help with DCGs or constraint programming but don’t expect easy answers. The challenge that you have been set just seems too tough for a beginner. Just solve one of the problems and try to enjoy the learning process.
As for the command language parser, there’s something similar here: http://www.amzi.com/manuals/amzi/pro/ref_dcg.htm
Which Prolog had lambdas?
DCGs are not covered in books I've seen, they are on a couple of websites. As for usefulness, I would rate DCGs near the top of the list.
Why is that? Superficially, they seem only useful for parsing. Please elaborate.
LambdaProlog. I woul not reccomend it; og Prolog is much better I think.
Swi-prolog has a lambda library which is quite popular.
A short elaboration... DCGs are usually portrayed as a parsing tool, but essentially they convert a list to another form, or verify a list is in a certain form. This behaviour is reversible, so a DCG that parses could also write to the same form. Because you can do operations on any list there are handy for many programming tasks.
That's rather interesting! Would you happen to have a link for further reading?
Did not know that!! Thanks! :-)
Markus Triska's website is particularly good, but rather heavy reading. Worth taking the time to understand it though. https://www.metalevel.at/prolog/dcg
You’ve pitched this at a really good level- easy to follow but informative.
How did it go? I've rolled my own tokeniser with some features that make it easy to reconstruct the exact point of failure in the original input by keeping track of line and character position with each token. However, it looks less fully featured. I might take a crack at integrating the functionality optionally.
I tried constructive criticism once and failed miserably. I will allow myself the freedom to say, all of this is just.... pointless? Like, why? I don't mean, "why" as in "why did you do it" (I can guess why you did it), but more like, "OMG who cares?"
It went well! 3 or 4 people chipped in, and we got the core of a couple features implemented. I need to set aside some time to finalize the work and cut a new version for the package repo. Location-awareness came up as an important feature missing from tokenizer: https://github.com/shonfeder/tokenize/issues/35
I don't know much about Prolog but if it is just about understanding code and the way the interpreter calculates the expression through unification then I can help you. I, however, don't know what "analysis rule" is.
Me neither. I thought it was a definition. However in order to explain it the teacher says that it is the way the results occur
So you want someone to do the homework for you? Like, instead of you reading your material and doing it yourself? So that you can, like, cheat? And so on, until one day you have a diploma in some "IT"-related major, and you start looking for jobs, and someone hires you, and it turns out you cannot be bothered to read shit and do your work yourself? It saddens me greatly, this kind of shit. You are wasting your life if this is your "plan".
Instead of just criticizing just think that somebody may just need a little push to understand a new logic. Even if I get this exercise solved I will not get better at it if I dont study it. Im sorry for you. What you supposed to do. Surfing on forums to critisize people. Think for a while you dumbhead. Υou should be ashamed.
I figured it out how to solve it. I had to unterstand the way the interpreter calculates the expression. A co-student helped me to figure it out. Thank you very much...
I think when in your program you declare colour(red) it is a fact and it is always true. But when you evaluate color(green) it is a predicate can be false or true
So if I get get it, the predicate is only the fact's "title"?
Predicate is any expression which returns Bool, you need to evaluate it to know result. Any predicate which is true is a fact. So your color(red) is both a predicate and fact
OK I got it. Thank you very much... :D
I am so ashamed. You really put me in my place.
you can activate trace in the interpreter (`trace.`) and see for yourself how certain input is calculated. You just need to find the used unificators yourself but that's not hard.
same, yielding ?- jogo(X,benfica,Y,3,0). X = 1, Y = v_guimaraes.
- &lt;prolog-question-on-topic-t&gt; - http://www.metalevel.at/prolog/&lt;topic-t&gt;
being a forgotten gem
It’s nice to see this formalised. I have done this many times myself (translate from, to and between XML schemas. Prolog is perfectly suited and enjoyable to work with. I’d like to develop or discover a way to automate the process of translating between schemas.
The paper looks great. The English is a bit dodgy but they can be forgiven for that. I’d offer to do a final translation for them.
Here is the link to a glossary of terms: https://www.swi-prolog.org/pldoc/man?section=glossary You can look up "fact", "predicate", "head", "body" and so on. I find this glossary of terms quite useful.
Have they made their implementation available?
Thank you very much
bite me
An Alexa app is fun one I did before: https://www.youtube.com/watch?v=ScrEe1vsPug&amp;t=1s
There is a tutorial to create a basic text adventure out there something. Creating your own text adventure with some extra commands and puzzles seems like a project that would fit in the scope and complexity of a weekend.
Maybe write a lexer using Prolog DCGs?
That sounds exactly like my cup of tea! I searched for a while and I found a couple of different tutorials but I can't know if you're referring to any of them. Would you mind linking the one you have in mind?
Do you know this one ? Props to the guy above me in here for triggering memory of it. 😆 http://www.amzi.com/AdventureInProlog/
The difficulty in this case is the [SWI-Prolog-specific C file](https://github.com/SWI-Prolog/packages-ssl/blob/master/crypto4pl.c) that it depends on. You would have to port that to use the SICStus foreign interface, which I don't think is a small task. The original author, Markus Triska, also develops for SICStus so you may be able to get some good advice by contacting him directly. (It looks like he hasn't been active on Reddit for a while.)
Hi, thanks for your replay. I'll try to contact him.
Are you sure you want a high ratio of skill/result? (i.e. too much skill, very insignificant result). I think, people answering your question interpreted you to mean "low ratio". Just for the pun of it, I'd suggest parsing and interpreting some logs (like, say, Apache HTTPD or NGNX), as in Pro-log.
Just use bash to call similar functions from sicstus and get the results as a string.
The concept of "fact" is similar to our normal language-- When I am sitting in a room, for example; I can notice several facts -- the chair I am sitting on, the table in front of me, the color of the walls and so on A collection of these facts can be useful later for making certain logical conclusions and we can try to achieve some goals. Such a collection can even be called a "database" A fact can be nuanced -- that means it can have some more properties. So I could state the chair as chair(wooden, brown, cushioned) So I am putting together all the attributes that I think are needed to describe the chair. Such a fact is called a functor. The goals that we try to achieve with such facts are expressed as predicates. Sometimes the goals are self-evident and always truthful (i.e. the goal is always passed) So I can say isOccupied(cat,chair(wooden,brown,cushioned)). &amp;#x200B; (in the above case, the cat is always found in that specific chair) Now that looks like a fact; but actually it isn't -- it is simply a goal -- which in this lame humorous case -- is always true.
Thank you very much my friend. Thank you for your extremely detailed answer...
I advise you to go back to before the beginning: "Logic for Problem Solving" by Robert Kowalski. Reading this book brought to light the origins of many of Prolog's conventions which later books take as gospel. Also, as mentioned by others, "The Craft of Prolog" by O'Keefe, as well as Ross' "Advanced Prolog".
I’m not sure what the aim is here. Asking if I think they are accurate descriptions seems odd as this is an objective fact not an opinion. Are you really asking- “Do you think that the imperative or NL descriptions will help a newcomer understand the prolog code”? . I.e. you are testing for the pedagogical value here. Anyway, I answered 5/6 of the survey questions. :).
Yes, perhaps the subjective nature of the questions was lost in translation. The questions are used to test pedagogical value of the descriptions. Unfortunately, I think Google Forms doesn't save forms that are not completely filled ;( But still thank you for your input!
You might build an [eliza](https://en.wikipedia.org/wiki/ELIZA) chat program. This is a popular project and particularly direct to implement in Prolog. There is a Javascript version at [http://manifestation.com/neurotoys/eliza.php3/](http://manifestation.com/neurotoys/eliza.php3/).
Cool, but I had trouble finding the source code for your other examples. Could you put the ProscriptLS part on the same page as the example? Also, it would be great to see a side-by-side where you show off your language doing something in a nicer way than Javascript.
Thanks for checking it out. I can put the ProscriptLS code next to the example link on the Examples page. All of the examples can be found in the github repo: [https://github.com/lindseyspratt/proscriptls/tree/master/examples](https://github.com/lindseyspratt/proscriptls/tree/master/examples) I have avoided trying to claim the Prolog (in ProscriptLS) is better than Javascript. I think this is a long discussion and probably not well served by small code snippets. I am trying to provide a service to people that are already interested in Prolog and, like me, sad that they cannot use it in the web. I think that in most cases small code comparisons will appear to favor the language with which the reader is most familiar and therefore will not be persuasive to convince someone to switch from a familiar language to an unfamiliar one. That being said I do think that some code comparisons would be helpful to understand how to get from Javascript to ProscriptLS Prolog.
&gt; I have avoided trying to claim the Prolog (in ProscriptLS) is better than Javascript. I think this is a long discussion and probably not well served by small code snippets. I am trying to provide a service to people that are already interested in Prolog and, like me, sad that they cannot use it in the web. That's fair. In my case I've glanced at Prolog from time to time but never gotten a strong sense of what it has to offer over other languages so I guess I was just hoping to see something that would make it more clear why someone would choose Prolog for the web, purely for my own curiosity's sake. However, I certainly don't have to be your target audience, especially on a subreddit dedicated to Prolog.
Holy schmoly that's nice! :D I've been working a bit in React, on a huge web application, and was beginning to think that I'd like to use Prolog to handle state calculations and stuff This would also make it possible for me to make web-implementation of a parsing-project I've got in my drawer Thanks! -Hope I get the chance to try it out soon (the summer is generally not a time when parents have time to fiddle with stuff :))
I look forward to hearing about your adventures.