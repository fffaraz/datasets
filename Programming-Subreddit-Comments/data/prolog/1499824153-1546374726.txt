I'm sorry(super new), what do you mean by stepping through it?
Trying to do each part of the operation on its own line. Just iterating the whole thing, rather than trying it all at once. Slowly introducing things to the equation overtime so you can fix any mistakes as it builds up. Hope you're enjoying logic programming, good luck!
Link to the actual site: http://eisl.kan-be.com/library/oprolog1.html. Unfortunately, no source code (that I could find).
O-Prolog is not open source. Some documentations about O-Prolog are here. However, the explanation is only in Japanese. I'm sorry. http://qiita.com/sym_num/items/e6e35d3e1bff41f0efe5 http://qiita.com/sym_num/items/b48a92eae86d92a51fe9 http://qiita.com/sym_num/items/4af619de02191c95e3b9 http://qiita.com/sym_num/items/8e5f537bb345f49c1b98 
Indeed, if you try and pass that as Prolog, you deserve to fail at that competition of yours.
Just curious : what are you using it for? I've been making commercial applications in Prolog for 15 years - I'm not looking to change jobs right now, but I'm always interested in what others are making :) 
We rip invoice data out of (millions of) pdf's using a formal grammar approach describing the structure of said invoices. The we stick them in ERP systems. We charge 20p per invoice. 
 % Just a convenience predicate. perfect_number(N) :- % true if LF are the divisors of N proper_positive_divisors(N, LF), % and N is the sum of LF list_sum(LF, N). % L is the list of factors of N, if N is &gt; 0 and f_list(1, N, L). f_list is just a commodity predicate (see below). proper_positive_divisors(N,L):- N &gt; 0, f_list(1, N, L). % The first argument S is a counter. We start with 1. % Basically we just go through every number from 1 to N/2 here and check if they divide N % If S is higher than N/2, then we reached the final point of recursion. We return the empty list. f_list(S,N,L) :- S &gt; (N // 2), !, L=[]. % If S divides N then L, the list of factors is given by the result of f_list(S + 1, N, T) appended to S f_list(S,N,L) :- divides(S,N), !, L=[S|T], S1 is S+1, f_list(S1, N, T). % If that's not the case (S doesn't divide N) we end up here, and just try again incrementing S f_list(S,N,L) :- S1 is S+1, f_list(S1,N,L). divides(D, N) :- 0 is mod(N, D). list_sum([Item], Item). list_sum([Item1,Item2 | Tail], Total) :- list_sum([Item2|Tail], Total1), Total is Total1 + Item1. Let me know if there are some parts you don't understand. If you are happy I'll send you my Paypal username privately
Nice stuff, i know some guy doing something like that using machine learning with tensorflow I think, if you're interested
I am indeed interested!
Neat :) 
Seriously - how come you need to cheat this bad? I not judging (I think) - just curious as to why it is necessary
Triangle(x,y,z) :- connected(x,y), connected(y,z), connected(z,x), x\=y, x\=z, y\=z 
May I suggest an extra argument to `triangle` and `connected` to specify which graph. All `triangle` should need to do with it is pass it on to `connected`. As OP seems to want all possible triangles collected in one list, I'll also mention [bagof](https://en.wikibooks.org/wiki/Prolog/Bagof,_Setof_and_Findall) etc.
The source is located [here](http://www.cse.unt.edu/~tarau/research/2016/prologEngine.zip) in case anyone is interested.
RIP. The Thinker dies but his ideas live on.
;
Yeah, Prolog is weird to get your head around. You have to be careful to not apply your knowledge of procedural programming - with subroutines and return values - to Prolog. It doesn't work that way. It's worth mentioning that your code isn't quite correct. Here's a sample that produces the wrong results: ?- remove_last(b, [a, b, c, b], R). R = [a, b, c] ; R = [a, b, c] ; R = [a, c, b] ; R = [a, b, c] ; R = [a, b, c] ; R = [a, c, b] ; false. It says that there are 6 solutions: four copies of the correct solution and two copies of an incorrect solution. It's important to remember that Prolog will always report all solutions to a query. Consider these: ?- member(X, [a, b, c, b, a]). X = a ; X = b ; X = c ; X = b ; X = a. # ?- member(b, [a, b, c, b, a]). true ; true ; false. `member/2` isn't a boolean test. It finds all members in the list that unify with the first argument. So in the first case, we get 5 solutions. In the second case, we still get two solutions. That might not be what you're expecting. (In [SWI Prolog](http://www.swi-prolog.org/pldoc/doc_for?object=memberchk/2) and [GNU Prolog](http://www.gprolog.org/manual/html_node/gprolog044.html#member%2F2), there's a separate `memberchk/2` predicate that will succeed at most once per invocation. I don't know if this is ISO compliant.) --- So let's start by looking at the parameter shape of your clauses (I'm going to reorder them slightly): remove_last(_, [ ], [ ]). % clause 1 remove_last(X, [X], [ ]). % clause 2 remove_last(X, [X|T], T). % clause 3 remove_last(X, [H|T], [H|Result]) :- ... % clause 4 Focus on the second parameter. * Clause 1 applies if argument 2 is an empty list. * Clause 2 applies if argument 2 is a list with exactly one element. * Clause 3 applies if argument 2 is a list with one or more elements. * Clause 4 also applies if argument 2 is a list with one or more elements. So consider what happens if we issue a query like this: ?- remove_last(a, [a], R). R = [] ; R = []. We got two results. They're both correct, but we'd prefer to just get one. For each clause, Prolog will try to unify the actual arguments against the parameter pattern for each of your clauses. In fact, we can follow along: % Clause 1 ?- (_, [], []) = (a, [a], R). false. # % Clause 2 ?- (X, [X], []) = (a, [a], R). X = a, R = []. # % Clause 3 ?- (X, [X|T], T) = (a, [a], R). X = a, T = R, R = []. # % Clause 4 ?- (X, [H|T], [H|Result]) = (a, [a], R). X = H, H = a, T = [], R = [a|Result]. So as you can see, when our actual arguments are `(a, [a], Result)`, three of the four clauses have parameters whose shape matches the actual arguments. Only clause 4 has additional rules, so let's look at it in more detail: remove_last(X, [H|T], [H|Result]) :- member(X, T), remove_last(X, T, Result). As we saw above, when the arguments were bound to parameters, we got these variable bindings: X = a, H = a, T = [], R = [a|Result]. But when Prolog asks `member(X, T)`, it can't find a solution; `a` isn't a member of `[]`. So this is why we get two copies of the same result when we pass those inputs: clauses 2 and 3 both generate a solution. Clause 4 matches the shape of the arguments, but it fails when it tries to prove the additional rules. And clause 1 doesn't match the shape of the actual arguments at all; it fails immediately. --- For a few more examples, consider these cases: ?- remove_last(a, [a, b], R). % will match parameter shape for clauses 3 &amp; 4 R = [b]. # ?- remove_last(a, [b, a], R). % will match parameter shape for clauses 4 only R = [b] ; R = [b] ; false. # ?- remove_last(a, [a, b, a], R). % will match parameter shape for clauses 3 &amp; 4 R = [a, b] ; R = [a, b] ; R = [b, a]. --- When you're writing Prolog programs, it's important to think about how your clauses overlap and whether that's a problem for you. If you want to ensure that only one clause applies to a given input, you might need to insert extra rules in some of your clauses to prevent them from applying. For example, if you test `member(X, T)` in one clause, you *might* want to test `\+ member(X, T)` in another clause (that's roughly "`X` is not a member of `T`", but is more accurately read as "ensure that we can't prove that `X` is a member of `T`"). --- Finally, a quick mention of efficiency. Suppose you do something like this: ?- remove_last(z, [a, b, c, d, ..., z], R). At the start, just clause 4 will match. But clause 4 will use `member/2` to scan the list `[b, c, d, ..., z]` for `z`. When `remove_last` recurses, again only clause 4 will match, and this time it will use `member/2` to scan the list `[c, d, ..., z]` for `z`. Every recursive call will cause a scan across a progressively shorter tail. This will cause your query to be O( n^2 ). This is sort of inherent to any sort of list processing where you have to operate at the start of the list but you're prefer to work at the end of the list. But it is possible to get it to be O(n)... just with a large-ish constant factor on that `n`. 
Wow thanks for the in depth explanation. I think it will help!
 i([],_,[]). %Empty list means intersect is empty. i([H|R],List2,[H|List]):- %If Head of List1 is a member of list 2 then add it to our intersect list memberchk(H,List2), i(R,List2,List). i([H|R],List2,List):- %if its not move on to the next element in list 1 and check that maplist(dif(H),List2), i(R,List2,List). I would define it like this, but I have used dif/2 maplist/2 and memberchk/2 instead of member/2. This makes it quite general, probably could be improved by enforcing that all elements in each list are unique (depending on if you want that or not).
Would it be possible to do without the dif/2?
I can see one way to do it with `!` and another way to do it with `\+` instead. Does your prof consider them to be built-in predicates?
Yeah, he does. Makes it quite a bit harder. But I do think I can get somewhere with the code provided! Thx for that
I'm not the original commenter, but I'm sure he appreciates the thanks. I'm not convinced that this can be done with only `member/2`. I'd point out that, if your prof considers `\+` and `!` to be built-in predicates, that he probably considers things like [`=`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%3D\)/2) and [`,`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%27,%27\)/2) to also be built-in predicates. There's not much you can do without them. Every solution that I come up with needs a way to ask a negative (i.e. "are these two things different" or "can I disprove this goal"), or a way to simulate conditional logic (i.e. using `!` or `-&gt;`), or else needs to use a metalogical predicate (like `findall`). I don't know of any way to emulate those things with just `member/2`. Note that, if you don't need to actually produce the list but instead just need to produce the common elements, then this is trivial. You were asking for it to work like this: ?- intersect([a, b, c], [b, c, d], X). X = [b, c]. But here's another interpretations of "find the members that exist in both lists". If this is what your prof. is after, then it's easy to do with just `member/2`: ?- intersect([a, b, c], [b, c, d], X). X = b ; X = c ; false.
Oh I'm sorry I wasn't clear. He doesn't see ',' and '=' as built-ins. He sees dif/2 as a built-in. Mb
I think I do indeed need to use \+. Btw, I wasn't clear. The Prof doesn't see ',' and '='. As built-ins. The prof sees stuff like diff/2 and append as built-ins. Mb
You aren't checking duplicates. I'm not certain from your assignment specifics whether you need to or not.
Yeah I need to. Is that possible with only using the built-in member/2?
There's extra logic involved.
What do you mean?
To avoid duplicates in the solution, I think you will have to use an accumulator, as the predicate needs to compare the current test to the solution so far. I am not aware of a way to do that without using an accumulator solution. Here is the introduction to accumulators from Learn Prolog Now! http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse20
member/2 alone wont do it.
You can see exactly what happens with [`trace/0`](http://www.swi-prolog.org/pldoc/man?predicate=trace/0). ?- trace. true. [trace] ?- intersect([a,b,c], [d,b,a,d,b], L). Call: (7) intersect([a, b, c], [d, b, a, d, b], _G4380) ? creep Call: (8) lists:member(d, [a, b, c]) ? creep Fail: (8) lists:member(d, [a, b, c]) ? creep Redo: (7) intersect([a, b, c], [d, b, a, d, b], _G4380) ? creep Call: (8) intersect([a, b, c], [b, a, d, b], _G4380) ? creep Call: (9) lists:member(b, [a, b, c]) ? creep Exit: (9) lists:member(b, [a, b, c]) ? creep Call: (9) intersect([a, b, c], [a, d, b], _G4477) ? creep Call: (10) lists:member(a, [a, b, c]) ? creep Exit: (10) lists:member(a, [a, b, c]) ? creep Call: (10) intersect([a, b, c], [d, b], _G4480) ? creep Call: (11) lists:member(d, [a, b, c]) ? creep Fail: (11) lists:member(d, [a, b, c]) ? creep Redo: (10) intersect([a, b, c], [d, b], _G4480) ? creep Call: (11) intersect([a, b, c], [b], _G4480) ? creep Call: (12) lists:member(b, [a, b, c]) ? creep Exit: (12) lists:member(b, [a, b, c]) ? creep Call: (12) intersect([a, b, c], [], _G4483) ? creep Exit: (12) intersect([a, b, c], [], []) ? creep Exit: (11) intersect([a, b, c], [b], [b]) ? creep Exit: (10) intersect([a, b, c], [d, b], [b]) ? creep Exit: (9) intersect([a, b, c], [a, d, b], [a, b]) ? creep Exit: (8) intersect([a, b, c], [b, a, d, b], [b, a, b]) ? creep Exit: (7) intersect([a, b, c], [d, b, a, d, b], [b, a, b]) ? creep L = [b, a, b] ; [trace] ?- nodebug. true. You can see a pattern: Call: (8) lists:member(d, [a, b, c]) ? creep ... Call: (9) lists:member(b, [a, b, c]) ? creep ... Call: (10) lists:member(a, [a, b, c]) ? creep ... Call: (11) lists:member(d, [a, b, c]) ? creep ... Call: (12) lists:member(b, [a, b, c]) ? creep It's asking, for each element of the right-hand list, whether that element is a member of the left-hand list. Since `b` is in the right-hand list twice, and since in both cases `b` is a member of the left-hand list, it's added to the output twice. You need to somehow suppress that. --- &gt; Only the first answer prolog gives has to be correct OK, that's an interesting constraint, and was the piece we were missing the last time you posted. A quick aside about Prolog's evaluation model: Normally, Prolog emplys backtracking to generate a set of solutions. If you want Prolog to only generate one solution to a given goal, it's important to design your clauses so that only one clause "responds" to the parameters. Suppose you have a program like this: trim_head_matching(E, [H | T], R) :- E \= H, R = [H | T]. trim_head_matching(E, [H | T], R) :- E = H, R = T. %same as... % trim_head_matching(E, [H | T], [H | T]) :- E \= H. % trim_head_matching(E, [E | T], T). --- ?- trim_head_matching(a, [a, b, c], R). R = [b, c]. ?- trim_head_matching(z, [a, b, c], R). R = [a, b, c] ; false. As you can see, both my queries produce just one result, even though there are two clauses. In each case, just one clause matches. But you can't use `\=`, so what happens if we just remove it: trim_head_matching(_, [H | T], R) :- R = [H | T]. trim_head_matching(E, [H | T], R) :- E = H, R = T. %same as... % trim_head_matching(_, L, L). % trim_head_matching(E, [E | T], T). --- ?- trim_head_matching(a, [a, b, c], R). R = [a, b, c] ; R = [b, c]. ?- trim_head_matching(z, [a, b, c], R). R = [a, b, c] ; false. The second query produces the correct result. The first query also produces the correct result, but there's a junk result in there as well, and the junk result comes before the correct result. The ramification of your instructor's constraint is that you want to be careful with your clause order. You'll always want to put the most-specific clause first. Let's swap the clauses: trim_head_matching(E, [H | T], R) :- E = H, R = T. trim_head_matching(_, [H | T], R) :- R = [H | T]. %same as... % trim_head_matching(E, [E | T], T). % trim_head_matching(_, L, L). --- ?- trim_head_matching(a, [a, b, c], R). R = [b, c] ; R = [a, b, c]. Now the correct answer comes first. --- &gt; How do I solve this? I figured I had to check if the head of the second list provided is a member of Result. And then basically remove that head, and then run intersect over the remaining tail of the second list provided. This didn't work. The code I used for that is this. &gt; &gt; intersect(L1, [H,T], [[Result]|Tail]) :- &gt; member(H, Result), &gt; intersect(L1, T, Tail). That's a good plan, but you have some errors. When you wrote `[H,T]` (i.e. a list of exactly two elements), I think you meant to write `[H|T]` (i.e. a list with one or more elements). You do that correctly in your first code chunk. Also, I'm not quite sure what you were getting at with `[[Result] | Tail]`. That pattern matches lists that have lists as elements, and that's not what you're producing. For example: ?- [[Result] | Tail] = [a, b, c]. false. ?- [[Result] | Tail] = [[a], b, c]. Result = a, Tail = [b, c]. --- OK, so to avoid duplicates, you can do one of: 1. Check just before generating a new result whether that result has already been generated. This seems to be the path that you were headed down. The only way to do this is to employ an accumulator as /u/gurzil says, and that will add a parameter to your `intersect` rule, changing it from `intersect/3` to `intersect/4`. (Though you can still have an `intersect/3` that immediately poses a query to `intersect/4`). 2. Change your recursion to eliminate any possibility of generating duplicates. As soon as you determine that you should add an item (say `b`) to the output list, change the parameters that you pass down to the next iteration of `intersect` so that there's no way it could possibly generate another `b`. This will require you to write a helper rule. In both cases, you'll need to consider your clause order to make sure that the "most specific" case is listed first. --- This is a strange assignment. Maybe your instructor is trying to start you off easy without fully explaining the Prolog evaluation model. But it's very odd to write a rule where only the first result is valid. At best, that's merely inefficient; at worst, in a larger program, that will prevent you from generating *any* correct solutions. I'm a little concerned that this assignment is designed to teach bad habits based on an incorrect model of Prolog evaluation. Keep that in mind in your future work with Prolog.
Wow thanks for the in depth explanation. These assignments were for explaining recursion. Btw I figured it out. It had to do with the order of my rules, kind of what you were getting at. Thanks for the write-up!
No problem. I find that writing answers like this helps me to organize my own thoughts. I had to take a couple stabs at the "evaluation order" section before I realized what I was actually trying to communicate. Glad you figured it out! Prolog is bizarre and interesting.
&gt; Its also important to point out that only the first solution that prolog comes up with is relevant, which leaves out any solution found by backtracking. That's not entirely true. That statement is true for the top-level query - the top-level query will not backtrack. But any intermediate queries can and will backtrack, and in fact you need to leverage that to get a correct solution. You're the second person who's asked about this assignment. The "only the first solution is relevant" clause is interesting, as it's not how Prolog programs are typically written. It has the ramification that your clause order matters a lot, and that your clauses should be ordered most-specific to least-specific. In any case, your code currently handles three cases: 1. The second list is empty 2. The second list is not empty, and its head is a member of the first list, and it has not yet appeared in the output 3. The second list is not empty You can't express #2 without `not` or an equivalent, but is there some more specific clause that you could insert before #2?
if this is what you are referring to is true, I will slap myself in the face for not seeing this: * The second list is empty * The second list is not empty, and its head has already appeared in the output (in that case, do nothing with NewList). * The second list is not empty and its head is a member of the first list. * The second list is not empty. Thanks a lot for replying tho!
You're a quick student. Good job.
Thanks :), I did forgot to include that in the second clause the head also has to be member of the first list, else you will be stuck in a loop because member(Head, NewList) will always be true at some point.
Lol thanks bro I got the exact same problem. I guess you also study AI in Amsterdam?
This is the reason Prolog isn't more popular. It hurts your brain. It certainly hurts mine at times, but it does get easier. I'd start by... umm... well... yea, hang on, I'm thinking. You could recurse over one of the lists. For each element, add it to the result L if it occurs in the second list. So start with a membership check (this will contain bugs. I haven't tried running anything): member( Me, [Me|_] ). member( Me, [H|T] ) :- member( Me, T ). Then you can recurse over the first list and add it to the result if it's in the second list: intersect( [A|B], C, [A|D] ) :- member(A, C), insersect(B, C, D). Etc.
You need some base case, in this case `related(X, Y) :- pais(X, Y).`. edit: or even `related(X, X).`, if you consider a person to be related to themselves.
The standard negation operator in Prolog is \+ not not (sic). IMO it is better style to focus on the positive cases, not the negative ones. Also you don't state whether the input is already de-duped. intersect([],L,L). intersect([X|Lx],Ly,Lz) :- member(X,Ly), intersect(Lx,Ly,Lz). intersect([X|L1],L2,[X|L3]) :- \+ member(X,L2), intersect(L1,L2,L3). Note to TA: if you see this code, ding the student for copying without thinking. 
Thank you Michael, I greatly appreciate your feedback! It's always work in progress! Always. πάντα χωρεῖ καὶ οὐδὲν μένει
This can be done with a compound query, searching for something that meets two criteria. Is there a continent.. continente(X), where you cannot find a country that belongs to it. not(pais(_,X,_)). 
Thank you !
It's easy to get Prolog to iterate a set of well-known things. For example: isbn_digit(0). isbn_digit(1). isbn_digit(2). ... isbn_digit(9). ?- isbn_digit(X). X = 0 ; X = 1 ; ... X = 9. It's also easy to bind a variable to a list of a known length, but with unknown contents: ?- length(X, 10). X = [_G1750, _G1753, _G1756, _G1759, _G1762, _G1765, _G1768, _G1771, _G1774, _G1777]. SWI-Prolog has a built-in predicate called [`maplist/2`](http://www.swi-prolog.org/pldoc/man?predicate=maplist/2) that lets you ensure that every member of a list obeys a predicate. If everything is already grounded, it can be used as a simple true/false test: ?- maplist(integer, [1, 2, 3]). true. ?- maplist(integer, [1, b, 3]). false. But it can also be used to enumerate all lists where every element satisfies the predicate (assuming the predicate itself is enumerable): ?- maplist(isbn_digit, X). X = [] ; X = [0] ; X = [0, 0] ; X = [0, 0, 0] ; X = [0, 0, 0, 0] ; X = [0, 0, 0, 0, 0] ; ... If you start with your list's size already constrained, it will do what you want: ?- length(X, 5), maplist(isbn_digit, X). X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 2] ; ... X = [0, 0, 0, 0, 0, 0, 0, 0, 0, 9] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 1, 0] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 1, 2] ; ... X = [0, 0, 0, 0, 0, 0, 0, 0, 1, 9] ; X = [0, 0, 0, 0, 0, 0, 0, 0, 2, 0] ; ... X = [0, 0, 0, 0, 0, 0, 0, 0, 9, 9] ; X = [0, 0, 0, 0, 0, 0, 0, 1, 0, 0] ; ... If you're not using SWI-Prolog, you could write your own, more specific version of `maplist/2` without too much hassle. All it would need to do is to recursively apply the `isbn_digit/1` predicate to every element of the provided list. Note that, with 10 digits, there are 10 billion ISBN strings, or 25 billion if you include `X`. With 13 digits, that goes up to 10 trillion (35 trillion with `X`). You probably don't want to iterate them all. 
Suppose `yfy` were a valid type for an operator. For the sake of concreteness, let us suppose we could state: ?- op(700, yfy, +). With this definition in place, I give you the following term to parse: a + b + c Please write down the **canonical** form of this term. The second question is the same as the first. The answer only contains, as a small addition, a description of what `x` and `y` means. You can find this in every description of the `op/3`directive.
Prolog is a *declarative* language. To make the most out of it, think about the task this way: How would you *describe* the situation that a list has repeated elements? We know that there are two possible cases for a list: Either it's empty, or it has at least one element. Obviously, if it's empty, then it also has no repeated elements, so we *do not even have to consider* the case where the list is empty: In that case, the relation *cannot* hold, no matter what else is the case. In contrast, what if there *is* at least one element? Let us thus start with: repeated_elements([E|Ls]) :- ... Here, we are considering a list that has E as its first element, and where the remainder is Ls. Under *what conditions* is E a repeated element of the whole list? This is the critical point of the whole definition. After some reflection, we find: E occurs repeatedly in the list *if* it is a member of Ls. So, a single further goal suffices to conclude the definition for this case: That goal shall describe the case that a term is a *member* of a list. After that, ask yourself: Are there any *further* cases in which a list contains repeated elements? Describe them as well! I hope this helps you to complete the task, in at most a few lines of Prolog code. Moreover, your definition will be **very general**: By this, I mean you will be able *not only* to "check", but also to *generate* lists where an element occurs repeatedly! Note that when you speak about "check", you are already implying a particular *direction* of use. That is very procedural, and thinking this way about the task will confine your program to only a subset of those modes that a more general, *declarative* Prolog program will be able to cover. Note also that *no arithmetic* is necessary to complete the definition: Simply reason *symbolically* about all terms that arise, and describe the various cases by using the same variables for things that are equal.
Thank you so much for taking the time to explain this to me! :) I will try to do it with this in mind 
In addition to /u/zmonx's excellent writeup (saying that you're sort of going about it the wrong way), I want to point out a specific problem that you have as well. Consider the heads of the three clauses you have for `repeated`: repeated([],0) repeated([M],0) repeated([H|T],R) It's clear that `repeated` only makes sense if the first parameter is a list (or can be constrained to be a list). Now consider this: repeated([H|T],R):- repeated(H,R1), Let me rewrite that like this: repeated(L,R):- L = [H|T], repeated(H,R1), You're taking the first element of the list `L` and passing it to `repeated`. But we already established that `repeated` only accepts lists in its first parameter. Those two things imply that `L` must be a list of lists... of lists of lists, all the way down to either empty lists or lists with just one element in them (handled by clauses 1 and 2). That's probably not what you intended. --- One more point: in this clause: repeated([M],0). You're saying that `repeated` can be called with any one-element list as its first parameter, and it doesn't matter what value appears in that list, the relation will be true. The `M` in this clause is known as a singleton variable because it only appears once in the entire rule. It's essentially a wildcard saying "anything can be here". Singleton variables are typically flagged as warnings by Prolog systems because they usually indicate an error. But in cases where you really don't care about a value (maybe because other parameter constraints ensure that the value really doesn't matter), you can use an underscore (`_`) for the variable. Underscore is a special variable that never binds to anything and which suppresses the singleton variable warning. 
Check tagshelf.com
"Out of local stack" is just like a stack overflow in any other language. You're putting stuff on the stack and recursing. In particular, whenever there is a choice to be made, a choice point is put on the stack to facilitate backtracking. If you don't care about these choice points, the `!/0` predicate (called the cut) will discard the choice points from the current stack frame. You can call it before you recurse. Be warned, using the cut will prevent backtracking and may break the correctness of your code. In "pure" Prolog, you shouldn't use the cut. The CLP(FD) library often offers good alternatives for pure programs. To the problem at hand, consider moving the cut somewhere before the recursion.
Sounds like just my thing! :) Will try to have a look at! 
Wtf, there's nothing like avoiding interruptions while concentrated. That is worse than regular open spaces.
Try this: 1. Use `length/2` to get the length of the flat list. 2. Get the number of sublists by dividing by 9. 3. Use `length/2` with that number of sublists to create the list of sublists. 4. Write a helper predicate (or use a combination of `maplist/2` and `length/2`) to say that each sublist has length 9. 5. Use `append/2` to say that all the sublists appended together equals the flat list. 6. ... 7. Profit. In the unlikely event that your Prolog doesn't have `append/2`, it can be implemented by using `append/3` in a loop. There's another way to implement this using just recursion and no library predicates, but it's less declarative. Also, it's possible to omit the first three steps. The downside is that if you try to backtrack, you could hit an infinite loop. The code is literally less than 10 lines, so your Prof is right about it being simple. I'm not posting code because that's your job ;)
Thank you, prolog beginner so everything is hard. 
The links in the sidebar are really good if you need more resources outside of your class materials. Also [Learn Prolog Now!](http://www.learnprolognow.org/) is a great tutorial. You can follow the code examples along in a web browser with [SWISH](https://swish.swi-prolog.org/).
you can have two different predicates: sister_fact(mary, catherine). sister(X, Y) :- sister_fact(X, Y). sister(X, Y) :- sister_fact(Y, X). 
Clever. Thanks :)
Meaning will you get a job doing it alone? Prob not in many markets. Meaning will you learn from the experience and possibly use it from time to time to solve certain problems? Certainly. 
Yeah. You will have hard time finding job with just Prolog, and even job related to Prolog apart from academy. But it's kind a cool concept. 
Absolutely. Understanding how to build and query knowledge bases and solve combinatorial optimization problems (simply!) is a tool every programmer should possess. That’s not to say you’ll use it all the time, but being introduced to it will make you a better programmer. And when you need something like prolog, there’s nothing better. People should learn a variety of programming languages so that they will: a) know how to think in a variety of computational models; and b) always have the right tool for a particular job.
William Byrd comments on this comparison over on [stackoverflow](https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp). 
For learning, I would recommend starting off with prolog and a good book such as "The art of prolog". The syntax is nicer and less mental overhead than dealing with an embedded logic engine in another language. Once you are more familiar with the concepts of logic programming and want to interface it with other languages then you can come back to core.logic.
I've been a bit interested in the idea, but never had the opportunity to try! Ever used it? 
Datalog doesn't allow complex terms and isn't turing complete. I think it's a bit dumb.
Because it is not a programming language perse, thats not the idea. But that doesn't mean it is not useful other stuff
Nope, seems that I'm in the same situation.
[Souffle](http://souffle-lang.org/) is a DSL for program analysis based on Datalog. [LogicBlox](http://www.logicblox.com/) and [Datomic](http://www.datomic.com/) are databases which also use Datalog derivatives for query languages. You could try using it in those applications. If you want the theoretical perspective, [Ullman](http://infolab.stanford.edu/~ullman/dscb.html) covers it in great depth. A summary can be found in lectures 14 and 15 of [these slides](http://tinman.cs.gsu.edu/~raj/4710/widom/pdf/).
Do you really mean the first line, `empty( R ) :- R == [].` or the whole thing? Did you try to load it and query it? Where did you find this code?
Just the line you mentioned yeah and I don't remember. I just thought it was necessary so I put it in there but I don't know why. 
 empty( R ) :- R == []. This establishes a unary relation `empty/1` that holds if its one argument is identical to the empty list. If its one argument isn't identical to the empty list, then the relation won't hold. I just want to put out there that you might actually want to be using `=`, not `==`. In particular: ?- X == []. false. ?- X = []. X = []. but ?- X = [], X == []. X = []. `==` won't unify an unbound variable with a term. But in Prolog, you *usually* don't want to be so picky. When you issue any query in Prolog, you generally want to think of that as asking "what variable bindings will satisfy this query". `==` hinders that process by preventing variables from unifying.
You should try and see what happens if you leave it out. I don't see it used in the rest of your code you are showing.
&gt; I just want to put out there that you might actually want to be using `=`, not `==`. The `==` is probably on purpose. The purpose is shrouded in mystery, just like the source of the code that OP is showing us.
If a list has repeated elements, this means that it will get shorter after you sort it. Basically: repeated(L) :- sort(L, S), length(L, X), length(S, Y), X &gt;= Y.
It "works" for me. I have no idea what you did but it must be something different from what I did.
Thanks a lot! That fixed it. 
If you are using `read` and `write` like this you are doing something wrong anyway.
Just trying out stuff, don't know enough to be productive in prolog.
The future is declarative and there are 2 ways to go. Logic programming or functional programming. Functional programming can be seen as a degenerative case of logic programming so why not learn the more general form as expressed by a modern prolog. 
Why don’t you just use is_set/1 if all you want to do is check whether a list is a set or not?
The toplevel is already a REPL, you shouldn't need to program your own unless you are doing something really special.
Basically: isbn(X) :- length(X, 10), maplist(between(0, 9), X). 
Perhaps unintuitively, `max` is a function, not a predicate, in the same way that arithmetic operators like `+` are. Functions are evaluated to values, unlike predicates. The `is` operator is a builtin which evaluates its right operand before unifying it with its left, so this works: ?- max(2,X). ERROR: toplevel: Undefined procedure: max/2 (DWIM could not correct goal) ?- X is max(2,3). X = 3. ?- X is 1 + 2. X = 3. 
Thanks, this works as you indicate. Maybe the documentation could make things clearer!
It is listed under "Arithmetic Functions". At the top of [that subsection](http://www.swi-prolog.org/pldoc/man?section=functions), it reads: "Arithmetic functions are terms which are evaluated by the arithmetic predicates..." This means that you can give any of [the arithmetic predicates](http://www.swi-prolog.org/pldoc/man?section=arithpreds) one of the arithmetic functions and it will do the right thing. But again, those are not really _functions_, they are _terms_ that are evaluated by predicates. Here is what it means: Unification, X is just a term: ?- X = 2 + 3. X = 2+3. Again, unification, both X and Y are just terms: ?- X = 2 + 3, Y = X / 2. X = 2+3, Y = (2+3)/2. Using the arithmetic predicate `is/2` finally evaluates the term `min(2, (2+3)/2)` and unifies the result with Z: ?- X = 2 + 3, Y = X / 2, Z is min(2, Y). X = 2+3, Y = (2+3)/2, Z = 2. 
There are different approaches. You could get a textbook on Prolog and read it. I have been told that it helps some people; others are better at reading existing code and learning from that. If you are of the second kind, and you think that searching Stackoverflow and googling in general is not a very structured approach, then the SWI-Prolog implementation source code is a gold mine. If you go to the [documentation](http://eu.swi-prolog.org/) and search a bit, you will find [`min_list/2`](http://eu.swi-prolog.org/pldoc/doc_for?object=min_list/2). There is this orange circle with a `:-` inside, in the right corner of the blue title bar. If you click on it, you get to [the implementation of `min_list/2`](http://eu.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#min_list/2). The same code is [available on GitHub, in the SWI-Prolog repository](https://github.com/SWI-Prolog/swipl-devel/blob/cbb87e1161b0fe5c19b0ba0479fe4df586741c6a/library/lists.pl#L564-L577). The code reads: min_list([H|T], Min) :- min_list(T, H, Min). min_list([], Min, Min). min_list([H|T], Min0, Min) :- Min1 is min(H, Min0), min_list(T, Min1, Min). The first two lines: min_list([H|T], Min) :- min_list(T, H, Min). The `[H|T]` says that a list must have at least one element in order to have a minimum. The `Min` on the first line is the minimum (the smallest number in the list). It is not clear what it is yet, but in appears as the third argument of `min_list/3` on the second line. The `T`ail and `H`ead are also there. In the definition of `min_list/3`, we first read: min_list([], Min, Min). which says that the if the list is empty then the current minimum is the minimum. The last three lines: min_list([H|T], Min0, Min) :- Min1 is min(H, Min0), min_list(T, Min1, Min). If the list is not empty, you get the smaller of the head and the current minimum and use it as the current minimum.
Since we already talked about arithmetic functions and terms and whatnot, how about this: numlist_min([H|T], Min) :- min_expr(T, H, E), Min is E. min_expr([], Min, Min). min_expr([H|T], Min, min(H, Min0)) :- min_expr(T, Min, Min0). How is this different from the SWI-Prolog library solution? 
Of course, the other solutions are not _declarative_; they are _procedural_ in their nature. They follow the obvious algorithm: &gt; Seed the minimum with the first element of the list; then look through the rest of the elements in order; whenever an element is smaller than the current minimum, replace the current minimum. When there are no elements left, the current minimum is the global minimum. A _declarative_ solution would be: &gt; The minimum of a list is an element of the list which is not greater than any other element in the list. Prolog has `member/2` which has the declarative reading "X is member of List". So, you can use it to say: list_min(List, Min) :- member(Min, List), \+ ( member(X, List), Min &gt; X ). which is a one-to-one translation from the declarative statement above to correct Prolog syntax. Exercise**: why does the library implementation use a procedural implementation?
what does "\+" mean?
It means "succeed if goal fails". It should be possible to find it in the documentation of the Prolog implementation you are using. In this context, it means, literally, "Min is an element of List, and there is no X that is element of List so that Min &gt; X."
`between/3` is a built-in predicate that is not at all easy to implement on your own _correctly and completely_. But guessing that you mean that "K is in [I, J]", why not: I =&lt; K, K =&lt; J ???? PS: you really need _at least_ to look at the documentation. If you did, you'd know that `;` has lower precedence than `,`, and all the parentheses you have put in your code are completely unnecessary, and what you have means "K &lt; J OR ( K = J AND K &gt; I ) OR K = I". This is why you usually write ( foo ; bar ), baz just to make sure that it is really obvious that you are using a disjunction, and to make it do what you mean to do.
I've been looking through the documentation. That's how I figured I could use ';'. I just thought that it meant 'or', I didn't realize the precedence issue. Is this any closer? less_than(K, J) :- K =&lt; J. greater_than(K, I) :- K =&gt; I. between_ints(I, J, K) :- greater_than(K, I), less_than(K, J). 
Why are you making it so difficult? Anyway, this probably doesn't compile, `=&gt;` is not the same as `&gt;=`. See the documentation. And `&gt;=` means "greater than or equal to", not "greater_than". But why define a predicate for that?
Just sort the list. If the number you want to check is the same as the head then the result is true otherwise false. 
You are answering to the title, not to the question, but I will take this opportunity to show you something: ?- sort([X,0], [1,_]). X = 1. Exercise: What happened?
If using SWI Prolog you can write this. :- use_module(library(lists)). is_min(X,Ls) :- min_member(X,Ls).
 ?- min_member(1, [X,0]). X = 1. WAT?
http://www.swi-prolog.org/pldoc/man?section=standardorder
min_list(1,[1]). true. min_list(3,[1,2,3]). false. min_list(4,[5,6,4,7]). true. This is how it works. It’s all the question asks. 
It is the exactly same effect as in ?- sort([X,0], [1|_]). that I showed above. I was hoping that u/Hitaka02 picks up on it.
If you read the text of the question and not only the title then you would be wasting too much time reading.
Ah, your "WAT?" made me think that you were also unsure of what was going on. I should have been paying closer attention to usernames.
The best part of this whole discussion is that OP seems to have been attempting to implement their own version of `between/3`, which is not _exactly_ the same as finding the smallest number in a list.
Thanks a lot for your help. Could you possibly help me with one more? https://www.reddit.com/r/prolog/comments/7dh5yy/checking_repetition_of_list_values/?st=ja37fqkm&amp;sh=c769b02b
Can you show me what course materials you have gotten? It is very difficult to do homework without knowing what you are supposed to know and who is trying to teach you.
 I was only given examples of what basic things like facts &amp; rules are and then the problems. I'v never programmed with a logical language before.
Yeah sure but still you must have gotten something. It would be easier to look at it instead of learning all of Prolog on my own and then solving problems for you. This is actually also fine but usually this kind of work costs money.
Basic info + a link to a youtube video with the same basic info. **Facts** • A knowledge base: A collection of facts and rules • Prolog programs: simply knowledge bases, collections of facts and rules which describe some collection of relationships, rather than a set of steps to solve a specific problem. • How we use Prolog programs: by asking questions about the information stored in the knowledge base (queries). **Rules** • The right side is the if part, and the left side is the then part. • If the right side Prolog statement is true, then the left side of the statement must also be true. • The left side of a Prolog statement is a single term, while the right side can be either a single term or a conjunction. • Conjunctions contain multiple terms that are separated by logical AND operations. • In Prolog, the AND operation is implied. **List Structures** • The list elements are separated by commas, and the entire list is delimited by square brackets, as in [apple, peach, grape, pear] • The notation [] is used to denote the empty list. • Prolog simply uses a special notation. [X | Y] denotes a list with head X and tail Y. **Unification** The = sign in Prolog represents unification, so: ?- 2 = 3. % False ‐ equality test ?- X = 3. % X = 3 assignment ?- X = 2, X = Y. % X = Y = 2 two assignments, Y is assigned to, even though it is on the right hand side, because it is free ?- X = 3, X = 2. % False First acts as assignment and binds X=3 Second acts as equality because X is bound, since 3 does not equal 2, gives False
I have been searching but nothing that comes up really applies. I've looked through the [built-in predicates](http://gprolog.org/manual/html_node/gprolog024.html) but I can't seem to find any that I can apply
If you go through [7.1-7.3 of Learn Prolog Now!](http://learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse28) you will have what you need to solve this. It might be more advanced than the expected solution, but your question is a variation of one of the exercises.
I'm looking at the bottom of 7.2 and I don't know how to translate that into code, I'm just getting a bunch of errors. I don't even see where the length comes in
So where is the link?
You'd probably use a DCG for this. It would go like p(X) :- phrase(as_bs, X). as_bs --&gt; [a], as_bs, [b]. as_bs --&gt; [].
Indians are putting up videos on everything, not just logic programming. The quality is questionable; the information density approaches zero. "Hello buddy. Today we learn how to make headings in markdown...." 3:47 minutes later you learn that this is how: # Heading level 1 ## Heading level 2 ### Heading level 3 "... sign up for my markdown tutorial channel." Although I am biased, I really prefer to read well written documentation than to watch videos. This all said, here is at least one "American" channel with Prolog instructional videos: https://www.youtube.com/channel/UCfWpIHmy5MEx2p9c_GJrE_g/videos
I have done some youtube videos on prolog - the most popular video was https://www.youtube.com/watch?v=BHRy7P0gMy8 Not done any more for a while though as I am busy but wold like to when I get the time. 
Thanks for the info. I’ll take a look. Actually I’m a returner to Prolog. I’m most interested in the constraint programming aspects of the language. Trying out SWI Prolog and Eclipse. 
I would say reverse the list while substituting a for b and b for a, then check that the original list is identical to the reversed+substituted one. No arithmetic! 
CHR or CLP(B/FD)? If you are interested in CLP(B) or CLP(FD), make sure to look at the website by Markus Triska: https://www.metalevel.at/prolog This is the only comprehensive free textbook I know of that consistently prefers using constraints and declarative, logical constructs. It is a bit preach-y at times but definitely worth reading.
Thanks, I have come across this guide already and have it book marked. This is a free book on CLP using Eclipse http://www.anclp.pl/ which is pretty comprehensive. 
I think you need a relational database. Postgres is one free option. 
I forgot that I need to define rules! (I've edited the original post to correct that.) Does SQL let you define rules?
Yes, you can. First, you can do a lot with SQL. The recursive rule can be a recursive query, or a `CONNECT BY` in Oracle, and so on. Every database has its own extensions to SQL so you'd have to read the documentation. Then, you can define stored procedures both in Oracle and in Postgres. It might be a good idea to define an API using stored procedures instead of writing raw SQL queries on the client side; it really depends on the use case. You can of course use a Prolog for all of this; some of it might be easier with a Prolog. For example, [Pengines](http://eu.swi-prolog.org/pldoc/doc_for?object=section(%27packages/pengines.html%27)) from SWI-Prolog lets you load Prolog code to a server, query it on the server, and get the results, all over HTTP. However, as far as I know, if your data does not fit in the main memory than you really should use a proper relational database instead.
... and of course, do not forget about views. The recursive query above can be used to `CREATE VIEW`; then, you query the table if you want the simple "is" relation and the view to find the transitive closure.
Just to expand a bit on "does SQL let you define rules?" Actually, the textbook approach to this is to use views. In the sibling post, I used a query; you can add `CREATE VIEW view_name AS` on top and you'll get a view that you can query as you'd query a table. Here is a file `rule.sql` that creates a view `BE_TRANSITIVE_CLOSURE` using the recursive query, then queries the view instead of the table: create table be ( x text, y text ); create table have ( x text, y text ); insert into be values ('dog', 'pet'); insert into be values ('fish', 'pet'); insert into be values ('pet', 'fun'); insert into have values ('dog', 'flea'); insert into be values ('motorcycle', 'loud'); insert into be values ('motorcycle', 'dangerous'); insert into be values ('dangerous', 'fun'); create view be_transitive_closure as with recursive be_r(a, b) as ( select x, y from be union select x, b from be, be_r where be.y = be_r.a ) select a x, b y from be_r ; .mode column .headers on .print 'solve for X in (be X pet &amp; not(have X flea)) | be X loud' select be.x from be_transitive_closure be left join have on be.x = have.x where be.y = 'pet' and (have.y &lt;&gt; 'flea' or have.y is null) or be.y = 'loud' ; .print 'solve for (X,Y) in be X Y' select x, y from be_transitive_closure ; .print 'solve for X in be X fun' select x from be_transitive_closure where y = 'fun' ; and now you get, as you'd expect: $ &lt; rule.sql sqlite3 solve for X in (be X pet &amp; not(have X flea)) | be X loud x ---------- fish motorcycle solve for (X,Y) in be X Y x y ---------- ---------- dog pet fish pet pet fun motorcycle loud motorcycle dangerous dangerous fun dog fun fish fun motorcycle fun solve for X in be X fun x ---------- pet dangerous dog fish motorcycle 
Nice sql-ideas! As a Prologist I would probably check out the SWI Prolog solution first, though. If it would be practical to persist the data, SQL is probably a good idea in any case. I don't know how the SWI solution handles large amounts of data, but with Sicstus Prolog this has never been an issue for me. I've routinely handled calls with 5 megs of data sent in
Mind: blown. I had no idea SQL was so expressive. What are the limits of its expressivity? To its scale and speed? How do those compare to, say, Datalog? Can you recommend a good short text on recursive across-table SQL queries?
As far as I know, Datalog is a subset of Prolog that is meant for querying a relational database. Basically, it is another query language (in addition to SQL) with very similar semantics. Scale, speed, expressiveness: I am not aware that there would be hard upper limit to any of these. For what I know, different databases have different selling points and make different trade-offs; then, they try to expose as much of the features through the SQL interface. What cannot be done in the purely declarative part of SQL can be worked around using PL/SQL. In the case of SQLite, it is meant to be used as a library, so you just call it from the application directly, you don't need to have a procedural layer in between. Finally, "a good short text on recursive across-table SQL queries": every database has its own documentation, and since all databases are different, you just have to read the documentation. The concepts carry accross databases but the details are going to be different. Here is the [Wikipedia article](https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL) again. Here is the [SQLite3 documentation page](https://sqlite.org/lang_with.html) (look at for the recursive and hierarchical query examples). 
**Hierarchical and recursive queries in SQL** A hierarchical query is a type of SQL query that handles hierarchical model data. They are special cases of more general recursive fixpoint queries, which compute transitive closures. In standard SQL:1999 hierarchical queries are implemented by way of recursive common table expressions (CTEs). Unlike the Oracle extension described below, the recursive CTEs were designed with fixpoint semantics from the beginning. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/prolog/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
I guess it really comes down to defining your constraints and your aims. I didn't want to hijack the discussion (I realize this is the Prolog sub). I'd definitely prefer a pure Prolog solution if the data is not excessively large and if persistency is not a really important issue.
Prolog and SQL feel like they have much in common - I don't mind cultural exchange :) As you say ;it depends a lot on the requirements! If the data is not that large, you could even just keep it in the Prolog process which answers the query, if the SWI solution works similarly to the Sicstus one
I am only a bit disappointerd that you don't give any details on how the Prolog solution would look like? How exactly would you load the code over HTTP and then query it? Would you use Pengines? How exactly do you setup? How does it scale? How do you persist the data if you wanted to? I would really like to know at least a bit about this, I have heard quite a bit about SWI-Prolog but I haven't had the opportunity to use it for anything bigger.
I am afraid I don't know any details - only that it's supposed to be possible. SWI usually has documentation on their site. Just started using their Java - interface, and it seems to be working fine
Hmm. I'm not even sure what you are asking. Can you show a picture or at least a list that demonstrates what you mean?
Updated the post, hopefully it's more understandable now. :)
So, not sure, how would you solve this problem on paper? Why would you not connect the two zeroes in the upper left part?
I'm trying to make a program that solves Hitori puzzles, and one of the three main [rules](http://www.conceptispuzzles.com/index.aspx?uri=puzzle/hitori/rules) is that all un-shaded cells (represented by 0) has to create a single continous area.
Ok, so basically, around each 0 (each unshaded cell) must be at least one other 0 in direction up, down, left, or right?
Correct, I've tried (unsuccessfully) to implement a floodfill predicate to do this, however, using floodfill gives the CPU a relatively heavy workload.
I see what you mean! Im not the most experienced prolog programmer but i just came op with the following pseudocode. 1. Find the first 0 in your array, if there arent any 0´s: false (obv.) 2. Check if 0 is connected to another zero, if so call this step recursively. else proceed to step 3. 3 When the 0 isnt connected anymore check if theres another 0 that isnt connected in the list, if this succeeds return false, else: true. Theres probably a more efficient way, but I hope this will get you a bit further in general! 
Although floodfill isn't preferable it's still better than nothing 😄. However, the challenge lies in the programmatic part, not the conceptual.
I have the code that comes really close, the only thing is that it outputs false when all the 0´s connect and it outputs true when there exists a 0 so that its not connected to the rest. This is what it looks like from the highest level. all_connected(State) :- flatten(State, Flat_state), length(State, Size), find_first_0(Flat_state, First_0), Nth0_Row is First_0 mod Size, Nth0_Column is First_0 // Size, not(check_verticalconnection(Nth0_Row, Nth0_Column, State)), not(check_horizontalconnection(Nth0_Row, Nth0_Column, State)). ill let you implement find_first_0, check_verticalconnection and check_horizontalconnection yourself. You can of course use whatever names you like for your predicated. If you have questions about my code or if it isnt right (which could very well be the case) then ask me!
"so basically, around each 0 (each unshaded cell) must be at least one other 0 in direction up, down, left, or right?" This is not correct as I understand it as you could have two islands of 0s that are disconnected but every 0 is still connected to at least one other. I would model the puzzle as a graph and check that each 0 can 'reach' all other 0s.
You’re not spoiled for choice here. Have you read Naish’s Technical Report 96/2 Dept. Of Comp. Sci., Univ. of Melbourne? It discusses techniques for supporting higher-order programming. 
Yes. For example, here's a rule that will filter down to only include the numbers greater than 5: gt_five([], []). gt_five([ A | As], [ A | Bs]) :- A &gt; 5, gt_five(As, Bs). gt_five([ A | As], Bs) :- A =&lt; 5, gt_five(As, Bs). You could adapt that to instead build a list that only contains the values that satisfy your `is_factor` predicate. Or, in SWI-Prolog, there are some builtins that help you do this with metaprogramming. [`include/3`](http://www.swi-prolog.org/pldoc/doc_for?object=include/3) can be used in a way that's similar to `filter` from functional programming. You could try this: build_list(12, L), include(is_factor(12), L, RL). ... except that won't work. `include/3` appends the values from the source list to the goal that you provide. So that will effectively evaluate all of these: is_factor(12, 1) is_factor(12, 2) is_factor(12, 3) is_factor(12, 4) ... But you want it to evaluate: is_factor(1, 12) is_factor(2, 12) is_factor(3, 12) is_factor(4, 12) ... The easiest way to handle that is to just flip the parameters to `is_factor`. If you don't want to do that, you'd need to create a helper rule: is_factor_flip(N1, N) :- is_factor(N, N1). 
Thank you very much, this will help me greatly!
What you have isn't necessarily wrong, but it is incomplete. OK, so with regard to your existing code: you use `is/2` a lot when you don't need to. Typically, you use `is` to do arithmetic. But you are using `is` to check for equality. For your purposes, you could replace `is` with `=`. Note that `=` isn't technically an equality check, either. `=` is the unification operator in Prolog. If the left and right operands are both instantiated (i.e. are concrete numbers like `0` or `1`), then it turns into an equality check. It's not that it's incorrect to use `is`, but I think `=` would be more conventional. Also, using `=` would let you shorted some of your clauses: leftcalc(A, B, C, D) :- o(A, B, K), o(K, C, D). Whether that's more or less readable is up to you. --- OK, so what are you missing? Well, how do you know if an operator is associative? It's associative if, for any three arbitrary values `A`, `B`, and `C` from the operator's domain, `(A op B) op C == A op (B op C)`. If the domain is the set of integers or the set of reals, then you need to use some sort of proof (possibly using induction or contradiction). When the domain is finite, as here, you can just brute-force test every possible combination to check for associativity. That's the piece you're missing. `asso/3` provides the code to test whether `o` is associative for a given `X`, `Y`, and `Z`, but you never iterate the set of possible `X`, `Y`, and `Z` values.
"but you never iterate the set of possible X, Y, and Z values." that is exactly the problem i'm having, i found a function forall but cant really understand how to use it.
equal(Q , W) :- Q is W. equal(X,0). gives X=0. whereas leftcalc(A , B , C , L) :- o(A ,B ,K) , o(K ,C, L). leftcalc(0,0,1,L). gives L = 1; false.
So `false` in Prolog doesn't have the same meaning as in other languages. Remember that in general, Prolog is trying to find a set of solutions, not just a single solution. For example: ?- member(A, [1, 2, 3]). A = 1 ; A = 2 ; A = 3. Sometimes, as above, Prolog deterministically knows when it has exhausted the set of solutions. Other times, it's not sure: ?- member([x, A], [[x, 1], [x, 2], [y, 3]]). A = 1 ; A = 2 ; false. (In case that's not clear: I have a list-of-lists, and I'm using pattern matching to find elements that match the pattern. So Prolog will evaluate `[x, A] = [x, 1]`, which will succeed. Same with `[x, A] = [x, 2]`. But `[x, A] = [y, 3]` will fail because `x` and `y` can't be unified.) In this case, `false` should be read as "there were no more solutions". Essentially, that result set is the same as: A = 1 ; A = 2. Similarly, `true` doesn't mean the same thing in Prolog as in other languages. In Prolog, `true` means that a solution was found that didn't involve any top-level variable bindings. For example: ?- member(1, [1, 2, 1]). true ; true. ?- member(1, [1, 2, 3]). true ; false. Since `1` is in the first list two times, there are two `true` results. In the second case, it finds one success, but then Prolog isn't sure that there are no more solutions. Once it goes back to try to find more, it realizes that there are no more, and produces `false` (no more solutions). 
 ?- forall(member(A, [1, 2, 3]), A &lt; 4). true. ?- forall(member(A, [1, 2, 3]), A &lt; 3). false.
findall(Nr, (member(Nr, NrList), is_factor(Nr)), Nrs) Should do it? :) 
too much data to process Thanks anyways :)
hi ,im desperate child plz :)))
report this spammer! 
hi 
Hire a tutor with that money
If you are already failing college what is the point in helping you?
1) Don't offer money. We don't want it. ii) Don't be so obvious about it being a school project. You're basically cheating and we don't like that. c) Instead of saying "help help!", how about you actually write out the problem in more detail. What, for example, is a perfect number? 4) Get a tutor. So, cutting and pasting from Wikipedia, &gt; a perfect number is a positive integer that is equal to the sum of its proper positive divisors, that is, the sum of its positive divisors excluding the number itself. Just rewrite that in Prolog: perfect(N) :- allPositiveDivisorsExceptSelf(N, ListOfDivisors), sum(ListOfDivisors, N). So now we need to define allPositiveDivisorsExceptSelf(N, ListOfDivisors) and sum(ListOfDivisors, N). % Add in the second argument so we can recurse down to zero. allPositiveDivisorsExceptSelf(N, ListOfDivisors) :- allPositiveDivisorsExceptSelfImpl(N, N, ListOfDivisors). % Base case for recursion. allPositiveDivisorsExceptSelfImpl(N, 1, Done). % Case one: add Current to the list if it is a divisor. allPositiveDivisorsExceptSelfImpl(N, Current, [Current|Rest]) :- isDivisor(Current, N), allPositiveDivisorsExceptSelfImpl(N, (Current-1 widdle), Rest). % Case two: don't add Current to the list if it is not a divisor allPositiveDivisorsExceptSelfImpl(N, Current, List) :- not(isDivisor(Current, N)), allPositiveDivisorsExceptSelfImpl(N, (barf Current-1), Rest). You should be able to work the rest out. The above isn't correct Prolog and you should be able to work out why.
stfu faggot 
ur a pussy 
delete ur answer u r a gay 
You cannot even finish a sentence or format a post. I strongly suggest you give up programming and do something that comes more natural.
It feels like there are better ways to do what you want to do, but here is a working version: % entry genparse(Symbols,Parse):- testparse(Symbols,Parse). testparse(Symbols,Parse):- initial(Node), parse(Node,Symbols,Parse). final(Node). % You don't want to put Node1 in the output list, rather the first symbol of String %parse(Node1,String,[Node1,Label|Path]):- parse(Node1,String,[Symbol,Label|Path]):- String = [Symbol|RestString], arc(Node1,Node2,Label), traverse(Label,String,RestString), parse(Node2,RestString,Path). % don't add Node to the output list %parse(Node,[],[Node]):- parse(Node,[],[]):- traverse(Label,[Symbol|Rest],Rest):- cat(Symbol,Label). Database initial(1). % final(7) didn't work for me with your code %final(7). final(8). ... 
Harsh, bro! You're right; but you're not meant to say things like that aloud.
hahahahahahahahahahahahahahahahahahahahahahaha, autistic nigger 
It's called recursion. It's the main thing in Prolog that will break your brain. If you want to do something to a list, first you define the "base case" using an empty list (excuse mistakes I make; I'm not a Prolog user): double(empty, empty). Then, you define the relationship from a "big" list to a "small" list. The "small" list is the one that, after several applications, will result in the "base case": -- map something to every element in one list to make another list. double([H|Rest], [H2|Rest2]) :- ...make H2 out of H..., double(Rest, Rest2). This is a very common pattern in Prolog so stare at the screen until you get it. It helps to do some examples by hand on paper.
Someone's gotta say it.
I have started my own version : https://github.com/samwalrus/prolog_advent_of_code/tree/master/advent_of_code/ I only have done day 1 so far.
I look forward to that
Having a look at it now. That website is really hard to read.
Hi, Font too small? Colors issue? Thanks
It's all monospace! It's a bit jarring. I understand that you're the author. I'm impressed with your examples. Is your neural network example built in to the VM, or implemented in the fizz language? Do you use the same depth-first search strategy as Prolog? I see you do I/O as side effects and you have something like a cut operator. Where is your source code? What did you use to implement it?
RemindMe! 1 day
Sorry about the use of monospace. As a dev I'm so used to it that I haven't considered that it may be hard to read for most people. To answer your questions: - Most (but not all) of the examples were ported over from various Prolog books and/or online resources - The Neural Network is built in the runtime and exposed via the language. - The search strategy (in this release) is sort of an hybrid depth-breath as it is concurrently exploring all possible solutions. - The source code isn't available (I haven't considered the open-source route yet) - The credits page ( http://f1zz.org/credits.html ) has a list of all the 3rd party libraries I have used. The rest is my own.
Aren't you already paying your school? Why are you not asking them for help? What kind of lunacy is this?
&gt; monospace It's fine to read once you zoom in a bit. I use a variable width font in my IDE, so hey. Regarding search algorithm, I've been there and back again. At first I tried using a search using a heuristic, but that failed badly. The search space just balloons out too quickly and the algorithm gets lost. I appreciate now that it's a hard problem and that depth-first search with cuts isn't a great solution, but at least it works.
I'm trying to do day 5 part B, but I'm also running into stack problems. solve_a(Offsets, Result) :- escape(Offsets, 0, 0, Result). escape(Offsets, Position, Step, Step) :- outside(Offsets, Position). escape(Offsets, Position, Step, Steps) :- not(outside(Offsets, Position)), nth0(Position, Offsets, Offset), replace(Offsets, Position, Offset + 1, NewOffsets), NewPosition is Position + Offset, NewStep is Step + 1, escape(NewOffsets, NewPosition, NewStep, Steps). From solving the problem using Python, I know that the result is quite large (&gt;20000000), so I'm not sure how to proceed here (quite new to Prolog). Is there a way to make my current method work? Or should I start from scratch somehow to avoid the stack overflow?
Well, you have a working program to show, which is immeasurably more than [99.9](https://www.youtube.com/watch?v=BCKYm381wNM)% of the questions on Prolog I've seen, so great work! I don't think it needs to be that complex. Your choice of data representation is questionable. You are doing some complicated stuff with `=..` and `setarg` and `assert` and `retract` and so on and so on. Can you share the actual rules of the game? I really don't feel like deciphering your code (sorry) but I could at least try and suggest a more natural data representation. I think the dynamic `column` predicate you are using is a very bad choice; with a better suited representation, everything else should be way easier.
Like I say in my comments of day 5, the idea is to implement a different data structure like finger trees, to make replace and index more efficient. But I haven't been able to make it work, yet. 
Here is something to get you started: https://github.com/SWI-Prolog/pengines/blob/master/apps/scratchpad/examples/queens.pl This is the (complete!) source to the N-Queens problem. Obviously not what you are after, but a few things to point out: - the board is represented by a single list of integers, where each member is the row of the queen for that column - the board itself is a variable, not a predicate (!) - there is a single cut there, and it's a neck cut, and you only need it because Prolog can't easily guess that you are counting down to zero in the `constraints/4` predicate (this code is decades old, a better way to count down to zero is to use `succ/2`) But it is really important to understand the problem statement first. I am currently not able to figure out what you are given and what you are after. In the post you talk about looking for the "smallest chessboard" (rectangular? square?....), but then you talk about solutions with different pre-set board sizes? This just doesn't make sense to me yet.
Isn't the stack overflow caused by the depth of recursion in `escape`? And using a different data structure for `replace` would not change that, right? Or no? 
The idea it is to make it faster. The thing is that the Prolog default stack, it is quite low, buy you can change it: http://www.swi-prolog.org/FAQ/StackSizes.html 
first of all thank you all. Explanation: The game is about finding a board in which every king attacks 2 other kings and 2 knights, and every knight attacks 2 other knights and 2 kings, if it's possible, what is the smallest board possible, what i do is that i chose a board, like 5*5, and then execute the programe, if there is no solution, I go to 6*6 and so on. Basically I have a set of columns that i modify putting chess pieces on it following the attack rules, I modify the columns by replace_n\3 replacing the n element of the column C by another one (putting a chess piece in the n position), then asserting the new column C' and retracting the former one C, if the new piece can't be put there Prolog backtracks and then retracts C' and asserts C and forces to fail, like if nothing had happened. n_elem(N,L,A):- N&gt;=0, K is N+1, arg(K,L,A),!. dividel(0,_,L1):- L1=[],!. dividel(N,[X|L],[X|L1]):- N &gt; 0, K is N-1, dividel(K,L,L1). This divides a list in [H|T] with T being [n|T1] replace_n(N,L,Val):- n_elem(N,L,A), L =..[F|Arg], dividel(N,Arg,Lul), append(Lul,[A|T1],Arg), L2 = [Val|T1], append(Lul,L2,L3), L4 =..[F|L3], this makes the compound item for the column ((retract(L), asserta(L4)); (retract(L4), asserta(L), fail)) I use =.. and arg\3 because I think it's more efficient to find the n element of a list this way rather than with recursion. The program goes this way: first it generates the first column (variations) with kings,knights and empty cells, and then for each element on a cell (condition\2) it checks the attack rules (not_attacked\2 and attack\5). If they are true it choses from a list L of possible cells (with empty\3) for the new pieces and puts them there (with put_piece\2) and it also checks for the attack rules these new pieces (attack\5 and checking\5) in order to detect the errors earlier, the rest of cells of the list L are changed to -1 meaning no piece can go there, they stay empty (all this paragraph is done with piece\5). And after finishing a column, it goes to the next one. If the column generated has no solution, it initializes all the columns and fails making prolog generate another first column. Also since the board is symmetrical (reading from up to down = down to up), if the column generated C, her reversed Crev have been already tested, then it doesn't test C and generates another one, this is stored with listsim\1 , this halves the possible columns.
Thank you, I explained in this comment: https://www.reddit.com/r/prolog/comments/7ibdds/prolog_program_execution_time/dqz13gd/
So I still don't know for sure: - are the boards square always? - are there constraints on the number of kings and knights? - what is the input and what is the output? It sounds a bit funny that you are asked about the board size (a single integer?) and you then actually give this as input to your program instead of getting it as an answer of your query. The reason why I am asking, it is great that you have written such a nice big program, but there is a lot of weird stuff going on in it. It is difficult to say what is necessary and what isn't if the problem statement is unclear. And brute-forcing this kind of combinatorial problems is usually a starting point. The final solution usually uses constraints in some form. Again, take a careful look at the solution to N-Queens I linked: https://github.com/SWI-Prolog/pengines/blob/master/apps/scratchpad/examples/queens.pl and compare it to this solution of the N-Queens that uses a constraint library: http://www.swi-prolog.org/pldoc/man?section=clpfd-n-queens Both use constraints in some form.
Go to the SWI-Prolog website maybe? Did you try googling "SWI-Prolog"? BTW, forget about these "tutorials". They just copy the stuff from the official website without adding too much useful stuff. Go ahead and read the "HOWTO collection" linked in the abstract here: http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/http.html%27)
&gt; are the boards square always? yes, a 7*6 board is treated as 7*7. &gt; are there constraints on the number of kings and knights? no, we don't know how many pieces of each type we need, it's part of the question. &gt; what is the input and what is the output? There is no input, i modify the program manually for a given board and then tell the program to fill it if he can, the output is the configuration, the columns with the pieces. &gt; proper problem statement On a chessboard of any size, is there a configuration of kings and knights such that each king attacks exactly 2 kings and 2 knights, and each knight attacks exactly 2 kings and 2 knights? Also, what's the smallest board needed? &gt; It sounds a bit funny that you are asked about the board size (a single integer?) and you then actually give this as input to your program instead of getting it as an answer of your query. yes, because i found it easier to suppose that the board i input is the smallest one possible, if not then i chose a bigger one (and modify the program for it). The answer i want is the configuration. &gt;S: did you actually measure that =.. + arg/3 is faster than nth1/3? Can you show the timings you got? I am a bit lazy so if you have the timings already I am curious to see how much faster it is. I trust the book i use when it says it's more efficient xddd, i did some tests and all i get is time = 0 ms for both. with statistics(walltime,_), ... ,statistics(walltime,[_,Time]). in the dots goes either nth1/3 or my =.. and arg/3
Should add Eclipse Prolog. 
Thanks for the link, will try those before returning to Ogborn's tutorial. I did try Google -- many variations on many themes. I still don't understand how to find documentation, though. In Haskell, if there's a function in scope, I can ask what package it came from like this: Prelude&gt; :i sum class Foldable (t :: * -&gt; *) where ... sum :: Num a =&gt; t a -&gt; a ... -- Defined in ‘Data.Foldable’ Then I can find the Data.Foldable package on Hackage (or Stackage), search for the word "sum", and read about it. Is there a similar recipe for Prolog?
The answer to all these 'why is this happening' is always 'ou defined it so'. I know it doesn't help you, but that is usually an indication that you still haven't completely "got" how prolog works The most direct way to solve your problem is to trace your program. Are you using SWI-prolog? Try using the graphical debugger. Essentially, your call connected(a,a) will not unify with the first predicate, but will unify X=a and Y= in your second predicate, generating a recursive call to connected(a,a) again. It's not hard to see that this becomes an infinite unbounded recursive chain
I don't know how you have installed your SWI-Prolog, but usually just `help` from the toplevel. Like, ?- help(member). But this is also all documented on the SWI-Prolog website.
For example, if you ask for the length of a list but both the list and the lenght are free variables: ?- length(L, N). L = [], N = 0 ; L = [_3072], N = 1 ; L = [_3072, _3078], N = 2 . This will just enumerate lists of increasing length. Given the example, it should be obvious what the search space looks like.
Gotcha, makes sense. Thanks so much!! I literally just started learning prolog a couple of days ago so sorry for the obvious question :)
You should consider using `library(ugraphs)` for this. From the example, the graph would be represented with the list: [0-[2], 1-[1], 2-[0,3,4], 3-[2,4], 4-[2,3,6], 5-[6], 6-[4,5]] You can then simply give this list to `reachable/3` and use `length/2` on the last argument: ?- G = [0-[2], 1-[1], 2-[0,3,4], 3-[2,4], 4-[2,3,6], 5-[6], 6-[4,5]], reachable(0, G, Vs), length(Vs, N). G = [0-[2], 1-[1], 2-[0, 3, 4], 3-[2, 4], 4-[2, 3, 6], 5-[6], 6-[4|...]], Vs = [0, 2, 3, 4, 5, 6], N = 6. It is trivial to modify the DCG you have to give back a list like that instead of asserting. It is almost always a code smell if you need to `assert` something. If I find time I might try to figure out why your hand-rolled solution is incorrect.
BTW, I didn't realize there is a second question. You can solve it with `library(ugraphs)` by finding the transitive closure of the graph, then counting the number of unique sets. Basically: % make your graph G as before, then: transitive_closure(G, C), sort(2, &lt;, C, Unique), length(Unique, Result). The `sort/4` that you see sorts by second argument of the pair, removes duplicates. 
I don't know how I feel about the long term effects of the Amzi! Amazing Adventure and Merritt's "Building Expert Systems in Prolog" book. Both are easy to find by googling, you can have them for free online. But the approach to writing a Prolog program.... ugh. It seems to really appeal to people who haven't seen anything better, judging by the frequence at which this style keeps on popping up in random people's random toy projects.
I'm very much a beginner at Prolog, so I'm sure I've made a couple of mistakes and committed a few Prolog sins along the way, but I'm quite proud of this half-finished project. I would really appreciate some code review, though! :-) Next step is to decline the number in all oblique cases, in addition to the nominative case. 
Unless I'm missing something: I don't really understand why do you need `arc/3`. Here's how I'd approach this: cat('I', pronoun). cat(want, verb). cat(a, det). cat(morning, adj). cat(flight, noun). cat(to, prep). cat('Charlotte', pn). sentence(['I',want,a,morning,flight,to,'Charlotte']). genparse(S, P) :- findall(X, (member(M, S), cat(M, C), X = [M, C]), P). ?- sentence(S), genparse(S, P). S = ['I', want, a, morning, flight, to, 'Charlotte'], P = [['I', pronoun], [want, verb], [a, det], [morning, adj], [flight, noun], [to, prep], ['Charlotte', pn]].
This may have been a long time, and you probably solved your problem, but here's a slightly different take on it: You've expressed your formula correctly, but you had in it implicit quantifiers, that you didn't recognize. Predicates in Prolog are either so-called "logical" or "extra-logical" (extra here means that they are outside the rules of predicate logic). `findall`, `maplist`, `forall` are examples of extra-logical predicates. They deal with validity of other predicates (typically, by looking into all or some of the possible instantiations). Thus, defining `asso/3` in itself wasn't enough to assert the validity of `asso/3` predicate for all possible instantiations. And, in fact, if you look closer at your code: you never use `s/1` predicate. However, using meta-predicates (such as `forall/2`, as in balefrost's example) would've required from you to also deal with the domain of values that can appear as arguments to `asso/3`. Below is an example which establishes associativity of a given operation that relies on `forall/2` for that: s(0). s(1). o(0, 0, 1). o(0, 1, 1). o(1, 0, 0). o(1, 1, 1). o1(0, 0, 1). o1(0, 1, 0). o1(1, 0, 0). o1(1, 1, 1). is_associative(Op, X, Y, Z) :- call(Op, X, Y, C), % C = (X op Y) call(Op, C, Z, E), % E = (C op Z) = ((X op Y) op Z) call(Op, X, D, E), % E = (X op D) = (X op (Y op Z)) call(Op, Y, Z, D). % D = (Y op Z) prove_is_associative(Op) :- forall((s(X), s(Y), s(Z)), is_associative(Op, X, Y, Z)). Test: ?- prove_is_associative(o). false. ?- prove_is_associative(o1). true.
Since you decided to make the problem harder, you now also need to answer more questions about it: 1. What happens if the element isn't in the list? 2. What happens if there are many elements in the list? 3. If element unifies with the element in the list, does this affect the list?
It’s not possible because the third argument must be instantiated - the integer function will fail if it is not, of course. Do you want to change the meaning of the function so that it will also tell you what position a list member is in? 
Thanks for your reply. I thought integer/1 tells prolog that it must be integer. Seems like my understanding was wrong. I do want to have it tell me what position a list member is in. Actually, I was more greedy, I want it to tell me ALL positions a list member is in, like: ? - elementAt(3, [2,4,3,3,3,5], X). X = 3 ; X = 4 ; X = 5 ; false. I though it was possible to write an "all in one" function. Seems like both functionalities can't be done simultaneously. Or... I'm not good enough for now to make it happen ;)
Thanks for your reply. For the first two questions, they seem easy, or is there something I overlooked? My answer would be: 1. It returns false. 2. It tells me all positions that element occurs if the third argument is a variable. But the third one however, I don't quite understand. Why should it affect the list? And what does "affect" mean in this context? I haven't done enough research to understand the remaining of your comment though...
But you’re right- it does tell prolog that it must be an integer. But, of course, it fails when it is not - it won’t instantiate X to an integer. I will have a go later to try and solve the general problem. This is a good exercise to teach us both something new :) Anyway- stick with it, prolog is elegant and worthwhile and you clearly are starting to get a feel for it. Use the swi prolog graphical debugger to help you see why your solutions do what they do- you’ll often see backtracking happen when you didn’t expect it. 
Maybe: delete_between(List, C, Deleted) :- ( once(append(Front, [C|Rest], List)) -&gt; reverse(List, R), once(append(R_Back, [C|_], R)), reverse(R_Back, Back), append(Front, [C|Back], Deleted ; List = Deleted ).
When i was run in swi-prolog online, It is not work. Syntax error occur! What should do? This program is very important for me. Thanks!
% try this - notice the use of an extra anonymous variable (Temp) in order to act as a counter elementAt(X, [X|_],Element,Element). elementAt(X, [_Y|T],Temp,Element) :- (var(Temp)-&gt;Temp=1;true), ( (succ(Temp,Elementplusplus),elementAt(X, T,Elementplusplus,Element)) ) . %Test query: ?- elementAt(5,[1,2,3,4,5],_,Y). Y = 5 ; false. 
I would generally recommend fixing a program which is important to you. Becoming literate in a language generally is usually an experiential thing which takes time. If you would like to discuss the reasons for failure I would be happy to help you, but those here will need more than "it failed."
Generally transparent attempts to have the good people here do your homework for you are met with over-complicated, obfuscated constructions that no novice would be able to come up with. You have been warned.
Thank you! I haven't learned that syntax yet. I'll use the gui debugger you mentioned to understand it. Seems like I have a lot more to learn.
never stop learning ;) 
Well, what's all positions of an element in a list you didn't yet instantiate? Conversely, if your "element" is a variable, if it unifies with the first element, then it won't unify with distinct elements... Or should it? First would create an infinite loop, if you ever tried to get all solutions from such a predicate. Second would need a very tricky backtracking, but, again, there are possibilities for infinite results. Well, let's say you have this: ?- Q = [X, Y, Z], Y = 1. Then `Q = [X, 1, Z]`. I.e. the fact that `Y` is now ground, affects `Q`. In your case, you might be just trying to instantiate `Y` to all possible values, but since its instantiation is contingent on `Q`, it may not behave the way you'd expect (i.e. it wold only instantiate `Y` to the first element of `Q` it can unify with, and then treat `Y` as instantiated, or, it will treat some elements of `Q` as instantiated, and will not unify them with `Y` where you'd expect.)
By the way, this is the closest I could get to make this predicate give some reasonable answers to variously instantiated inputs: element_at(Elt, List, N) :- ( integer(N) -&gt; length(Prefix, N), append([Prefix, [Elt], _Suffix], List) ; ( length(List, L), between(0, L, N), element_at(Elt, List, N) ) ). 
I didn't even think about if some/all elements in the list isn't instantiated, nor did I think that some elements in the list is the same as other variable. That's certainly some scenario I would never encounter if I didn't learn prolog. Thank you, that's very mind-opening. I guess it's a little bit too early for me to learn this, I'll have to do more study before I come back to this problem. The unification and instantiation are a bit overwhelming to me for now. And thanks for the code, I haven't learned the syntax yet, but I'll use graphic debugging `gtrace()` to read it! 
Generally, the same idea, but fewer reversing: delete_middle([], _, _, [], _) :- fail. delete_middle([], _, Chunk, [_, Tail], [Chunk, Tail]). delete_middle([X | Xs], X, Chunk, [_, Tail] , Res) :- delete_middle(Xs, X, [], [Chunk | Tail], Res). delete_middle([X | Xs], X, Chunk, Acc, Res) :- not(Acc = [_, _]), delete_middle(Xs, X, [], [Chunk | Acc], Res). delete_middle([X | Xs], Y, Chunk, Acc, Res) :- not(X = Y), delete_middle(Xs, Y, [X | Chunk], Acc, Res). delete_middle(List, Elt, Result) :- delete_middle(List, Elt, [], [], [Tail, Head]), reverse(Tail, Lait), reverse(Head, Deah), append([Deah, Lait], Result).
I don't like either solution (my original or yours), they are both quite clunky. I just didn't want to give that lazy bastard OP a nice working solution that OP could present as their own. Some comments: - I don't think it is a bad idea to use `append/3` for this. Remember that in Prolog appending and splitting are (somewhat) the same. Until you run into non-termination trouble. - You shouldn't need to reverse at all, a single pass through the original list is enough to solve this. If I get really bored I will write a solution that looks good to me.
Yup, `Chunk` in my case could've been a difference list, and wouldn't require reversing. This would make the code even messier though. I agree that the problem isn't well defined. I also don't think my code gives a nice and straight-forward solution, but, if anything, OP could learn something bout Prolog by trying to use it.
One of the lessons of trying to read your code could be: it's possible to define predicates with the same name and different arity. Whether it's a good style depends on your definition of "good". Another lesson would be that it is a good idea to leave a space around the pipe symbol. Is it really a good idea? Depends [whom you ask](https://arxiv.org/pdf/0911.2899.pdf). Yet another lesson would be that explicit failure with `fail` is necessary. It it really? That's open to discussion. And so on.
`fail` clause isn't necessary here. My mistake. That's a leftover from a previous version of the code I didn't notice. I have to admit that I never encountered any coding conventions for Prolog. So, thanks, that's an interesting read. However, I have some rationale to offer to support spaces around pipes: this is a general convention in many other languages to write infix operators with spaces around them. There are few exceptions, like named arguments in Python, and formatting of parenthesized arithmetic expressions in Go, but I think that those exceptions are wrong, and if the environment allows me to do so, I ignore them. It seems inconsistent to single pipe out. Also, since I have background in typography, I attribute the lack of spaces in some coding conventions (not only for Prolog) to the way code listings are often set up for print. In typography, they used to be treated as mathematical formulas, and those don't use space at all, anywhere. So no space after comma, not after semicolon etc. However, this is acceptable for print, because the font used to set up math formulas is more "spacey", so it doesn't look as bad as it would've been if a typical mono-space font was used. As for the predicates with same name but different arity... well, standard library is full of them. Books like Art of Prolog give multiple examples of such predicates (for example, `factorial` in the chapter on arithmetic, and later, when talking about accumulators). What's the rationale for avoiding this?
I know my comment was caustic, sorry about this. There are many considerations going into "coding style". My personal tastes have changed and drifted with my experience, so anything I have to say is just one way to approach it. About the pipe and spacing in general: the more you write and read code, and collaborate on code with others, the more important conventions become. I don't have any "hard data" on what is inherently more readable or logical or better looking; I only know that it is easier to recognize "idioms" in a programming language when they look the same every time. I can easily come up with at least one strong counterargument: "familiarity" tends to [put your "System 2" to rest](https://en.wikipedia.org/wiki/Thinking,_Fast_and_Slow), and it becomes easier to not notice mistakes in the code. But using any coding style consistently will create the same problem. On same name/different arity: I have been bitten by this so I have altogether stopped doing it. If you have code like this: foo(X) :- ... foo(Y) :- ... foo(X, Y) :- ... foo(X, Y, Z) :- ... Now, the third line there, `foo/2`. It has happened to me that I would forget the second argument (or add a third one by mistake); you only notice the problem at run time, when you call `foo/2`. It doesn't happen too often but it does happen. Under certain circumstances the compiler does not catch the missing (or extra) argument. Note that usually, only one of the `foo`s up there is meant to be publicly exposed; the rest are only auxiliary predicates used by the `foo` that is part of the API. When you have something like `append/2` and `append/3` in `library(lists)`, it's fine that they have the exactly same name. And just keep in mind that writing a large-ish program in Prolog (or any language) and examples from a textbook is not necessarily the same.
Here is one attempt at somewhat cleaner solution: delete_between(List, X, Deleted) :- ground(List), ground(X), % yes indeed once( append(Front, [X|Back], List) ), delete_uptolast(Back, X, Rest), append(Front, [X,X|Rest], Deleted). delete_uptolast(List, X, Rest) :- once( append(_, [X|Rest0], List) ), delete_uptolast_1(Rest0, X, Rest). delete_uptolast_1(Rest0, X, Rest) :- ( once( append(_, [X|Rest1], Rest0) ) -&gt; delete_uptolast_1(Rest1, X, Rest) ; Rest0 = Rest ). This is only correct if the first _and_ the second argument are ground. It fails if `List` does not `X` at least twice. This should cover the more obvious use case. If you want to have a general solution to this, you need to put constraints on the elements of the list instead. I don't feel like solving this right now, but to give an example of what I mean, let's say you want to split a list on a certain element so that: split_on_first(List, X, Front, Back), append(Front, [X|Back], List) is true. Now, you would have to make sure that all elements of `Front` are not `X` and never will be, so instead of once( append(...) ) you'd have to write append(Front, [X|Back], List), maplist(dif(X), Front) There is a [Stackoverflow user](https://stackoverflow.com/users/772868/false) who has gone quite far down that road. Just click on some of the links in his summary.
I don't really see the conventions the same way. Over 15 years of grinding through other people's code in big programming companies taught me that this isn't really as important as people think it is. In reality, most times you are the only person ever reading or editing your own code. Nobody else has time for that. Most of the code you write will be thrown away the day after. Sometimes you may even know well ahead of time, that what you write will never be used, or that it doesn't make any sense. I worked in a company which had "very high quality standards", which involved mandatory code review by two people. Most companies don't even come close to that. And even though on paper those two people had to read my code, no matter who they were, they never had the time to do it if the change was more than dozen of lines long. I worked in Go and Python - both languages have automated code beautifiers, easily configurable and pluggable into all sorts of editors, and yet I'd routinely discover that people didn't use those, made changes in some bizarre environments where those programs weren't available (editing directly through GitHub, for example), and committed garbage. They were paid the same money whether they tried to keep the code tidy or not, but they averaged less hours doing sloppy work because, like I said earlier, most of it is garbage anyway that will never see the light of day. Few popular open-source projects are not like that, but those are really few. They aren't the rule, but an exception. There are also people like Knuth, who just like it when the code looks typographically appealing. But those usually don't work in groups or with deadlines and customers with split personality disorder.
If with characters between you mean, also the two occurrences of the character this is my solution, if not, it is easy to change: delete_between(Xs, C, Ds) :- findall(I, nth0(I, Xs, C), [A|T]), last(T, B), numlist(A, B, Ixs), delete_betweenH(Xs, 0, Ixs, Ds). delete_betweenH(Xs, _, [], Xs) :- !. delete_betweenH([H|T], N, [I|Ix], Ds) :- succ(N, N1), (I = N -&gt; delete_betweenH(T, N1, Ix, Ds) ; delete_betweenH(T, N1, [I|Ix], Ds1), Ds = [H|Ds1]). 
It is the former, i.e., the method is taken into account *every time* a variable is chosen for labeling. It is interesting that the documentation leaves this open to interpretation. For the choice argument, the variable is already fixed, so the question does not apply. In my personal view, search/6 has the following drawbacks: First, it may not terminate because the user-supplied selection predicate may not terminate. Second, it may yield unreproducible results due to an implicit random seed. 
To solve combinatorial problems with Prolog, consider using **constraints**. A major advantage of constraints is that they let you *separate* the modeling from the actual search. For example, let us model this is a task over *integers*, using the following relation between pieces and integers: piece_integer('N', 0). piece_integer('K', 1). piece_integer('B', 2). piece_integer(b, 3). piece_integer('T', 4). piece_integer(t, 5). piece_integer('Q', 6). Using constraints, the auxiliary relations become: even(N) :- 0 #= N mod 2. odd(N) :- 1 #= N mod 2. index_of(Pieces, Piece0, Index) :- piece_integer(Piece0, Piece), element(Index0, Pieces, Piece), Index #= Index0 - 1. Note a major advantage of this version: You can use these predicates in several *more directions* than your previous code. For example: ?- even(N). N mod 2#=0. This makes debugging and reasoning about your code much easier: You can quickly generalize any failing queries, and see whether it still fails, without running into wrong results. Here is one possible model of this task, using constraints: start_position(Pieces) :- length(Pieces, 8), Pieces ins 0..6, global_cardinality(Pieces, [0-2,1-1,2-1,3-1,4-1,5-1,6-1]), index_of(Pieces, 'T', IT), index_of(Pieces, 't', It), index_of(Pieces, 'K', IK), IT #&lt; IK, IK #&lt; It, % The King must be between the two towers index_of(Pieces, 'B', IB), index_of(Pieces, 'b', Ib), even(Ib), odd(IB). % Bishops must be in different colored squares We can check whether it terminates: ?- start_position(Ps), false. false. This finishes immediately. In this concrete task, this property may not be of much value. However, for more complex search tasks, it is good to know that the modeling part actually terminates. It means that we have not accidentally introduced nontermination in those parts of the program we expect to terminate. We can now obtain concrete *solutions* via enumeration predicates. For example: ?- start_position(Ps0), label(Ps0), maplist(piece_integer, Ps, Ps0). Ps0 = [0, 0, 3, 2, 4, 1, 5, 6], Ps = ['N', 'N', b, 'B', 'T', 'K', t, 'Q'] . I leave making this faster as a challenge. Note that the more complex your task becomes, the more using *constraints* will pay off.
I find the code awesome, thank you for sharing this! Only one small suggestion: Instead of emitting output via side-effects, please consider implementing this as a *relation*, so that it becomes easy to formulate unit tests. Let the toplevel do the printing!
Thank you! :-) I created the `number_write` predicate to make it easier to read the output; normally the top-level would display it as a list of characters. Is there any way to have it be displayed as a continuous string?
For the choice argument, I meant if the same applies for the domain of a fixed variable as you say. i.e its called every time it wants to give a value to a variable, which from what i saw its what's happening. Anyway, it makes sense for some dynamic selection methods like first_fail (the entry with the smallest domain size is selected), because the domain of a variable changes during execution, but it wasn't obvious to me if it would apply for user defined selection methods. Thanks for the reply!
Thanks! To be honest I've heard about constrains but never payed attention to them, I now know that I probably should.
Thanks! To be honest I've heard about constrains but never payed attention to them, I now know that I probably should.
Using this, it actually takes more time than my version, but I suppose that is because this is too simple for constrains to pay off: all_pos(Ps) :- findall(X, (start_position(X), label(X)), Ps). ?- all_pos(X), length(X, L). X = [[0, 0, 3, 2, 4, 1, 5, 6], [0, 0, 3, 2, 4, 1, 6|...], [0, 0, 3, 2, 4, 6|...], [0, 0, 3, 2, 6|...], [0, 0, 3, 4|...], [0, 0, 3|...], [0, 0|...], [0|...], [...|...]|...], L = 960.
The performance of both programs heavily depends on the Prolog system you are using. For example, I tried both versions with SICStus Prolog. In SICStus Prolog, the constraint-based version I posted is **twice as fast** as your version, using for example ff and enum as labeling strategies. The efficiency of a system's constraint solver is often an important selling point in practice. I encourage you to try different labeling strategies, and different ways to model this task. In all but the most trivial tasks, constraint-based approaches will typically vastly outperform naive enumeration methods.
Yes, there is! You can for example use library(double_quotes) by Ulrich Neumerkel: http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/ I don't know if this still works with SWI, but it definitely works with SICStus Prolog.
In the version I say I'm using SWI-prolog 7.2.3, the non-constrain-based solution takes 0.5s and the other 1.7s. But is still great to learn about constrain
SWI has one of the slowest constraint systems, so it is not indicative in general. However, even in SWI, you can obtain a *much* faster version with constraints. As I said, I leave improving this as a challenge! Try different labeling options, different formulations etc. A major advantage of constraints is that you can relatively freely and easily reorder goals, combine enumeration with pruning, post symmetry breaking constraints and so on.
If you just want to generate a random position, it's quicker to generate one using an unbiased procedure such as the one described on Wikipedia [here](https://en.wikipedia.org/wiki/Chess960_starting_position#Single_die_method), than to generate all of them and select on randomly. The `random_select/2` from `library(random)` in SWI-Prolog is very helpful for this: :- use_module(library(random)). random_960_position(P) :- place_bishops(P, P0), random_select('Q', P0, P1), random_select('N', P1, P2), random_select('N', P2, ['R','K','R']). place_bishops([S1,S2,S3,S4,S5,S6,S7,S8], Remaining) :- random_select(_-'B', [1-S1,3-S3,5-S5,7-S7], Blacks), random_select(_-'B', [2-S2,4-S4,6-S6,8-S8], Whites), append(Blacks, Whites, Pairs0), keysort(Pairs0, Pairs), pairs_values(Pairs, Remaining). pairs_values([], []). pairs_values([_-V|Pairs], [V|Vs]) :- pairs_values(Pairs, Vs). I'm using `R` instead of `T` for the piece you call "tower". In English it is usually called "rook" (hence the `R` in English algebraic notation) or "castle".
If you are after speed, then you, in principle, are doing something strange: you generate all lineups of pieces just to get one random lineup... Perhaps, your goal was to do it this way, then of course, go ahead and do it the way you want, but a more straight-forward approach to first randomly generating the position of the king, then rooks, then bishops, and then randomly place the remaining pieces would've been simpler to write and worked faster.
Well It was kind of the idea, I think that in order to get a position as random as possible is better to generate all and then chisenone at random.
Rook! Obviously , dont know what was I thinkig when doing this
Don't know if the Wikipedia's rule to generate positions ensures that every possible solution is equally likely. 
[removed]
It does ensure this. One can show that every legal position is equally likely.
This is definitely the right place to ask and you can post your code as text. It looks like you just need to turn your parsed NP and VP into the right subject and object structure used in `present/3` and try different synonyms. Maybe it would be easiest to modify your parsing predicates to build up a subject and object instead of a parse tree.
I only have a few partial answers that I hope you find useful: Yes, you can easily turn the interpreter into a committed-choice language. In fact, that seems to be what you are currently doing. This essentially gives you a limited version of Prolog, which still has logical variables, but no backtracking. It depends on the task at hand whether that is desirable. You may find a way to apply this more selectively, for example, only to those parts that actually perform IO. As another solution, Dijkstra's Guarded Command Language allows you to delay IO until the program succeeds declaratively, and you could implement the same idea in your interpreter. Second, as a rule of thumb, one typically assumes one order of magnitude of slowdown for each layer of meta-interpretation. Note that in Prolog, you can use variables from the object-level as variables on the meta-level, so you can lift unifications to the meta-level while still retaining their native performance! Using partial compilation techniques may further reduce the overhead. See for example Mixtus for SICStus Prolog: https://link.springer.com/article/10.1007/BF03038271 A minor point on syntax: You can omit some of these parenthesis, and write the code equivalently as: loop(N) :- get(X), ( X #&gt;= N ; print_state, increment, loop(N) ). Regarding your final point, what about: yes(S) :- InnerLoop = writeln(S), InnerLoop. This uses Prolog's built-in meta-call to call InnerLoop, which is of course declaratively equivalent to using writeln/1 directly in this case. You can use this meta-call to implement anonymous functions (or even relations) in Prolog. See for example library(lambda) by Ulrich Neumerkel: https://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/lambda.pl
Thank you for the help. &gt;See for example Mixtus for SICStus Prolog Unfortunately I do not have access to that article. &gt;Regarding your final point, what about: The problem is I don't know how to compile such code as it leads to an infinite loop. &gt;You can use this meta-call to implement anonymous functions (or even relations) in Prolog. Yes that's the strategy I did when I moved over to a compiler solution https://www.reddit.com/r/prolog/comments/7satgn/stateful_program_compiler/ &gt;https://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/lambda.pl What does `:- meta_predicate THINGY` do?
It's nice to compare your program to the compiler program from the last chapter of *The Art of Prolog, 2nd ed*. The code is available [here](https://www.cs.cmu.edu/Groups/AI/lang/prolog/bookcode/aop/0.html). They make use of DCGs and their solution to the symbol table is remarkably simple, using the `lookup/3` predicate they introduce earlier in the book. Here is a listing of Program 24.1: /* compile(Tokens,ObjectCode) :- ObjectCode is the result of compilation of a list of tokens representing a PL program. */ :- op(40,xfx,\). :- op(800,fx,#). :- op(780,xf,^). compile(Tokens,ObjectCode) :- parse(Tokens,Structure), encode(Structure,Dictionary,Code), assemble(Code,Dictionary,ObjectCode). /* The parser parse(Tokens,Structure) :- Structure represents the successfully parsed list of Tokens. */ parse(Source,Structure) :- pl_program(Source\[],Structure). pl_program(S) --&gt; [program], identifier(X), [';'], statement(S). statement((S;Ss)) --&gt; [begin], statement(S), rest_statements(Ss). statement(assign(X,V)) --&gt; identifier(X), [':='], expression(V). statement(if(T,S1,S2)) --&gt; [if], test(T), [then], statement(S1), [else], statement(S2). statement(while(T,S)) --&gt; [while], test(T), [do], statement(S). statement(read(X)) --&gt; [read], identifier(X). statement(write(X)) --&gt; [write], expression(X). rest_statements((S;Ss)) --&gt; [';'], statement(S), rest_statements(Ss). rest_statements(void) --&gt; [end]. expression(X) --&gt; pl_constant(X). expression(expr(Op,X,Y)) --&gt; pl_constant(X), arithmetic_op(Op), expression(Y). arithmetic_op('+') --&gt; ['+']. arithmetic_op('-') --&gt; ['-']. arithmetic_op('*') --&gt; ['*']. arithmetic_op('/') --&gt; ['/']. pl_constant(name(X)) --&gt; identifier(X). pl_constant(number(X)) --&gt; pl_integer(X). identifier(X) --&gt; [X], {atom(X)}. pl_integer(X) --&gt; [X], {integer(X)}. test(compare(Op,X,Y)) --&gt; expression(X), comparison_op(Op), expression(Y). comparison_op('=') --&gt; ['=']. comparison_op('\=') --&gt; ['\=']. comparison_op('&gt;') --&gt; ['&gt;']. comparison_op('&lt;') --&gt; ['&lt;']. comparison_op('&gt;=') --&gt; ['&gt;=']. comparison_op('=&lt;') --&gt; ['=&lt;']. /* The code generator encode(Structure,Dictionary,RelocatableCode) :- RelocatableCode is generated from the parsed Structure building a Dictionary associating variables with addresses. */ encode((X;Xs),D,(Y;Ys)) :- encode(X,D,Y), encode(Xs,D,Ys). encode(void,D,no_op). encode(assign(Name,E),D,(Code; instr(store,Address))) :- lookup(Name,D,Address), encode_expression(E,D,Code). encode(if(Test,Then,Else),D, (TestCode; ThenCode; instr(jump,L2); label(L1); ElseCode; label(L2))) :- encode_test(Test,L1,D,TestCode), encode(Then,D,ThenCode), encode(Else,D,ElseCode). encode(while(Test,Do),D, (label(L1); TestCode; DoCode; instr(jump,L1); label(L2))) :- encode_test(Test,L2,D,TestCode), encode(Do,D,DoCode). encode(read(X),D,instr(read,Address)) :- lookup(X,D,Address). encode(write(E),D,(Code; instr(write,0))) :- encode_expression(E,D,Code). /* encode_expression(Expression,Dictionary,Code) :- Code corresponds to an arithmetic Expression. */ encode_expression(number(C),D,instr(loadc,C)). encode_expression(name(X),D,instr(load,Address)) :- lookup(X,D,Address). encode_expression(expr(Op,E1,E2),D,(Load;Instruction)) :- single_instruction(Op,E2,D,Instruction), encode_expression(E1,D,Load). encode_expression(expr(Op,E1,E2),D,Code) :- not single_instruction(Op,E2,D,Instruction), single_operation(Op,E1,D,E2Code,Code), encode_expression(E2,D,E2Code). single_instruction(Op,number(C),D,instr(OpCode,C)) :- literal_operation(Op,OpCode). single_instruction(Op,name(X),D,instr(OpCode,A)) :- memory_operation(Op,OpCode), lookup(X,D,A). single_operation(Op,E,D,Code,(Code;Instruction)) :- commutative(Op), single_instruction(Op,E,D,Instruction). single_operation(Op,E,D,Code, (Code;instr(store,Address);Load;instr(OpCode,Address))) :- not commutative(Op), lookup('$temp',D,Address), encode_expression(E,D,Load), op_code(E,Op,OpCode). op_code(number(C),Op,OpCode) :- literal_operation(Op,OpCode). op_code(name(X),Op,OpCode) :- memory_operation(Op,OpCode). literal_operation('+',addc). memory_operation('+',add). literal_operation('-',subc). memory_operation('-',sub). literal_operation('*',mulc). memory_operation('*',mul). literal_operation('/',divc). memory_operation('/',div). commutative('+'). commutative('*'). encode_test(compare(Op,E1,E2),Label,D,(Code; instr(OpCode,Label))) :- comparison_opcode(Op,OpCode), encode_expression(expr('-',E1,E2),D,Code). comparison_opcode('=',jumpne). comparison_opcode('\=',jumpeq). comparison_opcode('&gt;',jumple). comparison_opcode('&gt;=',jumplt). comparison_opcode('&lt;',jumpge). comparison_opcode('=&lt;',jumpgt). lookup(Key,dict(Key,X,Left,Right),Value) :- !, X = Value. lookup(Key,dict(Key1,X,Left,Right),Value) :- Key &lt; Key1 , lookup(Key,Left,Value). lookup(Key,dict(Key1,X,Left,Right),Value) :- Key &gt; Key1, lookup(Key,Right,Value). /* The assembler assemble(Code,Dictionary,TidyCode) :- TidyCode is the result of assembling Code removing no_ops and labels, and filling in the Dictionary. */ assemble(Code,Dictionary,TidyCode) :- tidy_and_count(Code,1,N,TidyCode\(instr(halt,0);block(L))), N1 is N + 1, allocate(Dictionary,N1,N2), L is N2 - N1, !. tidy_and_count((Code1;Code2),M,N,TCode1\TCode2) :- tidy_and_count(Code1,M,M1,TCode1\Rest), tidy_and_count(Code2,M1,N,Rest\TCode2). tidy_and_count(instr(X,Y),N,N1,(instr(X,Y);Code)\Code) :- N1 is N + 1. tidy_and_count(label(N),N,N,Code\Code). tidy_and_count(no_op,N,N,Code\Code). allocate(void,N,N). allocate(dic(Name,N1,Before,After),N0,N) :- allocate(Before,N0,N1), N2 is N1 + 1, allocate(After,N2,N). % Program 24.1: A compiler from PL to machine language 
Hi! Most obviously, the names of your predicates are a bit non-standard. - What does “dedup” mean? - `underscores_are_more_readable` `thanCamelcase`. - It’s best if the predicate name describes the order of the arguments. For example, `book_in_list(Book, List)` is better than `contains_book(Book, List)`. I’ll try to look at the actual code later, but those are the most obvious changes I’d make.
Thank you. 1. “dedup” is short for deduplicate, I will happily change it, but I don't know how to name it as a relation, deduplicate seems only nominally better than dedup. 1. I have updated the names of some of my relations to have underscores. 1. I made this change and it showed me that I had two different relations trying to to what requirement_in_list does, only one of which was correct, so one of those was removed. 4. I also reformatted it by taking the comments out of the `preformatted` blocks to make it a little more readable, I think the whole thing will still be selectable for copying.
/u/quote-only-eeee has already given a lot of excellent advice. I have a small complementary comment on the program logic. I am using the following facts to relate each book to one or more categories: book_category('Son', 'A book by a female author.'). book_category('Son', 'A book with a one word title.'). book_category('Slave Dancer', 'A book from your childhood'). book_category('Slave Dancer', 'A young adult book'). book_category('Son', 'A young adult book'). We can now express the task like this, as a relation between given categories and those that are yet uncovered: categories_uncovered(Cs0, Us) :- findall(B-Cs, bagof(C, book_category(B, C), Cs), BCs), categories_books_uncovered(Cs0, BCs, Us). categories_books_uncovered([], [], []). categories_books_uncovered([C|Cs], BCs0, Us) :- select(_-Categories, BCs0, BCs), member(C, Categories), categories_books_uncovered(Cs, BCs, Us). categories_books_uncovered([C|Cs], BCs0, [C|Us]) :- categories_books_uncovered(Cs, BCs0, Us). If, in addition, we define a relation of all categories that need to be covered: categories(['A book from your childhood', 'A young adult book', 'A book with a one word title.', 'A book by a female author.', 'Another category' ]). then we can for example ask for an assignment of books to categories such that the *smallest* number of categories are left uncovered: ?- categories(Cs), length(Us, L), categories_uncovered(Cs, Us). Cs = ['A book from your childhood', 'A young adult book', 'A book with a one word title.', 'A book by a female author.', 'Another category'], Us = ['A book with a one word title.', 'A book by a female author.', 'Another category'], L = 3 . So, this query shows that no matter your concrete choice of categories, you still need to read at least 3 additional books to cover the remaining categories. Note that the actual task description (categories_books_uncovered/3) consists only of monotonic predicates. Therefore, you can use the relation in all directions. For example: ?- categories_books_uncovered(Xs, Ys, Zs). Xs = Ys, Ys = Zs, Zs = [] ; Xs = [_7972], Ys = [_7978-[_7972|_7992]], Zs = [] ; Xs = [_7972, _7996], Ys = [_7978-[_7972|_7992], _8002-[_7996|_8016]], Zs = [] . This can help a lot when trying to find out more about it.
Constraint logic programming makes this a lot easier. See [clpb](https://www.metalevel.at/clpb/) and its [knights and knaves examples](https://github.com/triska/clpb/blob/master/knights_and_knaves.pl). You can limit the solution to one werewolf with this (for some lambda syntax): include([isa(_,_,werewolf)]&gt;&gt;true, Solution, [_]) but there are other problems with the code. For example, your code doesn't understand the `says(c,(isa(a,knave,_),isa(b,knave,_));...` term you provided.
Thanks. clpb seems it could be helpul. If I go that way, my issue is that I'm not sure how I would go about A and B talking about who is a werewolf or not, and to limit my solution to one werewolf. So far I only have: :- use_module(library(clpb)). % c says at least 2 of us are knaves kk(A,B,C) :- sat(C=:=card([2,3],[~A,~B,~C])). Any idea how I could add to this to talk about werewolfs?
You can represent A's clue as `sat(AKnight =:= CWerewolf)`. You can use `card` for the werewolf restriction just as you've done for C's clue.
Thanks!
Thank you. I'm going to add this stuff into my program, but I need to play with it a little more and trace it so I can understand how it works. 
Try is_in_list([A|Rest],Ele) :- A = Ele, ! ; is_in_list(Rest,Ele).
I swapt the arguments. You have to make the call like this ?- shopping_list(List,carol), is_in_list(List,bacon).
So I'm going to stop you right there and point out that you've re-implemented [`member/2`](http://www.swi-prolog.org/pldoc/man?predicate=member/2) with the arguments swapped.
I’m not sure, that rule didn’t work and isn’t member/2 meant to see if if X is part of a list?(args are swapped in my case): member(Item, [is in this list]). Whereas I’m looking to see if... this_rule(Item, person’s name). ...is true
I'm assuming that you're replying to /u/schnizou. Their reply to their comment explains what they were doing. Their query first captures a particular person's shopping list into `List`, then tests whether the item in question is in that list. You could generalize their query into a predicate (i.e. abstract `carol` and `bacon`). Going back to your original question, it's worth mentioning that running a Prolog query doesn't produce a boolean result. Instead, running a Prolog query is like running a database query - it produces a set of solutions that satisfy your query. In Prolog, `false` means "there were no more results" (or if it's the only thing produced, it means "there were no results"). And `true` is a solution that has no bound variables. I mention this because it's easy to construct a query that produces both true and false. Here's a query in SWI-Prolog: ?- member(1, [1, 2, 3]). true; false. That should be read as "there was one solution, then there were no more solutions". And consider this slight variation: ?- member(1, [A, 2, 3]). A = 1; false. This also has exactly one solution, but this time a variable was bound. 
What you will have to do first is get the asked shopping list. You can find that with shopping_list(ShoppingList,Person). Then you'll have to check if the item is in the list, so with member(Element,List). Just put those 2 formulas in the body of your is_in_list(Item,Person) predicate and connect the variable names so the unification gives you what you need.
Alright I’ll give it a shot asap👌🏻
You can play a bit with your different predicates. What do you get when you execute `shopping_list(ShoppingList,dave)`? Or `shopping_list(ShoppingList,Name)`? Play a bit with `member(E,L)` too, for example `member(X,[1,2,3,4,5])`. It'll give you some feeling with prolog. 
Don't use a list in the first argument. is_in_list(Item, Person) :- shopping_list(List, Person), member(Item, List). Or `memberchk/2` instead of `member/2`. Read the manual of your Prolog and decide yourself.
"Do my cuts make sense" is a bigger question than you probably realize. It would require that we talk about, in roughly that order: Why are you using cuts? Can you achieve the same without cuts? How would that change the behaviour of your program? and so on. A small aside: it would be nice if I know how you run the program. At the moment, I am doing, for example: $ swipl -g main -g halt pwd.pl -- -D -c -u -l Obviously I am using SWI-Prolog. Was that your intention? Either way, it is a program that obviously works, so good. It doesn't look super idiomatic but that's not a problem I guess. If you are interested I can comment on that, too.
So does you suggestion work with backtracking?
It actually does as it uses a new idea for each new map so no two maps are confused. Example, :- use_module(map). insert_one_of([Key|KeyTail], [Value|ValueTail], M0, M1) :- map_put(Key, Value, M0, M1) ; insert_one_of(KeyTail, ValueTail, M0, M1). go :- map_new(M0), insert_one_of([mary, sam, adam], [turkey, beef, potato], M0, M1), insert_one_of([mary, sam, adam], [turkey, beef, potato], M1, M2), map_to_list(M1, List1), map_to_list(M2, List2), writeln((List1, List2)). However, this means some form of garbage collection must be implemented. Unfortunately, most prolog systems don't seem to offer a way to hook into the garbage collector.
It would make it so much easier if you provided some context to your code: what problem are you solving, how are you solving it, how the code is meant to be run, and so on.
Thank you. I am trying to get a feel for prolog to understand for what kind of things I could use it. I was trying to use the cuts to increase performance. I found when I ran the program in swipl it was only half as fast as basically the same program in python. Compiled with swipl -t halt -g main -o passwdgen -c passwdgen.pl it was about the same speed. But on the other hand the prolog version is only half as long. So my question is, am I using prolog "the right way"? Or am I trying to whack a tree with a chainsaw because I didn't understand it had a motor?
To be honest, I would have written it quite differently. But I have seen Prolog code that I can assign to a person from maybe 4 different people, and they all have wildly different ideas about what is "good Prolog" ;-) I think you can get away with _less_ code than this, and it can be faster. I will try to find time later today and give some general advice and some code.
Because there are so many things to be said, I will just start somewhere. Lists in Prolog are a data structure that closely resembles a singly linked list. A list `[a, b, c]` is actually a nested term, traditionally `.(a, .(b, .(c, [])))`. To access an element, you need to traverse the list. Usually, you get the n-th element using nth/3 or nth0/3, and random_select/3 uses it too -- you can [see for yourself](https://github.com/SWI-Prolog/swipl-devel/blob/03ed936659ff879dc7d0c936c66eb5dc86fea59e/library/random.pl#L247-L272). Lists are necessary when you have to represent run-time data of unknown length. In your case, you have anyway hardcoded the character classes. So you might as well use a better representation. Two ideas: First, don't make a list at all. For strings, you have `sub_string/5`; for atoms, it would be `sub_atom/5`. Both give you random access to any character. Here is a predicate that takes a random char out of an atom: :- use_module(library(random)). atom_rchar(A, C) :- atom_length(A, N), succ(N0, N), random_between(0, N0, X), sub_atom(A, X, 1, _, C). Another idea: you can use compile-time predicate expansion to turn a string like "abc" into a table like: letter(0, a). letter(1, b). letter(2, c). You would achieve this as follows: term_expansion(char_class(Class, Chars), Rows) :- findall(char_class(Class, N, C), sub_atom(Chars, N, 1, _, C), Rows). char_class(digits, '0123456789'). char_class(special, '.,-+=:;!?~'). Here, I used term_expansion/2 to make a table. The first column is the character class, the second column is the index (within the class), the third column is the character itself. You can consult this and use listing/1 to see what is in the database: ?- listing(char_class). char_class(digits, 0, '0'). char_class(digits, 1, '1'). char_class(digits, 2, '2'). char_class(digits, 3, '3'). char_class(digits, 4, '4'). char_class(digits, 5, '5'). char_class(digits, 6, '6'). char_class(digits, 7, '7'). char_class(digits, 8, '8'). char_class(digits, 9, '9'). char_class(special, 0, '.'). char_class(special, 1, ','). char_class(special, 2, -). char_class(special, 3, +). char_class(special, 4, =). char_class(special, 5, :). char_class(special, 6, ;). char_class(special, 7, !). char_class(special, 8, ?). char_class(special, 9, ~). true. This might be an overkill. It depends how the rest of the program looks like. This is it for now. The use of a string, then making a list, then using random_select/3 was the first thing that stood out in your program which is probably why I decided to start here. Let me know if you find this at all useful.
Thank you! This was really helpful. I was using lists only because the tutorial I read used lists. I hope this puts me on a better track. Thanks again.
[Prolog 99 Problems](https://sites.google.com/site/prologsite/prolog-problems) is a nice start.
The 99 prolog problems is good because you can find solutions to them. But if you are _studying_ I would suggest you do the right thing: find and read _The Art of Prolog_ by Sterling &amp; Shapiro. Your university library should have it. It has the right amount of examples that you can try to solve on your own.
Economics is more popular than AI, so if popularity is in any way relevant to you, maybe you should study economics instead? If not, I recommend you listen to your heart and follow where it takes you!
I'm no expert in Prolog or AI. With that caveat out of the way... From what I can tell, a lot of the current research and practice of machine learning is oriented around using statistical models, derived from training data, to analyze inputs that have never been seen before. Can Prolog be used for that? Sure, Prolog is Turing-complete. Is it an ideal match for that problem? Probably not. Python works well because the numerical libraries for it have become quite robust. I don't know that the same is true of popular Prolog distributions. If that "elite" specialization dives deep into current ML trends, then Prolog might not be the best choice. But if it looks beyond current trends, then Prolog might be more applicable. 
So the think the case you don't handle is something like: my_copy_term([A, A], R). That is, by doing this purely with recursion, I think you'll miss shared variables. You need to make sure that multiple instances of one variable are replaced with the same replacement variable.
When I was at the university we learnt that there were two main camps of AI - the symbolic one, where, like in Prolog, you manipulate symbols and logic, and the connectionist one where decisions are arrived at through things like neural nets. Nowadays most of the focus of AI research seems to lie on the connectionist side, where they are using large amounts of statistic data to train (among other things) neural nets. But you can also use statistic data to generate symbolic solvers - for example when using a bunch of data to create a decision tree in Prolog or some other language. Myself i am not that interested in neural nets, for some reason. I like when I can understand the program that is making the decisions - and that's something I don't see how how you can do with a neural net :) Prolog is used in reality for demanding AI problems. IIRC, a large amount of today's air - traffic is planned by Prolog systems, and at my last job it was the core of the (very handy) business rules system which analyzed credit evaluations If you can - learn both Prolog and python - I like to think prolog can provide an interesting alternative way of seeing things, and used correctly it can be very useful for many AI tasks. 
A Prolog-like implementation has the potential to be an actual AI. If you ignore the execution semantics, remove cuts and I/O, and make the language pure, then you are left with a language that can specify problems for an AI to solve. For example, given a problem with two methods for solving it:: myProblem(Problem, Solution) :- methodOne(Problem, Solution). myProblem(Problem, Solution) :- methodTwo(Problem, Solution). The VM can choose to try one or the other. It can measure the amount of time each approach takes and make decisions on that. Or, if it has a concurrent implementation, it can try both at the same time. One thing which I'm not aware of any Prolog having yet, is minimisation and maximisation. For example:: findShortestRoute(Maze, Route) :- findAnyRoute(Maze, Route), lengthOf(Route, Length), minimize(Length). For now, you'll just have to imagine some AI trying to run this. Anyway, my point is that Prolog is a language who's full potential has not yet been reached.
Fun ways to write `copy_term/2` that _won't help you at all_ ;-): copy_term1(X, Y) :- findall(Z, X = Z, [Y]). copy_term2(X, Y) :- catch(throw(ball(X)), ball(Z), Y = Z). :- dynamic(copier/1). copy_term3(X, Y) :- asserta(copier(X)), retract(copier(Y)), !. 
Noice! Variant 3 is not thread safe though!
I think I'm beginning to see why copy_term is usually implemented natively. :)
Ok, I wrote a much longer solution that builds a list of pairs of free variables as X is traversed -- the first of each pair is a free variable in X, the second is its counterpart in Y. Once the traversal is done, free variables in Y are unified according to their matches in X.. it is really janky, but perhaps it could become less so. Here's the problem stated formally: Given a list of pairs of free variables, where the first element of any pair may appear repeatedly in the list, but every second element appears once, as in [X1-Y1, X2-Y2, X3-Y3, X1-Y4, X3-Y5] unify the pairs of Yi's with matching Xi's. The above example has the solution Y1 = Y4, Y3 = Y5. Is there a clever or efficient (ie. linear time) way of solving this? The only solutions apparent to me are linear search, or sorting, grouping by first element, and then folding (=) over the groups.
Ok, I wrote a much longer solution that builds a list of pairs of free variables as X is traversed -- the first of each pair is a free variable in X, the second is its counterpart in Y. Once the traversal is done, free variables in Y are unified according to their matches in X.. it is really janky, but perhaps it could become less so. Here's the problem stated formally: Given a list of pairs of free variables, where the first element of any pair may appear repeatedly in the list, but every second element appears once, as in [X1-Y1, X2-Y2, X3-Y3, X1-Y4, X3-Y5] unify the pairs of Yi's with matching Xi's. The above example has the solution Y1 = Y4, Y3 = Y5. Is there a clever or efficient (ie. linear time) way of solving this? The only solutions apparent to me are linear search, or sorting, grouping by first element, and then folding (=) over the groups.
I think you're definitely barking up the right tree. Broadly, I can think of three approaches: 1. Traverse the term to be copied once, building up both the cloned term and a set of source -&gt; target variable mappings. Then, as a post-processing step, unify similar target variables. I believe this is what you're currently proposing. 2. Instead of post-processing to unify similar target variables, you could pre-process to gather the set of all variables in the source and associate each with a brand new target variable. Then, this would be an extra input to the helper predicate that actually copies the term. That extra parameter would get passed, unmodified, through all the recursive calls. 3. Skip the pre- or post-processing steps; instead, thread the current set of source -&gt; target variable mappings through all the recursive calls. This would enable you to do it with just one pass of the term to be copied, but the code will be more complicated. From a function programming point of view, this means that instead of mapping over a term's children, you'd instead fold over them. The fold accumulation value would need to collect not only the copied children, but would also need to track the full set of known substitutions. I think all three approaches are in the same complexity class. Whether you sort a list of pairs or use something like the [SWI-Prolog `assoc` library](http://www.swi-prolog.org/pldoc/man?section=assoc), I think it's going to cost roughly `n*log(n)`. And traversing the source term once or twice is immaterial to the complexity class. Of all the solutions, I think I like #2 the best. I think it would produce the cleanest cost, even if it's not necessarily the most performant (for that, I think #3 might beat it). #2 would pair particularly well with something like the `assoc` library. 
Indeed, and I'm sure I've seen it in a few old textbooks. I guess most Prologs didn't have threads in the 80s...
Functional are LISP or ML derivatives. Prolog is considered to be an example of Logical language.
So there are mutations as well? That would make it impure, but yeah I realized it's not really functional.
I don't know how useful it is to talk about a programming language using such words. It is a turing-complete, general-purpose language. It has things called "Prolog terms" which are immutable. But then again, it has the thing called "logical variable" which can be "free", and at a later point you can bind a value to it; it is then that it becomes immutable. But to reiterate, without actual code to show such discussions are useless; and code is useless unless you have a problem that you are solving. So, if you actually would like to learn, pick a problem you'd like to solve and implement it in Prolog. You'd learn something along the way.
True, I'll have to dive in and start learning.
I will try to give you an example of what a "logical variabe" is. Let's say you have a binary tree, and you want to [traverse it breadth-first](https://www.cs.bu.edu/teaching/c/tree/breadth-first/), creating a list. Here is the complete code: tree_bf_list(Tree, List) :- queue_tree_node(Tree, 0, Back0, N, Back), tree_bf_list_1(N, Back0, Back, List). queue_tree_node(e, N, Back, N, Back). queue_tree_node(t(X, L, R), N, [t(X, L, R)|Back], s(N), Back). tree_bf_list_1(0, Q, Q, []). tree_bf_list_1(s(N), [t(X, L, R)|Q], Back, [X|Xs]) :- queue_tree_node(L, N, Back, N1, Back1), queue_tree_node(R, N1, Back1, N2, Back2), tree_bf_list_1(N2, Q, Back2, Xs). The interesting part is using a logical variable (a "whole" at the end of the list, the second argument of tree_bf_list_1/4) to imlement a queue (first-in-first-out). And this is what I get when I use it (I am using the example from the link I posted, under 3. Breadth-first-traversal): ?- T = t(j, t(f, t(a, e, t(d, e, e)), t(h, e, e)), t(k, e, t(z, e, e))), tree_bf_list(T, L). T = t(j, t(f, t(a, e, t(d, e, e)), t(h, e, e)), t(k, e, t(z, e, e))), L = [j, f, k, a, h, z, d]. If you have trouble reading the code please ask and I can try to explain.
If you start a paragraph (so leave an empty line before and after), and use 4 spaces at the beginning of each line, Reddit will show it as code. This is a line with 4 spaces I cannot be bothered to read code that looks like your code at the moment, sorry :-( but I am sure someone will fix your formatting for you.
When i typed the code i fixed the format. when i hit the post button it suddenly changed.. 
&gt; For example, I would never dream of implementing a neural net or clustering algorithm in Prolog with reasonable runtime performance Don't know much about the topic. But is implementing a new algorithm really what people do, unless you're a researcher? My impression was there are libraries in C++/CUDA for this? Also, even in Python it's not all turtles all the way down, is it? Ultimately it's BLAS / LAPACK / etc.
Still a bit weird. This is what I can read: p(,,_):- ... and so on which would be a syntax error.
when i run this it returns an infinite loop. It does not make sense.
And anyway, ideally you should show how you run this, what you see, what you expect to see, why you think what you should get should be different from what you actually get, and how you tried to debug it before you gave up. Altogether I guess Stackoverlow might be better for such questions but I guess that's a matter of opinion.
Could you please tell me what syntax errors you see?
Can you tell me how to load this code?
swi prolog enviroment and i typed pp(BA,WA,Board). this thing will not stop running
Man, do yourself and everyone else a favor and read the article at this link: [How to create a Minimal, Complete, and Verifiable example](https://stackoverflow.com/help/mcve) As it stands, I don't know what your code should look like, where I should put it, how I should load it, and what I should get. I give up, good luck with the next guy.
It is not too easy to debug DCGs. [This textbook chapter](https://www.metalevel.at/prolog/debugging) has some useful ideas and links at the bottom. If you are using SWI-Prolog and `phrase_from_file/2,3`, then you also have `lazy_list_location//1` and `lazy_list_character_count//1`. I am sure you could find some way to keep track of the position by adding arguments to your rules. To be honest, most often than not I end up just reading my DCG carefully to find out what could be happening; if this doesn't help, I add "debugging info" of some kind as an extra argument. Let's hope someone else can provide actual help.
I'm not really qualified to respond as my parser doesn't work yet and I'm not a particularly good Prolog programmer, but... I wouldn't use DCGs and just do it the long-winded way. I declare: parse(State, Text, Unparsed, ParseTree, PreviousStatus, Status, NumCharsIn, NumCharsOut). Where: * State is an atom which is the active node in a state diagram for your parser. * Text is the text you want to parse. * Unparsed is the remaining text after this particular node has parsed. * ParseTree is your parse tree. * Previous * PreviousStatus is so that errors can cascade. See below. * Status is either "success" or "error(Message, Position)". * NumCharsIn is how many characters have been parsed before this rule. * I provide NumCharsOut, the number of characters after I've had my way with the text. To parse some text: parse(root, "my text for parsing", "", P, success, success, _, _). If parsing returns no results, get a parse error instead: parse(root, "my text for parsing", P, _, error(Message, Position), _, _). (you could probably use cuts or negation to provide an error automatically) The reason you would put PreviousStatus in there is so you can declare this: parse(_, T, T, _, error(Message, Position), error(Message, Position), Position, Position). I.e. if any parse rule in a chain fails with an error, all the parse rules following it can be unified with this rule, meaning they all "succeed" with the same error. E.g. a parse rule for parsing a Prolog predicate: parse(predicate, T1, Tr, predicate(Name, Innards), S1, Sr, Nc1, Ncr) :- parse(predicateName, T1, T2, Name, S1, S2, Nc1, Nc2), parse(leftBracket, T2, T3, _, S2, S3, Nc2, Nc3), parse(predicateContents, T3, T4, Innards, S3, S4, Nc3, Nc4), parse(rightBracket, T4, Tr, _, S4, Sr, Nc4, Nc5). and then each rule can either succeed: parse(leftBracket, T1, Tr, na, S1, success, Nc1, Ncr) :- substr("(", Tr, T1), -- Can Prolog cope with this? Ncr is Nc1 + len("("). or fail: parse(leftBracket, T1, Tr, na, S1, error("Brackets may not be curly", P), P, P) :- substr("{", Tr, T1). If you want to get fancy, you could probably redefine --&gt; to do all this for you.
I just want to add a good book you might like: https://www.amazon.es/Programming-Artificial-Intelligence-International-Computer/dp/0321417461
You do realize that the DCG notation is just a notation, right? It helps so that you don't have to type (and read) the two extra arguments. Basically, DCGs are not difficult, parsing is difficult. With DCG or just typing out the rules, doesn't matter, the original problem is still there.
Could the `&amp;` be "disjunction" in this context?
I don't know λProlog, but I can sort of guess at what might be going on. From your rewrite, this set of standard Prolog rules: rev([], L, L). rev([X|L], K, M) :- rev(L, K, [X|M])). ...pretty much describes reversing a list with an accumulator (though it blows the stack if you invoke it as `rev(A, [a, b, c], [])`. Given that, my interpretation of the original code is a little different. To me, it looks like `w :- (x &amp; y) =&gt; z` should be read as "`z` implies `w` if `x` and `y` are assumed. It looks a bit like a Haskell `let..in` expression to me. --- In your derivation, this step looks wrong to me: &gt; ~(~(x &amp; y) ; z) ; w. (~(~x ; ~y) ; z) ; w. I think it should go: ~(~(x &amp; y) ; z) ; w. ~((~x; ~y); z); w. ~(~x; ~y; z); w. (~~x &amp; ~~y &amp; ~z); w. (x &amp; y &amp; ~z); w. That sort of makes sense, except that in my interpretation, `x` and `y` are true because we asserted them to be true. So that just becomes: ~z; w. which is just z =&gt; w.
Thanks! I spent ages reading over my logic thinking there must be an error in it. Good spotting!
In the example code that you show at the top of your post, at the end of the first line, there is a `&amp;` symbol. To me it looks like it replaces the Prolog `;` in that context.
PS: the Prolog definition of `rev/2` that u/balefrost demonstrated is equivalent to: rev(L, K, M) :- ( L = [], K = M ; L = [X|L0], M = [X|M0], rev(L0, K, M0) ). 
[This link does not exist *cough*.](http://www.eecs.ucf.edu/~leavens/learning-LambdaProlog.html)
;-) gzipped ps and dvi, it is enough to stop a lazy fucker like me
*note*: I was hoping to provide a more insightful (for you and me) exposition here, but it turns out I'm quite fuzzy on the details and I need to get to work! Instead, I just have some notes that gesture towards something interesting. I'd be interested in spending the time needed to refresh my understanding, if anyone is interested enough to question or expand on my remarks. --- /u/balefrost seems to have done a great job of unraveling the technical part of your questions, but there may still be room for the general questions you have about the value and sense of the λProlog approach. I only dabbled in λProlog and I haven't looked at it in a quite awhile, so I welcome correction if I make a mistake here, but I may be able to help with the motivation a bit. iirc, `A =&gt; B` is just syntactic sugar for `B -: A`, so we don't actually need to worry about this operator, aside from the fact that it lets us represent implication going from left to right, in cases where that feels more natural. The important point is that our horn clauses can be higher-order. Lambda Prolog lets us write predicates like ``` C :- (B :- A; D :- A). ``` Which we can read as, "(C if (B if A or D if A))". I.e., C will hold only if our "sub-program" (B if A or D if A)` holds. The latter could be its own valid horn-clause program: ``` B :- A. D :- A. ``` So, one way of thinking of this is the following: it lets us write horn-clause programs which are conditional on horn-clause sub-programs. As an example of the expressive power this can provide, consider this implementation of reverse[1]: ``` type reverse list A -&gt; list A -&gt; o. reverse Fwd Rev :- pi rv\ % for all predicates rv ( rv [] Rev % when the list is empty, then Rev is reversed &amp; % and ( pi X\ pi Fwd\ pi Rev\ % for all X, Fwd and Rev (these vars shadow Fwd and Rev in the head) rv [X|Fwd] Rev :- rv Fwd [X|Rev]) % Rev reverses Fwd if you take the head off of Fwd and put it on Rev ) =&gt; rv Fwd []. % Assuming the preceding, reverse Fwd onto an empty list ``` In effect, this defines a predicate `reverse` which is true if our definition of a program for reversing a list with `rv` is is true. Notice that this version of reverse has the same basic logic of the accumulator approach--take each element off the head of `Fwd` and cons it on to `Rev`--but it doesn't actually need separate arguments for the accumulator and the result argument. There are more telling examples involving, for instance, the construction of dynamic databases without having asserts (meaning the construction of the database itself is back-trackable!), but I don't have time to root around for those now. --- [1]: (I have this in a file written when I was studying the language. I know I got this predicate from some other source, but I cannot remember what that source was! Sorry I'm unable to give credit :( The annotations, at least, are mine.)
&gt; C :- (B :- A; D :- A). &gt; &gt; Which we can read as, "(C if (B if A or D if A))". I.e., C will hold only if our "sub-program" (B if A or D if A)` holds. The latter could be its own valid horn-clause program: &gt; &gt; B :- A. &gt; D :- A. I've got a some experience with logic and Prolog, but this is hurting my feeble brain. I can't reduce `C :- (B :- A; D :- A)` to meaningful Horn clauses, and I can't make sense out of it as a logical statement. I look at it, and I can't make head or tail out of it intuitively. I've learned the mechanical laws of logic (or at least, I passed the exam :-) ), but after the simple example statements, I lose intuition. I can understand `B ⊃ A`, it's trival: B implies A. If B is true, A must be true. But then I have no intuition for `(C ⊃ B) ⊃ A`. Saying that `(C ⊃ B)` is false is like saying "this relationship is invalid". How can you add a `⊃ A` to that? Further, you can state "`(C ⊃ B)` is false, but A is true, and this whole rule is still valid and usable for unification". A Prolog program is a finite set of logical rules. I've never fully understood how rules in a program relate to each other. We assume that each rule is true and use them to unify stuff. Are they then in conjunction with each other, or disjuction. Say: A. B. Is this `A ∧ B` or `A ∨ B`? My immediate reaction would be to assume conjunction, as you can [can do this](https://en.wikipedia.org/wiki/Conjunction_introduction). But then, you've used disjunction within an implication. I thought you might have made a mistake, but if I expand out `C :- (B :- A, D :- A).` (which makes more sense to me, kind of?), I get: C :- (B :- A, D :- A). C :- ((B ; ~A), (D ; ~A)). C ; ~((B ; ~A), (D ; ~A)). C ; ~(B ; ~A) ; ~(D ; ~A)). C ; (~B , ~~A) ; (~D , ~~A)). C ; ((~B ; (~D , ~~A)) , (~~A ; (~D, ~~A))). C ; ((~B ; D), (~B ; ~~A)) , ((~~A ; ~D ) , (~~A ; ~~A)). C ; ((~B ; D), (~B ; ~~A)) , ((~~A ; ~D ) , (~~A ; ~~A)). C ; ((~B ; D), (~B ; ~~A)) , ((~~A ; ~D ) , (~~A ; ~~A)). (C ; ((~B ; D), (~B ; ~~A))) , (C ; ((~~A ; ~D ) , (~~A ; ~~A))). ((C ; (~B ; D)), (C ; (~B ; ~~A))) , ((C ; (~~A ; ~D )) , (C ; (~~A ; ~~A))). Which I understand to be the program: C :- B, ~D. C :- B, ~A. C :- ~A, D. C :- ~A. Which is... weird. You can also extract: A :- B, ~C. A :- D, ~C. So I haven't really progressed my understanding of any of this.
Regarding the second half of your comment which I'm still slowly working through, your example is very similar to one on pg 73 of the draft of "the book". It must be for an older version of λProlog as the list syntax has changed. Also, the book's example doesn't have `pi rv\`. Your example has some kind of funky higher-order voodoo going on. I'm not up to that chapter yet, but thanks for the help!
This: ?- consult('foo.pl'). and this: ?- [foo]. are the same. This: ?- [foo] consul('foo.pl'). is indeed a syntax error. This however (note the comma in between!): ?- [foo], consult('foo.pl'). would have been fine; you just do the same twice.
note that for `.pl` files, you can omit the extension if you use the `[foo].` notation. Also, you need to quote only if the file name (sans extension) is not a valid Prolog atom. In other words, for a file `languages.pl`, `[languages]` is fine. If the filename has for example a dash in it, you'd have to quote it even if you skip the `.pl` at the end, so `['foo-bar']`, if the file is called `foo-bar.pl`.
It is a term like this: `.(2, 3)` or like this, in modern SWI-Prolog: `[|](2, 3)`. It is just a term with two arguments. Why you'd use it, I don't know. So it is not an atom; and `[]` is atomic in SWI-Prolog, even if it is supposed to be an atom in Prolog (so, `atom([])` is indeed false but `atomic([])` is true).
fizz 0.2 is out, it's not a huge update: - console commands /import and /export were renamed /import.csv and /export.csv - new console commands /import.json and /export.json to import and export JSON files - new elemental class FZZCWebAPIPuller for fetching JSON data from web services - the elemental class FZZCTicker now also supports time interval expressed in seconds - new primitives: change, console.exec, then, tme.str, str.cmp
You're close. Some notes: 1. You define `is_different/4`, but then try to use it with 8 arguments. 2. You define `higher/2` as "the second argument beats the first argument". But you *seem* to use it the other way around (I'm assuming that `one` means "first place"). 3. I see two distinct solutions, but your (slightly modified) program generates duplicate solutions (it generated 4 for me; two copies of each). That's not necessarily wrong, but be aware when you're looking at the results.
Thanks for the response! I fixed those obvious errors, but am still having some trouble figuring out how to write some of the conditions. For example, the "at least" statements. Any suggestions on what to do or somewhere I could read up on similar problems? 
&gt; am trying to write a predicate that will check if all of the elements on a list are in at least one of each list From your example, it looks like you're seeking elements that are in at least *two* of the given lists. If you want elements that are in at least one of the given lists, that's simply all the elements of all the lists. I think you might be mistaken about what `maplist` does. It runs a predicate against each element of the list and, if the predicate succeeds for every element of the list, then it itself succeeds. For example: ?- maplist(atom, [a, b, c]). true. ?- maplist(atom, [a, b, 42]). false. When you call `maplist` with more than one list, then it will run with elements chosen pairwise from the lists. For example: ?- maplist(=, [1, 2, 3], [A, B, C]). A = 1, B = 2, C = 3. (that's one result with three values bound). ?- maplist(=, [1, 2, 3], [A, B, 42]). false. ?- maplist(=, [1, 2, 3], Z). Z = [1, 2, 3]. In particular, if the lists have different lengths, then `maplist` won't succeed: ?- maplist(=, [1, 2], [1, 2, C]). false. If you use `member` as the predicate for `maplist`, then the second argument should be a list of values and the second argument should be a list of lists. `maplist` in this case will call `member/2` with each element in the first list and each corresponding element from the second list, pairwise. For example: ?- maplist(member, [1, 2], [[1, 3], [2, 3]]). true ; false. (Note that the previous result *is* a solution; the `false` should be read as "there were no more solutions"). 
It would help if you provided at least some high-level description of how you are going to solve the problem. Right now I only know that you want to split a number into two lists, which makes little sense. Do you mean you want to split an _integer number_ into a list of its digits? So, 15 becomes `[1,5]` and `0` becomes `[0]` and 2345 becomes `[2,3,4,5]`?
I cannot know about your knowledge, but I still cannot understand what exactly is the difficulty. &gt; So after I find the sum of a number, I want to split it and append the words together. Sound maybe OK but too vague. Split the number in what? ones, tens, (hundreds)? Is that the difficulty?
Did you find [this post](https://www.reddit.com/r/prolog/comments/7l09wk/prolog_program_describing_the_relationship/)? It solves the same problem for another language, you might take it as a starting point.
Just ones and tens, in separate lists so I can append the words. So for 35, I declared spanish([5], [ones, cinco]), spanish([3], [tens, treinta]), I then want to append trienta with cinco to trienta y cinco. 
What if you have something between 11 and 19?
Ill make a diff case for 11-19 and 21-29. Thats unrelated to the difficulty, rn im just trying to figure out how to split the two digits in two diff lists.
What are diff lists and diff cases? Are they somehow special forms of lists?
Did you ignore a compiler warning? ;-) You can always use `listing/1` to check what is the defintion of your predicate, after compilation. Here is what I get with your code: ?- listing(cmd). cmd(c, B, A) :- A=[_|B]. true. Do you see it now? You can also just take the whole definition (without the period at the end) and give it to `write_canonical/1`: ?- write_canonical((cmd(c, S1, S2) :- S2 = [C|S1])). :-(cmd(c,B,A),=(A,[_|B])) true. But most importantly, **never ignore compiler warnings**. There is _always_ a good reason for a compiler warning. It might even be an error in the compiler, even though in this case it is an error in your code.
I'm really sorry, that is actually a typo. Both of the C's are capitalized, so I never got a compiler warning.
Do you actually know what is the difference, in Prolog, between an identifier starting with a small letter and an identifier starting with a capital letter? As in, `s` vs. `S`?
I can't believe I missed it. I blame the font he used. haha. Once I changed `s` to `S` I got the correct output. Thank you for catching that.
This is kind of important, so make sure to read up on it. It is in the first few paragraphs of any Prolog tutorial I have seen. Try looking at the "Learn Prolog Now!" tutorial, for example.
You can recursively create a list, and you should learn that way as well. But if you are using SWI prolog you can use findall with sort to remove duplicates. &gt; findall(G, gradpa(G,_), List_with_Duplicates), sort(List_with_Duplicates,List_of_Grandpas).
Ups, I forgot to mention that I can't use findall/forall etc. But I've already found solution :)
[solution on stackoverflow](https://stackoverflow.com/questions/49369862/creating-list-of-all-elements-fullfilling-relation-in-prolog) Code: &gt; find\_grandpas(Tmp,List):- ( grandpa(New,_), not(member(New,Tmp)) -&gt; find\_grandpas([New|Tmp],List); List = Tmp ).
Some problems with your code, not specific to this attempt, but something of a debugging / selfcheck tool: 1. Notice that you are never instantiating `List`. I.e. your code seems to operate on this variable, but, essentially, it does nothing to it. So, unsurprisingly, it ends up being un-instantiated. 2. Notice how your predicate `find_grandpas` "wants" to be recursive, but it doesn't have an end of recursion condition. So, it will either never terminate, or it will error producing no results, but it won't do any useful work. More on your question: what you are asking for is something called "extra-logical" operation. The logic implemented by Prolog isn't powerful enough to express quantifiers (s.a. "for all" or "exists"), that is why Prolog has special meta-logical or extra-logical predicates that do this job: `findall`, `bagof` etc. However, sometimes you can express something similar in the logic implemented by Prolog, that is when your domain is certainly finite, you can just iterate over it. But then you would at least need to know how many grandparents are there.
I feel you
Hey, I have an update for you: member() and call() is also forbidden this is ridiculous
You might want to share in some way (link?) the exact problem statement, as well as the lecture materials you are working with. Otherwise it is a guessing game. What exactly is asked? What are you allowed to use? Do you really have to make a list? and so on. It would be much easier to help.
Teacher said, that "advance functions" are disallowed, and he wants us to know the basics of prolog. I used call() only for optimization to avoid copy-pasting chunk of code 20 times and actually I'm allowed to write my own member() function (sic!). I tried: mymember(X,[]):-false. mymember(X,[H|T]):- X==H ; myownmember(X,T). but it lacks the ability to look for elements, like built-in member: ?- member(X,[1,2,3]). X = 1 ; X = 2 ; X = 3. ?- myownmember(X,[1,2,3]). false. 
Your construction: atom_concat(H, ' ', String), createString(T, String). You can use `string_concat` and add a third parameter to your predicate. The third parameter is unassigned *until* your list is empty, then it'd be: createString([], String, String). For the case where there *is* something in your list: createString([H|T], Acc, String) :- atom_concat(H, ' ', HSpace), string_concat(Acc, HSpace, NewAcc), createString(T, NewAcc, String). To avoid changing your code (and hide the accumulator, doesn't need to be presented to everyone): createString(List, String) :- createString(List, "", String). One deficit of this version is that an extra space will be tacked on when the list consists of only one item. I'll leave it to you to attempt a fix for that case.
Another way to approach this problem would be to think about it not in terms of how list elements are added one by one, but to see it as merging of two lists, one that has given elements, and another one, which has one fewer separator elements. For example, it could look like this: merge(X, [], X). merge([], Y, Y) :- not(Y = []). merge([X | Xs], [Y | Ys], [X, Y | Z]) :- merge(Xs, Ys, Z). join(In, Separator, Out) :- length(In, Len), SepLen is Len - 1, length(Separators, SepLen), maplist('='(Separator), Separators), merge(In, Separators, Out). 
Not sure if I understand your question. Usually, if you want to make a list out of all solutions, you should use `findall/3` or `bagof/3` or `setof/3`, depending how exactly you want it to go. Read the documentation. With findall: $ gprolog GNU Prolog 1.4.4 (64 bits) Compiled Jul 15 2017, 09:25:55 with gcc By Daniel Diaz Copyright (C) 1999-2013 Daniel Diaz | ?- findall(P, permutation([a,b,c], P), Ps). Ps = [[a,b,c],[a,c,b],[b,a,c],[b,c,a],[c,a,b],[c,b,a]] yes But please don't write to files or to standard output unless you really have to. This is what your toplevel is for. And if you really need to write things to a file, do it after you have collected everything you need. The Prolog toplevel is way more powerful than say the Python interpreter, learn it and use it.
Wow I am impressed. Back in the day, we used to solve this category of problems using something called "lagging". When you need to lag exactly once, it looks like this: atom_list_concat([], _Sep, ''). atom_list_concat([H|T], Sep, Atom) :- atom_list_concat_1(T, H, Sep, Atom). atom_list_concat_1([], Prev, _Sep, Prev). atom_list_concat_1([H|T], Prev, Sep, Atom) :- atom_list_concat_1(T, H, Sep, Atom0), atom_concat(Sep, Atom0, Atom1), atom_concat(Prev, Atom1, Atom). With this, I get: | ?- atom_list_concat([a,b,c], '-', A). A = 'a-b-c' yes | ?- atom_list_concat([a], '-', A). A = a yes | ?- atom_list_concat([], '-', A). A = '' (1 ms) yes I am not sure if the empty list should give back an empty atom, but this is just to demonstrate what I mean by "lagging", which is just a word for unpacking one element from the list and adding it as an argument to a helper predicate.
Well, I don't think that in this case my "solution" merits this kind of approach... :) but thinking in terms of deconstructing a problem (just like Derrida would), and then building it from smaller, but simpler parts is a valid approach.
I was honestly impressed, I would not have thought about it, and this approach does have its uses. I would have written the merge differently but that's a detail.
Here is what I have tried cut([],[]). cut([H|[]],_). % in order to avoid fail [H|[T|T1]] when only 1 element left in list cut([H|[T|T1]],P):- T is H + 1, append(P,H,Result), cut([T|T1],Result). cut([H|T],P):- % in case there are elements not in sequence how do I put the elements in the same 'Result' list cut(T,P). 
Here is what I have tried cut([],[]). % in order to avoid fail [H|[T|T1]] when only 1 element left in list cut([H|[]],_). cut([H|[T|T1]],P):- T is H + 1, append(P,H,Result), cut([T|T1],Result). % in case there are elements not in sequence how do I put the elements in the same 'Result' list cut([H|T],P):- ......... cut(T,P).
 Trying to post a better view of the code cut([],[]). cut([H|[]],_). cut([H|[T|T1]],P):- T is H + 1, append(P,H,Result), cut([T|T1],Result). cut([H|T],P):- cut(T,P).
Put 4 spaces at the beginning of each line of a code block. Example: foo. bar(X) :- foo. Then, you really don't need to use append for anything here. Concentrate first on how you'd take an increasing sublist of of the original list. Then: What should be the answer for this list: `[5, 5, 5]`?
Also, `[A|[B|C]]` is just a weird way of writing `[A,B|C]`. On the other hand, you should rarely need to write `[A,B|C]`. Or to say it differently, it is a code smell. If I were you, I'd concentrate on the logic of what you are trying to achieve. If you can write it in procedural pseudo-code and test that it works correctly using Python, for example, it would be much easier to translate it to working Prolog code (at least for a beginner, that's definitely a valid approach). And I still don't know what should happen when you run: ?- cut([5, 5, 5], Result). 
I wrote the below code to copy the elements in seq in the Result but this gives me 'false' as the result. Can you tell me why it happens so check_seq([],[]). check_seq([H|[]],H). check_seq([H,T|[T1]],[H|Result]):- T is H + 1, check_seq([T|T1],Result). Sample output check_seq([1,2,3],P). false
Hi, I used the format [A,B|[C]] to segregate the first 2 elements in the list to check if B = A + 1. I have changed my earlier format and come up with the following code to check the sequence of number check_seq([],[]). check_seq([H|[]],H). check_seq([H,T|[T1]],[H|Result]):- T is H + 1, check_seq([T|T1],Result). 
However I am getting the result as 'false' for the query with the above mentioned code, which I don't understand. Result should contain the list isn't it. check_seq([1,2,3],P). false
Aha, so when you say "increasing" you actually mean x, x+1, x+2, ... . Fine. Another thing: `[H|[]]` is just `[H]`. `[H,T|[T1]]` looks wrong to me. ?- L = [1,2,3,4], L = [A,B|C]. L = [1, 2, 3, 4], A = 1, B = 2, C = [3, 4]. ?- L = [1,2,3,4], L = [A,B|[C]]. false. What's up with this square bracket fixation? In the last few days this is the third separate incident I see this kind of code.
No, really, don't write `[H|[]]`. This is just weird and unnecessary. Try: ?- [a|[]] = [a]. and see for yourself that the two things are identical. And I don't know if someone is forcing you to force everything into the same predicate, but it is not making it any easier. As a rule of thumb, if you are dealing with lists, you need one or two clauses: foo([], .....) % this one is only if the empty list makes sense foo([H|T], ....) I'd still try and write down the logic in a procedural language like Python first. Or whatever you are comfortable with. It is difficult to fight simultaneously with the algorithm and with the programming language. Once you have the algorithm figured out, you can move on to implementing it.
You can see this problem as similar to a more general reduction problem. This is typically solved by taking an element from a sequence, the result produced so far, and applying an operation to both of them. And repeating this process until all elements of the sequence are processed in this way. SWI Prolog has this kind of predicate implemented: the `fold` family of predicates, but standard Prolog iirc doesn't have one (but it's easy to implement one if you want). With this in mind, here's something I could come up with: sublist(Op, [X | Xs], [Y | Ys], [X | Sublist], Z) :- call(Op, X, Y), sublist(Op, Xs, Ys, Sublist, Z). sublist(Op, [X | Xs], [Y | _], [X], Xs) :- not(call(Op, X, Y)). sublist(_, [X], [], [X], []). sublists(_, [], []). sublists(Op, List, [Sublist | Sublists]) :- List = [ _ | List2], sublist(Op, List, List2, Sublist, Rest), sublists(Op, Rest, Sublists). one_greater(A, B) :- B is A + 1. Then you can use it like this: ?- sublists(one_greater, [11, 12, 5, 6, 7, 9, 5], X). X = [[11, 12], [5, 6, 7], [9], [5]] ; false. One could make the accumulation of sublists / sublist elements more efficient, but this isn't very important to illustrate the idea.
&gt; I used the format [A,B|[C]] to segregate the first 2 elements in the list to check if B = A + 1 Just to comment on that: ?- [A,B|[C]] = [1, 2, 3]. A = 1, B = 2, C = 3. ?- [A,B|[C]] = [1, 2, 3, 4]. false. ?- [A,B|[C]] = [1, 2]. false. That pattern will match a list with exactly three elements. It matches a list with two elements and a tail, but that tail must itself be a list with exactly one element.
I don't don't think this is your problem, but SWI-Prolog broke from the ISO standard at some point. In ISO Prolog, `.` is the name of the compound term that glues list elements together. So in ISO Prolog, a list `[a, b, c]` could (I believe) also be written as '.'(a, '.'(b, '.'(c, [])) Or possibly as just a.b.c.[] ...since `.` is a registered operator (not sure about that, and can't test it ATM). In SWI-Prolog, they wanted to use `.` for other purposes, so they replaced the name of the list concatenation compound term with `[|]`. ?- A = '[|]'(a, '[|]'(b, '[|]'(c, []))). A = [a, b, c]. If the `.`s that are in your original Prolog program were meant for concatenation, you'll need to replace them with `'[|]'` in SWI-Prolog. That's why the error is complaining about you not having a dict - `.` in SWI-Prolog is meant for lookup up fields in records. But as /u/wellmeaningtroll points out, it looks more like a transcription error. In particular, you probably want a base-case version of `alessx/2`, and rewriting that first clause as: alessx([], [_|_]). could be read as "the empty list is `alessx` any list with at least one element", which seems to make sense.
You don't need to quote the dot. `.(a, .(b, .(c, [])))`. You can get this working if you pass `--traditional` when you start SWI-Prolog: $ swipl --traditional Welcome to SWI-Prolog (threaded, 64 bits, version 7.7.11-6-gde6e44cd9) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). ?- X = .(a, .(b, .(c, []))). X = [a, b, c]. But you cannot use the `a.b.c.[]` notation for sure. Either way, this is definitely not the problem that OP has with their code.
The problem with this solution, of course, is that you need to again traverse each sublist if you want to have the last element. In OP's problem statement, you compress the list by keeping only the first and the last elements, right? But this is relatively easy to fix. You get to the last element in your `sublist/5`, but then you throw it away, and keep only the whole list. Another idea altogether would be to make a predicate like [numlist/3](http://eu.swi-prolog.org/pldoc/doc_for?object=numlist/3) that properly works in all modes. With its current definition in the SWI-Prolog library(lists), it works only if both Low and High are integers. Can you make it work with `numlist(?Low, ?High, ?List)`? The dudes over at the Prolog Stackoverflow tag would cheer loudly if you did.
Well, I think that giving the entire solution would be counterproductive :) But, in my experience, having partial solution both helps understand how someone could've come up with the solution and develop a working solution to the actual problem.
Basically, every Prolog system does stuff slightly differently. There was an attempt at standardization some years back, but it ended up in one fraction (let's call them "the purists") completely disregarding the point of view, and shitting on the work of the pragmatists. One of the consequences is that SWI-Prolog at least has moved on and given up on attempts at being standard compliant, where compliancy goes against pragmatic considerations. The `dict` for example is an attempt to provide an efficient key-value store with the semantics of a normal Prolog term (backtrackable, immutable) and a more ergonomic notation (using the dot).
Do you understand why the `fail` is there? You could add a clause to `print_all_facts` that's vacuously true: print_all_facts :- myFact(X), write(X), nl, fail. print_all_facts. You'd want to put that after the existing clause because you want it to be evaluated last. Alternatively, if you don't want to mess with `print_all_facts`, you could instead change the callsite: (print_all_facts; true), some_other_rule. Though `print_all_facts` will never succeed, `true` will succeed, allowing the query to proceed to the next goal.
Hey, thank you for your answer. Yes, `fail` is for backtracking, which I have a question about... Is there a way to backtrack to the very beginning instead of going back to the most recent successful 'execution'?
I don't completely understand your question, and I don't want to confuse things by giving an incorrect answer to a misunderstood question. Can you provide an example? In general, Prolog answers queries by doing a sort of tree traversal. To answer `print_all_facts`, it will find all solutions for `myFact(X)`. Then, for each of those, it will find all solutions to `write(X)`. For each of those, it will find a solution to `nl`, and for each of those, it will find a solution to `fail`. For a better example, let's say you have this program: happy(alice). happy(bob). rich(bob). rich(charlie). successful(X) :- happy(X), rich(Y), X = Y. % note that this isn't the typical way to write this % rule, but it works better for the diagram... and % it might be closer to how Prolog actually executes % the query The query tree would look something like this: ?- successful(X). | ?- happy(X). | A---------------+---------------D | | X = alice. X = bob. | | ?- rich(Y). ?- rich(Y). | | B-------+-------C D-------+-------E | | | | Y = bob. Y = charlie. Y = bob. Y = charlie. | | | | ?- X = Y. ?- X = Y. ?- X = Y. ?- X = Y. | | | | false. false. true. false. Whenever a subgoal fails, Prolog kills off the current query branch. As it walks back up the tree, if it encounters any right branch, it follows it. So when the leftmost branch fails, it walks back up the tree until it reaches `B`, at which point it tries the remaining branch `C`. That fails too, and this time Prolog walks all the way back up to `A` before taking the right branch of to `D`. (The same is basically true if a branch succeeds, for what it's worth. Failing just kills the branch sooner.) All that `fail` does is to forcibly fail the current branch. You could just as easily replace it with `1 = 2` or some other goal that can never succees. But when that particular branch fails, Prolog will continue to explore other branches. If you want to suppress that, you'd have to use something like a cut (`!`). But even the cut doesn't stop the query completely - it just kills of other branches for the current rule. 
&gt; Is there a way to backtrack to the very beginning instead of going back to the most recent successful 'execution'? Hopefully I'm understanding you correctly, but this is called non-chronological backtracking or _backjumping_. It's been explored quite a bit in SAT-solving literature. See [this](https://stackoverflow.com/a/48915655).
The obvious problem with the code: you have a conjunction that is not inside the body of a predicate definition, but just hanging out there on its own: print_all_facts, some_other_rule. That's where the warning is coming from. If you just put it inside a predicate you won't get the warning: print_and_more :- print_all_facts, some_other_rule. **However**: you might be suffering from the XY problem. You are talking about looping while using Prolog, which is already a red flag. What are you actually trying to achieve? Why do you think you need `forall/2` in the first place, and why do you want to replace it? The default search strategy for Prolog is indeed depth-first search, which is not well suited for every problem. But you can easily implement a breadth-first search using a queue data structure (just to give an example). So what is it that you are trying to achieve?
And while on the topic of `forall/2`: if you read [the documentation](http://www.gprolog.org/manual/gprolog.html#sec194), you'd know that `forall(Condition, Action)` is equivalent to: \+ (Cond, \+ Action). You could read the [SWI-Prolog documentation on forall](http://eu.swi-prolog.org/pldoc/doc_for?object=forall/2) for a decent explanation of the why and the how. 
If I were you I'd do it the lazy way: take the three arguments, put them in a list, sort without removing duplicates, then check if the sum of the first and the second is larger than the third: triangle(A, B, C) :- msort([A, B, C], [X, Y, Z]), X + Y &gt; Z. The last line will correctly throw an exception if any of the arguments is not a number already. Does this solve your problem? Do your question is definitely asking for more than this I'd like to know if it is at all necessary.
Actually, if I add a square bracket to the left side like so: triangle([A,B,C]), and write my query similarly, it works perfectly. Thank you. I think you are right, in that I was making the problem too hard for myself. Your other reply where you talk of limiting the scope by asking questions was insightful. I should have realized earlier on that there would be a "sort" function, that could do nearly every thing I need it to do. Thank you for your help. Last week I had to figure out Lambda calculus. This has been a challenging class, but it is really cool to get a chance to work in paradigms other than OOP. 
Just a small comment: you use lists if you don't know how many things of the same kind you will have. For a predicate called triangle that expects exactly three arguments it is probably better to just use three arguments (not a list of three things). Make sure you are not using `sort`, but `msort` (the "m" stands for "merge" I'd guess?). Because: ?- sort([2,2,3], Sorted). Sorted = [2, 3]. ?- msort([2,2,3], Sorted). Sorted = [2, 2, 3]. 
Paradigms are less important than they seem at the moment. Trying hard to classify them and assign a language to a paradigm (or a paradigm to a language) is quite popular in universities but I really don't know if it's more useful or damaging.
No, it doesn't mean that. Swish is more or less like a Prolog, just read a book or a tutorial first.
You'd have to show us the query that you're running, but `false` as a result means "there were no more solutions". It doesn't necessarily mean that there were no solutions. For example: ?- member(1, [1, 2, 1, 3]). true ; true ; false. Sometimes, Prolog can immediately realize that there are no more solutions; in these cases, the `false` is omitted. 
gotcha thanks!
For something like non-local jumps you can use `catch/3`: http://www.swi-prolog.org/pldoc/man?predicate=catch/3
I love this. (You should have mentioned that I need library(clpfd) but anyway.) Look: ?- use_module(library(clpfd)). true. ?- [user]. |: triangle(A, B, C) :- A + B #&gt; C. |: triangle(A, B, C) :- A + C #&gt; B. |: triangle(A, B, C) :- B + C #&gt; A. |: ^D% user://1 compiled 0.00 sec, 3 clauses true. ?- triangle(3, 3, 3). true ; true ; true. It is triangle/3, which has 3 clauses, and when you query it with arguments 3, 3, 3, you get true 3 times. I am getting nerdchills; as you [can see for yourself](https://www.reddit.com/r/programming/comments/6wws46/the_software_engineering_rule_of_3_you_need_at/dmbghnx/), 3 has a special place in my heart.
You chop the head and process it, then repeat the same for the tail until you reach the base case. – this was my explanation verbatim of tail recursion on the midterm.
It is difficult for me personally to give quick help because I tried to read quickly your problem statement and I did not understand it. Can't you paste the original problem statement? When you tried to quickly explain it you might have mangled it a bit. Some guidance. If you have a non-negative integer x and you want to generate a list of all integers [1, x], then one quick and dirty way to generate a list of integers 1, 2, ..., x is: ?- X = 4, findall(N, between(1, X, N), Result). X = 4, Result = [1, 2, 3, 4]. If you wanted to make a compound term, say a pair, you can just write stick it into the first argument of findall/3 like this: ?- X = 4, Y = 3, findall(Y-N, between(1, X, N), Result). X = 4, Y = 3, Result = [3-1, 3-2, 3-3, 3-4]. This first argument can be any valid Prolog term, it doesn't have to be `A-B`. But `First-Second` is the conventional way of representing pairs in Prolog. This is the quickest help I can give you. If you want more you need to explain better. 
You need to tell Prolog to evaluate the `N - 1` using [`is/2`](http://www.swi-prolog.org/pldoc/man?predicate=is/2). Like this: element_at(X,[H|T],N) :- N1 is N - 1, element_at(X,T,N1). 
I recommend using `#=` instead of `is`. Then your relation is actually relational. https://swish.swi-prolog.org/p/hEdXDjBk.pl
I thought this might have been something homework-related in a course where clpfd hadn't been covered yet. But I probably should have mentioned it.
This is a good use case for length/2 and append/3. I don't want to give you the full solution, but for 3 and 7, you make a list of length 2, split it off with append, then a list of length 7-3 = 4 (your slice), and split it off. More or less: ?- L = [a,b,c,d,e,f,g,h,i,j,k], length(Before, 2), length(Slice, 4), append(Before, Rest, L), append(Slice, _, Rest). Slice = [c, d, e, f] 
slice([H|_],1,1,[H] ). % base case : c,d,e,f,g slice([H|T],I,K,[H|Ys]):- K&gt;1, K_1 is K - 1, slice(T,I,K_1,Ys). % iterate to stop : c,d,e,f,g,h,i,k % Ys acts as accumulator variable slice([H|T],I,K,Ret):- I &gt; 1, I_1 is I - 1, K&gt;1, K_1 is K - 1, slice(T,I_1,K_1,Ret). % iterate to begin : a,b,c,d,e,f,g,h,i,k
Yeah well i don't feel like debugging code when I don't like the approach. Did you try debugging it yourself? But when you get solutions like this it usually means that you have forgotten a limiting condition.
There are some that i could catch: - When declaring a predicate in Prolog, it's good practice to put the input at the left and the output at the right in most cases, at least that's what i was told, so making the otherwise can be confusing. It doesn't affect the correctness of the program, though. Now, about the issue itself, the problem is that you bind the variable S (in "sum_nat(S, Nm1)") to 1, and then you make a query "S is S+Nm1", which will always fail, because Nm1 &gt; 0. This is probably not the way you thought the program would think, but because variables in prolog, once binded to value, cannot have its value changed, it makes a comparison instead of a attribution. The solution for that is to change the variable in the recursion call, for S0, for example, and after it received its value, sum S0 and Nm1 to get S. There's still another problem, though, and it's in the way you modelled the program. In a mathematical definition, the program would look like that: 1)sum_nat(1) = 1 2)sum_nat(n) = sum_nat(n-1)+n-1 That's because you put Nm1 in the sum, when it should be N.
OP defined natural numbers as starting at 1, so I did too. His solution (with fixes) would be false with sum_nat(S, 0), this would be true. 
https://www.reddit.com/r/prolog/comments/89mqk1/gnuprolog_how_to_append_all_permutations_to_a/?ref=share&amp;ref_source=link
I see, it does make sense. Thanks for the formula, will keep it in mind - but I was more looking to solve it "the hard way", to get into prolog's mindset.
&gt; When declaring a predicate in Prolog, it's good practice to put the input at the left and the output at the right in most cases, at least that's what i was told, so making the otherwise can be confusing. It doesn't affect the correctness of the program, though. So it would be more correct to write `sum_nat(N, S)`? &gt; variables in prolog, once binded to value, cannot have its value changed, it makes a comparison instead of a attribution. I see, so I have to be careful with what is assigned to what! &gt; There's still another problem, though, and it's in the way you modelled the program. In a mathematical definition, the program would look like that:(...) This made it quite easier to understand, thanks :)
Did you figure it out yourself? It would be nice if you shared the correct code. Do you know that you can do it in two (more or less equivalent) ways, using an accumulator (extra argument) or using the stack (not tail-recursive)?
ok, I got this now permutations_helper([], []). permutations_helper([X|Rst], V) :- permutations_helper(Rst, V1), select(X, V, V1). findall(A, permutations_helper([1, 2, 3], A)). *** I'm trying to have a permutations predicate that invokes findall so I can simply type in permutations([1,2,3],X). and have it return X=[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] *** how can I do this? Thanks 
What I think I have done and working: *equalLists(x,y) tests whether the lists x and y are equal.* equalLists(X, [X|T]). equalLists(X, [H|T]) :- X=[H|T]. *my_member(x,y) tests whether x is an element of the list y.* my_member(X, [X|T]). my_member(X, [H|T]) :- my_member(X,T). *equalSets(x,y) tests whether x and y, considered as sets, are equal.* equalSets(X, Y). equalSets(X, Y) :- X=Y. *equalBags(x,y) tests whether the bags x and y are equal.* p(X,Y). equalBags(p(X,Y)). equalBags(p(X,Y)) :- X=Y. If you see any problems or anything, let me know please!
I'm really trying to understand what does your 'all' implementation was supposed to do, with that "all(not(X),Y)" and the "(all(not(X),Y))" int the end, but let me explain some things about the language. Two of the most important aspects of Prolog are unification and back-tracking. The first one, unification, an operation where the program tries to bind a free variable in order to satisfy the query. It's represented by '='. You should look for it in more detail in order to better understand better how a program in Prolog works. The way prolog runs a query is to trying to unify the query with the facts and rules that exists in the knowledge base, and tries to unify first with the facts on the top, which means that when you do the query "all(2, [1,2,3,4,5])", it will try to unify to "all(X,Y)", and since they're both free variables, and no conditions to be true, the result is always true, no matter the values you put. Oh, and talking about variables, they don't work like the one in imperative paradigm. Once the variable is grounded (i.e gets unified with any valor), its value doesn't change for the rest of the execution of the program, unless when it gets free because of backtracking, but don't worry about it for now. Which means that, when using the query "all(2,[1,2,3,4,5])", you aren't going to get the output you desire, since Prolog's queries just give "true" or "false" as output. What you should do is put a third argument in the predicate (like "all(X,Y,Z)"), and make one of them, preferably the last one, unifies with the result. Before talking about backtracking, let me explain about ':-'. Whenever you declare a rule like A :- B,C. It means that, in order to a query D unifies with A, both B and C must be true. So, if you were to write a rule like: even(X) :- X mod 2 =:= 0. it means that even(X), is true if the value X mod 2 is equal to zero(I really didn't want to use a mathematical example, but i couldn't think in a good example that had only one rule and no recursion that didn't envolve math). Moving on to backtracking, let's say you made the query: ?- member(X,[2,3,4,5,6,8]), even(X). The member/2 predicate is an predicate that returns true whenever the first argument can unify with one element of the second argument, but, because of backtracking, when we insert a variable as its first argument, it iterates over the list, unifying one of the elements of the lists in the variable. So, when we try to run the query, the first step is calling member(X,[2,3,4,5,6,8). This call will return true with X being grounded as 2. The next step is calling even(2), that will be true. So, the console will show: X = 2 One valid answer to the query, but what if we want the other results? That's when backtracking enters. If we press ';', the program will make a backtracking in order to try to get another valid answer. To do this, it reverses the state of the program. So, when we ask Prolog to look for another answer, it will reverse the unification with the first clause of the even predicate and try to unify with another. But, since it has only one clause, the query will fail. Since it cannot unify with any other 'even' clause, it will backtrack to the moment it unified to 'member(2,[2,3,4,5,6,8])'. The member predicate can be written like: member(X,[X|_]). member(X,[E|L]) :- member(X,L). I don't know how familiar you are with recursion, but in this case, when the program backtracks in 'member(2,[2,3,4,5,6,8])', which was a unification of the first clause, the program, then, will try to unify to the second clause which will result in the 'member(3,[3,4,5,6,8])', meaning that we get 'member(3,[2,3,4,5,6,8])'. Once we have another value for X, the program will try the query 'even(3)', but it will fail, leaving for the backtracking to continue. This time, it will get 'member(4,[2,3,4,5,6,8]'). Since 4 is even, the console will display: X = 4 if you continue, the same will apply to the rest of the list, until the list has no more elements. In this moment, it will return false. The not predicate does not work in the way you think it works. It can be used to check values, but never to get them. In the last line "(all(not(X),Y))", you're misunderstanding something. The way its presented, the only queries that will unify are the ones that are wrapped in not/1. If a predicate is inside an argument of another predicate, it's nothing more than data. However, if you want to check the a query A, you must use "call(A)", or just "A" in SWI-Prolog(and probably some others). These problems require recursion. You should learn how it works in Prolog to solve them. I hope i was helpful. I'm sorry if the explanation got confusing at some point, i tried to talk a little about the theory behind, but i am not an expert myself, so i probably made confusion out of the terms, and even probably said something incorrect. You should get some material to start to know more about the language, since the basic concepts. When i was starting, I used [Learn Prolog Now](http://www.learnprolognow.org/), but there's more material in the side bar of this r/ you should take your time to check that.
Thank you so much for taking the time to write out a detailed response! My all implementation is supposed to return the list y without any x in there. In Java it might look something like for (int i=1; i&lt;=5; ++i){ theValue = input.nextInt(); if ( != 2){ System.out.println (theValue); } } So it only prints out [1,2)U(2,5] As for recursion and backtracking, I get the idea but it's very hard for me to visualize the process. I haven't had to do really anything with recursion before so it's still a new concept.
You don't need much knowledge about backtracking to do these programs, but recursion is essential, not just to Prolog but also to programming in general. You really should try to better understand it at some point, but i'll try to explain the best way i can. Basically, the most basic thing about recursion is that is divided between basic case and recursive step (i cannot guarantee these are the actual terms, but let's use them). The Basic case is a trivial case of the rule to be defined. For example, in the Fibonacci series, they would be that both 1 and 2 are Fibonacci numbers, or: F(1) = 1 F(2) = 1 The recursion step is the case when we do not have a trivial case. The idea is to simplify the problem to the point it's composed of only trivial cases. In the Fibonacci series it would be the formula: F(n) = F(n-1) + F(n-2) So, when we get something like F(5), we can do something like this: F(5) = F(4) + F(3) F(5) = [F(3) + F(2)]+[F(2)+F(1)] F(5) = {[F(2) + F(1)] + F(2)} + [F(2) + F(1)] F(5) = [(1 + 1)] + 1) + (1 + 1) F(5) = 5 Btw, the Prolog version would be like this: fib(1,1). fib(2,1). fib(N,F) :- N &gt; 2, N1 is N-1, N2 is N-2, fib(N1,F1), fib(N2,F2), F is F1 + F2. it's very inefficient, though. Before continuing, just some knowledge about Prolog lists. They're divided in Head and Tail, being the head the first element and the tail a list containing the other elements of the lists. So, for the list [1,2,3,4,5], the head is the atom 1, while the tail is the list [2,3,4,5]. We will use that for the recursion. When using L = [H|T], we're saying that H is the head of L, while T is its tail. The recursion will be used basically to iterate over the list. I will show an predicate that is almost the first problem and try to explain over that. Let's take an predicate that takes just the first occurrence of a certain element in a list. remove(X, [], []). remove(X, L, L1) :- L = [X|L1]. remove(X, L, L3) :- L = [E|L1], \+ X = E, remove(X, L1, L2), L3 = [E|L2]. The first two clauses are the basic case. The first one is true if the list is empty and the output is also a empty list. The second one is true if the first element of the list is the one to be removed and the output is the tail of the list. We do that by unifying L to the head X, which means that this clause will be true only if the first element of the list can be unified with the first argument. We also unify the tail of the list so that we can pass it as the output. So, when running the clause remove(1,[1,2],X), the result is that X = [2]. The third clause is the recursion step. It's there for when the list is neither empty nor its first element can be unified with the element to be removed. The first line will unify the head with the variable E, so it can be test if the head does not unify, and the tail to L1, so we can use recursion on it. The second line is testing whether X does not unify with E. the '\+' is the same as the not predicate. the third line is where the recursion takes place. It will call the predicate again, but this time sending only the body of the list as the list to have the element taken. This step will be called recursively until the basic case is true, i.e when it finds the element or gets in the end of the list. It puts the output list in L2, so we can use it to generate the correct output. So, when we run the query remove(4,[1,2,3,4,5,6,4], X), it will be: the (call-n) I used in the beginning of each step is to point out that this step happens in the n-th layer of the recursion stack. 1. (call-1) Since it does not unify with clauses 1 and 2, it will run the third clause. Since +\ 4 = 1, it will call remove(4,[2,3,4,5,6,4], X1). 2. (call-2) Again, it does not unify with clauses 1 and 2, Since +\ 4 = 2, it will call remove(4,[3,4,5,6,4], X2). 3. (call-3) The same as the other two. since +\ 4 = 3, it will run remove(4, [4,5,6,4], X3). 4. (call-4) This one finally unify with one of the basic cases, in this case, the second one. Thus, we have that 4 = 4, which means that X3 = [5,6,4]. 5. (call-3) Once we have X3, it will then unify with the head of the list and make the output for this layer. Thus, we have that X2 = [3|[5,6,4]] = [3,5,6,4]. 6. (call-2) Once we have X2, we will do the same as the previous step and have X1 = [2,3,5,6,4]. 7 (call-1) Now we're back to the first call of remove. We will do the same things we did in the last two steps. With that we have that X = [2,3,5,6,4]. In the last line, we unify the head of the list with the list that doesn't have the element, or that didn't find it, and unify with L3, this variable is the output of our predicate, so it will be unified with the result list. It's not that hard to get the predicate to remove all the instances once you have one that removes the first one. Oh, one last thing. I made the unification through the program to try to make it more easily understandable, but when creating predicates, it's normal to make the unifications in the arguments. If i was programming, i would write the predicate like that: remove(_,[],[]). remove(X,[X|L1],L1). remove(X,[E|L1],[E|L2]) :- \+ X = E, remove(X,L1,L2). The '_' is to tell that it is an anonymous variable.
To remove all occurences of something, you can use "exclude": ?- exclude(=(b), [a,b,c,d,e,b,f], R). R = [a, c, d, e, f]. To remove repeated elements, just sort. ?- sort(List, Set). This will also sort (obviously) which means you can now treat the set as and "ordered set". Take a look at this library and how it is implemented: https://github.com/SWI-Prolog/swipl-devel/blob/347a3cca9b9101b567599cc0523c3c62bc337258/library/ordsets.pl This should give you ideas about the set and the bag stuff. Not sure how your "bags" are defined. Is this a bag: `[a,a,a,a,a]`? Is it a "sub-bag" of `[a,b]`?
You need to be more specific about this. You cannot possibly write any useful program if you cannot use _any built ins at all_. So I guess the question is "which built-ins are you allowed to use?". Anyway, the SWI-Prolog repo that I linked has implementations of many predicates, so you can just go ahead and copy the implementations to your code.
Sorry to tell you dude but "Don't use any built-in functions" requirement on a Prolog course tells me that your instructor is a complete moron. My condolences.
Yeah, but I'm not entirely sure I liked her as a person in the first place. I respected her as a professor since she was my first CS prof and the only woman in the department. But yeah, I'm probably going to start avoiding her like the plague now.
From experience, the biggest problem is that there is a huge misalignment between what the instructor is trying to achieve with a course, and what the students think they will get from the same course. It would be extremely useful if you managed to squeeze out of your professor, in some form, the goals that she has with this Prolog course. If you know this, the exercises will make more sense and will be easier to get done.
A bag is a set which can have repeated elements and there is no particular order. So yeah, [a,b,c]=[c,a,b]. For two bags to be equal, they must contain the same number of elements. So, [d,o,g] does not equal [d,o,g,g,o], but [d,o,g] is a subbag of [d,o,g,g,o]. I tested my equalLists function (is that the right word?) and it worked. equalLists([1,2,3],[1,2,3]) evaluated to true while equalLists([1,2,3],[1,3,3]) evaluated to false.
So is there anything particular about the E variable? I've seen it used before but I haven't seen anything to suggest that it's got a particular function, maybe just a common practice? As for the \+, can I use not(X) instead of \+ X? Or am I really just not understanding the not predicate? I think I understand recursion, conceptually, it's just difficult for me to envision the process step-by-step. I really appreciate all of the time you've spent helping me, by the way! You've already done so much more for me than my professor has lol
There is nothing particular about using E, it's just that it's the first letter of Element, probably. as for the use of not instead of \+, i don't think it makes a difference, but I generally use \+ because it's an operator and I generally don't have to worry about making a mistake in putting a wrong use of not, like using not(A) = B instead of not(A = B). The best way to really understand recursion is experimenting and making mistakes. You should at least take tome some time to look at some built-in list-handling predicates, like member/2, select/3, append/3 and permutation/2. Most of them will be really useful in these problems and it's very easy to find a simple implementation of them. Lastly, You're welcome! I had a tremendous problem in trying to understand how I was supposed to do the programs, so I know how frustrating all of this this can be. I don't really mind to help with I can. P.S.: It's not that hard to find these predicates in textbooks. The one my professor gave me was really old, it was from, like 1995 or so, but it had most, if not all, of the predicates of your assignment. Just Saying.
If I'm not mistaken, Bags can contain duplicates, while Sets cannot. About your subBag predicate, the problem is because of the use of member, since it will return true in the first occurrence of the element, which means that, so it does not matter the amount of elements you have in the list, as long as the list has one, it will return true. You should take a look in select/3, since it can return the list without the element.
So, I've tried making it recognize that it should return false if there are more occurrences of a particular element in the subbag, but I can't figure it out at all. Any pointers? I also tried writing equalBags doesn't care about order, but it seems to want to care about order lol equalBags([],[]). equalBags(X,Y) :- subBag(X,Y), subBag(X,Y), X=Y.
Your subBag predicate will be correct if you change member to select and change the variable that goes in the recursive call. Your equalBags predicate cares about the order because of the unification in the last line. Lists are, like any other thing in prolog, a predicate, '[|]'/2, if I'm not mistaken, but let's use ./2 for make things easier. When you have a list like: [a,b,c,d] You actually have: .(a, .(b, .(c, .(d,[])))) So, when you say: [a,b] = [b,a] In the last line, you are doing the unification a = b, which will fail, cause they're both atoms and distinct from each other. The first step is to remove that line. I guess you put that because it returned true for sub-bags of Y, but that's you've put "subbag(X,Y)" twice instead of "subbag(Y,X)" in the second line.
&gt; Your subBag predicate will be correct if you change member to select and change the variable that goes in the recursive call. I'm not following. Should I have member(Y,Bag)?
The select/3 predicate is like this: select(X,[X|L],L). select(X,[E|L],L1) :- select(X,L,L1). And basically it does the same as member, except that its third argument unifies with the list without the element. For example: ? - select(3,[1,2,3,4,5],X). X = [1,2,4,5] If you use that, you can avoid the program reading the same occurrence multiple times, since it will be removed from the list. So, when you have a bag [1,2,3,5,5] and the sub-bag [5,5,5] : sub-bag: [5,5,5] bag: [1,2,3,5,5] select(5,[1, 2, 3, 5, 5],[1,2,3,5]) sub-bag: [5,5] bag: [1,2,3,5] select(5,[1,2,3,5], [1,2,3]) sub-bag: [5] bag: [1,2,3] select(5, [1,2,3], X) -&gt; fail And then would return false.
You, my good sir/ma'am, are a freaking miracle worker! Thank you so much!
I'm by no means a prolog expert (or even amateur tbh) but I think the assignment to 0 at the top is going to mess with your outcome. If I recall correctly, once a variable is assigned like that, it doesn't change. Again, I know very little about prolog.
Your post is kinda confusing, so i'm going to try to put it in another way to be sure that i'm understanding. For what i'm understanding, you have an assignment which you have to implement some database-queries predicates. Those would be: 1. A predicate num_cred/2 that takes as input a list of courses (represented as their abbreviation), and output the sum of their credits. 2. A courses/2 that that takes the identifier of a student (probably one that is indexed), and output a list of all the courses this student has attended (is it implying that the student has completed/cleared/passed the course? Sorry, I'm not used to college jargon in english). The other two I can't be sure because I have no idea what ECTs are (is it credits? electives?). I guess you wanted to show your input/output like that: Input Output num_cred([pai,qf,d],X). 30 courses(alice,X). [pai,qf,d] pass2(X). alice fail2(X). bob And that would be your num_cred/2 implementation: num_cred([], 0). num_cred([H|T], Sum) :- num_cred(T, Rest), course(H, P, C), Sum is C + Rest. And that would be your Knowledge-base: course(pai,inf,10). course(qf,eco,10). course(d,law,10). student(alice,ss). attend(alice,pai). attend(alice,qf). attend(alice,d). student(bob,ss). attend(bob,pai). You could answer if it were to be like that, and clarify about the things that I have no clue of as well. With all that said, I have no clue of what exactly is the issue you having. Since you only implemented num_cred/2, I made a test with the case you showed to check its correctness, and their result matched. Could you be more specific about what is the problem with your predicate, preferably including expected input-outputs queries that fails? One issue I found, though, is the way you presented your knowledge base. You should not mix definitions of two predicates, instead you should define all its facts and rules adjacent to each other, like that: course(pai,inf,10). course(qf,eco,10). course(d,law,10). student(alice,ss). student(bob,ss). attend(alice,pai). attend(alice,qf). attend(alice,d). attend(bob,pai). 
Not necessarily the most efficient, but a simple way to do this would be to use a DCG rule of a form: upper(Y) --&gt; [X], { X &gt; 96, X &lt; 123, Y is X - 32 }, !. upper(Y) --&gt; [Y]. uppers([H | T]) --&gt; upper(H), uppers(T). uppers([]) --&gt; []. (Code written directly in this post, use at your peril).
What version of SWI-Prolog is installend on machine? Maybe machine has an older version. If your machine has version that is less than 7 you should tell machine to get a newer version. But this is a small problem. Your bigger problem is that you maybe don't understand what is atom, string, term, code list? Maybe you should read that first somewhere.
OP doesn't know between string, atom, code list, and you are throwing DCGs at them. :-) But are you serious with the hard-coded ASCII values there?
You need to decide what data type you are working with. Is it atoms? Strings (not Prolog standard, available for example in SWI-Prolog 7)? Code lists? Char lists? Once you know what data type you are using you can decide how to do it. But basically there should be, somewhere in your Prolog, something equvalent to [SWI-Prolog's char_type/2](http://eu.swi-prolog.org/pldoc/doc_for?object=char_type/2) that lets you do this character by character. Otherwise your question is impossible to answer with code because it is too broad.
But you really shouldn't be doing this. There are libraries for this kind of stuff and it is not easy/trivial to do right except in the most basic cases. You need to take care of encoding and non-ASCII _at least_.
So what is your question?
Hm, I think we have a [repeat offender](https://www.reddit.com/r/prolog/comments/8bk6lz/noob_here_give_me_some_quick_help/).
at least this man is really trying to learn prolog
I really hate to say it but the only way to learn to program is to read programs written by good programmers. And of that there is very very little easily available out there. Basically you need to somehow bootstrap yourself (by reading dead tree books?) until you are able to read something like the library code of SWI-Prolog. It doesn't help at all that many of the excellent Prolog programmers that are currently a bit more active online are quite deep into it, to the point that they literally refuse to accept that there is "vanilla" Prolog and insist on some esoteric (to a non-expert) coding style or programming ideology.
I also think (s)he might be a bit afraid to get caught cheating which is a pity.
Not the "only" way, just the near best. You can learn on your own, but your path can be short, wavey, absurdly long, incomensurate.. I never got to talk to any prologist .. I never realized that. I wish I'd have some meetups .. I'd be very curious to see them operate IRL :)
Just use `select/3` as many times as your N says. Backtracking will give you the solutions. Collect them with `bagof/3` or `findall/3`.
There is quite a bit of misleading advice here.
I must obey [Cunningham's Law](https://meta.wikimedia.org/wiki/Cunningham%27s_Law) and [do the right thing](https://xkcd.com/386/). First, it seems that OP (or their teacher) is misusing the term "permutation". Maybe they are talking about "variation", some special case of [k-permutations of n](https://en.wikipedia.org/wiki/Permutation#k-permutations_of_n), or most likely, just a [combination](https://en.wikipedia.org/wiki/Combination). We also have to do a lot of guessing as to what is meant by "order" in this context, since OP has an ordered list of ordered pairs in their example. The significance of the pairs is also unclear. The example could have been so many other things that I don't even feel like going too deep, but why not: [a, b, c], N = 2 --&gt; [[a,b], [a,c], [b,c]] or [a, c, d, b], N = 2 --&gt; [[a,c], [a,d] [a,b], [c,d], [c,b], [d,b]] Are those correct examples? We don't know. Only god in his infinite wisdom knows. We also don't know what is the significance of the (1, 2) or (1, 4) thingies. Nor do we know why on earth is this weird python-style pseudo-tuple structure used. Why not 1-2, 1-4? And why keep on dragging the 1 along if it always stays the same? Why not just [1, 2, 3, 4]? Or numlist(1, 4)? Or even "Non-negative integers up to 4"? Again, we don't know. But calling this a permutation and solving it using a predicate called permutation is almost certainly wrong (unless OP gives a good reason why they think it is correct). There is no need to use some weird `\+ member` stuff there if it is indeed just a combination and the input list is a set (represented as a sorted list???). But of course we don't know that. Whatt a shitty assignment, really.
If you add the clause has\_job\(\_,\_\) at the very end, you will get a 'true' exit. I have not programmed in Prolog in a long time time so I don't remember why that is necessary !!!! But it works...
 ?- has_job(cagarayt, not_much_longer). true.
not fails if its argument succeeds and succeeds if its argument fails. But it also prevents any binding to happen. So a double not succeeds exactly if the inner argument succeeds but without binding unbound variables. The given predicate thus tests if A could be bound to 0 and also could be bound to 1 without doing either, which is only true for unbound variables. Testing that an unbound variable has been passed to it seems to be its only purpose.
I am lacking the context as well, it is just a practice task where there are a couple of predicates and we have to find their use cases if there is one. There are completely useless predicates as well. Thanks for your clarification and examples!
I didn't consider the binding, very well explained, thank you!
You should show the queries in b. and the solutions you get.
I think this is a very good start! You can significantly improve termination properties of this code by applying *iterative deepening*. For example, simply add the following (entailed) constraint to test/1: length(Input, _) Iterative deepening is an asymptotically optimal search strategy under very general assumptions. To improve determinism, I suggest you use a so-called *clean* representation of states that lets you *symbolically* distinguish between halting and non-halting states. For example, you could use h(S) to denote a halting state S, and n(T) to denote a non-halting state. The second source of unneeded choice-points can be avoided for example by turning the transition table into a Prolog predicate, and letting the system's *indexing* mechanism select only applicable transitions while retaining the code's full generality. It helps if your Prolog system supports *transactions*, i.e., a way to temporarily assert clauses, to benefit from indexing while minimizing side-effects. One small comment: the pattern "[], NT" in DCGs can be read as: "*nothing*, and then NT", and can always be replaced by "NT" alone. 
Maybe you should post on reddit and ask. Googling it is useless. And forget about books, no one cares about books.
http://www.learnprolognow.org/
You basically just need to know the pattern for recursion in Prolog. I found it to be the hardest concept, but also the most important. It looks like this: % base case(s). recurse_something(A, A). % Where A is the smallest possible element. % recursion case(s) recurse_something(A', B') :- recurse_something(A, B). % Where A' is a more complex version of A, and B' is a more complex version of B. A and/or B eventually reduce down to the base case. You just need to work through problems to develop an understanding of it. Recursion is a bit of a brain cooker in any programming language. Work through a deduction on paper perhaps. You use a lot of paper, but it becomes apparent after a while. % Base case. An empty list is already compressed. compress([], []). % Another base case. A list with one element is already compressed. compress([X], [X]). % If an element is repeated, try again with only one. compress([X,X|Xs], Zs) :- compress([X|Xs], Zs). % You can add X to Zs if it's not repeated. compress([X,Y|Ys],[X|Zs]) :- X \= Y, % X and Y are not the same. compress([Y|Ys],Zs). % recurse, eventually Ys=[] and Zs = [].
For example, SWI Prolog supports transactions for its RDF database: http://eu.swi-prolog.org/pldoc/man?section=semweb-update-view For more information, see *Extending the logical update view with transaction support*: https://arxiv.org/pdf/1301.7669 It includes a section on related work that mentions various implementations and prototypes. The paper also mentions possible future extensions which will probably become available if there is sufficient interest from application programmers. Regarding the look-ahead: You only need a sufficiently smart implementation of DCGs. Whether or not there is something left to parse can be pulled into the clause head, and hence decided by argument indexing. Adding a !/0 only makes the code incomplete. 
Some time ago, when I was taking intro to automata, I wrote this: https://github.com/wvxvw/intro-to-automata-theory/tree/master/automata . This is by no means a good quality Prolog code, but it does implement some textbook algorithms. In particular, it does string matching in linear time. Not sure how much will you be able to salvage from it, but just in case you will find something there that may be helpful...
&gt; Can you point exactly where in the code the string matching is? https://github.com/wvxvw/intro-to-automata-theory/blob/master/automata.pl#L82 This is the predicate (the next one after it can also match just the prefix). But I doubt it will help you generate strings. The code in the link was written to do things like converting DFA to NFA to regex and back, to do products or concatentations of DFAs, to minimize DFAs etc. It always worked under assumption that the input is ground (at least I never even considered testing it with something that wasn't).
Alright, thank you! Although TBH one reasonable approach would be to take the DFA and generate the code that one would hand-write otherwise. This is fairly straight-forward (says I without having done it yet), esp if the DFA is available at compile time. I will try to do this and report the success or failure. I also suspect that this has already been done. I know that there is more than one pack for SWI-Prolog for regex; the conventional wisdom is that it is always better to write a DCG instead of a regex, and I'd also say that it's probably easier to write a DCG instead of a DFA. I guess this exercise would be interesting for the cases where the DFA is already there and the DCG has not yet been written.
I think that having a DFA is mostly interesting for things that aren't often used in practical text parsing: things like algebraic operations on graphs representing it. I.e. product of DFAs or concatenation, or subtraction. At the time I though about using regular expressions to describe behavior (state transitions) of objects in OO language, so this algebra would be useful in automatic correctness proofs, but I never actually got to working on this project.
So, to cut a long story short, the DCG idea was stupid maybe. It is more of a liability than anything else. For the simple example, a normal predicate would look something like this: binary_even_0s(String) :- length(String, _), s1(String). s1([]). s1([X|Xs]) :- s1_transition(X, Xs). s2([X|Xs]) :- s2_transition(X, Xs). s1_transition(0, Xs) :- s2(Xs). s1_transition(1, Xs) :- s1(Xs). s2_transition(0, Xs) :- s1(Xs). s2_transition(1, Xs) :- s2(Xs). Shortly, you need the `length(String, _)` to enumerate solutions in increasing length (when the string is a variable). Then, you call it with the starting state. Then, for each state, you split the head and the tail and pass them to a predicate that does the transition: state_N([X|Xs]) :- state_N(X, Xs). Additionally, if the state is in the set of accept states, you need a clause that accepts an empty list: state_N([]). This is for example `s1` above. Then, for each transition, pass the rest of the input to the next state. These are the `state_N_transition/2` predicates above. Obviously this is very straight-forward to generate. Here is a module that does that to some degree. ("To some degree" means it works for demonstration purposes.) :- module(dfa, []). :- multifile system:term_expansion/2. system:term_expansion(dfa(Name, Q_0, F, D), Clauses) :- transitions_states(D, Q), atomic_list_concat([dfa, Name], '_', N), phrase(compile_dfa(N, Q, Q_0, F, D), Clauses). transitions_states(D, Q) :- maplist(transition_state, D, Q0), sort(Q0, Q). transition_state(transition(S, _, _), S). compile_dfa(Name, Q, Q_0, F, D) --&gt; dfa_entry_point(Name, Q_0), dfa_states(Q, Name, F), dfa_transitions(D, Name). dfa_entry_point(Name, Q_0) --&gt; { atomic_list_concat([Name, Q_0], '_', Start_name), Head =.. [Name, String], Start =.. [Start_name, String] }, [ (Head :- length(String, _), Start) ]. dfa_states([], _, _) --&gt; []. dfa_states([S|Ss], Name, F) --&gt; { atomic_list_concat([Name, S], '_', N) }, accept_state(S, N, F), dfa_state(N), dfa_states(Ss, Name, F). accept_state(S, Name, F) --&gt; { memberchk(S, F), Clause =.. [Name, []] }, !, [ Clause ]. accept_state(_, _, _) --&gt; []. dfa_state(Name) --&gt; { atomic_list_concat([Name, transition], '_', N), Head =.. [Name, [X|Xs]], Body =.. [N, X, Xs] }, [ (Head :- Body) ]. dfa_transitions([], _) --&gt; []. dfa_transitions([transition(From, Input, To)|Ts], Name) --&gt; { atomic_list_concat([Name, From, transition], '_', HN), atomic_list_concat([Name, To], '_', BN), Head =.. [HN, Input, Xs], Body =.. [BN, Xs] }, [ (Head :- Body) ], dfa_transitions(Ts, Name). What this does is that it takes a DFA in the form as in the original problem statement (start state, accept states, transitions), plus a name, and generates the code as in the simple example above. So with this module, and with SWI-Prolog, with the following source: $ cat binary_even_0s.pl :- use_module(dfa). dfa(binary_even_0s, s1, [s1], [transition(s1, 0, s2), transition(s1, 1, s1), transition(s2, 0, s1), transition(s2, 1, s2)]). $ swipl ?- [binary_even_0s]. true. ?- dfa_binary_even_0s([]). true. ?- dfa_binary_even_0s([0,1,0,1]). true. ?- dfa_binary_even_0s([0,1,1]). false. ?- dfa_binary_even_0s([0,0,x]). false. ?- dfa_binary_even_0s(String). String = [] ; String = [1] ; String = [0, 0] ; String = [1, 1] ; String = [0, 0, 1] ; String = [0, 1, 0] ; String = [1, 0, 0] ; String = [1, 1, 1] ; String = [0, 0, 0, 0] . In other words, no unnecessary choice points, works in constant space, nicely enumerates strings of increasing length when the argument is a free variable (the last thing is due to the idea by /u/zmonx to use `length/2`). At least I finally got to use compile-time term expansion, which seems like fun. I am sure that this code is full of logical errors of all kinds, so criticism is most welcome.
Yes, I don't doubt the value of a DFA. What interested me was how to implement it in Prolog. I now managed to write some code that takes a DFA and generates at compile time the code to actually implement the DFA. Most importantly, now you can also generate strings without the code getting any more complicated (the generated code is not complicated... the code that does the compile-time expansion is a bit weird but this is the first time I write such code so....). See it [here](https://www.reddit.com/r/prolog/comments/8hmaw3/dfa_in_prolog_avoiding_choice_points_and_fixing/dyvj7mg/).
An interesting thing to reflect on here is that the predicate you are given will succeed only once, however, there are multiple ways it can succeed. Prolog is actually capable of expressing this situation (succeeding multiple times), but once you think about this problem further: succeeding multiple times here will be the same as just generating all permutations of all sub-multisest of given size of the given mutliset, no randomness involved. As for your particular solution, it seems like `remove_at/4 is a reimplementation of standard predicate `select/4`. It probably comes from `p20`, which you completed earlier. I'm not sure about the rest. What problems did you encounter when trying to understand this solution?
You need to learn to format your code. I can't know what you wrote because I don't see the code as you wrote it. So just edit your post. There should be "formatting help" link on the lower right.
There: 1. This is textbook stuff. Grab a textbook and read it. I suggest, for example, "The Art of Prolog". These predicates are explained there. 2. It doesn't help to keep on trying to "understand" code. Code means something. This code means "the list in the first argument and the list in the second argument, appended, is the list in the third argument". When you write this in Prolog, the code that you see is what you get.
You're clearly missing a comma between `[H|T]` and `R`.
Hey, zmonx, just a quick heads-up: **should of** is actually spelled **should have**. You can remember it by **should have sounds like should of, but it just isn't right**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
&gt; But full support for transactions should of course support nondeterminism as well. Thank you, CommonMisspellingBot! I correct my statement to: But full support for transactions **should have** course support nondeterminism as well.
Don't even think about it.
Are you sure the facts that get assertz-ed are local though? And local to what? To the thread? It also will be implementation dependent I guess? Otherwise it seems straight-forward: setup_call_cleanup( assert_facts, goal_using_facts, retract_facts) The visibility is still a problem, isn't it?
I mean local in the sense of: Only visible for goals running during the transaction. If your Prolog systems supports threads, obviously this should also be supported in some way.
That's very interesting; I am still afraid I might be misunderstanding. So can you demonstrate this, with code, in any existing Prolog implementation? Or are you describing something that would be nice to have and desirable and doable using the techniques you mentioned earlier?
I read your comment more carefully. So _not_ local to the scope of the calling predicate, but just _temporary_. This is not too useful I am afraid. The textbook solution for scope-local "data" is to use a data structure, and it seems that this holds. I did some trying out, including using for example `library(assoc)` (as implemented in SWI-Prolog). Unfortunately, in `assoc`, there are `get_assoc/3` and `gen_assoc/3`, _and_ on top of this `gen_assoc/3` leaves behind a choice point after the last solution. And the reason why I bothered implementing the compile-time expansion was that I agree with you that it is very nice to use predicates/tables for representing data. At the same time, asserting and retracting is too much trouble, esp. because it would have to be combined with using `call` to evaluate whatever was asserted. All in all, at that point compile-time code generations seems like a cleaner way to achieve the same goal. Thank you for all the useful comments!
Each line that starts with a "?-" is a conjunction of *goals*. For example, in: ?- g(a), h(a). the two goals are g(a) and h(a). Prolog applies **SLD resolution** to find a counterexample of the negated query, i.e., an instance where the query is actually a *logical consequence* of the given clauses. This kind of resolution always proceeds in the same way, by picking the leftmost literal and resolving it with the available clauses. Since the leftmost goal g(a) obviously holds (due to the fact g(a) that is part of the program), Prolog proceeds to consider h(a). Since that is also the case, we have found a substitution (X = Y, X = a) that makes the query a logical consequence of the program, and is hence a solution. After that, [nothing to do here](http://i0.kym-cdn.com/entries/icons/original/000/006/707/nothing-to-do-here-template.jpg.scaled500.jpg), in this branch of the computation. On backtracking, alternative clauses are also considered. They tried in the order they appear in the program. So for example, when resolving f(X), the two cases X = a and X = b are tried in this order. You will likely not get very far with Prolog if you try to understand it in this way, since the precise steps that Prolog applies when searching for solutions is too hard to understand in general. In my experience, it is far better to concentrate on more general notions, such as universal termination properties of your predicates and the different possible usage modes.
In my experience, thinking about recursion in the "forward" sense is a very poor strategy, and you will not get far along with it. Say you are given some typical task, like "drop an element from a list in Prolog". A student with a bad instructor will go about it like this: OK, I have a list and I want to drop an element: drop_element(List, E) :- and then have no way to go "forward" with this. In my experience, a much better strategy is to think more in terms of an *inductive* definition, and get rid of the imperative thinking entirely. This starts already with the **name** of predicates. In this particular case for example, think not "how do I drop an element?", because that already implies a *direction* of use and precludes more general readings. Instead, ask: "What is the **relation** I want to describe? What are the entities that are involved?" And finally: What are the **conditions** that make the relation hold? Backtracking happens *automatically*, Prolog **will do it for you**. *Your* task is to focus on a clear *description* of the relations you want to express. If you are stuck start with simple cases, write down concrete facts one after the other, stating cases that you *know* hold. Then, *generalize* the definitions. For example, when you have found a concrete case that holds for a list of the form [a], what else can you say? Does it hold for *all* single-element lists, i.e., [_]? Does it hold for lists with *at least* one element, i.e., [_|_]? Or only a particular subset of those cases, i.e., [L|Ls], with some *constraints* on L or Ls? Then, use the clauses you already have to describe further cases. This way, you will **inductively** construct declarative descriptions of *what holds*. Recursion and backtracking is what Prolog will do for you. You need not worry about them *at all* when writing your code.
Thank you very much, your feedback helps a lot. I have 2 problems that I could use clarifications on: 1\) factorial. I don't understand why in the body factorial is being called with F1 when it hasn't been declared yet and why is F being assigned after it? factorial(N, F):- ( N &gt; 0 -&gt; N1 is N - 1, factorial(N1, F1), F is N * F1 ; F = 1 ). 2\) for this one I don't have the solution but the problem is to find the maximum number in a list, for example given \[1,2,3\] would be 3. Could you go over how you would start thinking of a solution for this? Should you consider base cases first or the recursive case first?
You do not need to "declare" anything in Prolog. Terms come into existence by *writing them down*. Your definition of "factorial of N and F" states *when it is the case* that "factorial(N, F)" holds. It holds **if**: If N is &gt; 0, then it holds *if* etc. Otherwise, it holds if F = 1. An obviously *unintended* result is that for example the query "?- factorial(-30, F)." *succeeds*. The exercise could have been much more clearly solved along the following lines: Which cases *are there to consider*? Start with concrete cases. For example: n_factorial(0, 1). n_factorial(1, 1). n_factorial(2, 2). n_factorial(3, 6). Then, try to make this more compact. How many cases do we *really* need? For example, let us distinguish between N = 0 and N &gt; 0: n_factorial(N, F) :- N = 0, ... n_factorial(N, F) :- N &gt; 0, ... Then complete these clauses. *Under what conditions* are these cases true? In the first case, and in the second case? What must hold for F such that we can say "Yes, F is the factorial of N." For (2), exactly the same strategy applies. Start with concrete cases. For example: list_maximum([1], 1). list_maximum([1,2], 2). list_maximum([1,3,2], 3). Then make this more general, and more compact. Which cases do you need to distinguish? For example, let us distinguish two cases: Lists that have *exactly* one element, and lists that have *at least* one element: list_maximum([L], Max) :- ... list_maximum([L|Ls], Max) :- ... Again, *what must hold* for Max, L and Ls so that we can say: "Yes, Max is the maximum of this list?" Note that I say "*is*", and not "*find*". The reason is that we want to use the same relation also to **generate** solutions out of nowhere, where there is nothing to *find*, but to *construct*. So, again, eliminate imperatives from your vocabulary when working on Prolog programs. Clear descriptions of what holds are all that counts, and yield most general programs.
Yep! Your explanation was otherwise great. 
Thank you very much again. I tried to implement that example you have with dropping an element from a list. I'll walk you through how I did it: drop_x/3 Ex: drop_x([1,2,3],2,L). L = [1,3] First I thought of a base case of dropping an element from a list that only contains thats element which was pretty easy. drop_x([H], H, []). Then I thought about if there were more than 1 element so in this case I would "copy" the head from the input list to the output list. drop_x([H|T], X, [H|T2]):- drop_x(T, X, T2). And the case of when the head of the input list equals the element, don't "copy" it. drop_x([H|T], H, T). So putting all that together everything seems to work fine. I tried to take it a step further by making a predicate drop\_all\_x that would drop all occurrences of an element from a list. This is what I came up with: drop_all_x/3 Ex: drop_all_x([1,2,1,2,1,3,1],1,L). L = [2,2,3] drop_all_x([X], X, []). drop_all_x([X|Xs], E, [X|Ys]):- % put head of input list into output list drop_all_x(Xs, E, Ys). drop_all_x([X|Xs], X, Ys):- % if head of input list is equal to element skip it drop_all_x(Xs, X, Ys). It seems to get me the right answer but I'm not sure if I did it right, also I think it's doing some sort of weird backtracking, this is the output I got: | ?- drop_all_x([1,2,1,2,1,3,1],1,L). L = [1,2,1,2,1,3]; L = [1,2,1,2,3]; L = [1,2,2,1,3]; L = [1,2,2,3]; L = [2,1,2,1,3]; L = [2,1,2,3]; L = [2,2,1,3]; L = [2,2,3]; no
It does get the right answer, but it is clearly **too general**, because it also holds for cases that should *not* be among the solutions. The beauty of logic programming is that you can reason in a logical way about these cases. Here, you must make one of the clauses *more specific*: No further (pure) clause you add can remove the invalid answers! Hint: The built-in predicate dif(X, Y) is true iff its arguments are different.
I strongly reccommend getting a copy of "The Art of Prolog" by Sterling &amp; Shapiro. Your library should have it. It has thorough explanations of most basic predicates (appending, selecting, and so on). It dedicates a whole section to learning how to define recursive predicates in Prolog. I don't think you need to read the whole book (you should if you have time), it is enough to read selectively the first one third, approximately.
It would be easier to help you if you told us: - what is the scope of the exam you are preparing for? - what is the learning material you are supposed to have covered for the exam? - any previous exams given by this professor for this lecture? This provides a lot of context and makes it easier to limit the question of "How do I program in Prolog" (a huge question without a clear answer) to "How do I learn to program enough Prolog to pass this exam" (a question that is still hard but much smaller). Otherwise all you will get are ad-hoc answers to specific questions. We don't even know if these answers are acceptable by the standards set by whoever is going to grade your exam. Here is a small example, using your "maximum number in a list": Do you do it like this: list_max([X|Xs], Max) :- list_max_1(Xs, X, Max). list_max_1([], Max, Max). list_max_1([X|Xs], Max0, Max) :- Max1 is max(X, Max0), list_max_1(Xs, Max1, Max). This is identical to the [library implementation in SWI-Prolog](https://github.com/SWI-Prolog/swipl-devel/blob/1595c5ba46a87c0c9e268a94546e3cb4e1df8b49/library/lists.pl#L548-L561), an open-source, publicly available Prolog implementation. This is arguably a good way to define it. But it is probable that your instructor expects a different implementation (we can only guess what it would be).
The example in the slide you linked is copied verbatim from [here](http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse6) from the "Learn Prolog Now!" textbook, freely available online. There is enough explanation there so just try and read it.
Thanks for the feedback. Basically it’s an upper division computer science course called programming languages. It’s one of the final classes you take before graduating so by this point they expect you to know pretty much everything there is to know about computer science. The class started by doing brief overviews if well known languages like c, python, JavaScript etc. then went into functional languages (SML), then general programming languages syntax/semantics/data types (we wrote our own parsers using regular expressions). The final topic now is logical languages and prolog specifically which is all the exam will be on. We pretty much went over all the semantics/syntax of prolog and how it works. We didn’t learn about lambdas specifically, but I would be able to use it on the exam (any valid prolog is OK). We covered the language pretty quickly though (over the course of 2 weeks). We’re using XSB Prolog so the professor said any library predicates included in prolog itself or XSB we can use (not SWI). For example, XSB includes the predicate “sort” similar to that of SWI but it doesn’t include a majority of what SWI has. The exam itself is gonna be straight prolog coding questions where he gives you a predicate name and describes what it has to along with a sample input and output of the predicate. He likes to make questions that involve combining or separating lists/strings in various ways. An example is: given any 2 strings S1 and S2, return the index of the first occurrence of S2 in S1 (if there are any). Here’s a couple more example questions: [Example 1](https://ibb.co/gEmCyy) [Example 2](https://ibb.co/chAuBJ) 
Hmm. It doesn't look like XSB Prolog is too different from normal Prolog. It is a bit annoying that the documentation is only available online as PDFs. But anyway. For the substring question, you already have this in the standard library: [Manual 1](http://xsb.sourceforge.net/manual1/manual1.pdf), 15.5, "Low-level Atom Manipulation Predicates". The first question is interesting in the sense that it explores backtracking. It also seems quite straight-forward (on first sight). Don't ask me how I got this solution, it just makes sense: interleave([], [], []). interleave([X|Xs], Ys, [X|Zs]) :- interleave(Xs, Ys, Zs). interleave(Xs, [Y|Ys], [Y|Zs]) :- interleave(Xs, Ys, Zs). ?- interleave([1,2], [x,y], R). R = [1, 2, x, y] ; R = [1, x, 2, y] ; R = [1, x, y, 2] ; R = [x, 1, 2, y] ; R = [x, 1, y, 2] ; R = [x, y, 1, 2] ; false. This is exactly the sort of stuff that "The Art of Prolog" really helped me with. So try to get the book if you can... I think it was Chapter 7, "Programming in Pure Prolog" that would be most relevant for you. The second question I cannot answer because I don't know how the graph is represented. As a table in Prolog? In the S-representation as in [library(ugraphs)](http://eu.swi-prolog.org/pldoc/man?section=ugraphs)?
Downvoting your post for yet again failing to format your code as code. Sorry :-(
Reformatted for anybody who comes along after: subset(_,[]). subset([H|T],[H|T2]):- subset(T,T2). subset([_|T],T2):- subset(T,T2). subset2(S,S2):- findall(X, subset(S,X), L), member(S2, L). member(H,[H|_]). member(X,[_|T]):- member(X,T). --- So `member` here is a re-implementation of the built-in [`member/2`](http://www.swi-prolog.org/pldoc/doc_for?object=member/2) predicate. Among other uses, it lets you test to see whether an item is a member of a list and, alternatively, it lets you enumerate the members of a list. `findall` is used to collect all the solutions to a query into a single list. Prolog typically produces a single sequence of solutions to the top-level query. That's fine, but you sometimes need to see all the solutions at once. `findall` can do that for you. [Learn Prolog Now!](http://www.learnprolognow.org/) has [a section covering it](http://www.learnprolognow.org/lpnpage.php?pagetype=html&amp;pageid=lpn-htmlse49). I'm not at all clear on why `subset2/2` even exists. It uses `findall` to collect the solutions, but then uses `member` to turn them back into distinct solutions. That seems pointless.
Why not explain *how* to properly format, or at least provide [a link to something explaining it](https://www.reddit.com/r/raerth/comments/cw70q/reddit_comment_formatting/).
I did already in two previous posts by the same user.
Yeah wow I was stumped on that interleave question for so long I can’t believe the solution is so simple.. thanks. I really think I’ll take a look at this book. For the graph problems all the predicates are of the form p(+A, +G) where A is a list of the nodes ([1,2,3,..]) and G is the graph in the form: [edge(0,0), edge(0,2), edge(0,3), edge(2,3),...]. Sorry, forgot to mention that.
Do you mean that you have a program that has a predicate without a body (a _fact_) that looks like: p([0,1,2], [edge(0, 1), edge(1, 0), edge(2, 3)]). Are the nodes in any particular order? How about the edges, are they in any order? And I assume they have direction? So `edge(1, 0)` means there is an edge from node 1 to node 0? And any idea how you are supposed to query this? ?- p(A, G), reflexive(A, G). ??
Yes exactly like that, the list of nodes will be in ascending order just like that and you are also right about the edges. Edge(a,b) means there’s an edge from node a to node b.
I see; I'll tag them in RES.
Ok, this is also straight-forward, except for "reflexive" (on first sight). "Symmetric" you can do by checking that for each node in A, if you have an edge X --&gt; Y in G, you also have Y -- &gt; X. symmetric([], _). symmetric([X|Xs]), G) :- member(edge(X, Y), G), member(edge(Y, X), G). I am too lazy to read textbooks now so I can't remember if X and Y can be the same node or must be different nodes. If they must be different nodes, you'd have to add `X \== Y` or `dif(X, Y)` or something along these lines. It seems you can solve "transitive" in a similar manner: you just need one more edge in the relation. "Transitive" is a bit more involved, probably. You'd have to show that there is a loop, and you don't know in advance how long the loop is. But you can use `select/3` instead of `member/3`, and then just keep on chaining the nodes, edge by edge, until you get to the starting node. There is a lot of "path" solutions for Prolog on the internets, or if you attempt something and get stuck, just ask again.
Great, thank you so much!
It looks like you could replace `right/4` with the following: right(Xs, XXs, S, I) :- maplist(reverse, Xs, Ys), left(Ys, XXs, S, I). Depending on your implementation, `maplist/3` is usually available from a library somehow. Otherwise, [here](https://www.complang.tuwien.ac.at/ulrich/iso-prolog/prologue#maplist) is a definition.
This is actually a huge area of research. There's decades of papers on implementing finite domain constraints, including years worth of work coming out of OR and AI research. 
You are lucky because both GNU-Prolog and SWI-Prolog are open-source, and both have their own implementation of finite domains. The easiest is to google each implementation's web site, then go to the download section and finally get the code. You can then read it.
The full SWI-Prolog source code is on github: https://github.com/SWI-Prolog/swipl-devel I found this by clicking on the "Download" button on the documentation page. I wonder why you couldn't see it? The GNU-Prolog code you can download as a tar: http://www.gprolog.org/gprolog-1.4.4.tar.gz The link to "Download" was at the very top of the main page. Did you miss it somehow?
I will give you two answers that are contradictory but that's how it often goes. **Answer 1**: Use `findall/3` or `setof/3`. There are many reasons why it is a folly to try and recreate either predicate on your own. **Answer 2**: often you don't want to backtrack over solutions, but put them in a list right away. It really depends on the problem. Say you have a predicate that gives you the square of a number: square(X, S) :- S is X * X. Now, you have a list of numbers and you want to square them all: % DO NOT DO THIS ! ! ! list_square(Xs, S) :- member(X, Xs), square(X, S). This will give you squares on backtracking: ?- list_square([-1, 0, 1, 2], S). S = 1 ; S = 0 ; S = 1 ; S = 4. ... and now you use findall to get them as a list: % DO NOT DO THIS ! ! ! list_squares(Xs, Ss) :- findall(S, list_square(Xs, S), Ss). and then you get what you want: ?- list_squares([-1, 0, 1, 2], Ss). Ss = [1, 0, 1, 4]. **Do not do this!** This works correctly and sometimes it's fine if you are trying stuff out, of course. The Prolog police doesn't care about this, it's just silly and wasteful (and you often are told you cannot use some predicates which is a stupidity on a whole other level... I should write a blog post about it....) Instead, **do it like this**: list_squares([], []). list_squares([X|Xs], [S|Ss]) :- square(X, S), list_squares(Xs, Ss). An identical solution is to use maplist: list_squares(Xs, Ss) :- maplist(square, Xs, Ss). In real life you'd always prefer the maplist version I guess? And now to your question: without showing what your `f(x)` looks like it is difficult to help further. But if there is a chance that you are enumerating solutions when it's possible to build the list instead, then this comment of mine _might_ be relevant.
The underscore means you didn't give names to these variables. ?- X = a(_, _). X = a(_1962, _1964). About DCGs, not that tricky, sometimes useful, sometimes not. I usually recommend this: https://www.metalevel.at/prolog/dcg
Yeah.
Then why would one use dcg? If it's the same thing?
Kinda. Did you read the explanation at the link?
Yeah, I mean it's not the same as what I sad head:-body, dcg is more for generating I guess. The other thing is more of a rule. So, idk why it says that dcg can be compared to head:-body, it's kinda confusing.
Who says |dcg can be compared to head:-body"? What does that mean? Yeah, it is confusing. What are you asking? Why? What did you read? Where?
http://www.pathwayslms.com/swipltuts/dcg/ A DCG is defined by DCG rules. A DCG rule has the form: head --&gt; body. Analogous to normal Prolog rules with: head :- body.
Don't read anything on this site. It is just bad. I don't know who's written it but most of it is stolen from other places on the internet and then somehow made less understandable and less useful.
Haha: &gt; By Anne Ogborn &gt; &gt; Thanks to Markus Triska. Large sections of this tutorial are taken directly from his tutorial, which is used by permission here. So the tutorial this is citing is the one I linked. Permission or not, it is still just badly written and somehow broken. Read instead: https://www.metalevel.at/prolog/dcg which is better written _at least_. I haven't bothered to look for factual errors in the Prolog material on pathwayslms.com but the whole thing has an amateur feel to it.
Oh, since both places (your link and that site) has similar content, I thought of sticking with the other one because they used an image for explanation haha. Guess, I'll check the other one then. Although, I've read most of it from this book "Programming in prolog". Looks easy and tricky at the same time. Is there some resources you could suggest for these topics- meta-programming, constraint logic programming over integer finite domains and and constraint meta-programming.
Hmm. What you are describing is this book, the DCG was just a chapter: https://www.metalevel.at/prolog For what you are asking this is the only accessible book I know. I would like to know other opinions of course.
you need to experiment with DCG rules to understand them. Both tutorials are equally confusing ima, but have enough info to get you started. 
No, not as much as I would like to know. But I am sure others know more than I do, so just ask.
This sub seems pretty dead, hopefully someone reads this thread.
Why are you asking? It is difficult to answer questions without context. If you want to know what it is and how it works, read a textbook. If you then have a specific question, explain what the problem is and what you don't understand.
This is a larger question though. It deserves a separate post even. The short generic answer: You can use `=..` to generate Prolog terms dynamically (at run time, not at compile time).
What kind of errors do you get? Can you show an example input file (or is the "example line" like a one-line file?)
The problem is most probably that you are mixing up the data types and the predicates. I would try and fix your code but I'd rather show you a better (easier?) way to do it. Parsing a file like this is easiest with a DCG. DCGs are just another notation for Prolog predicates. If you feel like reading about it, here is one good source: https://www.metalevel.at/prolog/dcg (this is a chapter of a book, btw) So this is how I'd do it in a hurry. This is from my command line: $ cat iris.pl :- use_module(library(dcg/basics), [blank//0, white//0, integer//1, number//1, string_without//2]). load_iris_file(Filename) :- phrase_from_file(iris_file, Filename). iris_file --&gt; iris_line(Iris), { assertz(Iris) }, !, iris_file. iris_file --&gt; []. iris_line(iris(Order, Sepal_length, Sepal_width, Petal_length, Petal_width, Species)) --&gt; [0'"], integer(Order), [0'"], white, number(Sepal_length), white, number(Sepal_width), white, number(Petal_length), white, number(Petal_width), white, [0'"], string_without("\"", Species_codes), [0'"], blank, { atom_codes(Species, Species_codes) }. Then, loading and using it (I have saved the data to `iris.data`): $ swipl ?- [iris]. true. ?- load_iris_file('iris.data'). true. ?- listing(iris). :- dynamic iris/6. iris(1, 5.1, 3.5, 1.4, 0.2, setosa). iris(2, 4.9, 3, 1.4, 0.2, setosa). iris(3, 4.7, 3.2, 1.3, 0.2, setosa). iris(4, 4.6, 3.1, 1.5, 0.2, setosa). iris(5, 5, 3.6, 1.4, 0.2, setosa). iris(6, 5.4, 3.9, 1.7, 0.4, setosa). iris(7, 4.6, 3.4, 1.4, 0.3, setosa). iris(8, 5, 3.4, 1.5, 0.2, setosa). iris(9, 4.4, 2.9, 1.4, 0.2, setosa). iris(10, 4.9, 3.1, 1.5, 0.1, setosa). iris(11, 5.4, 3.7, 1.5, 0.2, setosa). iris(12, 4.8, 3.4, 1.6, 0.2, setosa). true. There is quite a bit going on but I'd rather go into details if you have a particular question.
However: as long as your data is in a CSV format, you can also just go ahead and use library(csv). I am just a bit confused about the first column of the data: is it supposed to be a string? (or why on earth is it quoted??) The library [is pretty well documented](http://eu.swi-prolog.org/pldoc/man?section=csv). With this library, it is just two predicate calls: ?- use_module(library(csv)). true. ?- csv_read_file('iris.csv', Rows, [functor(iris)]), forall(member(Iris, Rows), assertz(Iris)). 
It should not be string actually. I really did not understand why it is quoted. It is a homework that wants us to implement kNN on iris dataset using prolog. I think it is just for driving us crazy. I cant find better thought than this.
Hm, it would seem it was exported from R using &gt; write.table(iris, file = "iris", quote = TRUE) The last option puts the quotes around the row number. But yeah, it's a shitty assignment. Maybe it's some "Learn R the hard way" approach where you first do it in Prolog to make it difficult and then bam, one-liner in R. Who knows.
WARNING: the code as written above correctly reads this particular input but it **has mistakes**. Just sayin'.
fizz 0.3 is out. Among the many changes is support for macOS. I also wrote two articles you may want to checkout for an introduction to fizz: - Building a simple stock market monitor with fizz (http://f1zz.org/downloads/iex.pdf) - Importing and managing a large data set in fizz (http://f1zz.org/downloads/ecoli.pdf) As before, feedback is welcome.
This article is an introductory material that comes with the lastest release (0.3) of fizz which is an experimental language and runtime environment for the exploration of cognitive architectures and combined Machine Learning (ML) and Machine Reasoning (MR) solutions.
Try the Prolog channel on freenode (link in sidebar). You can also post your questions here.
I can offer some support. I’m not an expert, but I like the language and lol to help. Feel free to dm me.
This sounds like a great effort! Are you also announcing in places like r/programminglanguages and /r/programming too?
Subscribed! Thanks!!
This sounds like a great idea, and I would assume that it is not a waste of time, however, a couple of red flags: &gt; We are hosting a class taking someone from 0 Prolog experience to Production Ready in 8 weeks. I either don't understand the metaphor or the joke, but at face value, this is an outlandish claim. Then, how are you going to put it on your resume? This is not a course from any recognized educational institution (is it?) so what are you going to put there? "Did Prolog for a few weeks"? You could read a book and put on resume about the same. I don't want to get into &gt; The problem with programming is it needs more Prolog. Let's hope it's just an attempt at a joke.
Hmm, let me summarize it for you: &gt; &lt;The thing I happen to know best&gt; is really underappreciated. Here are a couple of trivial examples of how it is great. &gt; &gt; And no, I have never heard of relational databases. There, you can thank me for time I've saved you later.
Today, I posted several links in sequence to gauge what this community is most interested in. While it is still a bit early to tell, it seems reasonable to assume that this discussion is not among the community's favorites of today's links? A Prolog implementation in JavaScript fared best so far. Personally, I also thought that this link is only tangentially related to Prolog. Still, I hope someone who is interested in Prolog enjoys this language being mentioned and discussed in this context. If not, please downvote: I will remove this topic at -2. 
No, don't remove anything. If nothing else, reddit should have by now taught you that "popular" is not something anyone should aim at (or be proud of). I was commenting on the general level of the submissions at the link. Basically, as I said already, it was useless in the sense that there is nothing to learn from it. And BTW, it is quite telling that no one mentioned relational databases. What do you make of that?
I want to post content that the /r/prolog community finds most interesting. Of the links I posted today, this is the only submission that evoked any reaction at all, and one I can only count as adverse. What should I make of that? Personally, if one or two more negative reactions accumulate, I consider it clear: This is content that the community does not want to see here. I see little value in posting such content, even if it may happen once or twice out of several submissions. 
Hmm, you are confusing me. What kind of community do you think this is? A few lurkers that never comment (I'd guess, by the number of up/downvotes and the lack of comments); a few idiots like me who keep on shitting all over the place for reasons unclear to themselves; and hordes of poor souls who desperately want someone to do their homework for them.
Yes it does, thank you! 
Oh noes.
Thats the next step, thanks for the suggestion!
Glad to share it with ya'll.
What do you know about azprolog? I don't often see it on the lists of prolog implementations. 
It looks like it is a heavily Japan-localised prolog. 
Why is the findall version considered "wasteful?" It's a little roundabout but doesn't seem inefficient.
It is inefficient. It is all very fast for small inputs but it starts to matter eventually. But don't just believe me, set up a test and measure it yourself.
I am improving O\-Prolog. I found more bugs than expected. I plan to release ver1.00 in June. Kenichi Sasagawa
There is another bigger problem with any of these predicates that collect all solutions. They are extra-logical, and you can read in a textbook what exactly this is supposed to mean. In practice, the problem is that your predicate stops being a true relation, meaning that you can no longer ask the opposite question. In the example above I used `is/2`, which is also not a logical operation, so this argument is totally moot.
I got that from the install. And there's a long history of Japanese interest in Prologs. 
It’s not the same as reading book. The point is that you have the community of students doing the same thing, and the mentors too. I’d totally put it on a job specific resume, or use it as a talking point in an interview. 
See especially **Meetings and resolutions**: https://isotc.iso.org/livelink/livelink?func=ll&amp;objId=8918827&amp;objAction=browse&amp;viewType=1 
&gt; any suggested videos that teach Prolog well? Why videos? I'd suggest sticking to reading material, Prolog is not that "hot" yet so there are not too many millenials teaching it on Youtube.
I'm going to need a Rule 5 on this...
I remember reading that there's another meeting happening soon? Do you know the date? Are you going to participate as well? I will be interested to read the minutes when they appear here.
There are no subexpressions to evaluate, so call by need makes no sense. Also as values are immutable there is no difference between call by value and call by reference.
The most recent meeting took place on June 4th, and I expect the minutes to become available in due time. They will contain the list of participants too.
Cool. Thanks!
[https://www.metalevel.at/prolog](https://www.metalevel.at/prolog)
I think this is very exciting. I have not read the whole document yet, but I think it would cool to be involved in spreading these idea and getting some stuff off the ground. 
What other languages do you know, besides Java, or Clojure? Something with parentheses? Javascript? Also, what do you want to learn about it? 
I don't know Clojure, that's why I'm asking for tutorials not written in Clojure. I'm familiar (to a good enough extent) with languages like Kotlin, Python, Javascript, C, Prolog. I've dabbled in Haskell but don't feel like I know it to a good enough extent, though I am comfortable with the more functional aspects of programming through the use of Java 8 streams, RxJava, etc. Basically my ultimate goal is to implement microKanren in Kotlin as I want to embed logic programming paradigms in Kotlin, but I am not totally sure how mini/microKranen is implemented or even used. From reading the tagline of this "library", it seems exactly what I'm looking for though. I'm not sure how well I answered this, so please ask me to clarify on anything if need be.
Wasn't miniKanren done in Scheme first? Or am I thinking about something completely different? Either way, Scheme is a pretty easy language in the sense that you don't need to learn anything to start using it _somehow_. PS: 10 seconds of googling gave me this: http://minikanren.org/. Look at the list of implementations at the bottom. PPS: Or do you mean a textbook and code is not enough, you need it in a tutorial-style intro?
Oh, okay. Well, if you've dabbled some with Prolog already, and are familiar with the pure subset of Prolog, then I might imagine you're already doing pretty well. For instance, the "relations" of miniKanren are pretty close syntactically to completed predicates a la Clark. For better or worse, a lot of the documentation is just (il?)literate implementations of source code. Seeing as your a Pythonist already, for instance: https://gist.github.com/cheery/d89bfb4c8d6c7a3eb908 There's javascript ones, and also a whole host of other languages: http://minikanren.org/ Most of those listed are the microKanren flavor, but the miniKanren stuff mostly amounts to fancy syntax over the basics. Even if you don't read parentheses, if you wanted to walk through with a literate implementation together with one where you understand the behavior of the language, the words of the literate one (https://mullr.github.io/micrologic/literate.html for instance) might be just the thing you're after. Oh, and you might even pick up some parentheticals as you go. Oh, and like, also, ping me if I can help! 
Correct, and [The Reasoned Schemer](https://mitpress.mit.edu/books/reasoned-schemer-second-edition) is the book that spawned miniKanren.
Yeah sorry, it's Scheme not Clojure I was talking about :/ I've seen the implementations on the website and have tried to go through it. I'm more looking for a textbook/tutorial. As an example, if I wanted to learn about linked lists, I'd want the theory behind it, best practices, limitations, etc. (which is usually what Wikipedia will give me) and then I'd look through implementations in whichever languages I want (or implement it myself if need be). I'm looking to take a similar approach to learning miniKanren.
So what is wrong with "The Reasoned Schemer"?
https://github.com/SWI-Prolog/swipl-devel/blob/6f3cbcb74238e7762ffa5eedf6bc48b8c8cd1c64/library/lists.pl#L153-L159 %! select(?Elem, ?List1, ?List2) % % Is true when List1, with Elem removed, results in List2. select(X, [X|Tail], Tail). select(Elem, [Head|Tail], [Head|Rest]) :- select(Elem, Tail, Rest).
Thanks, an example would be: := isRemoved( a, build(a, build(c, build(a, null))), build(c, null)) =&gt; TRUE
Haha that is funny. Who gave you this assignment? The idea is that instead of having a normal list like this: `.(a, .(b, .(c, [])))` you use a different functor for the empty list, `null`, and for the non-empty list, `build(X, Rest)`. The solution above still stands, you just can't use the `[a, b, c]` notation for the list, you need to use the funny build/2 and null/0 instead. For example, the first line in normal Prolog is: select(X, [X|Tail], Tail). Instead, you'd have to write: select(X, build(X, Tail), Tail). The rest goes in the same fashion. Don't want to give you full solution so that you don't get caught cheating or get scared and delete your question after it has been answered.
Ok, I see. Few things. This is not `select/3` as above. It seems you need to remove _all_ occurences of an element from the list. Then, this is just like a normal list, but whoever gave you the assignment wanted to make it marginally more difficult to just copy your solution off the internet. In Prolog, a list is build just like what you show, but instead of `build/2` and `null` you have `./2` and `[]`, and in addition, you can use the `[a, b, c]` notation instead of typing out `.(a, .(b, .(c, [])))`. Finally, I am afraid that if I gave you a solution you will delete your question because you will get afraid to get caught cheating, and then all the time I spend typing shit will be totally wasted. I would then have to post your original question and the solution on my own, to make sure that it doesn't go to waste.
No worries, I will not delete it.
Well, with a normal list, a naive implementation would look like this: list_removed(X, [], []). list_removed(X, [X|Xs], Ys) :- list_removed(X, Xs, Ys). list_removed(X, [Y|Xs], [Y|Ys]) :- % something to make sure that X and Y are different, for example, dif(X, Y) list_removed(X, Xs, Ys). Just instead of `[]` you have to type `null` and instead of `[Head|Tail]` you'd have to write `build(Head, Tail)`.
&gt; I am afraid that if I gave you a solution you will delete your question because you will get afraid to get caught cheating My attitude is to try not to give full solutions, but rather to either a) point them toward standard library solutions to their problem or b) explain principles but stop just short of giving solutions. People who are interested in learning are usually pretty happy when they (mostly) figure it out for themselves, and people who just want me to do their assignment for them end up getting strung along. I'm fine with both outcomes. 
Good, because it turns out that [it's all recorded anyway](https://www.removeddit.com/r/prolog/comments/8s202c/defining_prolog_predicates/).
This is sometimes too much work, with questionable efficacy. It is often too easy, and useful, to just show how it can be solved. The little programming I know, I have learned by looking at other people's code; the little math I know I have learned by looking at proofs. Now that I think back, I remember _hating_ people trying to gently push me towards a solution by explaining stuff. But this is a bigger topic.
When I explain stuff, I do try to show working code... just not provide a direct solution to the question that they asked. &gt; This is sometimes too much work, with questionable efficacy. Certainly each person chooses how they approach it. I'm just saying that I understand where you're coming from, and I'm telling you how I try to help people. My method might not be useful to you when you try to help people, and that's OK. 
Well, as I said, this is a bigger topic. I appreciate your point of view. What I was trying to explain is the following: Helping someone understand or teaching someone is difficult. I know that there is a tradition of trying to gently push people to the solution _we_ think is good, following the approach that _we_ would use to arrive at it. The problem is that this makes many assumptions that are not "obviously" true, at least not to me. Is that the best solution? Do we know that this approach is best for reaching the solution? We don't know. I can go on but I will stop.
Thanks! I'll check them out over the weekend when I'm free
I guess it saying "Scheme" in the title deterred me, but if your saying that it goes through the theory, then I'll check it out
And really, Scheme is quite OK. It is a really easy language to get started with.
PS: you will also get a lot of nerd points for having written Scheme code ;-)
Interesting what kyndi are doing, I would like to do some similar work in epidemiology. 
As much as I like Prolog, the idea that a programming language carries that much importance is so deeply flawed I don't even feel like starting to talk about it (a moderately complete argument will have to be pages long). As if I have never seen a monstrosity written in Prolog, or in a Prolog derivative (looking at you, Logtalk ;-) Engineers will be engineers, engineering for the pure joy of engineering. Coders will be coders, coding for the pure joy of coding. And all a start-up ever had to do is create enough hype to get capital. The way it has been for a while, the success or failure of the start-up itself seems to be inconsequential to the perceived value of the people involved in the start-up. Or in other words, "I was in a startup" seems to completely overshadow "I created a successful business from scratch" (on the one hand) and "I burned a lot of venture capital and have nothing to show for it but a bullet-point on a resume" (on the other hand).
Missed this... any materials/recording available?
You don't need to be a millennial to teach Prolog. https://www.youtube.com/playlist?list=PLkdv0ay0HIBGKYJFLlo53m3fdUX22mTlm 
I found [this SO question](https://stackoverflow.com/questions/20010215/prolog-inequality-operator). Basically `\==` is impure and will return true with uninstantiated variables, and since it appears before `parents`, it works when you pass a variable instead of an atom. If you put it at the very end of the `sister_of` list of conditions it will work, or use `dif` which is pure.
Thanks, that makes sense (mostly). The point about moving the diff predicate to after `parents` really helped, as now I see how it's getting called with an uninstantiated variable in that case. In real life, I'd probably just use the system provided `dif/2` but for now, all of this is just for didactic purposes. 
Consider the difference between [`=/2`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%3D\)/2) and [`==/2`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%3D%3D\)/2), and then consider the difference between [`\=/2`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%5C%3D\)/2) and [`\==/2`](http://www.swi-prolog.org/pldoc/doc_for?object=\(%5C%3D%3D\)/2). The `==` versions are stronger, though `\=` also won't solve your problem. The problem in general with negation in logic programming is that it's too open-ended. `A = 5` has a simple solution. Even `A = B` is simple. But what's the solution to `A \= 5` (assuming `A` is unbound)? There are an infinite number of solutions. You certainly don't want Prolog to start iterating all the possible terms. SWI-Prolog implements [`dif/2`](http://www.swi-prolog.org/pldoc/man?predicate=dif/2) as a constraint which, as far as I know, is a concept that doesn't exist in ISO Prolog. The evaluation of the constraint is deferred until the variable is given a binding. Consider these queries: ?- dif(A, 4), member(A, [1, 2, 3, 4, 5]). A = 1 ; A = 2 ; A = 3 ; A = 5. In this case, the solution is correct. Even though the constraint is established before `A` is given a binding, its evaluation will be deferred until `member` actually binds `A`. ?- length(X, 3), member(Y, X), dif(Y, 5). X = [Y, _1164, _1170], dif(Y, 5) ; X = [_1158, Y, _1170], dif(Y, 5) ; X = [_1158, _1164, Y], dif(Y, 5). This solution set accurately describes what I stated. Each result is a list of length 3, and each list has at least one member that is not 5. In this case, the constraint can't be completely evaluated since `Y` is never bound. But the constraint survives in the solution set. 
I cannot enroll myself to the first course. Does anyone has the same problem.
It seems that the first course is in the progress and one can't enroll. I was able to enroll in "Probabilistic Logic Programming with cplint", but there is nothing there yet: the course runs August 3-18.
The article is probably overstressing the Prolog aspect. AI, like the rest of technology, goes through boom-bust cycles where some breakthrough occurs and people get overexcited trying to apply it to every problem in sight. I don't think deep learning is going to be the ultimate AI trick to rule them all; after all, there are lots of domains where explainability of the decision matters as much as the decision itself.
Going off on a tangent a bit, but still slightly relevant. The real problem with AI, the way that most people understand it, is that it isn't really going to help us even if we had it. Say an AI passes the Turing test. If we are lucky, all we have is yet another intelligence that makes mistakes, has moods, is influenced in ways it doesn't notice or can prevent ("anchoring" being the most striking example, even though there are many more; "Thinking, Fast and Slow" by Kahneman is a good summary). In the worst case, we have an intelligence superior to us, and we don't understand its reasoning or motivations. As for whether the "explainability" matters that much, I am not so sure. We (humans) are real suckers for causality and narratives. Engineers and programmers in particular are quite terrible in this respect, but I don't want to single them out. Any profession that promotes or requires "logical thinking" tends to attract people like this.
Explainability matters in some domains a lot. For instance, there are a lot of government programs that have eligibility criteria. Think foodstamps. There is software to take legislation or policy and turn it into decision trees that determine if someone is eligible. When the result comes out, it must come with the reason why the result is what it is: you qualify for foodstamps _because_ whatever. Modern statistical AI is no help here, because 99% accuracy is not enough and you can't qualify for foodstamps because some neural network inexplicably lit up the YES button for you. Classical AI such as decision trees, rules engines and expert systems handle this situation nicely, but the techniques are not cutting edge and it isn't the comeback story of the generation. I am not worried about general AI at all.
Look at the references of the work you cited- there’s at least one other paper on this topic. 
Thank you, just wanted to see if any of you guys had any obscure papers worth mentioning!
I am in the midst of cleaning up my blog and sorting through my Prolog writings, but for now the best I can offer you is a [Google search of my stuff](https://www.google.com/search?q=site%3Astorytotell.org+prolog&amp;ie=utf-8&amp;oe=utf-8&amp;client=firefox-b-1-ab).
Thanks, those look great. FWIW, I was looking at https://bennycheung.github.io/using-prolog-to-solve-logic-puzzles and wishing there was more like this.
I have another one where I tackle [the "shared expenses" problem](https://github.com/fusiongyro/prolog-site/blob/master/shared-expenses.org). This is part of the rework I'm doing. This and the Halt simulator are probably the largest published Prolog blog/articles I've done. I have a couple more programs similar in size I could do writeups on ([PERT](https://en.wikipedia.org/wiki/Program_evaluation_and_review_technique) is another one).
There is (Logtalk creator) [Paulo Moura's blog](https://blog.logtalk.org/).
404
There's a paper by David Sherman, "A Prolog model of the income tax act of Canada" Published in: · Proceeding ICAIL '87 Proceedings of the 1st international conference on Artificial intelligence and law Pages 127-136 http://www.davidsherman.ca/other6.html Sherman is an active author; he is the ongoing author of the Practitioner's Income Tax Act, published by Thompson/Reuters.
GNU Prolog and SWI-Prolog, at least, are open-source, free software. Just get the sources and look at the implementation.
`call(Goal)` works the same as just putting your goal at the `?- ` prompt. The "isolation" you're describing is just a normal Prolog thing, where variables are bound once going into a call and they are only bound for the lifetime of that call. It's better to think of `call/N` as exposed internal machinery than wondering how one would implement it. The main reason it exists is to make life easier on you if you're building goals dynamically. 
Yes and yes. You won't get a job only because you know Prolog, but it is a language that will teach you thinking about problems in a more general and structured manner.
Prolog can still be used today, and there are several implementations that are actively developed. However, I know of only a handful of companies that are using it. There are technologies that you can learn and obtain an immediate technical and economic benefit, like SQL. There are technologies you should avoid because they have been superseded by better things, like csh (C shell). There are technologies where, they probably provide you a technical setback but maybe economic benefit, like COBOL or Oracle pl/sql. Prolog belongs to a group of technologies that, for whatever reason, failed to change the world despite being radically different and massive improvements on what came before. However, it is a niche technology and it won't provide you with an immediate economic benefit. I happen to think that learning it has benefits outside the immediately applicable: showing you what kinds of crazy things are possible, helping to deflate hype on new stuff, helping you analyze problems more technology-agnostically. But these are "soft" benefits of learning Prolog. I really enjoy using it for side projects, personally. If you are inclined to learn it, just give it a try, it's very fun!
You managed to very nicely capture the reasons why Prolog is worth learning and using more than other languages. It has been something of a trend for at least a decade that ideas from "research" languages slowly find their way into "production" languages. Pattern matching for example is not at all a new idea (there is, for example, [Icon](http://www2.cs.arizona.edu/icon)), but it still hasn't properly taken off (Rust maybe? we'll see...). Prolog itself has been influenced by functional programming, it seems. On the Oracle PL/SQL, I don't know man. I have used it a bit and I definitely miss it. A lot of the technology stack that I have to use day to day would be just unnecessary if PL/SQL did not force you to sell your soul to Oracle.
It's funny, but I don't think any programming _language_ is really going to die, going forward, if there is even one person who is passionate about it. I mean, [SNOBOL](http://www.snobol4.org/), seriously. And there are even proto-Prolog ideas there. And Icon is a great example, because its concept of generator was influenced by Prolog and went on to influence generators in Python. I have enjoyed creating functions in Postgres, but I usually try and use SQL over pl/pgsql, because it's faster and helps keep you in the "table" state of mind rather than the procedural state of mind. But I do wonder why we have to keep recreating the same layers of abstraction in different parts of the stack...
not worth learning, unless you're capable of going back to lower level language full without crying :D
This is why I use it, some problems are just easier to think about in prolog terms, and I have even written rule a based engine in prolog and then transformed it to c# and the results are clear code and a low bug rate. 
Used it extensively at my previous job - it's great (IMHO) for making and handling business-logic. Now I work with web - programming... Sigh.. 
It can pop up in some surprising places. For example, the spec for the [Java bytecode typechecking verifier](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.10.1) is written in Prolog (I have no idea what the actual implementation is written in, though; I suspect it's written in Java or C++). Unification - core to how Prolog does what it does - is a good thing to be familiar with. Constraint programming can be very useful, too. Constraint programming isn't part of Prolog per se, but certain forms are built in to SWI-Prolog, and my impression is that it's available as a library for other Prolog distributions as well. Is Prolog used heavily in industry? Probably not. It's not been used in any places that I've worked, and I suspect that most of my coworkers would have never heard of it.
Wow buddy, you've got a ways to go here. First, you probably want `first_word(No), number(No)` or you won't get agreement there. I really hate your grammar, because you should either create a grammar for the strings you want to match or follow the grammar of the language you're supposed to be parsing. `first_word` is A) a lie, because you match two words, and B) a very uninformative name for your production, and C) forms part of the noun phrase along with number, gender, etc. Third, `mans` and `womans` are not grammatically correct (you have `men` and `women` in your example, so why is it broken here? Four, you never come up with the gender in your gender production: `gender(m) --&gt; [man] ; [men]. gender(f) --&gt; [woman] ; [women].` Of course, this isn't enough to fix your problem because you have information about plurality here you're discarding (you will accept "there is one men" and "there are two man" which are both invalid). Without knowing how you're planning on implementing the rest of the system, I can't give you very specific advice, but I would say: try to come up with a representation for the kinds of commands you want to process. Then your job in parsing the DCG is to create those representations. You do not want to see a 1:1 relationship between things people can say and bits of code you have to write to handle them.
This is where I would start: sentence(thereare(N, Type)) --&gt; thereare(N, No), type(Type, No). sentence(height(P, X)) --&gt; noun_phrase(P), verb_phrase(height(X)). sentence(left(P1, P2)) --&gt; noun_phrase(P1), verb_phrase(left(P2)). noun_phrase(P1) --&gt; definite_noun(P1). definite_noun(man(Id)) --&gt; [man,Id]. definite_noun(woman(Id)) --&gt; [woman,Id]. verb_phrase(left(P)) --&gt; [is,left,of], noun_phrase(P). verb_phrase(height(X)) --&gt; [has,height,X]. thereare(1, si) --&gt; [there, is, 1]. thereare(N, plu) --&gt; [there, are, N]. type(man, si) --&gt; [man]. type(woman, si) --&gt; [woman]. type(man, plu) --&gt; [men]. type(woman, plu) --&gt; [women]. This gives you three basic sentence types, `thereare(N, Type)`, `left(Person1, Person2)` and `height(Person1, N)`. You should be able to generalize this to more kinds of sentence. See how the agreement works by having a variable shared between the productions, but not elevated to the result? That's how you do agreement with DCGs. Note that I'm reusing `noun_phrase//1` in the verb, sometimes. 17 ?- phrase(sentence(X), [man,1,is,left,of,man,2]). X = left(man(1), man(2)) . 18 ?- phrase(sentence(X), [there,is,1,man]). X = thereare(1, man) . 19 ?- phrase(sentence(X), [there,is,2,man]). false. 20 ?- phrase(sentence(X), [there,are,2,men]). X = thereare(2, man) . 21 ?- phrase(sentence(X), [there,are,2,women]). X = thereare(2, woman) . 22 ?- phrase(sentence(X), [man,2,has,height,10]). X = height(man(2), 10) . 
Thank you!
It feels somehow wrong that the meaning of "1" and "2" is overloaded. Once it is used as count (one man, two men), once it is used as an ID of a kind ("Man 1", "Man 2"). Also, "There are one man"?? "There are two man"? Wrong on so many levels. But part of the reason is that the problem is ill-defined at the moment. As typical of people who are unlikely to ever become good programmers, OP has entangled the _what_ with the _how_ and completely forgotten about the _why_.
This post on hackernews is wonderful and inspiring: [https://news.ycombinator.com/item?id=17702946](https://news.ycombinator.com/item?id=17702946) At least if you're me, and part of the reason you got into Prolog was because you wanted to use it as an engine for creating fancy skinnable type systems.
I think knowing more about the problem specification would enable us to be more helpful, but also probably send the OP into the Dean's office for cheating. I think my grammar handles the obvious number agreement problems. There will later on turn out to be gender agreement problems but I'm not handling them at all in the example, because OP didn't provide any examples where it would matter (using "he" and "she"). The biggest problem with OP's code, IMO, is that OP thinks DCGs alone are going to solve the problem. DCGs are a powerful tool, but you still have to think about your problem and break it down sensibly. I agree with your assessment of OP's current abilities, but I am not prepared to say they will never get there. If I were they, I would spend my energy: - trying to get better at using the REPL and interactively exploring - trying to comprehend from written resources on my own There is no way to become a good programmer without developing the ability to struggle quietly on your own. Of course, social stuff like this can supplement. But if you don't struggle privately, you won't improve at programming, just asking questions.
Hey, thanks for the reply. I know it's really bad right now. This was just a quick draft. So, for the first_word, that's just a wrong name, you can use "first_string". Mans and womans, I know is wrong, but just for this problem we're taking it mans instead of men. The main problem I have is, how do I get the input sentence from the user. Then proceed from there with breaking up the sentence and matching them to the templates I have. It's a really small domain, so I don't really need to break it into really detailed "noun_phrases" etc.
Okay, There is 1 man There are 2 womans %%(not women) Man 1 has height 6 Woman 1 or Woman 2 is to the left of man 1 Woman 1 has height 5
I think you're discounting what I'm saying. `first_word` is wrong no matter what you name it because you're breaking your grammar into pieces in the wrong places. And as for mans/men, doing it the right way is as much work as doing it the wrong way. Making the excuse for doing it wrong is more effort than doing it the right way. I usually either build my grammar on characters directly, such as by using productions like `noun(man) --&gt; "man"`. This way you don't have to worry about tokenizing. You can also benefit from things in the [dcg/basics](http://www.swi-prolog.org/pldoc/doc/_SWI_/library/dcg/basics.pl) library. If you insist on having a separate tokenizing step, your final call will look something like `phrase(tokens(T), Input), phrase(sentences(S), T)`. The `tokens//1` rule is going to look something like this: tokens([T]) --&gt; token(T). tokens([T|Ts]) --&gt; token(T), whitespace, tokens(Ts). token(T) --&gt; tokenchars(Ch), { atom_chars(T, Ch) }. tokenchars([C|Cs]) --&gt; tokenchar(C), tokenchars0(Cs). tokenchars0([C|Cs]) --&gt; tokenchar(C), tokenchars0(Cs). tokenchars0([]) --&gt; []. tokenchar(C) --&gt; [C], { char_type(C, graph) }. whitespace --&gt; []. whitespace --&gt; [W], { char_type(W, white) }, whitespace. There's something annoyingly wrong with this but I'm at work and can't dig into it right now in depth. But this will break your input into tokens. You probably want to use something like [read_line_to_string/2](http://www.swi-prolog.org/pldoc/doc_for?object=read_util%3Aread_line_to_string/2) to get the input.
This is not enough detail. How do you start the program? What does the user type in? Or does the user "say" it? What is the response? When there is an error, how does this error look like? It might not be easy to make something, but it is impossible to make anything if you cannot describe to others how it looks. Because if you cannot describe it to other humans, how are you going to describe it to a dumb computer?
So the key idea in DCGs is that you're processing difference lists, so a DCG rule like this: foo --&gt; first, second. is going to "desugar" to something like: foo(L0, L2) :- first(L0, L1), second(L1, L2). In this way, DCGs thread a state variable through each of the productions. This makes for very convenient difference list processing, but what happens when you want to put some normal Prolog predicate in there? If you tried this: token(T) --&gt; tokenchars(Ch), atom_chars(T, Ch). it would desugar to this: token(L0, L2, T) :- tokenchars(L0, L1, T), atom_chars(L1, L2, T, Ch). This isn't what you want at all! The bracket notation says "ignore the desugaring rule for what's in here, it's already vanilla Prolog." So the list state variables are not threaded between the brackets. `token//1` is taking the result of `tokenchars//1` and passing it through `atom_chars/2` to turn it from a list of chars back into an atom, which is what you appear to be expecting. `tokenchar//1` is reading a character from the input, but asserting that it will be a printable character (`char_type(X, graph)` means that the character is graphical, in contrast to whitespace or control characters). So `phrase(tokenchar(g), [g])` will succeed but `phrase(tokenchar(' '), [' '])` will not.
I don't know enough, obviously, but I thought the PL in PL/SQL stands for "procedural language", and at least the way I have had to use it, it covers functionality that is provably not possible to achieve with SQL. It is basically for making an API. It comes with excellent IDE support for writing queries, without having to deal with some absolute shit like Hibernate, for example. The other option, when you have RDB + Java, for example, is usually "just use JDBC" and this is just so primitive.
but how would you suggest taking the input? read_line_to_string or something else?
I don't know, because I don't know what kind of input you need to take from where, because I don't know how the interaction between the user and your program is supposed to look like. But it is somewhat likely that you can use something like `phrase` or directly `phrase_from_stream`. Both predicates take a DCG.
Have you seen [myBatis](http://www.mybatis.org/mybatis-3/)? This is my go-to option for interfacing SQL and Java these days. Things must be different where you are. Where I work, the bulk of the PL/SQL is doing things that could easily be done in SQL with less code and greater efficiency. Much like Prolog, it takes some effort to get into the SQL mindset, and giving procedural programmers an escape hatch to Pascal like PL/SQL affords them the opportunity to not do it. That said, it may not have been the best example of what I was trying to describe, which is just that some technologies are profitable despite their technical virtues rather than because of them.
Where I worked with Oracle DB and PL/SQL, I was the most junior developer. The Oracle expert there basically forbid me from doing anything in any other way if it could be done in SQL, or doing anything outside of the database if it could be done in SQL + PL/SQL. But a big part of this was that the actual user-facing application was also written using a proprietary Oracle solution, APEX. All you need then is an Oracle Database. Technically, very nice. And some large institutions still would _require_ that either Oracle or Microsoft DB is used when selling projects to them, soo..... But definitely a dead-end street, career-wise. Good to know and to learn and get ideas from, but not something that will give you a lot of jobs offers to pick from.
True, but the built-in `call/N` predicates should outperform the naive ones. I personally never seem to have a reason to use `call/1`, but with more arguments it's way more convenient than building the term.
Yes and yes. 
Here's one example where something very similar to Prolog is used: https://github.com/rust-lang-nursery/chalk (actually, intended to be used, but, I believe that it will make it into Rust compiler eventually). Now, knowing Prolog will not get you hired. But, it's not the same as being worth learning. Today, I'm dealing with a huge system in finance world. It does something it calls "matching". It's a complex set of rules for finding reports from all parties involved in a money transaction and establishing that the said transaction took place. If only the idiots who wrote it knew about Prolog... it would be so worth their time learning it. Unfortunately, they didn't.
You are farther from the truth than when you started. Please believe me when I say, you would be better off deleting everything and reading from page 1 of any book on Prolog, than trying to push through with the understanding you have right now. You're only going to frustrate yourself. You cannot define a rule inside a grammar rule. In fact, that's what Prolog is saying when it says "Rules must be loaded from a file." Please take the time to actually read what appears on your screen. Good implementations of all languages will furnish you with help, but you must be prepared to slow down and read. In Prolog, variables are assigned once. So there is no difference between saying foo(X, ...) :- X = bar, ... and foo(bar, ...) :- ... &gt; So, what I'm trying to do here is that I will pass my grammar through 'startoffile' which has a or b. When the grammar gets the word "end", I want it to call 'startoffile' again to check if the next sequence belongs to a or b. Wouldn't it be simpler to just say: startoffile --&gt; a | b | startoffile. ? Of course, if you look at that I think you will see an obvious infinite recursion problem. Where do you supposed `[Head|Tail]` is going to come from, anyway? This is because you are still thinking procedurally instead of declaratively. Stop asking "_how_ can I make Prolog do what I want?" and start asking "_what_ do I want Prolog to do?" You are not going to be able to beat your way through this change of perspective with brute force. &gt; mainfunc([Head|Tail]) :- ... mainfunc(T) Pay attention to your singleton value warnings. They are "warnings" only in the sense that they don't stop the file from loading, they are almost always (especially for a beginner) symptoms of fatal misunderstandings that will prevent your program from working. In this case, `T` and `Tail` are supposed to be the same variable. &gt; call(startoffile), There are two problems with this line of code: 1. `call/N` is for calling predicates, not DCG rules. After the DCG is parsed, what you actually have is `startoffile/2`, which you don't have the ingredients to call in hand here, and anyway... 2. The way you invoke DCG rules from Prolog is using `phrase/2`, as in `phrase(startoffile, Input)`, but... 3. You're in a DCG rule here, so what you would have done if you needed to mix calling a DCG rule with Prolog processing is more like `foo --&gt; ... { some_predicate(...) }, bar, ...`, and by the way... 4. There is no benefit to using `call(foo)` over `foo` in ordinary Prolog, assuming it's some random predicate or goal you want to evaluate. Really, you are moving backwards. Stop. Read. Think. Try on your own. Read the output. Think. Read. Think. Read. Then ask for more help. If you keep digging and forcing like you're trying to do now, you're going to wind up a professional landscaper rather than a programmer.
What are you trying to achieve? Write down the input and the expected output of your program. Then explain what is the logic behind it. Only then show the code that you have. And please, format it properly. You need to put 4 (four) extra white spaces at the beginning of every line of code. Then, code looks like this: ?- between(1, 3, X). X = 1 ; X = 2 ; X = 3. What you have shown at the moment is not enough.
I'm trying to do a recursive search when the input encounters a particular. When I get that special word, I'm going to start the search for the next part of that again to see if it belongs to 'a' case or 'b' case. Input- Sky is blue and chair is red. a-Sky is blue special word-and b-chair is red
Okay, I've realized the mainfunc is not doing anything at all. As for Tail and T, they are the same thing, I might have removed 'ail' from the 'T' while I editing to post here. There is no singleton variable here. So, what I should've done is something like startoffile--&gt;{mainfunc...},a|b , something like this (after correcting the errors of course).
OK, so do I understand: you are trying to take a sentence like "Sky is blue and chair is red" and turn it into something like sentence(and(is(sky, blue), is(chair, red))) ???
lol The second one [sky,is,blue,and,chair,is,red] and just divide sky,is,blue into one part and pass the value of variables from that sentence and turn chair,is,red into another part and do the same with that sentence. So, W1=sky, W2=chair Color1=blue and color2=red.
I am feeling very generous today, so I will try to help a bit. You must make sure that you type in all code you see here and try to run it exactly as I have run it. If you don't do this, just save yourself time and skip this altogether. I first make a file called sentences.pl that looks like this: $ cat sentences.pl run :- read_string(current_input, _Length, Str), format(current_output, "~s", [Str]). This is now able to take its input and print it to output. This is what it does when you feed the file to a Prolog session that loads the file and call `run`: $ &lt; sentences.pl swipl -g run -g halt sentences.pl | cat run :- read_string(current_input, _Length, Str), format(current_output, "~s", [Str]). (You need the `| cat` at the end if you don't want to see the interactive prompt that SWI-Prolog is using.) But we would prefer to use a DCG. We can do by changing the file like this: $ cat sentences.pl :- use_module(library(pure_input)). run :- phrase_from_stream(copy(current_output), current_input). copy(Out) --&gt; [C], { format(Out, "~c", [C]) }, copy(Out). copy(_Out) --&gt; []. We can then run this program on itself, and we get: $ &lt; sentences.pl swipl -g run -g halt sentences.pl | cat :- use_module(library(pure_input)). run :- phrase_from_stream(copy(current_output), current_input). copy(Out) --&gt; [C], { format(Out, "~c", [C]) }, copy(Out). copy(_Out) --&gt; []. Here, you are reading the file character by character from standard input and writing them to standard output. Now, if you want to break them up by sentences ended by fullstop, `"."`. You can do like this: $ cat sentences.pl :- use_module(library(dcg/basics)). :- use_module(library(pure_input)). run :- phrase_from_stream(sentence_dcg(current_output), current_input). sentence_dcg(Out) --&gt; sentence(L), !, { format(Out, "~w~n", [L]) }, sentence_dcg(Out). sentence_dcg(_Out) --&gt; string_without(".", _Str). sentence(sentence(S)) --&gt; blanks, string_without(".", Str), ".", { atom_codes(S, Str) }. With this you can now do that: $ echo 'This is a sentence.' | swipl -g run -g halt sentences.pl | cat sentence(This is a sentence) $ echo 'This is a sentence. This is another one.' | swipl -g run -g halt sentences.pl | cat sentence(This is a sentence) sentence(This is another one) And how do you split on "and"?
Oh thanks, Imma try to understand this code.
Perhaps something [like this](https://stackoverflow.com/a/51662620/812818)?
Anne Ogborn has uploaded [a greenhouse regulator](https://github.com/Anniepoo/prolog-examples/blob/master/greenhouse.pl) to her fantastic Prolog Examples repository, demonstrating one use of MQTT. Nice!
Your writes are side-effects, but since you are computing those values, what you need to do is make them part of the DCG rule instead: plus(N1, N2, Sum) --&gt; number(N1), plus, number(N2), { Sum is N1 + N2 }. Now, there is the possibility that you need to propagate some information from one rule to deep inside the result of some other rule. I'm nervous to show you this because I think I'm more likely to confuse you than illuminate you, but here goes anyway. Check out [this article on my blog](http://www.storytotell.org/phrases-as-functions/) using a common example from one of the advanced Prolog books (I forget which, probably Prolog Natural Language Processing). The basic idea is that instead of, say, `plus(Expr) --&gt; ...`, you would return something like `plus(X^Expr) --&gt; ...`, and then in another place in the grammar where you have `... --&gt; plus(Expr), next(N), ...` you change it to `... -&gt; plus(N^Expr), next(N), ...` and in this way, the value `N` "from the future" can be inserted deeply into a structure you knew you wanted "in the past."
Firstly- let me say you are doing well and what you are seeing is what all is mid-level prolog programmers go through. That is, we get close to a solution but find there’s a bug that needs fixing and it’s very often exactly this problem if infinite recursion (and usually because we haven’t sorted the base case out correctly). If I have time, I’ll find the actual bug but even if I don’t - don’t see what has happened as a negative thing- it isn’t, it’s very positive. Just keep at it- debug patiently and accurately. 
First of all I want to apologize for my low level of English. I think the infinite loop could be caused by this: quest(Value, [action(Action, Parameter) | Actions]) :- quest(Parameter, Actions), perform_action(Action, Parameter, Value). When prolog doesn't find a solution using the other two quest rules, then enter in the third and keep enter again and again in the same quest rule and 'Parameter' is never instantiated. So, i changed the rule: quest(Goal, [action(Action, Newgoal) | Actions]) :- % Numbers lower than goal which can result in goal using "Square" o "Cube" actions. between(1, Goal, Newgoal), perform_action(Action, Newgoal, Goal), % Then we go on with the process quest(Newgoal, Actions). First i look for a useful number and then i continue with the quest process. And i got this: ?- quest(256,X). X = [action("Square", 16), action("Square", 4)] ; X = [action("Square", 16), action("Square", 4), action("None", 4)] ; X = [action("Square", 16), action("Square", 4), action("Square", 2)] ; X = [action("Square", 16), action("Square", 4), action("Square", 2), action("None", 2)] ; false. I added a "None" actions just because i don't like to see repeated solutions. And i have changed the name of some parameters. Here is the code: parameter(2). parameter(3). parameter(4). parameter(5). parameter(6). parameter(7). perform_action("Square", Value, Result) :- Result is Value ** 2. perform_action("Cube", Value, Result) :- Result is Value ** 3. quest(Goal, [action("None",Goal)]) :- parameter(Goal). quest(Goal, [action(Action, Parameter)]) :- parameter(Parameter), perform_action(Action, Parameter, Goal). quest(Goal, [action(Action, Newgoal) | Actions]) :- % Numbers lower than goal which can result in goal using "Square" o "Cube" actions. between(1, Goal, Newgoal), perform_action(Action, Newgoal, Goal), % Then we go on with the process quest(Newgoal, Actions). I hope it has been helpfull. It would be great if someone finds an error in the code. I found this problem very interesting so it would be cool to keep thinking about it.
&gt; even(X) :- X #= 2\*N. &gt; odd(X) :- not(even(X)). This is nice! However, it has a small drawback: ?- odd(X). false. A more general alternative is: odd(X) :- X #= 2*N + 1. Yielding: ?- odd(X). X#=2*_1462+1. With this small change, we can use also odd/1 in all directions. 
Ah yes, I hadn’t considered that, but that is even better. I tend to use this as the example because it’s exactly the definition of even/odd you typically see in a math class.
"The present notes are concerned with semantics-based dataflow analysis of definite clause logic programs. They have been produced for a tutorial given by the authors to the North American Conference on Logic Programming in Cleveland, Ohio, 16 October 1989. The notes are a condensed version of two forthcoming papers. Proofs omitted here appear in these papers. "
Does anybody here has joined at this courses? How was it? I'm interested at [Introduction to SWI-Prolog](https://edu.swi-prolog.org/course/view.php?id=2) but it was in June 8 - August 3. 
Yes. It's trying to call Fst and Snd (you have a typo/your variables aren't capitalized, assuming they are supposed to be variables). However, as they haven't been unified with anything, they can't be called. For the record, there are `true/0` and `false/0` facts in Prolog that you can use. Finally, if you want to get it to solve boolean expressions, you should write them like this: ``` and(true, true). % If you want, you can add here :- true. % You can also include these if you want, but it's unnecessary % and(false, true) :- false. % and(true, false) :- false. % and(false, false) :- false. ``` Then I can do: ``` ?- and(X, true). X = true. ?- and(X, Y) X = Y, Y = true . ?- and(false, Y). false. ``` You can define whatever other boolean operations you want like that and they will also work.
You should probably take a look at a library for constraint logic programming over booleans. I am not sure about your conclusions. Prolog is a general-purpose programming language, not a boolean expression solver. It can be made to do anything, and often there are already libraries available.
I certainly was not aware of this. What is it then? Conjunctive query? (https://en.wikipedia.org/wiki/Conjunctive_query). The wikipedia article on prolog links to "logical conjunction".
**Conjunctive query** In database theory, a conjunctive query is a restricted form of first-order queries using the logical conjunction operator. Many first-order queries can be written as conjunctive queries. In particular, a large part of queries issued on relational databases can be expressed in this way. Conjunctive queries also have a number of desirable theoretical properties that larger classes of queries (e.g., the relational algebra queries) do not share. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/prolog/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
They _are_ logical conjunction and disjunction. 
I might be wrong, of course. Could you tell me what the following query means? ?- X = a ; X = b. X = a ; X = b. 
The use of `,` must be quite old already. On [this page](https://gdz.sub.uni-goettingen.de/id/PPN266833020_0039?tify={%22pages%22:[184],%22panX%22:0.477,%22panY%22:0.869,%22view%22:%22info%22,%22zoom%22:0.317}) of one of Gentzen's papers on sequent calculus from 1934, you find it being used as conjunction in the antecedent and disjunction in the consequent. In Horn clauses there is at most one literal in the antecedent, so `,` is always conjunction, and nowadays we might separate the consequent literals of general clauses with `;` to be clear. When `;` came to denote disjunction, I have no idea. It wasn't used in the original Marseille Prolog interpreter, which separated the literals with spaces as you can see from its manual [here](http://alain.colmerauer.free.fr/alcol/ArchivesPublications/ManuelProlog/Pr.pdf). If it was a Prolog innovation, then it must have appeared in Edinburgh Prolog in the 70s. I'd be interested in seeing a more authoritative answer, though.
I somewhat agree with you. A query like `X = a ; X = b` has a beautiful logical interpretation, but there are perfectly logical queries you can pose to Prolog that Prolog will fail to evaluate properly simply because the machine must proceed in a certain order. For instance, bottom :- bottom. foo(X) :- bottom ; X = a. There is no _logical_ difference between `bottom; X = a` and `X = a; bottom` but one of these will produce nothing and the other will produce `X = a`. And this is a symptom of Prolog's execution model leaking through the abstraction. In practice I think Prolog programmers with moderate or better experience just order things from cheap to expensive and it turns out not to be a huge problem.
I think you're trying to make a statement about the difference between Prolog and logic, yes? One could contend that Prolog and logic are the same. This, you and I would disagree with, because Prolog has an execution model that dictates order where pure logic does not, and Prolog is subject to nonterminating computations etc. One could also contend, and I think you are, that this deprives Prolog of a logical interpretation. I disagree with this, because I don't think Prolog's disjunction deprives us of the ability to read and reason about Prolog programs logically. We just have to accept the possibility that there are circumstances where Prolog will not succeed despite logical correctness. But the logical subset of Prolog will not succeed where logic would not allow it. Being able to reason about Prolog well is one of the appeals. It's not perfect, but what is? Secondarily, I think the question of multiple successes goes back to how you interpret Prolog queries as such. I don't think of Prolog queries as statements that are evaluated per se. I think it's productive to think of Prolog queries as asking Prolog, "can you prove `Goal`?" and the variable substitutions constitute the proof. During resolution the disjunction may be evaluated as true and then again as false or whatever, but when the resolution step is over, you either have a successful unification and some variable bindings, or you do not and there is no solution. A statement can be true and have multiple possible proofs; this doesn't have anything to do with whether it is based on logical conjunctions and disjunctions or not. So I don't think there is some other kind of disjunction available for Prolog, or for logic, or for proof. It's just that, as Prolog attempts to prove statements, it must traverse disjunctions in a certain order because it runs on the machine. But this doesn't deprive disjunctions of their logical meaning.
I was making a statement about `;` not being the same as the logical disjunction and `,` being not the same as the logical conjunction. There is some truth in your words, of which there were many. However: _you_ can think of Prolog queries any way you wish; whether your thinking of Prolog queries changes the meaning of a Prolog program is an interesting topic.
The way the discrepancy is dealt with in the textbooks (for example in _The Art of Prolog_) is to distinguish between logic programs and Prolog programs. Logic programs have a precise proof theory and semantics in terms of least Herbrand models and `,` and `;` really are logical conjunction and disjunction. Pure Prolog is a not-quite correct theorem prover for this logic: it's incomplete because - as you pointed out - it will miss proofs if it goes down an infinite branch first, and it's unsound because occurs check is not required and negation need not be sound. There's a wonderful freely available book by Peter Flach, _Simply Logical_, that explains all of this in its first few chapters. The PDF is available (here)[http://people.cs.bris.ac.uk/~flach/SimplyLogical.html], but there's also a new website for the book (here)[https://simply-logical.space/] where you can try all the code in SWISH sandboxes.
Thanks!
Not every topic can be addressed pithily. :)
Ha! Just to clear things up, when I said: &gt; whether your thinking of Prolog queries changes the meaning of a Prolog program is an interesting topic. ... I meant it. To elaborate just a bit, the mental model of whoever is running a Prolog program, or wrote a program and now runs a query: this does change the _meaning_ of the program.
I wasn't sure whether you did or not, but I agree that it is an interesting question. Unlike lots of languages, Prolog really does sort of "inspire" several different interpretations of what is going on.
I always prefer the mechanistic reading of programs. Sooner or later you must go there to understand what is really happening, **if** you are running a program on a computer. But of course this is very personal, and most probably influenced by my experience.
Nice! I added a tail-recursive version of `fib/2` and saved [here](https://swish.swi-prolog.org/p/tabing2.swinb), just to see the overhead of tabling compared to an efficient version without tabling.
Release notes: * Additions: * new primitives:str.trim.head, str.trim.tail, str.tail, str.head, lst.incl, lst.excllst.join, lst.init, sym.cmp, sim, is.even, is.odd, gid.make * new samples: [fibonacci.fizz](http://f1zz.org/samples/fibonacci.html) [irl2asm.fizz](http://f1zz.org/samples/irl2asm.html) [linkg.fizz](http://f1zz.org/samples/linkg.html) * new terms: guid * new classes: MRKCSBFStore, MRKCCSVStore, FZZCLGRProcessor (use Link-Grammar library for NLP) * new constraints: lst.incl, lst.excl, is.guid, is.even, is.odd * Changes: * modified primitives: lst.remove, str.trim, lst.length, fzz.lst, guid.str * modified commands: /peek, /poke, /tells, /knows * modified terms: binary, symbol * Bug fixes: * constraint is.string was testing for a variable to be bound to a symbol * primitive str.swap in some condition was repeating part of the tail of the string where the replacement was made * primitive add was returning 0 when used with an unsigned number as the first term and a negative number as the second term (e.g. add(23u,-18,:v)) * string terms with control characters were not rendered properly when they are embedded in other terms
Also updated the "*Importing and managing a large data set in fizz"* article to use the new binary store to store the DNA fragments: [http://f1zz.org/downloads/ecoli.pdf](http://f1zz.org/downloads/ecoli.pdf) 
Cool. Will study in more detail when I’m commuting next :) 
"Reform Prolog is an (dependent) AND-parallel system based on recursion parallelism and Reform compilation. The system supports selective, user declared, parallelization of binding-deterministic Prolog programs (nondeterminism local to each parallel process is allowed). The implementation extends a conventional Prolog machine with support for data sharing and process management. Extensive global dataflow analysis is employed to facilitate parallelization. Promising performance figures, showing high parallel efficiency and low overhead for parallelization, have been obtained on a 24 processor shared-memory multiprocessor. The high performance is due to efficient process management and scheduling, made possible by the execution model."
I use the second. It continues to work well when combined with chained-soft-cuts. i.e. ( N = 0 -&gt; fail ; N = 1 -&gt; member(X,Set) ; true )
Interesting question. But yes, there are things that are not really meant to be done with Prolog. Any algorithm that requires random access (C-array style) is going to result some difficult to read and unnecessarily slow code. So there are many useful programs that are probably not meant to be implemented in pure Prolog. But anything that has to do with list processing or text parsing is just great to do with Prolog. And web programming with SWI-Prolog is quite nice. I strongly recommend glancing over these HowTo's to get an idea how stupidly simple it is: http://www.swi-prolog.org/howto/http/ 
Prolog (standard) has nothing to say about concurrency (existing implementations usually offer some means of running code in parallel, but there's no requirement that they do), so, it's not exactly meant to solve problems that require that. Some languages like R, Matlab etc. have special features to support vectorized calculations, some other languages can have ways of extending them to have those features (eg. Python with NumPy), but, Prolog isn't generally known for doing things like this / isn't really meant for doing lots of parallel floating point calculations.
First let me say, you're going to want to use SWI to get real things done, or maybe GNU, but you're not going to be able to get far in ISO Prolog alone. I have enjoyed trying to accomplish normalish things in Prolog for a few years. I often have found that there is an initial hurdle to get over, but once you surmount that it is often a lot more fun than using something like Python. For instance, I have a Prolog program around here somewhere for trying to untangle some screwed up commits to Subversion. Most people would probably have used Python for what I was doing, but parsing XML isn't that hard and you can get Subversion to give you XML, so once I had that, it was like I had the whole Subversion database as Prolog relations. Well, the part I needed, anyway. I remember using Prolog for one of my blog migrations too. Getting access to Postgres from SWI kind of sucks in that you have to go over the ODBC bridge, but once you're in there, it's not too bad, and I wrote a few programs that did database queries this way. This "load into and transform" seems to be thematic for me. I found something similar with Haskell, where the hurdle was "how do I get this information into the pure domain of Haskell?" and then once it's there, it's much easier to transform and play with. Prolog has a significant advantage in DCGs this way, I can parse weird shit very quickly and easily directly into shapes that Prolog wants to work with, where with Haskell I would be thinking about using `interact` to sidestep the problem or deploying Parsec and "enjoying" the problems that come with that. I'm learning J now as well, and it's a similar story there: how do I figure out what shapes the data should be in to facilitate processing? A lot of the J tutorials sort of ignore the parsing problem altogether and just say, suppose you have this matrix, so it's been "fun" figuring out how to handle data in a J-friendly way. I have yet to really do a web app in Prolog. I'm enthusiastic about the idea of it, with the stuff in SWI, I just haven't made it "over the hurdle" yet. The SWI website used to be pretty unstable and that didn't encourage me either, although for the past two or three years it's been solid, which has added some interest for me. I feel like there are a lot of interesting slightly outdated ideas there but who knows, it's probably way better than the Angular/REST stack I'm using at work.
You can take advantage of indexing on the first parameter if your structure is sufficiently interesting that it warrants a whole relation. I.e., a query like `foo(X, ...)` against a database of several millions of `foo/N` is going to be quite fast. Look at WordNet for instance, it takes a few seconds to load but once it's loaded your lookups are basically instant. If your data are high-level enough, it doesn't need to be a problem.
SWI has threading built-in, as well as ways of calling into C and Python. For me the question would be, is it going to be worth the effort to set up and maintain the bridge, if I needed better performance out of something like that. That hasn't happened for me yet but I don't do a lot of really high performance stuff.
Funny you should mention J as I have tried to get into it for a while. I am always learning J *instead of* writing valuable programs, never learning J *by* writing valuable programs, due to the learning curve being more of a cliff. That's part of the reason I asked this question before investing any time in Prolog: I have too many Perlis languages already on my list and I end up spending my hobby time achieving results in JavaScript instead. :(
I'm not at all clear on this example... Are you saying that for random access into a structure foo, you would have several million overloaded rules named "foo" but with different arities, each having a first element X that is location of the element you want to access?
Thanks for the reassurance. I'll put it down as a fairly general-purpose language with emphasis on parsing.
:-) I was thinking myself about what I wrote, and it is of course a one-sided point of view. The real reason why I like Prolog, esp. the SWI-Prolog implementation, is that it is a liberating language. It is not dogmatic about how to solve a problem. On the practical side, when you get down to the code, there is very little boilerplate, so it it easy to read and to write. At the end, we write programs because we need something done; with Prolog, I just tend to spend less time on the trivial.
No, what I'm saying is that efficient random access to arrays is often (not always, but often) a building block for a higher level data structure you could replace with a Prolog relation. Considering Python, usually when I have a large amount of data in memory, I have a dictionary I'm using to look items up. In Prolog, you'd just make those things relations. The key would probably be the first item anyway, and now you're going to have highly performant lookups thanks to indexing on the first argument. If that happens to be an integer, it's still not exactly the same as an array index, but it's definitely not going to be as bad as finding some item in a linked list.
By that reasoning, why do we ever take data out of databases? :)
You got it buddy. :)
You are trying to talk around the problem. There are many algorithms that assume that you have constant-time read/write access to any element in an array. None of these can be implemented efficiently in Prolog. Sorting is a good example. In SWI-Prolog, it is implemented in C, so it is quite fast, but still, it is implemented as a merge sort, because it has to sort what is basically a linked list.
Yes, to some extent I am. But I do think in practice there are factors that work in my favor: - a lot of the algorithms from the literature are for solving problems that are already solved by builtins or libraries in Prolog. Volume 3 of _Art of Computer Programming_ is "Sorting and Searching"... the likelihood is very low that you'll need one of the extremely specialized algorithms from here versus using the generic facilities that are built-in and fast. IOW 1/4th of what most people would consider "the literature" on algorithms concerns stuff we get for free. (Another 1/4th on numerical algorithms... that's probably something you would avoid Prolog to do.) - most Prolog programs have performance inefficiencies stemming from our freedom to be vague that cause much bigger and more obvious problems - you can implement basically everything from _Purely Functional Data Structures_ in Prolog; this doesn't cover _every_ algorithmic use-case but it covers more than most people run into - there are actually several techniques that are easy in Prolog but difficult in other places thanks to unification; difference lists and data structures with holes, for instance, are mostly unavailable elsewhere (Haskell has a DList library) but it's quite easy to make structures and backfill them later on in constant time without having to traverse them at all I think it's easy to cast aspersions on almost any language for performance. In the end, the programmer has more say in whether programs are fast than the language does, and while it isn't like Prolog is an amazing speed demon, it hasn't really been a problem for me except when _I_ made it a problem.
I don't know if something works in your favor or not. This is a strange way to look at it. Yes, Prolog is a general purpose language. But so is C. Unlike C, Prolog is a high-level language with a somewhat peculiar execution model. Is it good for writing programs? You betcha. Are there classes of problems that are difficult to solve nicely with Prolog? Yes, yes there are.
Is there a language which is great at solving all problems?
Do they agree on what it is? :)
Yes, they do. It's the language they know best.
Correction: it is the only language they know well enough.
"bddbddb stands for BDD-Based Deductive DataBase. It is an implementation of Datalog, a declarative programming language similar to Prolog for talking about relations. What makes bddbddb unique is that it represents the relations using binary decision diagrams (BDDs). BDDs are a data structure that can efficiently represent large relations and provide efficient set operations. This allows bddbddb to efficient represent and operate on *extremely* large relations - relations that are too large to represent explicitly."
This seems interesting, but it's 10 years old. Have there been any updates since?
I don't think there is any ongoing work, but the technique is very interesting and re-usable.
If it's the database&lt;-&gt;Prolog thing you're looking for, maybe [CQL](http://www.swi-prolog.org/pldoc/man?section=cql) is what you're after? I have been meaning to check it out but still haven't done anything with it. There's [library(persistency)](http://www.swi-prolog.org/pldoc/man?section=persistency) which may be similar to what you want, if you just want persistence with Prolog programs. I would probably make predicates to query via ODBC exactly the things I'm interested in rather than mapping each table to a SELECT * and trying to do it from Prolog. The database is going to be a lot more efficient at optimizing your query if it has the whole thing at once.
Datalog?
See this: https://groups.google.com/forum/#!topic/swi-prolog/tmScPR12tOI
Thank you!
I think the simple answer is that humanity underestimated (and continues to underestimate) how difficult strong AI really is to achieve. Another interesting perspective on FGCS is given in this 2010 blog-post by Maarten Van Emden, one of the founders of logic programming: [Who Killed Prolog?](https://vanemden.wordpress.com/2010/08/21/who-killed-prolog/)
Yes. 
Variable names, indentation style, etc. &amp;#x200B; For the record I do know `person\_say(\_, Say) :- weather(sunny), Say="What a nice day!".` could have been written `person_say(_, "What a nice day!") :- weather(sunny).` but it felt natural to me to want to check the weather was sunny before saying it's a nice day. Maybe that's my imperative instincts taking over, but let me know if you think it is or isn't weird.
Also not sure if my `try` predicate was in the appropriate place an experience prolog programmer would expect. I couldn't find a swi-prolog built-in for it, at least not easily, and it was so easy to implement what I want that I just went ahead.
Done, thanks for the feedback! (Weird when I posted it it looked nicer)
What is the try predicate for? It seems utterly redundant. I mean that: try(myclause). Is exactly the same as: myclause. The call/1 predicate is meant for metaprogramming, not programming. Just my two cents. :)) 
&gt; it felt natural to me to want to check the weather was sunny before saying it's a nice day. FWIW, you should read `:-` as something akin to "if and only if," so the unification is not going to happen unless `weather(sunny)` is true. It's not like it performs the assignment _and then_ checks `weather(sunny)` in the latter format. I think a better argument for this format is symmetry with the ensuing method. Code style. Assuming you are likely to add more `person_say/2` clauses.
It's not exactly the same, it's suppressing the failure. `try(myclause)` is the same as `(myclause ; true)`. The author doesn't want `retract(weather(sunny))` to fail because `weather(rainy)` is true instead. Another approach that obviates the need for `try/1` would be to use a variable in the `clear_sky/0` predicate: clear_sky :- retract(weather(_)), assertz(weather(sunny)).
I really like this program! A nice, simple system that has a little taste of a lot of things. Have you seen the Nani Search tutorial? I think you might enjoy it if you haven't.
Thanks! Also what do you think of the line person_say(_, Say) :- weather(rainy), member(Say, [ "It's so glum today.", "Glad I have my umbrella.", "Rain rain go away..."]). I haven't seen this often in the prolog example programs I've seen, usually prolog programmers seem to prefer person_say(_, "It's so glum today.") :- weather(rainy). person_say(_, "Glad I have my umbrella.") :- weather(rainy). person_say(_, "Rain rain go away...") :- weather(rainy). Would you say one is better from a style or understanding perspective than the other? My goal is that an experienced prolog programmer would look at the code and not have to think too hard about what it means. I may be abusing the term but I guess "literate code" is what I'm asking about.
In this case, it looked like a stylistic choice, that you wanted to have one predicate for sunny and one for rainy, rather than a proliferation of predicates. It seems unlikely that you're going to try and unify this with the second argument instantiated, so I'm not worried about performance too much here. And it was immediately obvious what was going on there, so I wasn't too troubled by it. Looking at it now, later on you collect all the possible sayings and choose one randomly using `random_member/2`, which I've never seen before (thanks for that!). So, you have the list in point A, then Prolog is going to have to use `findall/3` to get a bunch of solutions, and then you'll have that list again in point B. This is not super efficient, it might be cleaner to just accept that `person_say/2` is going to have a touch of randomness to it and have it do the `random_member/2` thing, or make the second parameter of `person_say/2` be a list instead of a single value. I'd be inclined to make `person_say/2` random, because it isn't obvious to me why the idea of "interacting with" would begin by finding a bunch of solutions... In any case, I don't see any serious problems here (read some questions on Stack Overflow's prolog tag if you want to see serious problems!) and I don't see anything here that would be a particular impediment to anyone versed in Prolog understanding what's going on. It's simple code!
I agree about Mercury! I think it’s a good example of how syntax actually matters. Many people won’t use a language that feels ugly or inconvenient to write.
Thanks again for the feedback :)
This is a great video! It made me want to try out Smalltalk as well :)
I was at a public lecture given by Ehud Shapiro. It was organized, of all things, by local Clojure user-group. Ehud Shapiro worked on few things that were part of Fifth-Generation Project. In the lecture, he talked about declarative debugger and parallel Prolog. He didn't really reflect on what caused the project's demise, but it seems like he was very upset about what happened.
What do people think will be some good uses for web-prolog? 
For building web applications that need to both call APIs on a server and receive events from a server. A web chat application - something like discord or slack for example. Anything that Erlang might be a good use for.
code formatting
They're just using `/` to create a compound term here, like a pair. The underscore is acting as an uninstantiated variable; the next lines of code in the sample process this list of country-colour pairs using this structure. Using `/` like this is not terribly common, `-` and `=` are somewhat more common, some people use `,` which presents some additional difficulties, but ultimately the author just decided to associate an extra blank variable with each country during this step rather than later on.
Thanks for the explanation. How would you write it using &lt;pre&gt;&lt;code&gt;-&lt;/code&gt;&lt;/pre&gt; or &lt;pre&gt;&lt;code&gt;=&lt;/code&gt;&lt;pre&gt;? Also what does &lt;pre&gt;&lt;code&gt;^&lt;/code&gt;&lt;/pre&gt; means in the example &lt;pre&gt;&lt;code&gt;X^neighbours(Country,X)&lt;/code&gt;&lt;/pre&gt;?
You'd do `Country-_` or `Country=_` instead. Prolog does not evaluate things the way other languages do, expressions with operators in them are just more structures to it until you put them in a context where they would be evaluated. The `^` in the `setof/3` is causing X to be existentially quantified. You can think of it as a hint to `setof/3` that you don't care what value it takes. Without it, `setof/3` will produce separate solutions each time X changes, which is every time. Compare: ?- setof(Country, neighbours(Country,_), Countries). Countries = [malta] ; Countries = [slovenia] ; ... Countries = [france] ; Countries = [ireland]. ?- setof(Country, X^neighbours(Country,X), Countries). Countries = [austria, belgium, bulgaria, croatia, cyprus, czech_republic, denmark, estonia, finland|...]. In this case, `setof/3` is giving you the same behavior as `findall/3`, which always returns a single solution. The behavior of `setof/3` (and `bagof/3`) with existentially quantified variables can be really useful. For instance, once you have the list of countries by color, you could use `setof/3` to give you all the countries with each color; you'd get four solutions.
You could import it in the user init file if you don't care. http://www.swi-prolog.org/pldoc/man?section=initfile You could also put a path alias in there instead, and include it manually in each file. http://www.swi-prolog.org/pldoc/man?predicate=file_search_path/2
Thanks for excellent explanation. The "Prolog does not evaluate things the way other languages do" explains a lot. The ^ explanation is also interesting. None of the web sites I come across mention these. 
Alternatively there's a built in predicate to do this! http://www.swi-prolog.org/pldoc/man?predicate=ignore/1
&gt;Alternatively there's a built in predicate to do this! &gt; http://www.swi-prolog.org/pldoc/man?predicate=ignore/1 Perfect, thank you! 
Like /u/wellmeangtroll says, every statement gets fresh variables. The three A's you have in your example are all different variables because they're in three different statements. You can put them all in the same statement like this: ?- A is 3, B is 3, A =:= B. A = B, B = 3. This is Prolog saying "Yes, that's true, and the values of all the variables are...". Otherwise it would say "no": ?- A is 3, B is 4, A =:= B. false. 
No it is not that different really.
Prolog
You’re on the right track. What’s throwing you off is that the toplevel isn’t stateful the way you expect. It’s more like a sqlite3 session than your usual REPL: each command - each query - stands alone, unless they communicate through affecting the database. So “A is 3.” is really more like, “Check my work: A is 3. Can you verify that?” The prompt of “?-“ is very vaguely hinting at “put a question”. Moving the claims into a single command puts them all as part of the same question. “A is 3, B is 3, A == B.” is basically “Let’s say: A is 3, and B is 3, and A == B. Can that be true?” And you’ll get back false (nah, it’s gibberish) or examples of true cases - here, A = 3 and B = 3.
Because your comment was too long, the only thing I really noticed is the last word, "frustrated", and just wanted to say that programming (or _any_ work worth doing, really) always involves some amount of frustration. Esp. with interesting or demanding work. So the question maybe is not what kind of language Prolog is, but rather what kind of person (programmer?) OP wants to be.
Absolutely. I am not sure you can get a permalink to it :-(
You mean you don't think the link https://www.dropbox.com/s/9jhlbpmzho9is9z/1408.pdf?dl=1 is permanent, because it's a Dropbox link? You don't think they'll keep the link on https://mitpress.mit.edu/books/art-prolog-second-edition up to date and we can link people to that page?
[You can find that here.](https://www.youtube.com/watch?v=dQw4w9WgXcQ)
The best first Prolog book for anyone seriously interested in programming. Requires firm grasp of the fundaments of computer science and maybe some experience with programming in general. Some of the code in this book is literally textbook knowledge. The definitions of predicates like `append/3` and `select/3` (among many others) are the standard by now, and you can even find them in Prolog standard libraries, for example [here](https://github.com/SWI-Prolog/swipl-devel/blob/master/library/lists.pl). So definitely a great place to start. The book itself is organized in a beginner-friendly manner, and explains enough of the context _and_ goes into enough detail. The last 1/3 of the book is a bit more technical but eye-opening, in a way.
Beware though: The second edition introduces mistakes that are \*not\* present in the book's first edition! &amp;#x200B; For example, in the second edition, Program 10.3 yields wrong answers for the most general query.
That's incomplete/misleading. It makes perfect sense in the context it is presented.
Brilliant! This is the one I don’t have. 
I saw a comment from Ulrich Neumerkel once that the first edition is superior in some regards. I suppose this is the kind of thing he meant. I've never been able to compare the two, but now [the first edition](https://mitpress.mit.edu/books/art-prolog) is also open access! But now that I can compare, are you sure you mean Program 10.3? Because it looks the same in both editions. 
I like that you didn't read what I wrote, but that didn't stop you from replying.
Great, thank you for that link. You are indeed correct, Program 10.3 seems to be exactly the same (btw, 60MB pdf, I am impressed). I wonder what exactly u/zmonx meant to say.
overdosing(prolog).
Yes, you are right, this mistake indeed occurs in both editions! An example of a mistake that occurs only in the second edition is found in 11.3 ("Negation"): "Standard Prolog provides a predicate fail\_if (Goal), ...".
Have you seen [XPath](https://www.w3schools.com/xml/xpath_intro.asp)? It is essentially an HTML/XML query language, and [there is an implementation in SWI-Prolog](http://www.swi-prolog.org/pldoc/man?section=xpath) along with its [SGML parser](http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/sgml.html%27). It does a sufficiently good job that I haven't ever really wanted something else, though many web scraping systems provide a CSS-selector like system alongside XPath.
Firstly, XML and HTML suck. &lt;html&gt; &lt;head&gt; &lt;title&gt;Foo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p class="text"&gt;Some text&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; html( head([ title("Foo") ]), body([ h1("title"), p("Some text", class(text)) ])). I don't know. Something like that. You could also make all the HTML things prefix operators: html head [title("Foo")] body [h1("title") p("Some text", class(text))]. 
Join the dark side! We have parentheses! http://www.rkn.io/2014/03/13/clojure-cookbook-hiccup/
Agree completely (did you have to use so many words tho? trolling). Thanks for the mention about the link, apparently you have to escape the trailing close-paren for Reddit's markdown to be happy.
I didn't want to spend too much time writing a good comment so I just typed it out in a hurry.
"If I had more time, I would have written a shorter letter."
Thinking more about streaming, I thought I'd peruse the code for the sgml module in SWI. I don't see a way for you to hook into the parsing process to make it do something else. There is a facility called "[partial parsing](http://www.swi-prolog.org/pldoc/man?section=sgml-partial-documents)" that seems to be something you could leverage for streams. The documentation explicitly states that "Event-driven processing is not very natural in Prolog," which is probably true in SWI or ISO Prolog. I also found this [xml parser for Logtalk](https://logtalk.org/library/xml_0.html), which looks even less full-featured than the SWI one, but may be easier to copy/paste/adapt into a streaming parser. It's probably a lot easier to handle callbacks in Logtalk since you can make objects that match interfaces and the like. Or you could probably look at that and figure out how to make a pull-parser yourself. In Java, you would probably decide whether you wanted to have object serialization or not; if not, you could use SAX or a pull-parser to handle the stream yourself. If so, there are a couple tricks you could pull with JAXB, such as having your first object you return have a "list" that actually just behaves as a callback, and as it parses child elements under that list it hands them to your fake list and you handle them individually. This comes up sometimes even with just parsing large documents, let alone streams as you'd have with XMPP. I think in cases like that you probably are really dealing with a stream of events of various types. Maybe it would be easy to open a stream, read the open tag manually, and then invoke and reinvoke the XML parser on the same stream for each chunk, treating them as a series of separate documents.
If you conceptualize `check/3` as "true if any of two of the three values are the same" then I would be tempted to implement it like this: check(X,X,_). check(X,_,X). check(_,X,X). Such an implementation will necessarily have three choice points; Prolog knows after trying `check(X,X,_)` that it has to try two more things, but it doesn't know whether those things will work until it tries them. This is the same situation as with your code. &gt; If A and B have the same value, I want it to return true and stop running the other statements My first reaction is that you are trying to meddle too much with how Prolog works, because _in the general case_, just because you're on a successful path now doesn't mean it won't fail later on and have to backtrack and try another case. But really the only case I can think of for this particular predicate would be one in which you've made a call like `check(a,a,a)`, in which case `check(a,a,_)` already succeeded and now we're going to produce extra solutions for `check(a,_,a)` and `check(_,a,a)`, which all deal with the same value, not really altering much the rest of the problem. In a funny way, you only ever have zero, one or three solutions. A safe and straightforward way to do this, IMO, would be to do something like this: check(X,Y,Z) :- once(check0(X,Y,Z)). check0(X,X,_). check0(X,_,X). check0(_,X,X). I like `once/1` a lot, because it's like a very safe way of using the cut. Barring that, you would probably have to use a bunch of conditional expressions, like this: check(X,Y,Z) :- X == Y -&gt; true ; (Y == Z -&gt; true ; X == Z). If statements like this do not produce choice points in Prolog. And this is very compact compared to my solution above. But I still prefer it even though it's a bit bigger because I find it a little more obvious to me what it does. Opinions will vary.
Yes.
Not absolutely sure, but maybe you are mistaken. You can register callbacks on elements. Check sgml_parse/2 and try to understand what the code in your link on "partial parsing" does. I thought it was clear from my comment above but apparently I am not understanding something.
I'm looking at the facility and I don't see how I could use it effectively since I can't associate mutable state with those callbacks. But maybe I lack imagination.
Did you read the code example that you linked? There you get "mutable state" by asserting. There are many other ways of course but I sound like a broken record.
I didn't really read it. I see now what you mean.
First of all, thanks a lot for your reply! I did use the semicolon after the first answer in the Collatz Conjecture. It got me the first answer and then a \*\*false\*\* return. &amp;#x200B; hailstone(3,N). &amp;#x200B; N = 3 ; &amp;#x200B; false. &amp;#x200B; However I do get the same result as you when I use findall on permutation, and more importantly I must have not tested the semicolon on the permutation because it is working. Thanks a lot! Although it does mean that I'm not understanding correctly what's happening in the prolog program. &amp;#x200B; On a side note, I'm really left wondering about this Collatz Conjecture implementation... &amp;#x200B; &amp;#x200B;
Happy to help, enjoy prolog!
Starting a separate comment, to be separate :) u/wellmeaningtroll kind of gets it. There is more to the question. I am not trying to solve an actual problem. It was more of a I'm curious how the experienced Prolog devs approach these problems. For example, in a few of the Prolog texts I've been reading I've learned that parsing with the DCG is really nice. In fact some have stated that regular expression libraries are unnecessary because of the DCG support. I really agree with this point of view given my experience with regular expressions. They get unwieldy quickly. That made me wonder... do Prolog programmers find SQL or XPath or CSS selectors to be too primitive as well? What would a Prolog programmer use instead of them? To re-emphasize my point with SQL, it is notoriously or painfully bad at hierarchical queries. On the other hand, I've seen in prolog texts examples of 'database queries' as functor(Field1,_,_,_,_,_,_) etc. The lack of support for name attributes really hurts Prologs case there. Given that, I would lean towards making some DSL for queries. 
Hi - thx - I'm aware of XPath and CSS selectors. I was wondering if there was something idiomatic in Prolog that could achieve the same goals. (I've elaborated more in a separate comment on this thread)
Thx - you were right about there being more to the question. I've elaborated more in a separate comment on this thread. 
Thx - will chek out Logtalk. I'm still wrapping my head around prolog. It is hard to think about an event loop or a lazy list of elements. Maybe it could be seen as a parser that emits documents every now and then?
Yep - totally agree, but HTML is not going away soon. You have posted a representation that would look as I imagine some html to look. I've elaborated more about my question in a separate comment on this thread. I'm wondering out loud here on reddit if there is some idiomatic way of building a query language in Prolog that is better than SQL, XPath, etc. 
That can explain a lot indeed. And I understand the struggle, we're taught imperative first (C or Java say) and FP seems totally alien when you run into it. Especially full fledged languages like Ocaml who have a lot of syntax and constructions that hide the simple recursive nature of it. I think your mathematical background can help you revisit FP/Prolog through induction reasoning. I'm slightly suggesting you read basic functional programming exercises in lists; whether it's Ocaml, LISP or Haskell, you'll find a good playground for linear recursion. On a personal note, I struggled to grok induction but when it happened it was a strong eye opener, it does help you think about very large or very abstract problems. I wish high school math lessons had induction proofs on list rather than natural numbers :)
One last word of advice: concentrate on a concrete problem, choose your weapon, and try to solve it. You will learn a lot along the way. Abstractly thinking about things is important, but it won't take you all the way.
You, good sir, are a lifesaver! Thank you so much for such a detailed explanation, I'm gonna be reading that two or three more times! Seriously, this is so much more understandable than what my uni has been giving me... Thank you again and again! As an aside, if anyone is ever in the same situation and needs some additional ressources, I've found a book by John Stobo (Logic Programming in Prolog) and it's being very helpful! 
I strongly recommend "The Art of Prolog" by Sterling and Shapiro. A link to a free PDF from the publishers was posted here a couple of days ago, here is the link again: https://mitpress.mit.edu/books/art-prolog-second-edition (Look for the "Open Access Title" section on the left side, under the picture of the front cover.) Program 3.20 on page 69 has a definition of permutation/2. Almost anything you will find in the comments here has already been explained better in this book (sorry fellows). What this book gets right is that it discusses logic programming, pure Prolog, and practical Prolog, paying enough attention to the differences.
You're welcome! I think another Prolog problem that is fundamental in order to understand how recursion works in this language but which is a bit easier to understand is `subset`. The first line is the base case. Look at the second case and third cases and read it like this: subset([], []). subset([X|Y], [X|S]) :- subset(Y, S). subset([_|Y], S) :- subset(Y, S). ?- subset([1,2,3], L). L = [1, 2, 3] ; L = [1, 2] ; L = [1, 3] ; L = [1] ; L = [2, 3] ; L = [2] ; L = [3] ; L = []. "Say we have a list Y with subset S. If I have another list such that it's like Y, but with another element in front ([X|Y]), what is the subset of this second list? Well, it's going to be the subset of Y, but with the same X in front too. In other words, lets say you have a list `[1,2,3]`, where `X = 1` and `Y = [2,3]`: Would you agree that if you know that the subset of [2,3] is S (for example, [2], [3] or [2,3]; there are no permutations here) then the subset of that with an X in front ([1,2,3]) is the aforementioned values with a 1 in front too? [1,2], [1,3], [1,2,3]? By definition of subset, yes. But! There's a second case we are missing! Take [1,2,3]. Isn't [1] a subset of that too? Isn't [2] also a subset of that? That's why we have the third case: we say, if the subset of Y is S, then the subset of a list like Y with a value in front ([_|Y] we use _ because we dont use the variable, but that could very well be [X|Y]) is the same subset. We don't need to add the value. That's why you get results like the subset of [1,2,3] being [2], [3], [2,3], etc. We didn't add the 1 in the solution, because that's part of the definition of what a subset is.
Thank you for letting me know! I'm not surprised that those functions are already defined; I wrote them again because I have an upcoming exam. Furthermore, I think it's good for OP to be able to express a problem from scratch without relying on functions (even if they are so basic) just so he/she gets to see more definitions of Prolog functions.
Hey, thank you so much for the reply. https://www.dcc.fc.up.pt/~vsc/Yap/documentation.html Here's the documentation I'm using. Here are the prolog facts: https://drive.google.com/open?id=1ofYsgIe8nsVXlsIkbGkhtPALzXA37VfV Only the first ~1000 lines matter for this query. Thanks in advance, sorry for bothering
It’s interesting the different flavor the interface has, judging from the CP/M primer. It’s got far fewer “weird symbols” than the Prolog of today. Yet already the short text is able to contrast the declarative vs imperative readings of a query.
&gt; building a query language in Prolog Prolog *is* the query language. Let's change the HTML encoding a bit. It's more verbose but more workable (and could be improved with operators): element("html", [], [ element("body", [], [ element("h1", [id("theTitle")], []), element("p", [id("theText")], "Some text") ]) ]). findById(Id, element(Type, Attrs, Contents)) :- attrsContains(id(Id)). findById(Id, element(Type, Attrs, Contents)) :- findById(Id, Contents). 
Ah! - this is interesting. Thanks for the reply.
OMG. They are not functions they are predicates. If OP wanted to see more predicates they should get a textbook. Same goes for you my friend.
The link you provide says you should be careful, not that you should avoid collecting all solutions altogether. Esp. when you use Prolog as a database there is no replacement for bagof/3, setof/3, and findall/3.
This absolutely did the trick!! Thank you so much /u/wellmeaningtoll Can't thank you enough my friend, have a great weak! &lt;3
Well I really wasn't trying to do your homework for you. Now I feel bad.
Good point on use-as-database as justification. For the outer “find me ones with 5 actors”, you can avoid findall in favor of just poking it along “and the next one?”, but I had trouble seeing a good way to build that film_actorCount relationship without findall or similar, because it’s very intentionally accumulating state across backtracking.
I don't quite understand what you mean.
I'm a little too young to have used one of these machines but if I had to guess some of the standard symbols may not have been universal on the machines of the day. I know the original Prolog implementation also used very symbols (famously writing lists with periods, for instance.)
If so, it’s a far sight better than C’s workaround for limited keyboards/charsets of [trigraphs.](https://en.m.wikipedia.org/wiki/Digraphs_and_trigraphs#C)
`y` is not a variable in Prolog. `Y` is. Also, Prolog does not "return" values. These are answered-on-page-2 type questions, please read further in your tutorial or book.
and the [Bratko's book](http://catalogue.pearsoned.co.uk/educator/product/Prolog-Programming-for-Artificial-Intelligence/9780321417466.page) too
It would be better to ask on Stack Overflow, and include the rest of the code, since what you've got here isn't enough to run on my machine and see the problem.
It is easier to ensure your symptoms don't repeat when you receive them, rather than propagate duplicates further into your code, `sort` predicates allows you to do that. For example: symptom(delusions). symptom(hallucinations). symptom(disorganized_speech). schizophreniform_disorder(ExistingSymptoms) :- sort(ExistingSymptoms, SortedSymptoms), findall(S, (member(S, SortedSymptoms), symptom(S)), MatchingSymptoms), length(MatchingSymptoms, N), N &gt; 1. 
One problem here is that arithmetic evaluation is not extensible in ISO Prolog or SWI-Prolog. I believe SWI used to allow it (I could be mistaken). So you really cannot get your own functions into the right-hand-side of an `is/2` evaluation. This turns out not to be a huge problem most of the time, because you can still use `call/N` to call your own predicates, and you can make your own interpreters that use `is/2` as necessary. So what you probably need to do is a add a rule that looks something like this: evaluate_expression(X =&gt; Y, Result) :- evaluate_expression(X, R0), R0 -&gt; (evaluate_expression(Y, R1), Result = R1). And then you either need to decorate your arithmetic expressions so you can detect them in the head of `evaluate_expression/2` or you will wind up having to detect all the math operators and bridge them into your scheme. In other words, do something like: evaluate_expression(arith(Expr), Result) :- Result is Expr. or a bunch of rules like evaluate_expression(X + Y, Result) :- Result is X + Y.
Ok, I understood about zero of that. Tried out the second code block, without any success(no unification with Result). Building rules for every single expression isn't feasible, as I'm trying to evaluate things such as A=&gt;B^C, and build truth tables for them. So, again, to clarify: how do I pass an expression with an operator or predicate to a rule, and obtain a result?
You gave me a sketch of your problem and I gave you a sketch of how to solve it. If you want an exact solution to your exact problem, share your exact problem. Say you want to add an operator `borp`. This new operator does something weird like, take whichever is smaller, half the first times the second or half the second times the first. Let me show you the code for this. :- op(500, xfy, borp). Now you can enter expressions with borp in them, like `X = 3 borp 4 borp 4 + 1.` to which Prolog will simply echo them back: ?- X = 3 borp 4 borp 4 + 1. X = 3 borp 4 borp 4+1. To actually evaluate them, you need to write an evaluation predicate, which would be something like this: eval(X, X) :- number(X). eval(X+Y, R) :- eval(X, XN), eval(Y, YN), R is XN+YN. eval(X borp Y, R) :- eval(X, XN), eval(Y, YN), R is min(XN/2 * YN, YN/2 * XN). Now we can evaluate the above expression: ?- eval(5 borp 4 borp 4 + 1, R). R = 21.0. Notice that I have a rule for borp and a rule for +. I do not have a rule for every possible expression, because I can simply recur down both sides of the expression tree evaluating. So if I wanted to cover everything that `is/2` covers, I could just make rules for the six or ten operators it has rules for that look like my addition rule. This is the classic approach to building a simple interpreter for your own expressions.
Ok, your examples are a bit complex and all over the place, so let's start from the top. Keep in mind that I'm learning this language, so KISS. 1)How do you define borp to be an arithmetic operator such that it returns a value? I'd simply have borp as :- op(500, xfy, borp). XborpY:- some set of clauses. Any way to define borp as addition, and return the sum of X and Y? If there is, I'm guessing I can simply use eval(X,Y):- Y is X. ?-eval(1borp2,Result) This I already knew, since I could call: ?-eval(1+2,Result) 2) In spite of the above being successful(assuming I can define borp), I'm trying to work with predicates. How do I directly evaluate predicates? I tried the following: likes(mary,wine). eval(X,Y):- Y=X. //Y is X will not work for predicates ?-eval(false,X) //unifies X=false ?-eval(likes(mary,wine),X)//unifies X=likes(mary,wine), but does not evaluate it 3) If there is no way to evaluate it directly, it means I have to painfully parse the expression, which will probably include multiple terms, multiple operators, left and right associations, and various infix/prefix notations. God only knows how I'll manage that. Still, I might be able to do that using arg(), functor() and call(). However, that leads me to another issue, namely [using call() on custom predicates](https://www.reddit.com/r/prolog/comments/9rmsey/using_call_on_custom_predicates/). How do I do that? Thank you. 
You're trying to do a medium-simple thing, and I am doing this as simply as it can be done. The fact that it seems complex to you has more to do with this all being new to you. There is not some magic simpler way to do it, you will actually have to work and try to understand what I have said already. Or consult other resources. What I said originally is true. You cannot add a new arithmetic operator to Prolog such that it will magically work on the right-hand-side of `is/2`. So you will not be able to intermix your new operator with other existing arithmetic _and_ have it "just work" by using `is/2`. You will have to add your own evaluator as I have done above with `eval/2`. Your "simple" definition of `borp/2` is fine, but again, it isn't happening inside of `is/2`, and you would still have to deal with the case where you have an expression like `(2 + 3) borp (4 + 5)`. You don't want to have a copy of `eval/2`'s body inside `borp/2`. You can evaluate arbitrary expressions using `call/N`. The problem with this is that **Prolog queries do not evaluate to values**. In a language like Python or C, an expression like `foo(bar(23))` is evaluated by finding the value of `bar(23)` (say it works out to 46) and the substituting that value into the outer expression, `foo(46)` and then evaluating that to produce a value like 4.6. A Prolog query like `likes(mary,wine)` can succeed or fail, but it does not "evaluate" to a value. So what on earth is `eval(likes(mary, wine), Y)` supposed to unify for Y? Or worse, something like `eval(member(X, [1,2,3]), Y)`?
There may be a better workaround, but you could always do something like `p(X, Y) :- X ~ Y`, then just use `call` on `p`.
SWISH has limitations that prevent a developer from fully using the SWI-Prolog features. Try to avoid it when trying something advanced. If you still use it, look for “Sandbox restriction” message like in this case.
As I/dklions81 explains, Prolog does not let a developer to define a custom arithmetic operator. Basically this means any custom operator will “return” true or false and will never “return” an integer or anything else. Hence is/2 cannot accept the result of a custom operator because it requires both arguments to evaluate to numbers.
So, if I have an expressions like (A=&gt;B^C)vD (A^B)=&gt;(C&lt;=DVE) (AvB^C)&lt;=&gt;(DvE=&gt;F) how can I build an evaluator rule that prints out a truth table for those values? Y'know, since every approach I try seems impossible...
Trouble is, that doesn't allow for variable arguments.
I will come back later and show you how I would do it, but you may want to consult [this Stack Overflow answer](https://stackoverflow.com/a/2103284/812818) in the meantime. In general it would be better to ask these kinds of questions there anyway, so that next semester when someone else gets confused and asks the same question, it's a lot easier to find the answer there than on Reddit.
Have you looked at Mercury? 
The way I did it was that the device itself is in control. It runs a control loop which pushing events into your database and then queries what to do next. Your code then returns a result for each query, based on the events given. Each event and query has timing information; an atom is generated for each point in time. Predicates like "then(t1234, t1235)" are added to your database so your code knows which order the events happen in. E.g. say that the query is "performAction(Timepoint, Action)" and inserted events are "event(Timepoint, Event): performAction(T2, drawImage(Canvas, X, Y, Image)) :- then(T1, T2), event(T1, mouseClick(Canvas, leftButton, X, Y)), happyFace(Image). This code is made up on the spot. This API doesn't exist and can do with improvements, such as passing state around.
Don't fall into this trap. Here is what you do: - decide what you want your program (or programming language) to do; - make up your mind how you want to write it down; - write the program that translates what you wrote down to the behaviour you want to observe. As a bonus, if you get as far as the second step, you can share with others something tangible.
It also lacks a REPL, which makes it kind of a non-starter for me.
This is a complete example I worked up. I will be posting this on Stack Overflow later, so that next September it can be found. %% truth table examiner for u/emergenthoughts on reddit bool(0). bool(1). negate(1, 0). negate(0, 1). eval(Assignments, A, V) :- atom(A), memberchk(A=V, Assignments). eval(Assignments, \+ E, V) :- eval(Assignments, E, NotV), negate(NotV, V). eval(Assignments, E1 /\ E2, V) :- eval(Assignments, E1, V1), eval(Assignments, E2, V2), V is V1 /\ V2. eval(Assignments, E1 \/ E2, V) :- eval(Assignments, E1, V1), eval(Assignments, E2, V2), V is V1 \/ V2. eval(Assignments, E1 -&gt; E2, V) :- eval(Assignments, E1, V1), V1 = 1 -&gt; eval(Assignments, E2, V) ; V = 1. generate_assignment(Variable, Variable=B) :- bool(B). generate_assignments(Variables, Assignments) :- maplist(generate_assignment, Variables, Assignments). atoms_of_expr(A, A) :- atom(A). atoms_of_expr(\+ E, A) :- atoms_of_expr(E, A). atoms_of_expr(E1 /\ E2, A) :- atoms_of_expr(E1, A) ; atoms_of_expr(E2, A). atoms_of_expr(E1 \/ E2, A) :- atoms_of_expr(E1, A) ; atoms_of_expr(E2, A). atoms_of_expr(E1 -&gt; E2, A) :- atoms_of_expr(E1, A) ; atoms_of_expr(E2, A). table_for(E) :- setof(A, atoms_of_expr(E, A), Variables), write_header(Variables, E), write_separator(Variables, E), table_rest(Variables, E). table_rest(Variables, E) :- generate_assignments(Variables, Assignments), eval(Assignments, E, Value), write_assignments(Assignments, Value), fail. table_rest(_, _) :- true. write_header([Var|Rest], E) :- write(' '), write(Var), write(' | '), write_header(Rest, E). write_header([], E) :- writeln(E.) write_separator([_|R], E) :- write('---+-'), write_separator(R, E). write_separator([], _) :- write('-+-'), nl. write_assignments([_=Var|Rest], Value) :- write(' '), write(Var), write(' | '), write_assignments(Rest, Value). write_assignments([], Value) :- writeln(Value). Here's what the output looks like: ?- table_for(a /\ b \/ c -&gt; d). a | b | c | d | a/\b\/c-&gt;d ---+----+----+----+--+- 0 | 0 | 0 | 0 | 1 0 | 0 | 0 | 1 | 1 0 | 0 | 1 | 0 | 0 0 | 0 | 1 | 1 | 1 0 | 1 | 0 | 0 | 1 0 | 1 | 0 | 1 | 1 0 | 1 | 1 | 0 | 0 0 | 1 | 1 | 1 | 1 1 | 0 | 0 | 0 | 1 1 | 0 | 0 | 1 | 1 1 | 0 | 1 | 0 | 0 1 | 0 | 1 | 1 | 1 1 | 1 | 0 | 0 | 0 1 | 1 | 0 | 1 | 1 1 | 1 | 1 | 0 | 0 1 | 1 | 1 | 1 | 1 true. It's tempting to consider trying to write this using straight Prolog variables. Perhaps for your use-case that would work, if so, see `term_variables/2` and save yourself from including `atoms_of_expr/2`, but in my case I wanted to be able to print the expression with the _name_ of the variable (`a` or `b` or whatever) and if you use Prolog variables the name Prolog shows you is not metadata you can get at, at least as far as I could find. So I have a redundant traversal of the tree in `atoms_of_expr/2` for building the table. Another design decision, I went ahead and used `is` to evaluate AND and OR using the Prolog operators `/\` and `\/`. I could have used `bool(true). bool(false).` and then defined `and/2` and `or/2` instead, but I figured since part of your query had to do with extending `is/2`, you might like to see that being reused. A point I think may be sticky for you is how we are able to mix the `is/2` evaluated things with our custom implication operator. The answer is sort of typical of recursion, we use `expr/3` to reduce sub-trees to boolean values, so by the time we enter `is/2`, we are evaluating expressions with a single binary operator in them and two values, not sub-expressions. Anyway, I hope this helps. Let me know if you're still confused and I'll see if I can clarify anything.
There are too separate issues here: * Logically pure I/O. Prolog has no way to achieve this and it isn't very easy to do in logic programming because of backtracking, as you say. Mercury does it with static modes and static uniqueness types. Static modes alone make Mercury a very different language from Prolog. * Logically pure computation with state. This is _very_ easy to achieve in Prolog. You need to carry the state around in terms. There is a nice example of the latter, with interactivity, in Peter Flach's free book _Simply Logical_ in the natural language interpreter at the end of [section 7.3](https://book.simply-logical.space/part_iii.html#interpretation_of_natural_language). Notice that you can "assert" a statement `[every,human,is,mortal]` in the interpreter, but the assertion is logically pure, because the list of asserted rules is carried around (as `Rulebase` in the meta-interpreter `prove_rb/2`) in a list of rules that is threaded through the computation and changes as rules are "asserted". (You can try the code in your browser.)
This looks like a nice solution. It preserves logical purity in the clauses. The timed predicates resemble temporal logic. You have preserved little bit of ability to reason about the actions using different queries. You can ask whether the program would draw an image if it had some set of events. It's resembles how Haskell's I/O monad solves the same problem. &amp;#x200B;
It would indeed be a bad idea to be thinking of this if you were trying to do something practical. I'm not doing anything practical though. I'm a programming language designer.
Ha, good one ;-) I was honestly trying to help. One example in code or any other (semi-) formal notation would count way more than a paragraph or a page of free text. When you throw around words like that, they mean something to you and something completely different to everyone else.
I would be very interested to see a worked out example of how you'd ideally want the interaction with the system to look like. Something like: User: Could you go ahead and park the car in that spot? System: I see a cat there. Is it OK to run it over? User: No, do not run the cat over. Please use the horn to scare it away, then park. System. OK, used horn, cat is gone, now parking. Should I always use the horn when there is a cat in the way? User: Only if we are not in a residential area. System: OK, added rule "Scare cats that are on the way with the horn if we are not in a residential area. Otherwise ask for instructions." Is this correct formulation? User: Good enough for now. ---- Do you get the idea?
I have posted your question on Stack Overflow [here](https://stackoverflow.com/questions/53068824/prolog-show-truth-table-for-arbitrary-expression-using-is-2-for-some-subexpress).
[Fifth generation computer systems initiative](https://en.wikipedia.org/wiki/Fifth_generation_computer) tried to put concurrency into Prolog. They didn't entirely succeed but didn't entirely fail either. Therefore some sort of a warning is appropriate for people approaching similar subjects. Especially if they have some task at hand that needs to be solved. A system satisfying my requirement would be able to construct a plan, speculate outcomes, act on that plan, try out things and refine its plan as it acts on it. It would run continuously until it runs out of things to do. It might run on goals, or objectives, or provide a service. If I already knew what I'm looking for, I'd be more specific. I would desire to escape from imperative programming style. Telling step-by-step what computer should do when being tasked to do something. Some time during this Autumn I've concluded that imperative/object oriented style of programming is something that belongs to the problems, rather than to the set of solutions.
**Fifth generation computer** The Fifth Generation Computer Systems [Present and Future] (FGCS) was an initiative by Japan's Ministry of International Trade and Industry, begun in 1982, to create a computer using massively parallel computing/processing. It was to be the result of a massive government/industry research project in Japan during the 1980s. It aimed to create an "epoch-making computer" with supercomputer-like performance and to provide a platform for future developments in artificial intelligence. There was also an unrelated Russian project also named as a fifth-generation computer (see Kronos (computer)). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/prolog/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Alright so you don't really have anything in particular in mind. Fine.
I believe it is essentially doing what Clean does with uniqueness types, where effectful code must accept a "world state" and produce a new "world state" and these may never be reused, they must be threaded through the computation sequentially. I believe Mercury then applies lipstick to the pig in the form of DCG notation. Clean pitched this as a simpler alternative to Haskell's monads. If this isn't accurate, it's only because I've written ~10 lines of Mercury in my life and I didn't enjoy it.
 smallest([Smallest], Smallest) :- !. smallest([Pivot|Rest], Pivot) :- smallest(Rest, Smallest), Pivot &lt; Smallest, !. smallest([_|Rest], Smallest) :- smallest(Rest, Smallest), !. 
The Prolog part of this book is quite terrible. About your question, it is wrong is so many ways. First, you need at least one element to have a smallest. You also can use it to "seed" the search for smallest. Then, "smallest" means what? Smallest number? Smallest anything? If it is anything you'd have to use the correct comparison. If it is number, and you have a Prolog with an arithmetic function min(), you can use that. So here: smallest([X|Xs], Smallest) :- smallest_1(Xs, X, Smallest). smallest_1([], Smallest, Smallest). smallest_1([X|Xs], X0, Smallest) :- X1 is min(X, X0), smallest(Xs, X1, Smallest). This was for numbers.
Let me put it in other words: if you learn from someone who is bad at something, it is relatively difficult to get good. The Prolog part of this book is shit, just accept it. There are better books out there. As for what you are not understanding, you are probably not understanding that you are comparing a free variable using an operator that evaluates arithmetic expressions and compares their numeric values. But these are a lot of words and how are you supposed to know what it all means? Maybe by reading a better book?
Another way to approach this class of problems is to realize that all of them have in common this: you look into pairs of elements in such a way that one element is chosen from the input sequence uniquely, and another one is the one you have computed so far. This common thing is known as "reduction" or "folding", and different programming languages have baked-in way to automate this. For instance, SWI Prolog has http://www.swi-prolog.org/pldoc/man?predicate=foldl/4 . Using this predicate, your work will be reduced to only define such a predicate that given an element of a sequence and the minimal value computed so far will compute the minimal of them two. This is not as trivial as it may sound though, especially if you are trying to compare things that aren't comparable, or it is not known whether they are comparable (uninstantiated variables), what exactly you want to do about the edge cases will depend on a specific task you want to apply this to. Since it is just a learning exercise, I think, it's OK to just assume all elements of the list are numbers, but you need to keep in mind the limitations.
As you may have gathered from the many responses, there’s more than one way to solve this. Let’s look at how you tried to solve it, though. The error you tripped over has to do with its number operations being “extra-logical”: they don’t work with unbound logical variables - even though that’s probably why you want to use Prolog in the first place. You either work with that constraint, or you grab some new tools that can cope with unbound logical variables, like clpfd. The error you would have tripped over after that is an error in reasoning: &gt; Otherwise, the smallest element is both smaller-or-equal to the Head, and the smallest in the Tail. Rephrasing in painful detail: - Let [H | T] be a list L - Let S be the smallest in T - Let X be the smallest in L - Then X &lt;= H and X &lt;= S Note that unless you’re talking numbers with a lowest bound, X is never uniquely defined - all this says is “welp, it’s gotta be no bigger than these two.” (You might benefit from detouring to _Seven More Languages in Seven Weeks_ for the Idris chapter, where claims like “this function produces the smallest element in a list” can be done as part of programming and with the compiler’s help, rather than requiring unassisted reasoning outside the program.)
It’s because a, b, and c aren’t numbers.
So how can I use this solution to find the "smallest" of a list of atoms? For example smallest by lexicographic order?
Hm, this is a bit unfortunate. I also noticed it doesn't work with other numbers, for example: ?- smallest([1.0, 2.0, 3.0], X). This also breaks. So is it possible that you cannot use numbers, just integers?
Yes it’s just integers. If you look at the clpfd library you’ll see, though I suspect you already know that and asked the question because you knew it wouldn’t work.
Yes I knew it but I thought there must be some warning on the thread for anyone that takes your advice too seriously.
The idea seems solid in the proposal, but maybe that'd be possible to include structurally into Prolog, such that 'if' wouldn't be necessary. Still it's a good idea to avoid few Prolog cuts.
Here's how you can check what's wrong with your code yourself, in SWI-prolog. ?- consult("faulty_smallest.pro"). ?- guitrace. ?- trace. [trace] ?- smallest([1, 2], X). The thing will show you that it will immediately hit a hitch to the `X &gt;= H`, at the moment when it does so it's assumes `H = 1, T = [2]`. The comparison section in the SWI manual tells you that it expects the variables to be instantiated. But if you instantiate your variables and try then, the program is still faulty and does not do what you want. PROTIP: With your program, the query `smallest([3,2,4,1], 1).` succeeds. To program with Prolog, you got to understand both the imperative programming part, and the meaning of programs-as-proofs. Basically you're trying to tell the Prolog, what makes the item X, smallest item in the List Y? The first rule literally says: "The smallest item in the list Y is the last item in it." Umm.. you think that's true? The second rule says: "The smallest item in the list is smaller than the first item in the list. It's also the smallest item in the remaining part of the list".
Hey, I solved it with `foldl/4`! Thanks! Feels like cheating, though. Like it's not Prolog-y enough :) Got to try other approaches now, too.
&gt;“welp, it’s gotta be no bigger than these two.” I thought Prolog is supposed to deduce X is then the smaller of the H and S. I don't know how, though :) Thanks for the explanation! I'm trying to get my head around what Prolog can and cannot do. I'm not yet grasping it, but explanations in painful detail do help me sense the mistakes in my logic better.
`a :- b` means "if b, then a". `a, b` means "a and b". So combining those two together: for any sister/parent/sibling, if the sister is the parent's daughter, and that parent is the parent of a sibling, then that sister is a sister of that sibling.
Thank you so much!
Yes, using `fold` doesn't feel like a "true" Prolog way to deal with a problem like this. And yes, there are lots of ways this problem can be solved :)
So, your solution recursively splits the list into Head and Tail, until Tail is contains only one element, which is then deemed the "initial smallest", and then goes back through the stack, comparing the Smallest to all Head (Pivot) elements along the way. Neat. And the third rule (`(smallest([_|Rest], Smallest)`) is there as the "else" branch for `Pivot &lt; Smallest` subgoal. Whoa. This "define your logic as set of rules" is challenging for me. It's not what I'm used to in programming.
You need to just go one step further in your understanding. Firstly ‘is’ is exclusively for evaluation not unification. So replace ‘is’ with ‘=‘. Try tracing your rule again. 
A difference list is really just a special case of a simpler idea, a data structure with holes. If you stick uninstantiated variables in your data structure, as long as you keep track of those variables, you can fill them in sometime in the future for free. You wind up needing a way to hold onto the data structure separately from the holes. If you did this with a tree, you'd probably need two holes, one for the left and one for the right, so you'd wind up needing to keep track of three things. Because a list is either empty or has an item and a tail, there's only one thing you need to keep track of if you want to fill in the rest of the list later: the tail. So you could use in your program a standard functor, like `difference_list(List, Tail)`, and just pass that around; an example difference list would be something like `difference_list([1,2,3|Tail], Tail)`. The reason you have `Tail` in there twice is because in one position, it's deep inside your data structure, and you have another reference to it as the second argument so you can find the tail and add things to it easily. If you were making a difference tree instead it might look like `difference_tree(t(5,Left,Right), Left, Right)` and you'd have three arguments instead: one for the whole structure and one each for the left and right branches. Because operators in Prolog let you create two-argument functors very easily, people often do this for difference lists and instead of using `difference_list(List, Tail)` they would write `List-Tail` or `List\Tail`. But this is just syntactic sugar. Remember that in Prolog, a functor is a lot like a struct in C, it's a way to group together several values. It just happens to look like a goal or a predicate invocation. They're not the same thing, they just have the same appearance.
Same exact thing.
Could you please explain your findall in more detail? Is it a rule, is it a rule in the knowledgebase?
Remember, `[H|T]` is going to match H with the first element of the list and T with the remainder. It will never match H with [1,2,3].
The problem here is that you have a very weird and incorrect understanding of what basic Prolog does, and when you turn to more complex things in Prolog with a wrong understanding of the fundamentals, it looks even weirder and more limited. You are stuck thinking that operators do things to their arguments. Operators don't do anything. They just juxtapose two things. This turns out to be a lot more useful and powerful than if they did, but you have to get past this operator = evaluation = reduction hangup you have.
You've got two singleton errors here. What are you trying to do?
Did you get warning or an error? I’m pretty sure warning can be ignored if not then just replace those variables with anonymous variable to repress the error. 
diff([],[],[]). diff([H|T], [H|T2], R) :- diff(T,T2,R). diff([H|T], [H2|T2], [H|Tr]) :- \\+ H = H2, diff(T,[H2|T2],Tr).
So, try this: It’s probably not exactly what you want but it might encourage you: ?- f([(1,2,3),4,5],[4,5],R). 
Everything I would write here has already been explained better elsewhere. Someone posted a link to "The Art of Prolog" which has a whole chapter on difference lists. It uses the `L\T` notation but this is why I showed you how you can use `L, T` instead. And in the code in my comment above I showed how to "concatenate" when you have a difference list. Once again for the hard of hearing: ?- List = [a, b, c|Rest], Rest = [d, e]. there you go. But please do yourself a favor and read a bit before you push on with your questions.
What is this code doing and why?
There actually is something implemented in the language: append1(OpenList-Hole,ListToAdd):- Hole=ListToAdd. Called with: ?- DifferenceList=[a,b,c,d|Hole]-Hole,append2(DifferenceList-Hole,[d,e]). The problem is, at some point it gets more complex: append2(OL1-H1,H1-H2,OL1-H2). Called with: ?- DifferenceList=[a,b,c|H]-H, app(DifferenceList,[d,e,f|Hole2]-Hole2,Ans-[]) It's a "structure", that somehow fills in the tail. The problem is, it's increasingly convoluted(H1-H2 ?), having to pass difference lists of difference lists of difference lists. If you can explain those with a [H|T] structure, which is something I somewhat understand, that would be great. Again, the reason I'm asking for help here is precisely because the literature and the guides are failing me. Took a look at The Art Of Prolog, and it's a 500 page book from the dark ages that I'll never finish reading in time for the exam. Looking at specific chapters (15 in this case) helps none at all. Even stack exchange examples are usually as convoluted as a twisted tree in the darkest woods. Honestly, just looking to pass a class, and unfortunately, the professor isn't much help. Want less stupid questions? Advise your prolog friends to stop putting this on the curriculum. Put out a PSA in the community regading that.
Haha yes I know that Prolog is terrible in the classroom. But this doesn't help you right now. I don't know what you need to do to pass the class. I have passed many classes and if you ask me now, "how did you do it", my answer would be "it was not pleasant, don't bring back the memories please". So I will make one last attempt to help you, but first, please tell me: do you know how to implement a singly linked list in C? The one with the pointer to the first element that points to the second element and so on until you reach the sentinel?
Yes. I do understand that as recursion goes deeper, you can go through the list using the head as the current node. visit([]). %base case visit([H,T]):- write(H),visit(T). %recursive step. The trouble is, that "structure"(don't know what else to call it) is somehow avoiding that, by putting stuff at the end. And then putting stuff at that end. And so forth. And it's all passed with difference lists. 
Difference between lists through recursion. 
I get your stack point but can you please elaborate on why would it produce Q=X not Q=[1,2,3]
&gt; Want less stupid questions? Advise your prolog friends to stop putting this on the curriculum. Put out a PSA in the community regading that. .... and I will pretend that I didn't read this. You know that education is voluntary, right? And you realize that education is only good for those who want to learn?
That's probably what it should produce. But I don't think you'll be able to get there with uninstantiated variables.
I worry this might make someone believe that tuples exist in Prolog.
To be more blunt, I don't see what it has to do with difference lists per OP or the fact that [H|T] doesn't match subsequences, or anything else under discussion really.
 ?- List = [a, b|Rest],Rest=[c,d]. For is_list this seems to work. checkList(X):- var(X),!,fail. checkList([]):-!. checkList([_|T]):- checkList(T).
Good. You probably already understand what is "unification". For example, in `Rest = [c, d]` you unified `Rest` with `[c, d]`. It succeeded because `Rest` was free variable at that point of time; after the unification, `Rest` is the list `[c, d]`. In Prolog, just referring to two variables with the same name is what unifies them. This is why some texts say that `=/2` can be implemented as: =(X, X). Don't try to "understand" this, just accept it. So, you could have written a predicate that "concatenates" or "appends" a difference list with a list. Initially you had: ?- List = [a, b|Rest], Rest = [c, d]. Now you want to write: ?- List = [a, b|Rest], add_to_back(List, Rest, [c, d]). You should notice that I am passing the two terms, `List` and `Rest`, separately. In your class you probably would write `add_to_back(List-Rest, [c, d])` but this is beside the point. So you just define this as: add_to_back(List, Rest, More) :- Rest = More. But since you can just use the same name twice instead, it becomes: add_to_back(List, Rest, Rest). This will give you a warning if you try to compile it. Basically, this is an idiotic predicate and you shouldn't be writing it. Just unify `Rest` with the list, you don't need a predicate for this. But since your instructors are idiots they want you to write it. This is exactly the `append1/2` that you have shown above. If you want to append two difference lists to get a third one, you need 6 arguments: 2 terms for each list, 3 times. This gives you the `append2/3` that you have written above. Here it is with `List, Rest` instead of `List-Rest`. append_difference_lists(List_1, Rest_1, List_2, Rest_2, List, Rest) :- List_1 = List, Rest_1 = List_2, Rest_2 = Rest. I can barely look at this abomination, but anyway: unify the first list with the result list, stuff the second list in the rest of the first list, and unify the second rest with the rest of the result. If you move the unifications to the head and use `List-Rest` instead of `List, Rest` you end up with `append3/3`. In practice, you rarely need difference lists directly. But they are used a lot so it doesn't hurt understanding them. 
There are like a hundred questions just like this with answers on stack overflow. Look around. And be more specific than "don't work properly."
It works for me. Here is some advice: if you want help, write down what you expect to happen and what actually happens. Show exactly how you run the program to get the unexpected results. Bonus points if you show what else you tried and how it "dont work".
Thought this would be of interest to people interested in Prolog and logic programming in general. He demonstrates an interesting way to model the mechanics of Datalog as the continual application of a function until it reaches a fixed point, that is when the result stops changing.
Thanks. I hope to get round to viewing it later. 
Does it look like this: ?- findall(X, between(1, 100, X), Xs). Xs = [1, 2, 3, 4, 5, 6, 7, 8, 9|...]. If not you really have to paste in here your code and what you see. It is pure guessing work with your current description.
If it is this, /u/redInTheHat, it can be changed by setting the `answer_write_options` flag, by the way: ?- current_prolog_flag(answer_write_options, X). X = [quoted(true), portray(true), max_depth(10), spacing(next_argument)]. ?- findall(X, between(1, 100, X), Xs). Xs = [1, 2, 3, 4, 5, 6, 7, 8, 9|...]. ?- set_prolog_flag(answer_write_options, [quoted(true), portray(true), spacing(next_argument)]). true. ?- findall(X, between(1, 100, X), Xs). Xs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]. ?- 
Thanks, but it's not that. I'll post the parts of my code later today.
Try a different prolog- Yap, Ciao, Strawberry, whatever. If they behave exactly the same then at least you know it’s likely to be intended behaviour. 
Can you show how you tested `qsave_program`? One problem I see is that you are making assumptions about how the terms are represented in memory, and you would like to serialize _your assumption_. Keep in mind you can always re-write the term as a table, so that you completely control the representation, then serialize this. I will try to show some code a bit later today.
So...... Where's your code?
It magically fixed itself. I have no idea what the issue was. Thanks :)
**Hash array mapped trie** A hash array mapped trie (HAMT) is an implementation of an associative array that combines the characteristics of a hash table and an array mapped trie. It is a refined version of the more general notion of a hash tree. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/prolog/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Neat! Looks like write_term's cycles(true) option: http://www.swi-prolog.org/pldoc/doc_for?object=write_term/2 If only there was a way to write all parts of a term that way! Making the sharing semantics explicit definitely makes sense. We could probably even define a predicate that transforms implicitly-sharing datatypes into explicitly-sharing datatypes...
&gt; Somebody should write a postprocessing rule to add green cuts when clauses are mutually exclusive. I suspect we might be getting into Halting problem territory here. Anyway, the problem with choice points that hang around is the overhead they create. I have profiled programs and even cutting away a choice point immediately is more expensive than not creating it at all. But of course the only way to know for sure is to measure your own program with the implementation of your own choice. For search trees, you can reorder arguments (so that the tree is the first argument) and use `compare/3`, then switch on the order. Or just use `( If -&gt; Then ; Else )`. I suggest you try different approaches and report the results. But I would be super interested to see if you can write this green-cut post-processing rule you talk about.
It really annoys me how you keep on replying to my comments and then repeat a point I made, but make it sound like you just came up with it yourself.
Hmm, maybe I am starting to understand what you are after. Is it possible that you don't need saved states, but simply `write_canonical` and `read_term`? The trick seems to be to leave actual logical variables inside the term that you serialize. Here is the content of the file: $ cat serialized -([a,b|A],A). And then: ?- setup_call_cleanup(open(serialized, read, In), read_term(In, T, []), close(In)), T = X-Y, Y = [c, d]. In = &lt;stream&gt;(0x55617851b870), T = [a, b, c, d]-[c, d], X = [a, b, c, d], Y = [c, d]. In other words, you can have "references" instead of copies, but you need to use logical variables for those. As long as you use the same variable name, you get what you are after, it seems to me. The good thing is that you don't even need a saved state, just a plain-text representation of the term. You can produce this using `write_canonical(Term)` or `format("~k", [Term])`. Does that help at all?
Sorry, the formatting for my code blocks was all messed up. Hopefully they make more sense now. I want to serialize the data just in the general sense of having some to dump in a file and read back. The goal is to persist part of my program's state in between runs -- basically, a simple key-value store that maintains structure sharing between terms. To be clear, I don't doubt that unification copies terms by reference / doesn't "deep copy". That assumption is necessary for what I'm trying to do but not sufficient. :) The first code block shows that the dynamic databse doesn't preserve referential equality among terms it contains -- presumably there's a copy at some point. Maybe this is just the semantics of predicate calls. In the second code block I was looking for some way to serialize a set of terms in qsave_program that preserved referential equality. So, before qsave_program is called, it's true that `same_term(B, A)`; but when it's loaded with `swipl -x` that's no longer true. I'm not particularly commited to qsave_program; it just seemed like there might be a way to make it do what I wanted. I think that table representation is basically what I would want the serialization to be - sorry for missing that in your first comment. We would still want the nice declarative tree interface at runtime, so the challenge is to transition between those representations efficiently.
Did you see [the other comment](https://www.reddit.com/r/prolog/comments/9xiyg1/serializing_persistent_data_structures/e9yjqpi/)? I suspect what you actually need is just term writing and reading.
Yeah, saved states might be too much. I'm looking to serialize ground terms with structure-sharing -- that is, the data within the terms is important -- so this doesn't get all the way there iiuc. I think it does point to interesting alternative ways to represent the table data structure, though-- maybe even as a predicate: data([a,b|A]-A) :- A=[c,d]. Very prolog-y I feel! I mention this in the other comment, but the question is how to convert between representations. I think this would involve either looking up each subterm in a hash set, or annotating the data somehow. The alternative would be to store an append-only list of operations, which load by being applied. 
Thanks for the details - I hadn't thought of the helper predicate approach. For the green cut processing rule, I was thinking of just looking at a few sets of predicates manually listed as mutually exclusive, which seems like it would cover a lot of use cases. Though a more general static analysis / transformation tool would be really cool. I don't have any kind of implementation though. 
You have a syntax error but aren’t showing your code. Not much we can do to help without the code, bud.
I guess my question is more along the lines of why can't I do: `?- get0(C).` `test` `C = 116` `?- get0(C).` without getting the same error when "calling" the second get0. This happens in the shell. 
The distance between two lists would be the sum of all distances between corresponding elements. The distance between elements `X` and `Y` could be `abs(X - Y)`, for example, but think about whether it makes sense.
Yeah. Exactly that. 
If you are reading one character and then the rest of the input (up until you pressed "Enter") seems to just wait there, then somehow breaks stuff. If you only read one character with `get0` it works: ?- get0(C). |: a C = 97. ?- get0(C). |: b C = 98. I would suggest you don't use `get0/1` at all.
It has to be get0/1 BUT I have it working in the “file” of the assignment. The code just doesn’t work in the shell, which I’m guessing there’s a good reason. Either way thanks eh. 
The problem is the residual input. When you enter "test\n", get0(C) unifies C with the code for t, 116, but then the "est\n" is sitting on standard input waiting to be read by Prolog. Then you enter `get0(C).` again, but what Prolog sees is this: est get0(C). This is a syntax error. :)
I did miss what you had said. But thanks for digging in, a very interesting bit of information above about the unpredictability of Prolog doing deep copies.
By the way, you should generally use the ISO Prolog equivalent `get_code/1` instead.
I don't think you can have ground terms with structure sharing _directly_, but I guess you already figured this out. You'd have to normalize them as discussed above. But I kinda wonder how useful this is in practice. The whole idea behind backtracking is that Prolog takes care of what I _think_ you are after. In a functional language, you have immutable data. In Prolog, while you still have immutable data, there is more. First, you can have "logical variables" which only become immutable _after_ they are ground. But in addition each invocation of a predicate has its own variables, so even though they are immutable, they can and do change between invocations. If you take a classic algorithm like finding a path in a network: if you want to avoid cycles, you need to keep your "visited nodes" and check against them. In such an algorithm, in Prolog, if the current path turns out not to bring you to your goal, on backtracking, the structure that holds the visited nodes also backtracks so that _you_ (the programmer) don't have to take care of this manually. To demonstrate, I picked this [generic "path" implementation from the internets](https://stackoverflow.com/q/30328433), made a graph that would require backtracking, and committed a mortal sin by adding a print statement in the middle of it (to make it easier to visualize). :- meta_predicate path(2,?,?,?). :- meta_predicate path(2,?,?,?,+). path(R_2, [X0|Ys], X0,X) :- path(R_2, Ys, X0,X, [X0]). path(_R_2, [], X,X, _). path(R_2, [X1|Ys], X0,X, Xs) :- format("Visited: ~w~n", [Xs]), call(R_2, X0,X1), non_member(X1, Xs), path(R_2, Ys, X1,X, [X1|Xs]). non_member(_E, []). non_member(E, [X|Xs]) :- dif(E,X), non_member(E, Xs). edge(a, b). edge(b, a). edge(b, d). edge(d, e). edge(b, c). edge(c, f). If you try to find the path from `a` to `f` you will see the list of visited nodes backtracking: ?- path(edge, Path, a, f). Visited: [a] Visited: [b,a] Visited: [d,b,a] Visited: [e,d,b,a] % &lt;-- dead end Visited: [c,b,a] % &lt;-- backtracking! Path = [a, b, c, f] Now the really interesting question is how the implementation deals with backtracking data structures, and how it garbage collects them, too.
The state of Prolog instruction in particular is pretty sad. I think it shows up mostly in language survey classes ("principles of programming languages") and usually the underlying message is "look at this weird shit from the olden days." Such a perspective explains why Prolog assignments are so samey and include so many bizarre requirements ("you must use recursion" is another popular one). The professors don't know the material they're teaching and don't care.
I think you need to put TOld is T-1 before the recursive call otherwise you have a forever loop
`tickVal1(T, V) :-` `tickVal(T, V),` `!.` &amp;#x200B; `tickVal1(T, V) :-` `T0 is T - 1,` `tickVal1(T0, V),` `!.` &amp;#x200B; First, the predicate has to be of a different name than facts. Otherwise there is an infinite loop. Second, cut is needed to make sure only one value is correct.
tried that too, but it's still stuck in a loop
Right because there's no stop condition.
Thanks! that seems to do it :)
I think the other solution will loop if you pass a `T` that's less than the smallest tick. You could guard against it manually (i.e. `0 =&lt; T`) or dynamically check for the smallest tick. I would write something like this: tick_val_raw(0, 0). tick_val_raw(3, 4). tick_val_raw(5, 6). tick_val_raw(10, 3). tick_val(T, V) :- once(tick_val_raw(Min, _)), once(tick_val(T, V, Min)). tick_val(T, V, Min) :- Min =&lt; T, tick_val_raw(T, V). tick_val(T, V, Min) :- Min &lt; T, T0 is T - 1, tick_val(T0, V, Min). Some additional notes. 1. This version encapsulates all of the non-determinism into a helper predicate (`tick_val/3`), which allows it to use `once/1` instead of `!/0`. Most purist consider this better. 2. This version makes the recursive call into a tail call. This could reduce memory usage because of tail call elimination. 3. The naming convention in Prolog is `snake_case` for atoms/functors/predicates and `CamelCase` for variable names.
I think you're overthinking this. Your true predicate is unnecessary; that's what Prolog *does*. If I type `X` and it succeed, then it succeeds. I don't need to have some other predicate that unifies when `X` does (but of course you *could*: `true(X) :- X`). Your false predicate **is** `not`. If you're asking how do you write `not`, you could do it like this (there may be an easier way): ``` not(X) :- X -&gt; false; true. ``` Finally, for "material equivalence" just think about the cases where you want your predicate to succeed: either `X` and `Y` both succeed, or they both don't: ``` materially_equivalent(X, Y) :- (X, Y); % Both succeed (not(X), not(Y)). % Both fail ``` That being said, your encoding of the Liar Paradox probably doesn't produce a result like what you're looking for (it'll just throw an error when it tries to unify X). To see an encoding in a programming language, see [this](https://www.cs.unm.edu/~stelleg/liar.html).
**This fails indicating an infinitely recursive structure:** unify\_with\_occurs\_check(not\_true(LP), LP). 
I don't think so because an infinite amount of false statements would need to be explicitly defined. 
You've posted a couple things about proving things with Prolog. I would strongly suggest you take a look at a system that's meant explicitly for proving theorems, such as [Coq](https://coq.inria.fr/) or [Isabelle](http://isabelle.in.tum.de/)? I think that will serve you better. That being said, yes, you can determine whether something is unsatisfiable (provably false) in Prolog. In your example, this is easier, because Prolog (SWI-Prolog at least, and some others) has the [clpfd](http://www.swi-prolog.org/man/clpfd.html) library, which is meant for logically working with integers. If you want to see if it's possible for `A + B = C`, or some similar equation, then you can write `A + B #= C`. If it tells you `false` (which it will for `2 + 3 #= 17`), that means it's unsatisfiable. If you use variables, then it becomes a little more difficult, because CLP(FD) only really works on finite domains (that's what the FD stands for). Using the `label/1` predicate, you can do a complete search of the domains you've specified. Again, if it fails to find a solution like that, it means there really is no solution (in the domain you specified). I don't know what an easy way to do this more generally is, but you could always encode your problem as a SAT instance, then check every single possibility.
What I am asking is: Whether or not there is a way to get Prolog to report when it derives an explicit contradiction upon a query of its facts and rules? 
Prolog doesn't distinguish between "provably false" and "not provably true"; they are the same. Prolog operates according to the closed-world assumption. Notably, it's not really possible to state a negative in Prolog. You establish axioms and inference rules, but both of those are making statements about what is true. It's hard to produce a contradiction from a set of things that are all true. Finally, you asked about contradiction, but your example (2 + 3 = 17) isn't a contradiction; it's merely a false statement. If I'm not mistaken, all contradictions can be boiled down to the form "S ∧ ¬S", and I'm not seeing how to cast your example into that form.
I am looking for something like this: All cats are animals. All animals are living things. All dogs are animals. Dogs are not living things. Prolog Error! Attempt to add a rule that contradicts existing facts and rules, last rule rejected. &amp;#x200B;
There's essentially no way, in Prolog, to say "dogs are not living things". The closest you could come is to expand the `living` relation to include truthiness/falsiness, like so: animal(X) :- cat(X). animal(X) :- dog(X). living(X, t) :- animal(X). living(X, f) :- dog(X). This isn't quite the same as saying that "dogs are not living things". Again, you can't really state a falsehood in Prolog. It's more like saying "the liveness of dogs is deemed to be `f`". But `f` isn't anything special; it's just an atom. I could have just as easily used `0` or `no` or even `false`. Prolog would treat them all the same. Then, you can detect the contradiction yourself by finding *all* distinct solutions for `living(dog, X)` (possibly using [`setof/3`](http://www.swi-prolog.org/pldoc/man?predicate=setof/3)). You'll find that `X` gets bound to both `t` and `f`, and you could choose to interpret that as a contradiction.
I really need a system just like Prolog, yet it must not accept contradictory Facts and Rules. 
Check out chapter 8 of simply logical for some discussions around similar issues: https://book.simply-logical.space/part_iii.html#reasoning_with_incomplete_information 
None of those statements are facts, because a fact, like “rainy(monday).”, has no antecedents, but all your rules have antecedents (terms on the right hand side of :-, which is a stylized left arrow readable as “only if” or “implied by”.) You said: - if true can be derived, then so can animal(dog). - if animal(X) can be derived, then so can livingthing(X). - if false can be derived, then so can livingthing(dog). You ask: - can we derive livingthing(dog)? And swipl says: - give true, we can - given false, we also can Your true and false are just atoms. They may as well be harry and sally. As such, they’ve none of the logical semantics you want. Remember that you’re writing Horn clauses. Even if those atoms did have those logical semantics, the statement that false implies livingthing(dog) isn’t exactly the most useful - you’d expect to have a rule that false implies anything and everything, after all!
I think you are misinterpreting what is happening here. It doesn't "change to false." Prolog has reported "true" because your goal has succeeded, it is now asking you if you want another solution. When you click "next", that is what you are saying: I want another solution. The "false" you get after that is Prolog reporting that it could not find another solution.
There is no real difference between `animal(cat) :- true.` and `animal(cat).`. In fact, if you specify `animal(cat).` and then use `clause/2` to examine it, Prolog will give you `true` for the body as if you had specified it the other way.
Thanks. Of course I’d forget zero-arity predicates. 🤦🏽‍♀️ (And SWIPL has zero-arity compound terms these days, too…) It’s still that true and false are not logical propositions but rather claims that always succeed or always fail. The core point that implication in Prolog flows the other direction than OP seems to think remains: this :- true is not “if this, then true”, but “this, only if true”.
 is(cat, animal, true). is(dog, animal, true). is(X, alive, true) := is(X, animal, true). is(dog, alive, false). ?- is(dog, alive, X). X = true . ?- is(X, Y, true), is(X, Y, false). X = dog, Y = alive ; But seriously, learn Coq.
&gt; dogs are not living things notLivingThing(dog).
That notion of "not" isn't in any way visible to the Prolog runtime system. In particular, it wouldn't help OP's goal of finding contradictions.
 not(livingThing(dog)). ?- not(X), X. X = livingthing(dog). Also, I just found this beaut: ?- X. % ... 1,000,000 ............ 10,000,000 years later % % &gt;&gt; 42 &lt;&lt; (last release gives the question) ?- version(). Welcome to SWI-Prolog (Multi-threaded, 64 bits, Version 7.2.3) 
"2 +3 = 17" contradicts "2 + 3 = 5".
Does it, though? Again, a logical contradiction is of the form "S ∧ ¬S" (S must be both true and false simultaneously). I don't see that here. I think you're coming at it from the point of view that `+` is a function and that mathematical functions must have exactly one output for each distinct input. So `+(2, 3)` can't be both `5` and `17` simultaneously. So in a sense, the property that we're trying to prove is "`+(2, 3)` is unique", which is true by the definition of all functions but is false by the definition of *this* function. The two statements don't contradict each other; the statements taken together contradict the definition of a function. Here's the problem, though. Prolog doesn't deal with functions. Prolog deals with relations, which are generalized functions. Relations don't distinguish "inputs" from "outputs"; relations just relate values to each other. So relations don't have the same restriction that functions have. So, this notion of "functional contradiction" doesn't really show up in Prolog. I can define: foo(2, 3, 17). foo(2, 3, 5). I can just as easily define: +(2, 3, 17). +(2, 3, 5). Prolog doesn't care; it treats them both the same.
Eh, be careful with that. Typically, SWI-Prolog throws an error when you try to modify a built-in predicate. If you had instead tried this: \+(livingThing(dog)). % `\+` being the preferred way to say `not` ... you would get an error. I'm a little surprised that you don't get an error from modifying `not`. All I'll say is that this is tantamount to monkeypatching in Ruby or JavaScript. The built-in `not/1` has specific meaning. By modifying the built-in like this, you're giving it different meaning. That could easily break other predicates in a way that would be hard to detect. This is not how it's meant to work; you're doing it at your own risk.
If it had the Peano axioms encoded it would not treat them the same. 
Only if Prolog also modeled functions, which it does not. It treats everything as a relation. As others have said, perhaps Prolog is not the right tool for what you're trying to do. Prolog is not a general-purpose theorem prover. It's much more focused than that. 
The question, as you have stated it, is a bit misleading. _Because_ `2 + 3 = 5` and `5 != 17` is indeed provably false that `2 + 3 = 17`. So really, what does "contradiction" mean when you say that you want Prolog to "detect a contradiction"? I will try to give a couple of examples and maybe you can explain what you mean. If we have a geographical database, with countries and cities and town and so on. Now, if we ask, "Is Mistery City the capital of Wonderland?" I can think of several ways to answer "No" (or `false`) to that question. 1. We cannot find a record of a country called Wonderland with a capital Mistery City; 2. We can find a record of a country called Wonderland with a capital Wondertown, and we know that a country has exactly one capital. 3. We cannot find a record of a city called Mistery City, and we know that any capital would have to be also recorder as a city. The list goes on. Keep in mind that all of these ways to answer the question already presume that the system provides some way to answer that kind of question. In each case, the end result could be interpreted as "No, Mystery City is not the capital of Wonderland". So on base of this example, what exactly do you want "contradiction" to mean? Do you want it to mean that Mistery City is the capital of another country, or that it is not a capital, or that it doesn't exist?
**Can Coq spot the infinite recursion of this?** not\_true(X) :- X -false; true. materially\_equivalent(X, Y) :- (X, Y); % Both succeed (not(X), not(Y)). % Both fail **Liar Paradox formalized as Prolog:** materially\_equivalent(not(true(LP)), LP). **This fails indicating an infinitely recursive structure:** ?- unify\_with\_occurs\_check(not\_true(LP), LP). **Therefore this predicate cannot be evaluated:** ?- materially\_equivalent(not\_true(LP), LP). &amp;#x200B;
The assertion that: [Mystery city is the capital of Wonderland] is contradicted by the facts that [The capital of Wonderland is Mystery town] AND [Wonderland has only one capital]. Provably false rather than unprovably true. 
I think you're a little mixed-up about why `unify_with_occurs_check/2` is failing for you. At no point is that going to actually _call_ your predicate `not_true/1`. What you're actually doing is trying to construct the structure `not_true(not_true(not_true(not_true(...)`. If you do this with ordinary unification, you can see what it is trying to do: ?- not_true(X) = X. X = not_true(X). This is a recursive _data structure_, not a recursive _computation_. And all `unify_with_occurs_check/2` does is exactly what `=/2` does, except first checking that the result would not be recursive. There would be nothing wrong with `materially_equivalent/2` (although you should use ISO `\+` instead of non-ISO `not/1`). For what feels like the fourth or seventeenth time, I feel it would be worth gently reminding you that Prolog is really a programming language with backtracking and unification and thus, some logical flavor, but it is not a theorem prover and I would not consider it a worthy companion for a deep dive into mathematical logic. You should find another tool for the stuff you want to investigate.
Specifically section 8.4: nounphrase([Article, Noun | End], End) :- article(Article), noun(Noun). I understand the part after the :- I just don’t understand the first, particularly the pipe. It would also be extremely helpful to have some example input and a rundown. I really don’t understand prolog and have to use it for a NLP assignment. Thanks!
[] denotes a list. The pipe is the distinction for the rest of the list. [Head | Tail] and so on.
That’s what I was assuming. So what’s the End variable represent?
A list containing stuff besides Article and Noun.
For fun, in Prolog, type this: ?- [Article,Noun|End] = [one,two,three,four,five,six]. and see what Prolog tells you. :)
That actually kind of helped. So, assuming the list you’re setting there is a sentence ([the,man,likes,the,dog]) we get Article = the Noun = man End = [likes, the, dog] So, in the noun phrase example, where we have nounphrase([Article, Noun | End], End) How would this translate? I tried [Article, Noun | End] = [one,two,three,four,five]. and it returned false.
Not sure why you parenthesized it, but Prolog should definitely have responded affirmatively with: ?- [Article,Noun|End] = [one,two,three,four,five,six]. Article = one, Noun = two, End = [three, four, five, six]. I would strongly encourage you to do this kind of experimentation at the command line, as it will only help you develop intuition for what Prolog is going to do. The point here is that Prolog will let you peel any number of items off the front of a list and then refer to the remainder of the list using this syntax. [X,Y,Z|Rest] will match any list with 3 or more items, unifying X, Y, and Z with the first three elements and Rest with whatever remains or the empty list. But there's a difference between reading that and really feeling it.
In my example, nounphrase is a functor that returns true if the input contains a nounphrase. I was just testing what would happen if I entered ([Article, Noun | End], End) = [the,man,likes,the,dog]. I wanted to see how prolog would assign things, but it returned false. Also, I really appreciate the feedback and advice! It’s very useful and it’s definitely helping.
Try this: ?- ([Article, Noun | End], End) = ([the,man,likes,the,dog], X).
Aight, I’m getting Article = the End = X, X = [likes,the,dog] Noun = man Can you explain why it’s binding like that?
Your query was basically (to Prolog): (X,Y) = [...] `(X,Y)` isn't going to unify with any list because the principal functors are not the same. Imagine if you had instead put: foo(X) = bar(X). This is also going to fail to unify, because the principal functor `foo` isn't the same as `bar`. In other words, a pair of items on one side isn't going to unify with any list, even a list of two items, on the other side.
That makes sense lol So, with natural language processing specifically, the second End variable in the functor allows us to work with the rest of the sentence, right? So for a simple sentence, we might have sentence = [Nounphrase, Verbphrase] :- nounphrase(Nounphrase), verbphrase(Verbphrase). Where nounphrase([Article, Noun | End], End) :- article(Article), noun(Noun), verbphrase(End). verbphrase([Verb | End], End) :- verb(Verb). So in the sentence, we process the nounphrase, then past the rest of the sentence to verbphrase and test the validity there? Then if both return true, the sentence is a valid sentence.
Yes, exactly! Well, I think if you have verbphrase in sentence, you're probably not going to have it in nounphrase as well. This will actually get a lot simpler when you start dealing with DCGs, since this example is going to become something like: sentence --&gt; nounphrase, verbphrase. nounphrase --&gt; article, noun. verbphrase --&gt; verb. article --&gt; [the]. article --&gt; [a]. noun --&gt; [cat]. verb --&gt; [sits]. ?- phrase(sentence, [the,cat,sits]). true The way this works, you can see by using `listing`: ?- listing([verb,noun,verbphrase,nounphrase,sentence,article]). verb([sits|A], A). noun([cat|A], A). verbphrase(A, B) :- verb(A, B). nounphrase(A, C) :- article(A, B), noun(B, C). sentence(A, C) :- nounphrase(A, B), verbphrase(B, C). article([the|A], A). article([a|A], A). When you enter it in DCG notation, Prolog actually "desugars" it to this notation, and you see it is always taking something from the front of the list and then passing the tail along to the next thing. It's exactly like the kind of code you had before, where you take something off the front, and pass the remainder along. `phrase/2` winds up actually just making sure that the tail becomes the empty list and the whole input is consumed. Pretty cool, yeah?
I now realize there are in fact 2 predicates, rara/2 and rara/3. 
I'm guessing that this is an assignment. &gt; I am told we can use the pattern: predicate(X,Y), not ( predicate1(X), predicate2(Y), X &gt; Y ). I assume that was this: predicate(X, Y), not(predicate1(X), predicate2(Y), X &gt; Y). (i.e. it was all one conjunction) I'm not aware of any `not/3` built-in to Prolog (though I'm really only familiar with SWI-Prolog), so that wouldn't be valid out-of-the-box. Maybe you're using a separate library that defines it? --- Independent of that, consider this: unlike many programming languages, Prolog typically finds multiple solutions. When you run a query like `?- member(A, [1, 2, 3]).`, you will get three successive results in which `A` is bound to one of the elements of the list. If there was some mechanism by which you could inspect the previous solutions, you could easily find the cheapest book. But alas, AFAIK, there's no way to do that. Having said that, there is an even better solution. It's possible to run a Prolog query and collect all the results into a list. You can then process that data however you want. It would be easy to write a predicate to find the cheapest book from a list of books. Consider checking out [`findall/3`](http://www.swi-prolog.org/pldoc/doc_for?object=findall/3). I'm not sure how that relates to the suggestion given in the assignment, mostly because I'm not sure what it was trying to say.
Yes it is just different syntax we use to make more sense. Thanks for your suggestion but unfortunately for our exams we have to use negation to find the answer, I know the answer just not sure how it works. Thanks
Very, very cool! Thank you so much for your help, fam. We actually got done with our project early thanks to you :)
"The cheapest `ListPrice` for a `Title` is such that `hasBook(_, _, Title, ListPrice)` and there is no `OtherListPrice` such that `hasBook(_, _, Title, OtherListPrice)` and `OtherListPrice &lt; ListPrice`." In code: title_cheapest(Title, ListPrice) :- hasBook(_, _, Title, ListPrice), not((hasBook(_, _, Title, OtherListPrice), OtherListPrice &lt; ListPrice)). Try the query `?- title_cheapest(matrix, ListPrice).` You need the double parenthesis inside `not/1` unless it is declared as an operator (which it isn't by default in SWI-Prolog) and you leave a space. But the best thing to do is to use instead the ISO Prolog standard `(\+)/1` operator, which means exactly the same thing, and write \+ (hasBook(_, _, Title, OtherListPrice), OtherListPrice &lt; ListPrice). You can read `\+` as "not provable", which emphasizes that it's not the same as the logical "not".
The idea with this problem is to make you think of a definition of max like "the maximum of a list is an item such that no element of the list is greater than it." Which you can do in Prolog sort of like this: mymax(L, Max) :- member(Max, L), \+ (member(E, L), E &gt; Max). I think this is probably what was meant, whether it made it out of the professor or into the student properly is another matter. This is not efficient, but it has a certain appeal.
Very glad I could help!
It is of course not efficient, if your example. You have a list already. The idea is that you don't have a list and only use the database. I would first measure the performance in a particular use case before making claims about efficiency.
Yeah, that assumes that you already have the books in a list. I was running under the assumption that the data wasn't already in a list - that they would use Prolog rules to generate the data. Your solution is similar to /u/mycl's solution in that they will both end up with quadratic execution time. That style of solution hadn't occurred to me. 
I am having trouble imagining that there could be enough magic in Prolog to turn this from quadratic to something better just by using the database. Enlighten me.
Whether or not it is in a list seems to be a sticking point for you and u/wellmeaningtroll but I don't think it matters really. It's a classic generate-and-test, except your test winds up having to generate all the other options. Whether it's generating them out of a list or the database would only matter in a big-O sense if Prolog is going to optimize the database search somehow, which I don't think happens. Prolog certainly isn't supposed to index except on the first argument by default, and range indexes are not so cheap that I would expect it is doing that whenever it finds a numeric value.
No, I just meant that your specific formulation - using `member` - requires that the data is already in a list. If it's not in a list - if you need to generate it - you'd have to start with something like `findall`. /u/mycl's solution directly generates the solutions as it goes. But both your solutions are similar. I just find that solution style to be interesting. You're right, I don't entirely know how inefficient it will be, but it's *likely* to be inefficient - it relies on the runtime to be cleverer than the algorithm (or just hoping that you don't need to process large quantities of data). Still, it's certainly much more terse than a version using `findall` and then walking the list with an accumulator, or even a version that would use something like `min_member`.
I really intended it to illustrate the idea more than be the specific solution.
I don't think I can enlighten you. I can only say that this style is easier to write correctly for more complex queries and can be good enough for the particular use case. For example, I was going through the "Advent of Code" problems and for [day 3](https://adventofcode.com/2018/day/3), It took me about 20 min to write the following solution (so definitely not fast enough to get on the score board ;-) $ cat slice.pl :- use_module(library(pure_input)). :- use_module(library(dcg/basics)). :- use_module(library(pairs)). solve(Filename, Count-ID) :- phrase_from_file(claims(Claims), Filename), claims_to_db(Claims), more_than_one_claim_count(Count), non_overlapping_id(ID). more_than_one_claim_count(N) :- setof(X-Y, overlapping_inch(X, Y), XYs), length(XYs, N). overlapping_inch(X, Y) :- square_inch(A, X, Y), square_inch(B, X, Y), A \== B. non_overlapping_id(ID) :- bagof(X-Y, square_inch(ID, X, Y), XYs), \+ ( member(X-Y, XYs), square_inch(Other, X, Y), ID \== Other ). claims_to_db(Claims) :- retractall(square_inch(_,_,_)), forall(member(Claim, Claims), claim_to_db(Claim)). claim_to_db(claim(Id, Left, Top, Wide, Tall)) :- Right is Left + Wide - 1, Bottom is Top + Tall - 1, forall( ( between(Left, Right, X), between(Top, Bottom, Y) ), assertz(square_inch(Id, X, Y))). claims([claim(Id, Left, Top, Wide, Tall)|Claims]) --&gt; "#", integer(Id), " @ ", integer(Left), ",", integer(Top), ": ", integer(Wide), "x", integer(Tall), "\n", !, claims(Claims). claims([]) --&gt; []. It took me about 10 min to read the problem and write the parsing, another 5 minutes thinking how to do it, and another 5 min to write/debug the two queries, `more_than_one_claim_count` and `non_overlapping_id`. Keep in mind that you don't know the second part of the puzzle until you answered the first question correctly. (It takes less than 2 sec on my computer to solve both questions).
The dropbox link now returns 404, and MIT link not up to date. :( I missed out, looks like a great book. 
That is a shame. If it doesn't get fixed soon, I'll send them a mail asking what's up. 
You need to explain how two three-value sets compare and what is considered a higher value. 
Yep, that's what I've been banging my head against the keyboard trying to do. I've figured out how to do this /w 2 variables, ie: descendents(A,B):-parentRelations(A,C),parentRelations(C,B)...but with 3 variables I'm struggling.
How do you solve this kind of puzzle? Forget Prolog, just explain it to me.
It’s just like sudoku except instead of having Numbers on the inside you have them outside. The numbers outside influence either the 1st 3 cells on the rows or collumns they are next to (depending where the number or list of numbers is Next to)
Yes, this is not what you'd expect but that's how it is. Without going too deep into it, the `;` means "there could be more solutions; do you want me to keep looking?". It does not mean "There are more solutions". With this in mind, it now comes down to how good is your Prolog at knowing *for certain* that there are no more solutions. GNU-Prolog does not know it (I can reproduce it): $ gprolog GNU Prolog 1.4.5 (64 bits) Compiled Jul 15 2018, 03:47:56 with gcc By Daniel Diaz Copyright (C) 1999-2018 Daniel Diaz | ?- [user]. compiling user for byte code... parent(hank,ben). parent(hank,denise). parent(irene,ben). parent(irene,denise). parent(alice,carl). parent(ben,carl). parent(denise,frank). parent(denise,gary). parent(earl,frank). parent(earl,gary). user compiled, 10 lines read - 1024 bytes written, 5393 ms (8 ms) yes | ?- parent(irene, denise). yes | ?- parent(irene, ben). true ? ; no SWI-Prolog does know it (here is the same with SWI-Prolog): $ swipl Welcome to SWI-Prolog (threaded, 64 bits, version 7.7.25-2-g6f1f42ad3) SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software. Please run ?- license. for legal details. For online help and background, visit http://www.swi-prolog.org For built-in help, use ?- help(Topic). or ?- apropos(Word). ?- [user]. |: parent(hank,ben). |: parent(hank,denise). |: parent(irene,ben). |: parent(irene,denise). |: parent(alice,carl). |: parent(ben,carl). |: parent(denise,frank). |: parent(denise,gary). |: parent(earl,frank). |: parent(earl,gary). |: ^D% user://1 compiled 0.01 sec, 10 clauses true. ?- parent(irene, denise). true. ?- parent(irene, ben). true. If you want to know in detail how exactly a Prolog implementation deals with such situations, you'd have to dig quite deep. Altogether, choice points that obviously should not be there are a huge pain in the ass when writing Prolog code.
&gt; as i managed to program the normal one in one afternoon This was quite fast, you are good. On the other hand, there are plenty of examples out there on how to do it. Did you solve it [like this](https://swish.swi-prolog.org/example/clpfd_sudoku.pl)? Or did you not use a constraint library? How do you want to solve this one, using clpfd or without?
I used a lot more constraints but yeh something like that. I wanted to use clpfd yes
So how did you approach the problem when you were doing the normal sudoku? Can you show how far you get with this approach? Where do you get stuck? Because at the moment the way you have asked the question sound a bit like "hurr durr here is puzzle solve plz"
On the normal Sudoku i created a 9x9 matrix as the input, gave each velo a name from A1 to I9, restricted the values between 1 and 9 and made an all distinct for each line, each row and each ‘group of nine squares’ i showld have done that iterativly but i did it this way 
You did well. What _in particular_ stops you from solving this in a similar way?
I’m not getting how to pass the structure i created with the inputs throw the problem. Like now to create a predicate that knows wich cells to read in the matrix and puting them in a count function 
This makes no sense at all. To me it looks like you just need to take the "outside" numbers and set a couple of additional constraints based on these. If you managed to solve the normal sudoku, you'd only have to adjust it a bit to start with these additional constraints instead of filling in the squares.
The extra choice point there is caused by an implementation detail in your Prolog implementation. In general, extra choice points seem to cause beginners a great deal of concern but frankly it's best to ignore them and get on with your life, since if you go trying to remove them with cuts you're liable to make mistakes that make your predicates more brittle. This isn't a case where you can really do that, so it's good to learn the lesson here.
The reason I asked is because it can often be helpful to write down what your program needs to do _in words_ and then try to translate that into Prolog. Remember to choose a data structure that makes _solving_ the problem easier, you can always translate a more convenient for input or output representation into an easier to use one, but trying to solve the problem with a bad inner representation will be a lot harder.
Thank you for your input. If you have time can you take a look at my solution? I had problems with selecting the cells for the counts so i ended up making a file with all the possible cases. [https://drive.google.com/drive/folders/1KVxxtYu4IzpkEx3nW4MUmGru7j8l3eUR?usp=sharing](https://drive.google.com/drive/folders/1KVxxtYu4IzpkEx3nW4MUmGru7j8l3eUR?usp=sharing)
Can't you just paste the code here? It cannot be that much....
Pretty cool, watched the whole thing. Also keen on exploring smalltalk now haha.
Well, your code doesn't make a lot of sense and it's hard to map it to program description. But I'll try... 1. `Length #=&lt; LenNew` what were you trying to achieve with this? 2. You probably want `Length` to be an out parameter (i.e. a variable that gets instantiated when you find a solution. You'd also need a way to pass the intermediate value. 3. You never use the first element of `PS`, this seems more like an oversight, is it? Below I'll write an example of calculating distance between nodes in a graph, this will probably not be the exact solution you are looking for, but hopefully will give you some hints as to go about what you want. %% Some arbitrary graph rel(a, b). rel(a, c). rel(a, d). rel(b, d). rel(d, c). %% This is how you could get the list of nodes you seem to use, but %% you don't really need it. graph_nodes(Nodes) :- findall([X, Y], rel(X, Y), Pairs), append(Pairs, UnsortedNodes), sort(UnsortedNodes, Nodes). %% This is how you could compute the distance distance(From, To, SoFar, Distance) :- rel(From, To), Distance is SoFar + 1. distance(From, To, SoFar, Distance) :- rel(From, Neighbor), DistanceFromNeighbor is SoFar + 1, distance(Neighbor, To, DistanceFromNeighbor, Distance). distance(From, To, Distance) :- distance(From, To, 0, Distance). %% Example usage: %% %% ?- graph_nodes(N). %% N = [a, b, c, d]. %% ?- true. %% ?- distance(a, b, N). %% N = 1 ; %% false. %% ?- distance(b, b, N). %% false. %% ?- distance(a, c, N). %% N = 1 ; %% N = 3 ; %% N = 2 ; %% false. %% ?- distance(b, c, N). %% N = 2 ; %% false.
Last line should be connectFromTo(Lz, Ly) &amp;#x200B; maybe?
Its either this or something of the same pattern. Did you notice a warning when you compiled? Moaning about a singleton variable? Singletons only make sense when they are ‘don’t care’ variables: i.e. you need there to be a variable there to pattern match but its value is irrelevant. In the connect case, it’s self-evident that you need to care about the value. Innit?! :)) 
Your original code had that warning. I'm not much of a Prolog guy but maybe there's a standard way to put in a don't care variable, like the underscore in Erlang.
You mention SQL. Have you considered how you might create a connectFromTo view given a connect table holding your facts? (You may need to investigate common table expressions and union all, if you haven’t wandered into them before.)
I got it working, but I still don't quite understand what it's doing. I tried tracing, but got a bunch of errors. I'm using SWI on Windows. Anyway, for future reference, here's the code that seems to do what I want. But how does it do it? I've read five or six tutorials on the topic, and it has yet to click. &amp;#x200B; \`\`\` connected(l1, l2). connected(l2, l3). connected(l2, l4). connected(l4, l5). &amp;#x200B; connectFromTo(Lx, Ly) :- connected(Lx, Ly). &amp;#x200B; connectFromTo(Lx, Ly) :- connected(Lx, Lz), connectFromTo(Lz, Ly). \`\`\`
Forget Prolog for a minute and think in terms of logic: Given those facts and rules, how would you prove (deduce) that connectFromTo(l1, l4) is true?
It might help to use variable names that actually represent what you are looking for. Instead of Lx use From and instead of Ly use To and instead of Lz use Inbetween. Now you have two rules: 1. Two nodes are connected if To is connected to From 2. Two nodes are connected if From is connected to an Inbetween node and the Inbetween node to connected to To. I think prolog code becomes a lot clearer when you talk in more natural language, unfortunately most tutorials and examples favour brevity over clarity. 
I think you're right--see my next comment.
Yes you can use an underscore or prefix a variable name with an underscore. 
As suggested, I changed my variables around, plus my rule name. My code is now: ``` connected(l1, l2). connected(l2, l3). connected(l2, l4). connected(l4, l5). pathExists(From, To) :- connected(From, To). pathExists(From, To) :- connected(From, Between), pathExists(Between, To). ``` And as I pondered the revised code... I think something fell into place in my mind. Please tell me I'm correct in what I'm about to say. The first rule in the recursion says that From and To must be connected, as defined in my facts. The second rule must also be true, but it calls the recursion. However, the base case of the recursion says that From and To must be connected. Thus, we use the InBetween variable. Eventually, the recursion resolves to the base case (the first implementation of pathExists). This gives us connected(From, InBetween), connected(InBetween, To). That being true, the rule must be true, namely pathExists(From, To). Basically, the base case lets the recursion resolve to a single rule, meaning that part of the rule is true. So long as the first part is also true, we have two trues, which make the whole thing true. Thus, path found! The recursion lets Prolog try various values for that second statement as many times as it needs to until it finds a true set of values. Right? Please say I'm right. If I got this far but still have things wrong, I'll be quite sad. :) 
That's one way of looking at it, in the case that you call path exists(l1, l5) then you need more than one recursive call which would resolve to: connected(l1, l2), connected (l2, l3), connected (l3, l4), connected (l4, l5). If you can see why this works you have discovered a useful tool to use! 
This is all correct but the point here is that we don’t want to ignore the warning- we want to learn from it (and fix the bug in the program :)). 
Yes, I believe I can see it. I should have said that during the process of resolving to the final connected() rule, each intermediate connected() rule is recorded. That's the key, giving a complete path to the answer. 
Your post ends with: &gt; Related to that, Are you missing some text at the bottom?
Oh, that's weird. I think I meant to delete that last bit, but didn't do so before posting. My mistake. 
Link is still broken, by the looks of it. Disappointing.
I haven't done this particular problem in prolog but know the puzzle. I think it would be useful to start with three things: 1. What does the start world look like 2. What does the end world look like 3. What are the constraints that need to be adhered to when moving from start to end. Once you have an idea of how the different parts of the world are going to be represented, then you can code and test the constraints individually to make it easier. 
Actually, that's precisely what I started with yesterday, so it's good to hear I began on the right track. The wall I then ran into is how to define the end goal. For instance, if I define &amp;#x200B; startLocation(chicken, l1). &amp;#x200B; and I later want to move the chicken, I need a new rule to say that moving to l2 is okay: &amp;#x200B; endLocation(chicken, l2). &amp;#x200B; Now, though, I have to figure out how to tell Prolog to move items. I can't simply ask whether the endLocation of the chicken is l2, because I already said it was. I clearly need a valid movement predicate, one that will try to swap the location. But how to do that I'm not sure of. I'm also not sure about how to tell Prolog that \*this\* configuration is the starting one, while \*that\* configuration is the goal and means it can stop. Okay, I know how to tell it to stop--test whether the ending configuration is true--but I don't see how that will fit. I'll quit yapping and post the code I have thus far. &amp;#x200B; \`\`\` /\*define the allowed groups of items, so we know which can and can't travel/be left together\*/ canBeGrouped(\[chicken\]). canBeGrouped(\[chicken, human\]). canBeGrouped(\[fox\]). canBeGrouped(\[fox, human\]). canBeGrouped(\[grain\]). canBeGrouped(\[grain, human\]). canBeGrouped(\[fox, grain, human\]). &amp;#x200B; /\*define which items are in l1 (the starting point), and which we want to be in l2 (the ending point) to signify success\*/ startLocation(\[chicken, fox, grain, human\], l1). endLocation(\[chicken, fox, grain, human\], l2). &amp;#x200B; /\*define whether we can move a given group\*/ swapItemsLocation(Items, Location) :- /\*is this group able to travel together?\*/ canBeGrouped(Items), \`\`\` &amp;#x200B; &amp;#x200B;
When working on Prolog, thinking about the problem has resemblance to solving it. &amp;#x200B; In this case you have this kind of a game and you want a strategy for winning it. You probably want a list of moves between some starting and ending position. Since there's only three things and they're on either side, you create a compound term that says where each thing is, eg. left, left, left. Then you write the acceptable situations between moves. Eg. the moves when nothing gets eaten. Then you describe the gameplay and it's there. &amp;#x200B; You can also represent chess, checkers, and such board games in such frame.
You are describing to Prolog what counts as a connected pair and how to find connected pairs. The first "connectFromTo" says that it treats pair as connected if it knows they are connected. The second "connectFromTo" says that a connected pair can be determined by taking an existing connected item, and find a connected pair with direction flipped. Basically you're describing propositions, and propositions correspond to types in other programming languages. Prolog clauses are describing types. Types are sets consisting of values that satisfy some constraint.
state representation relations between old states and new states predicates to match the final state
so I'll give you some code to ponder over but don't worry too much if you don't understand it just yet (because it uses lists). The first section is explicit and you can follow each line to see that each line will call the next until the final solution is reached. moved([one, two], [], []) :- moved([two], [one], []). moved([two], [one], []) :- moved([two], [], [one]). moved([two], [], [one]) :- moved([], [two], [one]). moved([], [two], [one]) :- moved([], [], [one, two]). moved([], [], [one, two]). test :- moved([one, two], [], []). The first argument represents the start state (the first bank of the river) The second argument represents the moving state (the boat) The third argument represents the end state (the other bank of the river). If you run 'test.' in the interpreter then it should give you 'true' Moving on, the next step is to make this generic so that we can move any number of items. movedg([H|T], [], Moved) :- movedg(T, [H], Moved). movedg([H|T], [Moving], Moved) :- movedg([H|T], [], [Moving|Moved]). movedg([], [Moving], Moved) :- movedg([], [], [Moving|Moved]). movedg([], [], _Moved). test2 :- movedg([one, two, three, four], [], []). This is very similar to the original but uses all variables instead. run 'test2.' in the interpreter and it also gives 'true'. So you can turn on the tracer to see what is actually going on, but instead I've written a more complex version that will print out what is going on so you can see for yourself. movedg([H|T], [], Moved, [[[H|T], [], Moved]|Rest]) :- movedg(T, [H], Moved, Rest). movedg([H|T], [Moving], Moved, [[[H|T], [Moving], Moved]|Rest]) :- movedg([H|T], [], [Moving|Moved], Rest). movedg([], [Moving], Moved, [[[], [Moving], Moved]|Rest]) :- movedg([], [], [Moving|Moved], Rest). movedg([], [], Moved, [[[], [], Moved]]). test3 :- movedg([one, two, three, four], [], [], R), maplist(format('~w ~w ~w~n'), R). Run 'test3.' and you will get all the steps that are taken. This is similar to your puzzle except that in the puzzle there are multiple people that can go on the boat at the same time and some rules determine who, BUT the principle is the same, and prolog will determine who can legally go on the boat at any one time by trying each possibility and eliminating the illegal ones, which means that the end result will only give a valid list of moves.
Thanks, this is really good. I have been looking at good ways to organise larger projects and you have docs, test reports and binary creation in easy to run formats, which is mostly what I was missing.
OK. I've just sent a message through their contact form, letting them know. Hopefully they'll respond in some way.
Of course you have random access for lists: ?- L = [a, b, c, d], nth1(3, L, X). L = [a, b, c, d], X = c. But it is not in constant time. I guess that was your question? You can use functors for constant-time random access: ?- F = f(a, b, c, d), arg(3, F, X). F = f(a, b, c, d), X = c. Does that help? I suspect you are trying to ask something different but I am not sure what exactly. If you have a better question you might get a better answer.
Any way to use those functors in the knowledge base?
What are you trying to achieve? And have you read the manual?
The easy way to have "random access" in Prolog is to put it into a table in the database. So like this, for example: t(1, a). t(2, b). t(3, c). t(4, d). This is esp. good for sparse arrays. This is if you want to have your "list" in the database. If you want to have it as an argument to a predicate, just keep it as a functor and pass it around? But you really need to explain your use case first.
I'm curious as to why the language was designed without random access in lists. What were the design decisions behind it? A lot of memory problems and accumulators could be very well done away with if they had just allowed some basic random access on lists.
Yeah but your premise is just wrong. I have showed you now three ways to have random access to elements in a "list". I suspect that you have a different question but it is in my experience completely useless to guess the questions of random strangers on the internet and answer those. The person who asked knows just as little as before and the person who answered wasted their time.
The trouble with those methods is that they're all workarounds. I either have to use a non-constant time extra rule( nth1(3, L, X) ), or brutally "cast" the list into a functor or a set of rules. Heck, can you imagine "casting" a list with a million elements by hand? Of course not. Which means I'll probably have to use something else on top of that to "cast" the list. Essentially, I keep adding stuff and lines of code to obtain a very basic functionality found literally everywhere else: list[3]. So my question is actually the original: Are there any reasons why prolog lists don't have random access? To clarify: Are there any reasons why prolog lists don't have random access out of the box, and we have to use workarounds instead? To expand: Why doesn't prolog have something simple such as list[3]? What was the design reason behind not using this? Was it a conscious decision, or was it simply not the standard in 1972? Are there any advantages to using a pure linked list model? 
I think I can _guess_ where you are coming from and where you might be headed to with these questions. Most of your premises are still factually wrong, which makes it difficult, because I first would have to educate you before you can re-formulate your questions. But the short and incomplete answer to your questions is: you have the database, which is good for (sparse) arrays and gives you the random access you are talking about; you have functors, which are good for immutable "static" arrays as in C or C++ and also have random access; and you have Prolog lists, which are the equivalent of linked lists in C. If you read about linked lists in C (what they are meant for, how they are implemented, and so on) you will know what you need to know about Prolog lists.
&gt; Are there any reasons why prolog lists don't have random access? When I take this question at face value, you get the obvious answer: "Because they are implemented as linked lists." ... but this is exactly the kind of useless answer I am talking about.
Ok mate, you're being obstinate, so let me rephrase the question for you to make it easier: Are there any reasons why prolog lists don't have random access out of the box in the vein of list[3], and we have to use workarounds instead? 
Lists are not arrays, they are actually complex terms wrapped in an easy to read syntax, and more like linked lists. You can't access a linked list randomly. Your question might be: why doesn't prolog have arrays? Best answer I can think of is to keep the language clean and simple as it should be. 
Try to reach Jan Wielemaker, the author of SWI Prolog, on Stackoverflow. If you do, please post a link to SO here.
Ok mate, let me rephrase the question to make it easier for you: Are there any design reasons why prolog lists are implemented as linked lists and not random access arrays? 
Thanks for not beating around the bush like the other guy. Do you consider forcing accumulators on the programmer as "keeping the language clean and simple as it should be" ?
Listen mate, I have answered you in 10 different ways but this is not enough for you. A list is not an array, it is a list. A functor is an array. A table in the database is a sparse array. Do some reading and come back when you have something more useful to ask.
I cautiously ask myself, how is that going to help OP? OP is unwilling to accept that a "list" in Prolog is not like a C-style array, but like a C-style linked list; or that a Prolog functor _is_ indeed very similar to a C-style array; or that a table is also a good data structure for doing things that require random-access arrays. Instead, OP has postulated: &gt; Lists in Prolog are useless because they are linked lists. ... and now demands that we supply him with enough substance around this, so that they create a narrative around it.
Ok mate, let me rephrase the question to make it easier for you: Are there any design reasons why prolog doesn't have classic arrays in the vein of list[3]? Why do we need workarounds for that?
OP didn’t postulate Prolog lists are useless. Also, linked lists as opposed to arrays is an internal implementation which still may support random access with, for example, extra array structure. I’m also curious as why this decision. Though I didn’t actually need random access so far in my code.
If you think this: ?- F = f(a, b, c, d), arg(3, F, X). F = f(a, b, c, d), X = c. ...or this... t(1, a). t(2, b). t(3, c). t(4, d). ...or this... ?- L = [a, b, c, d], nth1(3, L, X). L = [a, b, c, d], X = c. Is the similar to this: list=["a","b","c","d"] print(list[3]) You're insane. Ironically, when I first approached prolog I was excited to learn something new. But the more I delve into it, the more bad ideas I find. Bad ideas that don't seem justified, or remotely useful. And whenever I try to have a conversation about why those ideas are there or how they work, I get a good treatment of passive-aggressive "you're too dumb to get it" from some members of the community. And don't refer people to the literature, because it's shit. If it wasn't shit, people wouldn't be asking questions about it. No wonder this language isn't more popular. It's academic hipsterism. Cheers!
No. You are again postulating something outrageous (and factually wrong) and then asking "But why is this so stupid?" which is a fair question, but starting from the wrong end. Why bring accumulators into the picture, if you are still unclear on fundamental concepts?
Well, this is because different data-structures optimize for different operations... if you use lists, you have very cheap prepend(), insert() and pop(), if you use arrays, you have cheap random access. And you can have all sorts of things in between, like all kinds of trees, hash-tables and so on. Unfortunately, there just isn't a single datastructure which optimizes for all use cases you can think for it. So... you have to convert from one datastructure to another if that buys you anything... this knowledge is really basic for someone who writes code :/
Fuck off mate.
And nothing of value was lost.
Yes, I think that accumulators are a necessary evil. I am curious how an index mechanism might work though, so if you have a simple example of what the code might be then it might help clarify your question further. 
No, they are not necessary, and they are not evil. What OP kept on doing is that they would absolutely refuse to describe a use case; instead, they show an obviously silly solution and ask why it's silly. Yes, lists are not arrays; so yes, a list is a bad array. Yes, you sometimes need accumulators; or maybe you don't. **It depends on what problem you are solving.** Without some common ground (as in, "this is the problem I am solving and for some reason I chose Prolog, what is a good approach?"), so anyway, without common ground we are all just shouting random stuff at each other and wondering why the others are not getting it.
I feel a bit bad for OP. They have somehow managed to completely mix up things like programming language syntax, semantics, data structures and algorithms, algorithm efficiency, problem and solution....
There ARE prologs with arrays actually, but frankly your bad attitude probably means you'll have difficulty learning or even understanding. Fundamentally, linked lists are not arrays. prolog lists are (very closely) analogous to lisp lists, not python "lists". You've waded into a forum where people use normal terminology and asked ill-posed and bizarrely loaded questions. Beware python terminology in particular. Python calls what are basically its 1D arrays "lists" rather than "[1D] arrays" or "vectors" for some reason. Did you learn python first? you're the one using deeply nonstandard terminology here, REMEMBER: MOST PEOPLE DON'T CALL WHAT PYTHON CALLS "LISTS" LISTS! see e.g. https://cscircles.cemc.uwaterloo.ca/13-lists/ &gt; What Python calls a list would be called an array in most other programming languages. Python also has something different &amp; more advanced called arrays. 
What do you mean by "compiling" a regular expression? What is the end product? What does it compile to?
I'm glad you found it useful!
My goal for the project is to have it produce small binaries that operate in a way similar to how you might use a tool like grep. So whereas a tool like grep needs to take the regular expression and transform it into something that it can run, the binaries produced by regex will already have that regular expression "baked in". &amp;#x200B; I know its a bit contrived, but making a useful tool was a secondary concern to producing a useful learning artifact. 
You need to show how you compiled and ran this code. I cannot make it work as it is written :-(
Really? What error are you getting, or is the answer not right? I'm using SWI on Windows 10, and simply pressed enter on the file with the code in it to open it. I then typed &amp;#x200B; length(\[a, b, c, 4\], Count). &amp;#x200B; and got &amp;#x200B; Count = 4.
Oh, wait. Try capitalizing both instances of the "count" variable on the line &amp;#x200B; count is count + 1, &amp;#x200B; so it is &amp;#x200B; Count is Count + 1,