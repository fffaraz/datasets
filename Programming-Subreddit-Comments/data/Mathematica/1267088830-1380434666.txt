I know it's obnoxious to be told to just read the documentation, but honestly, Mathematica has the most complete (and the most helpful) documentation of any other research grade software I've used. I actually learned manipulate on 7.0 just this week. [Documentation Center](http://reference.wolfram.com/mathematica/guide/Mathematica.html) will probably lead you to all of these, but I just bookmarked a folder full, so: * [Introduction to Manipulate](http://reference.wolfram.com/mathematica/tutorial/IntroductionToManipulate.html) * [Evaluate Exps in Dynamic/Manipulate](http://reference.wolfram.com/mathematica/howto/EvaluateExpressionsInsideDynamicOrManipulate.html) * [Advanced Manipulate](http://reference.wolfram.com/mathematica/tutorial/AdvancedManipulateFunctionality.html) I also downloaded a few demonstrations from their [Demonstrations site](http://demonstrations.wolfram.com/), and that got me to where I needed to go. 
yeah, that's the first place i looked. I can see how to move things around in my manipulate output, but not how to completely squelch outputs. normally if you end something with a semicolon in mathematica it won't show the output, manipulate is doing it different.
I guess it has something to do with vector vs raster definitions. I don't know a whole lot about image formats, but I know that vector images like pdf draw your graph using a bunch of splines or Bezier curves, and raster is just showing a matrix of sorts. I added PlotPoints -&gt; {100,100} to that Plot call, and it looks a ton better. Results in a 4MB pdf though. If I wanted this graph in a paper, like part of a latex document, I'd save it as a high resolution png, then convert it using `pdfimage` on linux (or something similar on Mac). That way it's a pdf containing a raster image, instead of a pdf containing a vector image with hundreds of thousands of graphics calculations to do just to disply.
I've tried increasing the plotpoints too, but the result is not really good enough. It's surprising that mathematica can't handle pdf/eps-export well, when matlab and maple does it so much better. I know I could just export as a rasterized image, but I have become a bit of a latex purist so I would prefer pdf :)
http://www.uoregon.edu/~noeckel/MathematicaGraphics.html#ExportGraphics
Nice find, thanks a bunch. 
I look here, lonely though it is. I don't have an answer for you. Sorry :-( 
You should probably ask on [stackoverflow](http://stackoverflow.com/questions/tagged/mathematica)... I'm a afraid this subreddit isn't as active as one could be lead to believe.
You should define your data differently: data = {{-0.26, -1.12,-2.49},{-0.25, -0.7, -3.7},{-0.27, -2.05, 2.8}...} 
What are the feature changes supposed to be?
Syntax changes mostly I think. They're trying to make the input fairly casual, like Wolfram Alpha. Also I think they're trying to do some sort of merging of mathematica 8 and wolfram alpha, I remember a sales rep talking about it. I still run 6.0, I'm not buying 7 because I'm certain 8 will be out within a year. 
I'm a little late to the party, but you need to put in the linear regression library (already included in the program) Needs["LinearRegression`"] Then you can use the Regression command in your linear fit. I'm not sure if this is what you're aiming for, but it does provide error of some kind.
This guy is a brilliant entrepreneur. Notice how the lecture moves from one of his products to the next and on to the last, referencing both other products at each stage. Business genius! 
http://semanticvector.blogspot.com/2010/07/mathematica-cookbook-attacked-by-troll.html 
They say they can't recommend it for "serious use", but what would they recommend? Mathematica's only competitors in symbolic math is, what, Maple and (kind of) Matlab? Isn't comparing it to F# basically apples and oranges?
&gt; They say they can't recommend it for "serious use", but what would they recommend? I haven't tried Maple for symbolics. I can only tell you that I tried to use Mathematica to do 4 major symbolic derivations during my PhD and it gave wrong answers on every single one. So the only thing I can recommend is pencil and paper. &gt; Mathematica's only competitors in symbolic math is, what, Maple and (kind of) Matlab? In terms of turn-key commercial solutions, yes. Power users seem to write their own symbolic code in languages like OCaml. That is harder but it allows you to fix the bugs. &gt; Isn't comparing it to F# basically apples and oranges? They may have different strengths and weaknesses but they are both used for interactive technical computing so I don't think it is an unfair comparison at all. 
You probably want: Intersection@@Table[S + k j, {k, 0, n - 1}] 
A quote: "... although we do not hesitate to recommend Mathematica as an executive toy or even fun educational software for children, we still cannot recommend Mathematica for serious use due to the pervasiveness of serious bugs in this software. On the other hand, Mathematica's commercial success really demonstrates just how unimportant quality is in the software world." Perfect. 
&gt; They say they can't recommend it for "serious use", but what would they recommend? It isn't as though nature owes us a bulletproof symbolic mathematics system. I use [Sage](http://www.sagemath.org/) a lot, and it is in some areas worse, but at least it's free and open-source. [My Sage tutorial.](http://arachnoid.com/sage) 
For example, what I want is a curl of a vector, and much more complicated differential operators, operating on vectors, without using Vector Analysis. If I can emulate the following Needs["VectorAnalysis`"] command, I'm golden Edit; this works: &gt;sMatrix = -I Normal[LeviCivitaTensor[3]] &gt;CrossOp := -I *(sMatrix[[1]].{D[#1[[1]], x], D[#1[[2]], x], D[#1[[3]], x]} + sMatrix[[2]].{D[#1[[1]], y], D[#1[[2]], y], D[#1[[3]], y]} + sMatrix[[3]].{D[#1[[1]], z], D[#1[[2]], z], D[#1[[3]], z]}) &amp;; &gt;CrossOp[{Exp[I*kx*y], 0, 0}] &gt;CrossOp[{x, x, 2 x^2 + 3 y^2}] &gt;Curl[{x, x, 2 x^2 + 3 y^2}, Cartesian[x, y, z]] 
I am aware of this, but I don't think this is what I want. In this case Alpha will be eliminated. That is, Alpha will not appear on either side. See the example they give: eqn = {x + y == 6 a + 3 b, y == 9 a + 2 x} Solve[eqn, x, a] which gives 1/7(9b-y) I want something like x=-a+b y=7a+2b 
I spent a few hundred quid on Mathematica 7 only to find that it sucks. I tried to [compute the all-pairs shortest paths of a matrix](http://mathematicanews.blogspot.com/2010/07/all-pairs-shortest-paths.html) only to discover that the functionality in Mathematica 7 was both incomplete (it cannot return the paths!) and buggy. Then I tried to use `MinCut` to subdivide a graph without breaking too many edges only to discover that [the `MinCut` function *always* crashes the Mathematica kernel](http://www.mathkb.com/Uwe/Forum.aspx/mathematica/18946/MinCut-crashes-the-Mathematica-kernel). I had problems with `ListConvolve` corrupting my data when I used Mathematica 4 and, if anything, Mathematica 7 is even worse. So thanks but you can count me out... 
HEHEHEHHEHEHE
You have to specify the variables you want to solve it for, in the form {x, y, ...}. In your particular case you should write: Solve[{(x Cos[t] - y Sin[t] - x0)^2 /a^2 + (x Sin[t] - y Cos[t] - x0)^2 /b^2 == 1, y == m x + c}, {x, y}] // FullSimplify 
Thats that was it, many many many thanks.
As NomNomDePlume has pointed out, close to the point {0,0} the norm of the vectors tends to infinity, so the vectors in most of the region are negligible in comparison and they are not plotted. This won't be a problem if you restrict yourself to vectors with magnitude smaller than certain number. For example to plot the vectors with norm smaller than 2, you could write: VectorPlot[If[Norm[#]&lt;2,#,{0.,0.}]&amp;[{x,y}/(x^2 +y^2 )^(3/2) ],{x,-2,2},{y,-2,2}]
Nein, as far as I know there's no way to do this with version 7. In version 8, you can type expression like sinh^-1(u) and it will be converted as ArcSinh[u]. However, the expression will remain in 1D (on a single line, with fixed-width font) As for your forum question, I know there's a Usenet newsgroup, but it's moderated. I once asked a technical question there (about a buggy display), and a guy working for Wolfram answered me pretty quickly. Otherwise, I'd suggest stackoverflow.com; if you have a question, it will probably be answered within hours.
You could write something like this: Module[{error = Infinity, errorMin = Infinity, aMin = 0, bMin = -2, data = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}}}, Manipulate[ error = Total[Table[Abs[data[[i, 2]] - (a i + b)], {i, 1, Length[data]}]]; If[error &lt; errorMin, {errorMin, aMin, bMin} = {error, a, b}]; Column[{Row[{"a: ", aMin, " b: ", bMin, " Error: ", errorMin}], Show[Plot[a t + b, {t, 0, 5}, PlotStyle -&gt; Red], ListPlot[data, Joined -&gt; True], PlotRange -&gt; All]}], {a, 0, 5, Appearance -&gt; "Labeled"}, {b, -2, 2, Appearance -&gt; "Labeled"}]] But there is typically no reason to find the parameters that minimize some error manually. FindFit does it automatically, using the option NormFunction as error. By default the error is the sum of the squares of the differences between the original points and the adjustment.
Awesome. Thanks. The StandardForm command or its keyboard shortcut seems to convert the displayed expression - input and/or output - to the form I'd like to see. When you click on the input after that, it does *kind* of let you manipulate the expression within the standard form. I haven't fully worked with that, but I may simply upgrade to version 8.
Thanks! The main reason I use that is to fit sinusoidal data, which I can never get FindFit to work for. Also, it just helps me conceptualize the functions I'm working with.
Seems this is possible in version 7. See my OP edit regarding Palettes in the Mathematica notebook. Thought you'd like to know.
Plot[5.3-0.7(x-2.1),{x,min,max}] where min-max are the starting and stopping points of your graph But, you know, I shouldn't be doing your homework for you :) From here on out, you're on your own... 
Btw- 'goes up at a [negative] rate' is a bit misleading, as, well, going 'up' by a negative, in this case, means its going 'down'...
The built-in documentation is one of the best resources I've ever seen for any piece of software *ever*.
I have been going through it and was pleasantly surprised with the amount of examples and information within the virtual book. ha, apparently i can't think straight "presently surprised"
And don't miss out on stuff; there's a lot of secret little disclosure triangles that you have to click to see more.
Apparently I'm really good at clicking on tabs without them haha. I had a whoa moment, I was looking through part of the tutorial and a string of numbers was referenced, and it was a calculation I did earlier. There are so many different features in this program, it is quite impressive.
It is almost unquestionably the most impressive program I've ever used, while at the same time missing very basic features (competent undo, for one). I forgive them for things like that, though, because of how awesome it is otherwise.
Haha. I noticed the undo issue earlier today. I was working on an equation (and I'm on break, what social life? hahaha) and my cat jumped onto my keyboard. She managed to delete the equation and type enough things that I couldn't undo back to it. I learned to shut my door after that. I just did all the calculations and grunt work for my last research paper in seconds with the few commands I have already learned. It is really amazing.
My favorite thing so far : standard form and traditional form. Being able to input expressions the way they appear in textbooks or papers is pretty useful.
I guess that the simplest way to do that, would be to mark the particular cell you want to execute as an Initialization Cell (in the menu Cell-&gt; Cell Properties -&gt; Initialization Cell), then you can execute it with the command FrontEndTokenExecute[“EvaluateInitialization”]. This will execute all the Initialization Cells, so if you have other cells of this type in your notebook or plan to add them, it may be better to attach a unique tag to the cell you want to execute (select the cell and press Ctrl+J). If the cell tag is MyTag, you can then evaluate it with the expression: NotebookGet[InputNotebook[]]/.Cell[BoxData[data_],___,CellTags-&gt;"MyTag",___]:&gt;ToExpression[data]; I am assuming that you are going to make the evaluations from the same notebook that contains the cell, otherwise, for a notebook nb, you would have to replace InputNotebook[] for nb in the second case, and in the first case you should write FrontEndTokenExecute[nb,“EvaluateInitialization”]. I wrote those possibilities assuming that you are adamant that you don’t want to change the cell, but that is not what I would do. I would rewrite the cell as: OutputDataMatrix[inputDataMatrix_]:=( (* calculation *) A = SomeFunction[inputDataMatrix]; B = MoreStuff[A]; B) Or if you truly want to use the global value InputDataMatrix and change the global value OutputDataMatrix: Calculation:=( (* calculation *) A = SomeFunction[InputDataMatrix]; B = MoreStuff[A]; OutputDataMatrix = B ) And then simply call Calculation. 
Great. Many thanks. I haven't tried, yet, but I think any of your suggestions will work for me. I was looking for something like the MyTag solution. However, I agree, that rewriting the cell to define a function/expression OutputDataMatrix[inputDataMatrix_]:=( ... ) is much cleaner. I didn't realize that I could just add parentheses around the whole cell. That's perfect. Thank You. 
I know this is an old post, but I find that reading the wolfram blog helps a lot with understanding how Mathematica is supposed to be used and what kind of potential it has.
Post some code, that might help!
I use Workbench with Mathematica test. Most of our code is either ".m" files or ".mt" files for test. Both of which are just plain text files, which is great for version control as oppose to regular notebooks, which can confuse version control systems and diff programs with its "hidden" information. We treat notebooks as sort of the "entry" point for whatever we're developing though. We do occasionally use a test framework outside of workbench. We've did it a couple of different ways, with Mathematica 8's built in scripting support its pretty easy to build automated test that way. Other times if we're doing things with mathlink and so on, we just use whatever test suite we feel appropriate 
There is a useful "White paper" which you can download from a link on the right hand side of http://www.wolfram.com/solutions/industry/software-engineering/
Thanks, that is pretty useful.
Both can do everything, the real question is more about what is easier to do in one compared to the other. Mathematica is a functional language, and has more elegant syntax. Its good for symbolic math. I feel that its good for scientists. The problem is that I find the Mathematica implementation quite buggy. I face frequent crashes. I find that Matlab is more suited for numerical calculations, and it encourages writing code in matrix form. While that comes naturally to some, I find it quite inelegant. Its also a procedural language, with OO design added as an after thought. It however has a solid implementation, and a huge install base. If you can deal with the ugliness of its syntax, its probably the best choice for numerical math, since many more people use it compared to Mathematica. 
Matlab was originally designed to work with numerical matrices, and from the outset, it has been very efficient manipulating them. Mathematica initially was intended for symbolic calculations and it was very inefficient in most numerical computations, in particular manipulating numerical matrices. However nowadays Mathematica has caught up with Matlab in numerical capabilities, while Matlab is still far behind in symbolic calculations. I prefer the last version of Mathematica to the last version of Matlab in any important category: it has a far more versatile language, it possesses greater mathematical resources, its graphical capabilities are very powerful, and the notebook approach to Mathematica documents is very convenient. I think that the main reason many people choose Matlab is that there are specialized toolboxes for many particular problems. The language may also be somewhat easier to learn than Mathematica. 
Both are suited for different tasks as other people have pointed out. I think you should also know that there are open source alternatives like [Octave](http://www.gnu.org/software/octave/), [Sage](http://www.sagemath.org/) and [Scipy/Numpy](http://www.scipy.org/) . They don't quite have the user base as the big commercial packages but they handle quite a few tasks just as well. 
Recently I often use Mathematica, because most of my calculations are symbolic calculations. Mathematica is functional languages so it requires a different way of thinking. The syntax looks a bit strange if you're not familiar with the functional programming. I understood what's going on when I had started learning Haskell programming language (pure functional) in spare time. I agree: On my computer there are also frequent crashes (version 8), especially when I use the shortcut Ctrl + O to open the notebook. Ps For numerical computing I strongly recommend the Python distributions like [EPD](http://www.enthought.com/) (free for academical purpose) or [Python(x,y)](http://www.pythonxy.com/) (GNU GPL). They contain several of packages and tools like: * [Numpy and Scipy](http://scipy.org/) - great libraries for linear algebra etc. * [matplotlib](http://matplotlib.sourceforge.net/) - high quality 2D plotting lib * [Mayavi2](http://code.enthought.com/projects/mayavi/) - 3D scientific data visualization and plotting, the power of the VTK toolkit and OpenGL - should be good for fluid simulation. * [Spyder](http://code.google.com/p/spyderlib/) - very good MATLAB-like IDE for scientific computing.
I had some issues creating a pretty massive array of complex numbers and doing discrete FTs on it the other day, but I think i just didnt know what I was doing and was rushing. I ended up just pounding it out with numpy in python. 
If you are going to go for open source go for Scipy/Numpy.
Apparently it is because they refuse do it until they can roll back the kernel state. How out of touch can they be? Who even wants to roll back the kernel state?
I agree 100%, it's unbelievable that Mathematica can't manage this.
Mathematica is teaching you to not make mistakes
I'm trying to analyze some graphs and I thought Mathematica could help but I just keep finding more and more bugs. In this case, I cannot even get the `NetworkFlow` function to solve the most trivial problem: g = FromAdjacencyMatrix[{{Infinity, 1}, {0, Infinity}}, EdgeWeight] let alone the one presented in this old newsgroup post or my actual graph problem. Mathematica just hangs in all cases. Has anyone had any luck using these functions in Mathematica? 
Why do you question the great and powerful Stephen Wolfram? Don't you know how great and grand he is?
One less thing today... http://www.wolfram.com/news/mathcoreaquired.html
Possibly shameful, but I don't think I knew that there was a FullSimplify command. Always used Simplify. 
Here's an link to the documented problem with a previous version of the paclet and how the current version has the same problem. [Link](http://forums.wolfram.com/student-support/topics/24056)
N[Pi, 1000000]
The inconsistency between using Symbols and Strings, mostly for options and stuff like that. There exist predefined symbols such as Thick, Red, and Joined, while more recent functions tend to take options specified as Strings. I feel Mathematica should pick a preferred style for this and deprecate the other way.
The inconsistent way in which conceptually similar functions return their results. E.g. Solve[] returns a list of replacement rules, while SatisfiabilityInstances[] (basically, a Solve over Booleans) return value lists. 
I sometimes really miss a "struct-like" data structure, where you can address items as x.field1 and x.field2. There are a number of approximations for this, but I feel they are rather clumsy.
I'm still not quite sure what over half of the buttons in the classroom assistant window mean, but that's more a personal issue than a problem with Mathematica.
The lack of a multi-level undo stack (or even single-level sometimes!) is absolutely *mind-boggling* to me. Seriously, Wolfram, what the fuck?
Infinity upvotes. Believe it or not, they say they're waiting until they can implement undoing the kernel state! Who would ever want that?!? Wolfram, this is your customers speaking: DO NOT WANT.
No CTRL+A to select an input.
Lack of plugin support.
The copy protection. Difficulty moving to a new machine or using on two machines (laptop &amp; desktop). Also as a non open system you are stuck with their choices on UI stuff.
This is a bit of a hassle, yes. I contacted Wolfram about this once, explaining that it is trivial to find key generators online, and that I didn't get why they were bothering paying customers like that for no good reason. However, I recently had a motherboard repair and it was actually trivial to get a new activation code, via an online chat in the user portal. 5 minutes of work, so that went better than expected. 
They are well aware of this issue, I heard this in a talk recently, and they are thinking of proper ways to address it.
What kind of plugins are you thinking about? 
Sometimes I wish I could tweak the UI more. I do a lot of programming in Vim and one of the main draws of that is how extensible it is. I also wish someone would make a data plugin so that it was easy to enter/browse/edit data. Excel might suck as a program, but it's sure a lot easier than typing your data as a nested list.
Oh mathematica.I love the language, however the implementation is soo shitty. - It crashes frequently, especially when using dynamic variables. - Notepad editor has the worst undo I have ever seen in any application. Applications I wrote when I was 13 had better undo support than Mathematica. - Very limited support for computer vision algorithms. Although Mathematica 8 added several functions, but they barely scratch the surface, and those which have been implemented, do not allow much tweaking. - SLOOOWW... - Plotting with error bars, and legends. Really mathematica, does it really have to be sooo complicated? - If you save vanilla mathematica plots as PDFs, it does not embed the fonts, and hence many conference paper submission system do not accept the PDF's. Maybe I don't understand this well, but the point is several times I am forced to convert these plots to PNGs before my latex generated PDF is accepted. 
It's not "open" (source). Any other drawback (damn notebook interface and lack of undo) is a consequence thereof. I do not demand that any software must be free as in beer/speech. However, the core functionality of Mathematica (symbolic math) is so fucking fundamental, it screams for an open solution. The fact that we rely so heavily on Mathematica/Maple to do really basic stuff in pure and applied science, is holding us back.
It would be great to have some open source alternative, of course. However, I'm afraid the only way to produce something approaching the breadth and depth of Mathematica, at a comparable level of quality, would require a benign dictatorship (a la Linus for Linux) and corporate sponsorship (a la Mozilla). 
&gt; It crashes frequently, especially when using dynamic variables. That is not my experience, but I tend to only use dynamic stuff via Manipulate[], which is pretty nifty. I haven't been able to really understand the dynamic semantics of Mathematica. &gt; SLOOOWW... What kind of stuff are you doing? In my experience, as long as you are able to express your algorithm in proper functional terms, the performance is pretty good; but as soon as you start to do explicit looping, it grinds to a near-halt. &gt; Plotting with error bars, and legends That is a big one, yes. The functionality is really lacking compared to Matlab or R, there. &gt; If you save vanilla mathematica plots as PDFs. Never ran into that myself, but I can see that is a nuisance.
You didn't get my point. It's always nice to get something for free, but that's not the reason to ask for an open solution. In an engineering or business world, the difference between free and commercial is the price tag, and if you use a product extensively, it's probably worth it. In pure math or science, we have to ask the question, whether we want to rely on a black box such as Mathematica's FullSimplify, which (although conceptionally trivial) we will never full understand. What if FullSimplify yields 1, but I cannot proof this without Mathematica. More practically speaking: What about teaching? In principle, we should introduce students more thoroughly into CASs (after they got their calculus!!). If done right, this boosts not only efficiency in problem solving, but can also deepen one's understanding of math. However, teaching Mathematica is problematic. It just doesn't feel right to get someone used (addicted) to a product, which is fucking expensive. Also, I'm not asking for "the breadth and depth of Mathematica". No one, needs stock market data and number theory in one application. I can do without 3D data visualization and numerical computation (because other tools can do this (better)). But, we really need a free bread and butter CAS.
&gt; What if FullSimplify yields 1, but I cannot proof this without Mathematica. If FullSimplify yields 1, that is still no proof. The same would go for a hypothetical open-source CAS by the way -- these systems are simply too complex to be without bugs, so a proof could never defer to a CAS, even an open-source one. The mathematical community will not accept that, and rightly so. I view Mathematica more as a lead generator. You can quickly derive interesting-looking results and check them against your intuition and numerical data, but if you want to do mathematics, in the end you will have to sit down with a piece of paper to work it out yourself. Engineering (the setting where I most often use it) is a bit of a different story. There, the threshold of proof required is much lower than in mathematics. If I solve an equation I can simply plug in a few numbers to see if the equation holds, make a couple of plots to verify the behavior against my understanding, and that is usually enough to accept that the result is ok. &gt; It just doesn't feel right to get someone used (addicted) to a product, which is fucking expensive. "Expensive" is a relative thing. For you as a student or individual, yes it is expensive. For a company or organisation, not so much. As an example, my company shells out about 600 Euros yearly for a Premier Service license (after an initial cost of 2k+ for the first year). As billable hours go, that's about a day's worth of effort. Does it save me (or my customer) a day a year that I have this software at my fingertips? You bet. Compared to e.g. Matlab, Mathematica is actually rather affordable, especially if you consider that you don't get to shell out enormous amounts of money for all kinds of silly toolboxes. &gt; But, we really need a free bread and butter CAS. And for this, I refer to my earlier comment. It is one thing to lament about the non-availability of a quality open-source CAS, but in absence of that I am happy I can at least get a quality closed-source product. If life gives you lemons, better make lemonade. 
I think CUDAFold works only with 32 bit integers. The result you have does not fit in a 32 bit integer. 
I would love to have something like PyMC for mathematica. http://code.google.com/p/pymc/ 
&gt; What kind of stuff are you doing? In my experience, as long as you are able to express your algorithm in proper functional terms, the performance is pretty good Mathematica's performance is generally awful. For example, sum of 1/n for n∈{1..10⁶}: In[1]:= Fold[#1 + 1/#2 &amp;, 0.0, Range[1000000]] // AbsoluteTiming Out[1]= {0.2380000, 14.3927} Same thing in F# is 13× faster: &gt; Array.fold (fun x y -&gt; x + 1.0 / y) 0.0 (Array.init 1000000 (fun i -&gt; float(1+i)));; Real: 00:00:00.019, CPU: 00:00:00.031, GC gen0: 0, gen1: 0, gen2: 0 val it : float = 14.39272672 When you use non-trivial data structures, Mathematica quickly becomes orders of magnitude slower. 
1. I am surprised that you found a 27 day old post! 2. It looks like such things will have to be done by us!
I was actually (earnestly) surprised that Mathematica is only 13x as slow in this case, given the way this was coded. F# has a lot of advantage here, since it can do its static type inference. But your point is valid; as soon as Mathematica needs to do separate steps for data items at the Mathematica level (and cannot properly vectorize operations), performance will be bad. For those kind of algorithms, the smart thing to do is to switch to a compiled language once you are done experimenting. The version that allows vectorization is a lot closer to what F# does in terms of performance. My computer is about as fast as yours, and I get: Total[1./N[Range[1000000]]] // AbsoluteTiming {0.0576171, 14.3927} The nicest thing about Mathematica, of course, is that the proper algorithm is often already there. Case in point: HarmonicNumber[1000000`] is a lot faster than the F# algorithm ... The obvious thing is that no single tool is best for all circumstances. 
&gt; But your point is valid; as soon as Mathematica needs to do separate steps for data items at the Mathematica level (and cannot properly vectorize operations), performance will be bad. For those kind of algorithms, the smart thing to do is to switch to a compiled language once you are done experimenting. You're assuming there is some valid reason to start using Mathematica in the first place. For me, that is never the case any more. I only use Mathematica to play with demos from the Wolfram Demonstrations project for fun. &gt; The nicest thing about Mathematica, of course, is that the proper algorithm is often already there. The bad thing about Mathematica, of course, is that a lot of the "proper algorithms" that are supposed to be there are completely broken. For example, I recently wanted to crunch some graphs and discovered the `NetworkFlow` function that has been in Mathematica for the past 10 years *has never worked on any input*. Wolfram Research just reply with the usual bullshit statement about how seriously they take QA. So, again, I coded a solution in a few lines of F#... &gt; The obvious thing is that no single tool is best for all circumstances. Better examples for Mathematica would be functionality that is rarely found in compiled languages, such as `NDSolve`, `FullSimplify` and `Integrate`. For anything else, it sucks. 
&gt; You're assuming there is some valid reason to start using Mathematica in the first place. For myself, that is not so much an assumption as it is a fact. &gt; The bad thing about Mathematica, of course, is that a lot of the "proper algorithms" that are supposed to be there are completely broken. I do not believe that. If you think this is true for a lot of algorithms, you should be able to give a few more examples? Or you could point me to a page where they are listed? NetworkFlow is part of the Combinatorica package, which seems to have fallen by the wayside a bit. While I agree that Wolfram should be upfront about this -- they should just deprecate it or something -- I disagree that the fact that you have found a problem there would be an indication of a broad quality problem. In my ~20 years of Mathematica usage, I only encountered a single serious bug. &gt; Better examples for Mathematica would be functionality that is rarely found in compiled languages, such as NDSolve, FullSimplify and Integrate. s/rarely/not/ I agree those kind of functions are the most prominent advantage of Mathematica. There is a lot of mathematical knowledge encoded therein.
&gt; I do not believe that. If you think this is true for a lot of algorithms, you should be able to give a few more examples? Or you could point me to a page where they are listed? I just listed several in my answer on this thread. `ListCovolve` was broken when I tried to use it in MMA 4 (silently corrupting its input) and I found lots of bugs where `FullSimplify` and `Integrate` would give wrong answers. Now `NetworkFlow` and `MinCut` are broken in MMA 7. Moreover, Wolfram Research just pushed the bugs around from one version of Mathematica to the next. The bugs I found in `FullSimplify` and `Integrate` during my PhD in Mathematica 4 were at least partially fixed in Mathematica 5 but other bugs that were introduced. So my MMA 4 notebook jumped through various hoops to hold Mathematica's hand as the derivation progressed, carefully to avoid the bugs, but that no longer worked in MMA 5. I had to start rebuilding others path through another set of hoops to work around the new bugs in MMA 5 in order to arrive at the correct result. I eventually gave up. If you're interested, my PhD thesis is freely available [here](http://www.ffconsultancy.com/free/thesis.pdf). Mathematica 4&amp;5 were unable to obtain the correct answer for any of the four major derivations in that work. Oh, I commercialized some of the Mathematica source code from my PhD and that was [afflicted by a bug in Mathematica 7's `Fourier` function](http://flyingfrogblog.blogspot.com/2009/05/mathematica-bug-afflicting-our-product.html). Our customers have complained about bugs in Mathematica countless times. Many of them have followed us to OCaml and F#. I tried to help someone last year who was [suffering from a bug in Mathematica's regular expression library](http://stackoverflow.com/questions/2257884/bug-in-mathematica-regular-expression-applied-to-very-long-string). There's a guy called Vladimir Bondarenko who has published thousands of incorrect results found my Mathematica. &gt; NetworkFlow is part of the Combinatorica package, which seems to have fallen by the wayside a bit. While I agree that Wolfram should be upfront about this -- they should just deprecate it or something -- I disagree that the fact that you have found a problem there would be an indication of a broad quality problem. Every single project I have ever tried to do using Mathematica (from version 4 to version 7) over the past 12 years failed due to bugs in Mathematica. I have long since given up on trying to use Mathematica to do any serious work. I just play with it as an executive toy. &gt; In my ~20 years of Mathematica usage, I only encountered a single serious bug. That's interesting. I have never encountered a satisfied Mathematica user in this regard. I've encountered dozens of bugs myself. Aside from completely broken core functionality I described above, both the kernel and GUI had bugs that caused them to crash several times a day back when I was using Mathematica 4. I remember there was a particular sequence of keys I used to press out of habit that crashed the Mathematica notebook front end. 
It is probably treating g as a function of x, transforming it accordingly and then applying the result. Try forcing g to be a constant.
Try this: In:=FullSimplify[InverseFourierTransform[FourierTransform[Exp[-(x - g)^2]/x, x, t], t, x]] This doesn't yield the original expression. Substitution some actual constants for g, the actual answer for the Fourier transform involving g seems to be: (Sqrt[Pi/2]*Erfi[g + (I/2)*t])*Exp[-g^2] I think you have found a bug. Best report it (if you don't feel like doing that for some reason, I can do it and report back). 
Note that, according to Mathematica, the inverse Fourier Transform of the first result also fails to recover an expression equivalent to the original: In[1]:= InverseFourierTransform[I*Sqrt[Pi/2]*Erf[t/2], t, x] // FullSimplify Out[1]= (1 + I*Erfi[x])/(E^x^2*x) So Mathematica is wrong in both cases. I'd advise against trying to use an executive toy for serious work... 
Unbound symbols are treated as constants by default, so this does not explain the OP's problem.
Thanks for the confirmation. I will report the bug. Once again, reddit proves awesome!
I'm using Mathematica 7.0.1.0. Aren't you the guy who was just telling me that Mathematica isn't riddled with bugs? ;-) 
That's me. "Riddled with" is a bit of a subjective phrase, wouldn't you say? Sure there are bugs, probably quite a lot, but then again it is a large piece of software. It's a useful tool for me. Not an "executive toy", to quote your favorite phrase.
&gt; Sure there are bugs, probably quite a lot, but then again it is a large piece of software. Mathematica isn't actually that large by modern standards. For example, Debian 5 had 130x more lines of code than the Mathematica 6 kernel (324MLOC vs 2.5MLOC). Even Facebook (at 9MLOC) is larger than Mathematica. Moreover, Mathematica is little more than a collection of largely-unrelated functions. The 450 functions in the 7.4kLOC of Combinatorica code is a prime example of this: completely unrelated to the rest of the system and now completely rewritten in C/C++ and put in the kernel. Same story for all the graphing and charting functionality and lots of other stuff: all originally Mathematica code now rewritten in C/C++ for performance reasons. So the MMA kernel has grown from 150kLOC in MMA 1 to millions of lines of code today. Basically, most of Mathematica is the result of typing code from text books in Mathematica syntax. Nothing clever at all. So I wouldn't expect it to be anywhere near as buggy as it is. Now, I know why it is this buggy. Wolfram Research very much subscribe to "never mind the quality, feel the width" when it comes to sales so they employ almost entirely sales people and pay students to write massive quantities of code that they then sell with virtually no testing. You can also imagine the effect of rewriting Mathematica itself in a modern language. Say you use F# on .NET. You inherit a real garbage collector for free (much better than Mathematica's reference counting). You get JIT compilation to native code for free. You get GUI libraries for free and even charting and graphing functionality for free. The Mathematica code base would be orders of magnitude smaller. You'd still have to implement the symbolic engine but Maxima's is only something like 50kLOC and the rest is, again, just copying integral equations from text books. So Mathematica is buggy because its creators do not value correctness. I don't mind that in an executive toy. ;-) 
&gt; So Mathematica is buggy because its creators do not value correctness That is quite an accusation to make. Personally, I refrain from pretending I'm able to see into other people's minds. Have fun with F#. I'll think back to this discussion in a few years time when Microsoft pulls the plug. 
I might not be understanding your question correctly, but your confusion may be based on the fact that Mathematica does not assume variables are real. The expression Re[a + b I] is equivalent to Re[ar + ai I + br + bi I] where *ar*, *ai*, *br*, and *bi* are real and represent the components of *a* and *b*. Since your assumption is that *a* and *b* are real, you must add an assumption to the expression. Refine[Re[a + b I], Assumptions -&gt; {a, b} \[Element] Reals] will return the intended answer.
 In[3]:= Re[a + b I] Out[3]= -Im[b] + Re[a] In[4]:= Im[a + b I] Out[4]= Im[a] + Re[b] This is right, though. The key point is that Mathematica does not make the assumption that a and b are real numbers. Try this to get the result that you expect. Assuming[Element[{a, b}, Reals], Simplify[Re[a + b*I]]] Assuming[Element[{a, b}, Reals], Simplify[Im[a + b*I]]] It is actually a bit surprising that the "Simplify" is even needed to me. Maxima seems to assume the symbols are real-valued. It is just a different convention. I think that you will simply need to add some assumptions here and there to get the results that you are expecting. 
@Vortico, @sidneyc Thank you for the explanation. This is exactly what I wanted to understand.
What exactly do you mean by "linear independence"? These aren't linear equations, so you're probably asking whether these are algebraically independent, which I guess means that you want to know whether there exists a nontrivial solution. The answer is yes. The output that Mathematica is giving actually corresponds to two different solutions: one where concI2 = concI = concHi = concCH3CO = 0, and another where concI2 = concI = concCH3cO = concCH3 = concCH3I = 0. Either of these sets of conditions gives a solution to the given equations.
Right, algebraically independent was my intent. I guess I set it up wrong.
I see; when I rearrange it as the product of a coefficient matrix and the constants k1,k2,...,k7 then row reduce I eliminate a row.
Hey dude, just do the Wronskian, its a matrix approach to linear independence. http://en.wikipedia.org/wiki/Wronskian Its up to you to program it though, I'm at a [4]
Doesn't anyone do real maths any more, you know, like with paper and a pencil?
the annoying part is that mathematica is typically really stupid when it comes to real or complex numbers (and getting the real part or the complex part). For example, D[blah] doesn't work with Re[] or Im[], and I can't get it to thread across Sqrt's (taking the sqrt of a complex number), even after assumptions are made. Anyone else have these problems?
What sort of fractals are you looking to render? It's fairly easy to draw fractals using [iterated function systems](http://en.wikipedia.org/wiki/Iterated_function_system) in Mathematica. For example, the following code will render a [Sierpinski triangle](http://en.wikipedia.org/wiki/Sierpinski_gasket): F[{x_, y_}, 0] := {x/2, y/2} F[{x_, y_}, 1] := {x/2 + 0.5, y/2} F[{x_, y_}, 2] := {x/2 + 0.25, y/2 + 0.5} F[{x_, y_}] := F[{x, y}, RandomInteger[2]] ListPlot[NestList[F, {0, 0}, 10000]] You can play around with the three functions to change the shape of the fractal, or add more functions to get more complicated fractals (e.g. eight functions for a [Sierpinski carpet](http://en.wikipedia.org/wiki/Sierpinski_carpet)) You can also use Mathematica to draw fractal curves. The following code will render the 7th stage of the [Hilbert curve](http://en.wikipedia.org/wiki/Hilbert_curve): F0[{x_, y_}] := {y/2, x/2} F1[{x_, y_}] := {x/2, y/2 + 1/2} F2[{x_, y_}] := {x/2 + 1/2, y/2 + 1/2} F3[{x_, y_}] := {1 - y/2, 1/2 - x/2} Points[1] = {{1/2, 1/2}}; Do[ Points[n] = Map[F0, Points[n - 1], {1}]~Join~ Map[F1, Points[n - 1], {1}]~Join~ Map[F2, Points[n - 1], {1}]~Join~ Map[F3, Points[n - 1], {1}];, {n, 2, 7}] Graphics[Line[Points[7]]] Rendering [Julia sets](http://en.wikipedia.org/wiki/Julia_set) and the [Mandelbrot set](http://en.wikipedia.org/wiki/Mandelbrot_set) is a bit more complicated. See the FastJulia.nb notebook on my [class website](http://math.bard.edu/belk/math323/) for the relevant code.
Awesome, thanks man. I know a good bit about fractals but nothing hands on. I've read Mandlebrot's "Fractal Geometry of Nature" and I've got a fetish for the complex numbers so I plan on continuing studying the subject. I'll mess with these babies tomorrow.
Here's a simple but CPU intensive way to render a Mandelbrot fractal. mandelbrot[c_] := Abs[NestWhile[#^2 + c &amp;, 0, Abs[#] &lt; 2 &amp;, 1, 20]] &lt; 2 RegionPlot[mandelbrot[a + b I], {a, -1.5, 0.5}, {b, -1, 1}, PlotPoints -&gt; 50 (*Increase for greater precision*)] If you have Mathematica 8, you can use the [OpenCLFractalRender3D](http://reference.wolfram.com/mathematica/OpenCLLink/ref/OpenCLFractalRender3D.html) example function to play with the 3D [Mandelbulb](http://en.wikipedia.org/wiki/Mandelbulb) or even build your own implementation.
Awesome, thanks man. I have an interesting idea which might lead to some more fractals.
Great! My computer doesn't support OpenCL, so I've never had a chance to try its features. I'm sure I'd have some fun with it.
Oh noes, it's a dragon! dragon[x_] := Join[x, Map[Cross, Reverse[x]]] ListPlot[FoldList[Plus, {0, 0}, Nest[dragon, {{1, 0}, {0, 1}}, 11]]] edit: actually, that's better: dragon[x_] := Join[x, Map[Cross, Reverse[x]]] Graphics[Line[Accumulate[Nest[dragon, {{1, 0}}, 12]]]]
Just a note: many institutions will accept EPS files embedded into PDF documents. This vector image format is usually better than raster PNG. I prefer this when using Mathematica with LaTaX (pdflatex).
Are you saying with EPS files, the font embedding problem does not exist? I will have to try that out.
Shorter version for the hilbert curve: hilbert[x_] :=Join[Reverse /@ x, {{0, 1}}, x, {{1, 0}}, x, {{0, -1}}, -Reverse /@ x] Graphics[Line[Accumulate[Nest[hilbert, {{0, 0}}, 5]]]]
Could you give an example? Do you want to move an output result around the Mathematica notebook, or are you referring to tables and lists? f[x] g[x] %2 %1
I'm referring to cells, as in, the things you can right-click on [at the very right-hand end of mathematica]
I'm pretty sure you can click and drag the brackets to the desired location (at least on Mac OS X, Mathematica 7 and 8). Are you wanting to do this automatically?
Hm I'm using mathematica 8 on win7 and click+drag doens't work :(
What about clicking the cell to highlight it, and *then* clicking and dragging?
Doesn't work - it just highlights all the other cells. =/
k, solved it. Depth is built in mathematica function. I didn't realize that cuz I first used D[t] and that also turned out to be built-in =/
The Mathematica documentation suggests the convention that user-defined symbols start with a lowercase letter. Which is pretty annoying... Compared to other languages, you are discouraged to make symbols starting with capitals, and you cannot use underscores.
You cannot use underscores in Mathematica symbols! Underscores have a very specific meaning in Mathematica, they define a pattern. For example: f[x_]:=x^2 defines a function f that can be applied whenever "anything" is passed to f; the "_" is the placeholder for "anything", and the thing that takes its place will be bound to the symbol "x". f[x_Integer]:=x^2 This will do the same thing, but with the added restriction that it only matches in case the thing passed to f is an Integer. Likewise, the pattern "x_h" means: a pattern that matches only to expressions with head 'h', and is bound to symbol 'x' upon a match. If all of this is confusion to you, please take your time to work through some tutorials. Working with Mathematica will be a very frustrating experience if you don't understand the basis of pattern matching. 
Underscore has a special meaning in function definitions. In a google search of "functions mathematica underscore," all of the top hits explain this. Read [this](http://pyweb.swan.ac.uk/~allton/Mathematica/node3.html).
This is the best I could do. Right click on the plot, and choose Get Coordinates. f[x_] := Sin[x] Plot[f[x], {x, -2 \[Pi], 2 \[Pi]}, CoordinatesToolOptions -&gt; {"CopiedValueFunction" -&gt; Function[x, Row[{x[[1]], ", ", f[x[[1]]]}]]}]
I'd like to add just to make sure that this is not limited to function definitions. The underscore is a syntactic element of the language that denotes a pattern. It is effectively syntactic sugar for the built-in Pattern[] function. 
The easiest way is to add it as a plot label, e.g. Animate[Plot[Sin[x + u], {x, 0, 10}, PlotLabel -&gt; u], {u, 0, 5}] But you can get much fancier than that, by inserting a graphics object inside the plot: Animate[ Plot[ Sin[x + a], {x, 0, 10}, Epilog -&gt; Text[a, {2, 0.5}, BaseStyle -&gt; {Large, Pink, Bold} ] ], {a,0,5}]
Just use a nested for loop with a conditional as you mentioned. It is the most straightforward way to do this. I don't know why you'd want a pretty/clever way to do this standard procedure.
That will only give you i &lt; j and not any of the i &gt; j.
The index of the inner for loop doesn't have to depend on the outer index. for i = 1 to n for j = 1 to n if i != j sum = sum + a(i,j) 
I take it you're using i and j as indices in a 2D array. IdentityMatrix[size] makes a matrix of 'size' where all elements are zero except the diagonals. So, 1-IdentityMatrix[size] gives you a matrix with everything as 1 except the diagonal (now zero). Multiply your result by that matrix and that should give you the result you're looking for.
I'm sorry, your post wasn't clear that's what you meant. By the way you worded it, I thought you were referring to the conditional of the 'for' statement and not a separate 'if' conditional.
also, use Table[] over For[] when you can. Mathematica runs Table faster.
I can't find any proof for this particular book, but I've seen other Mathematica books that are actually written using mathematica. If you're not locked into using LaTeX and want to include Mathematica code, I would check out what you can do within Mathematica. It's obviously not as powerful, but 8.0 does add EndNote support (though only for Windows users -- so I got burned on this. Thanks false advertising!).
No worries, I posted the pseudocode to remove the ambiguity.
Small correction: Multiply your result by that matrix and *sum the entries of this*. Your answer is probably the elegant solution ggrieves is looking for.
Can't you use something analogous to the [Kronecker delta](http://en.wikipedia.org/wiki/Kronecker_delta)? Maybe |delta_ij - 1| which should give 1 if i!=j and 0 if i=j. This is equivalent to [greggroth's suggestion](http://www.reddit.com/r/Mathematica/comments/hcp83/sum_over_ij_where_i_j/c1udvmz).
that's the perfect way to do it: Table[(i + j) (1-KroneckerDelta[i,j]),{i,1,4},{j,1,4}]
For loops are quite an unnatural way of expressing stuff in a functional language like mathematica, though.
How about this? Sum[If[i != j, 1, 0] * f[i, j], {i, 1, 3}, {j, 1, 3}] This will give f[1, 2] + f[1, 3] + f[2, 1] + f[2, 3] + f[3, 1] + f[3, 2] 
This is great, I really had no idea that mathematica could interpret the if statement inside the Sum operation. Many upvotes to you Sidneyc
Very nice, this is excellent
This may be because you are used to non-functional languages, where there is a difference between statements and expressions. In Mathematica, every syntactically valid statement is an expression, and vice versa. Even expressions that mimic functionality from nonfunctional languages (such as the For[] construct) yield a value. In case of the For[], for example, it returns Null, which is not explicitly shown. 
I agree, but a beginning Mathematica programmer is probably comfortable with them, which is why I suggested it. There is something to be said for writing code that you can easily understand and maintain. I am aware now that I misread the original question, and that the other answers are better suited to what he was asking for.
While I understand and appreciate your point of view, I disagree with it. I am a computer science guy by training, and I have seen mounds of truly atrocious code made by non-programmers over the last decade or so -- mostly in the setting of scientific software. My experience is that scientists (often very smart people but non-programmers nonetheless) only care about getting their stuff running, and getting an answer out of their program, ASAP. They don't *want* to invest the time necessary to become even moderately good at programming -- they just want the software to run, and they are happily (and quite unwittingly, often) committing every possible sin against decent programming practices in the process. If people with that mindset start to write For[] loops in a language like Mathematica, they will keep on doing that, leaving heaps of ugly code in their wake. The people taking over their code (more often than not, also non-programmers) will see this and think that it is ok - why wouldn't they? And so the cycle of very bad code continues. For that reason, I would never encourage people to use constructs that are out-of-place in the language at hand. I cannot recommend For's in Mathematica, much like I will not recommend using function pointers in C (to novices). Yes, it can be done -- but it is almost always a bad idea. 
I assume these are all linear ode's? can you give me a typical set of equations?
If it were me, I would probably write a MATLAB script for this. The Laplace transform commands should make things pretty straightforward. Once you're in the frequency domain, it's simple linear algebra, and MATLAB should handle that just fine. If this doesn't help, I have other advice but not a huge amount of time at this particular moment.
yes, the equations are dCn/dt = -2kn Cn + k1 Cn+1 + k2 Cn-1 for many n 
k thx, I debated for a looong time which math software to invest in before picking mathematica, but I guess there really is a need to own/know/use all of them for various problems. I chose mathmatica because it was supposed to handle differential equations better and matlab was more for matrices and linear algebra and this isn't an algebra problem.
Don't get me wrong, this can certainly be done with Mathematica, I can just more easily see how it would work out in MATLAB because I am more familiar with it. There are a lot of ways to go about this; the method I mentioned transforms the differential system in the time domain into an algebraic system in the frequency domain. And then an inverse transformation brings you back to the time domain, giving you your solutions. Another option may be to explicitly express the solution in general n-by-n form using the matrix exponential method.
The best solution so far: `File &gt; Save as... &gt; LaTeX Document (*.tex) &gt; Options... &gt; Typeset expression format: EPS` Each expression is saved in a separate eps file. It's hard to maintenance LaTeX code, but looks as I want.
There is a section in the Mathematica help describing this; on my Mathematica 8, it is available through the help system via "ref/file/init.m". In essence, what you are looking for is the "init.m" file. Another (perhaps better) option is to put your initialization stuff in an "Autoload" directory. The Help system's "tutorial/MathematicaFileOrganization" describes this. 
(deleed dupe)
You'll probably have better luck with the ratio test than trying to rewrite it as a geometric series. Take a look at the Convergence example on the Wikipedia page for the ratio test: http://en.wikipedia.org/wiki/Ratio_test#Examples I think that's what you're dealing with here.
Are you sure you're meaning to post this in the Mathematica subreddit? If, so, all you really need is: Sum[(n^2)/(3^n), {n, 1, \[Infinity]}] 
You won't be able to get in that form directly. As others have said, you can just stick it in using Mathematica and find answer. Here's a way I might do this sum by hand though, first that comes to mind. Let's consider the more general Sum[ n^2*x^n ] (all sums from 0 to infinity). Now, we know Sum[ x^n ]= 1/(1-x). If we differentiate this, we get: Sum[n*x^(n-1) ] =D[1/(1-x)]. (where D is "differentiation by x". Multiply by x: Sum[ n*x^n ] =x*D[1/(1-x)] Repeat this again to get: Sum[ n^2*x^n ] = x*D[ x*D[1/(1-x)] ] = x(x+1)/(1-x)^3 We want to find this at x=1/3. Put x=1/3 in, you get: Sum[ n^2*(1/3)^n ] = (1/3)(1/3+1)/(1-1/3)^3 = (4/9)/(8/27)=3/2, which is correct answer. I've been a bit fast and loose with checking that these sums actually converge; however, within the radius of convergence I think we can play dangerous like this :P. tl;dr: Apply the operator x*D[] to 1/(1-x) twice to get an expression for Sum[ n^2*x^n ], put x=1/3 into sum. 
In Mathematica there are several ways to remove information attached to a symbol. **Unset** (normally written as =.) is used to remove a single transformation rule. So for example Unset[f[a,x _ ]] (or equivalently f[a,x _ ]=.) removes exclusively the rule that transforms f with two arguments, the first one is the literal a, and the second some named general pattern (the name of the pattern can differ, that is, that command would also remove any definition associated to f[a,z_ ]). **TagUnset** is like Unset but you can specify the symbol to which the transformation rule is attached (with Unset it will be assumed that it is the first symbol of the transformation). For example f[g[a]]=. would remove the transformation of f[g[a]] associated to the symbol f, while g/: f[g[a]]=. would remove the transformation of the same expression associated to the symbol g. **Clear** removes all the transformation rules associated to a symbol (that is, its DownValues, OwnValues and UpValues will become the empty list) but it maintains the attributes of the symbol. **ClearAttributes** removes the attributes maintaining the transformation rules. **ClearAll** removes both attributes and transformation rules. It renders the symbol as clean as when it was born. **Remove** completely kills the symbol, and you should use it to liberate the memory associated to the symbol, only if you don’t intend to use the symbol again. To understand why this command is different from ClearAll it’s convenient to consider how Mathematica processes code. When Mathematica reads an input line, it generates a tree of numbers, strings and symbols. Some of the symbols will already be known by the system, the rest will have to be created. So a region of memory will be assigned for the symbol, where the name of the symbol will be stored and space will be reserved for possible information that may be attached to the symbol in the future. If you use ClearAll you just delete the data attached to the symbol, while if you use remove, the memory reserved for the symbol will be liberated, so if later you use a symbol with the same name, it will be necessary to repeat the process of creation. In particular you should avoid removing a symbol and then using it in the same line. Compare these two results: In[1]:= x=1; ClearAll[x]; x Out[1]= x In[2]:= x=1; Remove[x]; x Out[2]= Removed[x] 
Wonderful reply, thanks! This is quite a bewildering array of options for a seemingly simple operation. One must really have a good understanding of Mathematica's system of upvalues/downvalues/ownvalues and attributes to understand the subtleties, I suppose. It is fortunate that you don't encounter these things a lot unless you do deep development. It is quite bizarre to see the behavior in your last example. The fact that x=1; Remove[x]; x; behaves differently from x=1; Remove[x]; x; Iooks rather unclean to my programmer's eye, and it is a bit of a surprise -- I didn't consciously realize that a "newline" actually instructs the interpreter to evaluate its input, but it is logical when you think about it. However, I do not see the point of the Removed[] construct; what would go wrong when removing the symbol from the symbol table immediately upon executing the Remove[]?
The symbol is removed from the symbol table, and for consistency it also has to be removed from the line that it is being evaluated. Using the command FullForm we can see that Removed[x] does not actually contain the symbol x, it just references the name of the symbol: In[1]:= Remove[x]; FullForm[x] Out[1]//FullForm= Removed["x"] 
&gt; for consistency it also has to be removed from the line that it is being evaluated. I don't understand why. Why not simply remove the symbol from the symbol table, and re-introduce it if the user is foolish enough to reference it again after the Remove[]? 
Expressions only contain the addresses of symbols, they don’t store other information like its name or transformations associated to it. That is not a problem because if you want any of the information of that symbol Mathematica will simply have to follow the address and retrieve it. For example if you write SymbolName[x] it will return the name of the symbol “x” even though the x itself has been lost in the parsing and replaced by an address. However when Mathematica evaluates a line like *Remove[x]; f[x]*, it first removes all information pertaining to that symbol so the subsequent references to that address lead to nowhere. To avoid this, before a symbol is removed, all the references to it (whether in the expression that is being evaluated or in the transformation rules of other symbols) are replaced by Removed[“NameOfTheSymbol”]. It should be noted that when Mathematica removes symbols, the expressions Removed[“x”] act as symbols. For example if you write manually: Module[{Removed["x"]=3}, Removed["x"]+1] Mathematica will complain claiming that Removed[“x”] is not a symbol. However if the same expression is generated by the removal of x there will be no problem: In[1]:= f:=Module[{x=3},x+1] In[2]:= Remove[x] In[3]:= OwnValues[f]//InputForm Out[3]//InputForm= {HoldPattern[f] :&gt; Module[{Removed["x"] = 3}, Removed["x"] + 1]} In[4]:= f Out[4]= 4
Again, many thanks for the explanation. It makes me think about what is going on under the hood in Mathematica, which is really interesting. What I failed to fully grasp (and your post made clear) is that the line x=1; Remove[x]; x; is, in the end, a *single* CompoundExpression. After parsing and before execution, the symbols have already been replaced by their addresses, as you point out. It all makes sense, now - sort off. This reminds me of the problem in SQL databases where a "DELETE" of a row may mean that something that is being referred to in another table is deleted. The SQL solution is to either refuse the delete, or (using the CASCADE option) to delete also all rows that are dependent on the deleted item. The Removed[] construct in Mathematica is another solution to a very similar problem. Also, while I still feel that the resulting behavior is a bit counter-intuitive, I cannot come up with a better solution. &gt; Out[3]//InputForm= {HoldPattern[f] :&gt; Module[{Removed["x"] = 3}, Removed["x"] + 1]} Wow, that's pretty bizarre. In the end that seems to be a consequence of Mathematica's use of a single global symbol table. I've always felt that the way symbols are generated inside modules feels a bit kludgy, which is also a consequence thereof... It might have been much cleaner to have local symbol tables attached to expressions, or something along those lines. But I am probably not seeing the entire picture.
When you specify the path, use a period with your directory separator. "./testDirectory/testSubdirectory/file.txt" The period means the current working directory. *Directory[]* shows it, *SetDirectory* sets it. Going directories upwards can be achieved by using two colons. For example, if the working directory is *C:\users\johndoe\documents\\* then "./../../janedoe/documents/file.txt" tries to access *C:\users\janedoe\documents\file.txt*. EDIT: formatting error
I think there is no indefinite integral to be found with the current algorithms. Also [integrals.wolfram.com](http://integrals.wolfram.com/index.jsp?expr=exp%282*x%29%2F%285+%2B+3*exp%28x^3%29&amp;random=false) can't solve it either.
ah of course. thanks!
use a dynamic slider that adjusts the independent variable in the equation?
eg: f[x_] := x^2 {Slider[Dynamic[x], {-10, 10}], {x, Dynamic[f[x]]}}
http://reference.wolfram.com/mathematica/ref/NotebookDirectory.html
You can define cells as Initialization Cells, then Mathematica asks you if you want to evaluate those the first time you evaluate a cell.
I just wanted to point out that you can use NIntegrate to evaluate a definite integral with specified bounds, if that is ultimately what you are looking for.
Thank you. The command I was looking was : SetDirectory[NotebookDirectory[]] And then I could use: data = ReadList["./file.txt", Number, RecordLists -&gt; True]
Didn't work. Any new ideas?
You ever tried Maple? Maybe they pay more attention to quality? I don't know too much about it but their built in programming language really turned me off last time I checked. Maybe it's worth looking at because I don't see Mathematica improving quality in the future.
"s" is not defined as being i*omega in Mathematica. Also, you're deriving the inverse Laplace transform as a function of t, not x. So correcting these 2 mistakes your input becomes; InverseLaplaceTransform[(1/((I*\[Omega])^2 + 1))*(1/E^(Sqrt[I*\[Omega]]*x)), s, x]//TraditionalForm Which gives you DiracDelta[x]/(E^(x*Sqrt[I*\[Omega]])*(1 - \[Omega]^2))//TraditionalForm as a result. = Copy paste these to Mathematica and use //InputForm to see what functions are used.
Let me try to explain a little bit more, and I think that trying to make mathematica do an inverse laplacian of a function might be too much work. It turns out that my solution could be turned into a convolution of the laplace transform, so now it's a matter of trying to get mathematica to compute: (f*g)(x)=Integrate[f(t)g(t-z),{z,0,t}]=Integrate[f(t-z)g(t),{z,0,t}] Either one of the integration function works. where f(t)=Sin(t) and g(t)= http://www.wolframalpha.com/input/?i=%28x%2F%282Sqrt[%28pi%29%28t3+%29]%29%29%28e%28%28x2%29%2F%284t%29%29%29 (did it this way since it wasn't showing up right on Reddit, be sure to copy/paste) I've already tried getting it to do it, and it'll hang on that and just give me the integral in traditionalform as an output without evaluating anything. Is there a way to numerically integrate it? I just KNOW there has to be a way of getting a visual of this thing.. FYI: I need a function of x and t, since my solution u(x,t) describes the temperature of a rod
 Convolve[(x*(E*x^2))/((2*Sqrt[Pi*t^3])*(4*t)), Sin[t], t, notx] NIntegrate does numerical integration.
That would work if the Laplacian convolution had integration bound of negative infinite and positive infinity, but it's from 0 to t.
The unilateral Laplace transform has integration bounds from 0 to infinity. Is this the equation you want to calculate: http://mathbin.net/63290 ?
yes! The only problem is that in my book the convolution of the laplace transform goes from 0 to t...
The handwriting recognition systems are keyed to plan language dictionaries and do poorly with Mathematica. Get a device with a keyboard, you'll be much more productive.
There is a chapter about debugging (and using the debugger) in Mathematica cookbook by Sal Mangano (O'Reilly edition, if I recall correctly).
I expect this to not be the best solution. Be warned. Some time ago in university I solved a similar problem with data = Import[filename, "Table", "FieldSeparators" -&gt; {";"}]; ListPlot[Map[{#[[columnindex1]], #[[columnindex2]]}&amp;, Rest[data]]] FieldSeparators might be set to " " or "\t" (tab-delimited) depending on the file you are using. If landmass were in the second column and population in the fifth, columnindex1 and 2 have to be replaced by 2 and 5. The *Rest* is used to get rid of the first line, which I included in the table in order to still be able to get an annotated table. For extensive calculations this looked very ugly as is involved throwing around a lot of column indexes and mappings, but it did the job. I can't point you to any guides about handling tabular data with Mathematica but a lot of your mentioned points of interest might be solved with *Select* Select[Rest[data], #[[2]]&lt;600000&amp;]
To plot the landmass against the population: {titles, data} = {First[#], Rest[#]} &amp;[Import["file.txt", "Table"]]; ListPlot[data[[All, {5, 2}]]] To delete duplicate entries: DeleteDuplicates[data] To group entries with the same country: SplitBy[data, First] To find the percentage of countries with less than 600000 km^2: 100. Count[data, {_ , _ , _ , a_/;a&lt;600000,__}]/Length[data] To learn how to extract useful information from data I would use the help within Mathematica. You could start with the function Cases, and follow the links in the "SEE ALSO" section. The main point you have to take into account is that in Mathematica a matrix (or table) is a list of lists (rows), and many of the functions used to find the structure of a Mathematica expression (such as Cases, Count, Select, MemberQ...) will by default (that is if you don't specify depth levels) treat any expression as a list.
Assuming you're running Mathematica 8: You can tell Mathematica to use various commands to make this work. In my case, I used ssh tunneling to connect to remote machines with more processing power. My laptop is running windows 7 with cygwin installed the remote machines I use are all either Linux or OS X, with only port 22 available. Open Mathematica &gt; Evaluation &gt; Kernel Configuration Options &gt; Add Select the "Advanced Options" radio button *Arguments to MLOpen: -LinkMode Listen -LinkProtocol TCPIP -LinkName 31415@127.0.0.1,31416@127.0.0.1 --LinkMode Listen -LinkProtocol TCPIP -LinkName 31415@127.0.0.1,31416@127.0.0.1 -LinkOptions MLDontInteract *Shell Command to launch kernel: C:\cygwin\bin\ssh.exe -R31415:127.0.0.1:31415 -R31416:127.0.0.1:31416 user@remote.machine.ip.address "/Applications/Mathematica.app/Contents/MacOS/MathKernel -mathlink -LinkMode Connect -LinkProtocol TCPIP -LinkName 31415@127.0.0.1,31416@127.0.0.1 -LinkHost 127.0.0.1" This example connects to a remote Mac; for a remote linux machine you would substitute /Applications/... for the output of 'which math' on the remote linux box. If your laptop is running Linux or OS X, you can replace C:\cygwin\bin\ssh.exe which the output of 'which ssh' on your laptop. You can add a -p# flag to your "shell command" where # is the port the remote machine is listening for ssh on. You can also use a similar configuration to set up parallel kernels (ymmv) It's worth mentioning that this *requires* you to generate and store password-less ssh-keys on your laptop. Hope this helps.
You can probably get that data straight out of Mathematica: http://reference.wolfram.com/mathematica/ref/CountryData.html.
It works but not as well as one would hope. Best bet is to get good at typing them. I am using an hp touchsmart tm2t-1000.
You are looking for the Manipulate function. It is perfect for this purpose, and I have used it for such. If you want help or can't get the documentation worked out, feel free to send me an email and I would be glad to even make something for your purposes. I really enjoy coding in Mathematica and practicing.
Try looking at the [wolfram demonstrations project.](http://demonstrations.wolfram.com/). Many good interactive tools pre-built or you. For instance, [this one](http://demonstrations.wolfram.com/SineCosineTangentAndTheUnitCircle/) is take on an old reddit favorite, the transcendental functions and unit circle. You can download the source notebooks for any of the wolfram demos and see how they work. Additionally, check out the "Introduction to Manipulate" tutorial in the help section of mathematica. Cheers!
What does that even mean?
What does that even mean?
When you say, "x=3", you change the kernel state. The kernel now knows the name "x" and binds it to the number "3". maybe it used to be 2, or maybe it used to be unassigned. Undoing the kernel state would mean rolling back the binding of x to what it was before you ran the command x=3.
Oh yeah, unrolling the kernel state would so useful because I end up with &gt; Clear["x"] statements everywhere when I am trying something out. Either that, or restarting Mathematica.
You need to use module. It allows for local scoping so this doesn't happen. x=10 Module[ {x}, x=somesuch (* somecodewithx *) ] x==10 (* True *) Generally I use it for functions, so doseomestuff[x_]:=Module[ ...
It would help a lot if you could post a complete snippet of code that doesn't work the way you were expecting. Please avoid using superscripts, since those can't be copied onto the clipboard.
Local scoping, okay. It's funny how Mathematica can barely to pretend to be a real programming language (I mean I have to work hard just to get parenthesize to look indented and everything).
Looks like you got buttslammed. Maybe this works; mankey[y1_, a1_, u1_] := Function[{y, a, u}, Evaluate[D[f[a], {a, 2}]]][y1, a1, u1]
I didn't know that the power symbol was a command char for superscript. OP will be edited when I figure out a way to print the desired character without the superscript effect. Edit: Forcing it to be treat it like code seems to have worked. 
I wanted to a give a shot at your snippet, yet my activation key expired yesterday 2^nd August (the irony). Yet i managed to get some progress out of the following expression: D[f[Array[a,n]], {Array[a,n], 2}] Being n a constant related to the number of observations performed (just to give some insight). This way, it recognizes a symbolic array of n elements and finally started giving some [nxn] hessian matrices. The irony was that this also prove to be a pain train since n = 200. So I'm now exploring a new solution that has nothing to do with Mathematica anymore. Still, thanks for the help. 
Ok, thanks. That's much better. The main problem here is that you're trying to do something in R^n, but Mathematica doesn't really have a mechanism for dealing with vectors and matrices of unknown size. You're going to have to use vectors of known size if you want to get any results, e.g. D[f[{a1,a2,a3}],{{a1,a2,a3},2}] Does this help?
It does. When I realized that, the problem became: "How am I going to create an nx1 symbolic array. I can't write {a1,a2,...,an} by myself every time I change 'n' " Array[a,n] did the trick. 
This belongs in r/math, not r/mathematica.
Try using wolfram alpha for this kind of thing: [link](http://www.wolframalpha.com/input/?i=natural+log%28sin%282.07%29%29) So it seems like you do need to enter it in radians. 
I have and I get that answer all the time...but this is is killing me because how will I'll remember that small detail when I'm writing an exam for example?
Erm, I just typed in "Log[Sin[2.07]]" without quotes and it evaluated to -0.13015. What seems to be the problem? Log with one input defaults to the natural log, and Sin by default takes its argument in radians.
did you mean to "reply to" someone else's comment? Either way, remembering Log[Sin[2.07]] should not be hard. Mathematica assumes radians unless told degrees. In the future, you ought to try the [documentation](http://www.wolfram.com/support/) for a question like this. The built-in documentation (from the help menu) is really good and lets you interact with their examples. This is something you can solve yourself with 2 seconds of effort. 
Indeed. Mathematica documentation is some of the best I've ever come across, and they have some really interesting/cool examples in there. And, of course, for the record, Log[Sin[2.07 Degree]] == -3.3209
From what I understand you want to do this http://dl.dropbox.com/u/2719533/plot.jpg How big is the table?
Piecewise allows a variety of conditions. I made this http://dl.dropbox.com/u/2719533/plot2.jpg I defined two functions and when plotting I tell to evaluate those functions to test the condition.
You could do this too http://dl.dropbox.com/u/2719533/plot3.jpg Create a function that depends on two parameters. The first one is used for the plot and the second one for the frequency. The table command iterates freq over those 4 values and plots the function.
I am glad I could help.
Just finished a class on pde's and using the convolution, but I am not sure what you are asking here, do you want to give an example? 
yes, just for starters, I would like to solve the inhomogenous heat equation as seen here http://en.wikipedia.org/wiki/Heat_equation#Examples but I'm having trouble even starting even with the simplest homogenous equation here http://en.wikipedia.org/wiki/Heat_equation#Homogeneous_heat_equation getting the Convolve function to work properly in Mathematica 
Problem 3: What is the largest prime factor of the number 600851475143 ? FactorInteger[600851475143] 
In Problem 99, you can completely ignore the fact that all the numbers you have to consider are huge, since Mathematica will sort them just fine. It's a pretty great program.
Curious about different approaches to primality testing? [The Fermat test](http://en.wikipedia.org/wiki/Fermat_primality_test) is curious because it's probabilistic, and doesn't always tell you the truth.
Wish I could help you with that but I've never used matlab. Sorry for that. Maybe there is a matlab subreddit.
Actually I never read a .dat file but I found this. http://amath.colorado.edu/computing/mmm/12.html It would depend on how are the datarates placed within the .dat file. But the basic idea would be this. Create a list of lists, in each sublist there would be the 12 datarates. Each of those sublists would represent the frequency I imagine. e.g datarate would have to be something like this after reading the .dat file datarate = {{datarate1},.....{datarate12}, {datarate1},....{datarate12}, .... {datarate1},....{datarate12}} When you have that list you can access each individual item by doing datarate[[x,y]] x would be the frequency and y the position. The problem here is that your frequencies arent consecutive and the valid values of x go from 1 to 12. So you would need to map the frequency you want to the position of the frequency in the list. frq[frequency_]:=Which[frequency == 7,1, frequency == 10,2,....] and so on. so your plot would become like this: Plot[{Piecewise[{{datarate[[freq[frequency], 1]], f[x] &gt;= 18.5}, {datarate[[freq[frequency], 2]], f[x] &gt;= 16.5}, {datarate[[freq[frequency], 3]], f[x] &gt;= 14.5}...........{datarate[[freq[frequency], 12]], f[x] &gt;= 3.5}}]}, {x, 0, 40}, Exclusions -&gt; None] This could be combined with the table command to do all of them at once.
No joke. I feel like I'm cheating every time I fire up Mathematica (which happens every day at work, BTW). That google problem to find the first 10 digit problem in the sequence of pi? Solved it in a few lines. Then I looked for others' answers and found code in C. Terrifying to behold.
Okay, so I've managed to do something approximating what I want to do simply by using a while loop. 
In the third equation you wrote the operator for assignment = instead of equality ==.
Yeah a while loop will do that. And if you need to call the c1's c2's etc a few time you might want tot try dynamic programming. basically: c1[n_] :=c1[n]= Integrate[f[x] Sin[n*x], {x, -Pi, Pi}] will save each value of c1[n] the first time it is calculated, then just recall that value the next time rather than recompute the integral. At the moment your code is calculating each integral at least twice, maybe 3 times
You can always tell this mistake by the 'Tag" error message
Asking it to solve the equations may not terminate, but you may be able to find out something useful from FindInstance or Reduce.
Analytically, I don't think so. You can solve the first equation for ta easily, using that solution you can find the solution to the second equation for tb. Then you can use that equation to try to solve the last equation, but it doesn't seem like a general analytic solution exists. The best you can probably do is provide FindRoot with {a,b,c,x,y,z} and guesses for {ta,tb,tc}.
QM?
don't forget to add //FullSimplify to the results, this often makes a significant difference.
I'm not sure exactly what you mean. The equation x + y + z = 1 is the equation for a plane, and the cross sections when the variables are held constant are straight lines.
Oh thats easy. First decide which variable shall be constant. Then you use a ContourPlot and thats it. E.g The equation is x^2 + Sin[y] + z = 2 You want z to be 1. Then you use ContourPlot[x^2 + Sin[y] + 1 == 2, {x, -10, 10}, {y, -10, 10}] Hope that is what you want. ^w^
Sorry, I said something different from what I meant. the actual equation is x^2 + y^2 - 2*z^2 == 4. 
I'd like to plot more than one of those on a single 3D graph, but it doesn't seem to be possible.
oh that? ContourPlot[x^2 + Sin[y] + 1 - 2, {x, -10, 10}, {y, -10, 10}] Problem solved. Simply get rid of the ==
I'm not being clear enough. If I had the equation for a cylinder centered on the xy plane, I'd like to be able to graph cross sections of that cylinder at specific values along the z axis. This would look like the skeleton of the cylinder, with single circles floating in space. In other words, I want to plot the line where the equation for a 3d surface intersects with a plane given by holding a variable constant (e.g. z=0, z=2, x=3, etc.). I'd like this to happen on a 3d plot so I could show multiple cross sections at the same time. Example, for [this](http://www.google.com/imgres?q=cross+sections+cylinder&amp;um=1&amp;hl=en&amp;client=firefox-a&amp;hs=9Bw&amp;sa=N&amp;rls=org.mozilla:en-US:official&amp;biw=1920&amp;bih=945&amp;tbm=isch&amp;tbnid=yTND6_OUXoYmyM:&amp;imgrefurl=http://www.mathsteacher.com.au/year9/ch14_measurement/14_curved/cylinder.htm&amp;docid=MA7KaoOwDxF3xM&amp;w=288&amp;h=192&amp;ei=qH15Tpb-M8aatweW2cQK&amp;zoom=1&amp;iact=hc&amp;vpx=412&amp;vpy=173&amp;dur=4511&amp;hovh=153&amp;hovw=230&amp;tx=82&amp;ty=87&amp;page=1&amp;tbnh=140&amp;tbnw=215&amp;start=0&amp;ndsp=50&amp;ved=1t:429,r:1,s:0) I'd like to have the intersection of the plane and cylinder plotted. Edit: clarity.
You can use ParametricPlot3D. For example the intersections of the hyperboloid x^2 + y^2 - 2*z^2 == 4 with the planes z==0 and x==2 can be plotted this way: Show[{ContourPlot3D[x^2 + y^2 - 2*z^2 == 4, {x, -3, 3}, {y, -3, 3}, {z, -3, 3}, Mesh -&gt; False, Boxed -&gt; False, Axes -&gt; False], ParametricPlot3D[{{2 Cos[a], 2 Sin[a], 0}, {2, Sqrt[2] a, a}, {2, -Sqrt[2] a, a}}, {a, -Pi, Pi}]}]
I think I finally understand. I wasnt sure how to do it but I found this. http://mathgis.blogspot.com/2009/02/howto-display-2d-plot-in-3d.html Using that to3D function I managed to do the following. http://dl.dropbox.com/u/2719533/contour.png Show[{Graphics3D[ to3d[ContourPlot[x^2 + y^2 - 2*1.5^2 == 4, {x, -4, 4}, {y, -4, 4}], 1.5, 1]], ContourPlot3D[ x^2 + y^2 - 2*z^2 == 4, {x, -4, 4}, {y, -4, 4}, {z, 0, 5}, Mesh -&gt; None, ContourStyle -&gt; Directive[Opacity[0.5], White]]}] I think that is what you want. 
Can I ask how you know so much about the Mathematica kernel? Really interesting post.
A young guy like me could learn a lot from you guys.
Between that and Mathematico's suggestion I got what I needed, thanks.
I've been a Mathematica user since 1997. I wrote a mini Mathematica implementation in 2004 that attracted Wolfram's attention and they paid me to consult for them on the design and implementation of a JIT compiler for Mathematica using a functional programming language (OCaml). However, I have never read the Mathematica kernel's source code and I got the stats on their code base from their web page. 
=E^(2 x)/(2 (10 + 6 E^x3)) I like to use the "basic math assistant" palette to use integrals. Makes it easier with limits of integration and over what variable to integrate.
This kinda works: Hold[a Log[b, x] + c] /. {a -&gt; 1, b -&gt; 2, c -&gt; 3} Edit: I think you want HoldForm[a Log[b, x] + c] /. {a -&gt; 1, b -&gt; 2, c -&gt; 3}
Excellent! Thanks so much!
Hmm, I'm get getting divide by zero errors because my equation is actually {a*Log[b,x] + c {b &gt; 1}} and the HoldForm seems to be interfering with that. Any ideas? Thanks again for your help.
One way to include the assumption b&gt;1 is as a condition for a function like this: f[a_, b_, c_] := HoldForm[a Log[b, x] + c] /; b &gt; 1 There is also a function called Assuming[] that you can use. There is also Simplify[], FullSimplify[], and Refine[] that take assumptions as optional arguments. I'm not really sure what you're trying to do. 
Trying to make a little widget that when given points and an equation type will use FindFit and spit out an equation. Here's the code: http://pastebin.com/DZHSettw
Post what you have so far in a notebook file.
NDSolve definitely won't work because you don't have enough initial conditions. Doing it analytically is the only way but PDEs are a bit more tricky and Mathematica can't automatically do it because it is non-linear. It is however separable so if you say u[x,t]=v[x]w[t] then you can turn it into two (non-linear) ODEs which Mathematica may be able to solve
I added more info in the OP. Thanks!
I remember doing that with some linear PDEs earlier. The book has a certain way of solving the shock wave equations which I'm following and doing with Mathematica. It seems to be working. I've put my .nb file in the OP if you're interested.
That doesn't work? (the way you have it written down)? It works for me...
I make no guarantees of the optimalness of this solution, nor can I be held responsible for anything you do with it, but I think I've hacked together a pretty clever solution. Basically, you're trying to join a bunch of strings together with intermediate values in a series of combinations. I'll walk you through the steps (which may or may not work entirely on their own), then tie it together in the end. Table[] is kind of Mathematica's bread-and-butter, and it's kind of helpful for combinations, so we'll use that. First thing's first, though, we need to do some preprocessing on your key. Let's say, strings = {"123", "4-5", "678-", "9123-45", "67-89", "12-345", "6-", "7"}; Those are just the parts of the key that remain static, so I just pulled them out for easy reference. Now's where things get a little hairy, though. Riffle[strings, {a, b, c, d, e, f, g}] Basically takes two lists and riffles them like cards. So the output of this guy is {strings[[1]], a, strings[[2]], b, strings[[3]], c,...} but remember, in this case, a, b...g aren't strings, they're *variables*, which we'll fill in with the correct strings later. Up to what the variables actually *are*, we basically have our solution. We just have to put it all back together into one big string. Fold[#1 &lt;&gt; #2 &amp;, "", Riffle[strings, {a, b, c, d, e, f, g}] does just that (this won't work by itself because how to join a variable to a string is rather undefined. We fix that by wrapping this guy in a command that won't execute the fold until all the variables have been assigned character strings). The &lt;&gt; is the string concatenation operator, so what we're saying here is "Join the empty string ("") with the first thing in the list, then join that with the second thing, then join that with the third thing...". The #1 and #2 just represent dummy arguments to the &lt;&gt; function. Finally, we have to sub in the appropriate lowercase and uppercase letters for the variables. Take the whole thing here and shove it into a Table[] like so: Table[Fold[#1 &lt;&gt; #2 &amp;, "", Riffle[strings, {a, b, c, d, e, f, g}],{a,{"a","A"},{b,{"b","B"},...] Table will take the first option for all the variables a-g and enter that in a list. Then it'll work outward in in your list of arguments, so it'll take the second value for g ("G") and enter the result in a list, then it'll take the second argument for f ("F") and the first argument for g ("g"), etc, until it's enumerated all the combinations. So the final thing looks like this: strings = {"123", "4-5", "678-", "9123-45", "67-89", "12-345", "6-", "7"}; LowUp[char_] := {ToLowerCase[char], ToUpperCase[char]} varchars = Table[{ToExpression[char], LowUp[char]}, {char, CharacterRange["a", "g"]}]; (*You can use these to generate the second part of the Table[] command, just cut and paste the output *) Flatten@Table[Fold[#1 &lt;&gt; #2 &amp;, "", Riffle[strings, {a, b, c, d, e, f, g}]], ##]&amp;@@varchars The Flatten[] is just in there to bring the output back down into a single list of strings (instead of a list of lists of lists of lists of strings). EDIT: Figured out how to make Table accept varchars for loop control. Updated accordingly. 
You can still use Mathematica for ProjectEuler without cheating, just don't use built-ins that specifically solve the problems. Implement your own prime number enumerator, perhaps using the Sieve of Eratosthenes.
Thanks ChaosCon... I probably wont' be able to take a close look at this until the weekend. &gt; nor can I be held responsible for anything you do with it Nothing devious, I promise. Its just as I stated in my OP, I wrote the case sensitive key code down in all caps. I thought it would be a fun MMA exercise (still learning how to code/use MMA). 
That was mostly tongue in cheek ;) Whenever anybody on the internet says "Hey! I have a serial! Can someone fix it?" everyone always jumps to the shady thoughts.
Also, good luck with learning Mathematica! It's an absolutely amazing program. If you already know how to do some stuff in a more traditional language like C++ or python or what have you, I suggest really making an effort to learn some of the functional programming parts. They're *really* effective and cool when used right (like I tried to do above).
As far as I know, something like ARGV doesn't exist. You can pass any valid commands to Mathematica on the command line like this: ./MathKernel -noprompt -run "Print[D[Exp[x],x]];Quit[]" So maybe you could do something like: ./MathKernel -noprompt -run "yourFunction[$var1, $var2];Quit[]" Where $var1 and $var2 are variables inside a bash script. 
Or maybe make a wrapper script around mathkernel that quotes and escapes parameters and passes them as a string.
 $CommandLine is what you're looking for.
Thanks, I was really scratching my head on this one. The official tutorials have several things wrong, one of which is that they provide the code snippets as screenshots :P
Try Reduce, it works great for all logical combination/inequality.
The hobbyist edition came out to be about $300 after tax. 
I'm not an expert, but I've been using Sage for the past month or so. I believe it sends many calculus queries to Maxima, so you probably wouldn't need to use both sage and maxima.
You can probably get a symbolic solution using the Dixon Resultant. Try the CAS Fermat. Google "Robert Lewis Fermat."
If you're a student at a university, you may be able to "lease" a copy. My school sells 1-year leases for ~$25.
...R is huge as well. Of course R and Octave, etc are numerical, not symbolic. And Mathematica visualizations, controller interactivity, and built-in packages + access to live curated data are hard to top. Even monsters like SAS can't always compete.
...and to title each dot in a plot with the name of the country: ListPlot[Tooltip[#[[2;;3]],#[[1]]&lt;&gt;": "&lt;&gt;ToString@#[[2;;3]]]&amp;/@DeleteDuplicates@data[[All, {1,5,2}]]] order of 5 and 2 determines what gets plotted against what. 
Thanks for the reply. I don't understand, though - how does Chop[] come into play? In my original problem, I never used Chop. Does adding N[] somehow implicitly remove Chop[]? The basic confusion I have is, why does passing a small value to N[] seem to give me more precision than passing no value to N[] at all? 
So passing a value of p to N removes the implicit Chop completely? That's pretty counterintuitive. Passing no value to N has a default of what looks like 7 (e.g. N[pi, 7]); I thought N[exp, 3] would give me strictly a worse answer than passing no value to N. Distressed to find that is not true. 
Under "More Information" it says &gt; N[expr] is equivalent to N[expr, MachinePrecision]. http://reference.wolfram.com/mathematica/ref/N.html This is what I get: N[CDF[NormalDistribution[], -100], MachinePrecision] = 0. N[CDF[NormalDistribution[], -100]] = 0. N[CDF[NormalDistribution[], -100], MachinePrecision-1] = 1.34417907674420*10^-2174 There is something special about MachinePrecision N[MachinePrecision] = 15.954589770191003\` Also, the output is not as it seems: N[Pi, 3] = 3.14159265358979323846264338327950419993`3. (you see this when you go to use the output) N[Pi] = 3.141592653589793` Somehow 3 is more than MachinePrecision. Something strange is going on here. It turns out that the \`3 at the end of a number is a NumberMark and it indicates precision. Just a \` without a number indicates MachinePrecision. I think what maybe happening here is that a MachinePrecision number is just a plain old floating point number in memory (like in C) were as a number with with anything other than MachinePrecision is a special Mathematica object that is represented in memory by as many bytes as Mathematica deems nessary.
&gt;So passing a value of p to N removes the implicit Chop completely? That's pretty counterintuitive. My biggest grouch with Mathematica is that very small textual changes like that can cause really gigantic changes in what it does under the hood. 
&gt; Almost all functions in MMA have a default precision, ie effectively apply Chop. This is nonsense. "having a default precision", whatever you precisely mean by that, is very different from using the Chop function. 
MachinePrecision is not a number -- it is a symbol. It instructs N[] to perform calculations using default floating point precision on the platform (usually this means IEEE-754 double precision). Also, on my MM 8.0 (linux), I get different results than you do: &gt; InputForm[N[CDF[NormalDistribution[], -100], #]] &amp; /@ {MachinePrecision, MachinePrecision,MachinePrecision - 1, 3} { 1.34417907674464562466095337521379403276457`15.954589770191005*^-2174, 1.34417907674419830507308016713525255510081`14.954589770191003*^-2174, 1.3441790767441983050731`3.*^-2174 } 
using R_a = 1 and R_b = 2 just for example, you can use: &gt;`FindRoot[Exp[(-1*Pi)/Rs] + Exp[(-2*Pi)/Rs] == 1, {Rs, 1}]` which gives: &gt;`{Rs -&gt; 6.5285}`
you are a sexy sexy beast.
&gt; Somehow 3 is more than MachinePrecision. Something strange is going on here. At least I know I'm not crazy...
You are making a bunch of very imprecise and incorrect statements: &gt; If you let MMA only use the default precision it keeps something like 15 decimal places. That is somewhat true. When using floating point, mathematica defaults to the native floating point representation on the platform, which is usually IEEE-754 doubles, which usually have about 15--16 decimal digits of mantissa. &gt; If the number is less than 10-15 by default it will return 0. No it won't. Try FullForm[N[10\^-100]] &gt; Which in this case (which is why I used "effectively") is identical behavior to Chop[2.5*10-24 ,10-15 ] I don't know what you mean by "this case". Chop[x] replaces numbers by zero that are very close to zero in an ABSOLUTE sense; the default cutoff point is an absolute magnitude of 1e-10. This behavior is fundamentally different to floating point rounding behavior as performed by N[], which essentially precision RELATIVE to the magnitude of the number. The bottom line: drawing a comparison between Chop[] behavior and N[] behavior only leads to more confusion in regard to OP's question.
Note that MachinePrecision isn't a number that is "less than" 3 -- it is a symbol that is (probably) special-cased by the N[] function. It is true that N[MachinePrecision] yields a number, but MachinePrecision is not. Case in point: Head[MachinePrecision] yields Symbol.
There is no "implicit Chop". Valeen's explanation is confusing and (I think) wrong. Also, you are probably mixing up the number that the Mathematica kernel calculates vs. the number that the front-end shows you. If you want to see the actual (full) precision as calculated by the kernel, use e.g. FullForm[N[Pi]]. 
This still doesn't work: In[596]:= FullForm[N[1- CDF[NormalDistribution[], 10]]] Out[596]//FullForm= 0.` Passing a number to N does work, however: In[600]:= FullForm[N[1- CDF[NormalDistribution[], 10], 3]] Out[600]//FullForm= 7.6198530241605260659733432515993083`3.*^-24 Elsewhere in the thread, people were using CDF[NormalDistribution[], -100] as a test, but this doesn't work the same as taking 1 minus the large side of the CDF: In[606]:= N[ CDF[NormalDistribution[], -10]] Out[606]= 7.61985*10^-24 In[608]:= N[ 1-CDF[NormalDistribution[], 10]] Out[608]= 0. In[609]:= N[ 1-CDF[NormalDistribution[], 10], 3] Out[609]= 7.62*10^-24 
Can you point out which of these results you still consider strange or surprising? At first sight, all of them seem to be in accordance with my understanding of Mathematica's handling of precision and accuracy. One point to note is that (as I understand it) the N function behaves very differently when asking for machine precision (i.e., when not specifying an explicit precision, or when specifying MachinePrecision). This default behavior is interpreted to mean that Mathematica is allowed to do 'typical' floating point approximations when evaluating its argument. When evaluating 1-0.5\*erfc(-5\*sqrt(2)), for example (which is CDF[NormalDistribution[], 10]), the "erfc" will already be evaluated using a numerical procedure, with machine precision, which yields a floating point value of *exactly* 2. That is because "2" is actually the closest possible value that can be represented as an IEEE-754 floating point number to the *actual* value 1.999999999999999999999985... When specifying an explicit precision (as a number) on the other hand, Mathematica will invoke algorithms that aim to guarantee that precision, and that's why x = CDF[NormalDistribution[], 10]; N[1 - x, MachinePrecision] N[1 - x, N[MachinePrecision]] are different. 
&gt; Can you point out which of these results you still consider strange or surprising? CDF[NormalDistribution[], -10] should be the same as 1-CDF[NormalDistribution[], 10]. Passing both expressions into N[#, 3], they're equal. But passing both into N[], with no precision argument, one returns the correct answer and the other returns 0. 
N[#, 3] invokes algorithms that attempt to reach the guaranteed precision.; N[#] just evaluates the expression using native floating point precision. Let's consider what happens when we evaluate the two expressions using N[]. Case #1: N[CDF[NormalDistribution[], -10]] CDF[NormalDistribution[], -10] is symbolically evaluated, which yields Erfc[5*Sqrt[2]]/2. This expression is then evaluated using IEEE-754 precision floating point arithmetic. Essentially, this will yield the same as the following C program: #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { printf("%g\n", erfc(5.0 * sqrt(2.0)) / 2.0); return 0; } .. which is "7.61985e-24" on my linux machine. Good! Case #2: N[1 - CDF[NormalDistribution[], 10]] CDF[NormalDistribution[], -10] is symbolically evaluated, which yields 1 - Erfc[-5*Sqrt[2]] / 2. This expression is then evaluated using IEEE-754 precision floating point arithmetic. Essentially, this will yield the same as the following C program: #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { printf("%g\n", 1.0 - erfc(-5.0 * sqrt(2.0)) / 2.0); return 0; } .. which is "0" on my linux machine. The floating point value is exactly 0 now. Bad! So what happened in that last case? Double-precision floating point values can accommodate about 16 digits of precision alongside their exponent. When evaluating "erfc(-5.0 * sqrt(2.0))", which is an intermediate value needed on the way to calculate the full expression in case #2, the actual result would have to be: 1.999999999999999999999984760293951678.... The closest IEEE-754 double-precision number to this is 2; note: not *approximately* 2, but *exactly* 2. So the C function erfc() library returns the value 2, and the proceeds to calculate 1.0 - 2.0 / 2.0 which will yield 0 -- exactly. Why does this rounding business not happen in Case #1? Well because the actual result of erfc(5.0 * sqrt(2.0)): 0.00000000000000000000001523970604832105213194668650319861672700806655591392 ... This number can be approximated in IEEE-754 floating point doubles as: 0.00000000000000000000001523970604832099506509769086 Interestingly, there are even better approximations possible in IEEE-754 doubles, but the erfc() numerical algorithm as provided by the C runtime system (at least on my computer) provides this approximation that is accurate to about 14 digits. Now when dividing this number by two as a last step, the result will be something like 7.61985302e-24 I hope this explains why you see what you are seeing; it is an artifact of the limits of floating point representation of numbers, and it is not really the fault of Mathematica. You get what you asked for: a result that was calculated using the native facilities on your platform. Having said that, Mathematica *could* theoretically do better, by pre-conditioning the expression into a form that lends itself better to numerical evaluation. However, this is a very hard problem in general; no generic algorithms are available that can mold an expression to an equivalent expression that is less vulnerable to numerical roundoff, and Mathematica makes no attempt at it. The bottom line: if you need numerical approximation where Mathematica wields its knowledge to achieve a guaranteed precision, use N[#, n], with n an actual number. If you are willing to put up with artifacts that come with floating-point arithmetic, and understand if and how these artifacts will affect your calculation, just use N[#]. 
I don't think this is implemented as a standard graphics function in Mathematica. However, there is a package in the Mathematica Demonstrations that visualizes it in an even nicer way, I think: http://demonstrations.wolfram.com/MapsOfAComplexVariable/ As with all Demonstrations, source code is available. 
you can try with WolframAlpha[] function, but you can't customize it: ComplexMap[x_] := WolframAlpha[ToString[x], {{"ComplexMap", 1}, "Content"},PodStates -&gt; {"ComplexMap__Larger image"}] This will give same output as Wolfram Alpha Gamma[z]//ComplexMap
Wow -- thanks for your comprehensive reply. I believe I now understand what's going on. I wish the default behavior of N[] were N[#, 7] rather than N[#, MachinePrecision]. The only advantage of the latter is performance, sacrificing correctness. I'd rather correctness be the default!
&gt; The only advantage of the latter is performance, sacrificing correctness. One problem with making N[#,7] a default is that the "7" is rather arbitrary. I do agree that the default choice leads to hard-to-understand behavior. In a rather perverse way, the default "N" behavior is correct too, if you understand the subtleties of floating point arithmetic, and specifically the semantics of the IEEE-754 standard, which is quite explicit about the fact that it can lead to counter-intuitive results. For example, addition in floating point math doesn't obey the associative property, so (a+b)+c is generally different from a+(b+c)). This is another source of loss-of-precision that is sometimes seen in practice.
I meant to say the default should be 8 -- so chosen because that appears to be the default display precision already. Call it arbitrary, but that's what MMA does right now: N[Pi, 8] gives the same *visible* output as N[Pi]. The difference is that N[#, 8] is critically different because it's setting the magic internal flag that protects users from floating point anomalies. &gt; In a rather perverse way, the default "N" behavior is correct too, if you understand the subtleties of floating point arithmetic Huh? If there were such thing as a Mathematica apologist, I'd call you one :-). Saying "it's correct, because it does what you expect if you understand its weird, counterintuitive, and virtually impossible-to-predict behavior" is exactly the opposite of how software should behave. If MMA is capable of computing answers that work in an intuitive way, that should absolutely be the default. The *only* downside to computing this way by default is performance. But poor performance has the wonderful properties of being immediately obvious and having no hidden side-effects. N[] could then have documentation along the lines, "If your computation can be accomplished by floating point numbers and performance is critical, pass MachinePrecision, which uses the machine's native floating point format." As it is now, I was left scratching my head as to why Mathematica was giving me different numeric answers for two expressions that are mathematically identical. 
&gt; Saying "it's correct, because it does what you expect if you understand its weird, counterintuitive, and virtually impossible-to-predict behavior" is exactly the opposite of how software should behave. The behavior is rather understandable and predictable if you have some understanding of floating-point math. It isn't intuitive, but that is something that carries over from floating point math. FYI: I am far from a Mathematica apologist; I think there are several serious issues with the software -- but I think this isn't one of them.
I have detailed understanding of floating point math, but why should I have to manually analyze every expression I ever type into Mathematica to determine if it's possible to compute it using standard floating-point numbers? What is the downside to making N[#, 8] the default? This is the part of your argument I don't understand. 
&gt; What is the downside to making N[#, 8] the default? They could have done that, but I feel it's not superior, per sé. Several reasons: the 8 is arbitrary, the behavior is different from a well-established standard (IEEE-754), it is an order of magnitude slower, which will not be important for small expressions, but it will be for large numerical problems. Under current N[] 'best effort', defer-to-platform semantics, Mathematica can offload calculations to high-performance libraries (such as Intel's MKL) for large-scale linear algebra stuff, which is very useful. And for a great majority of cases, doing that is a preferable default, I think. The important thing is that the behavior is properly documented. Other that that, I don't really care which is the default.
I got Mathematica for free(for when I study there) with my University, so I'd think that you should research that first. Mathematica is a good introduction to programming, though trying out real programming languages might be a better and cheaper option if you wish to study computer science. Also, look for a double bachelor program if you think you might be able to do that, and are willing to put time into it. Maths and computer science is easily combinated. 
Mathematica is pretty slick to have around for exploring the new mathematics that you will be exposed to in university. Also, getting into the habit of trying to express problems, algorithms and models in Mathematica is a skill that could serve you well for years to come. This is what I still use it for, and I've been out of university for over 10 years. I don't feel it is a particularly good tool for programming (or learning to program) though. Mathematica sucks as an interpreted language and it is a very impure functional language. You'd be much better off to become fluent in Haskell (a proper functional language with well-defined semantics and free implementations) and apply that knowledge in Mathematica. (The reason that I feel Mathematica has ill-defined semantics is because the documentation can be *very* informal when it comes to specifying what a particular construct does.) 
If you've learning OOP already, I'd say that you don't need Mathematica for Computer Science. A friend of mine who studies Computer Science got a short introduction with Mathematica before switching over to more real programming languages. If you're really intending to study maths, you shouldn't initially consider using Mathmatica(or any way of computing) much, since you'd need to do it exact. Whilst mathematica is capable of doing that, you should too. I've only found Mathematica useful for my Physics classes, for Maths I'd resort when I was really unsure to Wolfram Alpha, as that is slightly more convenient. Whilst Mathematica might be quite important to you in later parts of your study, you will probably not need it currently. If you still doubt about getting Mathematica, you can try a free alternative, such as [Sage](http://www.sagemath.org/)(I haven't tried it personally). I personally do a double bachelor Physics and Mathematics(first year). Whilst I was doubting to do it initially because of the workload, after the first exam week, my lowest mark is a 8.7(well, I still miss one result). You do sound up for it with Computer Science, and if you can't keep up, you can normally drop one of the bachelors.
If you can get your hands on it for a good price, make sure you do ... Good luck with your studies!
Try both. Mathematica is pretty slick for playing with mathy things. I feel it has a lot of breadth, and I like the visualizations you can do with it. The documentation for it is pretty top notch, which is something you'd miss with Sage. It presents an impure functional language, with a wacky syntax, but it's not a bad start to functional programming. Check out the "Mathematica Cookbook." There's also a 30 day demo. The downsides -- I feel some of their functions don't have quite as much depth I'd like, and the add-ons that would make it useful in a production environment are expensive. Matlab / Octave is about numerical analysis. You have to formulate your problems in terms of vectors and matrices, and there's a ton of stuff to handle that. It's great for trudging through real data. Matlab has better visualizations than Octave, but Matlab is crazy expensive if you're not in school. If you like the octave way of approaching problems, you might want to play with Python and NumPy. You should also play with R, especially if you like statistics. All of these applications are pretty great for getting a grasp of things, and making sense of how things may work. I think of them as my prototyping tools -- with real code (python, c, whatever) as my implementation. 
&gt;but I don't know if I will be able to keep the pace Here's a [useful blog](http://calnewport.com/blog/2008/11/25/case-study-how-i-got-the-highest-grade-in-my-discrete-math-class/) about [study habits](http://calnewport.com/blog/2010/01/13/how-ricardo-aced-computer-science-using-his-iphone/) that I'd recommend taking a look at. It's written by a 29-year-old computer scientist who got his PhD at MIT. Check out [Anki](http://en.wikipedia.org/wiki/Anki) as well. And as far as the point of your post, I'd wait until you start university and ask your professors whether or not it's worth the investment or if your school will offer it for free. 
Mathematica is an awesome programming language that I'd use for tons of things if I could, including web programming. Unfortunately sometimes thats not possible. Maybe a Russian version is what you're looking for?
Mathematica is an awesome language. You cannot compare it to Octave/Matlab or C++ or other languages. - Mathamatica is a functional programming language. In short, it means that the programs you write are very elegant, and are similar to writing a math expression, rather than a procedurla program - It has excellent documentation, which you can use to play with it for hours and learn new math, and more mathematica - It allows things like interactive plots, which I think are indispensable for learning many new concepts - It has symbolic math. So you can solve math problems (like calculus problems), without assigning any numerical values to the variable. .. .. in short, i love mathematica, and I have played with many many languages. Only bad thing about mathematica is that I find its user interface kind of slooow...
I think Mathematica is absolutely right for you. The main advantage of Mathematica over alternatives like R, Sage and Octave is its easy-of-use thanks to a fantastic help system and the huge number of educational samples available on-line from the Wolfram Demonstrations project. This will teach you a lot of valuable stuff about all kinds of interesting subjects including mathematics and science. Beyond that, Mathematica can also teach you a lot about computer science because it is a *term rewrite* language, which is a very unusual way of evaluating programs but one that is very well suited for computer algebra. In essence, other languages are evaluated by an interpreter which has the type `expression → value` but term rewrite languages are evaluated by a rewriter which has the type `expression → expression`. This is why Mathematica evaluates `1+2` to `3` like any other language but can also evaluate `a+b` to `a+b` when other languages die with `Unknown variable 'a'`. Mathematica is not a panacea and other tools are often preferable in practice, even in the context of technical computing, and it has warts like any mature system. But Mathematica has a huge amount to offer largely because it is so different from other programming languages. In particular, make sure you understand how Mathematica evaluates programs and consider how you would implement Mathematica yourself in another language. 
can you write down five equations? If you can, just use: Solve[{EQ1,EQ2,EQ3,EQ4,EQ5},B]//TableForm
Here is an example that should help ... [Mathematica 'Series' function Tutorial](http://reference.wolfram.com/mathematica/tutorial/MakingPowerSeriesExpansions.html)
SeriesCoefficient[E^x, {x, 0, n}] will probably give you what you want: the coefficient of the term of degree n in the taylor series expansion around 0. Instead of a list of the actual expansion, which is what Series gives you, SeriesCoefficient gives you a general formula (if it can find one -- not always possible) that describes each term of the series expansion.
I haven't been able to find one either, although I was toying with the idea of making one myself based off of Monokai. I'll let you know if I ever succeed.
Thanks!
How about this? Graphics[{PointSize[#[[3]]], Point[{#[[1]], #[[2]]}]} &amp; /@ lst] As for showing the grid I found no nice way of doing it other than Show[ListPlot[{0}, PlotRange -&gt; {{0, 5}, {0, 5}}], Graphics[{PointSize[#[[3]]], Point[{#[[1]], #[[2]]}]} &amp; /@ lst]] P.S. I learned a couple of new things thanks to your code.
Thanks, it also works with Epilog ListPlot[ {0}, PlotRange -&gt; {{0, 5}, {0, 5}}, Epilog -&gt; Flatten@({PointSize[#[[3]]], Point[#[[1 ;; 2]]]} &amp; /@ lst) ]
While I'm sure a Wolfram Calculator would be undoubtedly awesome, most calculators with computer algebra system (CAS) functionality can do those things.
Do they already have an iPad/iPhone/iPod app or something? That would come pretty close, wouldn't it? Of course, the installation is &gt;3GB, so maybe having only the front-end on the device and the kernel on some network machine would probably be a better idea...
The WolframAlpha iPhone app is good enough for me. I don't think investing in a standalone device would be smart for Wolfram. http://products.wolframalpha.com/iphone/
Doesn't that require internet access though?
What college doesn't have WiFi everywhere you go?
What if I want my calculator to work in the field? Or somewhere that doesn't have wifi? Do you have any idea how much of a battery drain wifi is?
Then this app would be useless. You should bring a netbook when you are in the field.
Try an HP 50G.
In Mma, definitions are associated with a particular symbol; this can affect how evaluation proceeds. For example, you usually don't want to give new definitions to things like Times and Integrate. An upvalue allows you to tell Mma which symbol to associate a definition with. For example, if you write f[g[x_]] ^:= h[x]; then Mma will associate this definition with the symbol g. Try running "?g" to look at the definitions associated with g, and "?f" to see the definitions associated with f. This can come in handy more often than you'd expect. You might want to define the derivative of some function f without defining the function itself; instead of associating the definition with Derivative, you should tell Mma to associate the definition with your function f instead. That way Mma does not do a pattern test for f every time it runs into Derivative, but rather does a test when it only runs into f. That will keep evaluation fast. Upvalues only go so deep in level. If Mma can't figure out which symbol you'd like to use, then you instead have to write g /: some[deep[expression[of[g[...]]]]] := ... ; to associate the definition with g. EDIT: Formatting.
Cool! But where is it?
How does it work?
What you're doing here is an application of *generating functions*. It will also work if you don't stop at target, but rather take the infinite series for each of the coins, which can be expressed in closed form, and determine the coefficient of the power x^target of the resulting expression. If you invented this yourself: kudos! 
I first added default values to call to simplify expectation through quarters (somewhat force of habit). The function call changes from combinationsOfChange[target_, coinVals_ , coinNames_ ] := ... to combinationsOfChange[target_, coinVals_ : {1, 5, 10, 25}, coinNames_: {pennies, nickels, dimes, quarters}] := ... Secondly, by taking advantage of the form, if one takes the result (11 in this case) from combinationsOfChange[11] add the following syntax afterward combinationsOfChange[11] /. Plus -&gt; List /. Times -&gt; Plus /. x_^n_ -&gt; n x The outputs changes from this dimes pennies + nickels^2 pennies + nickels pennies^6 + pennies^11 to this ... { dimes + pennies , 2 nickels + pennies , nickels + 6 pennies , 11 pennies } which makes it a bit easier to read. It is easy to make a list within a list if one prefers as well. Rather than have the new result be a list of coins adds, switch the *Plus* to *List* to replace **+** with a list. One could add the *TableForm* on the backend of the statement to keep the values as a printable list for review. Or go further and parse the list into a matrix (each column vector represents a given coin amount and the row vector represents the combinations in a given coins in a set). To do this add the following syntax to the end of the statement /. MapThread[Rule, {coinNames, IdentityMatrix[Length[coinNames]]}] Doing this allows one to store the combinations as a matrix (table) and using matrix math can easily *humanize* the result to the former output listed above. I find the matrix form easier to subset the sets; for instance, "how many ways can I make 80 cents with less than 7 coins?" - would be much easier (via *Select* function) Very cool approach ... thanks for sharing!
cool. Make a mathematica demonstration and upload to wolfram.demonstration project
Mathematica treats an expression like a^b as e^b*ln(a). This means (-1)^(1/3) = e^i\*pi/3, this will give a complex root. Mathematica uses this to distinguish roots by expressing them as (-1)^1/3 , (-1)^2/3 and -1
Alright, that makes sense, thanks for clearing that up!
Also, Mathematica cannot directly solve this equation. I have no time now, but it may help to substitute z=Exp[k] and perhaps w=z^t1 .
Without this correction, Sage just rearranged the equation for me. With this correction, I get no solutions.
I substituted A=Exp[k*t2] and Mathematica gave me {}. I'm putting all of pinitial*ek*t2 in the denominator, even though it's against order of operations. I'm out.
Yes that's right sorry about that. The second exp(t2*k) must be exp(t1*k) 
Running the code gave me no problems. However, I did need to remove a "Null" which appeared after the second 3.78999999999996. Try retyping that, or alternatively using N[]?
Well, that was silly. In case anyone else is interested, Apply[And,*list*] Where *list* is the list of interest.
Note that there is an operator for apply, so you can write it this way. And @@ list 
Haha, I found the TrueQ function when I was looking for the function that I wanted. I thought to myself, "Could there be a more useless function?"
It's not as useless as you think. For example, x&lt;0 will not evaluate to False but rather stay as is. This is because x could be less than 0 or not at some point so Mathematica leaves it unevaluated. TrueQ[x&lt;0] will return False however.
I investigated and it appears to depend on the use of quotation marks. Without them, for some reason, Mathematical displays the full name of the symbol. Additionally, I see that Notation[ParsedBoxWrapper["\\[Beta]"] \\[DoubleLongLeftRightArrow] ParsedBoxWrapper["beta"]] makes that beta evaluates to β, and beta=1 makes that β is also 1. However, inputing β=2 does not change beta to 2, and beta remains equal to 1. So the Notation is a one-directional relationship. Is there a solution so that two symbols like β and beta are strictly equivalent? I put the notebook that I used to investigate the issue here: [mathematica 8 notebook](http://dl.dropbox.com/u/40987/Notation_tryout.nb)
I tried this Notation[ParsedBoxWrapper[\[CapitalGamma]]\ [DoubleLongLeftRightArrow]\ParsedBoxWrapper[gamma]] In[] gamma Out[] Global`\[CapitalGamma] In[] \[CapitalGamma] Out[] \[CapitalGamma] In[] Information[gamma] Out[] Global`gamma Notation creates a pointer from \[CapitalGamma] to gamma, but there is no pointer from gamma to \[CapitalGamma]. Set[] (or =) deletes the pointer and assigns a new value. I think it is impossible to do this with Notation[] not sure if mathematica allows what you want to do 
8.0.0.0 on Mac os x 32 bit... I tried again, same story. I put the notebook here if you want to see: http://dl.dropbox.com/u/40987/Notation_robust.nb
tried on Windows 7 and Ubuntu, still get different result maybe this feature was implemented only on os x can you try this code on your computer [http://dl.dropbox.com/u/28994831/nt-test.nb](http://dl.dropbox.com/u/28994831/nt-test.nb)
Pretty funny actually. I evaluated your notebook, and as expected, in the end: Information[ss] 3=2 Information[vv] 2=3 see: http://dl.dropbox.com/u/40987/Notation_nt-test.nb
 I changed x^b to (x^b )+a, because without parameter a options {a-&gt;b+1, b-&gt;0} will always evaluate to x^0 probably not the best solution, it will be more complex, if there are more than 2 parameters f2[val_, OptionsPattern[{a -&gt; 1, b -&gt; a - 1}]] := Module[{a1, b1, ReplacePart2}, ReplacePart2[fn_, x_, y_] := ReplacePart[fn, Position[fn, x] -&gt; y]; a1 = ReplacePart2[OptionValue[a], b, OptionValue[b]]; b1 = ReplacePart2[OptionValue[b], a, OptionValue[a]]; val^b1 + a1] f2[3, a -&gt; b + 1, b -&gt; 0] Out: 2 f2[2, a -&gt; x + b, b -&gt; y] Out: 2^y+x+y f2[2,b -&gt; x + a, a -&gt; y] Out: 2^(x+y)+y
What you're doing wrong is using `D[expr[duty], duty]` and trying to evaluate it at some value of duty=5 by effectively writing `D[expr[5], 5]`. Mathematica can not take a derivative with respect to 5 -- that doesn't make any sense. I recommend using Derivative instead. Then you want something like `Derivative[1][f][x]` for what we usually call `[; \frac{df}{dx}\Big|_{x=5} ;]`. Check the documentation on Derivative.
Are you saying because I used the := operator this happened?. The idea was to evaluate the derivative using D and then on the next line assign a value to Duty to evaluate it. I still don't quite always know when I'm supposed to be using :=
Writing `f = expr` means for Mma to immediately evaluate expr, and then assign the resulting value to f. Writing `f := expr` means for Mma to leave expr unevaluated, and then when the value of `f` is needed, to replace `f` with the expression `expr`. The most common usage of this is with "functions" which are really assignments of the form `f[x_] := expr[x]` where `x_` is a `Pattern`. What happened here is because of evaluation order, which is related to using delayed assignment, but is not the only thing that's going on. Basically, you would never write `[; df/d5 ;]` in traditional mathematical notation. This notation is a little ambiguous. A better notation is something like `[; (\partial_{1} f)(5) ;]`; this means: there is a function `f`; there is a new function `[; \partial_1 f ;]` which is the derivative with respect to the first slot of f; `[; (\partial_{1} f)(5) ;]` means to stick the value 5 into the slot of the new function `[; \partial_1 f ;]`. This is exactly what Mma accomplishes with the more verbose function Derivative[1][f][5].
NIntegrate expects numerical values for the limits, but NDSolve tries to symbolically preprocess the expression (or something like that). Try this: f[tm_?NumericQ] := NIntegrate[dist[t], {t, 0, tm}]; FindRoot[f[tmax] == .95, {tmax, .5}][[1,2]]; Or replace the first line with f = NDSolve[{y'[t] == dist[t], y[0]==0}, y, {t,0,1}][[1,1,2]]; if speed matters, it should be faster.
Thanks a lot, this was exactly what I was looking for. I changed your second suggestion to f = NDSolve[{y'[t] == dist[t], y[0]==0}, y, {t,0,10}][[1,1,2]]; since there is no reason to assume that the value of t I'm looking for is contained within (0,1) (it's actually close to 3). Of course, the disadvantage is that you still need to specify what region of t you should search, so I like the first method you gave better. Again, thanks a bunch!
At least for your example problem it is possible to state the problem symbolically and get a closed-form symbolic answer: sol=Solve[Probability[x &lt; xb, x \[Distributed] GammaDistribution[2, 2/3]] == 95/100, xb] Now you can use the built-in numeric evaluators for an arbitrary-precision result: N[xb /. First[sol],50] This may also work for other distributions.... The new probability framework is pretty powerful.
Thanks for your insight. I specifically want to use numerical results, since I have no clue what type of probability distributions I am going to use. I can imagine there being probabilities without a closed form solution for the cumulative distribution (and I guess Solve doesn't work then) , and I would also want to allow normal functions to be used as if they are probabilities (i.e. probabilities without a name, such as dist[t]=-3/2 t^2 +3/2 for 0&lt;=t&lt;1 ). There's probably ways around that all, but I don't need exact answers anyway, so am more comfortable with using NSolve and FindRoot and those type of functions.
When f is undefined, f[x] is simply f[x]. You think of Mathematica expressions as lists where the head (f in this case) is the 0th element, and the rest of the list is comprised of the arguments. So in this case, it is sort of like you have a list (f x) where the first element has index 0. I suspect that you have accidently clobbered your definition of f. To check this try looking at just the value of f[x] for some value of x. Also you may want to check DownValues[f].
Pejoculant is right here. Forget about your ODEs or anything more sophisticated... This is just straight syntax. In a fresh kernel, f[x,y,z], say, is represented as a list with elements «f,x,y,z» where the first element is the Head of the list (index is 0) and the remaining elements are the arguments, in this case x,y,z. Indexed starting at 1. When you do f[x][[1]] you are asking for index 1 of the list, or x. f[x][[2]] would be y, etc etc. You're just asking for different parts of the expression. In the ODE case here, are you trying to use f[x] before you've actually computed/solved for it? 
which means that it doesn't have a definition, so this is what you would expect...
Ah hah- you're confusing matrices (list of lists, indexed with [[...]]) with function arguments, via [...] perchance. f[1,2][x_]... is a perfectly OK function but once you get 'f' it isn't a list of functions anymore, just a bunch of DownValues of f f[1,1][x_]:=x f[2,2][x_]:=x^2 f[1,2][x_]:=0 f[2,1][x_]:=0 ?f Global`f f[1,2][x_]:=0 f[1,1][x_]:=x f[2,2][x_]:=x^2 f[2,1][x_]:=0 So, you don't really have 'f', you've got 'f[a,b]' where a,b are your arbitrary indices (you could make them anything and, as long as you reference them that way). Sorry if this isn't totally clear. I'm in between classes writing up a syllabus for the next one :) 
Well, there are 17 independent components in total, and the equations are quite long, so it's going to be a bitch, but I'll see... thanks everybody. Edit: I absorbed the list index in the arguments, such that f[1,2][x][[1]] becomes f[1,2,1][x], and so on. This seems to work.
When I finally got my head around the fact that **everything** in *Mathematica* is a list I realized just what a powerful concept that was. Functions like Map, Thread, and Apply totally rock.
Even Lists are lists in this sense. {1, 2, 3}[[0]] gives you List
You have to rerun the cell containing the definitions. You can: 1. do it manually 2. Go to Evaluation -&gt; Evaluate Notebook to do all cells at once 3. Right-click the cell tab (right of the notebook) and click "Initialization Cell" to have it auto-load when the notebook opens.
3 is exactly what I needed, thanks.
You can also all the definitions associated to a symbol (useful in the case they take a long time to calculate). Save["file.dat", f] then you can load it back with Get["file.dat"] See: http://reference.wolfram.com/mathematica/ref/Save.html
 Integrate[E^(-(x^2/s^2))/Sqrt[-r^2+x^2],{x,r,r0}]
Actually what I did was copy your formula straight into mathematica which screwed up the exponents. I tried it again and indeed it can't be integrated. it's probably best to copy as plain text, then paste into reddit but start the line with 4 spaces to prevent re-formatting. you may have to resort to numerical integration, or some other way of approximating the result. you probably won't be able to find an exact closed form solution to this integral. *probably* 
You can grab individual elements of a list by including [[i]] after the name of the list, where i is the i'th element of the list. So if you wanted to create a list that contained each element of the 2 lists in a pairwise manner say something like listpair= Table[{liste[[i]],listpi[[i]]},{i,1,1000}] 
 Cases[Transpose[{pidigs, edigs}], {x_,x_}] ?
Here's another version that doesn't use an If statement (as requested) but doesn't tell you the positions of the matches. It only tells you how many matches there are. Length[Select[MapThread[#1 == #2 &amp;, {list1, list2}], # == True &amp;]]
Ah, here we go. This maintains index information while not using the If statement: Length[Flatten[Position[MapThread[#1 == #2 &amp;, {list1, list2}], True]]] You could get rid of the Flatten if you didn't care that the indexes were 1-element lists. Remove the Length and Flatten and you'll see what I mean.
Well you'll have to set your variables properly first. I used: list1 = Table[RandomInteger[9], {i, 1, 1000}] list2 = Table[RandomInteger[9], {i, 1, 1000}]
After formatting the exponents, I keep getting errors when I adjust the t variable, and the T slider doesn't seem to do anything. I'm not sure what you're actually trying to do, but it looks as though you're trying to show a moving particle + the potential it's in. If that's the case, there might be a better way to draw the potential with RevolutionPlot3D. If you can tell me more about what you're doing, I can try to offer some better assistance. EDIT: Thanks, iamtravis. I didn't see that initially. Here's a simple fix I came up with; naively, I just switched out the parametric plot for a Line[] object. x[t_] := 10 Cos[.2 Pi t] f[r_] := -(Power[2.2510, -.005]/r) + (Power[9.8210, (-2.7)])/r^9 pot = Line[Table[{r, f[r], 0}, {r, 0.01, 10, 0.01}]]; Manipulate[ Graphics3D[{ Dynamic[Sphere[{x[t], 0, 0}, 0.2]], Sphere[{0, 0, 0}, 0.2], pot }, ViewPoint -&gt; {0, 0, 4}, Boxed -&gt; False, PlotRange -&gt; {{-1, 11}, {-5, 5}, {-5, 5}} ], {t, 0, 10}, {T, 0, 10} ] 
Are you sure that you need all of the 3D stuff here? It appears that you only vary things in 2 dimensions. The 2d version of this doesn't appear to suffer from that problem x[t_] := 10 Cos[.2 *Pi* t]; Manipulate[ ParametricPlot[ {r, -((2.2510^-0.005)/r) + (9.8210^-2.7)/r^9}, {r, 0.001, 10}, PlotRange -&gt; {{-1, 11}, {-5, 5}}, Epilog -&gt; { Disk[{x[t], 0}, 0.2], Disk[{0, 0}, 0.2] } ], {t, 0, 10}, {T, 0, 10}] 
Thank you I think this is exactly what I needed! The explanation of my weird-as-heck code is as follows: the T slider is only a placeholder right now - it will eventually control the y-value of a horizontal line which intersects the other curve at two points. The moving particle will oscillate between these two points representing an increase in temperature as a corresponding increase in amplitude, distance, etc... You've been a huge help! Thanks! =D
Thanks for the reply! I simply decided to use spheres here since they look spiffy but you're right - I probably should have at least tried the 2D stuff to see if it was more compatible. Regardless, I believe ChaosCon has fixed the solution as it is so I'll probably just use that. Thanks for the help! =)
Did you make sure to include the backqoute at the end? &lt;&lt;AutomaticUnits`
Give more information about where exactly you installed it, what $UserAddOnsDirectory returns and what command you use to load it in.
type it manually pressing ctrl + shift + - PlotLabel -&gt; "\[Mu] vs.\!\(\*SubscriptBox[\(b\), \(n\)]\) by GoldenBears"] without the Style works fine to me
Bring 'em all back!!!
I use Mathematica every day and I had no idea it could do this. This is going to waste a lot of time.
I just learned about it today. I also learned about Sound[] and Play[] today.
Please, don’t use *For* to loop in Mathematica. *For* doesn’t bind the variables, so if you had *n* already defined, that line would have spoiled it. The most Mathematicy looping construct is *Do*, since it uses the same variables specification as *Table*, *Sum* and other commands. In this case you don’t even have to specify a variable: Do[Speak["Get out of my bed"], {1000}]
There's an incest joke somewhere in there.
I first tried While[0==0,Speak["Get out of my bed"]] She was just about to leave so I closed the kernel. She saw it was still going and started laughing so she got back into my bed.
Is there any particular reason you want to use a loop? Why not: ob = RandomInteger[{1,10}, 10]; Then you can access its contents by ob[[1]] ob[[2]] etc.
 Do[ob[j]=RandomInteger[{1,10}], {j,0,9}]
Mathematics is a functional programming language. If you are using loops, you are most likely doing it wrong. 
Regarding the last part: NDSolve gives the result as an substitution rule, like {{y-&gt;InterpolatingFunction[...]}} This in case there are multiple solutions and/or multiple variables. But if you already know there is only one solution and one variable, you only want that InterpolatingFunction part. [[1]] would give you {y-&gt;InterpolatingFunction[...], [[1,1]] gives you y-&gt;Interpolating Function[...], and [[1,1,2]] gives you just InterpolatingFunction[...]. Regarding your first question, I don't really understand what you are trying to do here. The code I posted 27 days ago does solve for the upper limit.
I have a similar problem to the above post. I have NIntegrate[dist[t],{t,a,b}]==c, where c is given and either a or b are the limits to be solved and the other is given. I don't need a code to determine which variable to solve for, I only need to input the values and get a result. Just wondering how to achieve this. sorry for posting on an old post, I am just trying to avoid cluttering the subreddit with similar posts. The dist I have is dist[t_, p_,r_] := ((1 + (-t^(p - 1) /(r^p - t^p )^((p - 1)^)/p) ) ^p )^(1/p)) r and p are given as well. Basically I'm finding a limit given an arclength of a p-circle in an L_p norm.
try asking here http://mathematica.stackexchange.com/
In 8.0.1 on a mac, there's a menu item for deleting the outputs, Cell&gt;Delete all output. If you really want to change the way it saves, you might be able to find something in the Option Inspector (in the format menu).
Thanks, that's a start. Manually deleting all outputs gets to be a bit tedious. And sometimes I accidentally delete an input. With the silly only-one-undo-step, that can be annoying. I've looked through the Option Inspector, but didn't find anything at first glance. I'll ask over at stackexchange like Coder8 suggested and report back if I find anything useful.
Thanks, I was looking at that before, but i found that they already had a gui on the wolfram alpha site that i used
TIL. Also this was fun: n = 2 \[Pi]; Dynamic[{Show[Graphics[{Orange, Disk[{0, 0}, 1, {0, n}]}], Graphics[{Opacity[0], Rectangle[{-1, -1}, {1, 1}]}]], Speak[Round[(n*time)/(2 \[Pi])]];} ] s = 0; time = 10; sm = 1; RunScheduledTask[n = n - sm*(2 \[Pi])/time, {sm, Round[time/sm]}];
NSolve[(x - a)^p + (y - b)^p == r^p &amp;&amp; (x - c)^p + (y - d)^p == r^p &amp;&amp; (x - e)^p + (y - f)^p == r^p &amp;&amp; r &gt; 0, {x, y, r},Reals] I think that should work.
I don't get it... It doesn't even work for a=77, b=36, c=85.
hola mundo
I guess I was hoping that wouldn't be the case, but should have expected as much... I suppose I'll just have to suck it up and put in the time. Thanks!
You really need to undo all the damage Matlab has done to your brain cells. Forget you ever knew Matlab, and then approach Mathematica with a clean mind. I think the built in tutorial and help is good enough to get you started. I think the name of the game in Mathematica is functional programming. Mathematica really is Lisp in disguise. Everything is a list. just remember that. 
At it's core, Mathematica is based on pattern matching. Whenever Mathematica encounters an expression that it has a transformation rule for, it attempts to apply that rule. It repeats this until it finds no more transformations, then returns the results. For example, if I define f[x_] := x^2 what it is actually saying defining a rule that says "when you encounter an expression of the form f[ *something* ], take that something and substitute it in for x on the right hand side (giving *something*^2). Strictly speaking, x_ is usually called a named slot and just stands for a single arbitrary expression that will be referred to as x. := is called delayed assignment, and it means that you should wait to evaluate the assignment until a specific value for x is given. This sort of setup naturally leads to Mathematica as a function oriented language. Broadly speaking, most languages are divided into functional and procedural languages. A procedural language is based on systematically altering some overall state from an initial state to a final state (where the final state is the answer). In a functional language, the approach is more on transitioning *between* different states, where you start in an initial state, apply a function that transitions you to a new state, apply another function and so on. In other words, you're not altering a single global state, but moving between (ideally separate, but Mathematica isn't a strictly pure language in the theoretical sense) different, immutable states. Practically speaking, this means that Mathematica is oriented around application of functions to lists. Obviously, it does provide overtly non-functional constructs like Do[] and Table[] to make it easier, but the reality is that the functional approach is what is correct and will **always** be faster (it mentions this in the documentation). Eg. Instead of Table[ Cos[i*Pi], {i, 1, 10000} ] It will be a lot faster to do Map[ Cos, Pi*Range[1, 10000] ] Equivalently, Cos /@ Pi*Range[1,10000] For me, using Table[] takes a total of .017622 seconds whereas using Map takes .004739 seconds, so it's an entire order of magnitude faster (which is actually less than what it usually is, typically expect the functional approach to be between 3 and 5 OoM faster... it's just what the language is optimized for). Cos is actually listable, which means you could just do Cos[ Range[1,10000] ] and it will automatically thread, but it's just an example. Your own functions don't do that automatically. There are advantages and disadvantages to both approaches. Functional programming clicks for some people really well, others struggle. The fact that Mathematica lets you do either style is a blessing and a curse. A blessing because it makes it easy for everybody, but a curse because it belies the fact that there really is a single *best* way to do it. In essence, the procedural-style functions are largely a crutch to make using it easier. Not entirely true, because there are some legitimate uses, especially for Table[], but for for heavy-duty number crunching the functional approach is the only one. [This](http://reference.wolfram.com/mathematica/tutorial/PatternsAndTransformationRules.html) page from the documentation explains the pattern matching system, which they call symbolic programming. Also, [this](http://reference.wolfram.com/mathematica/tutorial/LoopsAndControlStructures.html) explains how to translate loops into more natural forms. Don't get caught up in their circlejerking, though... the people at Wolfram really like to pat themselves on the back. I love Mathematica and use it tons, but seriously: "Long viewed as an important theoretical idea, functional programming finally became truly convenient and practical with the introduction of Mathematica's symbolic language." That's a laughable claim to make. **TL;DR** Rule of thumb: if you access something by index on a large scale in Mathematica you're almost surely doing it wrong, double brackets are the enemy. Recursion and threaded mapping instead of loops.
F1. Only reference I've used besides the internet.
This symmmat = LowerTriangularize[matrix] + Transpose[ LowerTriangularize[matrix, -1] ]; should do the trick. Btw, I think you actually want Floor[cols/2] in your example. If you have an odd number of columns it will blow up otherwise. Also, this will only work for a square image, but what you want to do only makes sense for a square image/matrix anyway. The long and short of functional programming boils down to is 2 things * Functions should be *pure*. This means that if I call a function with a specific set of inputs it should **always** return the same outputs. In other words, it should only depend on its inputs and not any other values, e.g. global variables, contents of a file on disk, state of a random number generator etc. Mathematica is an impure functional language, which means it allows you to write impure functions if you want. Others (namely: Haskell, a few others) straight up don't allow you to. Which isn't actually as bad as it sounds, the advantages gained quite make up for it. How they handle inherently impure operations is really interesting, though it can be kinda confusing. * Functions are *first class*. Basically, this means that functions can return other functions. Hard to imagine, but once you get used to it, it can be very nice. There are some other common characteristics, especially lazy evaluation, but those two are the real defining ones. 
Also, you can compute a perfectly symmetric image by finding the nearest Hermitian matrix. This has the effect of blending the upper and lower half instead of reflecting. If A is your image, then the optimal symmetric version is given by (1/2.)( A + A^T ). Only works for square matrices as well.
It can. Please give an example of something you think should be simplified. BTW, Overdots do *not* mean derivative to Mahematica.
One thing to note is that symbols with overdots are not actually symbols, in the Mathematica sense, which is to say: the Head[] of such an expression is not Symbol. There are several situations where this makes a difference. Beyond that, you will need to provide an example for a more detailed answer. 
You used = instead of ==.
oo yes, I switched those, now it says "NDSolve::deqn: "Equation or list of equations expected instead of True in the first argument {True,True,x[0]==0.5,y[0]==0.5`"" Still one of the elements is not an equation?
"=" is assigment operator, you want equals operator which is "==".
When you wrote x’[t]=expr1, y’[t]=expr2, you defined x’[t] as expr1, and y’[t] as expr2. So the equations x’[t]==expr1 and y’[t]==expr2 both evaluate to True. Evaluate de expressions x'[t]=.;y'[t]=. and try it again.
oooo that makes so much sense. THANK YOU!
Lots of companies use Mathematica; knowing how to use it helped land me a job for the summer. The student edition is absolutely worth it, especially if you're some kind of engineer.
Depending on what you do, you may never run into a difference between Maple and Mathematica, in terms of their capabilities. I assume you have lab computers that have Mathematica installed, so that you can do your assignments for the class? Use it on the lab computers, and if you start to feel that it's worth it, you can buy it then. If you get through the course without feeling that... well, then you've got your answer.
Wolfram 
Hi avocadro, Yeah honestly that isnt the complete problem, I am just trying to learn small chunks of it one step at a time while also getting my hands dirty with mathematica - what do I have to type to have mathematica give me all the partial derivitaves in this case? That is, dH/dx1, dH/dx2, and dH/x3 ? As far as license - I am not in school anymore ...
awesomesauce! thanks!
 Ok thanks - last thing, do you know why I cant use x1, x2, x3, etc, instead of being forced to use x, y, and z? For example, my function H = x1 + x2 + x3, I do not want to use x, y and z for them... is there some simple syntax I am missing there?
You can use x1, x2, etc. The reason I didn't bother in the above was thus: in my original example, the sum was able to generate all the x[i]'s at once. I don't know how to do this when defining a function, i.e. the command f[x[i]_]:= x[i] doesn't work. One can, however, define functions on lists. I could, for example, write f[L_] := Sum[Abs[L[[i]] - L[[j]]]^p/p, {i, 1, Length[L]}, {j, 1, Length[L]}] Next, define L= {x1,x2,x3, xn}, and evaluate f[L]. Does this help?
It is possible to use Abs function, if it is used together with FullSimplify and Element function. Of Course it will not work in Wolfram Alpha. FullSimplify[D[ Sum[Abs[x[i] - x[j]]^p/p, {i, 1, n}, {j, 1, n}] == 0, #] &amp; /@ {x[1], x[2], x[3]}, Element[{x[1], x[2], x[3]}, Reals]]
"The rather dramatic discontinuity in 2002 is the moment when A New Kind of Science was finally finished, and I could start leading a different kind of life." source: http://blog.stephenwolfram.com/2012/03/the-personal-analytics-of-my-life/
@avocadro Sorry for the delay in replying. Yes, thanks your post helps me, but I am still a little confused on something small: The Wolfram-Alpha website only has one little bar for me to input something. Here you are giving 3 inputs and I cant figure out how to input this into the WA bar. I am solely using the bar on the webpage. I have tried commas, semi-colons, etc, nothing seems to work :-/
Sorry I didn't reply sooner &gt;For example, why did you equate the actual sum to 0, and not the derivitave? My mistake, but it doesm't actually matter: D[Sum[(x[i]-x[j])^2/2,{i,1,3},{j,1,3}],#]==0 &amp;/@Table[x[t],{t,3}] gives the same result, because in Mathematica D[f1 == f2, x] is same as D[f1, x]== D[f2, x] &gt;Also, would WA actually solve this problem (and give me values for x[1], x[2], x[3] that would minimize the derivitive should a unique solution have actually existed? In Mathematica it would be easy, just add //Solve at the end: D[Sum[(x[i]-x[j])^2/2,{i,1,3},{j,1,3}],#]==0 &amp;/@Table[x[t],{t,3}]// Solve In WA it will not work, because of the limit on number of functions. You have to copy [Mathematica plaintext output](http://i.imgur.com/lGuP5.png): {2 x[1]==x[2]+x[3],x[1]+x[3]==2 x[2],x[1]+x[2]== 2 x[3]} To solve group of equations use function Solve[list]. Now we have a second problem: WA is confused by variables x[1], x[2], x[3] (Mathematica doesn't have this problem). Change variables to x1 ,x2 x3. Now it works in Wolfram Alpha Solve[{ 2 x1==x2+x3 , x1+x3==2 x2, x1+x2==2 x3 }] [Link to Wolfram Alpha](http://www.wolframalpha.com/input/?i=Solve[{+2+x1%3D%3Dx2%2Bx3+%2C+x1%2Bx3%3D%3D2+x2%2C+x1%2Bx2%3D%3D2+x3+}])
You must have set x=0 earlier. You can use Clear[x] or restart the kernel if you're desperate. http://i.imgur.com/i3OXp.png
I tried importing some data from an MBOX file to try some of this stuff and mathematica freaked out because it was too large (2.7G). mailda = Import["mail.mbox", "Date"]; It runs fine when I use a smaller mbox file. Anyone know what I can do about this?
Flatten will do the trick: Flatten[D[{{u v}, {u2 + v2}, {u - v}, {Log[u + v + 1]}}, {{u, v}}], 1]
Ah thanks so much!
You should realize that "MatrixForm" is a function that turns a matrix into an image of that matrix. Adding two images together doesn't make sense (which is why Mathematica does not evaluate it). This is why you should only use MatrixForm at the end of an expression. Also, don't worry. This particular mistake happens to everyone at some point or another.
You are plotting t. Plot[i[t], {t, 0, 0.1}]; should do it.
1. It seems to me like you have extra "]]" after your PlotRange List? 2. Perhaps it has something to do with radians in your range (instead of degrees?) my last thought ( and I may be mistaken) is with your range values (vo, phi, theta). I'm not sure if you can use a range and have those values get iterated into your equations (not in the ParametricPlot3D function). I'm pretty sure all the computations set by a range have to be in the plotting function itself. 
I had my friend look at it, and the problem is more embarrassing than I thought. I spelled manipulate wrong....
You spelled "Manipulate" wrong. After that, just make sure you aren't dividing by zero and you're all set
The pattern match operator, `_`, goes with the symbol. If you want an expression with some head to be pattern matched, you need to write f[ aa_[ n_ ] , ... ] := ... 
In my experience, you see Mathematica used a lot less than you might expect in the real world of finance. Even when an advanced mathematical language is used, it's usually MATLAB. The only time I saw Mathematica used a great deal was as a back-end to something like www.scicomp.com. The trouble with Mathematica books is there is a lot of old ones that relate to older versions of the software that aren't as relevant to today's version as new features have come out and the capabilities and coding style have changed. This is especially true with finance, as the recent versions have greatly expanded the Finance package. I am not familiar with any new Mathematica/Finance books that address these new capabilities. The Wolfram website is probably a good place to start with that, as it seems they are making a big push into finance with Mathematica and there's lots of demos and samples of the new finance capabilities. However, if you are looking to use Mathematica to model advanced kinds of derivatives or something, and hand-coding the algorithms to do so, I'll mention this: http://books.google.com/books?id=Buezn_dQcTEC It is by no means a "good" book. It's dense, expensive, difficult to understand, ugly, outdated by now, and probably out of print. But at the time I bought it, it was the best spot on target Mathematica/Finance book in the market and definitely helped me tackle the problem I was trying to crack with Mathematica. 
You guys are awesome, both methods worked beautifully. Thanks!
To do them all at once (ListPlot3D@data[[#,;;]])&amp;/@Range@11 or in a fancy manipulate Manipulate[ListPlot3D@data[[i,;;]],{i,1,11,1}]
These two are in the Edit menu. It's really worth going through the menus once and looking at what functionality is available. I was using Mma for many years without knowing about divide cell and merge cells (ctrl-shift-d and ctrl-shift-m) and now I can't imagine working without them. They were right there in the menu, I just never looked. 
This doesnt work with GraphPlot but it works with Graph. Graph[{1, 2, Style[3, Red]}, {1 -&gt; 2, 2 -&gt; 3, Style[3 -&gt; 1, Orange]}] I think this is what you want.
The sixth of the seven 2D pieces should be mirrored. But nice. Also, I laughed at the font remark!
Thanks, I noticed that shortly after uploading to imgur.
You can do this: rand[x_?NumericQ] := RandomReal[]; Solution = y /. Flatten[NDSolve[{y'[x] == .25 rand[x], y[0] == 1}, y, {x, -10, 10}]] Make sure to clear rand before. This way, rand is evaluated again for every step. The ?NumericQ prevents that the expression simply gets replaced by RandomReal[]. Of course, now the ODE solving algorithm does not converge, because it tries to find the optimal step size and gets different values for y' every single time. But if you don't have any precision requirements, setting PrecisionGoal-&gt;0 in NDSolve works. rand[x_?NumericQ] := RandomReal[]; Solution = y /. Flatten[NDSolve[{y'[x] == .25 rand[x], y[0] == 1}, y, {x, -10, 10}, PrecisionGoal-&gt;0]]
Thanks, I really appreciate this. Been working on this for a while and couldnt figure it out myself (although i learned a lot of other stuff along the way). That ?NumericQ really did the trick. Also, I dont need the ODE to converge, Im comparing a system to itself when noise is introduced vs absent. It's a rough simulation so precision is not required. Thanks again!
Well, NDSolve must converge or you get nonsensical results. It will exceed 10000 steps and still be at the initial value. But it makes sense that you don't need precision if you have noise anyway. Btw, thanks!
Thankyou! :)
 Union[ Table[FindRoot[BesselJ[0, x], {x, i}] /. {x -&gt; y_} -&gt; y, {i, 0.1, 157, 2}], SameTest -&gt; Equal ] Two comments: * Instead of using Sort and DeleteDuplicates together, I suggest using Union. In fact, older versions of Mathematica didn't have DeleteDuplicates, and the documentation used to include different methods to compute an "unsorted union". * The reason why you see duplicates in the list is numerical precision issues. Those two numbers are not identical, but very, very close to each other. When you use SameQ (===) to compare two objects in Mathematica (the default for DeleteDuplicates), it only considers them equal when they're bit-by-bit identical. This makes it unsuitable for comparing floating point numbers where in practice it's more convenient to allow for a tiny difference when considering them equal. The Equal function (==) does this by default. There are many articles discussing the caveats fo comparing floating point numbers, e.g. this one: http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ For Mathematica questions, you can consider asking at http://mathematica.stackexchange.com/ You'll get more detailed and better answers much faster ;-)
Depending on the method used, NDSolve might do some pretty complex things in the background. The function may get evaluated at unexpected times ... If you are looking to implement a simulation with added noise, it may be a better approach to just write the solver from scratch. A simple forward Euler will be a one-liner. If you are looking to solve stochastic differential equations, then it'd be worth reading up on the topic and methods.
As zephyr said Plot[f(x),{x,xmin,xmax}] is the universal form 
Click F1 and write plot ...here u go
Typically i would plot a circle using the PolarPlot function. PolarPlot[r,{theta,theta min,Theta max}]
Graphics[Circle[]] That's pretty basic but look up those in the help browser :)
Thanks! Forgot about that guy...
Don't worry about it. I had a similar problem and it took me a week to find it.
I wont be in my house with a copy of mathematica until later but maybe I can think of something. Do you have an example of your data?
data is just this: {{0, 16.033}, {1, 16.2669}, {2, 16.0609}, {3, 15.8457}, {4, 16.0371}, {5, 15.8841}, {6, 16.0521}, {7, 15.8536}, {8, 16.0355}, {9, 16.0191}, {10, 16.0075}, {11, 15.9342}, {12, 16.042}, {13, 15.9637}, {14, 15.9893}, {15, 15.9441}, {16, 16.0104}, {17, 15.9844}, {18, 15.9572}, {19, 16.1549}, {20, 16.0027}, {21, 16.1205}, {22, 16.0142}, {23, 16.1558}, {24, 15.9979}, {25, 15.929}, {26, 16.1857}, {27, 16.1819}, {28, 16.332}, {29, 16.032}, {30, 16.1354}, {31, 16.0798}, {32, 16.3638}, {33, 16.173}, {34, 16.1549}, {35, 16.4596}, {36, 16.1141}, {37, 16.0771}, {38, 16.2482}, {39, 16.1972}, {40, 16.3027}, {41, 16.2954}, {42, 16.3645}, {43, 16.2212}, {44, 16.5008}, {45, 16.2644}, {46, 16.4583}, {47, 16.2078}, {48, 16.3656}, {49, 16.3469}, {50, 16.244}, {51, 16.4755}, {52, 16.2937}, {53, 16.3585}, {54, 16.4698}, {55, 16.4753}, {56, 16.4763}, {57, 16.4316}, {58, 16.4755}, {59, 16.4588}, {60, 16.6911}, {61, 16.6265}, {62, 16.4449}, {63, 16.4609}, {64, 16.5542}, {65, 16.5006}, {66, 16.5423}, {67, 16.5399}, {68, 16.8729}, {69, 16.5691}, {70, 16.6984}, {71, 16.6707}, {72, 16.862}, {73, 16.7943}, {74, 16.6505}, {75, 16.56}, {76, 16.6967}, {77, 16.6264}, {78, 16.6102}, {79, 16.959}, {80, 16.5313}, {81, 16.6151}, {82, 16.7491}, {83, 16.7132}, {84, 16.9959}, {85, 16.4817}, {86, 16.8737}, {87, 16.8974}, {88, 16.6923}, {89, 16.595}, {90, 16.7113}, {91, 16.7309}, {92, 16.6816}, {93, 16.6075}, {94, 16.6038}, {95, 16.9309}, {96, 20.2589}, {97, 20.0499}, {98, 19.5218}, {99, 20.8761}, {100, 19.382}, {101, 19.1595}, {102, 19.7717}, {103, 19.1433}, {104, 18.7944}, {105, 19.032}, {106, 16.7434}, {107, 16.5874}, {108, 16.4441}, {109, 16.7364}, {110, 16.6538}, {111, 16.7075}, {112, 16.7086}, {113, 16.9389}, {114, 16.529}, {115, 16.5775}, {116, 16.8123}, {117, 16.7186}, {118, 16.5754}, {119, 16.7142}, {120, 16.6443}, {121, 16.929}, {122, 16.7154}, {123, 16.5827}, {124, 16.6569}, {125, 16.6656}, {126, 16.5373}, {127, 16.5113}, {128, 16.5155}, {129, 16.6734}, {130, 16.6335}, {131, 16.7089}, {132, 16.6236}, {133, 16.5817}, {134, 16.5922}, {135, 16.5125}, {136, 16.4996}, {137, 16.5167}, {138, 16.4916}, {139, 16.6062}, {140, 16.502}, {141, 16.4107}, {142, 16.5328}, {143, 16.5297}, {144, 16.4761}, {145, 16.3968}, {146, 16.5051}, {147, 16.3459}, {148, 16.3553}, {149, 16.3579}, {150, 16.3612}, {151, 16.3741}, {152, 16.3053}, {153, 16.3568}, {154, 16.2873}, {155, 16.3185}, {156, 16.1954}, {157, 16.2589}, {158, 16.2082}, {159, 16.3052}, {160, 16.1767}, {161, 16.1802}, {162, 16.204}, {163, 16.1469}, {164, 16.16}, {165, 16.0763}, {166, 16.1902}, {167, 16.1422}, {168, 16.0359}, {169, 16.0644}, {170, 16.0495}, {171, 16.0265}, {172, 16.0104}, {173, 16.0295}, {174, 16.0983}, {175, 16.0771}, {176, 15.9659}, {177, 16.0201}, {178, 16.042}, {179, 15.9406}, {180, 15.9445}, {181, 15.869}, {182, 15.8401}, {183, 15.9838}, {184, 15.9351}, {185, 15.82}, {186, 15.8029}, {187, 15.8816}, {188, 15.9831}, {189, 15.9802}, {190, 16.0531}, {191, 15.9557}, {192, 15.9708}, {193, 16.0155}, {194, 15.9189}, {195, 15.9464}, {196, 16.0525}, {197, 15.902}, {198, 15.9811}, {199, 15.9725}, {200, 15.9423}, {201, 15.9607}, {202, 15.852}, {203, 15.9389}, {204, 15.8054}, {205, 16.0577}, {206, 15.9609}, {207, 15.903}, {208, 15.9096}, {209, 15.9426}, {210, 16.0099}, {211, 16.0287}, {212, 16.0142}, {213, 16.0448}, {214, 16.124}, {215, 15.9825}} I just want the Y axis to go from like 25 to 0 rather than 0 to 25
Thanks for your reply, please see my edit to the original post.
This is perfect, exactly what I need. As a former Fortran programmer I am trying to break the "loop" habit but it is all that I know. I will study your solution to get a better understanding of MMA and the functional style of programming. Thank you.
Wouldn't it just be 2^n where n is the number of elements in the original set? Given input set S of size n Output sets A, B where A union B = S and B = S - A Now you just need to find how many possible values of A exist which is 2^n since for every item it can either be in A or not in A.
I agree that it's rather easy to count the number of possible partitions, but I would like to have a list of them, as I wrote in the output above.
I think this does it: PartitionTwo[set_] := {#, Complement[set, #]}&amp; /@ Subsets[set]
Inside Plot3D[], the *x*, *y* and *z* are just variable names. Plot3D[x^y, {x,-1,1}, {y,-1,1}] is synonymous with Plot3D[x^z, {x,-1,1}, {z,-1,1}]. You need to make sure you know what equations you want to plot. When you say **y^2 /81 + z^2 /9**, do you mean that **x = y^2 /81 + z^2 /9**? I think the function you are looking for is ContourPlot3D. It lets you plot a function f(x, y, z). For example: if **x = y^2 /81 + z^2 /9**, then you can use: ContourPlot3D[y^2/81 + z^2/9 - x == 0, {x, -10, 10}, {y, -10, 10}, {z, -50, 50}, PlotStyle-&gt;Green] or similar, and likewise for the other functions.
I actually tried to use that function before, but it wasn't working for me. I copy pasted your example and I got this back: ContourPlot::nonopt: Options expected (instead of {z,-50,50}) beyond position 3 in ContourPlot[y^2/81+z^2/9-x==0,{x,-10,10},{y,-10,10},{z,-50,50},PlotStyle-&gt;Green]. An option must be a rule or a list of rules. &gt;&gt;
It worked! Thanks a lot! :) 
I usually do this sort of thing ( but the use of Table above works also of course). {#,f[#]}&amp; /@ Range[1,100] You have to know about anonymous functions (the # and the &amp; stuff) and Map (/@) but they are very useful once you know what they do. (Also it's good to know what Apply does). Worthwhile to learn them. But table works too and perhaps easier to get when just starting out. 
Yes it does and thanks for your help!
I'm mobile right now, so I haven't tested this out myself: Let's say you want to solve x^2 + y^2 = 26819945 where x,y are Gaussian integers. Try Reduce[(x1 + I * x2)^2 + (y1 + I * y2)^2 == 26819945 &amp;&amp; Element[{x1, x2, y1, y2}, Integers], {x1, x2, y1, y2}] You might also want to try something similar with FindInstance.
I think this is what I love most about mathematica. It's a wonderful tool for exploring a problem space intuitively.
Hm.. It seems to me that Table does some smart tricks. I kind of dislike using Table in cases where you are aiming for speed, because I always hear that because Mathematica doesn't really do nice compiling, a lot of time will be spent looking up your running variable. However, I guess Mathematica can recognize the case Table[i,{i,1,1000}] as a case in which i is never changed and therefore it can work more efficiently. For comparison, Table[i=i;i, {i,1,1000}] is a lot slower, probably because mathematica ..... Wait, experimenting some more, it seems like I found a crazy error in Mathematica. Compare the outputs of g := i = 2000; Table[g; i, {i, 1, 100}] and g := i = 2000; Table[g; i, {i, 1, 1000}] The first yields a constant list and the second gives Range[1000]... (Am I going) Crazy!(?) I guess you're not supposed to fiddle with your running variable 8) 
Yes, absolutely. I cant believe it completely slipped my mind that a simple table command existed in mathematica. I was trying to create one from scratch but was having issues with the NDSolve. Thanks. I've tried it and works great so far. My thanks, good sir!
Treat each function as a variable instead, and you should have a square system (7 eqn, 7 unknown). No guarantees that this will work though, since nonlinear systems don't always have a solution.
For the second problem, suppose you want a differential operator Exp[d/dx] to be applied to a function f[x]. Then define a finte-order expansion (say up to 3) Operator = Sum[1/n! Nest[D[#, x] &amp;, ##, n], {n, 0, 3}] &amp; and apply it to your function Operator[f[x]] and you'll get f[x] + f'[x] + f''[x]/2 + f'''[x]/6 I don't know if this helps.
Sorry I couldn't be more helpful.
Not that I know of, but I may be able to help if you tell me the application.
I think using HoldForm is more appropriate than Hold.
HoldForm[a+b == #1 + #2]&amp;amp;[a, b]
yes, I showed those 3 as an example to what I want it to come out as
I see. I'm sorry to say, variables don't work like that. What you want to do instead is put each of those items in a list and read through that list. Does that make sense?
but I also need the "[][1]" thing immediately after the integer.
I think so, but wouldnt that give me a list with , separating each of the elements in the list? If so, I'd need them to have no extra syntax.
You can use the BooleanTable to generate the truth tables. I'm not sure about reversing them though. Maybe the reverse function can be generated using brute-force.
You may have defined f wrong. In your post for instance you didn't include the _ for x and y. Also you used := whereas a = would be more appropriate, provided you Clear all the variables involved. Copy paste the following: it works, I just tested it Clear[a, b, x, y, f]; f[x_, y_] = a + I b x + a x x + I b y y; sList = {1, 2}; abList = Flatten[Table[{a, b}, {a, sList}, {b, sList}], 1]; pList = Table[{a, b} = pair; ContourPlot[Arg[f[x, y]], {x, -5, 5}, {y, -5, 5}], {pair, abList}];
Perhaps there’s a reason for it in your use case, but that all seems more complicated than it needs to be. I'd do this: tableOfValues[f_, list_] := TableForm[ Table[{x, f[x]}, {x, list}] ] Then: tableOfValues[f, {-1.5, -1.25, -1, -0.75, -0.5, 0, 1}] (* outputs your table *) Note, if your function is f(x)=( 3-x^2 )/( x+1 ) there’s a division by zero in there. Your example tableOfValues will do something similar, but don't forget to put underscores after the variable names in your function definition. eg: tableOfValues[f_, list_] := ...
Thanks, I got it to work. Hopefully my professor accepts this method :)
...I've never been able to articulate that feeling better than this.
Look up the Table function.
Table is a bit overkill for this, you should be just fine with Range.
Yep.
Search the help for `Piecewise`
Thank you very much! Can I ask how you know this? Did you look it up in the Documentation Center when you saw the question? I always have a hard time finding new commands that suit what I need done. I ended up with &gt;Plot[Piecewise[{{x^2 - 3, x &lt; 1}, {-2 x - 4, x &gt;= 1}}], {x, -10, 10}]
I've just happened to run into the function somewhere on my travels. If I hadn't known about it, I probably would have done something like: &gt;`f[x_] := If[x &lt; 1, x^2 - 3, -2 x - 4]` &gt;`Plot[f[x], {x, -10, 10}]` which is equally simple really. Also, `Piecewise` is in the SEE ALSO section of the documentation for `If`, which is a good way of finding useful stuff.
Nice. See I didn't know the If function either ;-) The way I'm trying to learn the program is by doing old assignments and other stuff. What would you recommend for learning this - just reading Documentation Center from one end to another? By doing assignments I think I'm learning what's necessary, but I guess I'm losing out on a lot too. 
Just browse the documentation aimlessly for hours on end until you've committed the whole thing to memory :) It's not that bad, really. Mathematica is huge, but half the functions are painfully obscure like `Hypergeometric2F1Regularized[]` or `RogersTanimotoDissimilarity[]`\* (and the other half are Bessel functions). You just need to read the basics from the "Core Language" section and the the parts of "Mathematics and Algorithms" that are applicable to what you're doing. - - - \* Introduced in a paper titled "A Computer Program for Classifying Plants"
 f[x_]:=[esc]pw[esc] Then hit [ctrl]+[enter]
Look at tutorial/PolynomialOrderings in the help. &gt; _The default sorting used for polynomial terms in an expression corresponds to the negative lexicographic ordering with variables sorted in the reversed order. This is commonly known as reverse lexicographic ordering._ and &gt; _TraditionalForm tries to arrange the terms in an order close to the lexicographic ordering._
Your pde is of hyperbolic type but you asked Mma to solve an initial-final value problem. That is in general not possible (for your wave equation it is, but that is a coincidence). You should specify an initial-boundary value problem. Or, for a pde of elliptic type, you can have just a boundary value problem.
Ah, so that's why! I wanted to calculate k as real. Thank you!
\[Equivalent] and \[DoubleLeftRightArrow].
Thanks! English isn't my first language, so I sometimes find it hard to find the functions that suit my needs.
Even if you speak english you will have a hard time finding functions that suit your needs
ESC &lt;=&gt; ESC is easier to remember. 
Ah thanks, I didn't realise different types had different rules about initial values.
if you don't get help here, ask mathematica.stackexchange.com
Alright, I don't have a lot of time to deal with this, but at least with the laguerre polynomials, and I would imagine with the real example you are working with the problem lies with mathematica's handling of the functions. Here is my suggestion, I tried it for n=38, and it worked, so its worth a shot with for you. Don't integrate your function, integrate an interpolation of your function. So say something like intfun=FunctionInterpolation[Realfun[x],{x,0,10000}] NIntegrate[intfun[y],{y,0,10000}] That should atleast give you a reasonable approximation of your integral. 
Sadly, that did not do it.... https://dl.dropbox.com/u/10324908/Re2.png But thanks anyway!!!
Try using FullSimplify. And if that doesn't work, my best suggestion is to conjugate the imaginary part out of the denominator manually.
You are trying to solve a partial integro-differential equation. That is harder than solving a plain-old PDE! It was extremely difficult to parse what you were asking, because you have traded one problem for another and then for another. I don't think you need your auxiliary function b in your system. Even if you do introduce this auxiliary function, you could actually specify that it should be constant in x: D[b[t,x],x]==0. I don't know if Mathematica actually knows how to solve integro-differential equations. There are iterative approaches which work, but you would have to write your own driver to converge on a solution (either in Mathematica or some other language, say C).
I definately need the b function - a and b constitute a two cycle feedback loop. And you would call this entire shennanigan an integro-differential equation? Mathematica warned me that it won't do delayed partial integrations - are those two concepts related? And just to be clear, I'm trying to have **á** integrated with each time step (dt) but not each spacial step (dx). Sorry for using two functions that look so similar! 
Your sqrt()'s need to be Sqrt[]'s. Also those options to Plot need to go inside the square brackets, you've just got syntax errors there.
You're also not using that last Plot correctly.
Could you elaborate?
You end the square bracket too early so the PlotRange, PlotStyle doesn't get passed to Plot. The range you're using is also *way* too large. After fixing capitalization, cleaning up the function in NDSolve, and playing with Plot I end up with something like [this](http://i.imgur.com/FTV8F.png).
Yay, it has already been answered! Boo, I don't feel useful!
Oh but there will be more questions! Do not doubt that.
Sweet :)
Indeed
It really depends on how familiar you are with Mathematica, and how familiar you want to become with it. A project like that is a great way to learn syntax and new built-in functions, as well as perhaps learning how to make your own. In my opinion, the plots and graphs that Mathematica makes look better and more professional than Excel, which is one of the reasons why I use it. You could write up the whole report in Mathematica, but I would not recommend it. Use it for data analysis and graph generation, then copy those images to your Word doc or LaTeX.
I'd strongly recommend writing in LaTeX and Mathematica, as ifrikinfix has also explained. They're definitely *annoying* to use when you first get started but the end product is superior to anything you could ever produce in Word. There are some nice features in Mathematica that allow you to output equations into LaTeX format and you can export all graphical images as png's or pdf's for easy inclusion in your LaTeX document. I'm not sure what operating system you're using but there are several different kinds of LaTeX editors to choose from in order to create TeX documents. See here: http://en.wikipedia.org/wiki/Comparison_of_TeX_editors I personally have only ever used TeXnicCenter and Winshell myself, but I have heard people often prefer ones like TeXstudio where you can actively see the output of your TeX document as you're writing it. Try out a few and see which one feels best. Furthermore, here are some additional resources to hopefully make you learn to love LaTeX. [Detexify](http://detexify.kirelabs.org/classify.html): Draw the symbol you want to produce in LaTeX and the site returns the LaTeX code for it. FUCKING AMAZING, you will find this to be. [Tex.StackExchange](http://tex.stackexchange.com/): This is a Q &amp; A site for LaTeX. It's a good place to look for answers to your woes. [LaTeX wikibook](http://en.wikibooks.org/wiki/LaTeX): I generally find answers for how to do certain things in here when I search it in Google. It could be good for getting started. Well, in fact, the easiest way to get started in LaTeX is to edit a pre-existing TeX document to become your own. I'd be happy to send a template your way. In particular, one that showed how to include Mathematica graphics and such. Ah, which reminds me to mention that although Mathematica offers to output to LaTeX, you'll often find the formatting to be quite unpleasant. For instance, it'll output "Cos[x]" instead of "cos(x)," and if you have a particularly long equation it won't format it in a nice way. And so on. Just a warning, I suppose. You can often use something like Notepad to find and replace parts that you don't like. Anyway, I've rambled a bit here but I hope you'll take something away from this. LaTeX is one of those things that you find yourself hating so much, yet you can't stop loving it. If you're in physics it's better to introduce yourself to LaTeX sooner rather than later. 
Mathematica makes very pretty graphics. There's a [Mathematica.Stackexchange](http://mathematica.stackexchange.com/) site that you may want to join at some point if you're not sure how to get such plots working. Or simply Google it. 
Unless you're giving a presentation in which you want dynamic graphs/models, I'd personally recommend staying away from Mathematica for typesetting. I personally am a *huge* advocate of LaTeX, as it's a powerful tool for writing the paper as you want it to look. Here are some TeX tools I personally have used: * [Texmaker](http://www.xm1math.net/texmaker/). It highlights errors in your code, auto-inserts \end{} commands, and is pretty damn well documented. * [Detexify](http://detexify.kirelabs.org/classify.html). Draw the symbol, get the TeX code and packages necessary for compilation. * The user base. LaTeX is probably the most widely used *professional* typesetting software (not counting Word here), and it's got an awesome, and active community to help you sort out your troubles. * [You can also install LaTeX on a thumb drive.](http://jimstitzel.com/2010/01/configuring-texmaker-usb-with-miktex-portable/) If you do insist on using Word, at least try out the built in LaTeX support in the Equation editor (2010 and up)! Best of luck, hope this answers your question! edit: formatting, funnily enough!
It seems like you still could use Table. First combine your lines into one expression separated by semicolons. You might want to look at the CompoundExpression function. But leave out the line where you set r. Then put the resulting expression into a Table and tell it which rs you need. If you want to distinguish the results based on the r value, make sure the last line of your CompoundExpression is something like {r, final} You could add additional variables to that list if they are relevant to you. You're code should probably look like this: finalsTable = Table[ a = 0; m = 34; ...; {r, final}, {r, Range[2, 21]} ] The result should be a list of lists {r, final for that r}. If later you're interested only in the finals value without regard to r, Map is your friend: finals = Last/@finalsTable HTH
That's the nicest way I've ever been called a n00b, and on top of that, you supply a heaping of help. Thank you!
No problem! Mathematica is a little weird compared to a lot of other programs. Things are done... differently. Another useful "trick" is to do replacement rules. You define: reprules = {a -&gt; 1.0, b -&gt; 2.0} Then you apply them: a^2/b^2 /. reprules This replaces all instances of `a` and `b` in the expression before the `/.` (the replacement operator). This is nice because you can do a bunch of symbolic manipulation of the expression before you put in final values. For more info, check out mathematica.stackexchange.com. Really helpful people who go above and beyond in helping people out.
So, if you have some function that returns a value: f[x_]:=SphericalHarmonicY[1,0,x,0] And you want to get a bunch of numerical values out from this function: Table[ N[f[i]], {i,0,2 PI,.1}] This will spit out a list of numbers of f at the values i = 0 to i = 2 pi in increments of .1. You can generalize this to three variables (or more): Table[ N[Function3[x,y,z]], {x,0,1,.1},{y,0,1,.1},{z,0,1,.1}] which gives you out a 3d list of the values (a list of lists of lists of numbers). There are other ways to do things (N[x] is the function that returns a normal number from a "symbolic number" or expression, but sometimes you want the "symbolic number"). But the language is pretty powerful itself. I highly recommend it.
Excellent, thanks. I don't quite understand the syntax from a quick glance, but it does seem incredibly powerful. From your description and process, I get the feeling I can get what I'm looking for in a plethora of ways. Thanks again.
If you don't care about all solutions you can use FindInstance instead which does the same thing as Solve but returns only one solution which is usually the more commonly sought sort of solution. 
I must NOT understand the question.. Straight from Plot[] documentation: Plot[{Sin[x] + x/2, Sin[x] + x}, {x, 0, 10}, Filling -&gt; {1 -&gt; {2}}]
[You've got to be kidding me...] (http://i.imgur.com/CcNt6.gif) Thank you! This only got me half way though. Can I specify the range of the filling to [-3;2]?
This gives me a blank plot. You seem to have forgotten the g[x]&gt;f[x] part.
http://i.imgur.com/Xy2nr.png Works for me. Maybe you forgot the function declarations?
True, I didn't see he was playing with side effects to put things in the Que instead of returning it. 
Hmm... Well, I'm not entirely sure what result you're trying to get, but one of the really nice things about Mathematica is that a lot of the functions auto-index over elements in a list. In addition, there are a crapton of built-in functions that can probably do what you want to do. The trick is finding those functions. The Mathemagita help is really really useful. Anyway, try this and let me know if it's the result you're looking for. The "~~" is a string concatenation... thingy... StringReplace[cstr, {"A" -&gt; 0, "R" -&gt; 111, "B" -&gt; 10, "D" -&gt; 1101, "C" -&gt; 1100}] RETURNS: 0 ~~ 10 ~~ 111 ~~ 0 ~~ 1100 ~~ 0 ~~ 1101 ~~ 0 ~~ 10 ~~ 111 ~~ 0 What StringReplace[_string_,_rules_] does is indexes over every character in _string_ and applies _rules_. 
Well, for starters, `assTable` should be a function. That way, instead of looping through each entry in the table, you can just apply the function. But you don't need a for loop for that, you can just use the `Map` function. So now you've replaced 2 nested loops with `Map[assFunc, word]`. But it gets even better. `StringJoin` can take a list of strings, so for you to concatenate everything you can just pass the whole list to `StringJoin`; there's no need for a loop or intermediate variables. And so those 5 lines can be reduced to `newEncode=StringJoin[Map[assFunc,word]]`. In general, fast Mathematica code is going to use builtin functions rather than manual loops. You should learn those functions if you're writing computationally-intensive code (especially the high-level functions like `Map`/`Thread`/`Apply`/...).
If you want an array as the output, these two lines are equivalent. The latter just uses some shorthand notation. ReplaceAll[Characters[cstr], {"A" -&gt; 0, "R" -&gt; 111, "B" -&gt; 10, "D" -&gt; 1101, "C" -&gt; 1100}] Characters[cstr] /. {"A" -&gt; 0, "R" -&gt; 111, "B" -&gt; 10, "D" -&gt; 1101, "C" -&gt; 1100} RETURNS: {0, 10, 111, 0, 1100, 0, 1101, 0, 10, 111, 0}
Yeah the reverse is easy too. I'm going to use what I wrote in my reply above, and stick with keeping things as lists (arrays). We'll define the encoding in the same way you did in your original post, as a 2D list (some languages call this a tuple, I think): encoding = {{"A", 0}, {"R", 111}, {"B", 10}, {"D", 1101}, {"C", 1100}}; You can easily make this list really long, or generate it programmatically if there's a known mapping function for letter to number (like A=1, B=2, C=3, etc). Anyway, to go forward, we use Characters[] and ReplaceAll[] ("/."), just like my other comment: encodedString=Characters[cstr] /. Map[#[[1]] -&gt; #[[2]] &amp;, encoding] The Map[] function actually generates the rules list. It it takes each element in _encoding_ and creates a **1-&gt;2** item, and then appends it to the an internal list. The hash (#) denotes where in the expression to use the item from _encoding_ It's the same as: EQUIVALENT: Characters[cstr] /. {"A" -&gt; 0, "R" -&gt; 111, "B" -&gt; 10, "D" -&gt; 1101, "C" -&gt; 1100} Lastly, if we want to go back, we just change the indexes in the map function so that it generates **2-&gt;1** instead: decodedString = encodedString /. Map[#[[2]] -&gt; #[[1]] &amp;, encoding] However, this is returning an array of characters. Let's put it back into the string form. As I mentioned earlier, a lot of Mathematica functions auto-index over lists, so this is really easy: StringJoin[decodedString] The total code looks like: encoding = {{"A", 0}, {"R", 111}, {"B", 10}, {"D", 1101}, {"C", 1100}}; encodedString = Characters[cstr] /. Map[#[[1]] -&gt; #[[2]] &amp;, encoding] decodedString = StringJoin[encodedString /. Map[#[[2]] -&gt; #[[1]] &amp;, encoding]] If you want to turn these into functions, it's pretty easy too. This is getting into slighly more advanced stuff (defining functions) which actually aren't a necessity for creating large analysis packages: encodeString[string_String, code_List] := Characters[string] /. Map[#[[1]] -&gt; #[[2]] &amp;, code]; decodeString[array_List, code_List] := StringJoin[array /. Map[#[[2]] -&gt; #[[1]] &amp;, code]]; encodeString["abc", {{"a", 2}, {"b", 3}, {"c", 1}}] RETURNS: {2,3,1} decodeString[{1, 1, 1}, {{"a", 2}, {"b", 3}, {"c", 1}}] RETURNS: ccc
For the problem I first want to take ABRACADABRA and turn it into its numerical encoding (01011101100011010101110) using the encoding table. For the second part, I want to take 01011101100011010101110 and turn it into its alphabetic word using the encoding table. The problem here is I don't necessarily have access to the first part. I need to take any numerical value and use the table to create the word. 
Ah, so we're keeping things as a single "word" - there's nothing telling you where the separation between letters are in the encoded line, (other than knowing the crypto key). OK, so, the 1st half is easy: encoding = {{"A", "0"}, {"R", "111"}, {"B", "10"}, {"D", "1101"}, {"C", "1100"}} encodedString = StringJoin[Characters[cstr] /. Map[#[[1]] -&gt;#[[2]] &amp;, encoding]] All that needs to be done is make sure that the encoding uses all strings ( using {"A" -&gt; "0"} rather than {"A"-&gt;0} ) and slap a StringJoin[] around it, exactly what you had at the very beginning. My bad, I misunderstood your problem. The second part seems a bit trickier. Give me a bit and I'll try working it out. EDIT: Huh. I didn't expect it, but a simple StringReplace[] works. Not sure why I thought it wouldn't... StringReplace[encodedString, Map[#[[2]] -&gt; #[[1]] &amp;, encoding]]
&gt; EDIT: Huh. I didn't expect it, but a simple StringReplace[] works. Not sure why I thought it wouldn't... This is because none of the codes can be constructed by concatenating some of the others (let's call that linear independence). So here, an encoded string is an unambiguous string of concatenated codes (if you always read from left to right, that is). This would change if, for example, you included a code "1".
The data above are 50 years of salmon passing through a fishway, with their length and weight measured as they pass through. Atlantic salmon can return after any number of years at sea. So the groups in the data should represent salmon that return after 1 year, 2 years, 3 years, or 4 years in the sea. I want to get the size range for each age group. So for all the salmon that are probably 1 years old, what is the probability distribution of them being of a certain weight and length. But since the data is overlapping, I'm not sure how to do this. Can anyone here help me with this?
Wow, every time I see those demonstrations I am just filled with a desparate wish to be able to migrate over to Python where the code is actually readable. But thanks for the hint. I will try to sort it out tomorrow. :)
I don't know how well this would work, and it sure as hell wouldn't be efficient, but could you make a 2D interpolation out of the data and solve for maximums using the second derivative?
Have you looked into FindClusters?
Collegues.
FindClusters gives [this](http://imgur.com/4XOkS). The borders are too sharp, it should be a probability distribution, not a set of boxes.
In the works of Dennis Eckersley: "Ehh...fuck 'em." But all of your colleagues don't use it, or refuse to use it?
Mathematica's notebook user interface is definitely written by some 17 yr old kid, who just got into Univ of Phoenix online technical school, and thinks its cool. It baffles me how even after releasing 8 versions of Mathematica, they still can't get it to work right. It crashes/hangs/slows down so often. And yeah it obviously lacks *advanced* features like a undo history. Have they finally fixed this in Mathematica 9? edit: fixed typos
R Code integration sounds awesome
("What have the Romans ever done for us") ... and there is the typesetting, interface building embedded in the document, slide shows, programmatic document creation and analysis, the CDF Player runtime, and now they have added image editing and 3D images and background images. That's not exactly standing still.
- and there is the typesetting What do you mean, other than what was already present in 1.0 or 2.0? - interface building embedded in the document Manipulate[] is nice (it's what I had in mind when I typed "dynamic data"), but I personally think it is deeply flawed to try to make a UI in Mathematica. - slide shows There's other programs for that that work better. - programmatic document creation and analysis How often do you use that? And in what way is it a front-end feature? - the CDF Player runtime That fizzled a bit, wouldn't you agree? And how is that a front-end feature? - image editing and 3D images and background images I see no use for those. All these features and then some, I'd trade them for a useable "Undo" and interactive plots. But different strokes for different blokes, I guess. 
It agree that it would be better if MM did all of the bioinformatics stuff in those packages but that seems like a long shot right now (as probably the only people who care/understand enough are the people who wrote the original packages). The R integration is a nice compromise where I can get what I need from someone's (probably horrific spaghetti code) R package and do my thing in MM without having to worry about bridging the gap at all. I think this is a Good Thing.
Or undo.
When a friend upgraded from 7 to 8 with that service it only took a few days.
Pffhahahaha, no. I guess I meant to say what five days in a lab *won't* get you.
You can use the Cholesky decomposition (there is a special function for that in Mathematica 8). I played around with it a while ago, and wrote about it [here](http://www.dan-erik.com/forum/viewtopic.php?f=42&amp;t=99).
I think you can go on the website and do it now. At least, I saw so on the upgrade page. I have a Student license, so I don't know.
No, it is not showing up on my downloads page. I still see 8.0.4 The official statement from Wolfram is that Premier Service subscribers will get an email notifying them that they can upgrade. I was just wondering how long I can expect that to take. I find tau_'s answer satisfactory.
Brilliant! If I only I knew about this when I started my degree...
You use `&amp;&amp;` to put multiple expressions into Solve. It's also wrong to refer to `x` as `x_`; that's only a thing for function declarations. So the expression you want is: Solve[7*Cos[x]==6.993 &amp;&amp; 0&lt;=x&lt;=2Pi, x]
I was able to upgrade before I got the email.
That's fantastic! So the `&amp;&amp;` and what follows works as the condition in Solve? The _ was from me experimenting. You are right - that should definitely be left out. Thank you for helping me out.
You get that because f is a partial function, so Mathematica can't differentiate it in the general case. If you're not planning on having separate definitions of f for different ranges, you should just make f a total function and not apply it to numbers outside of (0,2 Pi). If you are, you should check out the Piecewise function.
What I ended up doing was AspectRatio-&gt;2/(1+√5). What bothers me about it, though, is that wasn't that supposed to be the default? Or is that only for Plot[]? I know vector and 3D plots are square.
That's very strange. I just tried it in a fresh notebook at got the same result. Looking at the default options (code: *Options[ParametricPlot]*), I see that AspectRatio is set to Automatic, so the default is correct. (You can change the defaults with SetOptions[] if you want, but you already have your solution from other people). Looking a little deeper, it appears to be actually related to the plot range. The AspectRatio-&gt;Automatic setting uses the X and Y ranges as guidelines for setting the image aspect. If you set *PlotRange -&gt; {{0, 100}, Automatic}*, you'l get approximately the same image. If you change it to *{0, 100}* in the X, you'll get a decent aspect ratio. The same applies to other parametric plots. If you do the same with a standard plot, the aspect ratio remains about the same for all plot ranges. **This looks like a bug in how automatic AspectRatio is calculated with parametric plots**, probably relating to the max and min X values of the plot. Tested using Mathematica 8.0.
That certainly resolves the problem, but I want to specify a plot range which does not encompass the entire data.
The default for Plot and similar functions is AspectRatio -&gt; 1/GoldenRatio, while for parametric plot it's AspectRatio -&gt; Automatic. This is to ensure equal scaling which means geometry doesn't end up looking squeezed. Try for instance to compare: ParametricPlot[{Cos[u], Sin[u]}, {u, 0, 2 \[Pi]}, AspectRatio -&gt; 1/GoldenRatio] ParametricPlot[{Cos[u], Sin[u]}, {u, 0, 2 \[Pi]}, AspectRatio -&gt; Automatic] It's just the case in your code that you have a very long x-axis and a very short y-axis, so under equal scaling (non-distorted axis), you end up with a figure for ants.
Me and AspectRatio -&gt; 1/GoldenRatio are great friends. I think I have used it in generating almost every plot for every paper ever since I came across this.
Some mac subreddit is likely more appropriate, but hopefully someone here will know anyway.
Tried to get rid of the bar at the top of the Student Edition. Lost the battle.
Rules are your friends. Use ReplaceAll, typically shortened /. that is, someSolution = Solve[someSystem, somevars] someOtherExpression /. someSolution this replaces all occurrences of the variables in somevars with their solutions. If you are using Mathematica like a calculator or C code, you might ignore the rule and do something like c = c /. solution[[1]] and then go on with your merry way. But if you are doing serious calculations, trust me, you want to keep rules around instead of assigning values to variables.
I don't think you can. Not legally anyways. It is apart of why you have a "reduced" price by buying the home version.
Thanks a bunch! This will be a huge time saver.
&gt; A 3D heat map Are you talking about a representation of 3D space where each point is coloured according to the value of a specified function at that point? This you could *possibly* do with a RegionPlot3D, with the first argument set to True and adding your colouring function somewhere as an additional parameter. But how do you imagine navigating through that? You'd always just see the points on the outside faces of the cubic region you've plotted. It wouldn't really be useful until you take a 2D trace of it (i.e. a plane).
Maybe you could treat it as a collection of sample points, like how you draw 3D vector fields.
Sorry, I was edittting my post.
The advantage of this idea is that it kinda works like how a human would do it. Evaluate a question and go to the next question, repeat. Actually I had to think of a way to avoid the nested ifs and this solution came to my mind after a while. I hope it works for you. As a side note if some of the questions had more than two branches you could replace the Ifs with which. That should work quite nicely now that I think of it.
Try: UnitConvert[%, "Electronvolts"] I figured this out by: In[4]:= QuantityUnit[Quantity[500, "ElectronVolt"]] Out[4]= "Electronvolts" It looks like UnitConvert is more strict with unit names than Quantity.
This works. Thanks you very much. I've tried everything else like "ElectronVolts", "ElectronVolt" and so on. But non of them worked so far. Thanks for the hint with the QuantityUnit command. This is indeed very helpful.
Not worth it IMO. But why is your students license only for v8? Mine came with a free upgrade from 8 to 9
I've had this copy since fall of last year. Is the free upgrade just for those that hav bought student in the last x months?
Could be, I just bought it ~2 months ago
Complex dynamics. Make the Mandelbrot set! Try out Newton's method for complex polynomials! My friend is doing this right now and is learning a TON. 
I want to do this one myself, let's do it.
I posted [this](http://www.reddit.com/r/ECE/comments/13i5e7/nmr_developer_here_help_me_reddit_this_seemingly/) and [this](http://www.reddit.com/r/AskElectronics/comments/13i5o9/nmr_developer_here_how_can_i_characterize_this/), both are the same problem, in different subreddits. This is a simulation problem I need help on. I don't know how much physics you know, but if it's not much hopefully you can grab onto the idea enough from what I wrote in the post. This would potentially contribute to a major scientific achievement. It's worth a mention on a publication!
Came here to suggest Mandelbrot set. Well done.
[Project Euler](http://projecteuler.net/). EDIT: Thanks for the gold, stranger!
I love it - great suggestion!
Seconded. That's what I used to learn Mathematica. 
this worked precisely as advertised. should be top comment.
Think of the differences between a vector and three numbers. A vector, *V*, designating the point A(1,1,1) in cartesian coordinates tells you that there is a point of interest at (1,1,1). If you were to change your basis vectors to anything else, that information is still preserved, just the components of the vector change. We say that the vector transforms with a particular set of properties. We can choose our basic vectors including (1,1,1)/sqrt(3) such that the same vector transforms to *V*=(sqrt(3),0,0). Now think of three random numbers. Say, (3,2,5) where your first number is oranges, second number is apples, and the third number is bananas. You can't change your basis vectors. You can't choose the basis vector (1,1,1)/sqrt(3) by rotating our coordinate axes. A basis of 1/sqrt(3) banana mixed with 1/sqrt(3) orange doesn't make sense. This set of numbers doesn't transform properly. So to sum up, a vector is something that transforms like... a vector. A column of numbers is something that doesn't. A tensor is to a matrix as a vector is to a column of numbers. A tensor must transform properly so as to give consistent and correct physical meaning to the object being analyzed. To be more clear, a vector is actually a rank 1 tensor. A 3x3 object that is a tensor is called a second rank tensor. A number, a scalar, is a 0th rank tensor. 
Here's a document I wrote to explain the difference between tensors and their representation. http://www4.ncsu.edu/~jrrowlan/pdf/tensors.pdf
Mind if I add this to the document below, giving you credit?
That's very nice.
"A basis of 1/sqrt(3) banana mixed with 1/sqrt(3) orange doesn't make sense. This set of numbers doesn't transform properly." Tangential question here, and probably very thick-headed, but is this essentially what is meant by "orthogonality"? 
I think this is what you want. Plot[Sin[x], {x, 0, 10}, Ticks -&gt; {{{Pi, 180}, {2 Pi, 360}, {3 Pi, 540}}, {-1, 1}}]
Pi in base pi is 10, e in base e is 10. 
So do you want to use the image as a background to a plot onto which you will plot points? Also, there's a Wolfram demonstration project which may be of interest: [Galactic Coordinate System](http://demonstrations.wolfram.com/GalacticCoordinateSystem/)
It is probably worth nothing that anything that *isn't* pi or e looks ugly as hell in those bases.
Integer multiples of powers (excluding multiples of n^x above n) of e and pi look fine as well.
Thank you, that's what I meant.
You want to use [Off\[\]](http://reference.wolfram.com/mathematica/ref/Off.html).
Personally I prefer to define a costum function to handle dynamic variables using the Dynamic head to match. So for instance I'll have a non dynamic function f[x_]:=x^2 And I'll define f[x_Dynamic] := {Slider[x, {0, 1}], Dynamic[x[[1]]^2]} This allows me to do whatever I want, if for instance only parts of my expression should be dynamic I can easily make it such, and you can even extend it to handle the different specifications that dynamic can have. You can build some functions around this to ease this see: [this Mathematica.StackExchange](http://mathematica.stackexchange.com/a/13691/1194) answer. 
I did learn one thing. The first time I called WorldPlot["USA"] it failed (I forgot how), after which I tried every different spelling of USA with and without quotes - still no go. After posting this question I called CountryData["USA", "Population"], which went online and cached a bunch of data. After that WorldPlot["USA"] worked. Unfortunately it only has the country outline and not the states.
How are you plotting the other countries / continents? For example, CountryData["UnitedStates", "Polygon"] // Graphics gives me a Plot of the United States, while there are also the other properties {"FullPolygon", "Polygon", "SchematicPolygon", "Shape"} What kind of data are you trying to plot?
I've only plotted other countries for testing. And for them only down to the country level. No state/principality, etc. I first started using WorldPlot, but from what I can tell that seems to be on the way out in favor of CountryData - the maps are certainly more detailed. I'm happy with the detail/projection of CountryData["USA", "Shape"]. I just want to be able to draw data for different states - possibly down to the county level. Imaging coloring the US map states red or blue to indicate republican/democrat in the last election. That's the kind of thing I want to do.
Solving for x. The numerical answer is ~1.85
Then what about y? How do you get 1.85 from that, and what exactly does it mean to look for an integer answer if you know there isn't one? I'm asking because I want to help construct a command that can solve this.
You need to have whichever variable you're not solving for defined already. Unless you're trying to solve for both x &amp; y in which case you need a second equation (2 variables to solve 2 unknowns). Either way, you can use "?Solve" to get help with using the intrinsic Solve function in Mathematica. If you were trying to solve for y in terms of x your input would look something like "Solve[1/2 x Sqrt[49 - y^2] + 49/2 ArcSin [x/7] + (49 \\[Pi])/12 == 0, y]". To put an assumption into Mathematica's solver it seems that you have to use the funtion "Reduce". As in, "Reduce[1/2 x Sqrt[49 - y^2] + 49/2 ArcSin [x/7] + (49 \\[Pi])/12 == 0 &amp;&amp; x \\[Element] Integers, y]".Trying it with your equation Mathematica seemed to just hang. Are you sure an integer solution exists? Hope this was somewhat helpful.
I made a mistake; the y should have been an x. 
Solve[(1/2)*x*Sqrt[49-x^2] + (49/2)*ArcSin[x/7] + (49 Pi)/12 == 0, x] Although I'm not sure what you mean by "solving for an integer."
You'll have to request a new activation key but I think that is pretty simple now through the website.
I bought MMA 7 for Linux a while ago, and decided to transfer to OSX. I had to contact Wolfram Inc. and get a new license. It just required that I fill out a form confirming that I would only install MMA on a single computer and that it was removed from the first one. No transfer fee. That was back in 10/2011.
Thanks for the advice. Not coming from a coding background it helps even to be shown the right direction.
I am not sure why you apply ToString to the character you supply. I guess that you are anticipating a symbol instead of a string, but that would be problematic if the symbol had a value. As duetosymmetry pointed out you can use regular expressions to match string patterns with Mathematica, but it is typically more readable to use the string pattern matching that mimics Mathematica’s expression pattern matching (these patterns are actually converted into equivalent regular expressions, so they are equally efficient). In this case you could write: h[s_, k_, n_] := DictionaryLookup[Repeated[_, {k - 1}] ~~ s ~~ Repeated[_, {n - k}]]
Using `Select` and `HammingDistance` you can do it quite simply: words = StringSplit[ Import["https://raw.github.com/nickknw/dailyprogrammer/master/114/selected_four-letter_words.txt"] ,"\n"]; Select[words, HammingDistance[#, "puma"] == 1 &amp;] gives: {"duma", "pima", "puja", "pula", "pump", "puna", "pupa"} And you don't need to actually generate all possible permutations, only check for words that is "one change away"
Thanks simon. I tried to load a few shape files and Import always returns this error: Import::fmterr: Cannot import data as SHP format. &gt;&gt; I tried the CA shape file from the census site as well as tl_2009_us_state.shp that I located on the web (MD5=1ced38b61ca6b20db2b4d80abf840866) Is there a module I need to import first?
Well, I wasn't able to figure out how to pull it directly from the tooltip (which would be cool for so many other things), but you can just spit out the various quantiles: Quantile[data1D, {0, .25, .5, .75, 1}] (* for 1D data *) Since you you have 2D data, we'll wrap a Map[] around it: Map[Quantile[#, {0, .25, .5, .75, 1}]&amp;,{dataP,dataV,dataR}] Then just put it in a pretty format, perhaps with labels, and there ya go. **EDIT:** I first tried with Median[data] for to find, well, the median. I noticed that this did not equal what was displayed for the BoxWhiskerChart median (which uses Quantile[data,.5]). **Here's why:** Median[] uses *linear interpolation (hydrologist method)*, whereas the default method for Quantile[] is *inverse empirical CDF*. This means that Quantile[] (with defaults) will always return a value that is found in the data, whereas Median[] will interpolate if the list is an even number of elements. [http://i.imgur.com/CcwUtO2.jpg](http://i.imgur.com/CcwUtO2.jpg)
The suggestion would be to not link to "23.23.152.36" and put up a mandatory field to enter a name and e-mail address. It looks distinctly fishy. 
yup, fishy indeed
as i understand it, an operator is basically a function. Why not define a function?
There are packages to do those kinds of calculations, google 'quantum mathematica package'
[This might help a bit](http://i.imgur.com/iDrSxhh.png), it's from working on simple models of a Hydrogen moecule, and is written in prolate spheroidal coordinates which is where the μ and λ comes from. [Here's](https://www.dropbox.com/s/is65anlxofkh698/CHM346%20David%20Foltin%202012.01.23%20HW1%20H2%2B%20cation%20report.nb) the full mathematica notebook, I fully assert that it is full of errors and factual inaccuracies but should otherwise help. Basically, use partial differentials for d/dx and throw psi right after it, and make psi a variable. Define your psi function, then plug it into the formula. Make sure T isn't evaluated until it is used by using :=.
You are looking for something like this: http://mathematica.stackexchange.com/questions/5030/having-the-derivative-be-an-operator It will allow you to create your own linear operators. Let me know how that works out, I'd be interested in seeing it.
It's there, note the '. If you prefer, you can write D[Psi[x],x] instead of Psi'[x].
Is it treating the numbers as strings? Maybe throw in a `ToExpression` somewhere.
can you post the content of random.dat ?
I made the assumption that contents of random.dat is a list of "to,from" node pairs connected by an edge. So I assigned them to a variable as so: network = {{"5,2"}, {"3,8"}, {"7,9"}, {"7,13"}, {"15,2"}, {"17,2"}, \ {"9,17"}, {"10,17"}, {"6,20"}, {"20,13"}, {"14,20"}, {"20,16"}, \ {"21,6"}, {"8,21"}, {"14,22"}, {"3,24"}, {"25,26"}, {"19,27"}, \ {"3,29"}, {"29,8"}, {"14,29"}, {"2,30"}, {"31,9"}, {"10,31"}, \ {"6,32"}, {"14,32"}, {"18,32"}, {"33,25"}, {"8,35"}, {"35,26"}, \ {"7,36"}, {"8,36"}, {"36,12"}, {"36,13"}, {"2,38"}, {"3,38"}, \ {"21,38"}, {"14,39"}, {"39,32"}, {"40,4"}, {"40,17"}, {"13,41"}, \ {"41,20"}, {"28,41"}, {"39,41"}, {"42,22"}, {"33,42"}, {"37,42"}, \ {"1,44"}, {"44,27"}, {"45,3"}, {"45,20"}, {"31,45"}, {"44,45"}, \ {"10,46"}, {"15,46"}, {"46,38"}, {"45,46"}, {"5,47"}, {"40,47"}, \ {"12,49"}, {"16,49"}, {"32,49"}, {"48,49"}, {"5,50"}, {"50,19"}, \ {"50,21"}}; And then constructed a graph as so: Graph[Flatten[ Map[StringReplace[#, "," -&gt; "&lt;-&gt;"] &amp;, network]] // ToExpression] Is this what you're looking for?
They are kind of hacky but these will at least work: fa[x_] = DSolve[{f'[x] == x^10 - 5. x^2, f[0] == 1}, f[x], x]; aactual = Table[{i/999., f[i/999.] /. fa[i/999.][[1, 1]]}, {i, 1, 999}]; or fa[x_] = DSolve[{f'[x] == x^10 - 5. x^2, f[0] == 1}, f[x], x]; aactual = Table[{i/999., fa[i/999.][[1, 1, 2]]}, {i, 1, 999}];
The help in mathematica is phenomenal, and I highly recommend you check it out. Like Drugbird says, the Functions that you are interested in are: * DSolve (for solving the differential equation) * Plot (for showing the solution) * Manipulate (for manipulating the plot) Good luck!
0x3A28213A 0x6339392C 0x7363682E
&lt;3
I don't have a copy of MMA readily available, so bear with me. ____ In general when doing something like this I would define a function sol[yy_]:=NSolve[x`*`yy`*`z==2,z] Flatten should work but doing something like Table[{z/.sol[y][[1]],z/.sol[y][[2]], z/.sol[y][[3]]},{y,1,10,1}] Should work too. There should be several way to do what you are asking for. If memory serves Table[{sol[y][[[1,2]],sol[y][[[2,2]], sol[y][[[3,2]]},{y,1,10,1}] Should do the same thing, but I might have the numbers in the [[..]] backwards. The point of those '[[..]]' are to tell it which elements of your array to go pick. To get an (x,y,z) triplet you would say something like Table[{x,y, sol[y][[[1,2]},{y,1,10,1}] You can then save that as a table and export it to a csv if you want to use it with excel.
Oops, you also wanted to export to excel? Okay, so take the list and use the Export command... mylist=(z /. (NSolve[x*#*z == 2, z] &amp; /@ y)) // Flatten; Export["mydata.csv",mylist,"CSV"] (* Use Directory[], SetDirectory["yourpath"], or the complete path to find/put your file where you want *) You can probably just use SystemOpen["mydata.csv"] and Mathematica will open it with your default *.csv" program (probably Excel).
hmm, it does seem to be something with adding the "Constants-&gt;{}" option doesn't it? You might try to SetAttributes instead. This worked for me: SetAttributes[{a,b},Constant]; TraditionalForm[Dt[x^2 y*b + a, x, y]] I found this [here](http://reference.wolfram.com/mathematica/ref/Constants.html)
Thanks I was able to mess around with it a bit today. I'm confused at what the syntax # and then the &amp; /@ y does, you wouldn't mind explaining it. One problem that I thought of though is the equation that I am is cubic and will give 3 outputs per one variable, is there any way to group these together easily? Or display how they are grouped? Ideally I'd like to be able to have each set of solutions to be a new row in excel, if that is possible. An example of what I am talking about: x = 5; y = {1, 5, 10}; (z /. (NSolve[x*#*z^2 == 2, z] &amp; /@ y)) // Flatten --&gt; {-0.632456, 0.632456, -0.282843, 0.282843, -0.2, 0.2} Now it's obvious to see which solutions are grouped together, but I am going to be processing with a lot of numbers, and each new number is going to have 3 solutions. I'm not sure if what I am doing is easily accomplished in excel (ex, every 3rd comma is a new row) or better accomplished in Mathematica, but either way I am open to suggestions. **EDIT:** So I think I figured it out: x = 5; y = {1, 5, 10}; m = (z /. (NSolve[x*#*z^2 == 2, z] &amp; /@ y)); Grid[m] Does exactly what I want it to. I'm still carious as to what z /. is doing and the whole # &amp;/@ y thing is if someone would care to offer explanations though. **EDIT 2:** So one thing I am wondering is how do I have it vary on a level higher than the base equation EX: let's say x=5; y={1, 5, 10}; b=(y*x) NSolve[b*x==1,x] I'm not super comfortable with the notation and I can't seem to figure out how I would go about doing this. **EDIT 3:** x = 5; y = {1, 5, 10, 50, 20, 30}; t = (#*3 &amp; /@ y) m = (NSolve[x*#*z == 2, z] &amp; /@ t) Seems to do what I was looking for. I had changed it a but so it isn't exactly like *EDIT2*, but you get the idea. Though if there is a better way to do that I'd be all ears. So I figured out that /@ is the 'map' command. I'm still curious what " z /." does in the beginning of the expression, does it just evaluate an arbitrary point number by number so it clears the NSolve output syntax? Also is the '&amp;' between the NSolve command and /@ just used as a separator, or is it doing something? **EDIT 4:** So I looked around a bit and it seems that it replaces all values with the new value. One thing that confuses me about its use is why do I need to use the same variable that I am solving for in NSolve? **Edit 5:** So I was thinking and the way I need to use this would have more than one value changing based on the same based value, EX: x={1,5,10}; a=(#*2&amp; /@x); b=(#*6 &amp; /@x); Now I need to solve the equation for Z: Z*a*b=5 What would be the best way to do this? I feel as if I should use the map command, but I'm not really sure how I should input it. Thanks for the help! 
Sorry for the late response! Thanks for the help, when I tried to input the commands you specified I came up with a bunch of errors, and I don't really know enough about Mathematica to try to find solutions. With that being said I think I am going to go with the solution that I outlined in response to KaliumRubicon. 
Why does the documentation tell me to type In[x]:= and Out[x]:? I can't seem to get that to output anything, and everytime I right click an expression it just places a little In[x]:= subscript infront of the line with some incremental number. Thanks for the pointers
Also am I using the right syntax for partial x, y, and cross derivative? I seem to be getting some really wacky results...
The documentation is presenting what you would see, but you are not supposed to type In[x] and Out[x]. That's how Mma shows you an input line and an output line. Those things also automatically get defined, so that if later you'd like to refer to the 9th output, you can simply type Out[9].
For **Edit 5**: I don't know if you want a*b (which only returns a list with length 3) or "Flatten[Outer[Times,a,b]]" which returns a list with length 9. since I assume "z*a*b==5" isn't working for you... then, define: c=Flatten[Outer[Times,a,b]]; and solve like normal except to map across "c"
The problem I'm having is having Mathematica evaluate with the numbers like I want, for example A will equal 2, 10, 20 B will equal 6, 30, 60 For the function a*z*b=2 I want to use a=2 , b=6 and then solve for z Then I want to to use a=10,b=30 and solve for z. And continue that with how many iterations I have.. The problem is that in order for Mathematica to do this it seems you have to make use of the map command. Let's say I just have a*z=2 To solve this I have to use NSolve[#*z==2,z] &amp; /@ a The problem I am facing is how do I define the function in NSolve with both a and b varying? I've tried a number of ways, I can't figure out how to get the result I described. Esentially I want NSolve[#*z*#==2, z] But I don't know how to map a for the first # and b to the second #. Hopefully that cleared it up a bit, thanks for all the help! 
This cleared things up a lot, thanks.
 junkx = Range[ 20] eqna = (2*#) &amp; eqnb = (6*#) &amp; param=2 junkab={eqna[#], eqnb[#]} &amp; /@ junkx junksol = (z /. NSolve[#[[1]]*#[[2]]*z == param] &amp; /@ junkab) //Flatten Export["junk.csv", Partition[Flatten[Riffle[junkab, junksol]], 3], "CSV"] SystemOpen["junk.csv"] use FullForm[Hold[blah]] if "blah" doesn't make sense then use Mathematica's help to find out the rest. 
Thanks for all the help! That clears it up. 
Ok, but ... did we get multiple levels of undo yet? This is 2013. And no, automatic history is not what I want.
1) Given what you know, in what form should the List be to have Grid give you the correct output? Should the List be n x 3 (where n is the length of "val")? 2)Once you know that form, how can you append the values of val to sln? If you look back at my previous responses, you'll see functions "Flatten", "Riffle", and "Partition". Read the documentation on those and play with them using your example to see if you can coerce the lists to match what you want. An alternate solution might use the "MapThread" and "Append" functions. 
Is this what you want? MapThread[Insert, {sln, val, Table[1, {Length[val]}]}]
Join[ Transpose@Range[3], sin, 2] Third parameter -&gt; dimension to glue along.
This does exactly what I was looking for thanks. 
Cool, looks like you have lots of solutions, these were the two I was originally envisioning: Partition[Flatten[Riffle[val, sln]], 3] and MapThread[Append, {sln, val}] if you care about the order in the last one: RotateRight[MapThread[Append, {sln, val}], {0, 1}]
Try sigma[t_]:=blah blah blah....... ; sigma[t] Make sure that "t" is a free variable, if you plan to use it often.
The issue is basically how can you make the output of a calculation be a function that can be used somewhere else right? Sorry if this sounds dumb but do you do lots of things like Qx[{x,y,z}].F[x,y,z,t]? Or is that the only one? 
Are you actually using sigma multiple times? Instead of defining a function, you could just type in a statement using t, assuming t hasn't been defined.
That's basically the issue, although with a caveat: if I just want to evaluate the output numerically, I can use replacement rules and Mathematica will just poop out what I need. The problem comes up when I need to symbolically differentiate the output. I have only a few things that looks like Qx[{x,y,z}].F[x,y,z,t], but I also have several that look like Qx[{x,y,z}].grad[f][x,y,z,t], or other compositions of that form (Qx with some operator, then hit f). I could write out Qx[{x,y,z}].F[x,y,z,t] explicitly and define the appropriate function, since I know F = {fx,fy,fz} ahead of time, however a general solution would be deeply appreciated.
Could you paste the actual lines? Not sure why you want/need to do this
Great idea. I'll try it out :)
This is quite an interesting question. I wish I knew how to answer it. I would have to investigate more or wait until someone more knowledgeable answers it.
I am not exactly sure what you are trying to do... If you are frequently changing the two "blah" sections and just want it to kinda update/simplify them, here is a way but it isn't so nice... DynamicModule[ {x,y}, { InputField[Dynamic[x]], InputField[Dynamic[y]], Dynamic[x*Sum[y, {ind, 0, 3}]] } // TableForm ] if you type "a" into both fields you'll get "4 a^2". or if you type "b" in the first and "a[ind]" in the second: "b (a[0]+a[1]+a[2]+a[3])"
I can't give you the syntax you want but (using your last example)... F[r_] := {r[[1]]^2 + r[[2]]^2 + r[[3]]^2, r[[1]], r[[2]]}; Qx[r_] := {{0, r[[3]], -r[[2]]}, {-r[[3]], 0, r[[1]]}, {r[[2]], -r[[1]], 0}}; div = {1, 1, 1}.Derivative[{1, 0, 0}][#][{x, y, z}] &amp;; (* **Edit** OP's edit makes this "div" incorrect for his/her use, see my comment below*) s2div=div; (* no real need to repeat is there? *) transF = Qx[#].F[#] &amp;; (* definition of a new head for the transformed function *) div[transF] (* or s2div[transF] *) -2 x + y + 2 x y + z - 2 x z 
This is perfect. I understand exactly what I need to do now, many thanks for the instructive example.
Oh, Given your edit, why not use the "Div" and "Grad" functions already built-in? newdiv= Div[#[{x, y, z}], {x, y, z}] &amp; Now, newdiv=div. (Maybe you actually care about the 4th element in the list: "t"? in that case, of course you probably know this, just add another element ("time") to the list of spatial arguments and, I guess, stick with an explicit way of defining the "div" function. Now all of the transformations (e.g. "Q") need to be 4x4 and "vectors" (e.g."F") have length 4.)
Using the built-in functions was my go-to solution, but the code deals fundamentally with recasting these operators on different manifolds (while still operating on vectors in R^3 instead of local coordinates). I threw in the original definitions explicitly (and as you noticed, some redundant definitions when the two cases coincide) in order to help the code document itself. You're totally right, though. These are exactly the standard Div and Grad. I still might go back to using them in a later version. Thanks again for showing me that you can recast the result as a pure function.
My pleasure, thanks for keeping us updated.
\[CapitalPsi][x_, t_] := c[1]*Sqrt[2/L]*Sin[(\[Pi] x )/L] + c[5]*Sqrt[2/L]*Sin[(5 \[Pi] x)/L] c[n] is a function that defines my coefficients. The function that I define is plugging in the coefficients, and then multiplying it by something else. So I just want it to 'print' out what it will be. So ending a line with ";" suppresses output. Is there a symbol that forces output?
Ah thank you!!!
Alternatively, you can use Show[ Plot1[...], Plot2[...]]. This is nice if, say, Plot1 is a regular plot and Plot2 is a contour plot.
I mocked up an example of this, in case people are interested: M = 10^3; Data = Table[HarmonicNumber[k], {k, 1, M}]; c = FindFit[Data, a Log[x] + b, {a, b}, x]; Print[ a Log[x] + b /. c]; Show[Plot[a Log[x] + b /. c, {x, 0, M}], ListPlot[Data]] This computes the first M (e.g. 10^3 ) harmonic numbers, then fits them to a logarithmic curve. For large M, a tends to 1 and b tends to .577..., the Euler-Mascheroni constant.
You could generate a table of y and y', and use ListPlot to graph it in the yy' plane. e.g. ListPlot[Table[{y, D[y, t]}, {t, 0,10,0.1}]]
`ParametricPlot[{y[t], y'[t]}, {t, a, b}]` where `a` and `b` define the range of `t`
Remove the colon from your definition of the function and it will automatically "print it out" for you. More explicitly, there are two ways of making assignments in Mathematica: *set* (=) and *set-delayed* (:=). The latter tells Mathematica to wait to evaluate the right-hand side of your definition until you feed a value to the left-hand side. Additional info can be read here: http://reference.wolfram.com/mathematica/tutorial/ImmediateAndDelayedDefinitions.html
Wow -- hearing that has brought such happiness into my day. I feel honored. And you are most welcome, westinger! I send good wishes your way. 
Okay so what I actually am trying to do: I have 3 results from 3 different theoretical equations. They are all related to the ionic radius of a certain atom. I need to try and combine the results to get *another* result - specifically, the ionic radius of that atom. It seems reasonable that these 3 numbers can be combined to give this radius, because of the way they relate to it. So, I need to just keep combining these 3 numbers in a bunch of different ways, and see if the ionic radius pops out. This would then let me work backwards and try to figure out a new equation giving the ionic radius. I'm wondering if wolframalpha can do it for me. So, for example, if the numbers I got were 1, 2, and 3, I'd like WA to do stuff like: 1x2x3 1x2/3 1x3/2 ln(1/3)x2 1(2x3)^2 etc. In a perfect world it would then organize them all nicely in a list, from the smallest result to the largest. I know it's a *ton* of different possible combinations, I just figured it was worth a shot.
The input syntax for Mathematica is usually pretty standardized. That being said, I know of no way to collect a set of functions (some with as many as three variables) automatically that would give the right amount of variability you desire. If we restrict ourselves to a predefined set of binary relations, say f[L_, 1] := L[[1]] + L[[2]]; f[L_, 2] := L[[1]] L[[2]]; f[L_, 3] := L[[1]]^L[[2]] then we obtain about half of what you seek as follows: P = Permutations[{X,Y,Z}]; Do[L = P[[i]]; Print[f[{f[L[[1 ;; 2]],j], L[[3]]}, k]], {j, 1, 3}, {k, 1, 3}, {i,1, Length[P]}] This doesn't get everything, because it always applies the binary operation to the first two variables, then the last. You can get the last "half" of outputs similarly, though. If you add in unary relations, or allow variables to be called multiple times, this problem gets hard quick. On a tangent, you might be interested in Plouffe's inverter: http://pi.lacim.uqam.ca/
Hey sorry, I went to sleep. What you're looking for is a technique called "inverse symbolic calculation". I am not aware of any code for ISC in Mma, but you could in principle write code to do it. Sorry I couldn't help more.
Ok thanks a lot! I'll look into it today. If it works it'll save me hours of work possibly.
You're going to have to use some rules, samloveshummus. That is, you're going to have to tell Mma which transformations to make rather than letting it choose. Pick a relation which results on a simplification and write a rule that corresponds to it. Here's a made-up example. Let's say we have a relation like F[x+1]+F[x-1] == 2 F[x]. You'll want to write a rule to make the transformation, SomeRule = {F[ x_ + 1 ] + F[ x_ - 1 ] :&gt; 2 F[x]}; Mma is not actually that smart, so you'll want to allow multiples in this rule, so a better rule is SomeRule = {a_ F[ x_ + 1 ] + a_ F[ x_ - 1 ] :&gt; 2 a F[x]}; Now take some big expression and apply the rule: F[3 x + 1] - 5 F[y + 1] + F[3 x - 1] - 5 F[y - 1] //. SomeRule Pattern matching is powerful but can sometimes be too restrictive. For example, this rule will not match F[6]+F[4]. There are other ways to write the rule so that it does, but then it becomes less efficient on the above form. For example, you can use the pattern test F[a_] + F[b_] /; a==2+b Anyway, I hope you get the idea. Your rules will obviously be much more complicated. Find the types of terms you have in your expression, and figure out the simplest rule that will reduce the number of terms you have. I can try to give you a hand if you can't figure it out. EDIT: I wrote one rule for you to get you started. This is following the identity from [here](http://dlmf.nist.gov/15.5#E12). E12Rule = { c1_ Hypergeometric2F1[a_ + 1, b_, c_, z_] + c2_ Hypergeometric2F1[a_, b_ + 1, c_, z_] /; (c2/c1 == -b/a) :&gt; c1 (a - b)/a Hypergeometric2F1[a, b, c, z]}; As before, it won't match everything that you think it will. It could have been written with c1 F[a1, ...] + c2 F[a2, ...] and include a1-a2 in the pattern test, and similarly with b1 and b2, so that it allows more cases—but it will be slower. Your mileage may vary.
Thanks so much, duetosymmetry. I hadn't seen the delayed rules ":&gt;" before. This solved my problem for the specific case I was calculating, but I don't know if it would work in a general case. You see, whereas the Simplify functions try a large range of possible transformations and output the form which is most "simple", the use of rules presupposes that we know in advance which transformation rule to use (and in which direction). This won't be the case in general, and I would like to be able to get Mathematica to "try" various possibilities like it does with simplify. 
Personally I find this very useful, and have used a more scaffolded version of this method to make a work-space browser ala MATLAB, which I've been using for the past couple of years. Since I got used to having such a gui in MATLAB and felt it was missing in Mathematica. That said I think your code is quite messy and could use some structuring. Here's a restructuring that cleans it up a bit: SetAttributes[values,HoldAll] values[symbol_Symbol] := Flatten[Select[{OwnValues[symbol],UpValues[symbol],DownValues[symbol]},#=!={}&amp;],1] values[symbol_String] := ToExpression[symbol,InputForm,values] valueStyling[exp_] := Replace[exp,head_[Verbatim[HoldPattern][symb_],rest__]:&gt;HoldForm[head[symb,rest]]] Dynamic[Refresh[ Style[ valueStyling/@(Flatten[values/@Names["Global`*"],1]) //Column//StandardForm ,"Input"], UpdateInterval-&gt;1]]
Thanks for cleaning that up. Want to share your "more scaffolded" version? I am very interested.
Working further on your example Dynamic[Grid[ Join[{{Style["Workspace", Bold, Blue, 16], SpanFromLeft}}, Sort[{Names["Global`*"], If[Head[ToExpression[#]] === List, Row[{"Dimensions: ", Dimensions[#], " Depth: ", Depth[#]} &amp;@ ToExpression[#]], Head[ToExpression[#]]] &amp; /@ Names["Global`*"]}\[Transpose], OrderedQ[{ToString[#1[[2]]], ToString[#2[[2]]]}] &amp;]], Frame -&gt; True], SynchronousUpdating -&gt; False, UpdateInterval -&gt; 10] I haven't included the downvalues since it tends to crash the kernel.
If you replace the PlotRange-&gt;All by PlotRange -&gt; {10^-400, 10^400} you will see that you are indeed reaching a limit of what plot can handle. My guess is that floating-point-precision is fixed for Plot. At least, fiddling around with WorkingPrecision did not help here.
For some reason (probably speed), Mathematica uses your computer's builtin limited numbers when plotting instead of its own arbitrary-precision numbers. These builtin numbers only go up to 2^(1024), but Mathematica screws up Plot at around 2^1013 (for a fun trick, try `Plot[2^1023,{x,0,1}]`). As you've discovered, your plot goes above this range, so you can't plot this using `Plot`. But Mathematica can still do the calculations. If you use something like `Table`, you can do the calculations with Mathematica's numbers to create a list of accurate `{x,y}` pairs, and plot those using `ListPlot`, which will work properly because it doesn't do any calculations. The line won't look as nice, but at least it'll be correct.
As m42a showed, Plot can't handle huge numbers. So let's scale our function to give Plot bounded numbers, and then tell it to label the tick marks with the actual values. Result: http://imgur.com/5OZEm6k Code: (* your function *) f[x_, t_] := Sqrt[Sin[t]] Exp[-x*Sin[4 t]] (* a normalizing version of your function, memoizing the normalizing \ factor *) Clear[fScaled, fMax]; fMax[x_] := N[#, 3] &amp; @ First @ Maximize[{f[x, tt], 0 &lt;= tt &amp;&amp; tt &lt;= Pi/2}, tt] fScaled[x_, t_] := Block[{max}, max = fMax[x]; fMax[x] = max; (* save calculated max *) f[x, t]/max] (* plot with tick labels rescaled by max *) plotScaled1[max_, params___] := Plot[params, Ticks -&gt; {Automatic, Table[{i, N[i *max, 3]}, {i, Range[0, 1, 1/4]}]}] (* plot with tick labels rescaled by max, trying to find "nice" \ valued for the ticks *) plotScaledTicks[scale_][lo_, hi_] := N[#, 3] &amp;@ {#/scale, # } &amp; /@ FindDivisions[{lo, hi}*scale, 5] plotScaled2[max_, params___] := Plot[params, Ticks -&gt; {Automatic, plotScaledTicks[max]}] (* check out our results *) GraphicsGrid[Table[plotFn[x], {plotFn, {(* Plotting the direct function *) Plot[f[#, t], {t, 0, Pi/2}, AspectRatio -&gt; 1, PlotRange -&gt; All] &amp;, (* Plotting the scaled function, with rescaled ticks *) plotScaled1[fMax[#], fScaled[#, t], {t, 0, Pi/2}, AspectRatio -&gt; 1, PlotRange -&gt; All] &amp;, (* Plotting the scaled function, with rescaled ticks, attempting to choose nice tick values *) plotScaled2[fMax[#], fScaled[#, t], {t, 0, Pi/2}, AspectRatio -&gt; 1, PlotRange -&gt; All] &amp; }}, {x, {10, 100, 1000}}], ImageSize -&gt; Full] 
Thats a handy tip. Thanks.
Will this save the data in matrix format? For instance if the first row of data was 1 9 0, followed by a second row of 2 3 4, will it read into and save in mathematica as {{1,9,0}, {2,3,4}}?
Well, I think it just imports it as a list. Try the post hoc //MatrixForm and see what happens.
Well there's the builtin Mathematica documentation ... Use of loops is kind of discouraged, though. If you are doing the same thing to every element of a list (or list of lists, or basically any expression) you can write that with Map. There are a lot of wholemeal (rather than piecemeal) functional programming tools in Mma like Map, Apply, Select, Cases, etc.
Yeah I've seen the general concensus on stackexchange but unfotunately that doesn't help me when most code I'm reading for a class uses loops so extensively. Every homework assignment I've done integrates them in some way and I really want to understand it.
Oh I completely agree. So what are the alternatives to loops? I really want to become a better programmer in mathematica. 
You may want to use MatchQ instead of FreeQ, to make a more specific pattern, like the whole expression. If you want to test things out, maybe use With, e.g. With[{response=HoldForm[1+2 Sqrt[3]/3]}, key = ...; ReleaseHold@key == ReleaseHold@response &amp;&amp; MatchQ[...] ] EDIT: By the way, Mma also has ===, ala SameQ, which tests for the expressions being identical, rather than just numerical equality. == (Equal) also has the bad characteristic that if Mma can't tell if two expressions are equal, then it just stays unevaluated as an equation, rather than always spitting out True or False like SameQ does.
I can't figure out what the symbol between t and tmax is, and can't enter it into my code! Any help? EDIT: I'm adapting some code from the wolfram demonstrations for my own use, and currently entering it into my own notebook
Oh, look, orbitals! As by my username, I have spent a reasonable amount of time making orbital plots in Mathematica. I have done the coordinate substitutions using /. though I don't know if that would make a difference. One thing that's not clear to me -- how is the contour value being picked, i.e. the value c at which you want plot all those (r,theta,phi) such that psi(r,theta,phi) = c? Have you checked to make sure your pd is actually producing a pure real result? In the past when I've done that sort of thing I had to use a Re[] to get rid of a nonexistant imaginary part that confused plotting and numerical routines. I can do 2D contour plots in e.g. the xy plane without a problem. Its been a while since I tried doing what you're doing. 
Thank you for the suggestion, sandwichsaregood, but quantum-mechanic is correct - my function is of three variables and SphericalPlot3D only accepts a function of two. But thank you anyway!
Great suggestions. I'm going to try the /. (replace all) for my variable substitutions, and I'll also try specifying a specific contour to plot. And good call on the function outputting imaginary answers. I'll try that too. **UPDATE:** The only change I had to make was switching from using the With[] function for my coordinate conversions to using the /. for my coordinate conversions. See the new code below. conPlot3D[n_,\[ScriptL]_,m_,r_,\[Theta]_,\[Phi]_,win_]:=ContourPlot3D[( pd[n,\[ScriptL],m,r,\[Theta],\[Phi]]/.{r-&gt;Sqrt[x^2+y^2+z^2],\[Theta]-&gt;ArcCos[z/Sqrt[x^2+y^2+z^2]],\[Phi]-&gt;ArcTan[y/x]}),{x,-win,win},{y,-win,win},{z,-win,win},Contours-&gt;1,PerformanceGoal-&gt;"Quality",Mesh-&gt;7,AxesLabel-&gt;{"x","y","z"},PlotLabel-&gt;{n,\[ScriptL],m}]; That is, instead of plotting With[{r=Sqrt[x^2+y^2+z^2],\[Theta]=ArcCos[z/Sqrt[x^2+y^2+z^2]],\[Phi]=ArcTan[y/x]},pd[n,\[ScriptL],m,r,\[Theta],\[Phi]]] I plotted (pd[n,\[ScriptL],m,r,\[Theta],\[Phi]]/.{r-&gt;Sqrt[x^2+y^2+z^2],\[Theta]-&gt;ArcCos[z/Sqrt[x^2+y^2+z^2]],\[Phi]-&gt;ArcTan[y/x]}) Not sure why it made the difference, but thanks, quantum-mechanic! Here's the new plot http://imgur.com/WGwovHA
Ah thank you for the correction. The ParametricPlot3D function, though, only allows for the function to be parameterized by one or two variables. Unfortunately I need three (r, \theta, and \phi). Is there a way to do this that I'm unaware of?
He was trying to plot a surface in 3D, which is exactly what he said. There's no parametric functions here at all, just one function of three variables of which he wanted to "contour" from 4D back to a 3D picture. Which he was trying to plot. And apparently succeeded!
If 'e'; 'a'; 'c' are lists and "t" is their index and the length of e and c are one less than a, Try this: ineqlist = (c[[#]]+q*a[[#+1]]&lt;=e[[#]]+a[[#]])&amp;/@Range[Length[a]-1]; expression = And@@ineqlist; 
Another way, keeping closer to your example that worked, would be this: rhs = ( ( e + a[[1;;-2]] - c) / q) - a[[2;;All]]; (*assuming 'q' is a constant*) expression = And@@Map[ LessEqual[0,#]&amp; , rhs ]; 
You are a lifesaver, thanks so much!
How about this: parabola[x_] := x^2; wavevec = 1; newparabola[x_] := Table[parabola[x + 2*ind*wavevec], {ind, -5, 5}]; Plot[newparabola[x], {x, -wavevec, wavevec}]
Maybe my solution is kinda naive but I think its what you want. f[x_] := x^2 g[f_, A_] := {f[x - 2 A], f[x], f[x + 2 A]} Plot[g[f, 2], {x, -2, 2}, AspectRatio -&gt; Full, PlotRange -&gt; {All, {0, 30}}] The PlotRange -&gt; {All, {0, 30}} means show me everything in the x axis and from 0 to 30 in the y axis. I hope this is useful to you.
The fancy way of doing this would map the function using modular arithmatic. The simple way of doing this would be to break apart the function at the boundaries and map those sections with a horizontal shift i.e. y=a*x^2 + b -&gt; y=a*(x+c)^2 + b
A great adventure awaits you! Read up on [rules](http://reference.wolfram.com/mathematica/ref/Rule.html) and [patterns](http://reference.wolfram.com/mathematica/tutorial/Introduction-Patterns.html) and [rules and patterns together](http://reference.wolfram.com/mathematica/guide/RulesAndPatterns.html) and higher-order functions like [Map](http://reference.wolfram.com/mathematica/ref/Map.html?q=Map&amp;lang=en). You will be able to solve your problem with a suitably arcane combination of Map and and Fold and such like, or by writing your own recursive rules. And in other ways.
No recursion needed, just Map, Apply, and Flatten ;) See my answer. Mma is not that great with recursion, anyway, which is kind of sad.
Yeah, I rarely find all the #&amp;/ stuff the best place to start, and I _really_ don't think it's an appropriate paedagogical response to a question like OP's. Your mileage may vary.
Well all the syntactic sugar can always be stripped away: g[x_] := Flatten[{x, Apply[f, Partition[x, 2, 1], {1}]}, {2, 1}] But is that better?
I think that somone new to this kind of work has a much better chance of grasping what is going on with the functions named. I also wouldn't categorize those sigils as syntactic sugar. Almost the opposite.
Thank you, this has been brilliant. I have been able to combine this with a bit of my own stuff to get what I needed. This is the final result: http://imgur.com/a/UDm7V#0
More like syntactic methamphetamine. 
Last year I did a quick demo of Mathematica at a programming conference. Viewed *as a programming language* and *from the point of view of professional programmers* Mathematica is a shockingly awful piece of work. It embodies almost none of the principles that we know make programming languages easy to work with. It's almost as if there are no programmers working at Wolfram. Which can't be true, obviously, but they seem to have had no influence on how the programming language that's in there works.
Anyway we could see the code? I'd love to learn from this.
This is a levy fractal, who's motif takes a line and replaces it with two perpendicular lines intersecting the original at its endpoints. Keep that in mind, especially when thinking about what f is doing. It's probably inefficient, but here it is: f[a_, b_] := (a + b)/2 + I (b - a)/2; g[x_] := Flatten[{x, f @@ # &amp; /@ Partition[x, 2, 1]}, {2, 1}]; Co[a_] := Transpose[{Re[a], Im[a]}]; G[0, {a_, b_}] := {a, b}; G[1, {a_, b_}] := g[{a, b}]; G[n_, {a_, b_}] := g[G[n - 1, {a, b}]] f takes complex numbers a &amp; b and averages them, then adds to this the "vector" from b to a rotated by 90deg. g is explained above. co takes a complex number a+bi and gives {a,b}. It has transpose in it as, without it, when a is a list like {a1+b1i,a2+b2i,a3+b3i}, it would give {{a1,a2,a3},{b1,b2,b3}}, rather than what is wanted, {{a1,b1},{a2,b2},{a3,b3}}. G is a recursive function to generate the long lists (and they do get very long, the nth list has 2^(n-1)+1 entries). It does this by putting the numbers a and b though g n many times. G allows any two complex numbers a seeds, but it really doesn't do much more than rotate the image a bit. To make the images I used these: Export["18Ccurve.png", Image[Graphics[Line[Co[G[18, {0, 1}]]]], ImageSize -&gt; 3000]] Co[G[18, {0, 1}]] is the list of coordinates of the 18 iteration of g[{0,1}]. Line joins these. The rest allows it to be exported as 18Ccurve.png. Image size just changes the approximate width. The biggest I have made using this code is a 22 iteration 11,000x7,021 image. I tried a 25 iteration 1,000x6,383, but my computer ran out of ram (16GB!). Export["C-curveL.gif", Table[Image[Graphics[{White, Rectangle[{-.5, -.25}, {1.5, 1}], RGBColor[0*(Floor[n/5]/16), 0, 0], Line[Co[G[Floor[n/5], {0, 1}]]]}], ImageSize -&gt; {500, 283}], {n, 1, 17*5 - 1}]] Much of this is the same, but as it is a gif, it needs to be a table of images before the export. I have Floor[n/5] in G and RGBColor to account for the 17\*5-1 frames. Originally, I had just n and 17, but the gif went to fast, so I put 5 frames per iteration. I have RGBColor[0\*(Floor[n/5]/16),0,0] to make the line more red as the gif progressed, but I wanted to turn that off so I multiplied it by 0. The White rectangle is to make all the images the same size, as otherwise the points (0,0) and (1,0) would drift during the gif, the opposite of what was wanted. As I say, probably inefficient, (looking back now, there are several things I would change) but it works and was fun to work on. Hope that helps.
You're a gentleman and a scholar, this is deserving of reddit gold (if I had any). 
It's old (1996, covering Mathematica v3) but pretty well-written.... The core of the language hasn't really changed since then, so most of the information is still relevant.
The solution it is giving is correct as long as you pick any 5 integers C[1] through C[5]. In a slightly cleaner form: { {a -&gt; C[1]}, {b -&gt; C[2]}, {c -&gt; C[3]}, {d -&gt; C[4]}, {e -&gt; C[5]}, {f -&gt; 2 - C[2] + C[4] + C[5]}, {g -&gt; 2 + C[1] - C[2] - C[3] + C[4] + C[5]}, {h -&gt; 2 + C[1] - C[3] + C[5]}, {i -&gt; C[3] + C[4] - C[5]}, {j -&gt; C[1] + C[2] - C[3] - C[4] + C[5]}, {k -&gt; -C[1] + 2 C[3] + C[4] - C[5]}, {l -&gt; C[1] - C[3] + C[5]} }
That would be pretty cool. What tools are you thinking of using? One thing to keep in mind: a 2D global map is already distorted according to the projection chosen. So you need to decide what is the best projection to start from right? Maybe the one everyone is already familiar with would give people more of a sense of what the distortion mean, but then again, with that projection far north and far southern regions have hugely exaggerated areas: the downside is that these will be distorted even more since commute times here are likley to be some of the longest (land routes anyway). So an equal area projections would probably be better suited to the purpose. But again, most people aren't used to equal area maps, so there will be some sense of commute-time distortion lost on most people. One possible solution is to do an equal area projection one continent at a time and just put them together at the end. http://en.wikipedia.org/wiki/Map_projection http://en.wikipedia.org/wiki/Equal_area_projection#Equal-area This might be a good projection to use http://en.wikipedia.org/wiki/Dymaxion_projection
Are you having issues programming the solution, or finding the solution?
Are you allowed to treat earth as a sphere or a geode? Also rotation has no effect on gravity. Is s/he instead asking for the normal force at a given lat?
i think you're talking about the centripetal force caused by the spin, which does change. However the force of gravity is irrelevant of motion. so if the question specifically asks for the force of gravity then spin can be ignored. an i missing anything here?
Yes. The instructor seems to be using "observed acceleration due to gravity" as shorthand for "observed net force on an object in freefall, from your (non-Newtonian) viewpoint". This will be affected by the rotation, and will cause an error when attempting to measure the "force of gravity" using a naive testing method.
It sounds like he just wants to know how much earth's rotation affects the gravity of earth at a given latitude. The acceleration due to gravity alone ist just g = M * G / r^2 ~ 9.788 m / s^2 The rotational acceleration is a bit harder to calculate. We know the formula for centrifugal *force* is F = m * v^2 / r to get the acceleration we insert into F = m * a m * a = m * v^2 / r a = v^2 / r v is the rotational speed of earth v = 2 * pi * r / T Now all we need is r. This is where the latitude comes in, because a depends on the radius to the center of rotation, not to the center of earth. You want to calculate how far you are away from earth's rotational axis at a given latitude theta. This is just r(theta) = r * cos(theta) | -90° &lt; theta &lt; 90° Insert that into our formula for v and a and you get a(theta) = 4 * pi^2 * r * cos(theta) / T^2 Just subtract this from the calculated value for g and you got your formula of the observed acceleration. To calculate the fractional error, subtract g and divide by g. The curve I get does not quite correlate what wikipedia says, but apparently a better value for earth's mean radius is 6.37 * 10^6 km. If you use that as your radius it works almost perfectly. I should say I am nowhere near qualified to answer this, so you should check everything I did, especially the technical terms I used, because English isn't my first language.
So before Einstein came along there was a special class of forces called "Fictious Forces" and are due to an observer moving in a non-inertial ( accelerating ) reference frame. Centrifugal forces are a part of this, so are coriolis forces. Einstein's big break through was the equivalence principle. It says that you can not tell the difference between an inertial mass and a non-inertial mass, and therefore these fictious forces are equivalent to gravity. So from that viewpoint gravity DOES depend on motion. Tl;Dr the key here is accelerating reference frames, not gravity.
Are you setting the value for x1,y1,z1? Also - do not believe you can overwrite the q/w/p variables inside the module. If you can provide more context, might be able to guide you a little more.
Okay, now i realize what i need to do. thanks 
Thanks! I saw someone pointed this out on stack exchange too. I appreciate your time!
Well, thankfully stackexchange came to the rescue: http://mathematica.stackexchange.com/questions/24099/smoothing-averaging-2d-vector-fields Here's a simple 2D vector field de-noise using the Mathematica Gaussian filter: f = Sin[2 x + 2 y]; data = Flatten[Table[{{x, y}, {Cos[f], Sin[f]}}, {x, -1, 1, 0.1}, {y, -1, 1, 0.1}], 1]; noisydata = Flatten[Table[theRand = RandomReal[{-\[Pi]/6, \[Pi]/6}]; {{x, y}, {Cos[f + theRand], Sin[f + theRand]}}, {x, -1, 1, 0.1}, {y, -1, 1, 0.1}], 1]; args = noisydata[[All, 1]]; datVals1 = GaussianFilter[noisydata[[All, 2, 1]], 5]; datVals2 = GaussianFilter[noisydata[[All, 2, 2]], 5]; denoised = Transpose[{args, Transpose[{datVals1, datVals2}]}]; GraphicsGrid[{{ListVectorPlot[data], ListVectorPlot[noisydata], ListVectorPlot[denoised]}, {ListStreamPlot[data], ListStreamPlot[noisydata], ListStreamPlot[denoised]}}]
What platform? Maybe you have a PATH issue? If you suspect it's MikTeX, did you try uninstalling that?
I considered that but the problem is that I have to use MikTeX to write a paper due tomorrow so I don't really wanna risk the uninstall. I emailed Wolfram hoping that they have an answer.
I think that it might be a path issue. I considered uninstalling but the problem is that I have to use MikTeX to write a paper due tomorrow so I don't really wanna risk the uninstall. I also installed a new version of ghostscript. Do you know if mathematica uses ghostscript to write its pdfs?
Since gravity is an attractive force you are missing a minus sign in the second derivatives. Besides you’ve started the motion very fast and very far from the massive object so the trajectory will be almost unaffected. Try this: {fx, fy} = {x, y} /. First@NDSolve[{ x''[t] == -x[t]/(x[t]^2 + y[t]^2)^(3/2), y''[t] == -y[t]/(x[t]^2 + y[t]^2)^(3/2), x[0] == -2, y[0] == 0, x'[0] == 0, y'[0] == .5 }, {x, y}, {t, 0, 10}]; ParametricPlot[{fx[t], fy[t]}, {t, 0, 10}]
With `solution = NDSolve[...]`, the function you want is: &gt; `ParametricPlot[{x[t],y[t]}/.solution,{t,0,100}]` I'm not sure the DE you specified gives the solution you're looking for though!
Great, thanks guys, looks like I left out the minus signs from each equation. Works like a dream now!
Okay I've solved everything except one last detail, which is to add a sphere that orbits a central sphere (i.e. an Earth-Sun simulation). This is my code so far: orbit1 = NDSolve[{x''[t] == -(6.672*10^-11) (7*10^17) x[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), y''[t] == -(6.672*10^-11) (7*10^17) y[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), z''[t] == -(6.672*10^-11) (7*10^17) z[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), x[0] == 1000, y[0] == 1000, z[0] == 1000, x'[0] == 100, y'[0] == -100, z'[0] == 0}, {x[t], y[t], z[t]}, {t, 0, 1000}]; orbitplot = Animate[Show[{ParametricPlot3D[{x[t], y[t], z[t]} /. orbit1, {t, 0, a}, PlotRange -&gt; {{-1500, 1500}, {-1500, 1500}, {-1500, 1500}}], Graphics3D[{Yellow, Sphere[{0, 0, 0}, 100]}, {Green, Sphere[{x[t], y[t], z[t]} /. orbit1, 50]}]}], {a, 0, 100}] As you can see, I've tried creating a green sphere (Earth) which takes on the coordinates of orbit1 with the command, {Green, Sphere[{x[t], y[t], z[t]} /. orbit1, 50]} But it doesn't seem to show up when the animation plays.
Okay so I've managed to make an animation of the "Earth" and some other planets orbiting the "Sun", but I have a big problem. The planets start out orbiting pretty well, but after a little while the orbits kind of start to go haywire. I'm not too sure if it's a problem of the numerical solution or just because the orbit lines are redraw again and again over each other which starts using up too much memory. This is what it looks like starting out: [Imgur](http://i.imgur.com/2ngkcdR.png) And this is what it ends up looking like: [Imgur](http://i.imgur.com/2ngkcdR.png) Here's some of the code which solves the system of DEs for the first planet (the other orbits are exactly the same, except for their initial conditions): orbit1 = NDSolve[{x''[t] == -(6.672*10^-11) (7*10^17) x[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), y''[t] == -(6.672*10^-11) (7*10^17) y[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), z''[t] == -(6.672*10^-11) (7*10^17) z[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), x[0] == 1000, y[0] == 1000, z[0] == 1000, x'[0] == 100, y'[0] == -100, z'[0] == 0}, {x[t], y[t], z[t]}, {t, 0, 1000}]; And here's the code for animating and plotting the position of each planet: orbitplot = Animate[Show[{ParametricPlot3D[{{x[t], y[t], z[t]} /. orbit1, {x[t], y[t], z[t]} /. orbit2, {x[t], y[t], z[t]} /. orbit3}, {t, 0, a}, PlotRange -&gt; {{-1500, 1500}, {-1500, 1500}, {-1500, 1500}}, AxesLabel -&gt; {x, y, z}], Graphics3D[{Yellow, Sphere[{0, 0, 0}, 100], Green, Sphere[{x[t], y[t], z[t]} /. orbit1 /. t -&gt; a, 50], Blue, Sphere[{x[t], y[t], z[t]} /. orbit2 /. t -&gt; a, 50], Purple, Sphere[{x[t], y[t], z[t]} /. orbit3 /. t -&gt; a, 50]}]}], {a, 0, Infinity, 0.1}] If anyone knows how to solve this problem I'd really appreciate it. Cheers!
You didn't say what the problems are, so it would be hard to guess. But take a look here: http://mathematica.stackexchange.com/questions/tagged/cudalink There are a number of CUDA-related problem descriprions with solutions. 
Thanks!
I'm not aware of a built-in function that does exactly what you want. But if you want to dump differences isn't it just a matter of list1 - list2? The output will be a list of the deltas. If you want True/False then Equal[#, 0] &amp; /@ (list1 - list2) 
Thanks!
This is a very general question and not really specific to Mathematica.but if you just want to search for similar sounds. just split it up. Yo might want to do some filtering and such to the signal before chopping it up but it all depends on what type of sounds you are looking for and what the background is like.
Not[Boole[a-b]] works, too (if a and b are lists of numbers). 
Thanks!
Very useful. Thanks! I once tried right-clicking on an animation and doing Save As... .gif, but ended up with a 1GB file. :D
Since "a" is your changing variable, you need the earth sphere coordinates as {x[a],y[a],z[a]}. The way to do this is to go back and change your NDSolve to solve for the more general {x,y,z}. Then your intepolating functions can take any variable. Also you've got too many brackets within the Graphics3D function. The primitives should just be a single list. Here's a cleaned up version of the code: soln = First@NDSolve[{x''[t] == -(6.672*10^-11) (7*10^17) x[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), y''[t] == -(6.672*10^-11) (7*10^17) y[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), z''[t] == -(6.672*10^-11) (7*10^17) z[t]/(x[t]^2 + y[t]^2 + z[t]^2)^(3/2), x[0] == 1000, y[0] == 1000, z[0] == 1000, x'[0] == 100, y'[0] == -100, z'[0] == 0}, {x, y, z}, {t, 0, 1000}]; Animate[Show[ParametricPlot3D[{x[t], y[t], z[t]} /. soln, {t, 0, a}, PlotRange -&gt; {{-1500, 1500}, {-1500, 1500}, {-1500, 1500}}], Graphics3D[{Yellow, Sphere[{0, 0, 0}, 100], Green, Sphere[{x[a], y[a], z[a]} /. soln, 50]}]], {a, .001, 50}] [animation](http://i.imgur.com/2ncDAHE.gif)
http://mathematica.stackexchange.com/questions/4272
You want a delayed definition. Use := instead of =. The difference is that with =, Mma evaluates the RHS when you hit enter and assigns it to the LHS. With :=, the evaluation does not happen until the LHS is actually evaluated in an expression. In the case of =, you would have the *current value*, at define time, of matchArray appearing in the definition of b. In the case of :=, matchArray doesn't need to be defined yet, it only needs to be defined at the time when you evaluate b. If the value of matchArray changes, then a new evaluation of b will yield the new value of the sum. You could also pass matchArray as an argument to b. If you are worried about the types of the inputs, you can be super careful with your patterns, e.g. b[x_Integer?Positive, y_Integer?Positive] /; (x&lt;=y) := ... Hope that helps. Use the docs. Learn and love pattern matching. Sorry about Mma's shitty scoping rules and evaluation order rules.
Thanks a lot I am going to try := out. I actually changed the right hand side into an If statement to make the function work regardless of whether x&lt;=y and it cleared up the error messages. strange. I have been enjoying this foray so far.
If you mean to go from the lesser of x,y to the greater of x,y then you should do away with the If statement. This is not C/Fortran/etc., it's more like Lisp—it's supposed to be more of a functional language. Instead, just use Min[x,y] and Max[x,y].
Yeah, that is a problem I'm encountering. I am so used to procedural attacks that it is really challenging to reframe my thoughts functionally. I figure over time with experience this will change. Thanks for all the input! :)
Whelp, this just might be beyond the scope of NDSolve. Despite the fact that Mma has such a function, there really aren't any "general purpose" PDE solving schemes. NDSolve tries to analyze your problem (symbolically) first and determine if it is a boundary value problem for which it should try some sort of relaxation scheme or an initial value problem for which it should do something like method of lines. Have you analyzed this problem? Do you know if it has a Cauchy problem? Should you (in principle) be able to solve it as an evolution scheme? I think Mma is confused about the type of problem you have at hand here (and from my cursory look, I thought it was a BVP except you are not giving data on the whole boundary, so that can't be right).
Thanks for your reply! I'm going to email my professor and ask him some of your questions. As I said, I don't know much about PDE's or ODE's and I'm still trying to read up on it, so I'll try again later on when I have more knowledge about Mathematica/PDE's.
Thank you! I will email my prof about the boundary conditions and see if he has left some out.
Could you please elaborate on the toolbox? Are there some other functions that I can look into? I've never used Mathematica before so it'd be great if you could point me in the right direction.
I don't think /u/thtu was referring to a toolbox within Mma, but rather just the standard tools—e.g. trying separation of variables, looking for special solutions like solitons, perturbation theory for weakly nonlinear solutions, looking for some conserved integrals of solutions, those sorts of things.
You really need to go through some of the official mathematica tutorials, and read up on differential equations, before asking more questions. You've basically said you are totally ignorant and you would like other people to do your work for you.
Ah, I've just finished my second year undergrad majoring in Math, but I'm focusing more on probability and statistics so I'm only planning on taking ODE's next year. I'm reading "Paul's Online Notes for ODEs", and "Solving PDEs with Maple and Mathematica", so hopefully when I finish those I'll know what I'm doing. I posted when I didn't have a clue because I thought if there was a small error that could be easily corrected, I could get the solution to my prof faster. Thanks for all help! I really appreciate it.
&gt; This can easily be reduced to 2-3 terms How do you know? 
it comes down to (x-h) just 2 unknowns. I went through the painful process of solving it.
Did you try FullSimplify[Solve[...]]?
Whenever I hear a student ask, "Why do I have to learn this if I can just make a computer solve it?" I like to give the simple explanation that computers aren't always right. Being able to understand the nature of the problem can help to show the nature of the solution. If your anticipated solution doesn't match the computer's solution, there may be an error, either by you or by the computer. I know it's not really a lesson for you, but I plan to use your example when I'm tutoring bratty kids.
Computers are always right. If they are wrong, its either error via input (human) or error in programming (human). Computers are very good at doing specific set tasks very fast and completely accurate. Humans are good at thinking abstractly.
MapAt[1/# &amp;, matrixInput, {All,1}]
1/matrixInput[[All,1]]
The other answer only maps the function to the first row, not the first column of each row. Try either of these: data = RandomReal[{0, 100}, {10, 2}]; {1/#[[1]], #[[2]]} &amp; /@ data MapAt[1/# &amp;, data, {All, 1}]
How about: Framed[Plot[Sin[x], {x, -2, 2}]]
I'm not sure if this is exactly what you meant, but try this: p = 0.8; maxdepth = 4; tree[n_, f_] := (If[Length[Flatten[n]] &gt; maxdepth, {}, If[RandomReal[] &lt; p, Table[{n -&gt; {n, i}, tree[{n, i}, f]}, {i, f}], {}]]); tree[k_] := tree[{0}, k]; t = tree[3]; GraphPlot[Flatten[t]]
Didn't paste very well: http://pastebin.com/TvBMTM2X
Thanks! However, it returns an error: GraphPlot::grph: tree[{0},3] is not a valid graph. &gt;&gt;
When I pasted it, some underscores went missing.. You'll need to copy and paste from pastebin - http://pastebin.com/TvBMTM2X
Yeah, sorry. Everything's great now, thanks!
Does the same thing happen on new notebooks? If not, it's the stylesheet that is causing this, and you will want to check [InputAutoReplacements](http://reference.wolfram.com/mathematica/ref/InputAutoReplacements.html). 
Yes it does. If the InputAutoReplacements setting is incorrect, though, then why would copy-and-paste of the odd text still *work*? If the registered symbol is wrong and not just an encoding or a font error, then shouldn't the statement itself generate an error?
You need to use the directive [Texture](http://reference.wolfram.com/mathematica/ref/Texture.html).
Edited to make the conditions in the FindInstance function to be symbolic instead of the hard-coded values for your specific case.
could you elaborate? I'm having trouble replacing the colour for a texture on the object. Essentially I just want text to be placed on top of each side of the rubik's cube - with the text being scrambled up with the colours. It would be no problem to change the actual colour of the cube sides, however creating images to place on each side of the cube instead of the colours (and having them scrambled up) is the difficult part. 
Thank you so much! It works perfectly.
Awesome! Glad to hear it!
You could do something like this: y = Interpolation[Table[{t - Sin@t, 1 - Cos@t}, {t, 0, 4 Pi, .01}]]; Plot[{y[x], y'[x]}, {x, 0, 4 Pi}]
I'm just going to believe you that y is not expressible in terms of x. If this is so, then you need to approximate an answer. There are different ways you can do this. If you know the range of x-values before hand (or use periodicity or something) you can build a table of (x,y) values and use that to interpolate your value. Another option is to numerically try to find inverse relationships. Something like: you're given a value for x. Solve x=t-Sin[t] for t numerically and plug this value into y. You would get something like (untested, just spitballing here). y[x_]:=Block[{t},t=NSolve[x==t-Sin[t],t]; 1-Cos[t] ]
What about y[x_] = 1 - Cos[InverseFunction[# - Sin[#] &amp;][x]] ?
There were some odd errors I didn't understand about a protected tag function, but this effectively seems right. Thank you much.
Eliminate[x == t - Sin[t] &amp;&amp; y == 1 - Cos[t], t] Solve[-2 x ArcCos[1 - y] + ArcCos[1 - y]^2 == -x^2 + 2 y - y^2 || 2 x ArcCos[1 - y] + ArcCos[1 - y]^2 == -x^2 + 2 y - y^2, x] {{x -&gt; -Sqrt[2 y - y^2] - ArcCos[1 - y]}, {x -&gt; Sqrt[2 y - y^2] - ArcCos[1 - y]}, {x -&gt; -Sqrt[2 y - y^2] + ArcCos[1 - y]}, {x -&gt; Sqrt[2 y - y^2] + ArcCos[1 - y]}} Throw in periodicity/symmetry and you pretty much have it depending on what you're trying to do. You may need to solve the equations numerically, though.
Hellooooo
I think I understand what you want, so here's a try at answering. BlankSequence is the right way to go. I think it's best to explain this one by example. If we have f[x__]:={x} (note: two underscores there), then doing stuff like: f[1, 2, 3, 4, 5] =&gt; {1, 2, 3, 4, 5} And f[1, 2, 3] =&gt; {1, 2, 3} So, you can have something like getitem[array_, index__] := array[[index]] And then you can do something like getitem[IdentityMatrix[3], 1, 2] =&gt; 0 but also it will work on higher dimensional stuff, getitem[LeviCivitaTensor[5], 1, 1, 1, 1, 1] =&gt; 0 Is that helpful? There's other ways to do it, but this is probably the simplest.
Yeah that's what I'm playing with right now. I am trying to blend blanksequence with the definition of table that allows for more robust bounding: Table[f,{i,{i1,i2,i3,...}}] which returns {f[i1],f[i2],...} I feel like this might be strong enough to handle what I need done if I can make the indices complicated enough. Gah. I know exactly what I need to do in my head but making it codeable is always hard.
You can use this: Outer[Flatten[{##}] &amp;, ##, 1] &amp; @@ x[[y]]
 Found this code [here](http://pastebin.com/JEhqyvHx) but this uses GraphPlot. It's pretty nice.
To show the list {h[x], h[h[x]], ... } with n elements use: Rest@NestList[h,x,n] To get the table {h["foo"], h["fooo"], ...} with n elements use: Table[h["fo" &lt;&gt; ConstantArray["o", i]], {i, n}] To compare the distance between strings there are several ways. You can start looking up EditDistance and check out the "See Also" section.
After reading the documentation on Outer I am pretty sure that I was basically just trying to rewrite that function! This will be very useful. Thank you so much. :)
Look at your second input block in that image ( In[226] ). It looks like you've typoed a comma into the values for A (ie, *A={3.556,4,321}* should be *A={3.556,4.321}*. Since this means A has more elements than B, NSolve blows up. 
Yeah, looking at it again it makes sense that it wouldn't work. You're passing NSolve an object that isn't valid input. You need to iterate along each input value list rather than passing the lists into the function prior to pushing it into NSolve. To see what I mean, look at what the actual function is in your first input block: NSolve[Z^3 - (1 - B)*Z^2 + (A - 2 B - 3 B^2) Z - (A*B - B^2 - b^3) == 0,Z] is the same as NSolve[-1.67224 + 0.518957 Z - 0.2734 Z^2 + Z^3 == 0,Z] But then in your second block, you're defining A and B as lists, so now: NSolve[Z^3 - (1 - B)*Z^2 + (A - 2 B - 3 B^2) Z - (A*B - B^2 - B^3) == 0,Z] is the same as NSolve[{-1.67224 + 0.518957 Z - 0.2734 Z^2 + Z^3, -2.34894 + 0.150008 Z - 0.108 Z^2 + Z^3} == 0,Z] So there you don't have a valid input for NSolve. One solution is to iterate along your lists for A and B. The following code does that: fxn[A_, B_, Z_] := Z^3 - (1 - B)*Z^2 + (A - 2 B - 3 B^2) Z - (A*B - B^2 - B^3) == 0; A = {3.556, 4.321}; B = {0.7266, 0.892}; solutionsList=Table[NSolve[fxn[A[[i]], B[[i]], Z], Z], {i, Length[A]}] Then each element of *solutionsList* gives the list of solutions for the elements of A and B. 
Your question has already been answered but I just wanted to comment: I hope you know that SHA256 is already an iterative map of a certain function 64 times. That's actually the whole idea behind hash functions. The idea comes from the study of dynamics/chaos. You can get ergodic mixing of phase space by applying some iterative map over and over again. See for example the [Arnold cat map](https://en.wikipedia.org/wiki/Arnold's_cat_map) and notice how quickly it mixes up phase space. Anyway, you probably won't see anything interesting by looking at h, h^2, h^3 ... they all just continue to mix up phase space. SHA-256 works on blocks of size 512 bits. Your short strings like foo, fooo, foooo are all just getting padded out to 64 characters (assuming an 8 bit char). It's probably most meaningful to compare data of this size going into the hash function. But still you are not supposed to see anything interesting from similar data going in. Even just a 1 bit difference between two 512-bit blocks gets mixed up in phase space very thoroughly (or at least that's the goal!). EDIT: Whoops, I forgot to add: If you want to visually see the output, take a look at ArrayPlot. Try taking your hash value, using IntegerDigits in base 16, then Partition the List into an array (as square as possible), and ask ArrayPlot to display it for you.
For the latter, I would have said h /@ NestList[ #&lt;&gt;"o"&amp; ,"fo", n] which reuses the previous fo..o to get the next one, instead of rebuilding that ConstantArray every time.
I will try getting this to work. Thank you.
whoa that worked perfectly. i dont know who you are, where you come from but you just saved me. thank you very much!! :D :D
You got it! :) Edit: By which I mean, you're welcome!
Im not the best person to answer, but I was having a similar problem finding an analytic solution to motion of a charged particle in motion in 3D space about a system of charged objects. It was just too much for my computer to handle and would never compute. Instead, I needed a numerical solution... that's my best answer for you. Either use for loops to approximate your answer or NIntegrate. That's my 2 cents. Source: I took a computational physics course last spring.
two quick notes: 1) Functions have capital letters. Sqrt is not the same as sqrt. Maybe this is just how reddit is formatting though. 2) functions operate on square brackets. Sqrt[5] is the right notation; sqrt(5) is not. that being said, mine isn't evaluating. I'm not a major major; maybe you need some kind of condition (only real numbers, etc). Good luck. 
Firstly, your errors seem to indicate an error in the syntax of your input, as others have said. Secondly, this is not a trivial integral so Mathematica isn't going to do it by itself. I'd look it up in a table of integrals, eg. Abramowitz &amp; Stegun. But on first inspection it seems that a change of variables to polar coordinates or complex variable is the best place to start. In polar coordinates the integrand will be something like 1/Sqrt[1-r^2]*Exp[-(mu^2/2)*(r^2+c^2-2rcCos[\phi-\theta_c])] where c is the vector (a,b) with direction \theta_c. Good luck!
&gt;2+c 2-2rcCos[\phi-\theta_c])]
Besides your syntax errors that others have mentioned: your denominator goes to zero when x^2+y^2 -&gt; 1, i.e. on the unit circle in the x—y plane. Are you sure you're integrating the right thing?
Nothing against asking questions here in Reddit, but are you also familiar with http://mathematica.stackexchange.com/ ?
Thanks for all the help guys! My professor actually figured this out on his own, and he didn't really need my help (we're doing research together). Instead of the 2-D Gaussian, he used the Airy function and set the limits from -0.9999 to 0.9999 (but mistakenly told me infinity). Also, the syntax was incorrect, as many other people mentioned. He used NIntegrate by the way.
First, you're in the wrong forum. Try /r/math ? Second, if you don't know what logarithms are, that course will be too much for you. Save yourself the time and go for an algebra and trigonometry course.
Hmmm. Pretty sure Question 7 is easy to do in your head. But I agree with /u/quantum-mechanic : if your mathematical background doesn't include being comfortable with logarithms then you probably aren't ready for this course yet. The intro to the course says "for students with junior or senior college-level mathematical training including a working knowledge of calculus". Does this apply to you? Related but not immediately in response to your question: Coursera courses are very cool!! Real honest-to-goodness university level courses for free online. The best new thing on the web since Netflix! :-) 
Oh I just re-read all the questions that you posted. Honestly they are all very easy. (Not bragging, not trying to make you feel bad. Just that if you are lost now then you probably don't have the required mathematical background that is assumed for this course.) 
Here's another course at Udacity on "College Algebra". https://www.udacity.com/course/ma008. It includes information on "Log Properties". Maybe you could take this before (or in parallel with) your Coursera Biostatistics Bootcamp. (Udacity courses are done on your own schedule, unlike the coursera courses). 
Attaboy! Good luck!!
This is a neat sound, but I think that your code could be condensed a little bit. Since this T function is only used twice, you can evaluate is as it is in A and B and remove the definition entirely. Also, I like to put functions like this as modules so that they don't interfere with other variable definitions if I have other notebooks running. I made it into this: Module[{c, r, A, B}, c = 1/3; r = 44100; A = Table[ 4*Sin[55/(t + .0001)]* SawtoothWave[22.5` t^2 + 2 SawtoothWave[(55 t)/16]]* Exp[-t/(c/14)], {t, 0, 5 c, 1/r}]; B = Table[ 4*Sin[55/(t + .0001)]*SawtoothWave[0.` + 22.5` t^2]* Exp[-t/(c/13)], {t, 0, 8 c, 1/r}]; {ListPlay[B, SampleRate -&gt; 44100], ListPlay[A, SampleRate -&gt; 44100]} ]
Thanks for the suggestions, I put it here for all to use and alter and play with. The functional form for T is presented here and A and B are specific implementations...changing the parameters in the T function will result in different laser noises. Edit: I should have probably said this snippet came from a context where using the constants c and r seemed more relevant, etc...that said I'd appreciate anyone's efforts to build on this and create cool modules, hopefully to be posted here!
You might find this interesting... http://crca.ucsd.edu/~msp/techniques.htm 
Thanks! This is great. You are correct this came from my mathematica notebooks aimed at creating a full blown synth.
But... lasers are quiet.
What are you looking at? The theory behind it will help identify how you should fit it. For all we know y=3.15 is a good fit. Depending on what the data is chances are you probably only need to look at one period. 
Sorry, I would like to be able to get the location of the max/min points. The area under each peak and the height of each peak. 
I'll start looking into and FFT. It's been a while since I worked with Mathematica.
It looks like Tan to me
fitting an equation to that curve just isnt going to work. and fourier methods aren't going to give you any usable information. If you just want the statistics you listed it should be fairly straight forward. I am actually not super familiar with mathematica for data analysis, I usually use something like python, igorpro or matlab. Peak finding is kind of a pain to do with relatively noisy data, but it should be possible to do some simplified work around using thresholding. After you find the index values of the peaks and valleys I would just do integrals from valley to valley. It may not be perfect, but you will get good results. I hope this helps/sends you in the right direction.
What sort of application are you studying? Where did you get the data from?
I've actually been able to do peak finding with igorpro. The problem comes when I want to fit it. It doesn't want to fit past the inflection in the tail. The other thing I have been doing is integrating under a single peak. The problem is that I need to cut out the baseline. I have to do all this manually and need to be able to do it for all the peaks, preferably automate it.
Thank you for the post. I'll start trying to decipher it.
I'd like information about Fourier Transforms! I just can't grasp the concept of them..
Yeah but it is not symmetric above the horizontal...it's an awkward fit for sure.
Ah, I see. How does one go about doing a Fourier transform given a periodic function?
Is this something you only need to do once or twice? If this is something you'd like to automate, I'm not sure my suggestion would work, but if all you want to know are the basic max, min, and spacing between peaks then I'd go with Interpolation[]. Just get your data set in the form {{x_i, y_i}} and then say something like fit = Interpolation[{{x_i,y_i}}] Then you can use FindMaxValue[fit[x], x, x_0] where x_0 is the place to search for the maximum. If you have a rough idea of the spacing you could do something quick like this: maxes = Table[FindMaxValue[fit[x],x,s], {s,x_start, x_stop, x_spacing}]. FindMinValue works similarly. Then once you have these pieces of information you can easily find the height of each peak simply mapping the locations of the maxes and mins onto fit[x] and subtracting. Then the area is similarly obtained by using NIntegrate over the min,max bounds. If it's too noisy at the bottom of the peaks, use a sliding boxcar average: MovingAverage[data, span] which will average the data and smooth out some of the noise. 
It depends on whether you're given sampled data or a function. If you're given a function, it's a fairly straight-forward integral. That gives you a continuos function of amplitude over frequency. For sampled data you use a series of statistical analysis techniques to find the amplitude fit for sine waves at certain discrete frequencies. For this reason, it's called a Discrete Fourier Transform. A Fast Fourier Transform is a special kind of Discrete Fourier Transform that's designed to be fast on computers.
Do the Max and Min functions not work on the raw data? Also, to get an average value for the integral try Total[data]/(number of data points*samples per second) 
But... laser cats are not. http://youtu.be/GRBNkMnG4uY?t=1m52s
I will need to do this thousands of times. I'll look into the functions you gave me. Thank you.
Hmm I see. Interesting. What integral needs to be taken, if given a function?
The min max functions identify some of the peaks but there is also too much noise. I'm trying to understand the code. Unfortunately I'm learning mathematica as I do this.
I have to do this thousands of times. I'm going to have to learn the program I use regardless and automate it. Which is going to really suck. I started with mathematica because I had it. I also have igorpro. I would like to learn python but it will take time. I need to get this done asap so I've been trying to power through it.
[This one](https://en.wikipedia.org/wiki/Fourier_transform#Definition) Also, the wikipedia articles are pretty good and oddly in-depth.
What min max? There doesn't appear to be any local minima that aren't at endpoints of the segments...unless you mean the spikes that appear to be noise on first sight. Are those in your data or is that noise?
Suppose you've got a list "List" Do `Power = (Abs[ Fourier[List] ])^2` `ListPlot[Power]` It will be symmetric about the center. Drop half the points. If the length of the list is N, do `Relevant = Drop[ Power, N/2]` (*cant remember if its +N/2 or -N/2*) (*You wanna use a log plot *) `ListLogPlot[Relevant, Joined-&gt;True]` The spikes correspond to frequencies. It is common to add zeroes to the signal to give more defined peaks. It's called zero padding.
This could get you started. A useful call to manipulate a list is Drop[]. Use it to select parts of your list. You should look up list manipulation in the documentation to chop you data. Suppose you wanna power spectrum of some part of your data called "List". Do something like `Power = (Abs[ Fourier[List] ])^2` ` ListPlot[Power]` `Length[List]` Returns the length of your data. Suppose your list is N entries long... `GoodPart = Drop[Power, - N/2]` Because the fourier is symmetric and half of it is a copy... `ListLogPlot[GoodPart, Joined-&gt;True]` `ListLogLogPlot[GoodPart, Joined-&gt;True]` 
Dude i would recommend doing this by "hand". I don't know how much more data you have but the signal seem to be noisy and the resolution seems to be low (thus the unevenness of the peaks). When you try to do automatic curve fitting you have to remember that Crap In ==&gt; Crap Out. Or otherwise since the period seems nice and even i would chop it upp and try to find a fit that fits. If you want the oscillation in the middle as well try to fit a Fourier series instead. What is the purpose of finding a function for the curve?
I have thousands of curves that I will need to analyze. I was hoping to find an equation or fit that would work. From there I should be able to pull out meaningful data. Since I probably can't fit it I'm going to have to just use the min/max points and area under each peak to get my results. No way I can do it manually in my lifetime.
This is a very bad use of Dynamic and actually crashed MMA
Assuming I'm understanding the question correctly (that you want a 2D-plot with respect to x): f[x_] = Exp[I x/2] Plot[Arg[f[x]], {x,3Pi/2, 7Pi/2}] I'm not sure why you want to plot |f(x)|, because that is equal to 1 for any x (since all values that f(x) can possibly take lie on the unit circle in the complex plane). To do it anyway you just replace *Arg* with *Abs*.
I always think of Dynamic as being able to an object that changes based on outside factors, but in this case the displaying of the object causes itself to change!
I assume the reason to use Dynamic was to make the code as short as possible. 
Rewrote the code to output frames (pardon the inelegant code, I haven't used Mathematica in a while). You can just use "Export" on the output of the below function. psychedellicDisk[frameCount_Integer] := Module[{frames, a}, frames = {}; a = DiskMatrix[10, 300]; Do[ frames = Append[frames, a]; a = Rescale[a - GradientFilter[a, 2]]; , {frameCount} ]; Image /@ frames ]; 
Yea, I knew something like that would be better, but I went with the first solution that popped in my head. 
&gt; psychedellicDisk[frameCount_Integer] := Module[{frames, a}, frames = {}; a = DiskMatrix[10, 300]; &gt; Do[ frames = Append[frames, a]; a = Rescale[a - GradientFilter[a, 2]]; , {frameCount} ]; Image /@ frames &gt; ]; Thanks for giving it a shot. I get "Export::errframe: Null cannot be converted to a video frame. &gt;&gt;" when I try to export, however.
Copy and paste this. If it doesn't work then either ASCII is beng miscopied, you have an older non-compatible version of Mathematica, or there is some buggy difference between OS versions. You may have to change the filepath to suit your OS (I'm on Ubuntu) psychedellicGradient[frameCount_Integer, startMatrix_: DiskMatrix[10, 300]] := Module[{frames, a}, frames = {}; a = startMatrix; Do[ frames = Append[frames, a]; a = Rescale[a - GradientFilter[a, 2]]; , {frameCount} ]; Image /@ frames ]; movieFrames = psychedellicGradient[100]; Export["~/Desktop/psychedellicDisk3.avi", movieFrames];
That seems to work. Thank you much.
I modified it to take an arbitary color image if you're interested. Try setting the "img" variable to one of the example images Mathematica has or an artbitrary image from your computer. I think the results are pretty neat. psychedellicGradientMorph[frameCount_Integer, initialImage_] := Module[{gradientStep}, gradientStep[im_] := Module[{separated, separateMorphed, recombined}, separated = ImageData /@ ColorSeparate[im]; separateMorphed = Rescale[# - GradientFilter[#, 2]] &amp; /@ separated; recombined = ColorCombine[Image /@ separateMorphed]; recombined ]; NestList[gradientStep, initialImage, frameCount] ]; img = Image[RandomReal[1, {300, 300, 3}]]; frms = psychedellicGradientMorph[100, img]; Export["~/Desktop/withColor.avi", frms];
Your explanation doesn't make sense to me. I'm sure there are good and bad uses of dynamic, e.g., dont wrap more in dynamic than you need to, but I don't think it's obvious that this is a bad case. 
Thank you!
Thank you!
Use the option "AxesOrigin" after the range. For example, Plot[{(1.3612499999999996 - 1.2375 Sqrt[ 1.21 - 0.4 a] + (-0.45 - 0.25 Sqrt[1.21 - 0.4 a]) a)/(a (-3.025 + 1. a)), (0.5859375 - 0.46875 Sqrt[ 1.5625 - 1. a] + (-0.375 - 0.25 Sqrt[1.5625 - 1. a]) a)/(a (-1.5625 + 1. a)), (0.28125 - 0.1875 Sqrt[ 2.25 - 2. a] + (-0.25 - 0.25 Sqrt[2.25 - 2. a]) a)/(a (-1.125 + 1. a)), (0.12760416666666663 - 0.07291666666666663 Sqrt[ 3.0625 - 3. a] + (-0.12499999999999989 - 0.25 Sqrt[3.0625 - 3. a]) a)/(a (-1.0208333333333333 + 1. a))}, {a, 0, 3}, AxesOrigin -&gt; {0, 0}]
Works like a charm!
This is the best i could do, maybe you can work from this to your objective. clus = FindClusters[datapairs]; t = Table[ Table[Circle[clus[[i, j]], 5], {j, 1, Length[clus[[i]]], 60}], {i, 1, Length[clus]}]; ListPlot[datapairs, Epilog -&gt; {Red, t}, PlotRange -&gt; {{0, 180}, {1, 300}}, AspectRatio -&gt; 1] i recomend you getting the mean of random chunks of the variable clus, good luck
img = PASTEIMAGEHERE// Binarize // ColorNegate; morph = MorphologicalComponents[img]; maxm = Max[morph]; dottab = Table[ Total[Flatten[(morph - (morph /. i -&gt; 0)) /. {i -&gt; 1}]], {i, 1, maxm}]; this will give a list of the sizes of all connected structures. Might need a higher version of mathematica though (also takes a while to run). maxm will be the number of individual dots. Remember also its counting the outer border as one dot.
Awesome, exactly what I was looking for. Can also apply this to longer lists! One question though: What exactly is the difference between OddQ[OddTable] and OddQ/@OddTable?
`/@` is a neat little shorthand that generates a list by applying a function to each member of a list. so ` f /@ {a,b,c,d} ` would give ` {f[a],f[b],f[c],f[d]} `
Thank you so much! Getting greedy but do you also know how to make mathematica mark those 3 points in a graph?
Try putting a space (or a *) between P and M in the definition of popchangelog. The way it's written, Mathematica is interpreting PM as the symbol PM, not as the multiplication of symbol P with symbol M.
Also "rt".
oh yes, missed that
There's no difference here; I just didn't realize that `OddQ` naturally threaded over lists. The shorthand `/@` does exactly that: apply a function to each element in the list that follows, and give a list of outputs. (Great for when your function only handles single inputs.)
Good to know, couldn't find any difference with OddQ but this seems useful in other cases!
Thank you so much, works great!
'b' should be "ListPlot[Solve[f[x]==0,x]]"
It's a bit late now but better late than never ... For the case of a cubic (or even quartic) polynomial, Solve will work, as others have pointed out. However, for more complicated equalities, you'll have to find roots numerically with FindRoot.
Does that really work for you? Solve doesn't evaluate to a list of numbers, so why should anything be plotted? 
I am supposed to be comparing it to this as well. http://demonstrations.wolfram.com/VanDerWaalsEquationOfStateForANonIdealGas/ 
I'm not sure if it'd cause a problem, but I always avoid using capital letters for functions in Mathematica. System functions always start with capitals, and it's an easy way to avoid them. The "blah blah blah" part may be causing the issue. What is it?
A bit more information wouldn't have gone amiss. Ideally, anyone should be able to understand what you want to do in MMA without knowing about the van der Waals equation. Also, what's the problem? What precisely isn't working, and what have you tried? Based on what you wrote, I would assume you simply want to plot a function Y[T,Vm], and all you want to know is how you do that. First, make sure that all constants (everything besides T and Vm) has a numerical value in the definition of Y. For a two-dimensional plot, you obviously need to fix either T or Vm. Say you set T = 280. Then it's simply Plot[Y[280,Vm],{Vm,0,1}] I suggest you study the MMA documentation about "Plot" to learn about more options if needed. If you want to replicate a bit of the interactivity in the Wolfram Demonstration Project, you should read the documentation about "Manipulate" (that's usually the easiest way to do it). For a simple example, consider this: Manipulate[Plot[Y[T,Vm],{Vm,0,1}],{T,0,750},PlotRange-&gt;{{0, 1},{0, 300}}] You might also be interested in "ContourPlot" and "Plot3D". For example, ContourPlot[Y[T,Vm],{Vm,0,1},{T,0,750}] and Plot3D[Y[T,Vm],{Vm,0,1},{T,0,750}] 
You are right. I should map or tabulate the replace table. Didn't actually try out the code.
Good examples are 'C' and 'D' both of which are predefined functions in Mathematica.
There are two solutions, each given as a list of rules for the unknowns your were solving for.
The error is Mathematica getting upset about the 0.5's; it's thinking you put in a machine-precision number, rather than an "exact" number like 1/2. See this screenshot: http://imgur.com/zweeO0z Anyway, as elansey said, Mathematica is providing you with two solutions to your system: the case where TA = -C/2 and TB = C/2, and the case where TA = -C/2 - TC and TB = C/2 - TC. These are called "rules" in Mathematica (you can tell from the arrows). Either of them could be applied to an expression to "fill in" the expression according to the rule. If you had some expression *e* with TA and TB in it, for example, you could do e /. Solve[ ... ] [[1]] to fill in the expression according to the first solution.
After digging around the web more I found a solution a'[t]=. clears the derivative of the function.
With due respect: that's not a bug, that is you not understanding how assignment works in Mathematica. 
&gt; that is you not understanding how assignment works in Mathematica Or a design flaw in a computer algebra system for not handling boundary conditions on derivatives in a user friendly way. 
I agree that it's fairly silly that a derivative can appear as the first argument of a Set[] function without as much as a warning, but those kinds of idiosyncrasies are part of understanding Mathematica. So we may both be right.
Code from this Community post - http://community.wolfram.com/groups/-/m/t/123110
Can you post the code as text here?
I've removed the stuff that prints the text output since I plan to remove that in the future anyhow. This code just performs the calculations and then generates the graphics. [Here's](http://imgur.com/VxefOaF) what the ouput graphics look like for phi=0 and MotorCount=12. Clear[s, d, p, a, MotorSpeed]; MotorCount = 12;(*Set number of motors*) phi = 0;(*Set quadcopter's rotational angle [0,360]*) theta = 90 ;(*Set quadcopter's angle from +Z-axis [0,90]*) throttle = 1;(*Set throttle [0,1]*) a = p = d = Table[0, {MotorCount}];(*initialize motor percent change, motor locations, motor displacement from tilt*) MotorSpeed = Table[.5, {MotorCount}];(*set initial motor speed*) For[i = 1, i &lt;= MotorCount, i++, a[[i]] = (i - .5)*360/MotorCount; d[[i]] = Min[Abs[a[[i]] - phi], 360 - Abs[a[[i]] - phi]]];(*set motor placement angles, then*) total = Total[d];(*calculates net motor speed change*) For[i = 1, i &lt;= MotorCount, i++, p[[i]] = Round[1/MotorCount - Abs[d[[i]]/total], .0001]; MotorSpeed[[i]] = MotorSpeed[[i]] + 2 theta/90 p[[i]]];(*calculates motor power percent change, then Sets new motor speed [0,1]*) MotorLocationData = Table[{Cos[(a[[i]] + 90) \[Degree]], Sin[(a[[i]] + 90) \[Degree]]}, {i, 1, MotorCount}];(*creates point for each motor*) LableLocations = Table[{1.1*Cos[(a[[i]] + 90) \[Degree]], 1.1*Sin[(a[[i]] + 90) \[Degree]]}, {i, 1, MotorCount}];(*determines location for each lable (slightly past motor location)*) LabelText = Table[Text["P: " &lt;&gt; ToString[MotorSpeed[[i]]], {LableLocations[[i]][[1]], LableLocations[[i]][[2]]}], {i, 1, MotorCount}];(*places text at locations determined above*) For[i = 1, i &lt;= MotorCount, i++, MotorLocationData = Insert[MotorLocationData, {0, 0}, 2 i]];(*adds a return to origin for each motor*) TiltDirectionGraphic = Graphics[{Green, Arrow[{{0, 0}, {Cos[(phi + 90) \[Degree]], Sin[(phi + 90) \[Degree]]}}]}];(*draws arrow in direction of tilt*) MotorGraphics = ListPlot[MotorLocationData, AspectRatio -&gt; 1, Joined -&gt; True, Axes -&gt; False, PlotRange -&gt; {{-1.2, 1.2}, {-1.2, 1.2}}, PlotStyle -&gt; {Black}];(*Plots motors on graphic*) Show[MotorGraphics, TiltDirectionGraphic, Graphics[{Red, LabelText}]]
awesome
I think this does what you want. Manipulate[ a = Table[(i - .5)*360/MotorCount, {i, 1, MotorCount}]; d = Min[Abs@# - \[Phi], 360 - Abs@# - \[Phi]] &amp; /@ a; p = Round[1/MotorCount - Abs[#/Total[d]], .0001] &amp; /@ d; MotorSpeed = (0.5 + 2 theta/90 #) &amp; /@ p; MotorLocationData = {Cos[(# + 90) Degree], Sin[(# + 90) Degree]} &amp; /@ a; LabelLocations = 1.1*MotorLocationData; LabelText = MapThread[ Text["P: " &lt;&gt; ToString@#1, #2] &amp;, {MotorSpeed, LabelLocations}]; MotorLocationDataWithOrigins = Riffle[MotorLocationData, {{0, 0}}, {-1, 2, -2}]; MotorGraphics = ListPlot[MotorLocationDataWithOrigins, AspectRatio -&gt; 1, Joined -&gt; True, Axes -&gt; False, PlotRange -&gt; {{-1.2, 1.2}, {-1.2, 1.2}}, PlotStyle -&gt; {Black}]; TiltDirectionGraphic = Graphics[{Green, Arrow[{{0, 0}, {Cos[(\[Phi] + 90) Degree], Sin[(\[Phi] + 90) Degree]}}]}]; Show[MotorGraphics, TiltDirectionGraphic, Graphics[{Red, LabelText}]] , {{MotorCount, 12}, 1, 20, 1, Appearance -&gt; "Labeled"}, {{\[Phi], 0}, 0, 360, 1, Appearance -&gt; "Labeled"}] 
Reading about Manipulate is a good start. Dynamic is also useful, but it's mostly used for dependent/secondary objects (e.g. you'll change other variables and the Dynamic code will automatically update to match).
Oh, sorry. I originally had theta declared as one of the sliders, but then I remembered you didn't want that, so I ripped it out. I tried to write it as "Mathematica-y" as possible, I hope it's helpful. You really have to think differently than for loops and arrays. For[] was just shoehorned in because people wanted it, but it doesn't take advantage of Mathematica's power and is way slower than Map[]. The biggest tricks I used are /@ as a shortcut for Map[], and pure functions (that use # as their argument). When you get a handle on those, that's when Mathematica really starts to click. The Manipulate[] part of it is pretty simple.
Huh. I think that since I started using mathematica (maybe 6 years ago), I've been using mathematica as if it were a visual version of matlab (hence the For[], etc). I hadn't heard of pure functions before. I think I have a paradigm shift to work out.
I think maybe you meant this as a reply to me, but either way: @ and /@ mean different things. f@x is the same as f[x], and I just use it when calling a simple function on one variable because it looks nicer and reduces the amount of [[[[]]]] you have to look at. You could replace Abs@x with Abs[x] and it would work the same. /@ is shorthand for Map[], which applies some function on each member of a list. Think of it as transforming a list into another list. {Cos[(# + 90) Degree], Sin[(# + 90) Degree]} &amp; /@ a would be the same as Map[{Cos[(# + 90) Degree], Sin[(# + 90) Degree]}&amp;, a] that is, transforming the list a into a list of coordinates. Pure functions are just another kind of shorthand; they save us the trouble of defining a "real" function when it's going to be short and we're only going to use it once anyway. So it would be totally fine to write a "real" function like angleToCoordinate[theta_] := {Cos[theta], Sin[theta]} angleToCoordinate[45 Degree] but I think this is a simple enough function that we can just write it in one line as a "pure" function: {Cos[#], Sin[#]}&amp;[45 Degree] Hope that helps.
I'm a bit confused here. You can fit data in Mathematica with the `FindFit` function, but I'm not sure what you mean mean when you say that you want the known error to affect the result. If the error follows a given distribution, you should already be sampled from the mean/median/etc when taking your points in the first place. If I wanted to plot data with a certain degree of accuracy I might try using circle graphics of various sizes to represent the relative fuzziness of data locations. But for finding fit... there's going to be some error expected, and I don't see how you would incorporate this into your results.
I'm not sure either. The problem may be implying error bars instead of using uncertainty of data points to affect the plot of the fit.
 If[i &gt; i - 1 and i &gt; i + 1 What?
[Series](http://reference.wolfram.com/mathematica/ref/Series.html)[f[x],{x,0,n}]
You can use FindFit: fun[k1_?NumberQ, k2_?NumberQ, k3_?NumberQ, x_?NumberQ] := (g /. NDSolve[{ a'[t] == -k1*a[t]*b[t], b'[t] == -k1*a[t]*b[t], c'[t] == k1*a[t]*b[t] - k3*c[t]*f[t], d'[t] == -k2*d[t]*e[t], e'[t] == -k2*d[t]*e[t], f'[t] == k2*d[t]*e[t] - k3*c[t]*f[t], g'[t] == k3*c[t]*f[t], a[0] == 5, b[0] == 2, c[0] == 0, d[0] == 2, e[0] == 1, f[0] == 0, g[0] == 0}, {a, b, c, d, e, f, g}, {t, 0, 3}, MaxSteps -&gt; Infinity][[1]])[x]; Module[{dataset1 = {{0, 0}, {0.15, 0.271161}, {0.3, 0.525314}, {0.45, 0.68284}, {0.6, 0.782049}, {0.75, 0.846992}, {0.9, 0.890934}, {1.05, 0.921414}, {1.5,0.969472}}}, FindFit[dataset1, fun[k1, k2, k3, x], {k1, k2, k3}, x]] It doesn't have unique solution, and if you don't especify initial values you'll obtain a different one (g will be similar because it has to go through many of the same points, but the rest of the functions will be completely different). To reobtain your solution you can start with similar values, for example: FindFit[dataset1, fun[k1, k2, k3, x], {{k1, 21}, {k2, 8}, {k3, 2.3}}, x]
ya, I was just typing verbatim what the guy in the video was as he was doing it though. Also i've tried with and without the equal sign before hand. I don't know, I give up. 
Study this. Look up "Part" which is also [[]] in the documentation. Figure out how every part of this works. Then adapt it to what you need. In[1]:= mydata = {1, 2, 3, 2, 3, 4, 3, 2}; dthete = {}; For[i = 2, i &lt; Length[mydata], i++, If[mydata[[i]] &gt; mydata[[i - 1]] &amp;&amp; mydata[[i]] &gt; mydata[[i + 1]], AppendTo[dthete, {i, mydata[[i]]}] ] ]; dthete Out[3]= {{3, 3}, {6, 4}}
The first thing I would check is the locations of the packages on each of the machines and where each copy of Mathematica is looking for things. Look at the value of $Path on a working and nonworking machine. If those are identical then find the location of the package on a working and nonworking machine and make sure those match up. Google for Mathematica find package to get more information on this.
Hello! You might be interested in performing a histogram transformation. http://reference.wolfram.com/mathematica/ref/HistogramTransform.html This function is built into Mathematica 9.0. If you are using an earlier version of MMA, you may need to code your own version.
Thanks, I appreciate the help. I was able to solve it using ParametricNDSolveValue though, update on the forum linked above.
Thanks, I appreciate the help. I was able to solve it using ParametricNDSolveValue though, update on the forum linked above.
And you can try replacing Binarize with MorphologicalBinarize.
Very nice, thanks BillSimpsonxV. Funny, not long ago I was looking at the "//." replacement help page thinking that I couldn't think of a way to use it in my day-to-day. Clearly I was wrong.
/u/BillSimpsonxV already answered your question, but I just wanted to add some more. It's great that you want to learn the pattern matching system, because it's extremely powerful. This example of pattern matching that you gave is a very simple case. For more you should read up on `__` (BlankSequence), `___` (BlankNullSequence), `?` (PatternTest), `..` (Repeated), `|` (Alternatives), `.` and `:` (Optional and with a Default). You'll also be interested in `/;` (Condition). I've used every single one of these at one point or another. EDIT: Let me add that the single most common trope to understand is `symbol_head?test`, e.g. `x_Integer?Positive`.
Thank you for the information. 
I don't see any RsVc ... I see Rs, and I see Vc, both of which I have assigned values to .... Vc = 5; Rs = 1000000;
Well I solved it. One error was from unneeded curly brackets in IdRd[t_] := Evaluate[{(V1[t] - V2[t])/Rd[t]} /. s]; and then I just replaced IdQuenched[t] with IdQuenched[t][[1]] in the s1 equation.
Thanks so much! I took &gt;Solve[{moments.{1, 0, 0}, moments.{0, 0, 1}} == {0, 0}] and made it &gt;**{{Tbc, Tbd}} = {Tbc, Tbd} /.** Solve[{moments.{1, 0, 0}, moments.{0, 0, 1}} == {0, 0}] to get it to to apply the "rules" to the variables, just like you said. But why does Solve[] return rules with double brackets around them? I ask because your using Mathematica object terms ("rules", "assignments") is helping me understand it better.
Yeah, I'd suggest looping it and processing each element one at a time. 
Yep, there are two methods of pre-pending an image identifier to each result list. The first method is based on your suggestion: modifying the ProcessImage function to accept the identifier as a second argument. You have already shown how to change the function to accept the second argument and include it with the return value. Now, you need to modify how ProcessImage is applied to the list of images. The ProcessImage/@images expression is short-form for the Map function: ProcessImage/@images; is the same as Map[ProcessImage,images];. There is another function, named MapThread, which applies a function of N arguments to successive elements of each list. results = MapThread[ProcessImage,{imagelist,IDlist}]; This will call ProcessImage[image,identifier] on the 1st, 2nd, 3rd, etc elements from each list. Here's a second way of pre-pending the image identifier. For this method, you won't need to modify ProcessImage. The result of the ProcessImage/@images expression will be a List of Lists. You can visualize the List of Lists as a matrix where the results for the Nth image are stored in the Nth row. Now, what you want to do, is pre-pend a column of image identifiers to the left of the matrix. This is accomplished with the expression: results = Transpose@Prepend[Transpose@results,identifiers];
I'm in grad school now and started using it towards the end of high school for data analysis. All throughout college I used it for everything ranging from numerical stuff, data analysis, symbolics, image analysis, a bit of formal programming, etc. It's just such a powerful and versatile toolset. Despite this, I still think it's incredibly difficult to get good at. Sure, everyone can use it to find integrals, but if you want to do some really high level stuff it can get pretty tough pretty fast, and believe it or not, the question you asked was something I struggled with at the beginning. It's frustrating to be able to do something but to not be able to properly manipulate the output. I really suggest looking through their documentation (which is incredibly thorough) - they have a module specifically on list manipulation which is very good to read. After you can manipulate objects easily things become much simpler since looking up basic functions and their options is trivial. A good goal is to understand deeply the differences between single square brackets, double square brackets, curly brackets, and parenthesis as well as how to extract, insert, reverse, split, etc items in a list. While I'm at it, make sure you look at the function Map - this basically allows you to avoid having to write a Do or For loop in most computational settings. I don't know what stage of life you're at, but hardly a problem set goes by for me that doesn't include a lot of Mathematica use - definitely has paid off tenfold. Stick with it! 
First of all, do not use capital "N". That's already a function. Note that j = 0 is only one solution. Without further restrictions, there are many others, and you only have one equation for two variables. If you just want one of the solutions, try FindInstance: FindInstance[1/(n - j) - 1/(n + j) + Log[(n - j)/(n + j)] == 0, {j, n}, Reals]
Ah, I did not use capital "N" in my actual notebook, I just wrote this out really quick. So, the actual restrictions for this equation are that j,n are real integer values, j=-n, -n+1, ... n-1, n, and n &gt;&gt; 1. Is there a way to impose these conditions on the system to find an instance or solution at n&gt;&gt;1 ?
Yes, you can impose those conditions, although as you need inequalities, Solve is out and you need Reduce: Reduce[1/(n - j) - 1/(n + j) + Log[(n - j)/(n + j)] == 0 &amp;&amp; n &gt; 1 &amp;&amp; n &gt;= j &gt;= -n, {j, n}, Integers] However, that's not going to help you, because there are still infinitely many solutions. Strictly speaking, the solution is *not* "j = 0", but rather "j = 0 and n is any integer". So, there's an infinite number of solutions. In some simple cases, Mathematica will be able to find out and tell you, in some cases it won't. I don't fully understand it either, but it would appear that your problem is not quite as trivial as it looks. What you can do to help Mathematica is to add an additional constraint which eliminates the problem with infinitely many solutions. In this case, you could specify a finite lower and upper bound for n. For example, if you're willing to limit the set of solutions to those with n &lt;= 10, you could use Reduce[1/(n - j) - 1/(n + j) + Log[(n - j)/(n + j)] == 0 &amp;&amp; n &gt;= j &gt;= -n &amp;&amp; 10 &gt; n &gt; 1, {j, n}, Integers]
Great. This will work. This might be more appropriate for /r/math but have you any idea how one could prove/solve this without the use of Mathematica? I suppose you could sketch a plot or something, but I wouldn't know how to "formally" prove the j = 0.
To prove that j = 0 is part of *a* solution is easy, by just putting in that solution in the equation, which gives 1/N - 1/N + log[1] = 0. I suppose the question is if j = 0 has to be part of *all* solutions, that is, for arbitrary integers n, do we have to have j = 0? So you have Log[(N-j)/(N+j)] = -1/(N-j) + 1/(N+j). The right hand side is a rational number, as it is the sum of two rational numbers. So Log[(N-j)/(N+j)] has to be a rational number. However, Log[x] is generally an irrational number, except for x = 1 (this follows from the irrationality of e, see Theorem 5.1 and Corollary 5.3 [here](http://www.math.uconn.edu/~troby/Math200S08/piande.pdf)). So you must have Log[1] on the left hand side. Then you only need to show that (N-j)/(N+j) = 1 implies j = 0, which is trivial: (N-j) = (N+j), therefore -j = j, therefore j = 0. Edit: "j" instead of "i".
As an additional exercise, graph the speed and magnitude of the acceleration of the roller coaster as a function of time in a 2D plot. :-)
Thanks! worked perfectly!