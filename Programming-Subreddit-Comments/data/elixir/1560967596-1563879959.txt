have you seen [this URL-based graphic equalizer](https://twitter.com/jake_albaugh/status/1118611365508337665)? üòÖ
Great documentation, tooling, clarity of thought, the most positive community I've ever experienced, and a simplicity that gets out of your way.
Gleam is a statically typed language on the BEAM, so it is possible. Ecto is great, but IMO not the unique selling point of the language. For me, that would be BEAM's process model and OTP. Supervision allows you to build resilient systems. Joe Armstrong said that if Java was write once run anywhere, Erlang is write once run forever. Actually if you just go watch some talks by Joe Armstrong I think you'll get it right away. Or the recent talk by SasÃÑa Juriƒá at GOTO 2019.
You get all the fundamentally good things about the BEAM and Erlang ecosystem(distributed processing, OTP, rock solid battle tested implementation) but with modern dependency management, testing frameworks, REPL, a lovely language(aesthetically), a first class "web" framework, an intelligent unicode story. The Elixir team/community understands what a modern language needs to succeed and they wrote those things and they work, it's amazing. You get a language maintainership(I don't even know how the language evolves, is Jose the BDFL?) who don't feel the need to constantly add things to the core language. I recently bought the second edition of Programming Elixir and Dave Thomas basically says this book is more because I write Elixir differently than because Elixir has changed so much in the last few years. &amp;#x200B; I'm not that advanced in Ecto but it does something I don't see other ORM's I've worked with doing and that's leverage the database. Like, if you have a unique constraint defined you have a choice of checking first with a select, which gives race conditions(because between checking it and running the update something else could have updated--unless you're going to lock the whole table for the entire transaction), or often barfing back some db error from the underlying driver. Ecto understands what the database told it and wraps it up in a nice message for you. So that makes me feel like this is a language made by working programmers for themselves who also had to write a 'postgres\_error\_parser' package and are solving real practical problems. These little ergonomics add up. &amp;#x200B; Another thing I like about Ecto is that changesets are essentially a 'form' library built in(but not required to be tied to your schemas). Coming from Python only Django has this kind of integration between your models and forms (but its ORM has never been great if you're a database person). Or you have SQLAlchemy and then you have to choose a form library, and then you end up finding or writing some glue library that makes it easy to convert back and forth from the models to the forms, and they're all authored by different people and you have to track the versions of three libraries by yourself and you have all these library specific annotations in your models to help the form library and so on. Ecto is big but it's modular and also I suspect because they know that the vast majority of people who have a schema then want to present that schema to the world to do something with. &amp;#x200B; The only thing as interesting to me as Elixir is Rust, but I don't see very much overlap in where I want to use them.
Another great aspect of Elixir is pattern marching, combined with function guard clauses. That alone is probably not worth rewriting your whole Rails monolith, but it makes code much clearer.
Erlang/OTP offers: - A model / runtime to write programs that are incredibly resilient to failure (programmer or hardware failure). - A lightweight process model, which makes scaling easy - The niceties of functional programming languages (pattern matching comes to mind here) On top of this Elixir offers: - Great tooling (mix, exunit, exdoc, ...) are all great tools and are shipped for free with elixir, this is pretty great since it means everybody is using the same tools for basic things such as testing, documentation, ... - Modern syntax (Erlang's syntax scares some people away) - A great macro system, which leads to - Some incredible libraries (phoenix and ecto come to mind) All of these features really add up. I can't think of another language that offers all of these features in one nice package :). &gt; Also, is what you're doing here fundamentally incompatible with static typing It's certainly possible to create a statically typed language on BEAM, but I'm personally not convinced it would offer a lot of advantages. This is mainly due to the case that BEAM is built for Erlang and Erlang is still a dynamically typed language. Code clarity wise, liberal use of type specs, pattern matching and dialyzer seem to be enough for me.
Great write up! One side note: Ecto is not an ORM.
testing is really nice in elixir. &amp;#x200B; all the libraries feel so well thought out and like it is made with love. &amp;#x200B; I love writing elixir. I think if one of my elixir apps was in rails it would be way more complex and if one of my other apps was in rails it would be waay slower. also development speed is really fast. code is easy to reason about and adding features is generally easy.
The talk by Sasa made me buy his book instantly.
Ugh. I went and watched the talk after reading this comment. I then bought the book as well. ::shakes fist::
Ah you should have told me. I saw a 40% coupon earlier today.
Preemptively asking for the coupon because I‚Äôm about to watch the talk üòÑ
reactnews40
&gt; reactnews40 This works for print too, so thanks for letting me get Elixir in Action 2nd and Phoenix in Action with print and PDF for under 70. :highfive:
At the end of the presentation he put two coupon codes up, one for 50% that expired the day of the presentation; the other was for 40% and still worked today! :cheers:
Sweeeet
If you remember can you let me know how you like the Phoenix book. I was looking at that too.
So I already own the one from PragProg, but from what I've heard this one concentrates more on the Elixir-y bits than the Phoenix bits, which I'm actually pretty excited to read.
You might have an easier time doing a rolling upgrade of a distributed system with a dynamically typed language. What makes static typing so great? And how much of that is taken care of by static typechecking?
I follow Gleam (And other BEAM typed languages, like elchemy) just to see how they solve message passing, that's the most complicated thing they have to face, as is one of the killing features of BEAM, and it's not an easy task to type
But they (Rust and Elixir) can completement each other quite well as seen at Discord !
Watched the talk. I am curious about the downside of BEAM clusters that he mentioned briefly. Anyone had any experience to the exact downside he is talking about? &amp;#x200B; Regarding his slide of massive rail + go + redis + etc stack vs single Erlang stack, how hard it is for you to shift say, a portion of the task that Erlang can handle onto a specific third-party program after you reach the imaginary or real scaling threshold that BEAM offers? Would it be very difficult to shift any specific part out of Erlang as you pretty much have a strong monolithic system at that point?
&gt; The only thing as interesting to me as Elixir is Rust, but I don't see very much overlap in where I want to use them. Can you expand on this? I'm also interested in Rust recently. It seems to me that there are obvious cases where Rust is suitable but Elixir isn't. But, it's less obvious to me where Elixir is suitable but Rust isn't. Rust has several web frameworks, a good GraphQL library, ORM, etc. Rust has high-level features so it's not quite like trying to write a web backend in C. Obviously, the Elixir web ecosystem is more mature/developed, but over time this could change.
I hope to have a suit that snazzy one day!
Someone asked that question and he responded here: https://elixirforum.com/t/the-soul-of-erlang-and-elixir-sasa-juric-goto-2019/22631/14
In web development, where I have a bunch of short lived connections that are all essentially a series of string transformations marshaling data to and from various other API's and data stores, with a blob of string spit back, I don't find any of the guarantees that Rust gives me worth the increased headache of the Rust compiler or giving up a super-ergonomic and advanced framework like Phoenix. Also, I just find Elixir code more pleasant to read and write. So I'm not really worried about memory lifetimes or GC overhead, I'm more worried about if I remembered to check the database to see if the &lt;object\_id&gt; was actually created by the &lt;user\_id&gt; that is trying to edit it. No type system is going to help with that. Rust is super fast but I'm not writing fibonacci microservices--it's not going to make select statements or network latency to other services any better, so for the things I want to do Elixir is fast enough (especially coming from Python). Similarly I don't want to bother mucking around with very specific numeric types and such when almost any data store or API I'm using doesn't, if I am just taking a number of some kind I don't want to sit there and cast things to f32 or whatever, and I can count the number of errors I've had in Elixir due to types on one hand probably. I still write specs and behaviours but pretty much entirely for documentation and mocking. I AM very interested in Rust for WebAssembly, because I hate the wastefulness of modern JS frameworks and because it's harder to diagnose what is going on in a remote client so the guarantees of Rust make more sense to me. Even if I had some type error in Elixir it would show up in the logs, it would get fixed and move on, compared to where your website just stops working and the user abandons it in disgust.
Buy one now! :)
Very interesting. Thanks for finding it.
What‚Äôs interesting is that you can use Rust with Elixir! Using Rust to implement a NIF can provide better performance than pure Erlang/Elixir. Additionally, the safety of Rust makes it a good target for a NIF, since a crashed NIF will crash the BEAM. Discord has an interesting blog post about this recently: https://blog.discordapp.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3
üëç
Read all the recommended books on the elixir site. And just make something on the side. They will grow you, so just look up stuff during work as well to understand things before implementing.
I wouldn‚Äôt say I have any authority in elixir, but I have worked with multiple people who have never worked with elixir before. Most importantly, Elixir isn‚Äôt some kind of incredibly complex magic, it‚Äôs a programming language, ultimately just another tool under your belt. If you already know about functional programming paradigms, you are off to a good start, if not I recommend watching some talks that focus on beginner level elixir. Second, dont obsess about stuff like genservers, multiple processes communicating with each other, concurrent programming or anything people will usually tell you is amazing about elixir. Get familiar with the syntax and the basics. Again, it‚Äôs not like elixir is some magical unicorn. The only things you need to know to start are the same you need to know for every other programming language out there. Go to the elixir forum, introduce yourself, start a basic Phoenix project if your company uses Phoenix, start the elixir course on excersism, go through the introduction on the official elixir website. You know, all the stuff you‚Äôd do for any other language ;) Basically the hitchhikers guide to galaxy‚Äôs advice: don‚Äôt panic.
Sage advice thanks guys ill get to it.
Here are some suggested resources that you can checkout. I've utilized (or will utilize) everything on this list in my own study of Elixir and the Elixir ecosystem. * [Programming Elixir 1.6](https://www.amazon.com/Programming-Elixir-1-6-Functional-Concurrent/dp/1680502999/ref=pd_bxgy_14_img_2/131-8511091-3518950?_encoding=UTF8&amp;pd_rd_i=1680502999&amp;pd_rd_r=89d06d15-9524-11e9-8f2e-7b657eb7b6fa&amp;pd_rd_w=c1SDG&amp;pd_rd_wg=wUfn1&amp;pf_rd_p=a2006322-0bc0-4db9-a08e-d168c18ce6f0&amp;pf_rd_r=HWBZ854J5VKR526D7EG5&amp;psc=1&amp;refRID=HWBZ854J5VKR526D7EG5) =&gt; This book provides a great introduction to the Elixir language. I kind of got lost when Dave Thomas got to gen servers, supervisors, and workers but the rest of the book is excellent. (I'm pretty sure a second pass on those topics and it'll make sense. :-) ) * [Phoenix in Action](https://www.amazon.com/Phoenix-Action-Geoffrey-Lessel/dp/1617295043) =&gt; It just dropped back in May and it is a great resource not just for Phoenix but learning Elixir as well. I'm roughly half way through it and I love Geoffrey Lessel's approach to teaching Elixir and Phoenix. I definitely recommend it. * [Elixir in Action (2nd Edition)](https://www.amazon.com/Elixir-Action-Sa%C5%A1a-Juri-cacute/dp/1617295027/ref=pd_bxgy_14_img_2/131-8511091-3518950?_encoding=UTF8&amp;pd_rd_i=1617295027&amp;pd_rd_r=7beb9a31-9524-11e9-bb63-9f01c3232729&amp;pd_rd_w=aqOoV&amp;pd_rd_wg=ni0NC&amp;pf_rd_p=a2006322-0bc0-4db9-a08e-d168c18ce6f0&amp;pf_rd_r=92NE3FQYS5EH0HMYECDW&amp;psc=1&amp;refRID=92NE3FQYS5EH0HMYECDW) =&gt; I can't say much about this book since I haven't read it yet but it looks good and the 1st Edition has positive reviews on Amazon. As soon as I finish Phoenix in Action, I'll be jumping on this book. * [Programming Phoenix 1.4](https://www.amazon.com/Programming-Phoenix-1-4-Productive-Reliable/dp/1680502263) =&gt; This book is probably considered the definitive guide since it is written by the creator of Phoenix, Chris McCord. As soon as it drops, I'll pick up my very own copy. * [Exercism](https://exercism.io/) =&gt; This site provides coding exercises for tons of languages including Elixir. * [Code Signal](https://codesignal.com/) =&gt; This site is similar to Exercism, so you'll have tons of opportunities to practice Elixir. * [Project Euler](https://projecteuler.net) =&gt; Project Euler provides language-agnostic coding challenges. I've gone through a few problems in Elixir and the difficulty of the problems will "stretch" your Elixir skills. I hope this helps!
This is amazing thankyou for spending the time to create this reading list for me this is super useful.
I didn't see anyone in here say it yet but "congrats" ... not gonna lie that I'm a bit jealous you're going to be doing FT elixir. ;)
Read all the books! &amp;#x200B; As another commenter said Elixir is a programming language and a simple one at that. I would recommend a toy project outside of work if that isn't asking too much from you, but I tend to learn more on toy projects OR ask work if they will allow you to do like weekly exercises with coworkers or what have you.
I have no authority other than I semi-recently picked up Elixir and Phoenix (the defacto web framework for Elixir) with intent to build a pretty decently sized web based project. Been putting in about 2 hours a day for ~6 weeks so progress hasn't been amazingly fast but progress is being made while running into occasional issues (all of which has been solvable in the end). My learning path has been: - Watched a ton of ElixirConf talks to get excited and learn more about the benefits / ecosystem - Glanced Elixir's docs for familiar ground (how do I do XYZ in Elixir) - Glanced Phoenix's docs for getting a general idea of what words are used to describe certain things (I have prior web dev experience) - Looked at the source code of a real world app at https://github.com/thechangelog/changelog.com to use as a guide for general best practices - Asked for help when needed - Used all of the above resources while building my app, looking up things as I ran into trouble - Eventually bought the Programming Phoenix 1.4 book to help fill in some gaps Overall it's been working out. With less experience you may want to start with that book once you get the bare bones basics down and follow along exactly as you build the app but expect that you will have to research a bunch of topics as you go.
You shloud also check out Erlang, how it relates to elixir, and get accustomed to the syntax in case you would have to debug some Erlang code.
Spot on. Focus on the language and less about details until you have reason to. The elixir slack is invaluable and I'm always willing to answer questions there if you tag or message me.
I was in a similar situation. Here are some tips I recommend. Learn and practice with the pattern matching operator, =. To some, it seems like just a simple assignment operator. Oh no no no. Pattern matching is border line magical. For example, you have a variable that is a map. You can easily pull out what info you need like such: &gt; `%{title: title, id: id} = map` You now have two variables: title and id. Moreover, you can pattern match on function parameters to take overloading to the next level!! Using the map example, say you have an overloaded function that only deals with id's of 1: &gt; `def dostuff(%{title: title, id: 1}) do...` &gt; `def dostuff(map) do...` The first function will match with only ids of 1, and the second function is just the fallback, or catch all for everything that isn't id 1. Next, Elixir is not pass by reference. There is no mutation of variables. So if you are working with enumerables, let's say you want to filter out all occurences of `1` in a list of numbers. `Enum.filter(your_list_here, fn_to_remove_1s)`, your_list_here never changes. The function just returns a brand new list. Finally, Play around with the various functions the elixir comes with: https://devdocs.io/elixir~1.7/list Map, Enum, and List are very helpful. Hope that helped. If you have any questions feel free to message me. Always willing to help. Good luck!
Dot notation? try not(fun.(x))
I thought . is for anonymous functions. What if the function I passed in as parameter is not anonymous?
Technically it's still an anonymous function, it's just bound to a variable/parameter.
Awesome thanks i never would have thought of slack as a place to look.
Thankyou man im super happy in general as this is my first job in tech after working in retail for 13 years haha.
Thats awesome dude thanks for the advice specifically the real world example project i need to take a look at that.
Good point. Noted
Thanks man i already used pattern matching in my test project im pretty comfortable with it as its similar to destructuring in es6 but ill have to read more to pick up all the key diffrences.
Dot is used for closures. Every anonymous function is technically closure, but when you pass ‚Äúnamed‚Äù function as an argument you ‚Äúenclosure‚Äù it before - that‚Äôs why you still need to use dot. Other case - you can pass only it‚Äôs name, then it‚Äôs technical not a closure, and you don‚Äôt need dot notation.
I personally found Sasa Juric's book, "Elixir in Action" to be excellent.
If it happens that your company also uses Riak (who knows ;) ) you might be interested in playing with a project of mine: [https://github.com/tanguilp/attribute\_repository\_riak](https://github.com/tanguilp/attribute_repository_riak) There's still some work to do, so you're welcome (and I'd be glad to help).
Haha thanks ill get on it .
I think you can only pass modules like this by name.
One can use [https://hexdocs.pm/elixir/Kernel.html#apply/3](https://hexdocs.pm/elixir/Kernel.html#apply/3) to call function by it's name
Ah yes of course the good old mfa tuple. Can't call it with () though.
Absolutely
Congratulations! My name is Mark Ericksen. I'm a host on the [Elixir Mix Podcast](http://elixirmix.com), I run an [Elixir Meetup](https://www.meetup.com/utah-elixir/), and I will soon be more officially launching a FREE Elixir mini course. It is an introduction to Elixir data types and focuses on learning "pattern matching". Pattern matching is a fundamentally different way of coding. It is used throughout Elixir. As others have pointed out, you don't use "=" for assignment, it's the "match operator". So it behaves differently. Please feel free to check out the course! It's BETA and I need to finish making several videos that focus on general concepts. However, all the content is there and it has already had a small beta group go through it. Feel free to leave comments, questions, corrections, etc. on each lesson. Course: [https://thinkingelixir.com](thinkingelixir.com) The course and site focus on someone exactly in your situation. - already understand programming - new to Elixir - new to immutability - new to functional programming (OOP background) The goal is help people like you become productive and ramp up your Elixir skills. I focus on the skills needed to get a programmer quickly contributing to a company's existing project. Welcome to Elixir! It's a great community. I hope you enjoy it here. :)
Pick one book and read it. They are all good. If you feel like reading 5 books, resist the temptation and instead read the same book 5 times. Practice.
Thanks ! There is a ton of info here and im going to parse it all when i have time , the podcast sounds super interesting aswell as the confrence. And i think you are right doing coding challenges everyday is really helpful. So thankyou for all the info.
I think the example NIF was a bit complicated as I don't know Rust at all.
The guy explained almost everything from the example so one can search for more information. There's not enough time to learn Rust in an hour long talk.
This is something I've thought about and is the primary reason I've started learning Rust this summer.
He does not "explain almost everything", he goes very fast. Well that's the whole point. There is too much about Rust in this talk and not enough demonstration of a simple NIF, then a more complex example. Just my opinion obviously.
We use something super similar at work based on https://www.youtube.com/watch?v=8qDXG7tnl9w
Holy shit, if I understood this right it‚Äôs similar to how Go can compile a single binary to be used on whatever architecture you target without anything else?
You do have to compile it on the same architecture that you're targeting. You can often do that with Docker, though. The output is also not a single binary (although I assume you could package it like that?), but a collection of files that includes the Erlang VM + your compiled files.
~U sigil for working with UTC DateTimes my Love! Where have you been all my life!
this person datetimes
:: applause :: Declaring the language feature-complete is a brave step, but will probably now allow some cool stuff by others!
Let me know if you still need any help!
If \`fun\` comes in as a named anonymous function, then you have to always call it via fun.(args) in scope. You don't on that line. So it's looking for a function in that module called \`fun\` that takes 1 argument and it can't find one.
I'm super excited to be going. The Elixir conferences I've gone to have all been a lot of fun and educational. A bit of self-promotion, check out our class "Building Scalable Real-time Systems in Elixir" on Tuesday!
That's actually a class I'm really interested in! I'm still trying to get the greenlight on attending from my company, but this year looks fantastic. One of my old buddies is giving a keynote and other folks I know are giving talks. Not to mention the venue looks WAY better than last year.
Can someone explain how the releases would work together with something like Kubernetes?
You would probably use a 2 stage docker build which prepares the release in stage 1 and gets it ready to run in stage 2. I've been doing this with distillery and it works very well
The biggest gains I've experienced in the Elixir world were from taking examples from these books and elaborating on them with my own ideas for improvements or features. Come up with an idea and just go build it.
Great news. Excellent work
No, it's not like that. It produces a tarball containing many files which needs to be unarchived, and it'll only run on an environment similar to the one it was compiled on.
Do you have any suggestions on how to reduce the number of compilations to include tests with a similar docker multistage build?
I don't find myself wishing for much more than what Elixir already provides. I've kind of wondered how much more it could develop. Keep in mind there's a heck of a lot of stuff in Erlang (with syntax only a mother could love).
&gt;reduce the number of compilations to include tests Sorry, I don't really understand this. I'll just generally say how I do it: I use a Dockerfile for prod and Dockerfile.test for codeship. They're off the same base but slightly different in setup. I don't use Docker during development at all.
I would have to agree it's already pretty darn beautiful as a general purpose language and vm
Yea that makes sense i started with programming elixir 1.6 yesterday and just made an empty mix project and started playing around with some of the suggested functions from the book and writing tests and making assertions based on what i had just read . Every peice of me wants to jump ahead to concurrency and more complicated stuff but i know its always better to become comfortable with the syntax of the language first.
Hey, leafynospleens, just a quick heads-up: **peice** is actually spelled **piece**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Nice!! The concurrency features of elixir are phenomenally fun to play with. You should definitely take a look at Elixir in Action. Sasa Juric does a wonderful job explaining how supervision and process registry works. Though I do recommend using the source for the book that's on his github.
Hey, also check out Tensor programming Youtube channel. He got an amazing playlist : [https://www.youtube.com/playlist?list=PLJbE2Yu2zumA-p21bEQB6nsYABAO-HtF2](https://www.youtube.com/playlist?list=PLJbE2Yu2zumA-p21bEQB6nsYABAO-HtF2) &amp;#x200B; Joy of Elixir is nice for beginners: [https://joyofelixir.com/](https://joyofelixir.com/)
You should not be trying to execute test suites directly in-line *during* a Docker image build, primarily because in anything but a pure library, it will rely on external resources like a database. Those should be thought of as unavailable from that context, although you could probably hack it up to make it work, it‚Äôs an anti-pattern. Much preferable to sequence a non-Dockerized test suite before you even before you start the Docker build, which is viable for any CI platform or approach.
Distillery-like releases are cool, but this is the real MVP.
This should be the next "feature" on the roadmap imo :)
Rewrite one of your previous django projects in Elixir. Perhaps with LiveView for rendering? Most of your previous experience will be worth quite a lot. Also, if you're just working by yourself, why not build things in Elixir instead of Django? Are you advertising Django to customers?
If you‚Äôve been working that long as a developer then just apply for senior positions.
I don‚Äôt think elixir is a language you should learn to find work, there‚Äôs not a huge amount of elixir jobs out there (tons of Django/python jobs however). The real power of elixir is otp, you should be learning about architecting robust distributed systems, not just a new language, if that‚Äôs something you‚Äôre interested in.
I feel that for the kind of "boring" projects I'm currently doing for clients (Wordpress-equivalents, basically) Django, combined with Wagtail, is an excellent solution that allows me to build things very quickly, with a great admin interface for the client. If I used Phoenix I'd have to implement myself, in a worse way, all the functionality that comes for free with Django, which is not really cost-effective for this kind of sites (although it would be a good way to learn). I could try writing some API with Phoenix though, that seems a good use case. I also wanted to look into GraphQL, so Absinthe might be a good candidate. Another idea I was considering (just for fun) is to expand on the Exercism poker scoring exercise and build a full-featured poker engine + frontend with LiveView, which wouid give me practice with OTP too.
It's true that I've been doing this for a long time, and I have good knowledge on multiple domains. But I don't have much experience working on a full-fledged team, on a big codebase, or with development methodologies like agile... So I'm not sure I could classify as a senior developer.
Well, Elixir has already influenced the way I write code in Python and other languages, so I would love to keep learning it whether or not I get a job with it. I know the market is smaller but I guess giving a try doesn't hurt; if I don't find anything I'll start looking for something Django-related. Could you recommend some reading/learning resources for architecting distributed systems?
Yeah I need to take another run at learning rust
You're missing the \`as:\`, it should be: \`\`\` resources "/articles", Admin.ArticleController do resources "/comments", Admin.CommentController do put "/test1", Admin.CommentController, as: :mark\_as\_ok end end \`\`\` Check the options for \`match\`, which are the same for \`put\`: [https://hexdocs.pm/phoenix/Phoenix.Router.html#match/5](https://hexdocs.pm/phoenix/Phoenix.Router.html#match/5)
Well, if you already have considered writing a poker app, just go for it. For inspiration watch how a newbie learn JS and quickly makes a game and struggling with bugs along the way. I want to share this video because it shows how we become stale and have more resistance when we have more knowledge. Mike Boyd, how I learned to code my own game. 15 minutes. [https://youtu.be/s12npdDmGUc](https://youtu.be/s12npdDmGUc) P.S. I really love the video.
I'm not trying to discourage you from learning it. It's certainly good for learning FP. I just wouldn't learn it solely for the purpose of finding a new job as the market is pretty small. It wouldn't, however, be bad to put it on your resume, that would show you have interests outside of building CRUD apps, which is good, though not all managers will understand that. &amp;#x200B; [https://learnyousomeerlang.com/content](https://learnyousomeerlang.com/content) Is a great resource for understanding what erlang/elixir is good at, it's also just fun to read. The "distribunomicon" section is a really good intro to what distributed systems are about and what problems you'll be thinking about. Its examples are erlang, but elixir is erlang, so you should be able to figure out what's going on. &amp;#x200B; Then, go build a distributed chat application, or something with streams and sockets, where the servers talk to each-other. Phoenix PubSub + Channels work this way, try understanding them and why they're so powerful. You can just make a phoenix app, but they will have done most of the work for you, so you won't learn quite as much.
Something to keep in mind is do not be deterred by a project being "boring", "done before", or "simple". I think Elixir teams would rather like to see completed projects that show that you have a grasp of the Elixir/OTP style of programming. I doubt anyone cares if your app idea is novel when they're just looking to hire you.
You should get good at using OTP
I'm going to look for a (senior?) developer position soon but I've not been working as a developer for 7+ years. My strategy is to pick up some fancy new standards (for instance: WebAuthn, OAuth2), implement them and publish them open-source. That way you gain deep knowledge on protocols and have something to show during interviews. Maybe that's the way to go? Not sure yet if it works though -\_-
Thanks, codesignal looks exciting. Trying it out at the moment. Another one like exercism is codewars.
Hi everyone üëã, today a quick article (and screencast) still related to the LiveView pushState. The [previous one](https://www.poeticoding.com/phoenix-liveview-change-the-url-without-refreshing-the-page/) was mainly focused on `live_redirect`. We now see how to refactor the code with `live_link` getting simpler code and less messages exchanged between LiveView and our browser.
Mike Boyd is awesome.
TBH while multi stage docker builds are nice for end-Image-size, it completely destroys the simple caching logic you can make use of in CI systems: Pull the latest image from the registry. Docker normally would use this image as cache, but since it just contains the end result, it's not using it. You can add caching back, but it means keeping different stages as images in your registry and increases your ci script from 5 lines to 15, meh. I like the idea, but it also adds another step of complexity to big cloud stuff out there...
As someone who complained about using `live_redirect` for links, thank you for the update! A good summary I found is: use `live_link` for changing the address starting from the client, `live_redirect`when starting from the server.
Thank you to point out some aspects that needed to be inspected further! üòä
There are not a lot of options. Phoenix is not designed to me a CMS. [Thesis](https://github.com/infinitered/thesis-phoenix) maybe your best choice if you need one. I build my own website based of [changelog](https://github.com/thechangelog/changelog.com).
There is also \[Zotonic\]([http://zotonic.com/](http://zotonic.com/)), which is in Erlang.
I don't think there is anything in the design of phenix that hinders it from being used to create a wonderful CMS -- more likely than not the lack of open CMS options currently is related to the frameworks age not its feature set. Many times opened CMS projects start life as internal projects that get migrated out to open and that tends to take time. Those internal projects are many times also built out by dev houses that have moved to the framework/language to accommodate their client needs. &amp;#x200B; TLDR: they will be coming.
I built my own, using Phoenix. Other than figuring out how to customize meta tags on a per-post basis, it was all very smooth sailing
I'd second this other's book recommendations, especially from Manning and Pragprog. Obviously, if you've seen my YT channel, I'm a fan of project-based learning, too. I think the best way is to keep a tight loop of studying, then using that thing as quickly as possible, then learning some more and applying it, etc...
What are some resources where I can learn the "Elixir/OTP style" versus just the Elixir syntax?
I highly recommend that you visit the [Pragmatic Studio](https://pragmaticstudio.com/elixir) and their Elixir courses - they are outstanding!
Thank you for hard work, Elixir is really nice and practical language! So, language is complete, will use that as an opportunity to suggest some new features: \- Make types part of the language, so it will be more compact than the typescpecs writings. \- Full multiple-dispatch or parametric polymorphism \`map\` instead of \`Enum.map\` with ability to override it from any module, like in Juila language.
Looks interesting, I'm keen to read it. &amp;#x200B; But I also kind of fail to see the purpose of this post. It essentially just says "I will eventually post something that might interest you". Maybe post part 1 directly next time?
Here's a new book that could help: https://pragprog.com/book/jgotp/designing-elixir-systems-with-otp However, I've always found it easier to just build something and learn as you go. You could build something as simple as a weather app and learn quite a lot about OTP just from that.
... looking at the article.. trying to find the content... where is it?
Awesome- I read through Elixir In Action and built a craps simulation as a start so I'll check this out next.
Yeah I'm confused. This is more of a "I'm going to write an article" article.
I like to call it the PEE stack. Postgres, Elixir, Elm. Maybe the P could stand for phoenix? or maybe the PEEP stack? Doesn't have quite the same ring :P
MEE - Mnesia Elixir Elm MEEE - Mnesia Elixir Elli Elm
Using elm is suicide. No development. No good cross platform.
&gt; If I used Phoenix I'd have to implement myself, in a worse way, all the functionality that comes for free with Django, which is not really cost-effective for this kind of sites (although it would be a good way to learn). You might wish to try this library: [https://github.com/tmbb/mandarin](https://github.com/tmbb/mandarin). It contains generators to generate admin pages for your resources. It's very unlike Django Admin, though. Instead of introspecting your models and generating pages that are integrated into the router, it actually writes text files into your source tree containing contexts, schemas, views, controllers and templates. It makes your source code much more verbose than something like Django but also much more customizable. It doesn't support many-to-many relations yet. It's based on another of my packages called `forage`, which turns dynamic URL query strings into DB queries and integrates nicely with form widgets. It's not very tested yet, so be careful when using it in production.
Thanks for the link, I will definitely go through this book.
I mean, building a CMS from scratch with zero Elixir production experience seems the opposite of simple :) But I would prefer to exit my comfort zone and write something that takes full advantage of OTP and Elixir‚Äôs strengths.
Thanks, this looks really interesting!
Good luck! Let me know how it goes :)
Actually, this is the repo with the tutorial: [https://github.com/tmbb/mandarin\_office](https://github.com/tmbb/mandarin_office)
As stacktrace said it cannot find init callback in ClientTracker module. Did you rename MyTracker from example to ColumbaServer.ClientTracker? Could you provide ColumbaServer.ClientTracker code as well?
What does your tracker module look like?
Here is an example of tracker usage from a library of mine: https://github.com/pushex-project/pushex/blob/master/lib/push_ex_web/channels/push_tracker.ex#L22
I think the naming's ok, here's the code: defmodule ColumbaServer.ClientTracker do @behaviour Phoenix.Tracker def start_link(opts) do opts = Keyword.merge([name: __MODULE__], opts) GenServer.start_link(Phoenix.Tracker, [__MODULE__, opts, opts], name: __MODULE__ ) end def init(opts) do server = Keyword.fetch!(opts, :pubsub_server) {:ok, %{pubsub_server: server, node_name: Phoenix.PubSub.node_name(server)}} end def handle_diff(diff, state) do for {topic, {joins, leaves}} &lt;- diff do for {key, meta} &lt;- joins do IO.puts("presence join: key \"#{key}\" with meta #{inspect(meta)}") msg = {:join, key, meta} Phoenix.PubSub.direct_broadcast!( state.node_name, state.pubsub_server, topic, msg ) end for {key, meta} &lt;- leaves do IO.puts("presence leave: key \"#{key}\" with meta #{inspect(meta)}") msg = {:leave, key, meta} Phoenix.PubSub.direct_broadcast!( state.node_name, state.pubsub_server, topic, msg ) end end {:ok, state} end end
When you call: &gt; GenServer.start_link(Phoenix.Tracker, [__MODULE__, opts, opts], name: __MODULE__) You are calling Phoenix.Tracker implementation details. You want to do this instead: Phoenix.Tracker.start_link(__MODULE__, opts, opts)
You're talking yourself out of it. If you have that many years of experience you can apply for senior software engineer positions. Believe in yourself and have confident in your skills
Impostor syndrome is very real for me... but thanks, you‚Äôre probably right, and there‚Äôs no use in wondering ‚Äî I just have to try.
Thanks, the code compiles now.
I work at a startup right now and I've met so many people like you who don't have a formal cs background and just kinda started with freelance work and are now senior engineers at the company and very successful. Trust me, you're definitely capable
Today, it's even cheaper! Manning is doing an "every ebook is $20" promotion.
Oooooooo
Generally, I agree completely, there are a lot of web sites implemented as SPA's or requiring JS to render at all that don't need to be. At work I use React because this industry is almost entirely a fashion driven appeal to authority, but front-end frameworks bring a ton of complexity and redundancy. When I look at the React stuff we have so much is reinvented: urls are reinvented in frontend routing libraries(with the side-effect that you have to introduce some concept like 're-hydration' or whatever for 'rendering a web page'); browser history and back buttons are usually just broken; eex templates are reinvented in jsx; session cookies are reinvented in jwt; redundant validation of input on client and server (or worse: using Javascript for the backend, but at least the absurd made-up word 'isomorphic' has fallen out of favor). As an older coder I also find it amusing to watch the web kids reinvent XML things like Json-Pointer for XPath or Json schemas for xml schemas, or get excited about compiler tech from 1972 like 'tree shaking' or whatever. The supposed benefits are usually mythical--I hear a lot of lip service to 'offline first' but I've yet to see more than a handful of websites that were useful offline. Offloading processing to the client is a real benefit, especially if you're renting servers from aws/gpc/azure, but it's also incredibly user hostile ('I can't be bothered to write efficient server-side code so here, take this 10mb of Javascript and use 500mb of memory so i can offload all this shit to you').
I agree with you. However, when it comes to making pages interactive, i tend to throw in some react or vuejs depending upon the project. I tried using jquery but it ends up getting very dirty. I like the idea of keeping separate components that way if there is a bug, only that component will fail while the rest will work normally.
You might like Turbolinks https://github.com/turbolinks/turbolinks
Sorry I'm new to TurboLinks (and a front-end challenged in general). Is TurboLinks server-side framework agnostic? If so, why does it have installation instructions specifically for RoR and npm? I suppose it can be loaded using a `&lt;script&gt;` tag but it doesn't mention how. Also, is there a bigger read about TurboLinks somewhere?
Thoughtbot did a great write up about replacing react with Phoenix and Turbolinks back in 2016: https://thoughtbot.com/blog/how-we-replaced-react-with-phoenix
If we forget LiveView (that you don't mention) I'm not sure how it's a specific question about Phoenix. Also a front-end framework is not really about easiness for the developer, but what it enables for the users.
Not a Phoenix user but Nitrogen which is a framework with WebSockets as a base concept. If you have a simple abstraction to deal with web sockets you will end up with a more direct and simple application (there wont that artificial front and back end contexts which is most of the time forced on you for no benefit at all, unless you work with 10 more guys on the same application). People say that you need client side to make interactivity... thats just cargo cult. You can just cook all that interactivity from the server just fine. You can make complex interactive and responsive server-side first apps without falling in the dark sea of js libraries out there. &amp;#x200B; The thing why client-side rendering won is because managers and marketing people, that as somebody said, think in terms of hype instead of technical excellence. Truth is most of the mainstream languages used today cant handle the server part at all. Which is why Phoenix is gaining lots of traction, thanks to solid server languages like Erlang and Elixir. &amp;#x200B; Take a look at the new Phoenix LiveView library. Im pretty sure that abstraction will solve most of your doubts about whats possible.
[Svelte](https://svelte.dev/) might be an option then
neat. thanks.
It is server side agnostic for most GET requests but it's helpful to have a touch of server side support to handle redirects and form submissions. You can write a plug to handle that, but lucky for us someone else already did. Here's a fully working example: https://github.com/thechangelog/changelog.com/blob/master/lib/changelog_web/plugs/turbolinks.ex
I have historically been in the "most sites don't need an SPA" camp, and this is pretty much true. However, the last app I built was a phoenix app with server side component, for the admins, and an SPA vue app for the customer side. I have to say that the nicest benefit of this is that the server side app--where business logic resides--becomes really simple, and separating the front-end from the back-end has some really nice side effects as to how the code is structured and how work can happen. For example, if we're prototyping a feature, we can just do it in vue and "pretend" that the back end does it's thing. We were able to try vue, nuxt, even react, and not have to change a word on the back end. It's a really nice contract that I think can result in real productivity gains if done correctly.
Amazing video! I got to know about Elixir from a Discord blog post. This video gave me the extra push to want to pick up Elixir and start building stuff with it.
Yep you have the right mindset. Do everything server side if you can. It's much more testable, consistent, simple, fast, and accessible. You should use a front end framework and lots of JavaScript when you site needs a lot of interactivity. Otherwise, stay sever side as long as you can.
That's exactly what we do with our app. We're using Gitlab CI, the first stage "test" uses the elixir docker image, spins up a mysql image, runs mix ecto.migrate and mix test. When this passes, then next stage executes `docker build` with a multistage Dockerfile: the release is built from elixir:alpine (we're still using Distillery), second stage is just a base alpine image that unpacks the release created by distillery.
We are starting to use web components for our design and layout components. We are using Stencil.js for it because we are used to React. I think SSR is really brittle and takes too much overhead. I think using Phoenix with web components and possibly Turbolinks with a little bit of live view sprinkled in is a killer combo. Web components allow for super easy testing, good isolation ( React has a tendency of allowing for too much waterfall like design with props or context) and it easily works with IE11 which is super important in Canada.
Is psql configure to accept socket connections?
Bondy project code https://gitlab.com/leapsight/bondy
Not an answer to the problem, but whatever is wrong is going to be on the DB side. I set up a new project just a couple of days ago with Elixir 1.9 and Phoenix 1.4 and everything went smoothly. &amp;#x200B; Just wanted to make sure you were looking in the right direction. Good luck!
&gt; To be fair, if you‚Äôre an Elixir dev you‚Äôre in a slightly better situation than your Erlang counterparts: The documentation is, I believe, much clearer. Truth. This is one of the things that convinced me to start using elixir where we had previously been using erlang. The documentation is amazing.
Generally agreed but; * JWT isn't a reinvention of session cookies, JWT exist to facilitate a stateless architecture so that you can remove the idea of "sessions" from your stack. * Nothing about clientside routing necessitates hydration at any step * Clientside validation isn't redundant, it facilitates much better accessibility
The discussion here is about front end frameworks though, not service to service, and in that context JWT in almost all cases just acts as a bearer token in the same way that session cookies did, except that instead of looking up the session in redis or whatever now you decode the jwt, with the additional pain of figuring out how to invalidate them, keeping certs up to date &amp;tc. The web was already stateless and session cookies were already being used to authorize every request to a protected resource. I should have just said SSR there for the client routing. I get proper html with required and input types and whatnot, which I think people should use regardless of how they are validating the input, but how does it help a11y if on form submit you hijack the event and run it through a JS function to make the box red and add the message 'Password must contain at least one emoji' versus doing that server side?
Nice, I use the same things. I am excited for onivim2 though
Easiest would be to append hours, minutes and seconds like this `date = "2019-07-03"` `date_with_time = date &lt;&gt; " 00:00:00"` Then you can use the `NaiveDateTime.from_iso8601!(date_with_time)` which gets you `~N[2019-07-03 00:00:00]`
You didn't specify what time you want to use, so I'll assume midnight. Since that date is already in the ISO 8601 format, just tack on your time string and use `NaiveDateTime.from_iso8601/2`: date_str = "2019-07-03" NaiveDateTime.from_iso8601(date_str &lt;&gt; " 00:00:00") # =&gt; {:ok, ~N[2019-07-03 00:00:00]}
Umbrella applications and supervision trees are different abstractions for different purposes. You can use both. Umbrellas are for project organization and development convenience whereas supervision trees are for runtime process fault tolerance and lifecycle control.
Instead of appending strings like below, you can parse the date and create a naive date time from both date and time parts: iex&gt; NaiveDateTime.new Date.from_iso8601!("2019-07-03"), ~T[00:00:00] {:ok, ~N[2019-07-03 00:00:00]}
Thank you. Yes this I understood, just I cannot identify when to use umbrella applications ? Because sometimes there are used to separate project organization but are not often running applications. So why put it into a dedicated application instead to nest it inside the lib folder ?
`with` is certainly the idiomatic way in elixir. Other options are: 1. Let it crash: just match on the :ok case and fail with a MatchError if an error occurred. This is usually only appropriate if the error doesn‚Äôt need to be presented to a user. 2. use one of the many packages that provide functional tools for mapping over error tuples. There‚Äôs a list in the OK package [readme](https://hexdocs.pm/ok/1.8.0/readme.html#additional-external-links-and-resources)
Thank you for the reply :) I thought to let it crash, but because I'm building an interpreter I need to show the user the parsing errors. Do you think write multiple time `{:error, reason} -&gt; {:error, reason}` is bad or not ? (sorry I'm begineer on Elixir/Erlang)
It depends, and it doesn't really matter if you use the Umbrella structure, Phoenix's project structure, Poncho's, or just more modules in your `lib` folder. The trade-offs are minor. Umbrellas or Ponchos are good for bigger projects (think multiple years of coding, lots of developers). Phoenix/Mix generated apps are good for everything else. Any project structure can result in the same deploy-able set of code. I recommend just using whichever you're comfortable with; Elixir makes it easy to restructure your project because it's nothing more than modules and functions. I've migrated Phoenix projects to Umbrella projects in minutes - Elixir's tooling is nice like that. The only thing that's really worth thinking about is the boundaries and contracts between your contexts, and that depends on your domain. The project structure is just an implementation detail and it's not worth fretting over too much. When I was newer to Elixir I vacillated on Umbrellas vs Phoenix apps vs Ponchos and now I'm pretty sure it was a waste of time. They're all fine.
This is not completely true. Separate applications also have a separate application controller process - think of application process isolation. If umbrella application A exits, your application B will keep on running. So @sammanza if you need isolation in that regard, umbrellas are the way to go. For example if you have business logic that does business things and a separate API layer you want your API layer to ALWAYS work even if your business layer is not in a healthy state. That's how you would achieve it.
I've come to this same conclusion. I've worked on many elixir codebases at work and haven't seen a need for umbrellas yet. Variety of business case and functionality that has been served well by lib. It's probably a controversial opinion so I generally keep it to myself.
At my company, we have a mixture of the two. Our "main" application is a large phoenix app, observing the standard library and web split. Its very much a traditional phoenix app. We also have a large GraphQL app, which is an umbrella app. There is a single Absinthe app which handles the resolution and whatnot, and then a variety of other apps, depending on the context required. Each app has its own set of requirements; some listen on a socket, others an event-sourcing module, while still others are purely bags of functions. We could do what the Umbrella app is doing as just a part of a single app, but the separation of concerns is very nice.
By using supervision trees with one for api and one for business, I could reproduce the same thing, right? I mean ensure the healthy state of boths.
Thanks for your response. I saw indeed the release management can target the full umbrella or dedicated app. So to communicate between apps no need to use processes or network layer?
The rule of thumb I've found helpful for umbrella applications is only use them when you may want to scale apps independently. Even then, if you think you might want to that someday it may be simpler to start with a single app and split it later.
Right. Take a look at [action_fallback](https://hexdocs.pm/phoenix/Phoenix.Controller.html#action_fallback/1) works in Phoenix. You only use `with` to work with "happy path" and leave your fallback function to handle the error. Of course you need to make sure that all your possible errors are looks the way you expect
Not 100%. If your business supervision tree exits the error would propagate vertically to the root application controller process taking it with it. Never mind the api supervision tree still working... Applications on the other hand have complete isolation since there‚Äôs no horizontal error propagation.
&gt; What is your thoughts about this? All my side projects have been just backend and jquery. It's much easier to maintain dependencies and keep my stuff up to date with less things involve. I've played around with ansible, docker, etc... In the end, as a one man stop shop, I've learned to keep my technology stack at a minimum. Unless that is I get a job and they ask me to use front end once and a while. I was a fullstack since 2008 and I've given up on front end framework. I cannot justified the time and cost benefit of being fullstack while having a frontend framework skillset. I have a life beyond work and it bring me no joy juggling with technology and chasing fad. Boring technology is for me unless you pay me enough.
Ok thank you :) And is it relevant to use applications just to share modules without running ?
Needs to support SpoNgEBoB CaSE
I think you put together a nice and solid list of things that might tip someone who isn‚Äôt sure about the maturity of elixir over the edge :) We are using elixir and Phoenix in production, and it is our current infrastructure of choice for web applications. The state Phoenix is in right now, I am very confident in saying any Ruby on Rails developer can be almost as productive after maybe 2 months. And I also dare say that every rails developer can produce easier to maintain code in Phoenix after a few weeks, than he did after a long time in rails. I have seen it first hand. Disclaimer, I don‚Äôt think rails is bad. I love ruby, and I like the vast ecosystem of rails - got a problem, well there is a gem for that! I just think that Phoenix is better for thinking in domains and teaching you how to less of a wizard apprentice than rails, while maintaining a lot of productivity. IMO, you missed one of the huge selling points of elixir in your post though. It‚Äôs basically a pragmatic approach functional programming. It has most of the good things of FP while going for a more practical approach in some parts, making it a great language for people switching over from Ruby, Python, or any more OOP language. Of course, take this with a grain of salt, because I am very sold on elixir, and don‚Äôt really use any strictly functional language. But as far as I‚Äôm concerned, I love working in elixir, and it didn‚Äôt take all that long to get used to it. Overall a very nice article about what elixir offers, just missing a tiny bit of love for what the language does to improve on erlang :)
Very helpful. I find myself going between vim and vscode, and I think this is a better vim setup than I have currently.
Perhaps this can help you: https://elixirforum.com/t/what-is-the-idiomatic-way-to-cleanup-test-database-with-ecto/1387 In summary, a combination of setting up a test database (sandboxed} and if there is dirty state left behind from testing, you may need to run with: MIX_ENV=test mix clean
The Ecto Sandbox adapter is used in this case. It serves the database connections from a pool, and puts all changes from the test into a transaction. When the connection is handed back to the pool, the transaction get rolled back. https://github.com/elixir-ecto/ecto_sql/blob/master/lib/ecto/adapters/sql/sandbox.ex Another newbie :)
Elixir does have a powerful macro system. I'm curious if this is something can be solved with a clever macro?
It makes the language much harder to interpret for both humans and machines. The variables in the pattern that the matched values get bound to are no longer lexically associated with the scopes those variables are valid for use in. Also, it doesn‚Äôt really offer any benefits for making the language simpler, imho, I can‚Äôt think of any situation where this is better than just writing the pattern down.
Oh goodness, I can imagine the code and the uses and I already feel dirty. But in a forbidden-curiosity way. Reminds me of how I felt when I saw the "shorter maps" hex package
An umbrella application can have application properties - like a hierarchical process structure - or you can use it as a shared module repository. But it's a bad practice to include A application supervision structure and plugging it into application B. The borders between applications should be clean and decoupled.
&gt; The variables in the pattern that the matched values get bound to are no longer lexically associated with the scopes those variables are valid for use in. That's not true. The pattern is just a pattern of symbols. A match is what lexically binds the symbol to a variable. If the variable goes out of scope, referencing it would be an error. &gt; Also, it doesn‚Äôt really offer any benefits for making the language simpler, imho, I can‚Äôt think of any situation where this is better than just writing the pattern down. Eh. That just wrong. Please excuse the `@` syntax I just made up, but the first fn is easier to read than the second. Plus these pattern are now reusable. @impl GenServer def handle_info(msg, state) do case msg do @fetch_history_msg -&gt; fetch_history(day_count, module_to_catalog) @success_msg -&gt; fetch_succeeded(records) @failed_msg -&gt; fetch_failed(day_count, failed_attempts) @down_msg -&gt; :ok end {:noreply, state} end @impl GenServer def handle_info(msg, state) do case msg do {:fetch_history, day_count, module_to_catalog} -&gt; fetch_history(day_count, module_to_catalog) {_ref, {_, _, {:ok, records}}} -&gt; fetch_succeeded(records) {_ref, {day_count, failed_attempts, :error}} -&gt; fetch_failed(day_count, failed_attempts) {:DOWN, _, :process, _, _} -&gt; :ok end {:noreply, state} end
It probably is. I will look into that. Does it have reader macros?
Eh. Ya. You are correct.
Not very familiar with Lisp, but I believe elixirs macros have the same kind of access, they can operate on the AST.
It is easy actually. You just have to define a macro that takes variable parts of a match and return the full match pattern quoted.
Fabulous.
The docs are insufficient
Why couple so heavily to ecto? Why not just return the changeset and allow the user to make the call to the database. I'd prefer that stuff not hidden from me.
I've been wanting to play with scenic for a while, but the hardware requirement on this one is a bit tough!
Would love to see a photo of the final result.
Try using \`mix phx.gen.context\` &amp;#x200B; You should have a schema file that acts as the model and handles db stuff, and a context file that contains business logic and calls schema stuff.
Like Riiiiip said. Phoenix already has the patterns defined for you if you use the generator to generate your contexts/schemas, file for your business logic and it should spit out the controllers as well. I'll try to explain the pattern based on an example. Let's say one of the things you have a bunch of data around is books. You would generate a new context for books or put it under another context and it will give you a schema...schema is basically where you define your model (set the database table name, the field names, etc) and that file will be called book.ex. Then you will have a books controller which receives the request from the router, so books_controller.ex will handle all your crud endpoints (create a book, update a book, get a book, get all books, delete a book). In each one of those endpoints in the books controller, they are pretty simple but they each make a call to a books.ex function which has the actual business logic for creating a new book, deleting a book, etc....because creating a book maybe has more involved like creating an author and a publisher, etc if they don't already exist (whatever the business logic requires). And for the books.ex functions to write to the database, they call upon the book schema in order to write to the database...and if in order to create a book you had to create an author, you would call the authors.ex create function and let it handle creating an author since its business logic knows best. So hopefully that makes more sense and you can see how everything get split up amongst multiple files for each schema/model (elixir doesn't call them models but rather schemas which can be a little confusing).
I haven't documented this but there is a function to return the changeset: `Parsmeters.changeset_for(conn)`
I've updated the README with additional information
Also, this is not meant to map directly to the DB schema. Take for example a Form that actually changes two or more DB tables.
Tough is relative. The Inky is a bit niche and even a bit costly for what it is but a Pi Zero is fairly cheap and lots of people have some kind of Pi laying around. But certainly this is more of a DIY hobby hardware meets Elixir guide than something substantial. You can follow the guide and only do the on-host stuff if you want, just ignoring the eInk stuff entirely. &amp;#x200B; The blog also covers just getting up and running with Scenic in another post: [http://underjord.io/scenic-getting-started.html](http://underjord.io/scenic-getting-started.html)
Ah yeah, good idea, was a bit pressed for time when I was rounding out the post. Updated with a picture of the result. It might not be entirely final, I think I tweaked some font sizes after the photo but before publishing. Near enough.
This is a reason they split out ecto_sql: it is not just for sql db's, but an api that can be used for describing and validating structured data ... there are some examples somewhere showing things like using it for form validation, not toooo far from what yoimu are doing here, thouhh you have wrapped it all up in a pretty library :) question: is the params global to the module, or can we have different params for different functions? (i only.glanced in the ride in to work this morning, so apologies is that js an.obvious one...)
&gt;t an api that can be used for describing and validating structured data ... there are some examples somewhere showing things like using it for form validation, not toooo far from what yoimu are doing here, thouhh you have wrapped it all up in a pretty library :) You may have different params for different functions similar to how @doc annotations are for each function
Ah, it is positional, and the macro creates an inner module.. for me, given how large params can get (as in the example in the README) this could perhaps be hard to follow, and as params looks like a macro/function, could one perhaps provide the name of the intended function explicitly? e.g. `params index do` or some such? just a thought from someone who has only read through but not used your module :)
Interesting, the first version had this actually. I'll give it some thought.
On the macro doesn't actually create an inner module. Each module defined is namespaced under the \`Parameters\` name. &amp;#x200B; Similar to how all Elixir module are namespaced when you read it from Erlang. ``` defmodule MyModule do use Parameters params do requires :name, :string end def create() do # end end ``` The code above actually defines the schema under the `Parameters.MyModule.Create` name.
https://github.com/imranismail/parameters.ex/blob/master/test/parameters_test.exs#L51
First things first, if it will be possible to define specs that way, how you gonna use that information? Are you gonna run Dialyzer or what? Because specs by itself do nothing, it's just a metadata. Now, about possibilities. So, I started from sentence like "specs and behaviours are not interfere each other", but doin' some research I found that specs are actually will be translated into AST. That says that we actually can do something like that. If we had `parse_transform` in Elixir (have we? correct me if we can use it), I think it will be right call. That's documentation about AST: [http://erlang.org/doc/apps/erts/absform.html](http://erlang.org/doc/apps/erts/absform.html) You may see that `spec` and `callback` definitions will be translated into AST. So you need script, which will analyze AST and make sure that all correct.
Indeed we do. That's nice.
Holy lmfao are you my lost brother? Cut that cringe emo haircut and metal ass beard and were identical.
Ahahah, awesome ) Doubt I will ever use it. But it's a nice and fun tool to have )
Thanks guys! I'm already using the mix phx.gen.context set up so things are pretty organized. It sounds like I've got things set up well based on the great info you've passed on. Thanks everyone for helping with my sanity check!
Is distillery still needed when we have releases in Elixir 1.9?
mix release still does not support all the cases that distillery do, hot code swapping for example.
Thanks for sharing this. Just FYI OpenTracing and OpenCensus will be merged into [OpenTelemetry](https://opentelemetry.io/) - see [Merging OpenTracing and OpenCensus: Goals and Non-Goals](https://medium.com/opentracing/merging-opentracing-and-opencensus-f0fe9c7ca6f0)
Thanks. I am aware of the merger, but you are absolutely right, that it should be mentioned in the article. Thanks for pointing it out.
Parse transforms in Elixir have been deprecated, instead you should use macros.
In other words, no. :P
Good to know. I'm looking on it right now, looks like parse transforms were more reliable for AST transformations. Macros should be called explicitly, as I understand, when `parse_transform` can be called implicitly. I mean, macros is nice if you wanna do like some sort of code generation, but you can't really transform AST on the fly. That's the bummer. Gotta check if Mix can run scripts around compilation process and have access to AST.
&gt; macros is nice if you wanna do like some sort of code generation, but you can't really transform AST on the fly I do not quite get what you mean by that. Even Joe mentioned that ‚Äúmacros are parse transforms done good‚Äù. So could you give example where you think parse transforms are better?
Hot code swapping would not be useful for me in the context of Kubernetes. Are there any other reasons to consider distillery?
From what I hear distillery is useful for non-hot upgrades too, I'm looking forward to it since I'm liable to treat my elixir deployments like pets and not cattle
I don't understand what you mean. Would you be able to provide me an example? I'm new to Elixir but experienced with Kubernetes and Swarm.
Nice tutorial
Of course. For explanation's sake, let's imagine that we have a task: we wanna make some sort of "debug mode" for our application, so if we have key `debug` set to `true`, we wanna make all functions in all our modules are public(exported). Otherwise we do nothing. So, for Erlang and parse\_transform it's easy. I'm not gonna write fully working code, but I make some comments to understand how it will work: -module(debug_transform). -export([parse_transform/2]). parse_transform(Forms, _Options) -&gt; % note that we need handle debug flag somehow % I'll left it for now, there is a lot of options % basically scan AST and find all function tuples, return list with name and arity NewExports = lists:map(extract_functions/1, Forms), % and now we modify AST lists:map(fun(N) -&gt; modify_exports(N, NewExports) end, Forms). extract_functions({function, _, FunctionName, Arity, _}) -&gt; {FunctionName, Arity}; extract_functions(Form) -&gt; Form. % be advised: if there is multiple exports, that will cause issues % but I'm not gonna deal with that for now modify_exports({attribute, Line, export, Exports}, NewExports) -&gt; {attribute, Line, export, NewExports}; modify_exports(Form, _) -&gt; Form. And now just use that transform module in compile directives to inject it to all our modules. Now, what if we wanna do something like that in Elixir. Initially I said there is no way to modify AST on the fly for Elixir, I was kinda wrong. You can probably do something like that defmacro defmodule_debug(name, do: block) do expanded = Macro.expand(name, __CALLER__) quote do defmodule unquote(expanded) do % process AST like it was in Erlang unquote(block) end end end But as you can see, despite that we defined such macro, we can't automatically inject it into all our code. We of course can make search and replace, but it's really uncool. I prefer when computer works for me, not when I work for the computer. That's why I said macro are explicit and transforms can be implicit, that's the difference which can play sometimes.
Ignoring the fact that this is bad idea in Elixir you can do: if debug?(), do: @compile [:export_all] And achieve the same thing.
Hello, Nice article, but you should mention that map keys can be anything, that is a huge difference from JS.
Agreed. But it was just an example, and you still have to write that in each module, if you wanna affect multiple modules.
+1 I also think it would make more sense to show the `%{key =&gt; value}` syntax, after which you can mention that `%{key: value}` is simply syntactic sugar for `%{:key =&gt; value}`. The syntax seems less "magic" that way.
I have noticed that if you have stuff in your database prior to the test, it might wind up in your tests.
The ones I hear the most about are: * https://docs.newrelic.com/docs/agents/open-source-licensed-agents/elixir-open-source-agent * https://appsignal.com/elixir/ * https://docs.scoutapm.com/#elixir-agent I have no hands on experience with any of them though (we use statsd).
Check out [EEF Observability WG](https://github.com/erlef/eef-observability-wg). Currently the main forces are focused on Telemetry and OpenCensus/OpenTelemetry.
We are using ScoutAPM in our Elixir (with and without Phoenix), Ruby and Python applications. With the database module you can spot N+1 queries and so on.
If you are willing to pay, Datadog is a great service. I have heard good things about Prometheus as an open source alternative.
Thanks for the feedback, both of you. I'll incorporate it and flesh out the article a bit more!
using rust to scale to a tenth what erlang does
Oh probably if you're using kubernes you're good. We can't use docker for reasons
Done!
Another point I'd like to make, javascript actually has a construct that's almost identical, the spread operator (or Object.assign). It would look like this: a = {foo: 42} b = a b = {...b, foo: 5} b // now b is reassigned and bound to {foo: 5} a.foo // still equals 42
If there ends up being a recording, I'd love to see the presentation. :)
We use datadog across our stack at work, so I also use it for our lone elixir application. Here's the hex package we use: [https://hex.pm/packages/dogstatsde](https://hex.pm/packages/dogstatsde) Also made a quick wrapper module so I can define custom datadog-related methods, and I find it just as "easy" doing the same work in node/rails applications. That being said, I find dd's dashboard to be...a little more involved to setup. YMMV though. Like u/m0nstr42 said, it costs $$.
Is it free?
Hey everyone! ‚ÄãLiveView doesn't support JavaScript interop at the moment (but it's a planned feature), so in this article we see how to come up with a workaround to make LiveView playing together with a JavaScript library like Select2. We see how to take advantage of *‚Äãphx:update*‚Äã events, which LiveView dispatches every time it updates the DOM. Then we see how to send events to the server using *‚ÄãliveSocket.*
yep!
Do you have link to the discussion about js interop?
I think it comes from this issue: [https://github.com/phoenixframework/phoenix_live_view/issues/81](https://github.com/phoenixframework/phoenix_live_view/issues/81)
I have no idea who is Missy Eliot and what she has to do with Elixir.
I need more of these posts in my life
Step one: State that on an internet forum
Hi! Yes, I'm adding some resources to the article. I've seen the JS interop topic discussed in different threads and in different ways but unfortunately I didn't find a main open issue on the GitHub repo. I think that when JS interop will be properly discussed will be in the [phoenix-core mailing list](https://groups.google.com/forum/#!forum/phoenix-core), [#liveview slack channel](https://elixir-slackin.herokuapp.com/) and [elixirforum.com](https://www.elixirforum.com)
Hi! Yes, I'm adding some resources to the article. I've seen the JS interop topic discussed in different threads and in different ways but unfortunately I didn't find a main open issue on the GitHub repo. I think that when JS interop will be properly discussed will be in the [phoenix-core mailing list](https://groups.google.com/forum/#!forum/phoenix-core), [#liveview slack channel](https://elixir-slackin.herokuapp.com/) and [elixirforum.com](https://www.elixirforum.com)
I think this is another example of why liveview is not an idea that can work. I dont see you avoiding javascript anymore so whats the point?
It's almost as if it's a joke.
I love it.
[https://www.youtube.com/watch?v=cjIvu7e6Wq8](https://www.youtube.com/watch?v=cjIvu7e6Wq8)
And just to give u/majorius a little more context: [There's a related XKCD joke](https://xkcd.com/153/) And it's also not unheard of for there to be a similarly-related exercise/homework assignment for introductory programming classes at universities. I had such an assignment in my assembly class that was taught by a graduate student.
I guess treating the js as an API with a wrapper layer vs writing a js app
Don‚Äôt you need parens on those piped functions? That‚Äôs like if missy Elliot forgot to wear her hoops.
Well.. can't *really avoid* JavaScript when doing web apps, but the lesser JS you have write the better!
Ha! Good one
I think that LiveView it's great and another tool in our belt. To me the point is not avoiding JavaScript, but it's the speed we get developing realtime apps. It's easier to just think about the view we want to render, instead of having to build APIs, make calls with JS to get the data and make changes on the page. Consider that LiveView is in beta and there are still a lot of features to be developed.
You don‚Äôt need them if you don‚Äôt have any additional arguments ;)
This is awesome!
@wigflip did you create this?
This has made our day.
I did :)
It's so cool! Do you mind if we borrow your idea and extend it to other artists?
Ah gee thanks guys ‚ô•Ô∏è
Of course not! I'd love to help!
Nice hack!
Thank you üòä
Programming in Elixir by Dave Thomas. LearnElixir.tv (learnphoenix.tv also) Elixirsips.com
[https://elixirschool.com/en/](https://elixirschool.com/en/)
Elixir in Action by Sasa Juric was better for me than Dave Thomas's Programming Elixir. Simply because I felt Programming Elixir was more of a general overview of the language whereas Elixir in Action was about the real world reasons of what makes the language interesting.
Elixir Programming by Dave Thomas and The Little Elixir &amp; OTP Guidebook are essentials.
if you have access to pluralsight there is a video on there where the creator of elixir goes through the language features on there. I found it very helpful to understand why elixir is different than everything else.
Best thing ever learned from was dave thomas elixir for programmers. literally 10/10
Second this, I thought I know Elixir decently until I read this and learned how much more you can do with it in the real world.
I hope to learn Elixir in the near future, but work in JavaScript (React+Redux) and Python. I am curious as to what the salary range is for this position. &amp;#x200B; For others, if anyone cares to respond, why do you love Elixir? What do you think the top selling points are?
&gt;What resources do you like? What is well written? \+1
I had read Programming Elixir and thought that's enough, but this comment sold me on Elixir in Action. Thanks man!
Loved the rung analogy. Even if I am present with a solution, I will see it as an inconvenience unless I've encountered the problem myself. For those solutions that are on step 5 to 7, you probably won't encounter more than once, even then you probably wont enough it again with enough frequency to justify the complexity of the elegant solution.
I kind of feel a job advert without a clear salary range is a smell. Just be upfront. You'll miss some, you'll hit others and worst case you'll figure out what the market thinks of your salary range. I love Elixir for the documentation, the fact that it compiles and the functional nature. OO to me is always wonderjng what sonething should look like, vs what should happen. So I prefer functional. I used to do ruby. In terms of syntax and feel, its very very similar, but I feel like I get smarter every day coding Elixir.
I have to disagree on the last two here. In 2016, when I was learning, I attempted to use those resources and they were *extremely* out of date. More than half the tutorials I looked at on Elixirsips didn't even compile on Elixir 1.0 and later. We're at 1.9 now and the site has been frozen in time. The poor supply of up to date resources is *the entire reason* I started [Alchemist Camp](https://alchemist.camp) first as just a YouTube channel a year and a half ago. Dave's book is great, though.
If your primary interest is in learning Phoenix and you want a quick start, then I recommend this sequence of books: - **Phoenix in Action** (Manning): It teaches Elixir basics in the first few chapters - **Programming Elixir** (Pragprog): Very thorough book on Elixir, very accessible beginner but most newbies struggle to finish it if it's their first book - **Programming Phoenix** (Pragprog): By the creator of the framework, great book, must already be comfortable with Elixir - **Elixir in Action** or **The Little Elixir &amp; OTP Guidebook** (both Manning): Great, in depth guides to OTP and distributed apps. Screencasts: - [Alchemist Camp](https://alchemist.camp): My site, so I'm a bit biased, but it's got the most free videos by far, and it focuses on project-based learning. - [ElixirCasts](https://elixircasts.io): Short, fast videos, focused on features of the language and using specific libraries. You'll have to pause to keep up! - [The Coding Gnome](https://codestool.coding-gnome.com/courses/elixir-for-programmers): A fixed-size course, but a great one. References: - [The official docs](https://elixir-lang.org/docs.html): Seriously, they're good enough that after a while you won't need anything else! - [Elixir School](https://elixirschool.com/en/): Lots and lots of text-based guides! **AVOID:** - **Elixirsips**: Way out of date, code in many if not most lessons won't compile - **Elixir course on Udemy**: Very tedious, the author's JS courses are great but he's not to focused on Elixir, the course is still in Phoenix 1.2 - Anything Elixir focused made before 2017 or anything Phoenix-focused that isn't at least v. 1.3
I have to disagree on the last two here, especially Elixirsips. In 2016, when I was learning, I attempted to use those resources and they were extremely out of date. More than half the tutorials I looked at on Elixirsips didn't even compile on Elixir 1.0 and later. We're at 1.9 now and the site has been frozen in time. The poor supply of up to date resources is the entire reason I started Alchemist Camp first as just a YouTube channel a year and a half ago. Dave's book is great, though.
I think they're both great, but they're definitely of different styles.
The AVOID section is highly appreciated.
Usually we use \`\[ \]\` for time and dates, \`/\` for regexes and \`( )\` for strings/words. To my knowledge there are no differences in the result.
Thanks for the awesome reply. Does the little elixir and OTP guidebook still hold up with modern elixir?
Yes. Any no breaking changes have been added to Elixir since v1.0. There have been additions to the language, but the OTP guidebook's code should be fine.
Awesome podcast, thanks! It was mentioned that there is an Enumeration.map function in witchcraft that runs concurrently. Is there somewhere I can go to learn more about this? I‚Äôm really interested in some of these ideas but don‚Äôt know where to start!
Yes. No breaking changes have been added to Elixir since v1.0. There have been additions to the language, but the OTP guidebook's code should be fine (though pre-standardized code formatting).
There is no difference. I usually pick one that does not appear on the string itself, to avoid escaping. Which one does not really matter.
Watched a few Alchemist Camp clips. Very nice!
Doesn't Ecto make N+1 queries impossible since you can't access a relation you don't explicitly preload? Am I missing something?
Thanks for your replies, however I still sorry to that fact. I think that we already know what would happen to the ecosystem without the best practice([there's more than one way to do it](https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it)). I understand that the elixir is a relatively young language than others yet and thus there is no convention. Nonetheless, it's already problematic to use multiple delimiters as the same purpose. Someone uses parentheses for making a string, some doc uses just slash for making a string, and someone uses whatever which isn't in the string. &amp;#x200B; the riskiness of the fact that there's more than one way to do it. I'll skip it. &amp;#x200B; p.s. I'm an Asian student who is learning English, so I might have used wrong grammar in here ;p. Or please forgive me and let me know, if there are some rude expression in my question. Thanks!
Can you copy your config.exs file contents here in a comment? It sounds like you haven't put a line in there to set up the configuration for the endpoint module.
Thanks. I noticed that the content of \`config.exs\` in the book is different from the one generated by mix on my laptop. When I was adding the line to set up Phoenix to use Jason, I was assuming that these two lines in the book: use Mix.Config import\_config "../apps/\*/config/config.exs" equals \`import Config\` in the original config, so I didn't include them.
You are right ;) He also said he is expieranced developer. So I guess changelog and history of language is piece of cake ;). Personally I like to read about changes in languages. Anyway getting start with up to date resources is much easier and comfortable.
Looks like it‚Äôs running on port 80?
Only the first line of those would equal that.
Multiple function heads are just idiomatic erlang and elixir, it‚Äôs not TDD that‚Äôs driving you in that direction.
I feel like it is, though. Pattern matching is so powerful that often the least amount of code to get a test to pass just making a new function head to handle that case. From there a recursive solution practically writes itself. If I hadn't gone through TDD, I probably would have written the second solution using zip/2 and all?/2 If TDD is putting me towards idiomatic elixir, then I won't complain. I just wasn't sure if this sort of style was preferred over one that resulted in fewer lines of code.
What if you changed the order that you created the tests? Would you have ended up with the same solution?
I think so. It would have been a bit more complicated to get there, though. Generally, I start with the most basic, easy versions of the problem and test those, then move on to the progressively more complicated version of the problems. What this actually ends up doing is making me create the base-cases for the recursive function to terminate, and then when I get to the meaty parts of the problem (actually determining if non-trivial lists are equal or unequal), it's a simple of calling the function recursively and then hitting one of the base cases.
&gt; However, it is a lot more code than something like... But it does much less stuf. Your second code involves the Enumerable protocol, creation of tuples, an anonymous function, etc. To me your first code is way better. That being said, this code is enough: ``` def equal?([], []), do: true def equal?([h | t1], [h | t2]), do: equal?(t1, t2) def equal?(_, _), do: false ``` So TDD prevented you to find the simplest code. To get this result with TDD I think that you should build the habitude to start to crate a function with the default case : `def equal?(_, _), do: false` I know that is is not 100% TDD approved because you should only write the code that makes your tests pass, but that is a good rule of thumb.
I was going to reply with the same thing. The answer to this problem is just 3 function heads.
Remember that the final step in the TDD cycle is refactor. If, after getting the test to pass you think of a better implementation that still passes the tests, then you should move to it. TDD shouldn't hold you back, but instead give you the confidence to change your code in the way you want. In my opinion the multiple function head example you gave is more readable. When reading Elixir code I tend to find reasoning over a few function heads is easier than a block of code. Especially when the common case is also one of the base cases.
The last step of each TDD cycle is to refactor your code. Once you have it working and your tests all pass you should feel free to go back and edit the implementation into whatever form you want safe in the knowledge that since you have worked through it slowly flushing out your tests to cover all possibilities you won't accidentally overlook something in your more complicated one version does everything implementation. Now, in a trivial case like this it is fine to write a single unit test that checks all the possibilities then jump straight to the final implementation. If the problem is well defined and clear in your head you only really waste time by writing a simple version to later throw out. So here I would probably write a single unit test with a bunch of asserts and refutes and then jump straight to the overall implementation. If your unit test is so trivial as to basically be testing a language intrinsic (as in the first case where you are just testing that builtin pattern matching works) then it is probably too trivial an amount of functionality to merit its own unit test.
There‚Äôs nothing stopping you from refactoring as you go. One of the many benefits of tests is safe refactoring.
That seems like a great way to go about it. There have been a number of times where I've had to write something like: def foo([], _list), do: false def foo(_list, []), do: false and it's always felt clunky to me. def foo(_, _), do: false is so much better.
That config path would suggest an umbrella application structure (the apps/ folder). Are you using an umbrella project?
Even change logs were tough since the author didn't put dates, which language version was used on posts and the videos were self-hosted so there was no YouTube/Vimeo/etc date to look at. I literally had no idea which version of Elixir I was looking at in any given tutorial or how many tutorials I needed to skip to get to one that was post 1.0!
This is an umbrella app, so it needs to include the config from outside the Phoenix app itself! That's what the bottom line is for.
Anytime you see `use` or `using`, that means you're using a macro. It's very common to do this in Phoenix, Ecto and other frameworks to bring in functionality for a controller, a router, a schema, etc... This one brings in functionality to make the module act like a config file. This project is an umbrella app, so it needs to include the config from outside the Phoenix app itself! That's what the bottom line is for.
Look at your code and take it beyond simple conciseness for human readability. Consider how easy your pattern matching code is to optimize. Every place where ‚Äòequals?/2‚Äô Appears can be optimized down to a simple true/false value. Have you compared the ASM output of both to see which variant is most optimizable or if there is a difference? Your style is my preferred style whether I TDD or not. It promotes purity.
Which version of Elixir are you running? My bet is you are using 1.9 that was released a few weeks ago‚Ä¶ It changes a little the way configuration are managed/handled now that OTP releases are built-in mix. Phoenix was adapted so the generators are following the new configuration, which differs from the one from the book. Now, let‚Äôs work on what is causing your project not to start with a ‚Äúvanilla‚Äù configuration‚Ä¶ Could you share your `config/config.exs` and `config/dev.exs` files?
Thank you. I replaced the generated `config/config.exs` with the one from the book and it worked. In the latest generated `config.exs`, there's only one line: `import Config` The one from the book has access to `import_config`, which I don't know how to access with the generated version.
I just checked the beginning and: - you do not need to change binary to charlist, you can pattern match on binaries - you can use `?x` to get Unicode code of the character (it will make tokeniser clearer as not everyone know ASCII by heart)
Minor suggestion to improve the experience for readers : provide links to things in your requirements. Otherwise it's an interesting read, thanks for sharing üòä
Thank you for the advice
Another thing - use private functions and keep public API as terse as possible. This will not only improve the usability but also can improve performance (as compiler can inline calls). Also you can split it into Lexer, Parser, Interpreter, and REPL modules to make codebase clearer. BTW are you aware of [LFE](https://lfe.io)?
Yes, I know about LFE. I wrote my Lisp to change my mood. It is a toy program and there is no practicality.
Great way to learn Elixir. In addition to Brian Hauleth's comments, I'd just suggest this: `iex(1)&gt; :nil == nil` `true` So you don't really need to use `:nil` since it's already equivalent to `nil` and the latter is clearer.
dang i just bought this book, you sayin i'll run into this too? lol
You suppose to do multiple function and your function should be hella small. The TDD version is the better one.
The primary difference between a list and a tuple is a tuple is an ordered collection of fixed length, and a list is an ordered collection of variable length. I would not assume all elements in a list are usually the same type. The easier example I can think of would be an iodata list, which can contain integers, binaries, and lists of iodata.
Thank you for the advice
I tend to think about the layout in memory and resulting performance implications, but don't disagree with anything you said!
Yup yup. I'm now realizing I focused more on "tuple vs list", not "Elixir lists vs Elixir tuples".
This book doesn't seem to be written for people completely new to the framework.
can't I sign up with google or github or fb ???
I haven't yet implemented full tracking of users by our tech overlords ;) It is on the [list of requested features](https://alchemist.camp/requests), though and if enough people who currently have accounts vote it up, I'll implement it.
I have recently put together a list of resources for the next step on your journey - production deployment. You can chat it out at [https://www.bobek.cz/blog/2019/elixir-resources/](https://www.bobek.cz/blog/2019/elixir-resources/)
I improved the code.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_elbrujohalcon] [\[Podcast\] ElixirMix 60 - Property-Based Testing, Dialyzer, &amp; Inaka with Brujo Benavides](https://www.reddit.com/r/u_elbrujohalcon/comments/cdzojg/podcast_elixirmix_60_propertybased_testing/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Best javascript is no javascript
BeSt jaVaScriPt iS nO jAvasCriPt
hey thanks for asking this question, I'm learning elixir myself; I'm not a junior software dev, but new to elixir all the same. I'm typically a question vampire when it comes to questions like this. So your timing is great :)
Et jaacrit i n jvasrit ? Sounds Goa'uld.
Haha no problem, I've just finished elixir in action and done a ton of Katas to get familiar with the syntax. I then moved on to pheonix but if you want a reccomendation from me read up on plug and echo first as the abstractions Phoenix makes just confused me without any prior knowledge of those 2 libs.
This. I think of it as: &amp;#x200B; * Step 1: Test creation and code spike. * Step 2: Refactor given the complete test framework. &amp;#x200B; That second step is important as it usually helps to reduce the cruft of designing on the fly.
Unironically though, LiveView is great
The reason the developers added several sigil types is to reduce the need for escape characters. With double quotes, representing, say, a json file, would require a lot of escape characters. Like so: " \"greeting\" : \"hi\" ". So we have alternatives. But no matter the sigil, we might find ourselves in a domain that uses that symbol a lot. So we have choices.
&gt;So TDD prevented you to find the simplest code It did not. the TDD cycle is: add a little test, see it fail, make it pass, refactor. If some of those heads turn out to be redundant, delete them! A good sign that you are really refactoring and not just pushing the code into a different shape is that you got to delete some now redundant code.
TDD is: 1. add a little test 2. see it fail 3. make it pass 4. refactor 5. go to 1 Having found the solution with multiple heads (which is idiomatic in functional languages with pattern matching anyway) you are free to refactor to any other solution that improves on some figure of merit that you are interested in but still passes all the tests. &amp;#x200B; In this case, the solution with multiple heads has the merit that it is \_obviously\_ correct, which is a very good thing in code. The one that has zips and lambdas over triples and what not requires some thought to understand. Code is read much more than it is written, make code easy to read.
The `with` construct is pretty versatile. You don't only have to use it in the way that you described. You can also do some pretty complex processing with it, like this, to handle the individual errors in the patterns you provide: ``` defmodule WithTest do def do_something do with {:ok, result1} &lt;- do_something_else(), {:ok, result2} &lt;- do_another_thing(), {:ok, result3} &lt;- do_final_thing() do IO.puts("result 1: #{result1} result 2: #{result2} result 3: #{result3}") else {:error, reason} -&gt; IO.puts("error reason: #{reason}") :bad_response -&gt; IO.puts("oops, I was given a bad response") end end defp do_something_else do {:ok, "first result"} end defp do_another_thing do {:ok, "second result"} # {:error, "intentional failure"} end defp do_final_thing do # {:ok, "third result"} :bad_response end end WithTest.do_something() ```
Yes thank you for your reply. First I just wanted to avoid to repeat the {:error, reason} returns, but effectively it can be great to match latter specific and individual error
First I heard about render, and it looks pretty great. Seriously thinking about putting a few projects on it to test it out. Elixir on Heroku isn't terribly grand, you don't get access to a lot of the nice things OTP provides. Mnesia, for example, is crippled as the nodes cannot connect. I have yet to try them on Gigalixir, but they claim to support "all of elixir." I see from your docs that you have libcluster/distillery support, but how does this compare to Gigalixir's ability to use things like Mnesia or Remote Observers?
Literally struggled with this two days ago and solved it yesterday. Thanks for the write-up!!
you could say they had a pipe dream
Thanks for writing up. Really a nice Doc for Deploying Elixir using Mix Release.
You need to have a `Rule` for each thing you wish to parse. A `Definition` without a `Rule` does nothing.
Haha! This will speed up that screencast on Render I promised üòé
ü§û Also, Mix Releases and clustering: [https://render.com/docs/deploy-elixir-cluster](https://render.com/docs/deploy-elixir-cluster)
I think this is fine TDD using red green refactor. You need to write a test that fails so that you can make it pass and confirm the test isn't false positive
&gt; Another approach could be to use a pool of worker and dispatch / load balance across thel using for instance Poolboy. But it will require a significant number of worker to handle effectively the load of queries. FWIW, that's usually the preferred approach. I would give it a try and benchmark to have an idea on how many workers would be effectively necessary.
In this post, I introduce my first Elixir library, Verbalex, and showcase an example of how it can be used. You can find the package here: [https://hex.pm/packages/verbalex](https://hex.pm/packages/verbalex)
The code snippets used in this article result in the regex being built at runtime rather than at compile time (like the \`r\` sigil does). I would expect this to result in a significant performance penalty- have you benchmarked this approach?
Is upgrading an individual project's elixir version as simple as updating the version in \`mix.exs\` and then seeing if anything broke?
Great point. I hadn't considered that tbh. I'll look at doing some benchmarking soon with this and some different approaches and report back. Thanks!
So as an alternative, I provided \`email\_expr\` as a module attribute with the value \`&amp;Test.email\_expr/0\` so it was evaluated at compile time. I then returned \`@email\_regex\` from a function to include it in Benchee's results just for the side-by-side comparison (I haven't done any benchmarking before but I'm assuming comparing a compiled result to a running function is relatively pointless): Operating System: macOS CPU Information: Intel(R) Core(TM) i7-8850H CPU @ 2.60GHz Number of Available Cores: 12 Available memory: 32 GB Elixir 1.9.0 Erlang 22.0.7 Benchmark suite executing with the following configuration: warmup: 2 s time: 10 s memory time: 2 s parallel: 1 inputs: none specified Estimated total run time: 28 s Benchmarking Module attr... Benchmarking Standard function call... Name ips average deviation median 99th % Module attribute 7.81 M 0.128 Œºs ¬±294.93% 0 Œºs 1 Œºs Standard function call 0.21 M 4.69 Œºs ¬±602.85% 4 Œºs 7 Œºs Comparison: Module attribute 7.81 M Standard function call 0.21 M - 36.64x slower +4.56 Œºs Memory usage statistics: Name Memory usage Module attr 0 KB Standard function call 1.68 KB - ‚àû x memory usage +1.68 KB This definitely makes me re-evaluate how the documentation and this blog post directs people to use Verbalex. I'll note this in an amendment to both. ‚úåÔ∏è
Implement a simple board game or card game you like. One of my first projects was making multiplayer Skip-Bo in Phoenix. It forced me to learn about GenServers, process registries, supervisors, and clustering!
It‚Äôs not too hard to use a macro to evaluate it at compile time (assuming you have nothing dynamic going on in your regex generation, which is generally a good idea anyways). I don‚Äôt think there‚Äôs anything that would stop evaluating this and emitting an r-sigil in its place. If you‚Äôre unfamiliar, you might look at the way that that Logger eliminates debug-level call sites at compile time to get an idea how it works. It‚Äôs all macros (that call some functions). Maybe start here and work your way through: https://github.com/elixir-lang/elixir/blob/master/lib/logger/lib/logger.ex#L797
Hey thanks! I'll definitely look into this.
thanks! &amp;#x200B; I'm looking for something that does not involve phoenix or any other framework.
Sure! I just built the user interface using Phoenix and some JS, but the game logic itself was vanilla Elixir and OTP. You could totally do it on the command line or something like that.
How Elixir taught me to write better (insert pretty much any common language here) fixed
&gt; it's already problematic to use multiple delimiters as the same purpose How is it already problematic? I have never heard of this being a problem. If anything, it seems less problematic because it prevents hard-to-read escaping. Also, they are well documented... &gt; the riskiness of the fact that there's more than one way to do it What is the risk? I don't see it. No matter which delimiter you use, the code will be compiled the same. There is ZERO risk as to which delimiter you use. &gt; we already know what would happen to the ecosystem without the best practice(...link to "There's more than one way to do it" with Perl examples...) I guess I'm in the "more that one way to do it camp". For example, I like the fact that Perl, Ruby, and Elixir have the "unless ..." keyword. Yes, I could use "if not ...", but it's nice to have multiple options that can make my code easier to read and understand ‚Äî and to me, that's a good "best practice". Here is how they are explained in the official guide: &gt; Sigils support 8 different delimiters: &gt; ~r/hello/ &gt; ~r|hello| &gt; ~r"hello" &gt; ~r'hello' &gt; ~r(hello) &gt; ~r[hello] &gt; ~r{hello} &gt; ~r&lt;hello&gt; &gt; The reason behind supporting different delimiters is to provide a way to write literals without escaped delimiters. For example, a regular expression with forward slashes like ~r(^https?://) reads arguably better than ~r/^https?:\/\//. Similarly, if the regular expression has forward slashes and capturing groups (that use ()), you may then choose double quotes instead of parentheses.
A classic Erlang / OTP practice project would be a chat server and / or client. Once you‚Äôre done getting messaging between two clients working you can expand it with other features like channels, etc
OK, first I really appreciate your opinion and if my reply seems to disparage elixir, I would be sorry about that. And I know that each delimiter is needed in the different contexts as you said. I thought of [delimiter like c++](https://en.cppreference.com/w/cpp/language/string_literal), but on second thoughts, it still has an arbitrary delimiter. So my initial thought was wrong and now multiple sigils quite make sense to me. &amp;#x200B; &amp;#x200B; By the way, I'm learning [this part](https://elixirschool.com/en/lessons/advanced/behaviours/) now
One idea, something I regularly need: a library to periodically pull data from an HTTP source. This is a pattern I often need to use, such as: \- [Wax](https://github.com/tanguilp/wax): retrieving metadata \- [oauth2\_metadata\_updater](https://github.com/tanguilp/oauth2_metadata_updater): retrieving metadata and keys &amp;#x200B; The process is simple: download from source -&gt; call callback function to process data -&gt; set timeout to fetch again later &amp;#x200B; Could be really useful. Sounds easy, but it might not be. Features related to OTP: \- use of Supervisor / DynamicSupervisor \- use of GenServer, Task, etc. \- error management at all steps (let it crash or not?) \- local vs. global registration (in a cluster, you might want to have a unique updater). See the [Singleton](https://github.com/arjan/singleton) library Not related to OTP: backoff mechanism, HTTP client authentication, timeout strategies, \`use\`
I'm learning Elixir as well. I've gone through a couple of books, and right now I'm going through the tutorial at https://codestool.coding-gnome.com/courses/elixir-for-programmers I still need a lot of practice, especially with using OTP.
You can run mix phx.new my_app ‚Äîumbrella, and everything will be done for you for free
worked!! Thank you.
Game of life.
Yup! You'll of course also need to update the elixir version in your environment.
anything you could build with Phoenix, you could also build without Phoenix with a little more effort.
Thank you very much. I will think to consider that
Or is the unix socket is an alternative to communicate with port or through temporary files?
what is a chat server?? i have built dummy chat app with nodejs. is chat server and chat app the same thing but different terminology?
More or less. When talking about a chat server, it is specifically the server that would be interesting in this context (getting a deeper knowledge of Elixir and OTP). The client is less interesting when learning OTP. You could just use telnet for the client.
No. The version in your `mix.exs` is actually what you are saying is the minimum version of Elixir you will run on. You will get a warning if the version of Elixir you are using is actually lower than that number. As an example, if some library said `elixir: "~&gt; 1.8"` and you were running Elixir 1.7, it would give a warning when compiling about a potential issue. In order to actually see if anything breaks you would have to install the version of Elixir that you wanted to run on and run your tests or manually go through your application (I would suggest having a good test suite though).
The main difference is that when you use Port then BEAM is managing the process ran as a Port receiver. In case of UNIX socket the additional process need to be managed by the end user themselves. Also there is also another alternative - named pipes, which will work similarly to UNIX socket (aka the other process is need to be handled externally) while using standard IO interface.
Thanks, I will look at it
Looks nice! Definitely going to check out common test now.
I think the general consensus is on using asdf version manager. Find it at [https://github.com/asdf-vm/asdf](https://github.com/asdf-vm/asdf)
If you are advantageous then you can check out Nix package manager. It is more complicated than ASDF (which I would call ‚Äúentry level‚Äù) but provide much more power to the user.
Definitely this
Definitely asdf.
I suspect there will be little or no difference from a performance perspective. The one issue you might run into is that stdout gets buffered in some languages so you might find yourself needing to manually flush the output buffer to make sure messages get send immediately. Under the hood in practice there isn't really such a thing as a bidirectional stream, anywhere you see that it usually means the API has taken care of opening seperate input and output streams for you. I recently took a python program that I was rewriting in elixir and started by getting it working as a port in Elixir. The Python program has a websocket port which was used for communications, I gradually transitioned to just using the port for communications entirely (eliminating the websocket) before gradually factoring away the python program itself piece by piece. At no point did I notice any difference in performance between either method of communication (in all cases everything was running on a single PC so there was no actual networking involved). My guess is that unless your program is highly IO constrained then you won't notice a difference and it would be a toss up as to which would be better or worse. Interprocess communication on unix via stdin/stdout is very highly performant. A huge amount of the operating systems tools are built around being able to rapidly pipe input and output between processes so you can be sure it is about as fast as it can be.
The only thing I like better with `kiex` is that I can goto definition on core Elixir functions with `ElixirLS`. It seems that `asdf` doesn't compile Elixir from source.
Will give this a shot!
My top 3 1. docker: put version in Dockerfile then volume your project working dirs in compose. 1 way to rule them all from dev to build pipeline to production (if you don't care about native horizontal/vertical OTP supported scaling) 2. Exenv then mix release (packages erts) in your build pipeline 3. ASDF version. Manager, same mix release as step 2.
DDD is definitely a struggle for people who come from MVC and a Rails background. [I wrote about bounded contexts and structuring your apps](https://userinterfacing.com/how-to-improve-on-naming-contexts-in-domain-driven-design/) a little while ago which made it onto the Elixir Radar newsletter. Was definitely an eye-opener once I finally figured it out.
Wow this is a brilliant idea!
Great! That'd be really cool if you published it open-source. &amp;#x200B; Feel free to use [https://elixirforum.com/](https://elixirforum.com/) for some help (on design, etc.) or PM me for more idea sharing!