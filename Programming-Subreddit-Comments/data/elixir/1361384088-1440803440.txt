Does elixir have the equivalent of gem or bundler? Also another crazy question. Would something like this https://github.com/mojombo/erlectricity and/or https://github.com/KirinDave/fuzed help the ruby developer ease into Elixir?
elixir comes with "mix" which is the equivelent of a gemfile. So a mix.exs file contains something like: defp deps do [ { :ranch, %r(.*), github: "extend/ranch" }, { :cowboy, %r(.*), github: "extend/cowboy" } ] end then running "mix deps.get" goes and gets them. You can find some packages here: [cean](http://cean.process-one.net/packages/) but someone may know of a better one edit: formatting
There is also EXPM: http://expm.co/
I don't think you're going to have a good time if you try to write imperative/object-oriented Ruby code in Elixir. Elixir requires a different way of thinking and it's most likely best to get into that mindset as early as possible. This means that getting things done with Elixir will be somewhat slow at first as you shift your way of thinking to a more functional one and get familiar with the Elixir and Erlang API surface, but it will ultimately pay off. I would probably have said "yes" if Elixir was object-oriented or just generally imperative, but since Ruby and Elixir are based on two very different paradigms, I'm not convinced it's a good idea.
A fun functional algorithm for matrix transposition is to cons the heads of each row with the (recursively) transposed tails of each row. In haskell, this looks like: transpose ([]:_) = [] transpose x = (map head x) : transpose (map tail x) A (non-TCR) Elixir version would be: def transpose([[]|_]), do: [] def transpose(m), do: [ (lc [h|_] inlist m, do: h) | transpose(lc [_|t] inlist m, do: t) ] This does show the somewhat inelegant list comprehension syntax, albeit in a very contrived setting. There certainly might be a more elegant version in Elixir though. A TCR version of this algorithm is left as an exercise for the reader because I am lazy. Edit: Jose Valim pointed me to the `hd` and `tl` functions from `Kernel` (and originally from Erlang), which I was looking for but didn't find. They allow a version that is more similar to the Haskell version: def transpose([[]|_]), do: [] def transpose(m), do: [ Enum.map(m, hd(&amp;1)) | transpose Enum.map(m, tl(&amp;1))]
The tutorial steps ask me to do certain things, but it moves on to the next step regardless of what I've done. The first page asks me to do "8+4" but if I type "jkaslhfjkdhasfl" it still progresses. Just a heads up. Lookin good elsewise!
It should be working now.
This is very much appreciated. Thank you kindly for your hard work!
I'm about a third of the way through this book. So far it's amazing! The chapter on concurrency is available online for free. Even if you don't read the book, you should read that chapter, it's really awesome and along with the screencast, it's enough to get you up and running.
&gt; Something like: &gt; &gt; def fibonnaci(n) do &gt; when n == 0, do: 0 &gt; when n == 1, do: 1 &gt; when n &gt; 1 do &gt; fibonnaci(n - 2) + fibonnaci(n - 1) &gt; end &gt; end &gt; &gt; I'm sure there are great reasons why we can't do this in Elixir, but I still sort of wish we could. You can get pretty close with `case` or `cond`: defmodule Fib do def fib(n) when n &lt; 0, do: 0 # degenerate case def fib(0), do: 0 # base case def fib(1), do: 1 # base case def fib(n), do: fib(n - 2) + fib(n - 1) # default case def fib_case(n) do # `case` is similar to `switch/case` in C. in this example, # you can think of each match expression on the left of `-&gt;` # as prefixed with "n == ". so "n == 0 -&gt; ...". this is why # we need the additional `when` guard on the degenerate case. # so `case` evaluates it's expression and passes the result to # each match expression, and when the match is successful, it # evaluates the body on the right of `-&gt;`. case n do _ when n &lt; 0 -&gt; 0 0 -&gt; 0 1 -&gt; 1 _ -&gt; fib_case(n - 2) + fib_case(n - 1) end end def fib_cond(n) do # `cond` is like an if/else if/.../else in C. it evaluates # each match expression, and on the first "truthy" # (non-false and non-nil) match, evauluates the # body cond do n &lt; 0 -&gt; 0 n == 0 -&gt; 0 n == 1 -&gt; 1 n -&gt; fib_cond(n - 2) + fib_cond(n - 1) end end end I prefer multiple function bodies with the match in the formal paramaters, personally. NB: The simple recursive fib functions are not able to be tail-call optimized, since the last call is an addition operation on the result of calling themselves resursively. All the recursive calls have to be evaluated before the first result is returned, then the same for the next value, etc. This also means the stack grows with every recursive call and you'll eventually run out of space. In the fib example in particular, we're re-calculating fib for the same n on both sides of the addition, for all n &gt; 1. A tail-call version can be written with a helper function, so that the final call in every recursion ends with a call to the same function, and then the compiler/vm can use the same stack frame for every call and just update the stack variables with the new values passed in from the recursive call. It also calculates the fib of every n only once. def fib_tco(n) when n &lt; 0, do: 0 def fib_tco(n), do: do_fib(0, 1, n) defp do_fib(accum, _, 0), do: accum # base case defp do_fib(accum, next, counter) do do_fib(accum + next, accum, counter - 1) end There's a good discussion of this in SICP: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2
[Changelog](https://github.com/elixir-lang/elixir/blob/master/CHANGELOG.md#v0102-2013-09-03).
(Resubmission because the URL changed (blog engine change) and it's not possible to update the URL in Reddit)
The Scala syntax is effectively a form of do-notation tailored to collections (i.e. the list monad) rather than IO like in Haskell. Is this going to be a general form of monad notation or will it stay confined to just streams?
I'm planning to extend it to monad notation (see todo list in README file), but there is no obvious way how to perform it in Elixir, cause there is no generic "monad" or "functor" protocol in language. Streams were easy to do cause of Enumerable protocol which works the same way for any enumerable (collection or stream).
Not sure if you've seen these already, but there's a few existing attempts to implement monads in Elixir that you might be able to reference: * [nickmeharry/elixir-monad](https://github.com/nickmeharry/elixir-monad) * [yrashk/xonad](https://github.com/yrashk/xonad) * [sasa1977/monadic](https://github.com/sasa1977/monadic) (looks to be most complete at a cursory glance) Disclaimer: I have yet to learn how monads work myself, so I have no idea how generically applicable the aforementioned libraries actually are. 
I saw all of these libraries. And anyone looks like robust basement for moving on. Unfortunately.
Stream comprehensions are in the pipeline btw: https://github.com/elixir-lang/elixir/issues/1684#issuecomment-23783983
Are you planning a midweek or Saturday meeting?
Sorry for late answer :) First of all thank you for feedback, we continue developing and have now many new features, like HTML generators and etc... About blog, interesting thing, i'm web developer but never seen my blog from Chrome :) Will fix it. Thank you.
Please let me know how I could make things more clear or anything you'd like to see in following parts. Thanks!
This is a great introduction! In future articles it would be neat to see common Ruby patterns and their idiomatic Elixir counterparts.
Oh, hey, cake day!
The Homebrew formula isn't written to install a particular Erlang version. I don't know the reason, but you could ask them
It used to, then it didn't, and then it did again if it couldn't find Erlang, but that didn't work well, then some users complained, and now it doesn't again. Erlang isn't a trivial install :( Installing from Homebrew on my 2013 Mac Book Air it took 10+ some minutes, which is like forever ಠ_ಠ Installing a binary from something like erlang-solutions.com (https://www.erlang-solutions.com/downloads/download-erlang-otp) was really quick. It makes sense sure, but it's more desirable to detect an existing Erlang first and only install it if not. 
I did run homebrew on erlang and elixir, and both seem to install fine...just need to test it :). EDIT: yes, installing Erlang was slow...but the point is that if languages want to succeed, they should have an installer that you double-click and boom it works. Anything more than this, and you dissuade people (even an eclectic language like Elixir whose users are likely to be a brighter bunch).
Any feedback on this is greatly appreciated :)
I have an unrelated question. What terminal emulator and/or shell utilities are you using for those colors?
I'm using gnome-terminal with default color profile, and tmux. My dotfiles are available at http://github.com/knewter/dotfiles. This is just vim inside of tmux, with a very mildly customized tmux configuration. I'd be glad to answer any more questions around this :)
I'm really hoping that Elixir gets to 1.0 and the syntax gets stabilized. I don't mind Erlang's syntax, but I do mind its having lack of metaprogramming, lack of custom types, and other warts like records (not as good as real dictionaries) and lack of a first-class string type. But because Erlang's basically a concurrent fault-tolerant OS on top of your OS for making programs, there's nothing else out there that compares and so it was worth dealing with those annoyances. But if Elixir alleviates those problems and gains traction as a language, I'll be happy. I do wonder though, can Elixir automatically *ensure* that Erlang understands strings, or will things like logging still sometimes see lists of integers? Will Elixir add to its standard library better versions of some of the Erlang libraries? P.S. I noticed this was posted yesterday but the trolls came out and demonstrated their ignorance, as usual. I guess only Erlang programmers would understand why this may be a big deal and isn't just another experimental syntactic sugar language. When combined with Erlang/OTP, you get macros + concurrency + fault-tolerance + management of external subprocesses + distribution/network-transparency. I also program Lisp, but while Lisp is great at metaprogramming, it sucks at concurrency and fault-tolerance. Elixir's features all put together could make it the ultimate server-side language... if only its syntax stabilizes and it gains traction.
This is my first Elixir project and it was a lot of fun. I needed this for a rewrite of an IRC bot I'm running at my company, and there wasn't any good libs out there. I don't know how useful this will be to anyone, but feedback, bugs, etc are all very welcome!
Thanks for this lib, I'll surely be using it in my Elixir IRC bot. :) I assume I can launch N client processes at will? How does it handle multiple charsets?
Yeah, I'm really excited for 1.0 of elixir.
 mix weber.new /home/ch4s3/testWebApp ** (Mix) The task weber.new could not be found I'm not sure what I'm doing wrong here.
I'l try that out. I keep getting hung up on weber, but I'm sure some reading will sort it out.
I' digging into that after I finish finals, OTP seems really cool. Thanks For the input! 
Thanks!
Yea, the Programming Elixir beta book is pretty good. I am also a Ruby guy learning Elixir so from that standpoint it does a pretty good job. It's still a mind trip switching your thinking around :)
Site doesn't play nicely with Safari 6.0.5. If the author of the site reads, might want to take a look at your CSS there. 
Woot. Love to see stuff keep moving forward :) Onward and upward...
I think you have to run that from the directory into which you cloned the weber repo.
Ahh, that may be my mistake. I'll try that later. Thanks!
w00t
I tried reading through [Learn You Some Erlang](http://learnyousomeerlang.com), but doing the exercises in Elixir. [It](https://github.com/john2x/learn-you-some-elixir-exercises) went quite well. I stopped when it got to the OTP parts, as it was getting harder to translate. But now I can more or less read both (simple) Erlang and Elixir code. Whatever path you take, you won't regret learning either. They'll open your mind. 
Beauty is in the eye of the beholder, sometimes anyway.
This is also how I got to grips with elixir, although I would say the OTP parts are the most important thing to learn about erlang/elixir - it's one of the main selling points of the erlang/otp platform
Oh yeah definitely. Unfortunately for Erlang/Elixir/OTP, unless the problem domain you're working on specifically fit their paradigm, then they don't offer any definite advantage over other languages I like/interested in. So I stopped with just enough knowledge for in case I do find myself in a situation where OTP would be a good solution so I can much more easily jump in. I'll probably still continue when I'm bored and have nothing else better to do/learn. 
Awesome
Hey, really great set of examples. I appreciate the comments throughout. I'm curious about the choice to prefix some function names with a _. I get that those are the recursive looping cases for a function, but I'm not sure it fits with the elixir convention of having _var_name as ignored variables. If Jose or someone advocates this by all means correct me! Also, you may want to run through and do a check for the new sigil syntax per https://github.com/elixir-lang/elixir/commit/2af50f7b78342986c4c504eddb9f7047208c2592 Great stuff though, definitely learned some things!
Thanks. Pretty sure I saw the `_foo` style in Dave Thomas' _Programming Elixir_ book, but indeed it doesn't seem to be too common in the top Elixir projects. I just downloaded the top 12 trending Elixir projects from GitHub and ran `ack "def _[a-z]"` -- I found only one instance [in Amrita](https://github.com/josephwilk/amrita/blob/master/lib/amrita/checkers/messages.ex#L21).
Slight correction: I fixed my regex to be `ack defp? _[a-z]` and found a couple more instances: * [Weber](https://github.com/0xAX/weber/blob/master/lib/weber/helper/html_helper.ex#L51) * [Dynamo](https://github.com/dynamo/dynamo/blob/master/examples/simple_ecto/lib/simple_dynamo.ex#L67) But yeah, still not very common :-) I'll change my code to use the `do_foo` style. Thanks guys!
The approach in this gist should reduce the duplication of macros you have going on. I didn't verify that this compiled, so you may have to tweak it if my quote/unquote logic is off (I'm working off memory, so..). This approach is something I've used before though: https://gist.github.com/bitwalker/8967032
No problem!
What makes it realtime ?
loving the elixir content coming out of Neo
Going through your sips right now. Only on #7 but wanted to say well done. Great personal style, short and to the point, videos + .md files are a nice touch and I'm looking forward to the rest of the series. 
yea worth noting that you can still use :gen_fsm in your elixir apps. OTP isn't deprecating it or anything.
So I wrote this mostly for my company, to try and introduce everyone there to what Elixir is and why I keep talking about it. I don't know if you all will find this useful, and I know for sure it could be better, but I figured I would post it here in case you know someone that would like a quick intro and background into Elixir. If you have suggestions, fixes, etc. I'm open. I had to seriously limit myself, otherwise the post would've been waaaay too long, so I'm sure you'll think of something I left out. I'd rather not miss something critical though, so please do let me know if you think I've failed the community in some way :p.
Well, the thing is that I like both a lot and I probably place more emphasis than I should on knowing the platform before I begin to know the language (e.g. know enough about the JDK before starting Clojure). And on top of the principle, I really like Erlang, and it seems like there are some fundamentals of it that might make Elixir easier or at the very least recognizable.
So if I keep doing what I'm doing (doing LYSE and Introducing Erlang) and maybe build a few things in Erlang, would that be enough of a basis for starting Elixir?
&gt; Well, the thing is that I like both a lot and I probably place more emphasis than I should on knowing the platform before I begin to know the language (e.g. know enough about the JDK before starting Clojure). Elixir will still make you learn the platform. In fact, there is a policy of not having modules in the Elixir standard library that do nothing but wrap Erlang modules. Elixir also still encourages you to follow the OTP principles and to build your applications with the standard OTP behaviors such as `application`, `supervisor`, `gen_server`, etc. &gt; And on top of the principle, I really like Erlang, and it seems like there are some fundamentals of it that might make Elixir easier or at the very least recognizable. What do you have in mind?
&gt; understanding immutability, let-it-die semantics, general OTP principles Well, I see no reason why you couldn't learn these principles in Elixir, too. IMHO if there's something preventing you from doing so, we have failed in some way and we need to do something about it. I know Dave Thomas's Programming Elixir book goes into all of the above.
I don't have anything specific in mind. I just assumed that if I'm going to learn both, it should be in the order of less to more syntactic sugar.
Elixir is built on the same VM which Erlang uses and the best reason to use Elixir is to take advantage of the advantages this VM has in building distributed, fault-tolerant applications. Harnessing this power is a task people have been working on for a while and a lot of lessons have been learned, but because Elixir is still new, there isn't much written at an advanced level in Elixir. Being able to at least translate between the two is invaluable in order to have access to these writings. However, a primary reason Elixir exists is to fill in some of the potholes Erlang is effectively stuck with. For example, if you have to interact with strings in any significant way, Elixir is much more friendly than Erlang. Erlang libraries don't harness the power of metaprogramming to nearly the extent that Elixir libraries do, which may or may not suit you. I would recommend learning with Elixir, but recognizing that from time to time, being able to read Erlang (at least for now) can be helpful. They aren't all that different and most of the time the difference is that the Erlang version requires that you write out all of the boiler-plate where Elixir wraps that up in a convenient macro.
Some of core Erlang is exposed to Elixir but a lot of it is hidden behind pleasant syntax and powerful macros. This is a really good thing IMHO, but you will understand OTP a lot better via Erlang than through Elixir. The Elixir team is still trying to figure out their relationship to OTP and how much of it they want to expose. IMHO, once you start to get into OTP from the Elixir side you are basically using the Erlang docs and guides to do your digging and knowing Erlang is beneficial at this point.
Yes. To be honest I think that Elixir is a more "fun" language and I am really enjoying it but I also think that it helps to have some understanding of Erlang. At the very least you are more likely than not going to be interacting with various Erlang modules and packages to do a lot of the heavy lifting and it will help you to be able to read the code, understand the structure and grok the Erlang APIs.
You may be interested in my current project, a full release manager for Elixir: http://github.com/bitwalker/exrm
Oh, didn't know yet. Sounds promising, will have a look later.
Nice talk. This was one the features that got me interested in Elixir. 
As a Ruby dev and someone who dabbles in Clojure I totally agree that it's awesome.
You could always post the job here. That works well on /r/haskell, which is also kind of a small community.
Gaslight would also love to talk to you about what kind of help you're looking for. There are several of us here that are excited about Elixir and would be interested in seeing how we could help and maybe just talk about what you're doing. Shoot us an email hello at gaslight dot co 
One idea that I've thought about is if you think of Elixir Processes as Objects. They have internal state and methods to change or report on that state. 
My questions would be more the other way round: Where as an Elixir-interested developer can I find a company which is also interested in building applications with Elixir? This is because I think there are more devs trying this language than companies using it.
Iteration/looping (or anything that deals with collections/list/sequences) is probably the most jarring difference between procedural and functional programming. That, and state management. Just things to look out for I guess. Things you'll find yourself having to think twice about while you're trying out functional programming. 
I sent an email there. However we're hiring, not looking for a third party solutions provider. I'm also interested in seeing how we might be able to help each other.
If you're interested in building an elixir application and are able to relocate to Vancouver, message me!
We have purchased ads for several of these subreddits, let's see what happens!
Sorry for the delayed response. I appreciate the suggestions. I've been working with Elixir for about 10 days now, it's going pretty well ;).
Everyone is welcome to come by. The meetup is informal and held in a pub so it is also a great opportunity to have beer and a chat :)
What are you looking to get out of this adventure in the short-term? Your choices so far are not bad, but you can probably compress it slightly: clojure is a lisp so you are going to find that a lot of what you learn there will translate directly when you decide to play with a real lisp, julia is really only interesting if you are going to be doing lots of math and scientific computation (and if you are then none of the other languages on your list are appropriate and you should focus on Julia.) At this point there is really not a lot to recommend Ruby unless you are interested in doing a rails app or doing devops using chef, so drop it from the list. Now you have Elixir and Clojure, two of my favorite languages. If being on the Java VM and being able to plug into that ecosystem is of value to you then go with Clojure, otherwise give Elixir a try. Either way, in six months go and give the other language a try for a month or so. You will not be disappointed with either.
Interesting fact: Erlang/Elixir processes actually *are* objects if we go by Alan Kay's original definition! In that way, these languages are more object-oriented than any other mainstream language.
Yes, Elixir will definitely help there. To be honest it is probably better at this task than its Erlang roots as most of the leading devs are reformed Ruby/Rails folks. If you are familiar with Rails then look at weber and phoenix. The options are not quite as well developed as in Clojure, nor has there been the same degree of community convergence (e.g. in clojure almost everyone will be using ring/compojure) but the current options seem reasonably solid. The only reason I would potentially suggest you not build such a site in either elixir or clojure is that these are somewhat esoteric choices and so you need to be prepared to be this person's webdev and support person in perpetuity if you make this choice...
Technically, I think Clojure is a lisp1 and not a lisp2, so it is a 'real' scheme but not a 'real' lisp if you were to ask a purist on c.l.l ;)
I have to agree with Evgen on this; if you just want to build a website for a small business, there are far easier things to do than to try to teach yourself to develop software. I'd look at WordPress for something like that.
Yes, once more I have to agree with you.. I stand corrected. Thanks for the clarification
So after studying Elixir for roughly a month, I must say I'm really digging it ;). The concept of matching vs. assignment took some getting used to. I'd like to start to play around with Web Frameworks a bit. Can anyone recommend which? There seem to be a few which are popular (which is a good thing).
&gt;...julia is really only interesting if you are going to be doing lots of math and scientific computation (and if you are then none of the other languages on your list are appropriate and you should focus on Julia.) Can you expand on this a bit? I have a general idea of what makes Julia suited for scientific computing, but what makes Elixir unsuited for it?
Weber looks interesting.
I'm starting to get really excited about Phoenix. I'm hoping that views get fleshed out soon, but if it's anything like sockets, it'll be worth the time spent planning them.
It sounds like we could see views as early as ElixirConf!
That was fast. I'm excited about `xgen` in 13.3.
For this kind of task you also could have a look for Racket-Lang with an excellent FFI, Place, Futures and Math Library
I misused the term parallel computation, I believe. For the things I'm aiming for, concurrency is the term I wanted. Things like kNN and ensembles can take serious advantage of concurrency. Thank you for your input, I'll definitely take a look at Julia. But I'll try my hand at using Elixir for it. If you want, I'll let you know what I come up with. 
Hi all, Just wanted to post up the latest things happening with Sugar. Here's the changelog for the recent updates: **v0.4.0-dev - current master** - [Enhancement] Add view layer with EEx, DTL (thanks to ErlyDTL), and Haml (thanks to Calliope) engines - [Dependency] Add sugar-framework/templates back in **v0.3.0 - released 15 May 2014** - [Enhancement] Upgrade to Elixir v0.13.2 - [Dependency] Add sugar-framework/plugs back in - [Enhancement] Remove mix.lock from repository to improve dependency management in projects - [Enhancement] Add Unit tests to increase coverage from ~5% to ~96% - [Enhancement] Add Controller hooks for before/after actions - [Enhancement] Add Router filters for before/after calling matched route I'm still working on fully updating the docs site, but progress can be watched at http://sugar-framework.github.io/. Thanks!
Machine learning applications like kNN are where Julia really shines. John Myles White, who wrote Machine Learning for Hackers (O'Reilly book on ML that used R) actually switched from R to Julia and is now a core developer on the language. It is a pretty impressive system. There are several good implementations of various ML algorithms for Julia already, including the ANN package for Artificial Neural Networks.
Server Game Developer Job location - Cupertino, CA Are you willing to sponsor relocation? - Yes Is telecommute an option? - Not ideal Education or certification requirements. - C.S Degree preferred How/where should developers apply? - Email: mnagoya@quarkgames.com Company Website: http://www.quarkgames.com About the job: Quark Games was established in 2008 with the mission to create hardcore games for the mobile and tablet platforms. By focusing on making high quality, innovative, and engaging games, we aim to redefine mobile and tablet gaming as it exists today. We seek to gather a group of individuals who are ambitious but humble professionals who are relentless in their pursuit of learning and sharing knowledge. We're looking for people who share our passion for games, aren’t afraid to try new and different things, and inspire and push each other to personal and professional success. As a Server Game Developer, you’ll be responsible for implementing server related game features. You’ll be working closely with the server team to create scalable infrastructure as well as the client team for feature integration. You’ll have to break out of your toolset to push boundaries on technology to deliver the most robust back end to our users. What you’ll do every day: Develop and maintain features and systems necessary for the game Collaborate with team members to create and manage scalable architecture Work closely with Client developers on feature integration Solve real time problems at a large scale Evaluate new technologies and products What you can bring to the role: Ability to get stuff done Desire to learn new technologies and design patterns Care about creating readable, reusable, well documented, and clean code Passion for designing and building systems to scale Excitement for building and playing games Bonus points for: Experience with a functional language (Erlang, Elixir, Haskell, Scala, Julia, Rust, etc..) Experience with a concurrent language (Erlang, Elixir, Clojure, Go, Scala, etc..) Being a polyglot programmer and having experience with a wide range of languages (Ruby, C#, and Objective-C) Experience with database integration and management for NoSQL systems (Riak, Couchbase, Redis, etc...) Experience with server operations, deployment, and with tools such as Chef or Puppet Experience with system administration
This is such a big release I think it almost justifies a minor number. I'm really excited about `xgen`.
Is there a roadmap to version 1?
Are you going to do an Elixir Sips on this?
I don't really know how to do a good one on the hardware hacking bits tbh. I've tried to figure it out and never felt comfortable with the results
We're hiring Elixir developers at my company in Austin, TX. We're developing really exciting new software for the auto insurance industry. Everyday we tackle interesting problems as the technology arm of a very successful insurance provider. If you're not afraid of being a "full-stack" developer (http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/) then you would have a lot of fun here. We have a lot of projects in the pipeline and just had the first of many very successful demos of our product. Come be a part of the shakeup of a very old and crufty industry with 5 other Alchemists. Technologies our stack includes: Elixir, Ember.js, Couchbase, ElasticSearch, Logstash, CoreOS, Docker, and more. Email: devin.torres@clutchanalytics.com
This is a pretty good example of the "We should be killing languages off" vs Choice Is Good schism that came up on one Mostly Erlang episode. It might even have been the one about Elixir.
This is awesome, thanks for this. It really helped me understanding Elixir macros. :)
Hi and thanks for kind words! I'm glad you found the series helpful, and hope you'll enjoy the rest of it as well :-)
I liked the post, nice and simple. Apart from some formatting issues, I have a few technical comments: * Keep an eye for Elixir 0.14.1 in which all escript-related options will be moved under a single :escript key in mix.exs. See this PR -- https://github.com/elixir-lang/elixir/pull/2409. * I would suggest using the :strict key in OptionParser. Calling OptionParser.parse(args) is deceptively easy, but it yields some weird command-line experience. Using :strict is more useful in practice. * This is merely a suggestion: perhaps you could briefly describe how to implement a custom mix task. It seems to be more useful in short term than general-purpose CLI apps.
Cool beans! The presentation is excellent, makes it all look very simple. And it actually is! If you open the video in VLC and set playback speed to around x0.25, it'll be almost as if you were pair-programming with Josh :)
Awesome post! As someone who loves both Elixir and Ruby I really love this kind of material.
Im a big haml fan, so I'll definitely support it.
I have been threatening to write something similar in part to replace having to deal with Jekyll.
Am I the only one who feels that Rails shouldn't be the go-to ideal of web frameworks to imitate with Elixir? I feel that nowadays there's a much bigger pool of ideas to draw from, and some of the idiosyncrasies of Rails are not that great on hindsight. In particular I think there's much simpler controller architectures that are not as dependent on DSLs and expressing layout and view concerns in them, and use far less magic without being less expressive. I would say that, given the possibilities of errors that implicit DSL magic introduce, it would be best to be as explicit as possible to maintain reliability.
Rails got a lot more right than it got wrong. The goals of Phoenix is not to imitate Rails, but some of our decisions are borrowed from my Rails experience. I would love to hear your ideas for an ideal web framework as we're in the process of overhauling the controller layer. Controllers are just plugs (from the Plug library). My goals are very much to make the data flow explicit, which plug does a good job of. With respect to DSLs, I'm of the strong opinion that we can build robust and reliable programs with careful use of macros, so I will have to disagree there. Feel free to share your ideas here or on #elixir-lang IRC and I'll give them serious thought. :)
Release link: https://github.com/elixir-lang/elixir/releases/tag/v0.14.3
That's a much better overview. I'll use that in the future.
Could a similar project have been undertaken with Clojure on the JVM or with Haskell? I'm trying to figure out what Erlang/Clojure/Haskell can easily do that the other two easily can't. Useful library support and adequate documentation seems to be the Achilles heel of Haskell. But what about the inherent advantage(s) of each language in tackling these projects requiring concurrency, parallelism, distributed processes, etc. Are the three languages (consider Elixir as part of Erlang with benefits) more or less equivalent?
Erlang and Elixir are, at least in my opinion, superior choices for concurrent and distributed programming. I haven't been able to find anything in Haskell that would support code reloading in the same fashion that the BEAM (Erlang VM) does, nor anything that enables as fine-grained fault tolerance as Erlang has without requiring you to write very defensive code. From what I gather, Haskell's preemptive scheduling is also somewhat unfair compared to BEAM's, and it only has thread-local GC (that is, OS threads) rather than per-spark. I'm not sure how well Cloud Haskell works. From a cursory glance, it seems pretty neat and seems to display good performance. I think you'd still run into some of the issues above, though. I think Clojure (or the JVM in general) is in an unfortunate position: Implementing lightweight threads as a library within a virtual machine is almost never a great idea. My experience has always been that it leads to inferior performance compared to supporting lightweight threads directly in the virtual machine. Then there's the whole issue of accidental state sharing that both Erlang and Haskell simply prevent. I will say this, though: For local parallelism, I'm fairly confident Haskell and Clojure would outperform Erlang. You can certainly do parallel programming in Erlang, but it's really designed to deal in concurrency, and [keep in mind that these two terms mean different things](http://www.haskell.org/haskellwiki/Parallelism_vs._Concurrency).
Thank you!
Videos forthcoming? Btw I vote that Witcher franchise be hired as the marketing face and advertising campaign for Elixir. Let's have all sorts of Elixir metaphors, abstractions, modules, tools, frameworks, etc based on Witcher universe iconography.
From what I understand, videos will be available in 2-3 weeks here: http://www.confreaks.com/events/elixirconf2014
We're hiring Elixir developers at my company in Austin, TX. We're developing really exciting new software for the insurance industry. Everyday we tackle interesting problems as the technology arm of a very successful insurance provider. If you're not afraid of being a "full-stack" developer (http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/) then you would have a lot of fun here. We have a lot of projects in the pipeline and just had the first of many successful unveilings of our current product. Come be a part of the shakeup of a very old and crufty industry with other Alchemists. Technologies our stack includes: Elixir, Ember.js, Couchbase and more. We're currently looking for local Alchemists or Alchemists willing to relocate (which we sponsor). Email: devin.torres@clutchanalytics.com 
Not frozen but really slushy. :-)
grats!
Great talk. I'd like to see an expanded blog post on the Elixir Resque worker.
In this slide, what was the problem that your TcpSupervisor would crash/restart https://speakerdeck.com/jeetkundoug/elixir-and-the-internet-of-things-handling-a-stampede?slide=20 Is that because you did not pick the correct restart strategy?
Sweet. Looking forward to the MEAP.
100+ attendees, that's very cool.
Just a bump here to let everyone know the rest of the pictures went up today. The set is complete, up to the final panel of the weekend.
Great pictures.
The subject of the talk was changed, hence the incorrect title on Confreaks.
As a rubyist starting to learn Elixir it's a bit surprising to see him comparing against Ruby 1.8.7 which [exited normal maintenance in June 2012](https://www.ruby-lang.org/en/news/2011/10/06/plans-for-1-8-7/) and stopped receiving security fixes a year later. I don't think later versions would get particularly closer performance wise though :-)
Don't be that Cobol guy.
"Revolution" is one notch too enthusiastic, but we'll see more of languages like Elixir, I'm sure. 
If you want to say "P&amp;M's" then you can also add Piping.
This is a great question. I would love to hear the opinions of some of the more experienced Erlang'ers. I'm currently working through [Erlang and OTP in Action] (http://www.amazon.com/Erlang-OTP-Action-Martin-Logan/dp/1933988789) myself.
You might need to learn the syntax of erlang first. - Learn you some erlang - programming erlang by joe armstrong - erlang programming
I second this. I've found it to be useful. I started with Programming Elixir, then moved on to Programming Erlang, and now I'm reading through that one. The first one teaches you Elixir concepts, the second has more info on techniques for programming effectively on BEAM, and the third one seems (so far) to have the most info on leveraging OTP.
We are hiring Elixir developers at Hammer &amp; Chisel (hammerandchisel.com) to work on a AAA mobile game (fatesforever.com) that is already live and has been even featured by Apple multiple times. We have quite a few things implemented in Elixir already including our game server curation service, presence system and more. The job is in the SF Bay Area and we pay relocation. We don't allow telecommuting. No education required. If you are interested in high quality games and distributed systems feel free to email me at stanislav@hammerandchisel.com
You should probably give people some background: * Who are you? What do you do? * For what purpose are you doing this survey? * Why do you need names and email addresses? People will probably be more inclined to respond if such questions are answered.
I don't mean to sound like a tin foil hat, but why is my email mandatory? Is it not an anonymous survey?
I answered this above, if you want to read it. It was a good question. Sorry if I goofed.
Thanks for the clarification!
Just me in the comments for now -- Elixir deserves incredible libraries, and I'd like Neotomex to be one of those. At the moment it has some cool features like the ExGrammar interface for specifying a grammar and transforms, and prunable expressions. Past that, I'd love feedback and ideas! Some of my own: - Grammars that directly output Elixir AST, generating a program - Perhaps an even more "string-less" interface, similar to Java's parboiled (though I find it a little bit confusing) - https://github.com/sirthias/parboiled/blob/master/examples-scala/src/main/scala/org/parboiled/examples/calculators/SimpleCalculator1.scala - Named matches similar to neotoma - - Awesome error reporting
Turns out 0.2.0 has a build problem. 0.2.1 fixes that: https://github.com/alexrp/ex_parsec/releases/tag/v0.2.1
Yes. Ecto actually inspired by LINQ, according to Jose.
Cool, generating a standalone module is definitely possible down the road, through I honestly still don't know what the best approach is. The Netomex grammar data structure could be transformed into an Elixir AST, which I'm assuming could then be compiled right into a BEAM. Though, if performance is the goal, without a lot of tuning I'm not sure how much faster it will be: the current approach also outputs Erlang bytecode, though in more than one module. Other than removing a production dependency, are there other benefits? By string-less API do you mean how the expression is wrapped in a string? And, would you be envisioning something more like parboiled [linked to in grandfather post]? I have to admit, I would really like to kick around something like that. I built the current interface because I didn't want to go macro crazy, but I'd love to see what is possible. Opened an issue: https://github.com/jtmoulia/neotomex/issues/8
Man I kinda wish iex had a "-wex &lt;port&gt;" flag in it now. Looks great.
That's awesome!
It's perfect that it's showing your pic next to the title. Anyways great project name, and cool looking project.
This is more to warn people that it's really easy to make Elixir apps run on Heroku with the new "Heroku button"
I am a Canadian, so despite that photo being taken in Chicago, I would say that the photo is somewhat accurate. Thanks for the feedback!
Change log: https://github.com/phoenixframework/phoenix/blob/master/CHANGELOG.md#v040-2014-08-30
Awesome, glad to see constant forward progress!
Excited to bump deps!
Congratulations, guys.
We are looking for Elixir/Erlang developers to help us build a new decentralized communication platform. Basically we are building the next email. Company is based in London but we are flexible. Email: ryan@spatch.co
AWESOME work guys! 
Roughly now-ish: http://www.reddit.com/r/elixir/comments/2g5l8h/elixir_users_survey_2014_results/
Some interesting data in there. I would've thought that under the primary language, Erlang would've been higher. I guess the data would probably need to be normalized, so it will instead show the percentage of each languages entire community that is using Elixir. I also agree it would've been nice to see the reasons for why "it's complicated" as to whether Elixir is their favourite language or not. Since that might imply that it would be their favourite if it weren't certain aspects. The amount that want to use it in production is also really great to see. As that's really where a language will begin to take off. Not too mention Elixir is a primary candidate for production, as it's utilising the already production proven Erlang VM so there are less risks/reasons to stay away from it. And not too mention as a student it's also nice to see this, as getting a job using Elixir would be pretty cool. 
I love how straightforward the router specification is, and making versions central is super smart. I always get bitten by not versioning from the start and then having to do something awkward. Definitely would love to see being able to specify TLS preference as in the roadmap. Cool, I'll be looking for an excuse to use it. 
We're hiring Elixir developers! Our first product is a high quality image remixing and messaging engine. It is the first step in the launch of our full experiential guiding system that connects the internet of people, the internet of things and the internet of content for a human-centric emotive and intelligent society. Come be part of the next big thing, solve big problems around media and connectivity, be challenged and let your opinions shape our product. Positions: www.divaos.com Offices: Based in Jackson Hole, WY with offices in Tokyo, San Francisco and Cologne. Flexible vacation and remote work policy. Relocation and telecommute options can be discussed for right candidate. Photography, media and travel lovers a plus! Email: jobs@divaos.com
Super clean docs nice!
Thanks! Documentation is always important if you ever expect others to use your code :)
Basic HTTPS items landed in master tonight. [Have a look](https://github.com/slogsdon/placid#https), and let me know what you think.
Haha perfect, great kitchen sink example.
BLAME CAAANAADAAAAAAAA!
Awesome.
This video is a good segue for a question: About how much Erlang is [helpful -&gt; recommended -&gt; required] to grok Elixir? Anyone new to Elixir is *much* more likely (statistically) to be familiar with Ruby code over Erlang code. It seems to an outsider that Elixir *looks* like Ruby but really is masking Erlang DNA, just under the skin. So I would infer that learning you some Erlang for *some* good is something more like learning JavaScript to understand what CoffeeScript is actually doing than, say, learning Java to understand what Clojure is doing or learning C to understand what CPython is doing under the hood. In Elixir's case, the Erlang is hiding under a hood of plexiglass. Thoughts?
Once he stops talking about how bad the industry is and starts talking about physical limits of computation, this turns into a brilliant talk!
Actually, since Elixir has its own compiler that is straight to BEAM code it is far closer to Clojure and Java. CoffeeScript and JavaScript are useful to know together simply because CoffeeScript "compiles" into JavaScript and not byte code to run on all of the browser JavaScript VMs. Essentially, compile to bytecode and languages matter *less* but *do still matter*. Whereas if you are "compiling" to another language, you should really know both.
While it would be best to get a better understanding of it all. I'm not sure how required it really is. I think someone could get by without learning Erlang, possibly at the most they'd benefit from understanding a little of Erlang's syntax so they can incorporate any Erlang they want into their Elixir programs. But beyond that I don't think it's too necessary. Unless they'll be writing Erlang code. Like the same could almost be said for whether they'd need to learn about the inner workings of the VM. While it'd be beneficial, as they'd know how certain data types are handled, whether functions like :erlang.length/1 are cheap or expensive, understanding the Erlang assembler and core and beam, etc. It's not required. 
Some understanding of Erlang is helpful if you want to use erlang libraries, but otherwise Erlang *syntax* itself is not necessary. Two things however are helpful to understand and use Elixir efficiently: OTP and BEAM. OTP because that's what you use to structure fault-tolerant applications, and BEAM because that's the vm your code will most likely be running on. In that regard coming from an Erlang background is very helpful since you will already have thorough exposure to both OTP and BEAM. But it's absolutely not necessary to learn Erlang (the language) to understand these. I would however recommend studying Erlang if you struggle with some Elixir concepts like pattern matching, processes or the whole OTP thing. Being exposed to the same underlying concepts in a different way can be very helpful in understanding them.
Exactly! I feel that watching Erlang lectures helps me better understand Elixir *concepts*. Now just watched a Prolog lecture which helped me understand the choice of syntax (and pattern matching) in Erlang. This rabbit hole goes deep. I find a similar kinship in Ruby from SmallTalk, and even between Python and Haskell (scandalous). I'm likely to offend Python **and** Haskell camps with that comparison. But you can really see what was going on in the head of a new programming language designer, based on the concepts and/or syntax decisions they incorporated from a (then) contemporary language they knew.
In Dave Thomas' book, I believe he claims the Access protocol is going away. Is this true?
The closest to a course I know would be [Études for Elixir](http://chimera.labs.oreilly.com/books/1234000001642) and [http://exercism.io/](http://exercism.io/)
Oh that looks pretty cool, thank you!, for a moment I thought I had to practice my forgotten french 
This is certainly a step in the right direction (as I haven't come across a single other authentication tutorial for Phoenix), but I would be wary of using MD5 to store passwords. Someone needs to write a decent bcrypt/scrypt lib.
If I'm playing around with a language I don't bother with a VM. Better just setting it up on OSX using homebrew and mix.
I think I tried that, I have OSX mavericks, and if I remember correctly I was unable to install erlang or something like it
Do you use homebrew?
Have you checked brew itself is configured properly with `brew doctor`?
most definitely! 
I know half of those people (-:
does this help https://github.com/jveiga/vagrant-elixir
Then you should join us!
I moved to SF!
Couldn't agree more! As you read from the article introduction, this is a very naive approach. I'm newbie in this area, still learning all the stuff. That's why I started elixirdose in the first place. To force me write and learn. If you have ideas, suggestion or anything, don't hesitate to reach me. Thanks for your support!
Thanks! I try my best :)
"brew doctor" is your friend
Saving it for later, just today I was thinking on looking for a lisp written in elixir
Great work!
Thanks xiongxin8802, glad that you like it!
Correct URL http://learnelixir.com/blog/2014/10/23/image-upload-in-phoenix-web-app/
This is great, thank you so much for it!
You're welcome. If you find bugs or have some ideas just open an issue on github. :)
Read them all.
I read Dave Thomas book, and it was good. Scanned the ToC of "Introducing Elixir" and it also looks as a good option. You can download free chapters from both books and check which style you like more.
Yeah, it's my plan, but as a student with a limited budget, I like to make considerate choices about how to spend my money.
Cool. I think I'll go with Dave Thomas. I have already read one of his books and I like his writing. 
The details of erl flags concerning NUMA and such are here: http://erlang.org/doc/man/erl.html search for +sbt and below (this is at first glance).
Ah, I see. Then you can read a bit about Erlang in the online version of [Learn You Some Erlang for great good!](http://learnyousomeerlang.com). It will give you some good insights that you can use in Elixir as well. Other than that, read the inline documentation in the source code. Use the `h` function in iex to learn more about the various modules and functions (such as `h Stream` and `h Stream.unfold`, etc.). Digging into the Elixir core source code, and getting familiar with this will also help tons! Take a look at [the implementation of File](https://github.com/elixir-lang/elixir/blob/master/lib/elixir/lib/file.ex) for instance. Documentation as a first class citizen is kinda neat :)
There are a few options for books: http://www.manning.com/juric/ http://shop.oreilly.com/product/0636920030584.do?sortby=publicationDate https://pragprog.com/book/elixir/programming-elixir http://www.exotpbook.com/ (Actually all four of those books are on the http://elixir-lang.org/ website on the right side under "Learning Resources". Also look at the right side of the Reddit page here--it lists one more book which I had missed.) I've got a copy of Dave Thomas' book and I've seen Saša Jurić's stuff and I'd be hard pressed to recommend one of them over the other. They're both good books and I've gotten good ideas from both of them. Another good option (if you don't have your hard set on a book) is Elixir Sips: http://elixirsips.com/ 
Thanks for the link. The link however does not really mention two important details: * is it possible to explicitly set which NUMA node to bind to? Fo example I have another app bound to node 0 and I want an Elixir app to be bound to node 1 (to separate each of them) * it the "--localalloc" parameter enforced? For example, if I am using con_cache for a huge in-memory cache, will I be guaranteed that all of its memory will be bound by default to a specific NUMA node? 
Alchemist alone has made me give emacs with evil-mode a try and I'm enjoying it a lot thus far. Keep up the fantastic work!
Thats great to hear, thanks :-)
Is the [http://www.exotpbook.com](http://www.exotpbook.com/) book available yet? I can't find any way to view/purchase the book.
I don't think it is. I ended up writing the author yesterday to find out. I will post back, when/if I get an answer.
Self-promotion is absolutely okay when what it being promoted is free. And I am already going through the book, thanks.
It's possible to specify the timeout on assert_receive http://elixir-lang.org/docs/stable/ex_unit/ExUnit.Assertions.html#assert_receive/3 You can also just unit test the handle_call, handle_cast functions and have no timeouts at all. Just test the input/output according to the specified behaviour. On integration tests for async execution you will find timeouts and sleeps a common approach out there. P.S.: there's a typo "aysnchronously"
This is one of those slide decks that's totally useless without the rest of the talk. This actually means it's probably a good talk since the speaker knows not to just put everything on his slides then read from them.
I'm excited about seeing the recording! Does anyone know when they'll put it up?
Ohai, Ben here. Usually in 1 month's time. :)
Yeah, I guess the talk would be pretty good too. :X.
Saw this at Rubyconf, great talk. Now I'm learning Elixir on my free time!
Great to hear that! :) If you have question, just let me know.
Unfortunately it doesn't work for me :( All it completes is keywords from current file. Any ideas?
Did you update the to the 0.7.2 version, there was a bug in the company load sequence
Also you can follow @BostonElixir on the Twitters for all sorts of trouble.
I use version from melpa. Now I user 20141129.1201 (alchemist-version says 0.8.0) and no change.
Hi, Could you please open an issue on github and add the following informations: * which emacs version you have? run (emacs-version) * which company version you have? run (company-version) * which elixir version you have installed? run (shell-command) when prompt run "elixir --version" Thanks for reporting. Cheers Samuel
I've looked over both your implementation and Amazon's documentation and it appears that the signature does not match. What this means is that the signature you provided does not match the request signature amazon calculated. So if I were you I would check my signature. Do you have an AWS account? Did you create the key pairs? ["AWS does not provide key pairs for your account; you must create them."] (http://docs.aws.amazon.com/general/latest/gr/getting-aws-sec-creds.html) If all else fails try unplugging your Elixir Amazon Product Advertising Client, wait 5 seconds, and then try plugging it back in and see if it works then. 
I deduced that the signature does not match; the error message was explicit about that: &lt;Message&gt;The request signature we calculated does not match the signature you provided. Check your AWS Secret Access Key and signing method. Consult the service documentation for details.&lt;/Message&gt; The problem is that I don't know *why* the signature is incorrect. It appears to me that I've followed the instructions correctly, but the code is still not producing the correct signature. Do you notice anything about the code specifically that seems not to coincide with what the instructions require? I do have an AWS account, and I did [generate an access key ID and a secret access key](http://docs.aws.amazon.com/IAM/latest/UserGuide/ManagingCredentials.html#Using_CreateAccessKey). These values are stored in **/config/config.exs** (which is not checked into the repository for obvious reasons) and accessed in **/lib/amazon_product_advertising_client.ex** at lines [9](https://github.com/zachgarwood/elixir-amazon-product-advertising-client/blob/master/lib/amazon_product_advertising_client.ex#L9) and [30](https://github.com/zachgarwood/elixir-amazon-product-advertising-client/blob/master/lib/amazon_product_advertising_client.ex#L30), respectively.
I implemented request signing for my SimpleDB library which uses the same signature version (v2) as the API you're using. I'm on my iPad so I can't easily figure out what's different in your implementation, but I can confirm that this works: https://github.com/adamkittelson/simplex/blob/master/lib/simplex/request.ex#L45-L81 
Have you looked into using erl_cloud? https://github.com/gleber/erlcloud Even if you decide not to use it, you could look through their implementation of the signing process and compare it to your own.
Ah, thank you! I see my problem now. I was trying to use **:crypto.byte_to_integer** and then **Integer.to_string** before converting the hash to base 64, which appears to be completely unnecessary. Do you happen know if all of the Amazon APIs use the same procedure for signing requests? (I can't see why they wouldn't, but you never know.) If so, would you mind if I adapt your code to make a general Amazon API request signature generator module that could be used across various API clients?
There are (currently) two versions of request signing for AWS services, v2 which is what we implemented, and a newer v4. Some older services like SimpleDB only support v2 which is why I implemented that. Amazon recommends that services that support both versions use the newer v4 implementation. For example SQS supports v2 and v4 signatures, but if you sign with v2 the maximum request size is 64kb, with v4 you can go up to 256kb. It'd definitely be useful to have an AWS request signing library and if you want to adapt my code to make one I'd be totally fine with that. If you do it you'll probably want to have it implement both versions so users could select the one they need for the service they're targeting. The other thing you'd probably want your library to be able to do is fetch keys from the [metadata API](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html). Basically if you are running your library on an EC2 instance that was launched with an IAM Role that grants permissions to use a resource like the product advertising API or simpledb etc the instance has an internal API that can provide you with access keys that are periodically refreshed so you don't need to put them in a config file and try to keep that file secure by not putting it in source control etc. My simpledb library is handling the fetching of those values here: https://github.com/adamkittelson/simplex/blob/master/lib/simplex.ex#L59-L111 as a fallback if the user didn't already specify keys via a config or environment variable or something. When using the metadata API you also need the token in addition to the access key and secret access key so that's what's going on here: https://github.com/adamkittelson/simplex/blob/master/lib/simplex/request.ex#L70-L74 
You've been a great help, thank you!
From my understanding, you don't mutate the variable directly, it allocates a new variable to the heap when you reassign that variable, and uses a new variable in place of the old one. I imagine it simulates using a completely different variable from that point on.
To be a bit more specific, in Erlang (the original language for the VM Elixir runs on) everything was single-assignment immutable variables and Elixir is hiding a pattern Erlang programmers developed to work around this. In Erlang, if a=3 then that was what a was going to be its value for the duration of that variable's existence until it dropped out of scope and was garbage collected. This was useful at times (nothing changes after assignment or pattern match so it is easy to reason about what a function is doing) but also a bit cumbersome if you were doing multiple things to a variable or collection over the course executing a function. Code would often look like this: A=input, A1=do_something(A), A2=do_something_else(A1), A3=more_of_the_same(A2). This was a bit clunky and made refactoring more difficult than it needed to be. Elixir is doing this behind the scenes, but hiding it from the programmer via macros and code transforms performed by the compiler. 
Variables aren't the immutable thing. The data they point to is the immutable thing. That's why changing a variable is referred to as rebinding. You're point it at something else, not changing the thing it points to. x = 1 followed by x = 2 doesn't change the data stored in computer memory where the 1 was to a 2. It puts a 2 in a new place and points x at it. x is only accessible by one process at a time so this has no impact on concurrency and concurrency is the main place to even care if something is immutable anyway. Let's say you had a list l = [1, 2, 3] and you had another process that was taking lists and then performing "stuff" against them repeatedly and changing them during this process would be bad. You might send that list like... send(worker, {:dostuff, l}) Now, your next bit of code might want to update l with more values for further work that's unrelated to what that other process is doing. l = l ++ [4, 5, 6] Oh no, now that first process is going to have undefined behavior because you changed the list right? Wrong. That original list remains unchanged. What you really did was make a new list based on the old one and rebind l to that new list. The separate process never has access to l. The data l originally pointed at is unchanged and the other process (presumably, unless it ignored it) has its own separate reference to that original list. What matters is you can't share data across processes and then change it while another process is looking at it. In a language like Java where you have some mutable types (all primitive types plus references themselves) it would be possible to share a structure/object that contained say an int and change that int from one thread while another was reading it. In fact, it's possible to change a large integer type in java *partially* while it's read by another thread. Or at least, it used to be, not sure if they clamped that aspect of things down with the 64 bit transition. Anyway, point is, you can pull the rug out from under other processes/threads by changing data in a place that both are looking at simultaneously. That's not possible in Erlang and by extension Elixir. That's what immutability means here. 
http://natescottwest.com/elixir-for-rubyists-part-2/
Hm. Lots of upvotes, but no answers. :-/
Thanks! That example helped solidify it a lot. 
Ah, I think see why they did it. I was just thinking that instead of doing A=input, A1= .... you would break it up into different functions so they remained small, but perhaps that would result in function names like, "do_other_half_of_operation".
pretty much. or like a simulated rebind, and it just uses a different variable name in the background.
OTP provides the pool module out of the box, see http://www.erlang.org/doc/man/pool.html. It's not really a generic problem you can solve as far as I'm aware. I believe the easiest solution is to use https://hex.pm/packages/poolboy. There are also some good details in http://www.erlang-in-anger.com/ where it details different modules, solutions and when you would choose one over the other
Thank you for all the tips, I will definitely look into them. I recall encountering poolboy before when looking into Cassandra drivers for Erlang/Elixir.
Hi everyone, actually my goal was to play a little bit with elixir. However I'm a fan of nice tooling so I got a little bit distracted and ended up building this first ;) Here are some screenshots: (sorry they look huge because they were taken on a 4k screen) http://abload.de/img/1gqub6.png http://abload.de/img/2o6uj6.png http://abload.de/img/35qu3v.png http://abload.de/img/4cqucb.png I hope somebody else also finds this useful! Improvements are also welcome. Some things might not be optimal. I'm no experienced alchemist (yet), so I had to guess what could make sense. I tested it on windows and on mint and both works. However I can't test on OSX. On windows there's a problem with a non-terminating erlang process. I don't know yet if that's an elixir or brackets problem or a combination of both - this will need some more investigation. 
Hey, just one comment, you may want to do something like ``` do_to_base ``` instead of ```_to_base``` because ```_``` in elixir specifies that you're ignoring the value with variables, ie def foo(x) when is_integer(x) do: x def foo(_x) do: 0 # _x is ignored, you cannot say IO.puts _x As far as I've seen, the convention for when you have a public function that calls another private function to actually do the work, you use ```do_function_name```
Thanks, havvy
Thanks for this! I have OS X, and your work has convinced me to download `brackets.io` and check it out. I'll file any issues on the repo if there are incompatibilities I find. :) Thanks!
The plugin appears to be working well with OS X.. I'm a little confused by the Elixir REPL. Am I supposed to be able to type directly into the REPL? Or can I only execute code by highlighting text in the text editor and executing "Send selected text to REPL"?
Yes, of course you can also directly type into the REPL :) There's an input field at the bottom of the panel. The light grey thing you see in the first two screenshots. If it's not visible you might need to resize then panel. A question for you as an OSX user: When you shut down brackets are all erlang processes properly shut down too? When you have brackets open `ps aux | grep erl` should show 1 or 2 processes (depending whether you have a visible REPL open or not). After brackets is shut down they all should go away too.
Elixir doesn't complain in any way when underscores are prepended to function names, it only means something in pattern matching (no binding). Anyways, you're right that the convention is to prepend `do_` to the function name, I've seen it multiple times in open source projects and I like conventions, so I just pushed a "fix" to master :). Thanks for the feedback!
We're using readme.io, so we have no control over this, but if I hand rolled the site myself I guarantee it would be the same situation for the code snippet syntax highlighting. You can browse the raw markdown guides at https://github.com/lancehalvorsen/phoenix-guides which might have better luck with no js enabled.
It's also good to understand the distinction between "pure functional" (like Haskell) and "impure functional" (like Clojure, Scala, F#). Impure functional allows for mutable values for the simple reason that sometimes the fastest algorithms to solve certain problems are best implemented with some mutation. And, as others have pointed out, there's a difference between allowing mutability and defaulting to mutability. In imperative languages everything is mutable by default. In functional languages, everything is immutable by default. Impure functional languages allow you to mutate if you choose to.
Noob here. Why do you have to clone the repo and build it? Doesn't elixir have something like gems?
I use it together with the web framework Phoenix, building a hopefully new kind of chat experience. It's only a hobby project but it's certainly a lot of fun. The front end is JavaScript right now but it's easy to use the backend in a mobile app. 
I'm currently using it to write company-internal tools that easily take advantage of multi-core; I'm aiming to get company buy-in to write an intra-app message bus with it, too.
Learning and experimenting so far. I've built a backend game server, a bitcoin peer crawler, some ideas building off of _riak_core_, some real-time streaming experiments. Nothing in production yet though. I actually spent a decent amount of time experimenting with erlang's slave nodes and how to use them with Elixir (running code on remote hosts _without_ deploying any code to them). So much fantastic opportunity. Coming from a C# Networking and Ruby webserver background, I'm delightfully thrilled with Elixir so far.
Did you write any tools to help manage the remote-slave-nodes thing? Do you have any links to demos or other info? I think learning about concurrency (and how to take advantage of it) is one of the potentially big personal educational wins of learning Elixir/Erlang.
I'm rebuilding some of the libs I built in Ruby, in Elixir, as practice. Learning a lot. There's definitely a learning curve, though.
I'm currently reading [Handbook of Neuroevolution Through Erlang](http://www.amazon.com/Handbook-Neuroevolution-Through-Erlang-Gene/dp/1461444624/ref=sr_1_1?ie=UTF8&amp;qid=1418143976&amp;sr=8-1&amp;keywords=handbook+of+neuroevolution) and translating the Erlang code to Elixir as a way of understanding Erlang/Elixir and neural nets. I would like to apply this in the future to building Games based around strong AI.
Build a [simple job board](http://jobs.elixirdose.com/) using Phoenix for learning purposes 
Has anyone done any work on a automated style checker (e.g. rubocop, pep8, gofmt)? That seems like the obvious next step.
Thanks for posting this Samuel; this is very handy and I didn't know where to find it.
I think Elixir would also be a great language to write a web crawler with, as that could be a good use case for parallelism with a process fired up per site crawled.
I've mainly been using Elixir for small scripts. It turns out it is really good at CLI scripts (Escripts are cool as well as OptionParser), has good interop with other languages and is really good at doing data transformation which is what a lot of the small little scripts I write need to do.
They are not mutually exclusive. Doctests are just a way to verify that your examples still work
Use both. IMO, doctests are meant only for avoiding bad code in the documentation examples. ExUnit tests are the test you'd write in every other language. Doctests are just a nice touch :)
IMO doctests are for interfaces (externally callable functions), ExUnit is for everything else.
Only hobbiest stuff at the moment. I'm currently building a DSL for a binary loader/parser. I wanted something where you just write the spec of the data, and that's all that is needed for it to be loaded. It's coming together quite nicely (haven't worked on it as of recent though). However as it's my first project in Elixir, the actual code of the project (not the end DSL) is quite a mess. Especially where I'm doing stuff with the AST. Other than that I plan on converting my website from Ruby on Rails to Elixir (possibly Phoenix Framework, but haven't really decided, though I might do a couple). Just to see where it's currently at. Down the road, I do have some more serious project ideas that I will be using Elixir for, was originally going to use Erlang for them but I really like what Elixir has brought. A very late edit: Thought I should show the DSL for any that are curious how I'm using macros in Elixir. [example loader written using the DSL](http://nim.li/AzbRp) [the code generated by the example](http://nim.li/A1adq)
Sweet I'll have to check that out!
Thanks, I liked the post and the blog!
If you build the code into an executable with the following in your mix file: def escript do [ main_module: Cli, embeded_elixir: true ] end Then it will embed Elixir which may be some overhead but it makes it a tad bit more portable.
To be fair anything that would package and distribute it should install Elixir/Erlang for you.
Someone else already mentioned it, you can embed Elixir so all you really need is Erlang. Since we're mainly speaking about personal use and not official repos I think it's perfect for small scripts.
The, will definitely refer to this next time
Wonderful book, really well written. My intro into the world of Elixir.
Awesome! I have the PDF copy, but have been wanting a paper copy too. Ordered.
Been looking into learning Elixir lately.. Definitely picking this up.
Darn. Just bought it 14 days ago. 
How can I send amendment? Using readme.io "Suggest Edits" UI or as a pull request to https://github.com/lancehalvorsen/phoenix-guides maybe?
As someone who was looking to learn Erlang and started reading the learn you some erlang book, and have now become very interested in Elixir and bought Programming Elixir and am planning to learn it over my vacation... Do you think I should be learning erlang first?
I jumped directly into Elixir fwiw. You will necessarily become familiar with Erlang as a side effect of learning Elixir, so any prior Erlang knowledge will only help. Personally, I started with *Programming Elixir*, then picked up *Erlang &amp; OTP In Action* to broaden my OTP skills. I also consulted the online LYSE book here and there. You definitely don't need to learn Erlang first, so pick which interests you the most and start there.
I hope so! I think Phoenix has the potential to do for Elixir what Rails did for Ruby as far as accelerating adoption. But, I also think Elixir's use-cases as far beyond what we'd typically use Ruby for, so Elixir will hold its own either way :). If we're lucky enough to get the mindshare of anything like Rails, I think really great things will happen. We're also aiming to redefine a "Web framework", so I think we could end up attracting a lot of folks, especially around gaming. We have some interactive browser-iOS apps backed by phoenix channels at the office. They've been a lot of fun to build and proved out the gaming use-case. We've got some big stuff planned for 2015, so I'm happy to hear you're jumping on board. Expect a screencast or two in the new year!
The tooling built around Elixir is amazing. I don't think I've seen anything like it before. Is this something inherited from Ruby?
I agree. Its one of the things I rave about whenever someone asks me about Elixir. Other languages have good tools, but they most times seem like they are afterthoughts. Elixir's tools seem like they were given as much attention as the language itself and that is something I appreciate.
I've heard a podcast or two where the creator of the language, José Valim, mentions that good tooling was a very high priority from the start. José does have a history with Ruby, so I'm sure it provided a lot of insight into what Elixir needed.
This is awesome, thanks!
Video is up now: http://confreaks.com/videos/5078-RubyConf2014-rubyists-have-a-sip-of-elixir
Video is up now: http://confreaks.com/videos/5078-RubyConf2014-rubyists-have-a-sip-of-elixir
IIRC in a talk I watched/read he stated successful languages have good tooling, so it became a priority. I'm largely in agreement with that train of thought. Go has some good tooling around it and I think without a lot of that it wouldn't be nearly as popular.
Elixir and Phoenix made a neat thing like [JamBells](http://jambells.com/) possible.
Thanks for the share! Here are the [slides](https://speakerdeck.com/benjamintan/rubyists-have-a-sip-of-elixir). And please help me [improve](http://speakerrate.com/talks/39971-rubyists-have-a-sip-of-elixir)! Thanks!
And another thing, what about user input sanitization? How is this handled by Phoenix, if at all? How should it be handled in Elixir?
Hi, in termos of books I would suggest Programming Elixir and Designing for Scalability with Erlang/OTP. Check the mostlyerlang podcast for intermediate and advanced concepts.
This keyword is translated to a `require &lt;Module&gt;` and `&lt;Module&gt;.__using__(opts)` calls for a specified module: http://elixir-lang.org/docs/stable/elixir/Kernel.html#use/2 https://github.com/elixir-lang/elixir/blob/v1.0.2/lib/elixir/lib/kernel.ex#L3256 What concerns me I'd prefer to not overuse this macros as it makes code harder to read. Ecto and Plug are good examples of macros overusing. But it's just my opinion on the topic.
Just asking for clarification... By globbing do you mean using implicit functions from the "use"d module?
It declares it as a dependency and fires off a callback which can add useful functionality to the module in question (scoped, of course). Since changes are scoped, it could never get as bad as it is on Planet Ruby.
The thing is that there's plenty of code that makes 'use' declarations at the module top level, and thus those imports spread into places where the functionality is not needed at all and becomes another source of potential confusion.
`use` invokes the `__using__/1` macro on the provided module to inject some code into the caller's module. Balancing code generating and complexity is a careful game you must play, but that doesn't mean macros are evil. I disagree that Ecto and Plug overuse macros. I would argue they are perfect examples of using macros effectively. José created Plug, and is a core contributor to Ecto, so keep in mind he designed Elixir around these kinds of abilities. Can macros be exploited? Definitely. But don't let that discount great use-cases as concerning. Great power comes with great responsibility. You might find my macro talk from Erlang Factory SF helpful https://www.youtube.com/watch?v=mkoYqXdXl5Y&amp;list=UUKrD_GYN3iDpG_uMmADPzJQ
I too have had code comprehension issues due to this. 
thanks!
Handy - I read this yesterday and my copy of Programming Elixir arrived this morning. 
I've spent all of two seconds looking at the page, and the first thing I noticed is the lack of contrast between links and the page background. Any chance you can decrease the brightness of those link?
I'm always looking out for an opportunity to work full-time with Elixir. I'm "bitwalker" on GitHub if you're interested in what I've been working on. I'm not quite in a position where I can move for a job, but it's something I'm considering in the relatively near future. If you want to talk, shoot me a message (that goes for anyone hiring that reads this).
Thanks for the feedback, I've adjusted the brightness
And what a great book it is, hope the post gave you a good jump start
maybe it's the physicist inside me ;) but what are the units of those measurement?
Much more readable at first glace! Thanks!
Nice. My only criticism is that &gt; ZeroToSpawn.y(2) |&gt; ZeroToSpawn.x I'd prefer to look like this: &gt; 2 |&gt; ZeroToSpawn.y |&gt; ZeroToSpawn.x :) I also added a comment to the guy bitching about TCO.
&gt; You can keeping chaining these calls too "keep" :)
I consider myself a newbie as well (particularly when it comes to Erlang), but here's my interpretation of how Meck (the Erlang lib Pavlov uses for mocking) works: When you call `meck:new(module, opts)` the actual module implementation is replaced by a mock module. Meck appears to use a `GenServer` to actually accomplish this, but my Erlang is way to weak to understand it fully. When you perform an expectation on a function of a module my best guess is that the function is stored in the `GenServer` and mapped to the mocked module. I'm sorry if this is wrong, this is mostly my mental model of how Meck works by reading through the documentation and some of the code.
This looks to be brilliant project and will make testing in Elixir very familiar territory for people with experience of RSpec. I have a query concerning the `let` macro. According the docs: let "will never leak into other contexts (defined via "describe" or "context"), not even those who are children of the context where the lazy subject is defined." Coming from RSpec, this was not the behaviour I expected. I often look to reference subjects defined in parent contexts, as multiple tests often depend upon the same subjects. I would be really interested in gaining some info as to why this design decision was made?
You can rewrite https://github.com/membase/cucumberl in Elixir. It's a implementation of BDD with a tool for generating test from scenario/feature files. It's moderately difficult and should be also very very useful for the community! Actually I was thinking about doing that, but for now I'm stuck on rewriting my current work projects to Elixir.
I would love some ideas as well! I'm in the same boat, have been reading a ton online and am halfway through *Programming Elixir*. Would love to start a small project soon. I have big ideas, but they're a bit too big to start when learning a language.
Nice work, that looks really great. And we can create our own language definitions too (was hoping for that when I was reading through). Looking at the two languages, it also looks pretty simple to add your own language too. 
You may help some open source projects with contributing. For instance, if you are interested in web development, https://github.com/phoenixframework/phoenix . You can learn from the code, help with main project, try using framework and add some missing small parts, build tutorial application.
Playing with ExTwitter can be fun. Get tweets streaming and then play with making word clouds, doing stats, collecting urls and seeing how many redirectors they go to etc. I found it a nice way to play with different supervision strategies, GenEvent, and other things.
What does Pavlov stand for? I mean why Pavlov?
TL;DR [vim-elixir](https://github.com/elixir-lang/vim-elixir)
I'm `whatyouhide` on GitHub. I've been doing some Elixir work in the past few weeks and never enjoyed a language this much :). I'm available remote-only though, as I live far, far away from NY.
Thanks for the contribution! I will be trying this out 
Whisper uses a ton of Elixir. It's in Venice, CA. They sponsor relocation and don't have any formal education requirements. http://whisper.sh/jobs
This looks great. Going to have a go at implementing some tests.
For all those folks looking for ideas, try writing shell scripts with Elixir. Almost all of us have little repetitive tasks that we need to do and a shell script is a nice way to both automate the task and practice with Elixir. For example, I need to run a test on some code. But before the test will run, I need to log on to a VPN. I hacked together a little shell script to see if I was logged into the VPN and if I wasn't log me in and then run my test. Small, simple and saves me time every time I need to run this test. Just my humble suggestion, of course.
Now that's a grate feature! Thanks!
Thanks! Glade you like it :-)
Thanks. I actually think that doing small, but useful programs/scripts like that, is a very good idea. You'll both get some general experience and knowledge of the Elixir, and at the same time building something that actually eases your day.
What theme and font do you use? Seems nice and readable.
For Q1: I am also a newbie reading the Programming Elixir by Dave Thomas. I think it is doing an optimization as Elixir realizes that what you are trying to do can be mapped to an already know function so instead of creating another anonymous function it uses the existing one, which in this case is :erlang.+/2. I remember reading this somewhere in the book as well.
Actually this was a small regression I introduced when I released the app, I have fixed this, just update to reaxt 0.1.1
Thanks for the latest article. Do you plan on going back over some of the older doses and updating them to latest Elixir or the frameworks that they are using? Ones in particular are the phoenix_jobs walkthrus...
Hey, so I'm not sure if there's a better place to ask you questions so I'll just comment here again. :) I was reading through the code, but I don't understand what's going on exactly yet. How are you serving the assets from Node.js/Webpack on the same port that Elixir has open?
The reaxt application runs several nodejs workers communicating with elixir through port protocol (see exos/node_erlastic on my github): - n renderers in a pool, each of them run a server entry js script compiled with a modified webpack.config, this server is a nodejs "GenServer", you just call {:render,module,submodule,props} and it replies with %{render_js: ,html: ,css: } - if you are in Hot mode (in dev), then one nodejs worker handles client entries compilations with a "watch", then send message to port at each compilation event, these messages will be converted by exos to GenEvent events. The "debug plug" is actually an elixir implementation of the webpack "devserver", but as a plug, transmitting compilation event as simple "ServerSide Events" to browser javascript. Thanks to Erlang facilities and SSE (instead of socket.io in webpack-dev-server), this "devserver" is much simpler than the one from webpack devs, and it is a simply a plug, meant to replace the Plug.Static in dev... So when you add the Plug, you include a dev server into your application, that is why there is no need to play with ports :). The goal was to use nodejs, but with a better dev experience.
full documentation is available at http://hexdocs.pm/ewebmachine/
So, if I understand: Node isn't actually serving the asset files, it's using another mechanism to tell Elixir when the files are updated so that Elixir can serve the files with SSE?
oh, ok, got it. I know who he is, just could link test library with him :)
I'm also going and have already bought my ticket. The funny thing is that I started to learn Elixir only a couple weeks ago :) I'm a Ruby guy and I'm mostly in for the same reason(s) - concurrency + that familiar feeling of a Ruby language.
In practice, I've never wanted to pipe to an anonymous function. Instead, it's much better to structure your transformation as a series operations on named functions: conn |&gt; assign(:message, create_message(params)) |&gt; render("index.html") Make sense?
&gt; The Elixir standard library and most well structured Elixir libraries lend their APIs to passing the subject as the first argument What initially set my mind down the path re anonymous functions was seeing some code (somewhere) using the Elixir Regex library e.g. tmp = Regex.replace(~r/a/, "abc", "1") tmp1 = Regex.replace(~r/b/, tmp, "2") I had been surprised after reading about pipes to see that the Regex library didn't have the option for the /1 parameter to be a string and hit a similar "problem" while playing with Phoenix. &gt; In my example (and yours), we are transforming the connection; assigning message and sending the response, so we compose the pipeline with the conn as the subject. This may be a potential "newbie mindset pitfall" ... this is not the way I would have looked at it at all - I looked at it as transforming my "data" to an output, I would not have thought of it as transforming a connection! Very illuminating!
Yeah it's a bit of blurred line because your understanding of transforming your data is accurate too, since really that's the whole point of the request. The Phoenix/conn example is `conn` centric because the connection is our main vehicle to pass state around and operate on the connection throughout the request lifecycle. In general, I think your case of `input |&gt; my_data_transform |&gt; output` is exactly the way to think about it :)
&gt; This is a real pity since what should be an elegant way of expressing intention gets lost in the syntax - in fact the above might be better written: &gt; &gt; render conn, "index.html", message: create_message(params) So write it like that, I don't think you should try and improve this with pipes. Pipes are useful when you have a single type of value (a connection, an enumerable, etc.) that you want to perform transformations on. This works really well in Elixir because the convention is to put the "subject" of a function as the first argument. Pipes don't fit in your example because the `render` function is not performing a transformation on the result of `create_message(params)`. And that's perfectly fine, you shouldn't try to fit pipes to every problem, it's just a helpful tool when you have a set of transformations you want to perform on a single value. Of course you can rewrite it in a way that fits `|&gt;`, like Chris shows: conn |&gt; assign(:message, create_message(params)) |&gt; render("index.html") But that should not be an end goal. Your way of writing it is actually more succinct and readable to me in this case.
&gt; you could use String.replace which takes the input string as the first argument Ahh ha! Well worth fussing over this just for that snippet, ta :)
Nice!
Erlang is a proven technology and Elixir sits directly on top of it. I was hesitant to adopt and evangelize Elixir when we first started building our online game infrastructure at Undead. At the time (~1.5 years ago) Elixir was version 0.8.0 and I hadn't spent much time with it. I knew Erlang but I was excited for hygienic macros, a more consistent standard library, and the promise of better tooling (mix, etc). When I realized that Elixir and Erlang could inter-op as easily as they can, it was an easy risk to take adopting Elixir and I'm very glad we did. I've had a much easier time getting other engineers on board with Elixir than with Erlang. - Jamie
thanks, good to hear
FYI, I was confused/annoyed by the Regex library, until I found that the String library has many corresponding functions with string as the first parameter. http://elixir-lang.org/docs/stable/elixir/String.html#replace/4 http://elixir-lang.org/docs/stable/elixir/String.html#match?/2 Etc... EDIT: Should have read the rest of the thread! So redundant!
Will be there as well. I'm mostly doing C++ too. And definitely up for a pub crawl! 
You might also note that Bruce Tate, author of 7 Languages in 7 Weeks is now using Elixir at http://icanmakeitbetter.com/. Bruce is their CTO. Also unless things have changed recently Quark Games (http://www.quarkgames.com/) is using Elixir internally as well. Hope that helps. 
I believe the proper way is to make a third app e.g. encryption_lib under the same umbrella, and include it as a dependency of the encrypt and decrypt apps.
Thanks for your reply! I tried that, but then when I run 'mix escript.build', it complains that that project doesn't have the proper escript configuration.
Wound up creating a 'Common' app inside the umbrella project's lib directory: https://github.com/vigetlabs/otp/commit/d7a17edea2eca31c0050955ff78c9ad06f9edca6 Still curious if there's a better/more idiomatic way.
I'm right with you, but I needed two separate executables ('encrypt' and 'decrypt') for this particular purpose, and that didn't seem doable w/ a single project.
I personally have used Elixir to do some work on tree-like structures in the database alongside with my Rails application, where there are background calculations involved. It was not impossible to optimise these calculations in Ruby, but Elixir's functional nature seemed like a better fit and indeed it was. Essentially I was grabbing collection of records from the db, doing some calculations, writing it back to temporary table and updating by union. Result was an optimisation from 15minutes per task, to 1-2 seconds per task. I consider it impressive :) 
I've also come from a PHP background and I've found that Dave Thomas' *[Programming Elixir](http://pragprog.com/book/elixir/programming-elixir)* is a great intro to the language. I also enjoyed /u/chrismccord's [Elixir Workshop at RailsConf 2014](https://www.youtube.com/watch?v=5kYmOyJjGDM) while I waited for the book to arrive.
Thanks for the links
Start with Elixir. The syntax is easier (closer to Ruby) and it has a shorter learning curve. The deeper you go into Elixir the more you will run into Erlang, but knowing Elixir will help you understand the patterns in the code so that the "weird" Erlang syntax seems a lot more understandable. As far as Elixir resources go, there is some reasonable support in emacs (alchemist and elixir-mode) as well as SublimeText3. If you are coming form visual studio you might find SublimeText a bit more familiar. I would also recommend that you check out the Elixir Sips series, for a nominal payment you have access to a series of almost 150 lessons so far.
Looking almost exactly like good old Rails migrations. Nice
My first elixir package...! I have a little code cleanup to do, but I've added tests for all the use cases I can think of, and I used the same software license as Ecto for compatibility. Suggestions or are more than welcome. I hope someone else benefits from it!
Erlaudio is for interfacing with Port audio, sadly not really related to making art or music. :(
The name for this project is quite brilliant, I have to say.
This is awesome! Are there libraries like this for other OS's as well?
Great job! I love this language. It's my favorite!
Really great tutorial, also a fun take on FizzBuzz! Any plans to expand the tutorial to cover supervision and hot code swapping?
Homebrew, the OS X package manager uses Ruby which will fire up the MRI VM.
Stop down voting this :-/ I hate you guys for being selfish! 
Cool, but not really practical...
This looks pretty great. I've noticed most example projects don't touch serializing of models. It's not unusual to need to sanitize and mutate your models before sending them to the client. This will help me in a few projects, thanks.
By the way, with AM::S you can use the format: `ActiveModel::ArraySerializer.new(users, each_serializer: UserSerializer).as_json` To avoid the `.map{ |obj| ... }` call 
Pipes are like Ruby or Javascipt method chains. string.split('/') .select { |x| x.match(/foo/) } .reverse .take(5) .join(' ') If you wouldn't use a method chain in that situation, you probably shouldn't be using pipes here.
That last example is begging for Stream.resource :)
Just learning about the Stream module today as it happens! If I get round to it, I'll update the example or add another one and credit you. Cheers.
Beginner level stuff but the "feel" of using macros like this really surprised me and so I thought I would share.
I wonder what the issue is here, IIS 8 can perform a lot better than that... A bear bones HttpHandler will attain 22k req/sec on my workstation, and my application framework will do a full pipeline execution and render and still attain 10k req/sec. I appreciate this is running on an Azure instance and being benched more appropriately across the wire, so you'd expect it to be much slower... for all cases... I'm not understanding a 36% failure rate at only 1k req/sec. This does not tally with my experience of IIS at all. Maybe its an issue with HttpPlatformHandler. I might test this out myself over the next week. These are very modest numbers to be getting such a high rate of failure.
It's because the args to hash_update need to be swapped around, it takes the accumulator first, and 'thing to update the hash' with second. defmodule ShaPlayground do def enum_to_sha(enum) do enum |&gt; Enum.reduce(:crypto.hash_init(:sha256), &amp;:crypto.hash_update(&amp;2, &amp;1)) |&gt; :crypto.hash_final end end Then it works with a list of strings: iex(1)&gt; ShaPlayground.enum_to_sha(["does", "this", "work"]) &lt;&lt;37, 182, 79, 99, 123, 55, ... snip... 67, 148, 184, 149, 143, 39&gt;&gt; However, it doesn't work with a list of ints: iex(1)&gt; ShaPlayground.enum_to_sha([1, 2, 3]) ** (ArgumentError) argument error :erlang.iolist_to_binary(1) (crypto) crypto.erl:242: :crypto.hash_update/2 (elixir) lib/enum.ex:1261: Enum."-reduce/3-lists^foldl/2-0-"/3 iex:1: ShaPlayground.enum_to_sha/1 If anyone could explain to me why it blows up with integers I'd be grateful!
Do post your findings. I am even more curious. 
I like it. I look forward to seeing more detail on comprehensions, and control flow (cond and case) as I always have to look them up. 
Bookmarked! Very useful, thanks
Another thought Greg--since this seems to confuse so many who are new to Elixir, you may want to rephrase the description of a variable. Right now you've got "Can hold any data structure and can be assigned more than once." It's not correct to say "can be assigned more than once" because the second and subsequent assignments are _under_the_hood_ actually binding to different names. I'm not sure how else you might say it but, as I say, it seems to be a common bone of contention for people new to Elixir. 
Just added comprehensions: https://github.com/itsgreggreg/elixir_quick_reference/blob/master/README.md#comprehensions Lemme know if there's anything missing that you usually have to look up!
Definitely, variable re-binding does seem to be a confusion point for many people though I'm not exactly sure where it begins. I think the concepts of immutable data and immutable variables might be getting jumbled, though I'm not sure a clarification on that point could find a suitable home in a quick reference. I am completely open to changing things in the guide though and would love suggestions for better wording! 
Good point Greg; it is intended to be a quick reference for people who already know what they're doing. 
Control Flow: https://github.com/itsgreggreg/elixir_quick_reference#control-flow
Thank you so much, that is great to know. Much appreciated.
The new comprehensions and control flow look great. Thanks!
I have been following this framework for a while and I like the progress, but what we really want is a package manager to manage installing other package managers
Any idea how to get it to output .dot files (for use by things like Graphviz)?
You are going to have a better time using and getting set up with elixir/phoenix. Its a little new and raw but its definitely more integrated with the elixir community. Hop on to freenode irc room #elixir-lang and ask questions, or jump on the mailing lists. The guides on http://www.phoenixframework.org/ should get you 60% of the way, and we are always looking for help get it that last 40%! :) EDIT: Always free to ask questions here, stackoverflow or directly via twitter.
It's a tough call. The reality is if you are doing asset compilation, you are nearly guaranteed to need a js runtime/node dependency anyway, so the only way around it is to completely re-invent the wheel, which is not a good use of our time. I think we'll strike a nice balance in phoenix. We'll just ship a soft-node dependency with a boilerplate brunch config that's easy to extend, so we aren't doing any wrapping and it's easy to throw in another build tool if brunch isn't your style.
a) You get started by doing something. Find a project and work on it. It doesn't matter what is is - what matters is that it interests YOU. I started by reading the Programming Elixir book, did a few little projects then started on something big. b, c) Phoenix looks to be the breakout framework at the moment; I'd stick to the well worn groove at least initially.
My personal opinion here is that cucumber fell out of favour because of misuse. If only developers see/write features. Then it's a needless overhead. If you write features that too closely mirror implementation details then they become overly complex
Well I disagree with your disagreement :-) I think sharing a ubiquitous language with your clients is a very powerful thing. The gherkin syntaxt is a nice way of communicating this. Nice blog post here: http://everzet.com/post/99045129766/introducing-modelling-by-example However I don't believe in there being only one "right way of development". So your experience may vary.
We share that language with the client via some form of stories. eg: "When x, I want to y, so I can z". It's usually a lot higher level and doesn't dive down into unnecessary details like you will with Gherkin. It's also more difficult to maintain Gherkin, and from my experience with it takes a lot longer to write. I feel like that's unfair to the client who is only paying you to write quality, working software. I love testing and I'm not saying not to test, but it just takes too long and doesn't provide as much of a benefit from my experience.
I'm going to quote this for argument sake: "I feel like that's unfair to the client who is only paying you to write quality, working software." The client is not just paying you to write quality, working software. The definition of quality is very personal and working software might not necessarily be nice. Ultimately, what the client really want is a good return of investment and a product that does what he/she wants. Quality for you client is definitely different from quality for you as a developer, that's a fact. So how do you ensure that what you are building is exactly what the client want? You generally have example workshop session with your client and you gather requirements. How do you capture these requirements? Up toy you really but for sure communication frameworks like Gherkin (or any other) are of a great help. Having features file don't necessarily imply that then you need to parse/use them, but that's an additional benefit to help you driving your development process towards automation but still good nonetheless in my opinion. The fact that it takes a lot longer to write it's because as always new things requires a change and changes have a learning curve, sometime gentle sometime steep. To my experience it's the opposite, it pays back and quite a lot.
I wonder why such a silent release.
This is the second part of my Profiling Elixir investigation. This post focuses on the eflame profiler.
Thanks, this series is great!
You are welcome losvedir, glad you enjoyed it!
Great! I'm readeing guides (outdated as of now) about phoenix, and I'm wandering how to implement `title` function from [Views guied](http://www.phoenixframework.org/v0.9.0/docs/views) in this new `web.ex` solution. Adding `import MyApp.Web` in using block will pollute other views with functions `view` `controller` and `model` - is there an other way?
Is this going to be locked into brunch or allow for alternatives like gulp?
Nice. Why do you use a list instead of a tuple for the second argument of the q function though?
This could be a nice introductory article, but I wish the author could link most of his emphasized points to sources, or tools/libs' main pages/downloads so people who are actually accessing the technology could verify the claims and get a starting point to their studies. This is coming from someone who knows nothing about the Erlang world and wishes to get into it starting with Elixir. (why am I talking in third person?)
Just that the slug is different from the title. Actually it's good that he switched from the clickbait title.
Oh I didn't even think of it as clickbait at first. I thought you meant it was too apples-to-oranges comparing the two.
Some good points. Although I'm not sure I'd use the word sexy to describe a language. You Keep Using That Word, I Do Not Think It Means What You Think It Means
Please stop emphasizing random parts of sentences. You've emphasized so much that none of it has any value over non-emphasized text.
My guess is yes, it's very well suited. To prove that Elixir is not the bottlenck, you could distribute the tests on many clients machines. elixir would provide good tools to accomplish that too...
Benjamin Tan Wei Hao actually wrote an HTTP load tester (in Elixir) which he demonstrated during his talk at RubyConf last year. I'm not sure if it's up to date, but I think the idea is sound. https://github.com/benjamintanweihao/blitzy
Nice blog post! I released a library not too long ago which has the same end goal as what you're describing. I find it very important to break out the serialization into a reusable module, which you also are emphasizing. https://github.com/stavro/remodel
Thanks for reading!
To be fair many of these points can also apply to clojure.
Thanks! We are working on some changes to phoenix views which should simplify my JSON Api lib significantly. So will probably be within the week or so. 
There are some free videos at http://elixirsips.com/episodes.html . If you are willing to pay for the subscription then there are a lot of useful short videos there.
Looks pretty good at a quick glance. You may want to point out keyword lists's primary weakness when used as function parameters in that matching on several keys is order dependent, unlike maps. That is, def foo(a: a, b: b), do: a + b foo(b: 1, a: 2) #=&gt; This will raise a match error where as def foo(%{a: a, b: b}), do: a + b foo(%{b: 1, a: 2}) #=&gt; 3 When accepting many options via a keyword list you ought to def foo(opts \\ []) do opt1 = opts |&gt; Keyword.get(:opt1, :foo) opt2 = opts |&gt; Keyword.get(:opt2, :bar) end so that the options don't lead to match errors by accident.
We had to knock off some bigger hanging fruit first. Now we're good IE8+ so the Phoenix sell should be much easier
That is simply great! IMO this should be built in in Elixir with its own operator. Too bad we cannot create own operators freely but are restricted to `@binary_ops` - `|&gt;=` would look really nice here `|&gt;` part from standard pipe operator and `=` just looks like rail roads ;)
You just beat me to writing almost the exact same post. I did some s3 integration the other day and had a few stumbling blocks with the docs but overall was very happy with the results. Cheers!
Elixir is built upon the venerable OTP and Erlang, which are battle-tested in needs for fairly massive concurrency. Thoughtbot recently wrote about using Elixir to build a JSON api [here](https://robots.thoughtbot.com/testing-a-phoenix-elixir-json-api), and Benjamin Tan (and others) have written on the more 'real-time' applications of the language. It depends on what your needs are, really. You have access to (almost) the entire Erlang ecosystem as well with Elixir, if you need that sort of leverage. Deploying Elixir is relatively painless, though requires Erlang as a dependency. You can get it pretty light by not installing the whole of Erlang, however. We're currently using Elixir to power an experimental ETL pipeline, and use Docker and Terraform to 'deploy'.
Wow ... i was just asking this to ******* on #elixir-lang this week !!! Currently have EmberJS apps with rails. If i can, ( completly beginner in elixir , i will try to help )
I'm coming to Elixir from a C and PHP background, so I suspect coming from rails will feel a little easier. I'm a beginner too, and perhaps some of the design patterns I'm using are not really in the style preferred by Elixir people. For instance, I don't like controller code to make database queries specific to the adapter. In my app, I created a new function in web.ex which I call with :repository. It alias's and imports some conveniences like Repo.ex for use in queries and inserts. In this way, my controller has only my own defined functions and I would be able to just change the repository should Ecto make some breaking change (they've done that to me before!) I haven't seen this done in any elixir examples, and its honestly kindof a typical PHP design pattern, so hmm Edit: to simplify, I eliminated this repository pattern in the example on Github, and just put the code in the controller.
yes, from what i can look at your code, your controllers are fine. You just have your Repo in your controllers. In rails you do something like @users = User.all ( if you mean by this, the query in controllers ). Take notice that since in rails, active record is an orm with adapters to alot of databases, you can change databases without changing code. Seems fine and like rails, you should be able to switch databases without altering you controllers code. I will have a go at it tomorrow and let you know of any findings!
If ( and big if ) i am understanding correctly, i would say that those special query functions would go into models. You can lookup rails scopes , seems to be what you are talking about : http://api.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html ( see the scope example )
This can be accomplished using monads, which is essential what the article is describing. I've been using this https://github.com/rmies/monad which a good degree of success. Usage looks like: require Monad.Error, as: Error import Error def my_func do Error.p do foo(1) |&gt; bar |&gt; boo end end where `foo`, `bar`, and `boo` are of type `any -&gt; {:ok, any} | {:error, any}`
https://github.com/elixir-lang/elixir/issues/3228 Downgrade to OTP 17.4 or wait for Elixir 1.0.4 to be released.
Ubuntu has old version of elixir in repo. You can try to download precompiled packages or compile code yourself. Check info on http://elixir-lang.org/install.html I am using kubuntu 14.10 with compiled elixir version 1.1.0-dev
No idea. I hope so. ;)
Thank you.
In a sense that everyone knows what he means and its a fairly efficient way to say it. Dictionaries get updated after.
The sum example behaves pretty consistently on my machine (produces the same output on multiple runs), and I guess the biggest win here is because the streamed version needs to allocate much less memory since everything is computed in a single pass and the result is accumulated on the fly.
Seems more consistent here also after switching to benchfella. But Enum is always faster. So this is a mystery I guess.. I also checked peak memory usage, for only: Enum: 365 Mb Stream: 237Mb So as memory is sometimes more precious than CPU, Streams are a good option to conserve some memory when dealing with large lists. 
It of course depends on what you're doing. In [this simple example](https://gist.github.com/sasa1977/9786002d65baf4484c52) on my machine stream version runs consistently about 10% faster and uses about 3000x less memory, although it still needs to pass through the entire input collection. Now, if the whole stream must be converted into a list, then the final memory requirements are essentially the same for both versions. However, a stream doesn't produce intermediate lists, which might save some memory depending on the circumstances.
I have been using elixir on the side for almost a year now. I am never happier coding than when I'm writing elixir. Coming from 9 years of C# it's a different world to enjoy the tools so much. I'm writing Node.js and python at my day job now but hope to one get to do elixir full time. Once you finish Dave's book and use elixir for a bit check out Elixir in Action. It's a great follow-up that dives deeper into OTP and structuring libraries and components. I've also been reading Erlang books to grok OTP design better. 
That's some trustworthy face, I will have a look into Elixier.
I came from a C background and have been working with Php for the last few years. I have never even opened a Ruby source file, but Elixir just makes sense to me. It just feels natural to code with- maybe I should have been working with Ruby this whole time!
Nice. I added some comments there, further defending it. It actually solves or eliminates entire classes of problems that I constantly ran into on a medium- or large-size Ruby codebase. Plus, being about 10x faster is also nice.
Unfortunately it is hard to read because of line wrapping in the code.
About your specific example: Phoenix does not have a database layer, so it does nothing for you there. In general: Each request is handled inside its own process, although I believe these are taken from a pool and aren't necessarily spawned on every single request. In any case, any further concurrency you wish to do must be done by you or some library you use, it isn't done by phoenix itself.
The Agent is a gen_server abstraction so persisting it is not the best way. Using a DB or DETS table is a way to persist it. But I can do it in the github repo if you are interested.
That's correct. As with all optimizations, profile and see if that's actually something you need to do. If the queries you're doing in ecto are in fact taking a while though then by all means throw them in tasks and await. Keep in mind that await has a default timeout that you may want to adjust depending on how long you expect the tasks to run.
I would be interested in the code for using Ecto to persist to a DB in the github repo.
Ui needs work on iOS 
I really wish rlixir would ditch the ends. But otherwise love it.
Thanks for sharing this! I'm just getting into Erlang (using [leptus](https://github.com/s1n4/leptus)), but have lots of difficulties packaging my application. It seems that elixir and maru will make my life easier. This post helps a lot!
Looking forward to the interviews!
The one thing that you left put might be the dealbreaker for me; when you have a straight function call without pipes, you may leave out the parenthesis. If you added that to your analysis, i think leaving out the pipe symbol will give you more beautiful code. This is due to operator precedence i guess. The pipe operator is apparently borrowed from F# where you (I think) may leave out the parenthesises. There was some talk about adding that to Elixir, but the discussion was too late for version 1.0. (I'm not sure if that made any difference though)
I would vote against for the following reason: If the article has its own comment feed, adding a second one would fragment the discussion, and the author of the original piece would have to answer the same questions and/or defend a position in multiple comment threads. I do realize the irony of saying this on Reddit :)
It makes sense. I think I will remove them.
I'm glad you like it :)
Why is elixir bad for numeric computation? Is it worse than, say, java?
The Elixir FAQ breaks it down: https://github.com/elixir-lang/elixir/wiki/FAQ#2-can-elixir-be-used-to-write-programs-that-rely-heavily-on-fast-numerical-computations
The only class of problems I can think of are those that require multiple threads of execution operating on one very large data set in memory. (edit: because there is no shared state between threads of control) So, certain types of data analysis.
Maybe something like DSP and real-time machine learning.
Shared state in "multiple threads of execution" is a recipe for hard to find bugs. No shared state is a _good_ thing.
We solved this in irc by installing node. More interestingly, I had no idea /r/phoenixframework was a thing?!
nkomx's point in a wiki: https://en.wikipedia.org/wiki/Linguistic_description TL;DR Refusing to acknowledge a words existence does not stop that word from existing.
&gt; Clojure uses mutable data This is not true. Clojure's data structures are immutable (though using structural sharing), just like Elixir's. FWIW I have spent a lot of time studying both (I was involved with the Elixir community &amp; maintaining popular Elixir tooling for about a year and a half, and have been writing Clojure off and on for 4 years). To me, Elixir &amp; Clojure seem fundamentally equivalent, and I just want to know if there is some application for which Elixir is just a natural choice. 
I think a lot of people sleep on fault tolerance as a major feature. Elixir (from BEAM) has fault tolerance baked in. To me this is key for the projects I'm building and why I choose elixir.
I think both are very beholden to the VMs they build upon (in a good way). I would wager most concurrency on Clojure isn't using core.async channels because most people are working with legacy systems and/or come from Java and understand/like the concurrency primitives there. So we're talking normal threads, normal shared data structures and the like. core.async is great, but it's totally optional, easy to avoid, easy to accidentally break, etc, because it isn't enforced by the VM. Because Erlang is more strict, Elixer is "stuck" with message passing only (for most realistic cases) and so everything is done over channels or whatever they choose to call them. This is great for understanding wtf is going on, ensuring safety, etc. Not typically great for super high throughput when shared state of any kind is involved. To answer the original post, Clojure will (should?) win where the JVM does, which is anywhere that you need a bunch of libraries that you don't want to rewrite. Elixer will (should?) win where Erlang does... tbh I'm clueless where that it is in 2015.
I think if you're building an application that will be doing minimal calculations and will need to handle distribution well out-of-the-box Elixir is a good fit. You'll scale for "free" without needing to build microservices to achieve something similar and have supervisors to keep it all reliably running for as long as you need it. If you don't like dealing with the JVM there's also that. If you want a language that syntax wise is probably easier to get others to accept I'd think Elixir wins there hands down, since lisp is a harder sell. There's also hot code swapping, awesome bit syntax, and dialyzer (although typed clojure appears to exist). Clojure has a much larger community and many more packages. The only roles Clojure probably fills that Elixir can't are computationally expensive code, desktop applications, and a very popular javascript target allowing for isomorphic applications. Edit: I forgot about ets, dets, and mnesia. You basically get a db that you can use for all sorts of things baked into the language. You can probably avoid additionally dependencies and setup of a cache solution by using these options.
&gt; it's totally optional, easy to avoid, easy to accidentally break, etc, because it isn't enforced by the VM Hadn't thought of this before, very true
Anyone using RethinkDB in production? I'm seeing it a lot. I'm wondering how nasty complex queries would get, because startups inevitably end up needing reporting, and reporting almost ALWAYS requires complex querying
No real problems other than a few things I overlooked at first (Node version specifically). From a fresh Ubuntu instance, I believe I needed git, nvm (for getting the latest node version), and npm. After that, just follow the instructions, and it should go pretty smooth. I also installed inotify-tools after I had everything up and running. I'm connecting directly to cowboy for now since it's just a test/dev server. 
I'm not 100% sure I'm following what you're asking for, but here is what I think you're asking: iex(1)&gt; ["http://reddit.com", "http://facebook.com"] |&gt; Enum.reduce(%{}, fn(url, map) -&gt; ...(1)&gt; Map.put(map, url, url &lt;&gt; "/index.html") ...(1)&gt; end) %{"http://facebook.com" =&gt; "http://facebook.com/index.html", "http://reddit.com" =&gt; "http://reddit.com/index.html"} I'm iterating through the list of urls with the `Enum.reduce` method and accumulating a updated `map` with each new list item. Each list item becomes a key in the map, and the value is the key with "/index.html" thrown on the end (the "dothing(x)" in your question. This kind of question might get more visibility on [stackoverflow](http://stackoverflow.com) if this isn't what you're looking for.
missing a space between ) and do &gt; def start(N, M)do should be &gt; def start(N, M) do
what's up with all the capital letters for variables? I'm new to elixir, but does that even work? I thought caps meant alias for something
unrelated but as mentioned below convention is to use mixed case for variables, and module names and only module names should be camelcased. As for your error you have a trailing comma at then end of every line here for some reason. def start(N, M)do :timer.sleep(random.uniform(10) * 100), &lt;&lt;&lt;&lt;&lt;&lt; LoopPid = spawn(_MODULE_, :loop, []), &lt;&lt;&lt;&lt;&lt;&lt; spawn(_MODULE_, :sendMessage, [M, LoopPid]), &lt;&lt;&lt;&lt;&lt; end Other comments: you shouldn't use semicolons unless you're doing something inline and even then you should really think about how readable it is. In general "unexpected token: end" is usually a parse error caused by an unterminated expression, usually a do with no end or a trailing comma. 
Ok that's pretty helpful, but how do I put each URL through the dothing function to get the map (also it's a new map not appending to the existing map
You don't want to append to the existing map. Destructive assignment is contrary to functional programming.
I guess it depends on what you mean by "append". Append and create a new list--no issue. Append to modify existing list--contrary to the way FP should work.
You should be able to solve this faster by yourself than by leaning on the forums. Here are some tips: look closely at the line from the error trace and also the message. Look for the lines concerning your files. If that does not work, try starting with an empty module, and then add as small pieces as possible until you see the smallest added change that breaks the build. As others mentioned, variables in Elixir must have lowercase for the first letter. Otherwise they are considered atoms. Another tip is that Elixir does not allow functions defined inside another function. 
urls |&gt; Enum.map(fn(x) -&gt; #do something with x end) |&gt; Enum.reduce(%{}, fn(x, acc) -&gt; Map.put(acc, x, x) end) |&gt; Enum.into(someothermap) Embrace the pipe. 
I feel like a douche for even daring to ask this, but what is acc?
Ah okay awesome. That makes a lot of sense thank you! 
There's kalecto, which uses kalend that supports ecto.
Neat, I wasn't aware of this. I've been thinking about putting together a library that extended Ecto.model like this and correctly cast dates, times, as well as decimals- since decimal casting is not yet implemented in schema.
ah yeah allright that makes sense- I'm only using it for reasonably small values. Maybe you are right, maybe Elixir does need a really good math library. 
https://github.com/ericmj/decimal He's the one who actually pointed me to that custom "integer power of 10" code... as I stole it from a (unfortunately) private function in his own library there! Me, I'm just used to a \*\* operator. In Ruby you can do 10 \*\* 33 and it works exactly as you'd expect. In Elixir, maybe due to syntactical reasons, you can't even macro-define a \*\* operator... it chokes on the first \*.
Considering the limitations of some Erlang functions, I think having some math library built right into Elixir would be super useful. I mean what project doesn't have some math needed in it? Maybe something like Math.t. 
I agree... maybe Jose is waiting for that space to sort of battle it out, until one fits the bill? Me, I just need integer math that is fast, works, and is deterministic, for all values. ;) I can get by with coding my own on-the-fly modules in the meantime. I guess ;)
It's the dean of the CS department who is teaching it. It's basically a multi-paradigm class and he taught it several years ago but used skala instead.
I don't know of anything specific to JavaScript. Probably best to start working through the Elixir tutorials on the website: http://elixir-lang.org/getting-started/introduction.html Keep clicking through on the "Next" button; you'll get to a pretty good tutorial on Elixir. 
You can't modify the map, anyway. Modification always results in a new version. Old references to the map won't change. This is why you can't just "do immutable" in a language like Ruby... It pretty much has to be embedded into the language. Which all functional langs have.
you should study the enum functions: http://elixir-lang.org/docs/master/elixir/Enum.html "Reduce" is pretty powerful and fairly important (although not COMPLETELY trivial) to understand (IMHO). It's like "inject" if you've used Ruby, or "fold" if you've used Haskell.
Would you consider remote work (but visiting onsite once a month or so) from a guy who also knows German fairly fluently? I've been sort of looking around. My Elixir experience is all [experiments](https://github.com/pmarreck/elixir-snippets/) so far, though (I'm a self-teaching sort). I *am* getting a kick out of it, and I have a ton of Ruby dev experience at startups, if that matters... Happy to have a chat.
Microsoft just launched Visual Studio Code for windows, linux, and max. They already support a bunch of languages including Ruby. Although there already are plenty of editor options it would be awesome if we could get support for elixir as well.
I recently started reading the kindle version of this during my commute and it's pretty great. I heard about the book when watching this [tutorial](https://www.youtube.com/watch?v=5kYmOyJjGDM). The video is pretty good because it is 3h 20m long and covers most of the book (the presenter learned from the book as well from what I can tell)
Also, rereading my posting, I want to make it clear that I meant "my" in the sense of "That I work for" rather than "That I wholly own" ;)
Joe Armstrong uses a terminal and Emacs for coding Erlang; that's good enough for me too.
Right after you add it for Scala.
Who would've guessed we had an editor elitist show up! I use vim, but I would love to see people be able to use their favorite editor because I enjoy using mine.
This is how I look at it too. It's especially nice when you start to leverage destructuring in your signatures. You only need to think about those additional variables when they actually apply to the situation: defmodule FirstItem do def first({:ok, []}), do: {:NO_CONTENT_204, nil} def first({:ok, [head | tail]}), do: {:OK_200, head} def first({:error, _}), do: {:BAD_RESPONSE_400, nil} end FirstItem.first({:ok, []}) #=&gt; {:NO_CONTENT_204, nil} FirstItem.first({:ok, [1]}) #=&gt; {:OK_200, 1} FirstItem.first({:error, [1, 2]}) #=&gt; {:BAD_RESPONSE_400, nil} So `head` and `tail` are only things you need to think about when they're actually populated and remove any sort of checking to see if they exist.
Software is all about data. Nothing matters more. So modeling your logic around your data helps keep that logic relevant and accurate for the data known to be valid based on the specification of software behavior. To this end, it's very helpful to model logical reactions to data values when you can represent it in a way that honors the data at a higher priority than the logic itself. Pattern matching gives us this. Pattern matching allows us to directly say "When the data looks like this, do this. When the data looks like that, do that. When the data looks like the other, do the other and when the data looks like something we don't even know let us fail." And it allows us to represent this very directly and clearly which ultimately helps us reason about how we're reacting to input data more efficiently. In some languages, pattern matching can also be used for implicitly and strongly defining types for input/output of functions and provide a great degree of safety without so much annotation. To see a better example of this than what Elixir offers, check out O'Caml. Referring to your own example, in the pattern matching version you can think of the code as a listing of factual relationship declarations—a definition—where as in the more procedural logical articulation, it is the beginning of a binding relationship in concrete terms: it's instruction. When the former example is evaluated, the concepts of the algorithm are decomposed and considered on a basis of the data, and when the latter is read, it is considered in a linear flow that leads one to think of it as one giant block of rationale. Of course, neither is wrong, per se, but, the former helps more clearly break down the pieces and think about them. This example loses some of its luster by being a recursive algorithm, which forces interdependency in the model that is highly undesirable for reliable, understandable code. But it is probably the shortest way to write this algorithm in most languages. As usual, such an overly simplistic example doesn't do us many favors in realizing the power this has for improving our reasoning process. Far better examples would be found in finite state machines of greater complexity dealing with problems people actually care to deal with, like compression and decompression or transformations of data structures such as a tree decomposed into a relational database.
What's the equivalent of Module.&lt;\Tab&gt; in Windows?
Here's a [link to part 1](http://vysakh0.github.io/how-a-rubyist-tried-to-learn-elixir-lang-part-1)
well... there's always "h Modulename"
The author seems to have tested his website from a place that is network-far from his server. His server is based in SF, and the author's blog says he is based in Colima, MX, so maybe thats it. I'm only 13ms away and I get results more like this: (tl;dr: if you put your web service at the far end of a high latency connection, changes to the app server architecture are less significant) ab -n1000 -c10 "http://david.padilla.cc/posts/19-date-formatting-in-phoenix-elixir" This is ApacheBench, Version 2.3 &lt;$Revision: 1554214 $&gt; Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking david.padilla.cc (be patient) Completed 100 requests Completed 200 requests Completed 300 requests Completed 400 requests Completed 500 requests Completed 600 requests Completed 700 requests Completed 800 requests Completed 900 requests Completed 1000 requests Finished 1000 requests Server Software: Cowboy Server Hostname: david.padilla.cc Server Port: 80 Document Path: /posts/19-date-formatting-in-phoenix-elixir Document Length: 9050 bytes Concurrency Level: 10 Time taken for tests: 4.964 seconds Complete requests: 1000 Failed requests: 0 Total transferred: 9467108 bytes HTML transferred: 9050000 bytes Requests per second: 201.47 [#/sec] (mean) Time per request: 49.636 [ms] (mean) Time per request: 4.964 [ms] (mean, across all concurrent requests) Transfer rate: 1862.62 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median max Connect: 13 28 99.6 19 1230 Processing: 14 22 24.9 20 339 Waiting: 13 21 24.9 19 339 Total: 29 50 102.6 39 1246 
Yeah, I didn't get it either. Maybe because its frontend or interface is less than beautiful? I don't know. It can certainly do the job.
I've been getting comments about this. Apparently 300ms is slow for Phoenix standards. I'll re-benchmark and update as I know more.
I am in Las Vegas this week. I'll benchmark and see if I can get better results from there.
Try [Tsung](http://tsung.erlang-projects.org/). On a Mac at least, it's just one "brew install tsung" away. Happy to hear how you fare!
I only had a quick peek, but how about putting your account-credentials (eg. username, password in mailer.ex) into the configuration ([see](http://elixir-lang.org/docs/v1.0/elixir/Application.html#get_env/3))
I hope that's not the real username and password for your email account.
A small issue, but ```ruby defp get_all_top_posts([head]), do: [get_top_posts head] defp get_all_top_posts([head | tail]) do [get_top_posts head] ++ get_all_top_posts tail end ``` could be replaced with ```ruby defp get_all_top_posts(lst), do: Enum.map(lst, &amp;(get_all_top_posts/1)) ``` Initially, I had planned to say that [x] ++ [x,y,z] was less efficient than [x | [x,y,z] ], which I think is the case in Haskell. Checking the docs, it seems like it gets optimized internally to be equivalent, but I still think using the cons operator is more idiomatic with recursion, because you specify that you are adding one elemnt to the top of a list, rather than joining two lists. 
That's a really good idea. I wasn't sure how to do this at the time, but I'll make that change soon!
Can you explain the replacement example? Im not quite sure what it's doing.
Reading these makes me very happy I didn't come from Ruby to elixir. I have OO (C#) baggage but it didn't translate to elixir. It forced me to work through the functional stuff. I think that helped me transition a bit easier.
You can try to build directly into XEN: - http://slides.com/technolo-g/intro-to-unikernels-and-erlang-on-xen-ling-demo#/ - http://elixir-lang.org/blog/2013/05/02/elixir-on-xen/
I know it was July in 2014 and July is getting closer and closer so I'm starting to wonder if it's been announced and I just haven't heard about it yet or if it hasn't been announced yet.
ElixirConfEU just wrapped up a couple weeks ago in Kraków, Poland. ElixirConfUS, will be back in Austin TX this year October 1-3.
I do this and it works fine. The one caveat is if you'll run into trouble if you need to connect to distributed nodes using epmd. I've been using https://github.com/trenpixster/elixir-dockerfile as a base image, although it is a bit large.
https://twitter.com/jimfreeze/status/517507407883161600
[**@jimfreeze**](https://twitter.com/jimfreeze/) &gt; [2014-10-02 02:52 UTC](https://twitter.com/jimfreeze/status/517507407883161600) &gt; One year from today, Oct 1-3, 2015, ElixirConf 2015 will be in Austin, TX. &gt; &gt; Mark your calendars now! &gt; &gt; \#myelixirstatus ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Since we can use exrm and basically quite easily get Erlang, Elixir from ubuntu repos, is there any advantage to doing this? It seems like it would be really nice to basically build my production environment on my dev computer, then just run it on an instance, but it sounds like if I need it on a few nodes I'll need to set it up manually anyway
Hey!
Depends on your environment. I do development on OSX and then deploy to Linux; my locally compiled application won't run on the server, I would have to recompile it and do the exrm release remotely. By wrapping the release process in Docker I can verify that the compiled application still works as expected before deploying, and I don't have to maintain a separate build server to cut new releases.
It's for you.
I think /u/houshuang meant: defp get_all_top_posts(lst), do: Enum.map(lst, &amp;(get_top_posts/1)) Which applies get_top_posts/1 to each element of the list instead of manually recursing. Alternatively: defp get_all_top_posts(list), do: get_all_top_posts(list, []) defp get_all_top_posts([], acc), do: :lists.reverse acc defp get_all_top_posts([h|t], acc), do: get_all_top_posts(t, [get_top_posts(h)|acc]) At least in Erlang, it's considered bad form to use ++ for recursive list construction (it used to prevent TCO and had bad performance for long lists, although I don't think either is the case anymore). It's more idomatic to cons the list into an accumulator and then reverse the list in your base case, but as you can see, using the map abstraction is just easier.
This is some neat stuff, looking through it now. Interestingly enough, my first Elixir project started out as an RPN calculator and it eventually turned into an expression evaluator. It's located [here](https://github.com/Rob-bie/expr) if you're interested in taking a look!
UPDATE: The logs on the server read that the content is being served in ~20ms. Noticed a flaw in my design and tweaked the code to save the compiled HTML on the Database instead of compiling it on every page show and now the logs show render times of ~9ms. Sweet. I guess any overhead must come from network latency.
It's a slippery slope, isn't it? haha I am going to add nested loops soon, they currently don't work. just waiting on some free time, but I have an idea on how to make it work
I believe @tjking is right. This is more idiomatic in Elixir (AFAIK): initialList = [1] newList = [2 | initialList] And at the end, you just reverse the list (i. e. Enum.reverse(newList) ) if you need to do so. This is because adding at the front of the list is O(1) while adding to the end of the list is O(n) (again AFAIK). 
Keep up the great work, I've built a killer api in phoenix and it was a pleasure to do.
Sure, I'm familiar with both of those projects. I was just trying to ask how it compared to Dynamo. Dynamo was the first web framework for Elixir I used (maybe the first one ever written?), and is also broadly comparable to Sinatra in the way endpoints and responses are defined. It's in "maintenance mode" now, so I have been hoping for something to replace it.
if you announce a new open source project, it's probably a good idea to have all your documentation written already, so folks can read it and decide if they like it. Pointing a github repo with an empty README is probably not the most efficient way to get the word out.
Phoenix is the replacement for Dynamo for all intensive purposes to me. You got the majority of the community using, backing, and supporting it. IIRC, the ideas that came out of dynamo created plug. You could use plug to stand up your own microframework. This is also how some other libraries are able to run on their own or plug into Phoenix.
How is this or planning to be different than https://github.com/lpil/clint? There is also https://github.com/falood/maru and https://github.com/sugar-framework/sugar
@into_lexicons honestly this is the first time I hear about Dynamo. I read about it and I can say Spirit and Dynamo share the same idea. I started this project as an experiment and to give my first steps on Elixir. But actually I want to make it my default framework in the future, so I'll work hard to make it a nice framework :)
Agree. My bad, I was really excited to start using it and make it public that I didn't realize how much work do I need before publish it. Tonight I'll improve the README!
I started this project with the idea to get involved into elixir world! So the plan is to learn elixir by myself. Now, the future of the project seems very similar to `clint` so I should keep an eye on that project and try to contribute to the project. Right now I'm not confident to contribute to `clint` or any other project because my expertise on elixir is 0. Instead, I want to learn elixir, update and fix `spirit` by my own (and accepting contributions) until I can start contributing to other projects. When that time arrives, I'll know what to do with this project.
Thanks for the explanation! Hopefully this will be a great learning opportunity for you, so that you can eventually merge your ideas into other projects or collaborate more closely with others!
If you don't care about or don't know the timezone, I think it is better to use NaiveDateTime than DateTime with UTC. Otherwise imagine some code where you have DateTime struct with UTC and a new programmer finds it and say: oh, we have the DateTime in UTC great. Let's shift it to the user's timezone and display it. But really it was just a programmer cheating and saying a datetime was in UTC when in reality he did not know which timezone it belonged to. I could imagine some situations where you do not know the timezone of a datetime and still want to do something with it. For instance if you have some existing data in an old database and you are not sure of the timezone. And you just want to format it differently. You can use the NaiveDateTime module for that.
If you have a datetime in UTC vs a localized datetime, then by definition it doesn't matter what the original timezone was. Let's say a programmer saves a local datetime as UTC on accident though (which really should bring up a question of how the API allows that to happen easily), and then later realizes they actually cared about storing localized datetimes, it would be trivial to write a script to run through each datetime, and assign it to the correct zone based on the desired locale and the datetime in question. I would expect this mistake would be identified fairly quickly as a bug depending on how that data is displayed to the user (i.e. you create a record and see the creation date as being in the future). In the end though, while the programmer could create this situation, it's also one that is fairly straightforward to remedy. By making sure the creation of dates in either universal or local time is explicit via the API, I would guess this mistake could be avoided in general, but there will always be opportunity for the programmer to handle a datetime struct incorrectly - at least without a strong type system to protect against it. If you are unsure of the timezone of some old data, but want to display it, at some point you will have to choose a timezone for that data, because there is no other way to represent it to a user in their own timezone (i.e. shifting it). It seems to me like it's important to put the burden on the programmer to determine that property about their data rather than ignoring it. Perhaps there are cases where that's asking too much, but the two you mentioned don't feel like a good fit for that. I don't necessarily think it's a bad idea to have NaiveDateTime, just that I think it's extra cognitive burden for your libraries consumers, when I think the real answer to the question of "NaiveDateTime vs DateTime" is asking "what data are we working with, and what properties about datetimes in this data do we know and/or need to determine before coding this up". To use an example from my day to day work, C# DateTime objects are always created as localized datetimes, unless explicitly created with a different timezone, or as universal. There is no option to treat a DateTime as "zoneless", you must always decide what zone it belongs to, if you want your code to do the right thing anyway. I happen to think this is a good approach, but I understand that some may not agree with that sentiment. Anyway, I liked your article, just thought I would throw my two cents in, since I've been down this road myself.
My thoughts... 3) Check this out for some cool stuff with Phoenix/React/Flux, if you've not seen it already - https://github.com/fxg42/phoenix-flux-react 4) I'd assume it will take quite a bit longer for an experienced Rails dev to build something in Phoenix. But that should be expected as there is quite a paradigm shift. If you're doing a basic CRUD app, I'd suspect that 'quite a bit longer' can be smaller than something that deviates from the basics.
I have only used Ecto with Phoenix for ORM and it's nowhere near as feature-complete and mature as ActiveRecord and that alone is enough to turn me away from Phoenix for now because many of the projects I work on are very data-relation-heavy. That plus your answer to question 2), AFAIK, there are no solutions remotely comparable to Devise which is kind of funny considering who is behind both Elixir and Devise :) He probably didn't feel like rewriting the same thing twice? ;) That being said, keep following Elixir and Phoenix, they are getting better at a great pace so this will soon be a completely outdated viewpoint.
I'd say that's to be expected with a new language. Projects for new languages are often in house and smaller. And, in my opinion, they're more "Bring Your Own Friends." (But your tenacity is noted ;-))
While I can see the appeal, I am not convinced that it is a good idea to "force" programmers to *always* use timezones. &gt; It seems to me like it's important to put the burden on the programmer to determine that property about their data rather than ignoring it. It is not always "the programmer's data" so the speak. It could be imported from an external source. &gt; If you are unsure of the timezone of some old data, but want to display it, at some point you will have to choose a timezone for that data, because there is no other way to represent it to a user in their own timezone (i.e. shifting it). Well then don't shift it. It is not always a good idea to be clever and manipulate data before showing it to users. As a user it is likely that I prefer to see the original data, rather than something that has been arbitrarily manipulated. What if you have a legacy database with datetimes with different timezones? You know they are from different timezones, but not exactly which ones. Forcing them all to be the same timezone would be worse. I think legacy data alone is reason enough to keep the NaiveDateTime type. &gt; To use an example from my day to day work, C# DateTime objects are always created as localized datetimes, unless explicitly created with a different timezone Using "local time" and it being the default is something I think is a bad idea. I have a new blog post about that in the works :) &gt; Anyway, I liked your article, just thought I would throw my two cents in, since I've been down this road myself. Thanks.
You could have said the same thing about Ruby before RoR. 
That was the situation with Ruby 10 years ago when I managed to get involved with a paying Rails job (and this was even before Rails 1.0!) That seems to have worked out well for me. The paying jobs of tomorrow will be using different things than the paying jobs of today. Always look forward and push for the new stuff. Elixir/Phoenix are making faster tracks than I've seen in many other projects, and I've been doing this for 20 years.
I am going to take a look at Elixir/Phoenix..
1) Yes, Elixir provides mix and hex (http://hex.pm) 2a - auth) No complete solution, but some in the works 2b - assets) Yes, complete with live reload of templates/css/js, powered by http://brunch.io 3) Easy peasy. I am even considering shipping a `Phoenix.Flux` implementation that integrates with channels 4) If we ignore available off the shelf software and just what comes with the framework, we should be just as productive. We offer realtime push out of the box, which Rails 5 is promising, but hasn't shipped. We also offer conveniences like live reloading which Rails does not have. Off the shelf software can't be discounted in real life though, so the Ruby ecosystem is obviously ahead here, but high quality packages are coming to hex.pm at a steady rate. That said, we can go the other way and say that Elixir provides supervision and distribution for free. We can also block in controllers and parrallize work during requests where rails we have to jump through background worker/client polling hoops. Also with Ecto's repository pattern, we can easily setup master/slave reads. My ElixirConfEU keynote is worth a watch if you haven't seen it: https://www.youtube.com/watch?v=u21S_vq5CTw Hope that helps!
[Dave Thomas](http://pragdave.me/) agrees with you and developed an alternative to standard function definition syntax called [mdef](https://github.com/pragdave/mdef).
Straight from the horse's mouth (so to speak)! :)
We've been using Semaphore for building our Elixir projects for several months now (it's been *unofficially* supported since sometime last fall) and have been very pleased with it.
I've got this set up and working after installing the pg_trgm extension on postgres, but there needs to be a way to set the default matching threshold for %. It defaults to .3/1, but this may not be right depending on how you are using it. 
This seems to be a good idea, but would it be possible to send fragment(set_limit(?), 0.12) within the query to set it? It would actually be ideal to specify the limit on a query by query basis. I haven't tried the above, but I know checking similarity for things that are 30 characters long requires a minumum of 10 characters to match the default, while something 9 characters can match with 3. 
Thanks so much for this /u/TheStoneFox, one of the most helpful guides I've read in the Elixir community thus far. If anyone is looking for a use case: web scraping is a great one. Writing a scraper that runs in parallel is so easy with Elixir that it is also incredibly easy to accidentally DoS the site you are scraping by say running each request in a seperate concurrent process. Keeping a pool of task workers like this allows you to set a maximum amount of allowed workers and therefore (as each one runs serially) outgoing concurrent connections.
Awesome, thanks so much for sharing this! Is it easy to add user authentication in Phoenix? Is anyone working on a library like Devise? It's a super common problem, almost everyone these days needs to support Facebook and email+password login, and provide tokens for API access. I'm really keen to start using Elixir/Phoenix as the backend for my iOS and web app, but I don't know if it's ready for that yet.
I would really like to read about more interesting projects that leverage Elixir/BEAM's strengths more fully then YAWF (yet another web framework). Seems like all that gets posted here is people building web sites or services with Phoenix or some other web-related thing.
Just on first glance, I think the separate functions with guard clauses are the preferred way of doing things in elixir. The only thing that jumps out at me is using strings to indicate different actions ("delete","splice"), where this is normally done with atoms (:delete, :splice)
I really need to research json web tokens. I keep hearing people talk about them but have never really looked into it. Thanks for the tip! 
The atom thing makes sense. I don't write Ruby as much as I used to, otherwise that convention would come more naturally to me now. My main concern is the ridiculous amount of logic duplication here. You'll notice the separate list and string functions are logically identical, I just am having to use slightly different versions of the same functions for each :\
Nothing stops me in Phoenix from spawning and doing things like having additional node processes supervised from within phoenix. It looks like YAWF, but you still have both erlang and elixir at your disposal and can fully take advantage of BEAM, just with a pretty packaged entryway for newcomers. 
I suppose one option would be to require an `Enum` of some kind, rather than supporting strings, but I'm concerned that `String.to_char_list` on large strings might be expensive.
Have a look at https://gist.github.com/tallakt/75b856cc443e15e9718c Some stuff I did (maybe not all relevant/correct, and still untested): - converted the string to a list so no need to duplicate all functionality - replace strings with atoms - refactored most functions to use a private do_splice function - Simplify and optimize by using Enum.split and Enum.drop instead of chunk - I prefer not importing the Enum functions, rather just spell them out. - I would probably also rename the whole function to just `apply` instead of `apply_component` The thing with atoms vs strings is that if the operations are coming from the network, then you probably still have to use strings. So that depends on your application. Depending on the size of your data you could consider using streams instead of lists as well. This could reduce the memory consumption at a slight cost in execution time.
Thats possible I guess, I think the only error on restart would be adding the handler. Which would cause the server to crash and bubble up to the Supervisor. The handler wouldn't crash immediately, it would need to receive an event first. But I'd definitely be interested in a way to use a supervisor to add the event handler instead, I'm just not familiar with a way to do that. So I proxied it through a minimal server.
[**@finfoil**](https://twitter.com/finfoil): &gt;[2015-05-18 10:56:54 UTC](https://twitter.com/finfoil/status/600253725215760384) &gt;An adventure in 3D printing [@ElixirConfEU](https://twitter.com/ElixirConfEU) &gt;[*evercam.io*](http://www.evercam.io/blog/elixirconfeu-2105-an-adventure-in-3d-printing/) &gt;[@marcoherbst](https://twitter.com/marcoherbst) [#elixirlang](https://twitter.com/search?q=%23elixirlang) [#josevalim](https://twitter.com/search?q=%23josevalim) [#3dprinting](https://twitter.com/search?q=%233dprinting) [*pic.twitter.com*](http://pbs.twimg.com/media/CFSHlP1WoAE5E2y.png) [^[Imgur]](http://i.imgur.com/oBt8wUS.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/36hj0s%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Here is an example application: http://github.com/citrusbyte/spirit-example
Hey Elixir! I've been programming in Ruby for about 4 years now but am completely new to Elixir! So I thought what better way to learn than to write about it as I go. I'm loving the language so far. It's great to get my brain thinking in terms of immutable data. I haven't gotten into the OTP and more advanced concepts of Elixir yet... hopefully soon!
Hey thanks for sharing this article. I'm also exploring Elixir language and loving it so far. Being a long time Rubyist, Elixir just feels next level of it. 
Great explanation. Although other methods may be faster, json formatted tokens with base64 payloads are really the best thing to use if you intent to make your API public- just for standards and simplicity. What is also nice is that if you are building a SPA, which is the main purpose of my APIs, you can decode the payload if you need it in the javascript. 
Here's yet another approach, also includes a self-incorporated unit test suite (sometimes I get lazy, and this is easier for one-off style code experiments) This version is even more pattern-matchy. Which I think I like. It basically expands out/"unrolls" all the possible states this function can get as input. defmodule FizzBuzz do def fizzbuzz(n) when is_integer(n), do: fizzbuzz(n, rem(n,15)) def fizzbuzz(_, 3), do: :fizz def fizzbuzz(_, 6), do: :fizz def fizzbuzz(_, 9), do: :fizz def fizzbuzz(_, 12), do: :fizz def fizzbuzz(_, 5), do: :buzz def fizzbuzz(_, 10), do: :buzz def fizzbuzz(_, 0), do: :fizzbuzz def fizzbuzz(n, _), do: n # this is more like the ruby style but takes literally like 15x longer (!) # def fizzbuzz(n) do # out = "#{if rem(n,3)==0, do: :Fizz}#{if rem(n,5)==0, do: :Buzz}" # if out=="", do: n, else: out # end def run(i \\ 100), do: (1..i) |&gt; Enum.map(&amp;fizzbuzz/1) def test do unless run(15) == [1, 2, :fizz, 4, :buzz, :fizz, 7, 8, :fizz, :buzz, 11, :fizz, 13, 14, :fizzbuzz], do: raise "something is wrong in #{__MODULE__}" end end FizzBuzz.test FizzBuzz.run 10000000 For comparison here's a Ruby implementation. On my machine, this one takes 3.4 seconds; the Elixir one takes 2.6 seconds, for assembling an array of 10 million fizzbuzzes (using symbols/atoms)... module FizzBuzz def self.fizzbuzz(num = 100) result = [] 1.upto(num).each do |n| result &lt;&lt; case n % 15 when 3, 6, 9, 12 :fizz when 5, 10 :buzz when 0 :fizzbuzz else n end end result end def self.test raise "something is wrong in FizzBuzz" unless FizzBuzz.fizzbuzz(15) == [1, 2, :fizz, 4, :buzz, :fizz, 7, 8, :fizz, :buzz, 11, :fizz, 13, 14, :fizzbuzz] end end FizzBuzz.test FizzBuzz.fizzbuzz(10000000) edit: why downvotes? :(
Awesome!! I think the more I work in Elixir the more ideas like this will come to mind... I'm still very much in the mindset of "How do I do what I'd do in Ruby, in Elixir".
Cool, everyone here is fancy! When I solved this problem when I first picked up the language this is how I did it: defmodule FizzBuzz do def fizzbuzz(n) when rem(n, 15) == 0, do: "FizzBuzz" def fizzbuzz(n) when rem(n, 05) == 0, do: "Buzz" def fizzbuzz(n) when rem(n, 03) == 0, do: "Fizz" def fizzbuzz(n), do: n end and: iex&gt; Enum.map(1..100, &amp;FizzBuzz.fizzbuzz/1) It's definitely not exciting and whether or not it's idiomatic Elixir is debatable. Using '03' and '05' are just to pretty it up a little.
Thanks for sharing, and thanks for the organization for recording everything :)
Another version of FizzBuzz--this time attempting to use multiple processes (for what it's worth): http://codereview.stackexchange.com/questions/57034/multi-process-fizzbuzz-in-elixir Code for those who don't care to follow the link :) defmodule FizzBuzz do @fizz_buzz 15 @fizz 3 @buzz 5 @default_timeout 60_000 def getFB() do receive do {pid,n} when rem(n,@fizz_buzz) == 0 -&gt; send pid,"FizzBuzz" {pid,n} when rem(n,@fizz) == 0 -&gt; send pid,"Fizz" {pid,n} when rem(n,@buzz) == 0 -&gt; send pid,"Buzz" {pid,n} -&gt; send pid,"#{n}" after @default_timeout -&gt; raise "Timed out" end getFB() #Keep the process alive end end Used like so: fbPid = spawn &amp;FizzBuzz.getFB/0 send fbPid,{self(),15} receive do r -&gt; IO.puts(r) after 1000 -&gt; raise "Timed out" end But do check the link because Uri Agassi took my weaksauce and made it into a very cool example of using GenServer.
This is how I would do it. This is the 'elixir way' instead of the translated from ruby way. 
Nice!
I feel this is less functional than using mod and div. You're relying on the state of the streams, and using them has side effects.
I'm glad it was helpful! I wrote it because I was in need of using a background worker and I was struggling to cobble together examples and tutorials of how to do it. It was heavily inspired by sasa [https://github.com/sasa1977] and his blog post http://www.theerlangelist.com/2013/04/parallelizing-independent-tasks.html which really helped me out a lot! I'm hoping to extend the repo at some point to include how to test Poolboy using ExUnit (when I figure out how to do it!)
Um, don't we already have this plus suspension via Enumerable.reduce? Am I missing something?
Thanks for this! Seems to fix a few of the minor troubles I was having with it.
That's great to hear :) Thanks!
I believe the article describes the rationale behind Enumerable.reduce
You're making it very hard for people to use anything other than emacs =).
Enumerable is the long-to-write protocol name which most people don't interact with while the shorter Enum is the faster, easier collection of user-friendly functions which work on Enumerables.
haha sorry for that ;-)
bought one, thanks
I'm trying to talk our lead programmer into letting me build an microservice for our company in Elixir/Phoenix, rather than Scala like all of our other new microservices. I think this article goes a long way to helping me convince him.
&gt; The people who will win are going to be the ones who embrace changes in technology. I don't think it is that simple. 
It's actually ["For All Intents and Purposes"](http://en.wiktionary.org/wiki/for_all_intents_and_purposes)
Keep up the good work!
This is the first significant Elixir code I've published. Logfmt is a module for decoding [logfmt-style log lines](https://brandur.org/logfmt) into maps. It can also encode a Dict implementation value into a logfmt-style log line. A few things I'm trying to figure out: - Is my thinking around decoding into maps and encoding any Dict value correct? - How can I integrate this with the Elixir/Phoenix loggers? - Did I go too crazy with `@spec`? Dialyzer gives me a few overlapping domain warnings. - What's the right way to handle unsupported types in [`encode_value`](https://github.com/jclem/logfmt-elixir/blob/dec01c9765b31fbecc376d1afda624813c46f553/lib/encoder.ex#L17-L26)? Right now, encoding a map that has a map value somewhere will just raise an error. For reference, here are some other Logfmt implementations: - [Go](https://github.com/kr/logfmt) - [Clojure](https://github.com/yeller/logfmt) - [Node.js](https://github.com/csquared/node-logfmt) - [Python](https://pypi.python.org/pypi/logfmt/0.1) - [Ruby](https://github.com/cyberdelia/logfmt-ruby)
Neat way to show off streams! Here's my own (more complicated) "streaming fizzbuzz" from 2 months ago: https://github.com/pmarreck/elixir-snippets/blob/master/streaming_fizzbuzz.exs
Basically you just have to code in such a way that TCO is *not* prevented from occurring. The issue is that the naive approach prevents TCO from occurring so it takes a little more thought.
I ran into this the first time I used it as well, but in retrospect it makes since. Maybe the CLI output should emit a warning instead of a message to increase visibility?
That might help, on the other hand most people will run into this issue exactly once, so it is probably not that important. My problem was that I googled first instead of reading the error output :)
You can try using [Vagrant](http://vagrantup.com) for development, I'm not sure how well it works in Windows but you can use https://github.com/jveiga/vagrant-elixir to set up a vm with erlang and elixir working out of the box
the troubles you'll have with learning system environments will have to be learned at some point anyways as you'll almost certainly be deploying to a unix machine. I'd suggest getting it working on unix and work though one problem at a time. It will be required knowledge for much of the software you'll build in the future. Also, dev'ing in a VM won't change the fact you need to understand unix to get your env setup right.
I develop elixir on a windows box, and have no issues so far. Elixir/phoenix/postgres, with Sublime &amp; elixir linting.
If you have a decent system you might be able to run a clover vmware image in windows and use that. It's an option if you like developing with OSX
ಠ_ಠ
That risk is greatly reduced by the fact that the underlying platform, Erlang/OTP, is extremely mature and extremely well tested for reliability.
I know it's not what you asked for, and it might come across as slightly negative (it's not, I love Elixir) but some arguments against using it that you'll hear, and you'll need answers to are: * We have no experience with Elixir, and we have K yrs experience with X - it's too risky. Why should we risk that? * What other things that I've heard of are written in Elixir? * It's too new - where will we find more developers if we need them? * It's too new - there's no pre-built library to do X where X is critical to the project (think db drivers for obscure/unpleasant DBs), how would we proceed? All of these have obvious valid answers, but best to be prepared :) 
It depends on how skilled a developer you are and how much clout you have with the people who depend on you. Projects like this frequently end up with a growing scope. Can you handle writing anything for functionality you can't find a library for?
Good code. Good docs. Nothing to complain about here. :) To integrate to Elixir's logger you just have to write a new Logger backend. You should be able to modify the built in [:console Logger backend](https://github.com/elixir-lang/elixir/blob/master/lib/logger/lib/logger/backends/console.ex). Then try it with this. Logger.remove_backend(:console) Logger.add_backend(Logfmt.LoggerBackend) I had started adding this to [Hexoku](https://github.com/JonGretar/Hexoku) but never got round to finish it.
Author here. This is a little more heavy on Ember.js than Phoenix (since the Phoenix generators do most of the work for a simple CRUD backend). It's pretty basic but thought it might help others get started with this new "PEEP" stack!
Rails is probably the easiest backend to use Ember with, in my (pretty limited) experience since there is a pretty big overlap in community. Rails seems to be increasingly used as a backend along with something like Angular or Ember. Rails 5 will include [an option](https://github.com/rails/rails/pull/19832) for excluding the view-related libraries so that it only includes stuff necessary to make a backend API. My feeling is that if I only need a backend, I would rather do it in Phoenix since it will likely be faster (and I'm increasingly liking Elixir more than Ruby) but the community and documentation built up around Rails makes it definitely more approachable for beginners.
There are lots of companies already using it in production! :) We're talking to some of them and documenting their use cases, as you can see in that blog post. I recommend watching this talk about using Elixir and how risky it is or it's not to use right now: https://www.youtube.com/watch?v=_i6n-eWiVn4
I guess I don't know if Phoenix supports it yet or not, but you should use chunked requests for things like this, that way you can support arbitrarily large file uploads.
&gt; Ruby on Rails emerged in the late 2000s and has grown incredibly popular as an all-inclusive framework for making web applications. A little pedantic, but it was mid-2000s - specifically 2005.
The biggest benefit that elixir/erlang have over the JVM is immutability and the supervision tree (otp) being very well integrated into the entire language. Even though you may have library X in Java but not in Scala, it won't have the supervision system and immutability constraints where you would have them in the erlang VM. Each Java library is a risk, they are not meant to be used that way in my opinion. Introducing a library meant for the Thread model into Scala's Actor model of concurrency can lead to severe and devastating results. The Actor model depends on immutability. Scala is as fully capable of performing the task you want. If your app can stick to just scala ready libraries, and you have a Java/Scala team already, unfortunately you dont have much firepower to argue for Elixir. I'd research that you have the tech you want to utilize Elixir because it is still new. For example, if you plan on using Ecto but against a DB thats not yet supported, maybe Elixir isn't the best choice then after all.
Writing elixir is easy, once you figure it out. I'm an experienced c and php coder, and those are not easy to build something large and dependable. Elixir libraries are not so complex to write if you avoid things like macros which tend to obscure functionality from your team mates. All the other benefits are available in some roundabout way in most other languages, but it wont be pretty or easy. 
Cool stuff, I'm nearly done with a complex accounting app using durandal as a spa front end. This has inspired me to try out an Aurelia front end on my example api. I will share when done!
We are building a Ember + Phoenix app at our local meetup right now. This is good info thank you. Have you done anything with channels yet? I have started writing a service but, think some of it could end up being in a adapter. Curious if you have tackled this yet.
Heh, did you just introduce "PEEP"? It's catchy! My next project will be with the "PREP" (React) stack, though, I think. One comment: I'm pretty sure you can get away with just plain `web: mix phoenix.server` in your Procfile, as long as you're on Elixir 1.0.4 and you have build_embedded: Mix.env == :prod, start_permanent: Mix.env == :prod, in `project/0` in your `mix.exs`. I tested this on Heroku, sticking `Protocol.consolidated?(Inspect)` in my logs to ensure protocols were consolidated, and they were.
Phoenix is built with elixir macros, I don't think it is at all heavyweight in the way that traditional framework is. In fact, in testing it against straight plugs in cowboy server, there is little to no difference in response speed that I could see. YMMV. 
Start with Plug, then see what Phoenix provides. Then test performance.
Plug is great. Check it out :)
[Take a look at trot](https://github.com/hexedpackets/trot), a micro framework I recently put out. The intention is to wrap plug in a very light way and provide some useful conveniences. The end result looks sort of Sinatra-ish. I'm always open to suggestions if you think something's missing from it!
Phoenix may be heavy as far as codebase goes, but performance wise, you're already ahead of most frameworks. If that's still too much and your use case would fit something like Sinatra, you could always just use raw Plug on top of Cowboy.
The suggestions have been good. When I say "heavy" I don't mean that Phoenix is necessarily slow performance-wise. It just has a lot of things that I don't need for this project is all. Looks like I will start with Plug and then move to Phoenix if/when required.
Hey Folks, Let me dispel a few myths in this thread. Phoenix is not heavyweight, and its codebase is by no means heavy. Please have a look through the source: https://github.com/phoenixframework/phoenix We get many comments from people reading through the source who are shocked by how little code it takes to support our featureset. We also keep the core slim, so things like HTML templates are in a separate phoenix_html project. "Learning tons of DSLs": Phoenix's routing layer is the only DSL you'll find today in the framework. While you do need to learn a couple of our conventions, its "Just Plugs" all the way down. There is very little magic happening. What I usually tell people is this, if you want something as light as possible, Plug is the way to go. Plug is closer to Sinatra than it is Rack. It provides things like it's own routing DSL for example. Apart from that, I really don't see anything fitting b/w Plug and Phoenix. Plug gives you enough to get bare-bones web going, and anything further you'll arrive at what we have in Phoenix. Hope that helps
Sound reasoning. You want a bowie knife not a Swiss army knife :-)
Well it isn't really about the DSLs since Plug also uses a DSL. But it is somewhat about figuring out how everything works from the ground up, yes. Phoenix doesn't look all that complicated but I do feel I will have a better understanding of what Phoenix does when I do eventually use it if I've used Plug beforehand.
This is basically my reasoning.
Silly question I guess but have you looked at the Getting Started stuff on the Elixir website? It's pretty good to start with.
I believe there is a group offering training elixirmastery.com. My company has considered offering training as well.
I'm already started with it, probably past what could be offered in a short course. I'm interested in getting the language out in production environments and into devs hands!
I like Maru (https://github.com/falood/maru). It's like grape.
It feels a little odd having it as two different deployments, is there a concept of building a "release" of ember that could be served statically from Cowboy on /? Is there a reason it was intentionally kept as 2 separate apps /u/strengths?
It's too early... for some. For example, I'm currently writing a connection-throttling Plug. It's surprising that such a thing doesn't exist yet as Ruby/Rails probably has like 10... But such is life in a new ecosystem. But I think slides like this (cited in the OP article) are a good sign, because every good advance seems to also be a simplification of sorts: https://mobile.twitter.com/dliggat/status/591678168534134785
That does look rather nice. I am not 'there' yet.
Your skepticism is warranted. But so would keeping an eye on it be. ;) The Dave Thomas book on Elixir is awesome, btw
Not sure. The one you got wasn't yet available at the time and the Dave Thomas one taught me all I needed to know to get started. I was already familiar with Dave Thomas as his famous "Pickaxe" Ruby book originally got me into Ruby so I followed him right into Elixir territory lol.
Hey, I'm the author, thanks for sharing this :D. 
Sorry for the OT, but /u/ABC_AlwaysBeCoding, are you on IRC on #elixir-lang? I'd like to talk about the connection-throttling plug as I'm writing something similar myself, it would be great to know how it's going :).
The content type is specified in the headers. You don't need to be wasting billions of cycles auto-guessing at it. Just read the header. In the example you gave, it specifically says what you're expecting: Content-Type: text/html;charset=ISO-8859-1 From that info, you can decode the binary data into character code points and do whatever.
Yep! "pmarreck" I haven't written much code yet actually, I was literally studying Plug architecture and the source code of various existing Plugs just yesterday. Happy to collab or contribute, repeated effort is silly
Thanks for the hint! Since I'm fairly new to elixir/erlang, may you provide a code snippet that converts a given binary to a proper utf8-string when i know what the source encoding is? :)
Thanks, that's encouraging. 
[**@FrancescoC**](https://twitter.com/FrancescoC): &gt;[2015-06-12 16:48:45 UTC](https://twitter.com/FrancescoC/status/609401964200378368) &gt;And the winner of the 2015 Erlang user of the year is Jose Valim 😀! Congratulations!!!!!!!!! [*pic.twitter.com*](http://pbs.twimg.com/media/CHUH2fgWwAAv9Ei.jpg) [^[Imgur]](http://i.imgur.com/4BTeX8P.jpg) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/39m6n4%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Windows gets bad press but most major software packages run pretty well on Windows - it's when you start running third party libraries you hit problems.
seems like quite an endorsement of Elixir from the greater Erlang community.
Thanks. Based on what you wrote, I think I'm on the right track; I'll refine my understanding as I go :)
You're welcome! Have fun :)
LeHoff is teaching a group of danish elementary school children (13-14 year olds) Elixir. You can follow his progress and teaching material here: http://beamster.org/jb/index.html
Sounds like fun! Checked it out, maybe i'll follow it myself too! Thanks
I think its a great idea, except that when they encounter other, mutable, non functional languages in the future they will have a high WTF factor. I'm a php dev originally, and elixir has raised my WTF factor when looking at php and javascript- and I'm now disgusted looking at php and javascript- even if it is, by all definitions, well formed. 
Elixir has a really fun way of making command-line apps and reading in a text file, doing transformations, and spitting it back out. I know a ton of languages do stuff with files and CLI, but Elixir was the first one I ever had success with. Not as "cool" as graphics, but great problem-solving.
Be sure to tell Torben about your experiences with the material :)
This is pretty great, thank you :)
I'll say this as a fan of both Elixir and Ruby: Ruby can do (mostly) more than Elixir can. You can program in a functional style in Ruby to your hearts' content... you can also store state inside objects. There are no objects in Elixir (well, not in the OO sense at least), and it tries as much as possible to get away from storing state... and I'm convinced (after 20 years of programming) that this is a Good Thing™. In Ruby, you won't get pattern-matching/guard clauses (which eliminate a lot of bug-creating conditionals right off the bat) and you won't get easy lazy evaluation. In short I don't think this is a great analogy.
Good tips!
Glad you're finding `mix test.watch`useful! It's just a wrapper around a couple of excellent libraries, and the source can be found here -&gt; https://github.com/lpil/mix-test.watch
I don't like javascript as a first language- it has too many quirks that make it difficult to understand.
Thank you for the auto-completion and jump to definition functionality, it saves me a ton of time in my day.
Oh snap! That's AWESOME. THANK YOOOUUUUU
Just assume that each mutable variable in those languages is actually a function with a hidden time argument. :P
You don't need to take advantage of the concurrency or fault tolerance to experience the other benefits. I have been doing Elixir for a little while to warm up and have barely touched the concurrency or fault tolerance... but everything else is sweetness too
Hi Alchemists, Working on a new startup and basing as much as I can of it on elixir/phoenix for our infrastructure and our IoT device, with the usual IOS/Android/etc suspects for our apps. Distributed system, message queuing, a lot of networking and working within some time constraints for processing requests. Fun times, difficult problem to solve, and great things to build. Small team, with two previously successful founders in the lead and taking funding and starting some aggressive hiring in the very near future. We're located in Atlanta, and probably not interesting in anything remote for the first hiring surge. If you're interested send me a message, would love to talk more about the opportunity in a week or two.
Plataformatic is an elixir sponsor yet they haven't made a devise port for Phoenix yet :(
Great writeup. Thank you.
This is extremely difficult to read, what are you trying to do? Something like this? defmodule My.Macros do @pairs [foo: 1, bar: 2] for {key, val} &lt;- @pairs do def get(unquote(key)) do unquote(val) end end end Could you type out a small example the code you are trying to generate please? 
I edited it to provide the code the macro is supposed to generate.
I had a go, but I couldn't quite get what we're after here. defmodule My.Macros do @pairs [ foo: 1, bar: 2, ] defmacro create_translate do pairs = for {k, v} &lt;- @pairs do quote do unquote(k) -&gt; unquote(v) end end |&gt; List.flatten quote do fn str -&gt; case str do unquote(pairs) _ -&gt; "" end end end end end This results in this {:fn, [], [{:-&gt;, [], [[{:str, [], My.Macros}], {:case, [], [{:str, [], My.Macros}, [do: {:__block__, [], [[{:-&gt;, [], [[:foo], 1]}, {:-&gt;, [], [[:bar], 2]}], {:-&gt;, [], [[{:_, [], My.Macros}], ""]}]}]]}]}]} What we actually want is this: {:fn, [], [{:-&gt;, [], [[{:str, [], Elixir}], {:case, [], [{:str, [], Elixir}, [do: [{:-&gt;, [], [[:foo], 1]}, {:-&gt;, [], [[:bar], 2]}, {:-&gt;, [], [[{:_, [], Elixir}], ""]}]]]}]}]} Not really sure where that extra `:__BLOCK__` bit is coming from- I'm rather new to macros too. It seems like an odd thing to build with a macro. You're writing more code than you would if it were a literal anon function.
ExCheck is really cool. Property based testing is excellent, and this library does a great job of it thanks to the underlying triq library. I think it really falls short when it comes to test output error reporting though. Your test output is muddied by the verbose output from triq, and when you do get an error or a failed assertion you get the error message back in verbose and difficult to parse erlang. Perhaps this can be resolved with a custom ExUnit formatter for the project. The output is also completely mangled if unless you set ExUnit to run with `async: false`, which sucks.
Huh, thanks. I knew pattern matching was a thing in module functions, but I did not know it was available in anonymous functions, that makes it much more readable. In my original problem I have a huge .txt file and inside of it there is a dictionary encoded. I want to parse the .txt file into some valid Elixir datastructure during **compile time**, that's why I chose a macro. I am not aware of any other way to influence what happens during compile time. You are right, that a module function would be preferable.
Alphasights are a really cool team, or at least the London guys are. I didn't know they did Elixir :)
&gt; I want to parse the .txt file into some valid Elixir datastructure during compile time, that's why I chose a macro. In which case, metaprogram regular functions, anon functions are only advantageous if created at runtime. This is how the unicode handling functions are created in the Elixir standard library.
Good arguments!
It expressed my feelings about Go fairly well.
Great blog post, and the right amount of persuasive!
I'm coming from Ruby too, and there I always rely on nil being falsey and use the shortcut. I wasn't sure about the convention followed in the Elixir community. I guess I'll start coercing to bool in my Elixir code from now on. Thanks for explaining that! :)
What did you end up picking here @robotempire?
:: bows to the Erlangers here ::
That latter case is the kind of crazy bug I'm afraid of which is why I think predicate functions should only return pure true/false values. I asked Jose Valim on the IRC channel and he concurred
Is this the release that has faster (at larger numbers of keys) Maps?
Yup!
This is a rather complicated area about which entire books can be written, but here is the gist of it. An OTP application's head is a special application process. Management of application processes involves a different set of options to describe what should happen when the application process crashes. (see the [Documentation](http://elixir-lang.org/docs/stable/elixir/Application.html) for more info). Generally this means either doing nothing, or crashing the whole node which can then be restarted by the OS should you desire it. This is all in line with the 'let it crash' philosophy. The way you protect against this sort of thing happening is you run multiple nodes, hopefully on separate pieces of hardware. Then one node crashing doesn't crash your entire service.
Elixir 1.2 will be compatible with erlang 18+ Elixir 1.1 - 17, 18+ José Valim - Keynote: What's Ahead for Elixir? E…: https://youtu.be/EaP0y4pdKD0 
Aah ok! So multiple nodes "reviving" each other in case of failure. Simple and brilliant. Thanks for the explanation!
I think by 'umbrella' you are talking about an 'application' as it is understood in the Elixir/Erlang world. When an OTP application is used in a project, it launches an Application process which supervises several other processes which do the actual work. These supervisor trees are essential to the most important parts of Elixir and while it can take some time and experience to grok them, they are the primary reason to use the language and VM. ExIrc seems to be set up like a fairly compliant OTP application. What you need to do is set up separate clients and event handlers for your 'listener' and 'whisperer' connections and then have the listener pass messages to the whisperer. How to do this is a bit involved, but a good place to start is the [documentation](http://elixir-lang.org/docs/stable/elixir/GenServer.html) on GenServer; pay particular attention to the bit about Client / Server APIs. If you really want to get moving on this sort of programming, I am unfamiliar with any Elixir-centric documents which are of an appropriate level. There is, however, the free and very good [learn you some Erlang for great good](http://learnyousomeerlang.com/content). You have to bend your brain a tiny bit around the Erlang syntax, but it will walk you through the concurrency model and how OTP processes work.
Has the codebase become overall simpler would you say? How are the effects on latency?
Would you say you're overall happier with this than the original? How do you deploy? That seems to be one area in Elixir/Phoenix that can probably use some love. I think it's funny (even if kinda cool) that some folks use Ruby's legendary Capistrano gem to deploy Elixir apps
Why is it funny? It's common to use Capistrano to deploy non ruby applications.
Ah. Coming from a Ruby background, I had no idea lol
Hmm, I guess its time to upgrade- I'm now three releases behind on a project I started in April!
Do you know what is on the agenda for 1.0?
I can't wait- I'm really thinking to step away from my personal project for a bit and contribute to get us moving there faster
Great post. I have the same setup. One note/question. Why do you install emacs via homebrew, and then later download it from the emacs for osx site? AFAIK the supported/suggested version to use with spacemacs is the homebrew one (just a mirror these days). 
Trusting in your users also means trusting a lot more than your users, like that they wont get their browser storage pilfered or what have you. Trusting the client side at all is just asking for security issues. Also if a user never really logs out, how does the session know how to get destroyed? That token may want to just live forever, and even if you set the expiration in the token, can you trust that? If you have a forever token, how do you revoke it? Storing the token for a given user in the DB makes revocation and regeneration of the token a lot easier and allows the server side to track what that token is allowed to do. If you associate a given token with a user and that user only has a set amount of perms, the server side can know that and disallow access to things even if the token manages to get rigged. [This is a pretty good read on token based auth for SPAs](https://stormpath.com/blog/token-auth-spa/)
The token cant live forever because it has a signed expiry included with the payload. It is destroyed when either the user logs out of the SPA, or when the browser tab is closed. I get that I cant specifically revoke a single user's token. The point of a signed token though is that it cant be tampered with and still have a valid signature. A malicious user couldn't do anything more than the person the token was stolen from can do, and would only have a short window to do it with a short expiry time in the payload. Edit: From the article, I understand that it should be stored in an https cookie, and not in my app where evil JavaScript can get to it. Other than being able to revoke individual tokens, I still don't see why I should store sessions in my database
You might want to watch this: https://www.youtube.com/watch?v=fLlItGWiVFc
I have been [working on some programming ideas and a few algorithms in it](https://github.com/pmarreck/elixir-snippets/) to get practice and I think it's great so far, although I haven't yet done a lot with concurrency.
AFAIK the homebrew version includes an .app located in /usr/local/Cellar/emacs-mac/emacs-XX-XX-X-mac-X.X/Emacs.app 
It's Q3 now, time for a new post?
Erlang on Xen seems to still be relatively active, but I think the lack of interest in general is due more to the fact that it isn't hitting a sweet spot for most users of Elixir and Erlang. If it's something you are interested in, I imagine it's not too hard to bridge the gap, but even releases/hot upgrades aren't nearly as popular as you'd expect, so I figure running on Xen is an extremely niche interest/need at this point.
Types are checked at compile time. Take this example defmodule TestMod do def somef(x) do IO.puts x &lt;&gt; x IO.puts x * x end end #TestMod.somef 2 TestMod.somef "feh" Compilation fails here, complaining about bad argument in the mathematical expression on line 4. But if you uncomment the call that passes a 2, the compilation failure changes to line 3, due to eventually a wrong argument in a deeper call. 
&gt; I think [until] we've got a more robust ecosystem of libraries There's the entire Erlang ecosystem to draw on, for starters. That's a pretty huge head start
Yes, but for typical web startup stuff ruby and similar have a big lead.
Your indentation is really messed up on that post. Also, why use a JSONAPI package when it's dead simple to do it yourself in the `single.json` view?
I completly understand your point that doing json views is very easy, but I honestly dont understand why are you so against a package for what is a standard format of json views. Anyway, as a beginner in elixir, this package helps me, so that I can focus on other, new areas of elixir.
I was there when Ruby had almost nothing and there were no Rails jobs, so I know that bootstrapping takes a while, but I think this one definitely has a shot at being the "Rails" of Erlang, the same way Rails brought Ruby to the limelight. I mean, [just a simple json/http endpoint in Phoenix runs at something like 1/10 the latency of other solutions...](https://robots.thoughtbot.com/testing-a-phoenix-elixir-json-api) (good blogpost, btw)
What is Xen?
Not super against it, I just don't see the benefit of it to be honest, especially since it doesn't support the whole spec. It's fine either way, nice post!
Why don't you use the Ecto validator functions in your changeset? Using validate_length/2 seems much simpler to me.
well, i will try to help develop it to support the whole spec. this would certainly help me improve my knowledge of elixir ( as in language, not as in doing server api's ). i really hope sooner i manage to do things better. i hope next weekend i do part2 ( emberjs ) and then blog about deployments ( especially including emberjs app in deployment )
You're welcome. I've run into similar problems, and I'm currently rewriting a lot of my changesets because I should have studied the docs a bit more closely.
*First off, I will say that I really don't get the appeal of Go unless you are new because every time I mess with something in Go, I kinda wish I'd just have done it in C. But I am getting older/lazier/crankier - so take this with a grain of salt.* Anywho, my opinion is Go is capable when it comes to concurrency - but I still have to make a lot of decisions when it comes to how exactly I'm going to handle it and doesn't prevent me from making really bad decisions. When I am using Elixir or Erlang, I don't question those sorts of things so much and immutable data makes it all much easier. But I'm a conventions guy and like relying on the VM of Erlang to reject/bail out my bad ideas. I'm not picking on Go here because I say the same thing about languages like F# and Scala/Akka when it comes to concurrency/immutability. Sorry for the rant :) I'd say this - Go makes sense to me outside of the web dev world. The idea of using Go to roll a performant webserver sounds painful to me. I think Elixir would be much more productive there and especially if you're coming from Ruby/Rails with Phoenix, Ecto and so-on. Go makes sense in my brain for command-line tools and small binaries. I know that people use Go for much more, though. When it comes to your future, that is a toss-up. I see Elixir picking up steam, but I know Go is 'hotter' in the current job market. At least around Phoenix and California. If Elixir isn't your thing or you don't like the idea of the VM, maybe consider Rust as well? I've not spent more than a few hours with it - but like a lot of what I have encountered so far. With a gun to my head, I'd pick Rust over Go without hesitation. But would rather work with Elixir.
Go is a very nice little language. I like it. But it isn't extensible. It has nice features, but sometimes you just want more.
I touched on this topic recently on the elixir-lang-talk mailing list (https://groups.google.com/forum/#!msg/elixir-lang-talk/Tr8ayRHMOh4/ofJ_1LIZdfQJ). Here's the relevant part: &gt; This is a really broad question but I'l provide a couple of points why I personally regard Go inferior to Erlang when it comes to building complex systems that must run continuously: &gt; &gt; 1. A crash (unhandled panic) of goroutine crashes the entire system. A whole system may halt due to an individual bug. &gt; 2. There is shared memory in Go. Hence, if one goroutine crashes, even if you catch the panic, it might leave some permanent in-memory junk i.e. corrupt data that will compromise other parts of the system. &gt; 3. It's impossible to unconditionally terminate a goroutine. You can do something manually, but this amounts to sending a message "please kill yourself", and hoping this will happen. If due to some bug, you have a goroutine that ends up in a tight CPU bound loop, you can't possibly stop it, and it will waste your resources forever. &gt; &gt; There are some other issues, but these three are for me show stoppers. All of those things can be worked around with careful programming, testing, and debugging, but then it seems to me that I have to do more work to get around some fundamental limitations of the platform. And no matter how hard I try, I'll never be able to completely eliminate those issues. In contrast, I feel that Erlang has a more structured approach, and I tried to explained this in my talk. &gt; &gt; I personally regard Go as an interesting option for some heavy processing tool, that needs to take some input and produce some output in finite time. In such scenarios, raw speed will usually be more relevant, while high-availability is probably not needed. &gt; &gt; However, in my experience a system is a completely different beast. Many activities are happening there: requests, background jobs, communication with other systems, and it's beneficial that individual failures have as low impact as possible to the entire system. In addition most of those things are I/O bound, with some amount of CPU processing involved. This is where Erlang's approach feels more appropriate to me. Erlang is not as fast as Go, but it deliberately sacrifices raw speed to get other benefits, such as predictable latency with less variations, and better fault tolerance, both of which are possible due to total process isolation.
Looks awesome. Also, love the name ;)
is there a way to get an &lt;ul&gt; element following a h3 with floki, like via xpath //h3/following::ul ?
`h3 + ul` would be the selector you'd use.
Yes, you are right pushad. Unfortunately this selector is not available yet. I will implement it soon :)
Thanks! :D
Thanks! Yes, there are some basic selectors: * id: *#some-id* * class: *.some-class* * tag name: *h3* * attribute *[data-x=something]* * multiple selector: *.some-class, .another-class* * "descending" selector: *.some-class .some-elements-inside*
One thing I noticed is that you may want to look into escripts rather than the bash script that is inside the readme...
I'll try... From the perspective of the OS and hardware, a thread of execution represents state, including the current code being executed, register state, and so on. In that sense you are limited to 1 actually executing thread per "core" and often several per core where the state remains loaded on the local cache of the CPU even while that thread is not executing (hyperthreading.) That doesn't change with elixir. There is another perspective of a thread which is from the perspective of actual software implementations. A common use of multiple threads in reality is handling incoming HTTP requests. It is quite typical to have 1 or maybe even a handful of threads listening on ports to actually accept new connections then spawning a handler thread where the handler code is executed. The remainder of that connection's life cycle is then represented in the local memory of that thread (aka its state.) So with that basic design, it's really easy to model these interactions. You just stick to your current thread and your entire request life cycle is a simple linear program execution. Easy. But that doesn't scale well. Part of the problem is that each thread has overhead not only from the state from the program itself, but, things like local cache data on the CPU that has to be swapped in and out as threads are switched (context switching overhead.) There are ways to improve the scale, such as significantly reducing the size of the stack per thread. But it can only go so far and puts a significant limit on what you can then do in those threads. So from there we got an inconvenient but effective solution: asynchronous programming, as in callbacks. In this model, you don't maintain a thread per connection or even necessarily per request. Instead you build everything as lightweight callback actions and put them on a callback queue to be executed by a small number of threads (in the case of something like node.js, just one thread per process) and the actual scheduled threads switch context themselves by moving through the queued blocks of code and their associated local context which is usually stored on the heap. But, the platform (i.e. node.js, twisted python) does not have scheduling control. This is entirely left up to the programmer who also has very little control over this scheduling. It's extremely complex if you actually try to think about what's happening (and you must to avoid bugs.) This works okay for performance (technically, you can still do better with real threads that have very small stacks) but it's a huge pain in the ass for reasoning about logical flow in code. It's inevitable you're going to be wrestling with race conditions, and your debug process is going to be so scatterbrained if honest, or it's going to be dishonest, because if you are honest, you know that a single processor thread is still the master of reality for code execution and you have to design as well as debug from that perspective despite having little control over concepts like shared stack prioritization. Okay so we have simple single real thread-per-connection models, async models, and then.... elixir/erlang. Elixir features something known as "green threads" elsewhere, but, called lightweight threads here. Actually, Erlang just calls them processes. Basically what you have here is support at the execution environment level (the VM) for taking N linear threads of execution, and instead of scheduling them as normal with a 1:1 mapping of thread to cpu thread, they are interleaved, with the vm deciding which thread's code should be executed at any given moment. From the programmer's perspective, you have the code reasoning simplicity of the basic single-thread-per-connection model, but, from the performance and architecture perspective, you have the advantages of the asynchronous design. So you get resource usage reduction, context switching reduction, and still maintain the ease of writing code without having to monitor for a million possible race conditions thanks to call back hell. This is why something like Whatsapp can be designed and executed on very minimal hardware for its ridiculously large scale. Erlang allows for massive scalability without the headache of callbacks. The combination of immutability and lightweight process (and, of course, the thing we haven't even mentioned yet, which is automatic distributed execution/clustering) means you can write straight forward, understandable code with a reliable execution order and not suffer the penalties normally associated with that in a single-thread-per-core situation. TL;DR Lightweight threads have the performance advantage of async code (like node.js, or twisted python) with the ease of reasoning of conventional threads/processes.
Haha, good call :) 
Interesting project! I'm the author of http://goban.co and I'm also learning Elixir lately, so I'll definitely take a look at the code. Let me know if you need help with the position and score estimation part, as I'm also interested in building some features on my site around that.
Depends what you are pattern matching against? I assume doing it with a map/hash map is O(1) if you are matching on a key while key value lists are O(n) to traverse the list to find the key? Structs I am not sure, this sounds like a good blog post though...
I did a high-level talk that touches on this stuff (https://www.youtube.com/watch?v=wYttHG3S76Y). Audio sucks for first 10 minutes, but then it gets better. The part which focuses on lightweight concurrency and its benefits starts at https://www.youtube.com/watch?v=wYttHG3S76Y&amp;t=575
&gt; P.S. - Am I the only one who is confused whether to call himself an Elixirist or Alchemist? Well, the subreddit says "~8 alchemists in action" ;) Elixir Alchemist is quite explicit and sounds well.
&gt; Well, the subreddit says "~8 alchemists in action" ;) That's why I asked. Most Rubyists will understand "Elixirist", but probably wouldn't get "Alchemist" the first time. So your suggestion - Elixir Alchemist - is pretty nice :)
This is awesome. I was looking to dive into Elixir (coming from a Node / Python / Java background). Having an open community site that caters to both rookies and veterans could be awesome. I will definitely help in any way I can, although I am certainly new in this area.
All this information is incorrect. ALL pattern matching occurs in O(1) time. If you need to match on a list however, you'll need to perform N matches to cycle through the list. However, each match is still constant time. For example: ``` [ 1, 2, 3 | tail ] = [1, 2, 3, 4, 5] # Constant time ``` ``` [ head | tail ] = [1, 2, 3] # Still constant time ``` ``` [ ok: data, foo: bar] = [ok: "hi", foo: "bar"] # Yet again still constant time ``` But if I need to cycle a list: ``` defmodule Cycle do ``` ``` def cycle([]), do: :done ``` ``` def cycle([ elem | rest ]), do: cycle(rest) ``` ``` end ``` Each pattern match (i.e. selecting which function to execute) is done in constant time, however you will cycle through N function calls and so therefore traversing the list is O(N) time. Pattern matching's power is in the fact that it will always be constant time. Dynamo &amp; Phoenix's routing layer depend on this fact by pattern matching a function call like match("GET", params, ["/path", "/to", "/data", data_id]) and having it select the right function. Elixir's own String.upcase (as well as downcase and other functions) depend upon pattern matching against a choice of over 1,000 binaries (all the unicode characters that have upper/lowercase characters). See here: https://github.com/elixir-lang/elixir/blob/master/lib/elixir/unicode/unicode.ex#L65 Don't listen, pattern matching is ALWAYS CONSTANT TIME. How many matches you perform is different, and up to the developer.
Yes, in a way. ElixirStatus attempts to be a much smaller site. As ElixirStream is a link-sharing site much like reddit, where you post what you find on the web. http://elixirstatus.com will be about what you *made* and give everybody an outlet to post their creation. That might not seem like much of a distinction, but it is an important one. ;)
Cool! We are currently working on this with 3, 4 people on GitHub: https://github.com/rrrene/elixirstatus-web/issues
Broadly speaking, in most cases pattern matching should work fast and will likely not have a negative effect on the performance. That being said, there are certain gotchas, that might cause problems in some situations. Guard tests are performed one by one, until some clause matches. Thus, if you have many clauses with guards: def foo(...) when ... def foo(...) when ... def foo(...) when ... ... Then complexity of selecting the proper clause will be O(n), where n is the number of clauses. I can't think of a real world situation where this would be a problem. You would have to generate many clauses (and I don't know if there's a limit) each with a guard. Note that this problem doesn't happen when you're matching without guards. Then, the compiler will usually be able to optimize it to a binary search (see [here](http://www.erlang.org/doc/efficiency_guide/functions.html#id67905)). Moreover, beware of using `length` function in a guard, since this function is O(n). Matching a non-empty list with `[_|_]` should work better than with `when length(list) &gt; 0`, especially if you're matching a larger list from within a tight loop. Also, comparing two lists will be O(n), because comparison must be done for each element: def foo(list1, list2) when list1 == list2 The similar should hold for maps, though I'm not quite sure about the complexity (asonge's note about n*log(n) intuitively seems correct). With all this in mind, as I said in the beginning, if you're using pattern matching in a reasonable way, that is if your matches are fairly simple (e.g. matching an atom, a few elements at the head of the list, a few k/v pairs in a map), and are careful with guards, you should be fine. Of course, standard disclaimer applies :-)
Typos everywhere!
In Elixir/Erlang, these 'lightweight threads' are called 'processes' and they, along with the deep library support for them, are basically the fundamental reason to use the BEAM VM. While the benefits of not having to think so hard about state and callbacks and all of that are great, they have been explained already by others here. Other aspects I think were not explained as well as they could have been. One reason to use lots of processes is that they limit the scope of failure for your application. Isolation of failure to a process makes it easier to think about how your application handles the failure and empowers you to "let it crash" and only worry about what it takes to restart the service with as little disruption as possible. This reduces the amount of defensive programming required to keep your application up and running while simultaneously protecting all of the other users who might be interacting with it from a crash in one unrelated process. Creating a lot of small processes makes it easier to slice up your application and spread it across multiple nodes (presumably on different hardware) with very little, if any, change to your code; this means scaleability. You can program a single supervisor tree to service a single user with the plan of just spawning more for additional users. Since processes can talk to each other across nodes seamlessly, you just turn on hardware when you need it. Processes are at the heart of the OTP concurrency model and they enable many good things. If you have a problem, throw processes at it. Your code will become simpler, more modular, easier to fix, and easier to scale.
its not unreasonable to determine ethos in weighing an opinion.
tried it but then I see the same error messages.
Thanks, one last question. How can I use this anymous function. When I test it I see this output: c("fizzbuzz.exs") fizzbuzz.exs:1: warning: variable fizzbuzz is unused [] iex(2)&gt; fizzbuzz.(0,0,1) ** (RuntimeError) undefined function: fizzbuzz/0 
You can call anonymous functions with a dot, followed by params. Like so: func = fn x -&gt; x * x end func.(5) # =&gt; 25 So yours would work like this: fizzb = fn 0,0,_ -&gt; "Fizzbuzz" 0,_,_ -&gt; "Fizz" _,0,_ -&gt; "Buzz" _,_,n -&gt; n end fizzb.(0,0,1) # =&gt; "Fizzbuzz"
Man, I would love to go to this, but I know my company won't pay for it, and that is fantastically expensive for just a 2 day conference.
I think there's supposed to be another ElixirConf (or whatever it's called) in Austin this year.
I assume you meant to write: mapsum(tail, func.(head,value)+func.(head,value), func) However, this wouldn't sum the result correctly, as the 'func' function would be called twice for each value in the list. The fact that the function in the reduce example both expects the next value from the list (head) and the result so far (value), hints to me that the writer of the exercise expects that the summing can take place in the 'func' function. I leave it up to you why I think that's the case :) Personally, I would go for another approach. I would write the mapsum function that in such a way that the 'func' function only needs one argument and that the mapsum function itself does the summing of the results. In order to do this efficiently you would need to add the result so far (generally called the accumulator in functional programming) with the result of the 'func' function call. Hope I could be of help without giving too much away with the above
Forgot to add that the reason for why I think it's better writing mapsum in such a way that the passed function only needs one argument, is that mapsum would be much more generic. You can pass any function that does something with a number. 
Thanks, I will hit the book again to find out how I can use a accumenlator in Elixir. The book has a example of this I think. 
sorry then for the typos. Englisch is not my mother language. After a little thought I came to this in words. When the array is empty then we have our value. When the array is not empty then we have to take the head of the array to the function. The answer to this must be added to the accumulator and every step must be done with the tail of the array. Can this be a solution ? Roelof 
I don't know what your expectations are, but what I do when I want to get a taste of a language is program something simple yet fun. For example the last thing I did was implement a cellular automaton. Rule110 it was in my case. When you started and are getting into it it is most likely that you will have ideas on the way to improve your application and keep on going.
Wouldn't def divisible_by(x, list) when length(list) &gt;= 1 do if rem(x, hd(list)) == 0 do true else divisible_by(x, tl(list)) end end def divisible_by(x, list) do false end Be the same as? def divisible_by(x, []) do false end def divisible_by(x, [divisor|rest]) do rem(x, divisor) == or or divisible_by(x, rest) end Another one: def recurse_prime(x, primes, max) do if x &gt; max do primes else if is_prime(x, primes) do recurse_prime(x + 2, primes ++ [x], max) else recurse_prime(x + 2, primes, max) end end end With guards: def recurse_prime(x, primes, max) when x &gt; max do primes end def recurse_prime(x, primes, max) do if is_prime(x, primes) do recurse_primes x+2, [x|primes], max else recurse_primes x+2, primes, max end end ([x|primes] build a new list where x is the head and primes is the tail, so it's the opposite order of primes ++ [x] which is much slower, but in the case of your program, I think the order doesn't matter?) Also, def is_prime(x, primes) do if divisible_by(x, primes) do false else true end end Could be written as: def is_prime(x, primes) do !divisible_by(x, primes) end
This is professional training, not a conference. I spend most of my waking hours doing my best to help Elixir adoption and making the community accessible to everyone. I also dedicate a huge amount of my freetime putting together learning material for the community and make it freely available on Github (in addition to working on Phoenix in my freetime): https://github.com/chrismccord/elixir_express http://www.chrismccord.com/blog/2014/05/27/all-aboard-the-elixir-express/ 
You'll have to be more specific about what you're seeking opinions about. The project has a small readme which doesn't discuss the goals or reasons behind the project, and code-wise you only seem to have a single supervisor built over a year ago.
Got it - function arity. Awesome.
Just to put the earlier comment more exactly, a function is defined by its name *and* arity. 2 functions with the same name and different arities are *not* the same function.
Thanks for your comments! I know there's a lot I need to do to make more "functional" code, I appreciate the help.
One thing to remember is that pattern matching in functions includes quite a bit of the conditional checking that you have to do in the body in most other languages. Quite a bit of control flow is handled there. If you find yourself using "if" or "case" in the body of a function, you should be asking yourself if you would be better off doing that using function pattern matching. Another thing to remember is that lists in Elixir are simple linked lists. This means that interacting with the head of the list is very fast, but interacting with the whole list can be very slow. In particular, length(list) has to manually count the number of items in the list, so it takes O(n) time.
Here is a fairly major code refactor: def main([ {max, _} | _ ]) do primes_up_to(max) |&gt; Enum.map(&amp;IO.puts/1) :ok end The main function was pattern matching inside for no real reason, so I moved the pattern matching to the function. Now, if you want to insert a better error message, just toss another function clause which catches the error condition and reports something better. The original was also assigning the primes variable and then using a pipe in the very next line. Part of the beauty of pipes is they get rid of many intermediary variables (there is also a function rename, but I will get to that). When you call a function with the exact arity as is required, you can use the form &amp;Module.function/arity for enhanced clarity and brevity. I have it returning :ok, since the result of the map is just a list of :ok, which is meaningless. def primes_up_to(max) when max &lt; 2, do: [] def primes_up_to(max), do: primes_up_to(3, [2], max) I renamed the function from "recurse_primes", which doesn't really say what it is doing, with primes_up_to, which is much more clear. This section also captures initialization details which shouldn't need to be understood elsewhere and handles a case which didn't work correctly in the original. defp primes_up_to(x, primes, max) when x &gt; max, do: primes defp primes_up_to(x, primes, max) do unless divisible_by_any?(x, primes) do primes = primes ++ [x] end primes_up_to(x+2, primes, max) end This is similar to what /u/Microchip suggested with one difference: the recursive calling duplicated some code. Calling the recursion outside of the if (or in this case unless) block removes the duplication. This is also a private function since the public interface is primes_up_to/1 def divisible_by_any?(x, ints) do Enum.any?( ints, &amp;(rem(x,&amp;1)==0) ) end All of the rest of the code really just iterates over the list. While this is the sort of thing that people tend to do when learning FP since getting comfortable with recursion is important, simple tasks like this are already solved in the standard library. Seriously, learn how to do this manually, but real code shouldn't be reinventing wheels. Once again, there is a rename to make the function describe what it actually does as opposed to what it does in the context of why it was written.
To add to this, this is similar to overloading a method in an object-oriented language.
This is not a for loop. This is a list comprehension. It's like a for loop on steroids. You want to check out [this link](http://elixir-lang.org/getting-started/comprehensions.html) for more details. 
Thank you beautiful stranger! :-)
No problem. Any time :D
In many languages, a for loop is a statement rather than an expression as a traditional for loop doesn't return any values and can be broken out of during it's execution. What you see above is a list comprehension which is made to look like a for loop. It differs from a traditional for loop in that it can form a closure around it's scope and it returns a value
I have read that part. Is head Always a binary then. In the script I do not see any reference to convert the string to a binary. 
I guess it's a char list. Note the single quotes: [head | tail] = 'abcd' Now, head is `?a` also `97`, and tail is `'bcd'` also `[98, 99, 100]`
List comprehension in Elixir (and Erlang) take some time getting used to. I find Python's list comprehension syntax much easier to get my head around :) squares = [x ** 2 for x in some_list] and with conditionals: squares = [x ** 2 for x in some_list if x%2 == 0] You can also split it into multiple lines for extra readibility squares = [ x ** 2 for x in some_list ] Apologies for sticking Python into this list. I have a quiet hope that maybe in Elixit v2 above syntax could be adopted :)
oke, I see where I went wrong. I try to do it with double quotes and that does not work. I have to use single quotes.
&gt; Is there a performance (or other) reason why you didn't just go with Phoenix over Cowboy since Phoenix uses Cowboy on the backend anyway (yet likely provides a more Elixir-like API)? &gt; Phonix is a framework, so it looked like heavy to build a CDN server. Cowboy is robust and proven and lightweight and just an http wrapper . So that made me use cowboy
[Please see this comment by the creator of Phoenix.](http://www.reddit.com/r/elixir/comments/38urjd/alternatives_to_dynamo/crz143e)
I think you want this: https://www.reddit.com/r/elixir/comments/3c0867/relixirs_q3_2015_hiring_thread/
I think @mjs2600 got it right; think he meant to post to the sticky hiring thread and just misunderstood things a bit.
For the example of a Web server, take a users session ID, are you really going to pass that around to every function?
Psychogenetic fallacy. You can't attack someone's argument simply by proving they have motivation or ulterior motive.
LOL, it would likely be inside a tuple or dict, like a params dict. It's in the header, after all. You think that's "bad," in Elixir/Phoenix you literally pass around the variable that represents *the connection itself* (it's usually called "conn") And you know what the crazy thing is? *This ends up being better.*
So how do you implement stuff like method chaining? Say I have a shopping cart, (object called cart), and it has some items (cart.items == [item1, item2]) items have a price (item.price) and weight to calculate shipping (item.weight) so when the user checks out I can calculate cost + shipping by doing (in ruby): sub_total = cart.items.inject { |sum, n| sum + n.price } shipping_total = shipping_cost(cart.items.inject { |weight, n| weight + n.weight })
Based on your tips, here is an improved solution- I prepended the elements to the beginning of the larger lists in all cases and used Enum.reverse to get the correct order back. As I understand this *does not* require rebuilding the list, as it simply adds a pointer to it. I have also made all paths of the is_ordered function call itself, so this should allow the tail optimization to take place. Thanks for the help, let me know what you think! [bubble sort, improved](https://gist.github.com/Dania02525/e77b9a33d9b0761fc995) 
&gt; You can also construct lists using the exact same syntax I did not know this. This alone makes it much easier to look at. TIL . &gt; one-line pattern-matched function declarations Agreed on this, certainly nicer. &gt; function call, which doesn't work in function heads I've bumped into this before in using Elixir. Thanks for the input, code style improvements are much appreciated 
Well sorta, that depends on the linked list. I'm assuming they're singly linked then? Otherwise appending should be constant time. Interesting anyways, do you know what or if there is an optimal way to sort a list in BEAM?
It doesn't disprove an argument anymore than not having a conflict proves it, but it absolutely is a component of how seriously you take the opinion.
Yes, singly-linked lists. Optimal sort is always an area of contention, but BEAM has an efficient mergesort. Check out Enum.sort.
Why not use monitors? Then you get a message when the other process goes down, without having to trap.
I love how bizarre this question sounds if taken out of context. 
I'm really glad people like the idea. Looks like I'm already running out of issues, so I'll work on making more.
Interesting. It feels a bit weird having two processes both monitoring each other (as I want both to die if either does), but I guess it makes sense, and it is more explicit. Thanks for the explanation.
If you're new to functional take a look at the "Programming Elixir" book by Dave Thomas. It helps step through the ideas. 
How about: defp is_ordered?(enumerable) do enumerable |&gt; Enum.chunk(2, 1) |&gt; Enum.all?(fn [a, b] -&gt; a &lt;= b end) end
It works, but it also suffers from doing a bunch of unnecessary work by chunking the entire enumerable. You could fix this by using Stream.chunk instead. defp is_ordered?(enumerable) do enumerable |&gt; Stream.chunk(2, 1) |&gt; Enum.all?(fn [a, b] -&gt; a &lt;= b end) end
From my testing Enum is faster unless you expect very large lists. But ok, Stream might be more versatile :)
This is part of the official Erlang best practices. &gt; 5.12 Trapping exits &gt; As few processes as possible should trap exit signals. Processes should either trap exits or they should not. It is usually very bad practice for a process to “toggle” trapping exits. Joe Armstrong's thesis "Making reliable distributed systems in the presence of software errors" explains why in much more detail. See around page 104, "Error handling philosophy". In short, a cornerstone of the Erlang philosophy is to separate error handling and application logic in separate processes, workers and supervisors. Trapping exits in your application code mixes these concerns in the same process. It also means your module uses dirty operations, which Joe defines as: &gt; apply, cancel_timer, check_process_code, delete_module, demonitor, disconnect_node, erase, group_leader, halt, link, load_module, monitor_node, open_port, port_close, port_command, port_control, process_flag, processes, purge_module, put, register, registered, resume_process, send_nosuspend, spawn, spawn_link, spawn_opt, suspend_process, system_flag, trace, trace_info, trace_pattern, unlink, unregister, yield. These operations require a lot more care than normal application logic, and they can be dangerous. You should try to keep them in separate, carefully reviewed modules which are the "error kernel" of your application - the part where messing up would be a big deal. That's the magic of supervisors, gen_server, etc.: they handle the difficult things like concurrency, error handling, and dirty operations so that your application code doesn't need to care. It also means you don't need expert knowledge of Erlang to write your code, because the hard parts are already implemented by experts. For example, if you trap exits, you may have to think about the different kinds of exit (shutdown vs normal vs everything else), where they come from (it can be your supervisor, if you're under one, it can be another process that got linked during a gen_server call), etc. It mixes error handling and normal logic. Monitors are clearer and simpler. Re-reading your question, putting everything under one supervisor, and just asking it to shutdown when any of the processes are done is the best approach IMHO. If you stop it with reason shutdown and don't use brutal_kill for shutdown strategy nothing weird should get logged. See e.g. http://stackoverflow.com/questions/21138442/stopping-an-erlang-supervisor
The tabs formatting comes from using 2 space tabs in sublime text and cutting and pasting into gist. Seems to be not working to change tab saving to two
https://en.m.wikipedia.org/wiki/Test_fixture Check under software, it's a pretty common usage of the term.
I wonder if this was in dev mode, instead of production. It makes a big difference iirc
it must've been, I just realized the 3x speed was from node comparisons - the rails comparisons have been hovering around 10x for me
I guess you'd know if you came from Rails...
#[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)#....................... #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)#
#[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# #[Mayo vs Sligo Live Stream Connacht GAA SFC 2015 IN HD](http://liveonpc2tv.com/gaatv/)# 
#[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# 
#[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Monaghan vs Donegal Live stream](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# 
#[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# 
#[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)# #[Mayo vs Sligo Live Streaming..Connacht..SFC..Final..2015.. Watch..Online..](http://soccer365liveonlinetv.blogspot.com/p/gaa.html)#
Performance is much better after running as MIX_ENV=prod Thanks for commenting!
the term has been around a lot longer than rails. The ruby community is just vocal about testing so a lot of testing concepts are exposed to people via the ruby community (mostly rails)
I'm not sure that you had to do any comparisons to YAML and FactoryGirl to get your point across, but since you asked - YAML is better because if you're spamming out anything more than just a couple fixtures, it's MUCH easier to read what the data is rather than hoping someone properly aligned all the spaces when creating users in a file. FactoryGirl is basically the same thing you're doing in style, but adds a ton of functionality behind the scenes. Do you want to lazily evaluate something? FactoryGirl can do that, your code can't. (just for example) Either way, great writeup - I just don't think the negative bias against those other two tools was necessary.
true!
I did some benchmarks recently. Rails, Phoenix and play/scala. https://github.com/zepplock/phoenix-showdown/blob/master/README.md
Metaprogramming has a well earned reputation for creating completely unmaintainable systems. These macro-heavy systems are extremely hard to reason about and are eventually thrown away and a new system with no metaprogramming is put in its place. Elixir has created a more responsible form of macros (IMHO) than most, so maybe it will buck the trend. But, powerful metaprogramming can easily be a "con" -- it was part of the reason for my startup I did not use Elixir. An early video on Elixir even referenced this danger and just banked on a mature community acting responsibility to make it do more good than harm. I will continue to watch and hope it works out well.
Macros are cool and powerful, but I can see why many would view them as a double-edged sword. Perhaps a better way to approach this would be to highlight the ability to create DSLs to enable domain-experts to write the business logic, or the power of protocols to enable you to extend existing types and add your own variants.
Exactly, the point in the JVM is that when it runs longer it gets faster as it can optimise better. Especially this entire point just seems to be a hook on the "java is slow" stereotype.
"Phoenix – killin’ the game."... in dev mode :). The author stated the benchmarks were not run in prod, so we need new #'s to get a better idea.
True story - just look at Hans Reiser.
&gt; Metaprogramming has a well earned reputation for creating completely unmaintainable systems. So has object-oriented programming. Does this mean that we should throw out OO? ;) &gt; These macro-heavy systems are extremely hard to reason about and are eventually thrown away and a new system with no metaprogramming is put in its place. Do you have any examples? &gt; But, powerful metaprogramming can easily be a "con" I prefer to have the responsibility of using a powerful weapon appropriately instead of simply having it taken away from me. I didn't know that there was this much "pushback" out there against macros, though. I will have to do a little research
I would fault long spinup time as an impediment to rapid, nearly instant unit-test-result feedback, which I found (once incorporated into my workflow) was a rather huge productivity boost. The pattern I had going when I did Ruby, if I was working on a class or module, I just had to run the file and it would automatically run its unit test, it was literally instant feedback on what worked or got broken and it was fantastic. Now Ruby (if you have a large app stack) has [Zeus](https://github.com/burke/zeus) but I found that Zeus would occasionally go out of sync/whack and I'd have to restart the whole thing again. To put things in perspective, loading the entire Rails app stack at my last job took 40 seconds. Now you might say "you have way too many dependencies if you need to load so many things to get anything working that it takes 40 seconds"... and you would be correct. But the problem was boiling-frog syndrome- we started out with 1, 2, 4 seconds... and it slowly bled from there before anyone decided it was a real problem. Clojure has ways to create a pool of ready-to-go JVM's, but I feel like all these solutions are band-aids. The problem is that spinup time is evidence of complexity and state and it's possible that a multi-second spinup time is simply much less than ideal. (The ideal would be "as simple and fast as possible.")
Ooooh. Even I don't have the balls to make that joke. lol
In that case it might be better to state that the Beam VM has no noticable impact on the application load time. For example, one of the strong points with Go is that since it compiles down it works really well for CLI apps. Java isn't so great for that because of the spin up time. Elixir running on a VM would tend to make me think it'd have the same problem, but it may be closer to Go than Java. 
Macros are the "right" way to do metaprogramming to my mind: they get the meta magic out of the way during compilation, instead of at runtime. What is a Rails macro-method doing? There's not actually a way to "see" -- you can read the code and trade execution in your head, but keeping track of what is being run, and when, can be difficult in DSL-heavy libraries (and that's putting it mildly). What I would call 'vanilla' Lisp-style macros (ie, not macros that define other macros at runtime ;)) are, to me, a lot more straightforward. By the time your program runs, all of the meta magic has been compiled out of it, and in the case of Elixir it's very easy to see what the effect of the expansion is.
DSLs suffer the same problems, and because they are designed for external users -- require even MORE testing and documentation. You need to document a DSL like a new programming language... because... well -- it is!
&gt; So has object-oriented programming. Does this mean that we should throw out OO? ;) I have been in industry for 20+ years, and I have never heard someone say "dear god, we had to throw away that entire system because it was written using lots of OO". Switch out OO for metaprogramming (macros) and I HAVE heard it... multiple times. &gt; Do you have any examples? Yes, I have personally been involved in projects to correct these issues. I actually think one company (game developer) might allow me to talk about their hell publicly, will reach out and see. Can't promise I will deliver, but I will ask. This "metaprogramming rewrite" cost the company a little over $8M (not adjusted for inflation, it was about a decade ago). &gt; I prefer to have the responsibility of using a powerful weapon appropriately instead of simply having it taken away from me. Every individual wants maximum personal freedom. Every programmer wants to write code in their own style. But, standardization, norms and limits are what makes TEAMS work. 
This seems kind of foolish to me. To say, "I don't choose X language because it has tool(s) which my developers will abuse" is like saying I prefer using only butter knives because then I can't cut myself. Now to come out and say something like, "I don't feel that the idioms and standard library of &lt;SOME_LANGUAGE&gt; properly handle the common gotchas created by &lt;SOME_TOOL&gt; within the language and often lead developers down a false path which can eventually be very devastating to the codebase", would be more acceptable. But then you'd have to prove it. For example, I might say that I feel that the way JavaScript is used within Node.js with respect to callback hell and no promises in the standard library (I understand this is changing) often lead developers to produce non-maintainable and difficult to read code which in turn generally adds to the complexity of the system. Your turn.
[Reductio ad absurdum.](https://en.wikipedia.org/wiki/Reductio_ad_absurdum) They do not have to be a "magic bullet" to be extremely useful... which is exactly what we found. No, they did not catch *everything.*
&gt; and I have never heard someone say "dear god, we had to throw away that entire system because it was written using lots of OO Have you done much work with functional languages? I've heard of a few OO-&gt;functional rewrites which were not only successful, the end result was faster, easier to maintain, generated fewer bugs, etc. etc. Would be very interested in your macro-rewrite story (depending on what the company allows). How do you know that the perpetrators in question didn't see macros as "a hammer that turned everything into a nail"? Because I could see that happening... and it's of course the wrong approach.
&gt; Have you done much work with functional languages? I have shipped production Lisp and Erlang systems, both are still live and in use at 1B+ revenue a year companies. This Lisp one has become a laughable joke we called "procedural lisp" because almost everything that makes it lisp like has been banned (at commit level by perl scripts no less). 
Everything I've seen so far makes me think it's closer to Go than Java.
Wow. So how have your Erlang systems gone? ;)
Generally, very well. We had an issue around overuse of complex NIFs which ended up being completely unnecessary, premature optimization. Last I heard the system was down to single digit NIFs and has been connecting players to games successfully for a years now without any major incidents. 
&gt; I don't know if you can reduce that to "never make or use custom in-house libraries and/or DSL's," though. But, I have done exactly that, 4x times now (founding my 3rd and 4th company now). I don't allow DSLs, macro use or heavy (custom) code generation. Everything has a cost and a value. The cost in of metaprogramming generally VASTLY exceeds its value in my experience... I am hoping that Elixir may be the thing that changes this. There are exceptions to all rules and if someone convinces me of generating code for X or using a macro for Y, sure -- but the starting point is "no". &gt; When someone leaves who was responsible for writing some of the code in the codebase, YOU WILL suffer the loss of that person's knowledge. I think it's unavoidable to some degree. Absolutely. But, it can be minimized to a huge degree. Clean, self-contained functions with no side effects, good documentation and unit tests are FAR easier to deal with in the future than a massive smear of macros across an entire codebase. Hell, even documenting macros is a very tough thing to do in complex cases because of variable behaviors based on calling context.... unit testing your macros? Dealing with changing behavior in macros? 
Sure, and that is a core library, not an in-house one. That said, I am in interested to see how it is tested, will have to poke around the source a bit. 
Can you explain what the consistency columns means?
It's the deviation in response times. The less the better. 
Coincidentally this article also demonstrates why the currying was not there to begin with.
It's nice to have opt-in currying, though, like Ruby.
I'm very interested in this as well - seeing good examples of what code goes in controller, view, template, model; abstracting out common code; integrating with different Erlang libraries; testing; approaches to JavaScript front-ends etc. In the meantime, I'm writing a server that presents a bunch of interactive modules through LTI onto an EdX MOOC. It's in current production with a few thousand fairly active users, and we add features every week (we're in week 3 of 6). I just started learning Elixir for this project, so I can't promise idiomatic code, there are things I would do differently if I rewrote today. But there is quite a lot of diversity - different plug pipelines, integrated SMTP server, web sockets for chat with presence, worker queue, automatic survey generation etc. https://github.com/houshuang/survey
There is erlog which allows you write logic programming in a prolog like dsl.
I'm actually in the process of putting together a generic, weighted csp solver hex package at the moment - I haven't really sean any other a.i. packages though. 
I agree too! That said it's tough. Phoenix is changing fast. If you put up a non-trivial app as an example you'll need to keep updating it frequently or it'll fall behind and updating a non-trivial app takes a lot of time. I tracked down this as someone elses attempt to do what you are looking for: https://github.com/gogogarrett/phoenix_crud I don't know if it ever was a "good" reference but it's now super out of date and not too useful anymore. The best I've been able to find at this point is the scaffolding that phoenix generates for you with mix phoenix.gen.html and mix phoenix.gen.json. That said there's a lot still missing and a big opportunity to receive love by providing a good reference that hits on a lot of common scenarios. I'm game for starting one but will need help!
Is there a better way to write function arguments when you have such a long list of them, such as in this articles PNG pattern matching examples? Seems like longer things can get pretty unreadable.
I'm not making any claims about it being well organized or exemplary, but it is an example of doing some useful things in phoenix : [https://github.com/Dania02525/Restapp](https://github.com/Dania02525/Restapp) Its on what I believe if the latest version of Phoenix and demonstrates CRUD functions, Json views, Json web tokens, and nested inserts with transactions (Like insert new invoice with n number of items, and roll it all back if an item insert fails). I'm going to be working on an SaaS elixir app with a Durandal front end to create shipments using the easypost API as soon as I get some time. (It will be roughly modeled on an SaaS accounting app I've already built and my partially complete Easypost client.)
This is pretty awesome. Imagine writing this in another language. Would be quite messy I'd imagine
I've not had a lot of experience with currying. Why is it not there?
I'm not sure if it's the reason for it, but my reason for not currying things is that since functions - like in Erlang and LFE - are defined by their arity, currying makes my code harder to reason about for me. Also currying is primarily used either because you feel like it or because - like in JS or the like - basic functional abstractions don't exist in your language. So the answer to why Erlang - and by extension Elixir - never used it is that it was never necessary and the option to use it explicitly for people who crave it is there like in any other language. Again, personally for me, it's as much about not inventing a wheel, which is to say not reimplementing the abstractions smarter people than me spent 30 years on ensuring they got right.
Don't worry about it and keep writing stuff :)
Heh. Yeah I was just curious if there was a best practice for writing long function signatures that that community has decided on, or if there was something built into the language to help with it.
Carriage returns and Indentation? ;) Long function signatures are actually discouraged. It's usually considered a code smell. Which is why I said this wasn't really a long signature (that bit that starts with &lt;&lt; and ends with &gt;&gt; is a *single argument* match), it was just a long match. The clauses of which could be separated with carriage returns and indentation.
This is a long signature though. That's why I chose that phrasing over my original :p but I'd rather not argue semantics, I think we're both on the same page lol 
So when writing the article i screwed up the order of the functions. (in the "putting it all together") Updated the post now, and everything should work as in intended. Im sorry about any inconvenience. Thank you all for feedback!
Ah gotcha, so is it similar to a list in Scheme/Lisp? That is, lists are nested tuples? `[1, 2, 3]` would be `(3 (2 1))` if I recall correctly and adding 4 would add it like (4 (3 (2 1)))
Hi! Author here. I screwed up with the "putting it together" -section, and now I updated the article! Thanks a lot for taking the the time to try the code out, and sorry for any inconvenience! :)
I learned quite a bit from this one: https://github.com/ericmj/gaze especially, how to write HTTP tests without starting the instance.
This motivated me experiment with a macro version : https://github.com/niahoo/elixir-curry
This article didn't touch on my favorite feature of static typing: speed of execution! And no waiting for a JIT to warm up, either, depending on what language you're comparing to.
I made one here[1]. The UI is ugly, but it shows Ecto and Phoenix in action (with Ecto associations). [1] - https://github.com/drewolson/blox
https://github.com/elixir-lang/plug
Calling Phoenix 'larger' is a bit of a puzzle. Yes, it comes bundled with controller and view layers (which, iirc, are planned to be spun off to allow them to be omitted in the future), but Phoenix is much closer to a Sinatra in footprint than Rails. Phoenix is just 'plugs all the way down' and all of that behavior is fully customizable with anything that isn't used not slowing down the app at all. If you use the Phoenix router and plug into your own custom plugs, the controller and view layers never get invoked or loaded. The design philosophy of Phoenix is much more similar to Sinatra than you may be giving it credit for, it just comes with a few extra tools in the box which you can ignore with no harm done.
To be clearer I mean a framework that has a macro based DSL that would allow you to handle the responses inline with the route specifier, like the following pseudo-Elixir: get '/hello/:name' do conn |&gt; put_resp_content_type("text/plain") |&gt; send_resp(200, "Hello #{:name}") end No controllers or views, just inline code. My use case would be a json rest api.
Sugar Framework
You did basically just describe plug. Unless it has to be called a framework, you're pretty much set. Plug.Router is what you want.
watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . 
watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Live](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match 
Thanks for documenting this, great. I also felt that the basic chat app was a bit "basic", luckily it turned out to not be very difficult to extend. I also keep a chat-log, but it needs to be persistent, so I just use a single entry in Postgres per chat utterance (easy to sort by time, limit to the last 10, etc). I then pre-populate the chat box when someone joins with the history. I also wanted chat presence - being able to see who is online, etc. I made an agent that keeps track of this, although I think perhaps using an ETS table would be cleaner. It works though :) My code is here: https://github.com/houshuang/survey (web/models/chat.ex, web/channels/room_channel.ex and lib/chat_presence.ex). The system is live with a few thousand users, however not that many are using the chat features - I haven't seen more than 10-20 online at the same time. (Here's how it looks in the sidebar of our "collaboration workbench"): http://i.imgur.com/TkuQFPE.png As a beginner, it's always fun to read other people's code. I was a bit confused by your do false -&gt; true = (gen.ex:15), but I realized true = is a way to make sure that the ets.insert succeeds (presumably it returns true on success, rather than {:ok...}). I think part of my confusion is that although I love pattern matching, I would still use if...else instead of pattern matching on true and false. I was also curious about the efficiency of ETS - it seems like you are replacing the entire entry for a chat room every time a chat utterance is added? I know that linked lists in Elixir are very efficient, but if you have to retrieve it from ETS, append, and then store it, that doesn't seem very efficient? Or am I missing something about how ETS works? One other thing I do differently is that I send the list of previous emails as part of the reply to the initial channel join. This means that I use exactly the same javascript to render the chat history, as to render any new messages, and saves me some eex code. It does mean that it takes a few milliseconds longer to see the chat history after the page is loaded, but the advantage is that if you get disconnected, it will automatically update with the newest chat history upon reconnect (phoenix.js reconnects automatically without a page reload - it's always fun when I reboot my server and see a bunch of requests to /ws flowing in straight away). Anyway thanks for sharing!
The funny thing about performance in Erlang is that it's usually so fast that it doesn't matter... :) I'd love to have hundreds of thousands of users, having to scale across computers, optimize etc. :) But instead my server sits at 2% CPU, and responses are in 10ms... Good problem to have I guess :)
watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . CLICK HERE TO WATCH LIVE TV You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match watch America’s Cup World Series 2015 Sailing Live just follow our streaming link. You can watch this match up from home with your family if you don’t have enough time to visit the stadium,Just turn on ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- #Watch In HD▶▶ [watch America’s Cup World Series 2015 Sailing Liv](http://onlinesoftpro.com/sports/watch-americas-cup-world-series-2015-sailing-live-stream-on-hd-tv/)# ------------------------------- your pc/laptop/PC Mac and Iphone Ipad then watch the game from your PC or laptop or PC Mac and Iphone Ipad.Don’t worry,it is too easy to watch..Ensure that you must be 100% satisfied in out service so don’t be hesitated just click the link bellow and start watching and enjoy more.best of luck . CLICK HERE TO WATCH LIVE TV You all about USA,CA,AUS,UK Game entertainment like NFL,Sailing,GFL,LFL,SOCCER, NCAAFB, NCAABB, MLB,RUGBY, NASCAR, NHL, NBA, BOXING, FORMULA ONE, ect by which All of you can watch each and every games live streaming online. From any location! Get instant access and most exciting sports coverage stream software online directly on your PC. Download and install oue software and enjoy all the pleasures of the sporting world comfortably like you are at the stadium watching the match
I've been looking at the codebase for http://jobs.elixirdose.com/ and have been finding it pretty interesting. It's using Semantic UI for the GUI and RethinkDB as the storage engine. I'm personally crap when it comes to nice layouts and design so UI kits that help with that are a boon to me. RethinkBD also looks pretty interesting, especially as it sort of replaces the "model" in the MVC. Rather than having a database with migrations and models that translate into database calls, it seems like Rethink is clean enough you can just work directly off of that without any added code layer.
And this is the code repo: https://github.com/rizafahmi/elixirjobs Thanks @synn99 for the mentions!
When you did this, were you measuring the actual calculations OR just the full execution of the program? In both the ruby and elixir cases, there are going to be start up costs. However, it may not be the same inside - only outside. So it would be possible for elixir starting up to take longer, and the calculation itself to be short - while in ruby for the start up to be shorter but the calculation to take a long time.
Hi, could we talk? sheila dot chang at plataformatec dot com dot br :) 
As I said over on /r/rails Note that it looks like the author did not benchmark Phoenix in prod environment. We are typically 10-20x higher throughput than Rails, here it's 2.5x. He also used ab to benchmark, which in my experience can only stress my Macbook CPU cores to 50% when benchmarking Phoenix, so there's usually a lot more room for req/s, but ab can't push it. I used wrk instead to benchmark.
If I'm not mistaken, exs files compile in memory just before being run. There wouldn't be much difference unless your exs file was large enough to impact ram as it was compiled in memory. &gt; The file will be compiled in memory and executed, ... [source](http://elixir-lang.org/getting-started/modules.html#scripted-mode) 
It's updated now.
If you enjoy Ruby's Grape, you may enjoy [Maru](https://github.com/falood/maru).
https://twitter.com/josevalim/status/626131275150065665 @josevalim: Please avoid YAML in Elixir projects. It is unnecessarily complex, both in implementation and usage. Elixir already provides config files.
I've just given you a tool. It's up to you how you will use it ;)
Heaven forbid you link directly to the blog.
I guess the idea is to get people to click through elixirstatus.com to get to the links we are interested in. TL;DR, this is cool: :os.system_time(:seconds) and this is also cool: [https://github.com/bitwalker/timex](https://github.com/bitwalker/timex) 
Yeah, got the message and will post direct links in the future. But you can't blame me for trying to promote something I made together with the community. It might have come off as a stupid plug, but it's just me being bad at "getting my stuff used and known". If anybody's still reading: Here is the "About" page, which was phrased by a native-speaker and might get the project's mission across much better than I could: http://elixirstatus.com/about Sorry again. [edit] english is hard X-)
I wasn't raining on your parade, and I like the idea of a community project. However, it would probably be worthwhile to put some content on there besides links to other content. I get that the plan is to be a place to link projects/other things you have been working on, but thats essentially what this sub is and linking me to your site just adds another step for me to spy code.
I know this was already posted here [1], but that one wasn't a direct link to the article, it was a spammy link-to-a-link by someone trying to get some Google juice or something. Feel free to downvote if you think this isn't appropriate. [1] https://www.reddit.com/r/elixir/comments/3f518p/unix_timestamps_in_elixir/
Awesome! Just tried and it's not live on the website yet. Elixir is there though.
&gt; Unfortunately, as can be expected with any newly emerging technology, I will say that the ecosystem is not up to par with Ruby yet. In particular, I wanted to monitor the performance of my app, and there was nothing akin to NewRelic that I was able to find. I made do with lots of printing to the logs and post-processing, but until there’s a drop-in tool like NewRelic, I’m leery of using it in production. But I’m sure that over time this will change. That comes from the fact you are using NewRelic to monitor your node. What you need is proper Erlang instrumentalization tools like observer, node/function tracing, DTrace, etc... Using NewRelic in a distributed environment is simply impossible. I'd say instrumentalization and observability in Ruby and other similar platforms is a bad joke compared to the Erlang tooling. 
What the OP wants is probably: https://github.com/wooga/newrelic-erlang There should be a shit ton of monitoring and metrics in the Erlang stack. The telecom industry hasn't been using it for 25 years without an alarm going off when someone farts near a phone messaging router. As Phoenix gets more popular I'd expect companies like New Relic will just create Elixir/Phoenix plugins for it based off of the current Erlang offerings. 
To be fair, Channels are a concurrency primitive for client/server communication in phoenix. Comparing them with go channels make little sense, but to be clear, Channels are more than "just a websocket implementation on top of PubSub". Channels are implemented on top of PubSub, and we abstract the transport layer. We have WebSocket and LongPoll transports out of the box, but you could have others, say over a message queue like redis or rabbitmq. We did a lot of benchmarking recently since our latest released focused on performance tweaks. We're seeing half a million messages per second through PubSub on a Macbook. So using channels as a concurrency mechanism can indeed go well :)
Ha! Thanks.
I love elixir, but this highlights one reason why its not quite ready for prime time yet. Library support is important, if you can't trust stuff to work from hex, then that adds time to your dev cycle. I think this will resolve itself as phoenix hits v1.0 and the language gets more popular. Either old modules will be updated, or new ones introduced and gain popularity. I write a lot of node at my day job and was asked at our elixir meetup what would elixir need to convert node developers. The short answer was 100k hex modules.
Would term_to_binary/1 and binary_to_term/1 work?
A small, vibrant, and well-funded startup founded by Stanford alumni is searching for a back end engineer for our office in Austin, TX. Competitive salary with full benefits including 401k match. We are looking for engineers with experience or interest in developing with the Elixir language and Phoenix framework. Help tackle concurrency issues, develop our REST API, apply business logic, and handle big data. Considered a plus: memchache, Docker, GoLang, and Data Warehousing experience. Aspiring full-stack engineers of all types are also welcome to apply. Required experience: Software Development/Engineering: 5 years Please send applications to joeyr@leaf.ag
I want to serialize to string to implement memoization on top of a key value store like redis (maybe I am taking the wrong road). I have to check if redis elixir library could handle binaries as data type
Use a Elixir JSON library, quite a few are listed here https://github.com/h4cc/awesome-elixir#json
tl;dr Be careful when passing string arguments to Erlang code from Elixir code because Elixir strings are not Erlang strings so the types typically won't line up unless you single-quote.
String.to_char_list/1 is your friend when passing elixir strings to erlang.
Good job! Really liking how people make stuff for Elixir almost daily.
This is exactly what you want. It's what we do in phoenxi_pubsub_redis, for example: https://github.com/phoenixframework/phoenix_pubsub_redis/blob/master/lib/phoenix_pubsub_redis/redis_server.ex#L23-L24
I think you should consider learning Common Lisp first, along with ruby. I feel like erlang and elixir are pretty highly developed and complicated languages for a beginner to learn. Ruby and elixir occupy the same space and I believe that elixir may be the better language. But you need a foundation to build upon if you're going to learn such high level languages. 
Odd, I feel the same way about Ruby while loving Lisp and variants...
Each to his own, I can't follow the code structure with only ((((())))) and the (+ 2 3), I get lost there in my brain.
I agree, non-LISP code for me is easier to get around, but it is because i'm not used to it. For an absolute beginner it maybe doesn't matter, both LISP-like and non-LISP-like are alien. But most of the language have not-LISP-like syntax, so maybe it would be better for a beginner to learn and get used to that style (non-LIST)
If you have a short term professional goal then just focus on learning Ruby inside and out. There is a lot of work for Ruby programmers. Ruby seems easy to pick up but it is very hard to master without an understanding of the fundamentals of programming languages. Ruby is a weird language. Anything can be changed at runtime. Most rules can be and are broken. There is no real security for development such as static analysis or robust debugging tools. Because things can be done many ways you may be surprised or confused by other people's code. Isolation of modules is weak. Ruby encourages bad behavior with its casual everything is an object and pass by reference model. It's a cool language and even after five years I am still discovering new ways to use it. But I would no longer recommend the language alone for new projects. Ruby can be recommended on the strength of its community and the significant job market. If you, like other commenters balk at the syntax of Common Lisp then I feel bad for you, son. Lisp has important, built-in lessons that will help you understand Ruby, elixir, erlang and any other language you may learn or use. 
I only program in my spare time (and at the moment I build a web crawler at my company in Go to beat the one that was build with Python). I dismiss a language because of the syntax, if I program I want to have fun, not a battle with my () keys. Lisp/Scheme/Racket is just not for me, I tried them.
I don't know if Elixir is in the best place for noob land. There's a couple of books out for it that are actually pretty good, but they tend a little towards someone with a bit of prior experience. Also it's generally more fun to learn a language and do something immediately useful with it and Phoenix is sort of the "do really useful things quickly" tool for Elixir. But Phoenix doesn't have much out yet in the way of tutorials. Ruby + Rails has a huge amount of learning material out there for it aimed at all sorts of learning levels. Learning that and getting comfortable with it would also probably go a long way towards Elixir + Phoenix. 
This certainly shows many of the concerns about dynamically generating functions, but readers should note that this learning example is actually a very poor real-world use of macros. There is a bunch of difficult-to-grok macro code and a block of seven one-liners to replace a block of seven easy-to-grok one-liner functions. The real value of this sort of macro is if you don't know the set of values which are going to be useful in production or if that set of values comes from some large, unwieldy source which can be analyzed programmatically. In essence, while this is a fine example of *how* to write this sort of macro, it is a poor example of *when* to do so and knowing both is very important.
Will make sure to keep 'em coming then! In fact, will be releasing a new episode in a few hours :)
I think the reason there aren't many tutorials yet is that phoenix is so quickly changing. According to its creator, it will finally reach 1.0 this month, and we can actually start making useful tutorials. For now, find some simple stuff in github gists and using elixir-Lang, see if you can follow what's happening. Try to make changes and see what happens. 
HiPE can be very cool, but it is tricky and there aren't many good resources even from the Erlang community to talk about it. The two biggest drawbacks are that some code is slower when HiPE-compiled and context switching between HiPE-compiled and BEAM bytecode has a performance cost. Other things to consider are the compliation speed being much slower, larger file sizes, the HiPE compiler is less-well-tested and thus a bit buggier, and managing different compiler options for different environments. If you want to start using HiPE, the most obvious way is to find some module which is doing a lot of internal heavy lifting and include @compile options for just that module. Note that Elixir is currently not compiling to HiPE o3 (o2 is fine?) and that can cause some performance problems if you rely on Elixir standard libraries in your HiPE compiled modules. Pretty much everything from the 2003 paper continues to apply. Many of the issues are unavoidable given the decisions in BEAM and how to translate those to native code.
I guess coming from a different background I wouldn't have expected a temporary directory function to create a new directory for me, to insure it's empty or to get rid of it when the code goes out of scope.
When talking about Elixir, does anyone know what he means when he says: &gt; I find the macro system to be a bit inconsistent [...]
As in what's the macro system, or what's inconsistent about it? Edit: I'll just go ahead and answer either way :P 1) What's the macro system? It's the metaprogramming side of elixir. 2) What are its inconsistencies? Well, I think this is more of an opinion. He may just not like the way it works, or perhaps enjoys another languages meta features more. Maybe he doesn't like the AST.
Very cool. Would also be cool for the code to run in-browser using this project: https://github.com/bryanjos/elixirscript
I've been using IntelliJ myself. 
atom here, and have no problems with memory or speed ( powerfull computer and gentoo compiled locally :) ) pretty happy with atom !
I'm a long time emacsen but have been using Atom more and more for Elixir. Still using emacs for Clojure though.
I really like Sublime Text but honestly I can't tell if it's abandonware or not. I hear different things every time I check. It'd be fine if it were abandonware as long as the community could pick it up but I'm not sure that will happen either.
No way, they guy making it is REALLY thorough in testing it from what I understand.
You'll probably generate a new Elixir program using `mix`, like so: mix new foobar In the generated directory there are two important files: `mix.exs` and `lib/foobar.ex`. Open up `lib/foobar.ex` first, you'll need to add a `main/1` function which is going to serve as your entrypoint just like in C. defmodule Foobar do def main(args) do IO.puts "Howdy, reddit!" end end Now open up `mix.exs` and add this to it: def project do [app: :foobar, version: "0.0.1", ... escript: [main_module: Foobar], # Add this line deps: deps] end That will tell ebuild where to find your `main` entrypoint. Now that you have that, run `mix escript.build` and it should generate a binary file called `foobar` in your root directory. Run that and it should print "Howdy, reddit!"
&gt; When it's said that processes can hold state, is that a violation of functional principles (making Elixir a not-entirely-functional language), or is the author using it to mean "Parameters passed to processes do the job state would do in some other language"? Well, 'functional programming' means many things to many people. Even hard-core FP has a concept of state, but the issue is how does that state mutate. Whenever a program works independently from another system without guarantees of the order of execution of certain steps, there will be opportunities for guarantees of results to fail. Code execution within any single process has immutable data, so many would say that the language is 'functional'. &gt; Is there a plan to create Elixir wrappers for the Erlang standard library (things that don't exist in Elixir itself like random numbers etc) or is hooking into Erlang stuff intended to be part of the language long-term? Elixir is very deliberately *not* reimplementing or wrapping Erlang standard libraries unless there is a very good reason to do so. Exactly where that line is has shifted a bit over time, but the expectation is to use Erlang resources when they make sense, not hide from them. &gt; Are there any resources you would recommend for learning about Elixir other than Dave Thomas's Programming Elixir, Chris McCord's Metaprogramming Elixir, LearnXInYMinutes, and the stuff already in the sidebar? OTP is the real reason to be using Elixir or any BEAM-based language. Seriously, go learn it and construct programs using those pieces. Part of that is going to be easier if you learn enough Erlang to interface with the Erlang ecosystem. For an introduction to both, check out [Learn You Some Erlang for Great Good](http://learnyousomeerlang.com/content). Just read up on the syntax of Erlang (which maps *very* simply in almost all cases to identical Elixir) and then read all of the OTP stuff.
Having a `main` type function implies that there is some central thread of execution. In Erlang systems this not so, there are a (large) number of processes working together but no central process. The Erlang system design very much resembles an OS. It is not so much a language with concurrency but rather a concurrent systems with a language.
Yes, but about LFE it's referring to how things was a few years ago. With 20/20 hindsight, because of the way LFE has developed, I would now have called it ELF, Erlang Flavoured Lisp, instead. And the interpreter can interpret everything the BEAM can. Compiled macros are on their way but they do make system development more restricted.
Vim, a tiling window manager, bash, an iex REPL, a style linter, and a [mix task](https://hex.pm/packages/mix_test_watch) that automatically runs my tests when I save a file are my usual tools. :)
This is an ideal use of Elixir. Am currently implementing my masters thesis code on neural networks in Elixir, and it works great for this. Am implementing a variation of NEAT (https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies). Each connection is a process, each neuron is a process, each network is a process, each genome is a process, each species is a process, each population is a process, etc. One issue you'll run into is the vast majority of Artificial Neural Network code in the wild is implemented as imperative C++ or Java, where certain assumptions can be made that can't be made when you implement it as processes. Such as how to handle recurrent connections in genomes and in networks.
That looks interesting. I'll check it out in detail, thanks for sharing. Another interesting direction to explore apart from "effectiveness" is "scalability" , which is why I started thinking in this direction in the first place. From a cursory glance it looks like evolutionary technique would be easier to distribute (compared to gradient descent) given an efficient message passing interface. Also, has anyone compared HyperNEAT to state-of-the-art techniques such as Adagrad and Adadelta? http://cs.stanford.edu/people/karpathy/convnetjs/demo/trainers.html 
Also, what do you think about the results published in the Deep Q learning paper - https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf How do these training techniques compare with something like HyperNEAT
Good article. I have a rails background and this helped me understand the toolchain and look and feel of a Phoenix app. Thanks!
Doesn't Erlang/Elixir run into perf issues once you erect a few hundred nodes due to all the crosstalk?
To expand upon this, I had 0 vim or emacs experience and dove into spacemacs. I'm slowly getting better and would recommend others do the same without fear.
I've found that pattern matching eliminates a lot of logic like this
Yes, since the Erlang VM uses a gossip based protocol there becomes too much chatter over the network. There are those who have got past the limit through using several routers in between clusters. See this video for more detail: http://www.erlang-factory.com/sfbay2015/jamie-winsor
Is this by chance an open source project? Would love to see it...
Doesn't work on my Nexus 6. The header covers half the page as well as the input boxes.
+1 I'd love to know more about this too. Or even just some projects that are actively looking for help.
Do you have any materials discussing this? I've never heard of this before and I'd love to read up.
Just came by to offer encouragement and say that this is a really cool idea. I too work with Scala for most of my stuff/day job and am interested to see what sorts of data processing functionality (ML, DL, parsing, munging, etc.) the Elixir community can come up with. Right now the Elixir community seems to be focusing on the web (which is great...Phoenix is amazing and is elevating the standard of modern web frameworks), but I have to imagine that there are tons of data processing use cases as well, given the presence of things like pattern matching, destructuring, and massive concurrency/distribution in the environment. All the distributed systems apps that are currently implemented in Java/Scala, that may find more interesting or easier-to-reason-about implementations in Elixir/Erlang...it's an exciting time!
A thorough web authentication framework would be great
I don't know how to find missing libraries other than building stuff and finding that I need a library that doesn't exist. I'm working on a bigcommerce library now, since my companys web store is being moved to bigcommerce and I need some apps to integrate with it. The bigcommerce API is huge, and I'd be happy to have some help!
Why not help with existing projects?
How much Elixir do you know already? Picking up and using more Erlang specifics is as easy as learning more Elixir. You can focus on learning Elixir specifics first, and do a lot with just that, but you will benefit from reading a good Erlang book or two too.
It's in your interest to learn as much about Erlang as you can long term because everything already built for Erlang can be used with Elixir, but while being new you can strictly focus on Elixir. Once you understand how things work in Elixir, it's easy to see the parallels in Erlang. 
I feel like I can use phoenix and rarely call erlang functions, since it has so many convenience macros built into it and libraries available. In bare elixir modules, I tend to try to avoid dependencies and use existing erlang functions where possible, like httpc and time/date functions
None
You don't need to know more Erlang than you'll automatically pick up along the way. What you need to learn about is OTP and the amount of resources for doing that goes up drastically if you can at least read Erlang source.
I'm sorry--a lot of logic like which?
As I said, it's not so much the URI per se, it's the general idiom. I could apply this same logic quite easily to building a record in a CSV file. It's the same issue; on every element of the list except the last one I need some behavior. On the last one I need almost the same behavior but I need a small variation. In the case of a record for a CSV file, I want all the elements except the last one followed by a "," Could I do this with a fold function? Of course I could. But to me the separate function clauses make the intent a bit clearer. YMMV. :)
I've mirror the content of the article in a gist for you: &lt;https://gist.github.com/slogsdon/5799634562bf476363c8&gt;
This project seems to be decent: https://github.com/hassox/guardian
Hey OP /u/ugisozols can you update the URL?
This looks awesome, I will definitely reference it when it comes time to integrate a new API with websockets.
I'll be there weirdo here, as I use: Sublime Text 3 with the Vintageous (VIM) plugin. I also have the Elixir and ElixirSublime plugins for code completion. Has worked for me so far, but I'm only about a month into Elixir. After looking at people's responses, I'm really curious about Emacs with Evil-mode now. 
sry all for the cert issues. I'm waiting for letsencrypt to launch to get the certs I need.
Riak is built on Erlang.
Have a look at https://github.com/inaka/edis ; an Erlang implementation of Redis
Hiding in plain sight. I had not heard of doctests before, so thank you for pointing it out. Cool stuff.
No problem! I'm a huge fan of doctests, one of Elixir's top features in my opinion.
&gt; should put us in shape for a 1.0 release sometime next week Woohoo! Can't wait!
Let a thousand flowers bloom :)
I would love to see if we could set up some sort of experiment to see which version developers would find easier to comprehend--the Enum.join version or the pattern match version. I'd think it'd be the latter but I would be interested in seeing some empirical evidence one way or the other.
Why does it generate those function definitions?
Well, if you re-read the post carefully, that was exactly my point ;-)
Are you really using wordpress for this? 'cmon
Lol, zeg ik niet.
I would second this, good idea
Its temporary. I am trying to build something based on elixir 
For those unable to attend, it would be nice to get a web version of the slides/teachings
I'm building a [code style linter](http://github.com/lpil/dogma). It's a lot of fun. :)
A massively parallel miner of an API. Unfortunately I can't say more than that :P In the process I ended up making a [geocoder hex](https://hex.pm/packages/geocoder), a [maybe/result monad hex](https://hex.pm/packages/towel), and a [hex that provides the same Keyword API but for Proplists](https://hex.pm/packages/proplist) (list of `{string,value}` instead of `{atom,value}`). Also contributing to [Crutches](https://github.com/mykewould/crutches), which is a swiss-army-knife library of convenience functions.
Glad you think so. :) There's a lot of issues there, but not to worry, it's mostly a big TODO list to myself. They do get closed!
I'm working on an API wrapper for Pagerduty. I want to include the wrapper in a CLI app once I'm done with it. It's my first Elixir project and I'm using it to learn.
I'd love to help out but I'm still new any chance answer a few question if I get stuck?
Yes, of course! The more the merrier. Always happy to talk code with people. This project is mostly intended as a learning experience for myself anyway.
Trying to think of something to write! I'm more into the backend style development, so I want to do something that consumes some information, processes it and stores it. Anyone with ideas let me know.
That's a cool explanation, but I didn't see anything regarding this code: defp do_delete_at(list, index) when index &lt; 0 do list end Wouldn't that mean that `List.delete_at([1,2,3], -1)` would return `[1,2,3]` or is there something being done in the gateway List.delete_at/2 ?
Recently continued a small little project of mine. It's a DSL for parsing/loading binary data https://github.com/ScrimpyCat/Tonic It's not so much of a serious project as just something fun that I could mess around with Elixir's metaprogrammability features (which was one of the key features that interested me). The implementation itself is a bit of a mess (first Elixir project). And I already have found some better ways of dealing with things, so I didn't have to do so much AST stuff as I did. I also think it could've been designed better, but the idea kind of just grew from something simple. Next I'm about to start on an Elixir project using Phoenix Framework to implement a backend service that will be used by an iOS app. Thinking it'll be a mix of REST API and channels. 
My experience with Elixir is limited to playing around and doing some katas. I haven't felt like I need to know any Erlang. My comparison here is Clojure where using Java methods is an expectation within the community. 
You might occasionally find some places where you need to call into Erlang standard library from Elixir when it's something that Elixir puts directly in its own library. This just happened for me last week when I was wanting to write a function to generate an N-length URL-safe random string. I needed to call an Erlang function `:crypto.rand_bytes/0`.
I think this would be a cool topic to start periodically, like once every month or two. It's cool to see what people are working on and willing to talk about.
Well I think it should be easy enough to get it done :-) maybe someone can even write a reddit bot in elexir to post it :-P 
Semantically Elixir and Erlang are near identical, so on the rare occasion I've needed to read Erlang code it has not been too foreign for me. I've not yet going a situation in which I've needed to write any Erlang.
Thanks for the protip. It looks like it just covers Elixir and not Phoenix itself. On that subject, the [top link on r/elixir](http://blog.plataformatec.com.br/2015/06/elixir-in-times-of-microservices/) looks like it covers the same application: RPC where HTTP/JSON is not necessary.
And on IRC. Freenode #elixir-lang
How interesting. I'll take a look at that book, but it sounds like you'd never need more than one running Phoenix process since its concurrency, er, issues are handled by other processes? By that I mean Ecto having n connections to the database, Cowboy having n connections available to the user... That, contrasted with Rails requiring a forking model to give n Ruby processes. I'll delve into the book - thanks for your response!
`OptionParser` doesn't do much, and tries to guess a lot; which means more work for me usually. `argparse` I like better because the interface must be well defined, anything that does not conform is denied (and a helpful error message printed). I also missed the generated help messages :)
Cool write up. I've been using erlangs httpc for the requests, because it doesn't add dependencies to my library. Any reason you needed to use httpoison?
I think that user auth is so elemental to *every* phoenix app (well, except those hello-world-style examples), that it should be integrated into the framework core. Fiddling with it every time just feels wrong. Meteor does this exceptionally well, to the point that you just have to decide where you want your login/logout-buttons in the template and it works, with email/password or OAuth or other token-based auth mechanism. This is a real productivity boost to get started fast. The fastest way to get going for me has been https://github.com/opendrops/passport for me so far, it's far from perfect but at least I *"just"* have to copy a few templates/views/controllers from the readme page to get going... Of course one can do everything from hand everytime, customized like there's no tomorrow, but getting to something working instantly is something I *expect* from today' web frameworks :(
maybe something like : https://github.com/manukall/phoenix_token_auth ? Its pretty customizable, i use it for auth with my frontend emberjs apps.
We're nearing 1.0 and you're wondering why a feature doesn't exist that can currently be dropped in with a library that already exists. It's MUCH easier to add features to frameworks than take them away. I don't want core devs solving problems that have already been solved in elixir. I want them working on features I can't already find a library for and I don't necessarily want auth part of phoenix anyways as not all auths are the same, but if I did want it - I would certainly never put it in for 1.0. Feature creep is real and I don't think you lose any productivity if you're adding in modules as opposed to just having auth already in phoenix.
Phoenix does have some token auth built into it as of one of the recent releases. https://twitter.com/elixirphoenix/status/629691289638989824
Great call on guardian. That looks like exactly what I was looking for. 
I would much rather see things like JSON parsing included in the standard library before authentication. Authentication can vary widely between applications.
+1 for httpc. I've found it to be quite straightforward.
The basics of jwt consists of 3 parts, a header describing the algorithm used and the type, the payload (the data you want to pass around), and the HMAC signature to ensure no tampering has been done. Your data is json base64 encoded, so you can use it on the client and when sent down to you won't have to worry about someone tampering with it as you verify the token. There is a lot more surrounding it like JOSE, JavaScript Object Signing and Encryption, and a good high level overview can be seen here http://manu.sporny.org/2013/sm-vs-jose/. You basically have JOSE being the superset of everything, JWT being a token that uses either JWS or JWE (signing or encrypting), the JWA being the supported algorithm and supporting info in the header. All of this is going through the standards process as well. So really, what you can say it does is offer you a standard approach to tokens. It allows you to choose your use case for the tokens (do I need the data on the client, do I need the data encrypted where it could get intercepted, do I want to be as secure as possible)
Don't take this as rude, and I understand your decision. I just am strongly opposed to it on the basis of dependency. I also work in node professionally, so I'm sure that biases me as no one really questions dependencies. If the argument includes you wanted something quickly for v1 that makes sense too. I still believe that a future Phoenix version should get proper JWT. Nonetheless, yourself and other contributes should keep up the great work as Phoenix is making a ton of progress!
aka a monad
Yeah. Except this articles promotes functions like this : {:ok, var} -&gt; {:ok, res} | {:error, reason} Monads are way better in the sense that you define functions as : var -&gt; {:ok, res} | {:error, reason} which is much better imho because many functions are already compatible.
Yep. Except not "aka a monad". It's been my observation (and perhaps you've found different) that in computer programming, it's details that count. Saying something is sort of like some other thing isn't saying they're _exactly_ alike because details. Hair-splitting, persnickety details. 
WxWidgets is probably what you want. I'm not sure how other desktops handle it but on any GTK desktop, you won't notice it's not natively GObject. For reference, type :observer.start from iex.
Congratulations, /u/chrismccord! 
This is awesome! Congratz!
Very nice, thanks!
Awesome Thanks!
Awesome :) Thanks Chris
Awesome!! :)
Sure, people have integrated Node.js servers with Rails for those types of use cases in the past. There's no reason you couldn't do the same thing with Phoenix. There are a million ways to handle authentication, so it's hard to comment on the best way to share auth between the two. The other thing is routing requests to the right app server. You might try setting up nginx to handle traffic and then (for example) route websocket traffic to Phoenix and route everything else to Rails.
Thanks for the recommendation. I like to use `httpc` as well, but I wanted to show how easy is to add a dependency. That is why I use `httpoison`. 