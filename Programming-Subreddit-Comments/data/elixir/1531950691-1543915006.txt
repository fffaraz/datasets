I'm going through [Programming Elixir](https://www.amazon.com/Programming-Elixir-1-6-Functional-Concurrent/dp/1680502999) and loving it! I feel like what I'm reading makes sense and is written in an easy to understand manner.
The thing is, if you really just want to do something *super* basic with a GenServer, then in Elixir you can use an Agent. I think if you're using a GenServer to do something of any kind of complexity, the two boilerplate functions (`init` and `start_link`), are usually only 1 line a peice, and take up a very small amount of the overall code. In the example in the video (a Stack), then using Agent would be much better. Here it is, 3 lines/3 functions: defmodule Stack do def start_link, do: Agent.start_link(fn -&gt; [] end) def push(stack, item), do: Agent.update(stack, fn(state) -&gt; [item|state] end) def pop(stack), do: Agent.get_and_update(stack, fn([h|t]) -&gt; {h, t} end) end 
&gt; I have a defined start_link elsewhere. What do you mean? `start_link` should be defined in the module. In your test you directly call GenServer's start_link to start your GenServer, you should call your module's start_link, not GenServer's.
I love how this guy is recording this video at 1:40 AM üòÜ
When it fails you get an error message with the data it attempted to match, so there's no need to attach a debugger at all (which you cannot do to a production system anyhow). The development version of elixir will even spit back at you the patterns it attempted and highlight it so you can see why it failed. How is a procedual approach where you have to hook up a debugger and step through the code a clearer way for others to read your code (or vice versa)? I think you're just not yet warmed up to the idea and are retreating to your comfortable corner, that's ok it's human nature. Just try to give it time and let it sink in, it's different and that takes time for our brains to become accepting of the change.
Is there a way this could go in the sidebar? Very useful for outreach
I'm not sure if the side bar has been updated in years.
Then it might be due
 i.e. func(1, 2, a: 1, b: 2) would become (1, 2, [a: 1, b: 2]) Both of these are the same. the example on the left is omitted the square brackets, but compiles to the same thing on the right. Keyword lists are typically used for options due to their ability to hold duplicate keys. Lets imagine we were building an image editing library. options = [crop: "square"] Now what if I wanted to pass multiple crops? options = [crop: "square", crop: "circle"] I can't express the same thing in a map, because maps can't have duplicate keys, nor do they preserve an ordering iex(1)&gt; options = %{crop: "square", crop: "circle"} %{crop: "circle"} # it dropped the first one 
When would you want duplicate options?
&gt; Keyword lists are typically used for options due to their ability to hold duplicate keys. That makes sense. Thanks!
Maps are not preferred, they're for a different purpose. Think of maps as large pieces of data that you can extract pieces of for operations. Keyword lists are primarily for operations where you want to go over every piece of it- whether because of duplicate keys, wanting iterative key/value pairs, etc. The expectation with function calls is that the keywords presence matters.
For two situations. 1. When providing an option twice is valid and each time will be used. My crop example tried to illustrate this, but if you wanted to format an image such that it cropped it to a square, and then a circle. calling format(image, [crop: "square", crop: "circle"]) would be a situation where multiple options of the same key could be a valid situation. A second example of this is ecto, when you have a query with multiple `where` clauses. [where: a.id == ^id, where: a.weight &gt; 0] 2. You're building up the options list through a series of function calls, and you only want the last option. This is in some ways equivalent to a map, with the difference being that the keyword list preserves an ordering. This could be important to the function, where the presence of key a before key b could have different behaviour
That makes sense. I've always thought about it as being map-like, because in some ways it is. But thinking about it as exactly what it is, a list of tagged tuples, is probably a better way for me to think of it. 
There's an entire ecosystem reason to have keyword lists. Keyword lists are compatible with most of Erlang's options arguments in the erlang libraries. Maps are a real newcomer to the Erlang sphere. They landed just before Elixir went fully 1.0, and when Elixir was 1.0, they weren't even as good as HashDict's then (now deprecated and not usable for much).
I think keyword lists are the default with the \`func(1, 2, a: 1, b: 2)\` syntax because maps didn't exist at the time that syntax was created.
Yup, this'll also help you design better code with it by thinking this way. "Do I need everything(or need repeats), or do I not?" really is the best way to think about them for me.
What do you mean by the default?
If it's not matching and you can't tell why, the simple way to debug that is to add another function clause like: def pick_color(image, y, x, z) and then inspect what is being passed into`image`. But if you prefer doing the conditional logic inside a single function, just do it! You're writing code for yourself, not us, so do whatever works for you.
While I did like the look of the component in Dave Thomas's example, I'm not sure if it's really needed or if the abstraction will just make things more complicated. Like I already avoid having my genservers be very complicated, all the code they contain is simply what messages to respond to and how they manage their state. All of the logic behind that state manipulation I put else where. I also don't make convenient functions to perform the message sending if that GenServer is meant to be a public interface (I'll instead put it in a separate project). Since structuring it that way for publicly exposed genservers becomes a barrier with how dependencies can be structured and how you might like to deploy your app. While I certainly have a lot of repetition, I'm not sure if it's at the point that justifies having it all abstracted away. As far as your specific wrapper, I think structuring it that way might end up getting quite complicated (as there's a lot of possible behaviour choices someone might make beyond those simple match expressions or assuming the end result should update state). While I assume you'll have an alternative case as a catch all to include the more complicated logic. If it ends up where you're just using that alternative, then the DSL provides even less usefulness. So to get the most out of it they need to design their genservers in the way your DSL intends for them be done. 
tbf, in most cases (ecto being an interesting counterexample), providing multiple values is just as easy and imho more readable as a list passed in as the value to a key. it is als9 more explicit (easy to end up with duplicate keys in a keyword list, harder to accidentally have a list of entries as a value in a map) I think the real reason is likely to be ecosystem related as /u/asonge pointed out in their comment
It's important to remember that keyword lists are just lists of items, namely tagged tuples. When used as a function's trailing opts, they are more flexible (b/c of the repeatability mentioned here) and don't need to use an optimal representation (since they will normally be exhaustively consumed). It's also a very permissive opts API: many erlang libraries accept options lists where tagged tuples are the most common entry‚Äîbut in edge config cases as needed you can pass simpler/more complicated entries into the options list. This can be made to read well in elixir by treating the last parts of a list literal as a keyword list, only: ``` [:foo, :bar, :baz, fizz: :buzz] ``` I would think of kw lists to maps as atoms to strings: one is for developers writing code, the other for user input.
&gt; Boilerplate generally is an opportunity for error. This is why elixir provides the `use GenServer` macro. It provides a default implementation of the 6 required callbacks.
Calling \`func(1, 2, a: 1, b: 2)\` is the same as \`func(1, 2, \[a: 1, b: 2\])\`, not \`func(1, 2, %{a: 1, b: 2})\`
I cannot get why to not pass a list of values? I think it's more clear. format(image, [crop: [:square, :circle]]) IMHO proplists syntax for function is just from times where there is no maps in erlang and people in erlang community was forced to use lists of tuples or atoms to pass configuration. I even can't remember when some one in erlang community do such a thing like an options duplication.
I'm working on an APM (Application Performance Monitor) for Elixir apps. The idea is that it only runs commands that you tell it to run, and gives you the outputs per server. Beyond some stats charts, it will be able to do things like "Give me top 10 processes by memory" or "Give me top 10 processes by reductions occurring in a 5s period" The commands will be configurable, so you could have a custom command for your app specifically like "Kill the supervisor tree X so it can restart" or "Run GC on all processes" It will be fully OSS
this is the first time I've heard such a thing sounds wrong
It depends on how you define performance. Mostly for small project speed of development is utmost important. Elixir and Phoenix is capable of doing 99.99% types of projects. Only downside of elixir is lack of libraries as compared to ruby and nodejs. Most of the time small projects builder prefer to use already available libraries so i guess in that point of view elixir can impact performance of small projects. 
I think I just gave a bad example, I‚Äôll try to come up with a better one
tl;dr Shell out... MIND BLOWN.
Erlang for most developers was it‚Äôs ecosystem and the language‚Äôs syntax. 
Amazing, you all rock! 
Doesn't make much sense to me. Performance is generally going to compare pretty well to competing languages, though there are certainly ways to self-sabotage performance in certain areas. I consider development speed to be very good, though there is a learning curve that varies depending on past experience. i_am_pro's point about fewer libraries is valid, especially if there are large portions of the program that you know there is not already support for in Elixir but there is in other languages.
I've messaged the mod about putting Alchemist Camp in the screencasts section since 1. All three of the current links are to out of date, discontinued projects 2. Alchemist Camp is the largest source of free Elixir-learning screencasts 3. and I've only been doing this since December so it's up to date. I got zero response, waited a few months, tried again and got zero response again. I'd love to see the sidebar updated though...
it was exactly what I wanted to ask. thank you for the answer.
Speed on most small projects will actually be very good. Your options stay flexible if you run into almost any kind of desired functionality. There are fewer libraries as mentioned than many other languages, however in the erlang ecosystem this is because in many cases one solution was very good and becomes standard. In a large project speed becomes great because of the maintainability of a functional code base in a lot of cases. In a small project it is usually close enough and faster to develop. Dunno if I have examples you are looking for but here is: small project developed fast and modular https://github.com/Tyler-pierce/simplestatex Small erlang project converted to ex and expanded https://github.com/Tyler-pierce/giza_sphinxsearch Large project split into smaller parts with modular dependencies (not as much so as it should be as it was an early project) https://github.com/smileys-tavern/smileys_umbrella much of that code is easy to refactor, concurrent, or was developed twice as fast as I could in the main conventional languages (much of that is purely my experience of course and varies person to person!). The cost is the up front learning curve if you aren't from a functional language like prolog or erlang
`alias Identicon.Image` `def pick_color(%Image{} = image, _y, _x, _z) do` `%Image{hex: [r, g, b | _tail]} = image` `%Image{image | color: {r, g, b}}` `end` That better? :)
Page not found!
It works for me, but you might try [https://hexdocs.pm/envio](https://hexdocs.pm/envio) FWIW.
Lists of integers are treated as characters when printed through IO.puts. $ iex()&gt; IO.puts [104, 101, 108, 108, 111] hello :ok For fun, you can see the character code of a character by prefixing it with ?. $ iex()&gt; ?a 97 
Only just a few, small change. I like it this way üôÇ
Oh man. I **just** learned 1.6 and now I have to start again. :(
Yes. You have to relearn everything. It‚Äôs true. :)
I just threw all my books into the fireplace. (pdfs into recycle bin)
Wasn't property testing supposed to be in 1.7 or am i misremembering?
I think quality-of-life changes are not a bad thing at all to focus a release on. "You mean my very-nice language just got nicer? Right on!" It can get faster some other time, haha
I wish I were moving along more quickly with my self Elixir teachings. I‚Äôve wanted to work for ThoughtBot for years, but I‚Äôm trying to transition away from Rails. Fingers crossed they keep growing their Elixir staff!
Just wanted to share with you this post I wrote. I hope you find it interesting. I'm happy to read your feedback and comments. If you want to chat about something in the realm of programming, feel free to PM me.
If you are nearby, you should try anyway. Most companies doing Elixir know they have to train developers too, so you may get to work there AND learn Elixir in one go.
just go ahead and apply. I'm sure if you are experienced enough in Rails, that could convince them you can be valuable to them.
Interesting article! I found working with `:gen_tcp` to be quite tricky in a project I did for my work. In particular, it doesn't seem to integrate super well with `GenServer`s unless you use `:active` mode. How are you integrating it into the GenServer since you've changed it to a blocking call? Did you give up on handling other kinds of messages? Is it in a supervision tree? Do you have a backpressure mechanism? I actually went the other way around. I started with an infinite loop and `:gen_tcp.recv` but I found it was more important to have all the OTP goodies, so I switched to the old `active: :once` / `:inet.setopts` approach.
For a function's optional parameters use a keyword list. That's the convention in the Elixir/Erlang ecosystem. It's plausibly mostly due to maps being a relatively recent newcomer to the language. But one thing to consider is that for just zero, one or two items (which, in my experience, is usually the case when calling a function), keyword lists are [more memory efficient](http://erlang.org/doc/efficiency_guide/advanced.html) than maps. For `n` options, assuming the options are specified as atoms, and excluding the memory size of the options' _values_ which would be the same in either case, a map will take `5 + n` words of memory (on a 64 bit architecture 1 word = 8 bytes) while a keyword list (i.e. a list of tuples) will take `1 + 2n` words.
Damn that'd be a dream.
Love the love for devs.
I was only recently made aware of this language from reading a job posting. I looked it up and was immediately interested. That's not normal for me. I've been a web developer since the Internet reached the public in the early 1990s. So much out there just feels like hype. But the Erlang origin seemed to make it different for me. My immediately interest other than general web services is multiplayer online game servers. Here's my question. I watched the documentary in which the creator talked about needing the community to flesh it out. Perhaps it was a few years old. What's missing to use it right now for a multiplayer / clustered game server engine?
Well, it depends on the task. There is nothing stopping you from creating the server: Erlang processes can handle each client's connection, some other process, for example, to process game state (I am not a game dev). Really, Elixir right now is quite stable and mature and definitely ready for use in production. One thing you might find lacking is the libraries for some specific tasks, but thats what the community is about - you can contribute by creating the missing pieces. Other than that, Elixir/Erlang got you covered from TCP to sockets to a lot more.
There is a person writing a MUD in Elixir and keeping it open source: https://exventure.org/ (and here is a video: https://www.youtube.com/watch?v=mMP7S2i56So) I also think SquareEnix is using it for games too. They gave a talk at one of the ElixirConfs...
Erlang/OTP 21 came out last month and is expected to be 5 to 10% faster, part of it due to improvements from the Elixir team... count your blessings. :)
You can use it. There's https://www.merigo.co/ . There's https://github.com/oestrich/ex_venture . And others.
Killing in favor of other entries.
More information at https://twitter.com/Membrane__/status/1022557646677794817
Property testing is already available as an external lib https://github.com/whatyouhide/stream_data . Not sure it was supposed to be merged in 1.7 :)
I've never implemented a game specifically, but based on you description, I think Elixir is a perfect fit for that. You'll find the way Elixir allows you to spawn processes, very useful for handling the state or the actions performed by different players, and (if you decide to use a web framework) you could take advantage of the Phoenix Channels which are very powerful and easy to use when implementing realtime actions.
I am pretty sure you can write a multiplayer game server engine in elixir, but I am not sure it is the best language to do that. I have no experience in that field so I am just going o throw something out there and hope someone else can elaborate. 1) Keep in mind that elixir is immutable and thus a pretty bad number cruncher (is that important for this usecase?) 2) It also has a generational garbage collection, which I think I read a blog post about stating longstanding connections can lead to huge memory consumption if some of your data survives a few garbage collection cycles, which is usually bad for data that changes more or less randomly - which I think might be a problem for this usecase? 3) I love the elixir community and I actually see the lack of solutions as a chance to contribute, but if you want something robust as quick as possible, you would usually look for battle tested solutions in other languages. Basically what I am saying here is, if you want a multiplayer server solution in elixir, you might have to code most of it yourself. Can you elaborate on what a multiplayer server engines core features are and what that means for the underlying application(s)? It might be a really nice usecase for elixir.
Thanks! My receive loop still lives in a supervised GenServer process. Basically, at the end of my `connect` callback (I'm using Fishcakez' [Connection](https://github.com/fishcakez/connection) behavior), I cast a `:recv` message to myself: def connect(_info, state) do ... GenServer.cast(self(), :recv) {:ok, state} end On every `:recv` I do my blocking call to `:gen_tcp.recv/3`, handle the resulting data, and conditionally loop with another cast: def handle_cast(:recv, state) do with {:ok, message} &lt;- recv(state, 24), ... do GenServer.cast(self(), :recv) {:noreply, state} else {:error, reason} -&gt; {:disconnect, reason, state} end end So I still have all of the niceness of using an OTP GenServer, like being able to handle other process messages between receives. I don't have any backpressure mechanisms in place yet. I should probably think about that... Check out [the full GenServer module](https://github.com/pcorey/bitcoin_network/blob/master/lib/bitcoin_network/peer/connection.ex) if you're interested. 
That said, I can definitely see the merits of using active `:gen_tcp` connections. In my case though, going passive simplified things quite a bit.
Depends on how you do it or why you need to do it. Elixir and Erlang are great at processesing data like that if you can partition it somehow into chunks that can be executed asynchronously. It may not be the fastest syncronously but it in my opinion has the best language builtins for processing data period. Also it does really good at streaming constant data. What are you trying to to accomplish?
We do some heavy XML parsing/processing at my work using https://github.com/willemdj/erlsom. We've managed to get pretty good performance out of it, and Elixir has proven quite flexible for our needs.
It's pretty fast, and you can use Stream to break large files into manageable chunks for further processing. The standard library has lots of very good tools for it.
Some time ago, I benchmarked Elixir vs Ruby for CSV + text transforms, and indeed Ruby was faster. I need to revisit this in the future, though, because both Elixir/OTP and Ruby are changing fast.
I'm not sure if it can be considered true but it is definitely easier to set up custom processing for large amounts of text now with https://hexdocs.pm/flow/Flow.html Used it myself and it is beautiful
Do you have a source for this? I'm interested in how they wrote the code. I'm not surprised that Ruby is faster if the Elixir code is not run concurrently.
I can't share the source (it was a quick throw away experiment), but I'll make sure to publish the next round. This was a "single-threaded" version, to compare raw performance.
Which CSV parsing library were you using? The fastest one around is NimbleCSV, unless you drop to C.
When I wrote this, I checked out NimbleCSV, but I can't remember if this is what I ended up using. I'll make sure to publish my next test for sure.
I feel like that's a very apples to oranges comparison, not that it's not a valuable experiment. It's like comparing a Prius and a Ferrari for speed or gas consumption, they are specialized for different things. 
I feel like that's a very apples to oranges comparison, not that it's not a valuable experiment. It's like comparing a Prius and a Ferrari for speed or gas consumption, they are specialized for different things.
I don't disagree here ; I'm using both Ruby &amp; Elixir in production today, for different topics. That said if Elixir continues to get raw speed (and maybe one day, a BEAMJIT https://news.ycombinator.com/item?id=14749227), I'll be perfectly happy!
I would disagree, at least partially. In most cases when you process textual data then plain old sh with few helpers is much easier than anything else, in a lot of cases it will even be faster. Even distributed work is quite easy thanks to GNU parallel. However Erlang is great when it comes to parsing streams of data (not only textual) that comes via network (as this is what it is designed for). So if you have bunch of files that you need to process then Erlang will lose, I would say that it will always lose, with sh. Why? For example, while pattern matching is great, it isn‚Äôt the best when it comes to patter recognition in rows of text, it is perfect for binary data though. Also I think that regular expressions in tools like grep, AWK, sed, ed and their more modern alternatives will be much better optimised than Erlang implementation (mmaping files, complex SIMD tricks, etc.) as you try your best to not use `re` module if you can. Raw Erlang do not have tools for such workflow with files. While Elixir has Flow it just adds more complexity, in this case, to the table with a little to no gain in less battle tested solution. So if you want to process files, then IMHO Erlang will be pointless overkill and overengineering. However if you want to have server that process data flowing in (for example centralised log processing server like Logstash) then Erlang will be perfect fit. 
It all depends on your exact usage pattern. Elixir can process text very efficiently thanks to iolists. It's part of the reason why Phoenix is so fast. Here's an explanation: https://www.bignerdranch.com/blog/elixir-and-io-lists-part-1-building-output-efficiently/
is Phoenix fast?
creating a service that'll deal with processing and transforming text data
It's certainly fast at building and sending responses across.
for the record, v1.7.1 released.(bug-fixed version) https://github.com/elixir-lang/elixir/releases/tag/v1.7.1
This is a huge "it depends" question. And actually a lot of what you may have heard/seen might not apply as much anymore with the relatively recent changes to file and network socket reading/writing and improvements to optimized binary handling in Erlang/OTP 21 and Elixir 1.7 (I think for Elixir 1.7, but definitely for Erlang/OTP 21). The best thing is to make sure you are using binaries. Here's a relevant example from about a year ago. https://www.reddit.com/r/elixir/comments/5qsquu/performance_of_idiomatic_elixir_code/ The comparison of the original poster and the 'best' response (by deleted, of course) are what you should look at. Other good resources are this: https://tech.forzafootball.com/blog/binary-parsing-optimizations-in-elixir and (though a little dated now): http://erlang.org/euc/07/papers/1700Gustafsson.pdf
In short, If you are trying to build a full parser then Elixir is going to be a little short-coming in terms of speed, but that speed is well made up for in terms of development time. It doesn't take long at all to build a parser in Erlang/Elixir.
"... or based on improper foundations (such as JVM or GLib)." I like that opening. The JVM took every choice I would not have made when making a primary language and virtual machine.
It's been a little while since I have used Elixir. I mostly switched over to Erlang for most of what he is talking about. I never learned Rails or Ruby so I'm a bit isolated from most of the things he was talking about. I learned Elixir first because I liked Erlang but Elixir had better support for a (brand) new programmer like myself. I actually prefer Erlang's syntax. It's more intuitive to me. The docs just weren't there yet (They're much much better now). The other reason I like Erlang more than Elixir is that Elixir seems to keep trending more and more towards meta-programming. Yeah, It has it's place. I've been jealous at times when trying to do something in Erlang, but Dave Thomas is bringing it to absurd levels in his ideas. Teaching a language focused that much on meta-programming makes it impossible to understand the underlying mechanisms. That was fine in Rails, from my perspective, since I never used Ruby.
It would be great if you added more detailed notes/code to the article. Sometimes I‚Äôm not in an area where I can watch a video but I like the topics you cover. 
GenServer still confuses the absolute fuck out of me. 
How so? 
So, while Erlang still uses quite a lot of charlists, they don't show up in most idiomatic Elixir programming. You get handed Elixir strings, which are binaries. Charlists are interesting for a few reasons (having to do with iolists in general), but I don't understand why you would reach for one in the first place. But here's a slightly clearer way to think of this: `'2'` isn't the number `50`, it's `[?2]` or `[50]`. However, `?2` *is* the number `50`. If you keep in mind that intermediate step, you should be fine.
You don't want to use charlists for this, as you've discovered they're painful to use. Everything you need is in the String module. Strings in elixir are utf-8 encoded. This means that one byte is not necessarily a character. The String module therefore uses a type called a `grapheme` to represent a character. `String.graphemes/1` takes a string as input and returns a list of graphemes. This is probably what you want.
In what twisted mind (except insane JS and PHP) `List.first('2') * 2 == 2`?
Me too :(
maybe i don't understand the full context of the exercise, but if you want a data structure to store a list of integers, why use charlists at all, nstead of just lists of integers?
I find much of the talk "too clever". But I think he's right that genserver is a bit of a mess.
How does it confuse you? There are people here who can help if we know what is confusing about it.
Screencasts are my main focus, which makes it a bit tough! I've added more detailed notes for the beginner episodes, and I'm working on it. It's a bit of a trade-off in terms of time. Source code (after the very beginning episodes) is one of the things I've made a perk for members so as to be able to sustain this whole project. Now that you point it out though, I can see how it would be frustrating if you use reddit where you can't watch video. So, I'll lift the restriction on code for a few days on anything I post to reddit! I don't mind if you bookmark the unlisted gist, but please don't share them with others.
Are you familiar with [ASCII](https://www.cs.cmu.edu/~pattis/15-1XX/common/handouts/ascii.html)? Basically, what's happening is you're encountering how the *character* 2 is represented in memory. Back when computers were expensive, we just used 128 symbols for everything and mapped them to 7 bits (or the numbers from 0 to 127) in the way shown in the table I linked. Later it was extended to 8 bits (or 0 to 255) for European languages and more characters. As you can see, the letter a is represented as 97 (or as 00110001 in binary) and the number (well actually character) 2 is represented as 50 (or 00110010). If you do math with characters in character lists, this will actually work with their ASCII values. This used to be fairly common in C programs and even in some scripting languages. Java and just about any language newer tends to use Unicode by default, since it can represent far, far more characters from more languages, emojis, etc. Elixir strings were created with Unicode in mind, but charlists are from an earlier era (and mostly just encountered via Erlang interop).
It's just ASCII. This C program will also print the number 2: ``` #include &lt;stdio.h&gt; void main() { printf("%c", 50); } ``` 
On 2), a massive advantage Elixir has over anything on the JVM is that its garbage collection is per *process* (of which there are often millions), rather than in one gigantic sweep. This keeps performance much more regular. 1) could be a huge problem depending on the kind of game server it is, but many servers aren't CPU bound.
The existence of that MUD is awesome!
Thanks!
It's because sometimes the list can also contain uppercase letters, which are then mapped to 10 + the letter's position in the alphabet.
Is ExMachina really worth it? In Ecto 1.0 it was helpful since inserting required explicitly creating Changesets, but since Ecto 2.0 you can directly build a schema struct and insert it in the repo. Check out chapter 7 of [whats new in Ecto 2.0](http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0) for a detailed example.
The error is saying that you are passing PromoCode where you should be passing a Discount struct. Double check your "factories" and also double check your schema definitions.
Exactly. ASCII is basic of basic knowledge. 
MajesticNail is right I had a typo in the schema. Absolutely embarrassing, if anyone has this problem, check your associations in the Repo schemas. My apoplogies!
What about tasks and agents? Are they any clearer?
Elixir is a good general purpose language with great async and concurrency abstractions. And with its NIF/FFI you even get things like [https://github.com/versilov/matrex](https://github.com/versilov/matrex) which according to their benchmarks even beats NumPy in some cases. So I would strongly consider it for many projects.
Coming from a PHP background and generally setting up a non stop worker, cron job or queue and then trying to digest GenServer is what I find most difficult. The setup process, where best to place module files, sending data to GenServer are just a few things I find difficult. Recently I wanted to setup a GenServer to query an external API endpoint, check stock levels and return changed data. Shit went south really quick and IEX just kept throwing error after error. Like anything related to Elixir though, I suppose it will just take more time before it clicks in my tech tard of a brain. There is no written tutorial out there for GenServer either. Most are just copying one another. 
I think a lot of people forget Erlang was built for telecommunications, so BEAM wasn't built to shift through tons of text, makrup, or markdown files. So consequently, Elixir wouldn't be any better than Erlang at processing textual data. I guess people really want to use 1 programming tool for everything: not that it's wrong, but there are proper/better tools for every job. If someone wants to be processing textual data, it's not like using `sh` or maybe even Python are going to be crippling to use in a project/system/whatever over doing everything in Elixir/Erlang.
Here's a screencast I did several months ago that sets up a recurring query of an API endpoint. It starts from scratch with a new mix project: [https://alchemist.camp/episodes/statwatch-worker](https://alchemist.camp/episodes/statwatch-worker) It's video, but it should be just the sort of thing you're trying to do.
Some time ago, we built [ex\_schedule](https://github.com/quiqupltd/ex_schedule) to abstract a scheduler behaviour using GenServer. Hope others find it useful.
In that case, I recommend handling both cases of numbers or letters through pattern matching and subtracting offset. So for example if a char falls between 48-58 (I forget the actual ASCII code but you can look them up in a table) then subtract 48. If it's bergen 96-122 subtract 86.
I second flow! I used it to speed up parsing 350k+ rows of data from 30ish mins to 4. I recently wrote a blog post on it.
Elixir has tools like Flow, GenStage and GenServer which ones you can build an efficient text processor. The thing is it might be slower than other languages but with Flow/GenStage you are spawning processes using the erlang OTP. That means if your 300kk lines file has a bad encoded line whole process wont crash without having to encapsulate everything inside try/catch and having to code specific logic for crashes. In Elixir you just let it crash. Also you can stream the file and use it along with AWS Kinesis or similars. But, if you dont care about the OTP benefits and data streaming then probably you are looking for a different language. To sum it up, I wouldnt say Elixir suck at processing a lot of text, I would say elixir sucks at processing text faster than other languages but rocks at doing it in a distributed way being 100% fault tolerant and being able to stream it, which, you could do that with other languages but having to code a lot more meanwhile with elixir is plug and play almost.
After a lot of work, here's my new book on Elixir! Also written by my friend and colleague Daniel Caixinha, it takes the reader on a journey to develop a Dropbox-like web application and deploy it on the cloud!
That's awesome! (not awesome: being without Internet for 4 days lol)
Doesn't GenServer have this functionality built in? &gt; Returning {:reply, reply, new_state, timeout} is similar to {:reply, reply, new_state} except handle_info(:timeout, new_state) will be called after timeout milliseconds if no messages are received.
On init, you can also return {:ok, state, timeout} after which it will send the message :timeout to your server 
This is awesome! I love the way you merged two awesome things you like :D Thanks for the post!
&gt; The other reason I like Erlang more than Elixir is that Elixir seems to keep trending more and more towards meta-programming. Please don't take what Dave is doing as a reference for meta-programming in the community. The most seasoned developers actively advise against meta-programming, including the official guides. If somebody thinks that the best way to address the concerns of a GenServer is with meta-programming, now they have two problems.
Ditch Jenkins and use Gitlab + Kubernetes. 
Does kubes support elixir yet?
Kubernetes can run any container. There is a publicly available debian elixir image here: https://hub.docker.com/_/elixir/
Jenkins has a kunbernetes plugin or jenkins-x.io
This is a blog post I wrote for CityBase blog regarding Elixir umbrella applications and how that concept helps to build code that scale.
i am a newbie myself but a quick search tells me this: clause: A clause is basically just the pattern that is matched against when calling the function. check [this](https://www.culttt.com/2016/05/23/multi-clause-functions-pattern-matching-guards-elixir/) . default value: this should be quite clear. the compiler basically wants you to remove ambiguity. that's by design. again, here's a [link](https://elixirforum.com/t/definitions-with-multiple-clauses-and-default-values-require-a-function-head/2643) to the same problem answered [here](https://elixirforum.com/t/definitions-with-multiple-clauses-and-default-values-require-a-function-head/2643/6) 
 defmodule Example do def func(p1, p2 \\ 2) def func(p1, 99) do IO.inspect "you said 99" end def func(p1, p2) do IO.inspect [p1, p2] end end 
Exactly this. Also note the changed order of the functions here. If def func(p1, 99) was left as the second one it would never be reached
I did't ask how to fix. I asked what is the reasoning of this. thanks.
Thanks. I got it now. :)
Your links were helpful. Thanks
`_` and `_p1` are the same thing. `_p1` is just more readable because it matches the argument name in the function clause. You could use private functions but it's not necessary in the case. But, lets assume you want to multiply `p1` by `2` before processing. You could use private functions like this: defmodule Example do def func(p1, p2 \\ 2) do # Do something before calling do_func p1_multiplied = p1 * 2 do_func(p1_multiplied, p2) end defp do_func(p1, p2) defp do_func(_p1, 99) do IO.puts("you said 99") end defp do_func(p1, p2) do IO.inspect([p1, p2]) end end **But this raises another issue**; What if p1 isn't a number? We will get an `ArithmeticError`. So you need a guard which is also matched. That might look like this: defmodule Example do def func(p1, p2 \\ 2) # Ensure p1 can be multiplied by 2 def func(p1, p2) when is_number(p1) do # Do something before calling do_func p1_multiplied = p1 * 2 do_func(p1_multiplied, p2) end def func(p1, p2) do do_func(p1, p2) end # private functions defp do_func(p1, p2) defp do_func(_p1, 99) do IO.puts("you said 99") end defp do_func(p1, p2) do IO.inspect([p1, p2]) end end iex&gt; Example.func(2.123, 100) [4.246, 100] iex&gt; Example.func(10) [20, 2] iex&gt; Example.func("bob") ["bob", 2] iex&gt; Example.func("bob", 99) you said 99 Man I love elixir :)
Using _name vs just _ is a matter of preference. I like using _name so it's clear what is still being passed in. And defp denotes a private function which may not have been what OP wanted.
This is awesome! Not logging errors when they successfully complete a moment later has been the one thing I've always struggled with. Does this allow any kind of external persistence in order to ensure failed jobs due are retried after a system reboot (of the EVM)?
I agree. I also said "Yeah, It has it's place." He's just taking it too far with this.
I‚Äôve been learning and playing with it, I have been able to realize how the future of software development looks like.
Yea, I think it's worth it. It's a good way to separate how to build fixtures, variations of the fixture, and also makes the tests smaller by taking out \_some\_ of the setup. Ecto's great, and if you're happy with building fixtures without ex\_machina, then great, go for it. In my experience though, ex\_machina really helps make tests readable and focus on what you're testing, rather than the setup. This article [https://robots.thoughtbot.com/lessons-from-using-phoenix-1-3](https://robots.thoughtbot.com/lessons-from-using-phoenix-1-3) helps illustrate what I mean.
https://threadreaderapp.com/thread/1026434505136132096.html
100% agree on putting factories into separate modules to keep the tests focused.
Event struct that are being sent and received, the other modules will never know.
I would love to contribute to the design if needed. This is such a cool idea
couldn't find a room with people. forever alone :'(
Thanks Yawaramin - Bruno created the article on our platform himself in addition to the original, so he will have also included the orignial link in the article! :)
It would be really nice if there would be a notification of people leaving a channel, too.
Just use Mox. HTTPoison has all of its public functions exposed as behaviours for this purpose.
The downside of native compilation is just that it takes longer to compile and that if you are interfacing between native and bytecode you may see slowdowns. But assuming you compiled everything... you are good to go? I don't think there is a way to say for it to ignore native though. Unless you run a VM compiled without hipe or delete the `.beam` files.
Wow, so cool. You asked for comments about making it look better so: I had the thought that it might feel a tad snappier if you were to use onKeyDown for the Enter key -- not that it feels slow, but there's an added maybe 30 to 300 milliseconds waiting for the onKeyUp, whereas normal typing input is onKeyDown. More importantly on a mobile browser I can't see the chat and input in the same screen without scrolling -- iOS in my case. 
Aaaand, this is what this article is about, isn't it? :D
Cool, thanks for the report. I'll take a look.
Thanks for your kind words! They're good motivation for me to continue updating the lessons.
Yeah, this should be a thing
In the IoT space we‚Äôve been able to replace multiple large, expensive SaaS offerings related to networking fleets of devices with a unified elixir backend that even shares some modules with remote devices. It‚Äôs been a force multiplier for us, and idk if we could have done it at the speed required without being able to lean on OTP. Next up is replacing our dependencies on hosted dbms.
I read somewhere that debug support is minimal, but haven't verified it myself yet
I took an old Django webapp that gets approx. 1 million visitors a month and rewrote it with Elixir/Phoenix. I ripped out a complicated mess of caching layers along the way, greatly simplifying application logic. I also added a real-time websocket chat experience in very little time thanks to Phoenix Channels. Response times got 5-10 times better (now consistently &lt; 50ms) and I reduced my hosting costs by about 50% as well. Best move ever. Have been using Elixir/Phoenix for all my web or api related needs since then on various projects. 
Built a JSON API over SQL data warehouse with Ecto and Phoenix. Ecto was the real hero. Having a orm-like library that feels like composable SQL embedded in Elixir meant we needed very few stored procedures or views. The open source community around Elixir is amazing. Elixir, Phoenix, Ecto maintainers are very welcoming of issues and PRs. 
Hipe inlines more operations, which means you can trace less things, but iirc you should still be able to trace your own modules and public functions.
&gt;Project layout with Phoenix 1.3. Contexts are a little bumpy to swallow. I think I have it now. Users live in Accounts. You can‚Äôt do User.all, use Accounts.get\_users Contexts are just a design pattern to group related functionality try not to overthink it. The [Phoenix docs](https://hexdocs.pm/phoenix/contexts.html) do a good job explaining contexts. &gt;By using contexts, we decouple and isolate our systems into manageable, independent parts. I wouldn't say you CAN'T call `User.all()` it's just not automagically available (which i'm pretty sure that's what you mean). You can create a function `all` in a `User` module and call it using `User.all().` (don't do this) # MyApp.Accounts.User (BAD) def all() do Repo.all(__MODULE__) end This goes against the design pattern. There is no traditional automagic model similar to rails. This is a good thing. You could always use the `Repo` module to fetch all user like `Repo.all(User)` but this is exactly what contexts are for and this is what `Accounts.list_users()` should be encapsulating. # MyApp.Accounts (GOOD) def list_users do Repo.all(User) end
Sorry, yeah that‚Äôs what I meant. I just write a few more methods but I think my app trends towards better design. Sort of like DCI or what trailblazer was trying to do. The contexts are sort of annoying with pry. I can‚Äôt get to the Repo from a controller break just while playing but if I could then I could cheat so ...
I posted the direct link here because the one in the FW site linked to Bruno's blog index page, also because I commented on the post itself.
Really cool! 
Can I get a link to your blog post?
Of course! https://nickstalter.com/elixir-flow.html Im still trying to find ways to improve it, any time save across this much data is a huge boon to speed.
what's upman?
Wow, you almost got me :D
This is very reasonable. Please fill in the issue, I‚Äôll fix it.
That was the point of this awesome name wasn't it?
This is something I'd contribute to when I get the time. 
No, actually I just thought of UPdateMANager. But this is nice as well :)
This is fantastic, just in the first few paragraphs it cleared up some questions I have had. Thank you for posting this, your writing style is excellente the joy to read. I've been trying to rectify the relationship between genstage and Flow in my head. I'm looking forward to reading through this again with that in mind.
So you mean, if you add a pry breakpoint in a controller, then in the console, you're not able to do ad hoc db queries? 
It times out because the socket is open. There‚Äôs a workaround, increase the timeout for test and dev. https://github.com/equivalent/scrapbook2/blob/master/archive/mini-blogs/2017-05-26-phoenix-increase-timeout-when-debugging-with-iexpry-in-exunit.md It was just not ‚Äúprinciple of least surprise‚Äù. Also, not being able to call private methods even when breaking within the module, also surprising but understandable because you can‚Äôt be in an instance like ruby pry because there‚Äôs no such thing I guess?
explain
OTP
Nothing in this intro was about concurrency. Are you opposed to people learning about `send` and `receive` at all? FWIW, other screencasts cover OTP (and more on the way).
And you managed to get blockchain in there too. I'm impressed.
This one is kinda "official".
I‚Äôm still trying to get my work to send me. I‚Äôll ramp up the nagging. I hope there are tshirts. 
dont even get me started on the self driving cars too! 
Nice post! Nitpick, but you shouldn't need to add the `applications:` key to the `mix.exs` file. Since Elixir 1.4, your `deps` are automatically included as applications. The `applications` key was removed and `extra_applications` was added for those things like `:logger` that _aren't_ already in your `deps` that you still need to start up before your application.
Great timing, I just ran into a situation where I wanted to use something like this!
When using IDs for bulk updates you may want to wrap the code in a transaction and [lock](https://hexdocs.pm/ecto/Ecto.Query.html#lock/2) the rows so that you can be sure the query condition still holds. 
I'm thinking of diving into Elixir, and posts like these are exactly what I'm looking for on this sub. This is a great explanation of why Elixir was a great tool for their specific use case.
I'm working on a digital wallet backend that allow businesses to run their loyalty point programs called [OmiseGO eWallet](https://github.com/omisego/ewallet). Hi!
Welcome to Elixir! My use case for diving into Elixir was mostly the great UX it gives. And all sorts of awesome other features got discovered as I progressed (this being one) and I never looked back! Hope you have great experience with the dive. 
Does this cause the ID sequence to increase at all? I know it does if you're not using ID as the uniqueness constraint, but not sure if the ID is the constraint.
Ah, yes, good point. Probably a good idea to wrap the code in a transaction and use a lock. Thanks for sharing!
Glad it was useful :) It's not my writing, though. Found it online and had the same impression, so I shared it ;) 
I mentor myself there, and even as a mentor one can learn a lot, not only how to code, but how to teach as well.
I saw a similar request in r/rust and I'd love to help out in both, but although I've been coding for a long time, I've been using rust and elixir in the past few months. I assume there's a minimum level for mentoring a language? 
One of the top reasons I love Elixir is the community‚Äôs focus on performance and understanding the implications of different language features. Stark contrast to other language communities where performance is only something you think about when the server bills get too high or your app grinds to a halt under pressure, at which point you‚Äôre up to your neck in technical debt. 
It arose from its own ashes like a Phoenix :). I'm not sure if it was ever dead. I was using it a lot 3 years ago, then not at all so I have no idea, and a month ago it was re-launched with a complete redesign and mentoring. It's different than it used to be.
I used it about 9 months ago and every program was the same. 
It's entirely up to you and how proficient you feel. I would say the most important requirement is friendly approach to students. If you can point out a single thing they did well and a single thing they can improve, you are already helping. And with a few months of experience, I am sure you can. You can also be both a mentor and a student of the same language track, that could make you feel more confident with mentoring.
I signed up, I'll try to help as much as I can
Yes please, I'm waiting for some code review for 4 days now :(
Thank you!
I know! I feel so guilty when I see know many people are waiting... some of them have been waiting for 8 days now :(. That's why I am asking for help here. Please be patient and do some non-core exercises meanwhile.
Yes, nerves is your best bet. 
I am, I'm not complaining, I understand the situation and also this is a free service and the mentors have to give their free time. Anyway, thank you for being a mentor! Salut o7 &amp;#x200B;
Can someone ELI5 what is nerves? I have no experience raspberry pi or "embedded" programming
cli installation is awfull, not the guide, but the way itself
On which platform? On MacOS it's pretty standard, with the brew package manager.
on linux, tli wish it was a repo or something
&gt; Phoenix An Elixir reference? üòÇ
It also provides nice Elixir interfaces to all the hardware: network interfaces, I/O pins, i2c, etc. Super convenient as you do not need to set up or configure your device via system scripts or drop to C/C++ for anything, and your app can react to system events like networking becoming avaialable. Just a bug happy Elixir app.
Presumably you mean *big* happy elixir app?! :)
lol. yeah. obv too many years writing software has taken its toll on me ;)
source?
There has been a huuuuge improvement in the mentoring queue for Elixir in the past 2 days! Oldest not mentored solution went down from 8 days old to 2 days old :). This reddit post and a post on the Elixir forum really really helped attract new mentors. With all the new people onboard, I think we can keep this up. I definitely don't feel like it's a lost cause, we are helping people learn.
&gt; a 1000 times FYI, this is pronounced ‚Äúa one thousand times‚Äù. Just say ‚Äú1000 times‚Äù instead. 
Unless you‚Äôre Mario.
A right-a you a are-a. 
`Application.get_env` is basically as fast as ETS lookup, so this is fast enough for most of your use cases. 
Yeah I feel like if you need to read values that quickly then it might be time to pick up a different tool. Still, nice to see how fast get_env is.
For production deploys you should _probably_ be using `distillery`. And that provides yet another approach, where you specify your dynamic config with the syntax `"${FOO}"`, which you provide when you boot up your app. Distillery will then essentially find and replace FOO with the value you provide. That, I believe, provides performance akin to the hard coded (module attribute) approach, but lets the run time environment provide the actual configuration values rather than the build environment.
Ok Thanks. My main goal is to have a project to learn elixir and frameworks. I built a raspberry pi sprinkler system with python which really helped me learn python. 
... there are many places that pronounce it "a thousand", and I suspect the writer is either from such a place or learned their English from someone who is. So not entirely surprising to see "a 1000" in writing, even if it is entirely colloquial.
Most (all?) of the tools that provided this either did it at compile time, or did the equiv of `Application.get_env`. distillery 2 brings some new options here, though: https://hexdocs.pm/distillery/config/runtime.html
man where the fuck was that when I was reading the docs? I use google cloud build and kubernetes and figuring out how to handle environment variables annoyed the crap out of me.
Oh wow, you're right. Distillery changes [`sys.config`](http://erlang.org/doc/man/config.html#sys.config), I think, which does have it retrieved by `Application.get_env`. Don't know why I thought it was different from that.
Awesome. These are ALL pain points I‚Äôve suffered, and they are common from what I‚Äôve seen in the Elixir Slack. Great use of time and effort, and props to Dockyard for pushing this development forward.
nice! glad to see the config system touched. It was a pain for docker deployments
Great to see a solution to runtime configuration. That has been the biggest problem with the Elixir ecosystem, in my opinion.
Can someone please elaborate on this paragraph: &gt; Your application should be designed to receive configuration at boot, read it from the application env, and then pass it down your supervisor tree, rather than reading directly from the application env when needed. There is nothing enforcing this rule, but config providers are specifically designed with this approach in mind, and are not intended to be used to fetch configuration dynamically once the release has booted. What bad things happen if I am "reading directly from the application env when needed"?
Looks like this was answered on the forum: https://elixirforum.com/t/distillery-2-0-has-been-released/16039/15 No technical problem with retrieving app env on demand. Just the usual concerns about global state, testing, being explicit etc.
maybe you'd check react nextjs...I'd write a post about nuxtjs (which is like next but for vuejs) and could be useful for you...basically you will need run a node server (which run react or vuejs) and from here you make restful calls to your backend (although sounds overengineered the real truth is that it's really simple and nextjs and nuxtjs makes a wonderfull job handling the complex part)...
Skip to 4:50 unless you really enjoy silence. 
Take a peek at trunc
what?
This: https://hexdocs.pm/elixir/Kernel.html#trunc/1
I have float Decimal !
First set the rounding context as you described, then do your round operation, then you can use `Decimal.to_float` or `Decimal.to_integer` as you need.
https://github.com/emacs-pe/docker-tramp.el/blob/master/README.md I haven‚Äôt tried this with elixir, but it works with python and clojure/script via cider. Just open the files over tramp inside a running container and everything should just work[1], like C-c C-c will compile the buffer using whatever python or boot/lein is in the container. [1] I don‚Äôt think this should matter, but just in case: https://github.com/carrete/.emacs.d/blob/master/lisp/setup-python-mode.el 
Why would I use the ok library when OK.for is pretty much a `with` block?
Why not just use React inside Phoenix if you‚Äôre already used to it?
Good question. I have considered it a little though not looked into the options. I guess I felt that I wouldn't enjoy the disconnect between the elixir code and the React. Getting them to line up &amp; match on data structures, etc. I'd also have to translate everything over to pure JSON for the transition I guess. I also have a preference for Elm over React at this point but then with Elm I might end up writing a bunch of Decoders which I wouldn't look forward to. I guess I should do some research into it though. Thanks for raising it.
I think saying "bad input is not exceptional" is a very poor summary. Passing an integer to `File.read/1` should always fail because an integer is always wrong in this domain. What makes an input good or bad depends on the context we are working with. It seems the author means the same as I describe here but it is not clear.
/u/crowdhailer is a guy with a lot of ideas that just don't really work with elixir and he tries to shoehorn them in. I think he'd be better off learning LLVM or some other runtime and coming up with his own language. edit: Actually given his background, crystal would probably be a better language for him it seems.
Oof. I'd stay away from developing inside of a Docker container.
I'm working on a headless CMS. The plan is to create a CMS that will be able to manage multiple sites from the same admin panel. It will be open source but at this early stage, I don't want to share the code.
I was looking for a good backend for a SIP telephone central for VOIP, so far it‚Äôs amazing.
Want to make car. But how?
I would recommend learning server-side development before accepting jobs that require it. If you have no idea how to build online ordering and you are asking about frameworks on r/elixir, you're not ready to write the software someone's business is going to be running on.
Agree with the other comments. You should turn down the opportunity, and learn how to do this before taking any jobs that require it.
Welcome to Elixir! Programming Elixir and Programming Phoenix are great introductions to the ecosystem and will guide you in building a dynamic web application in Elixir. It sounds like you will need a database as well. Ecto, the Elixir database library that ships with Phoenix, is best paired with PostgreSQL. Lastly, you will need a place to host your new application. Heroku has a free tier that is easy to get started. If you want to explore the distribution capabilities of Elixir you may want to look for other cloud providers.
I'll take a look into aforementioned libraries. 
This is kind of what I meant by my other comment. This is some of the simplest information you could be given about web application development. If this was actually helpful, you're not at all ready. Ok, phoenix, but how do I use phoenix? Ok, postgres, but how do I use postgres? Ok, heroku, but how do I use heroku? Learning all these tools takes lots of time and practice.
Fair enough feedback. I was encourage to add upfront summaries, not something I've done on many articles previously, really wasn't sure what would be a good summary. I think I do agree with you. Perhaps I will just remove the whole TL:DR 
If you're in the states, your website will have to be PCI compliant, even if you don't personally perform the credit card transactions. This is no simple undertaking, security is tough, and a lot can go wrong, and either you or your company will be liable.
On a positive note it sounds like you might be a good salesman ;)
I'm not dismissing his ideas, instead I'm suggesting elixir isn't the suitable implementation language he thinks it is.
Whether or not you intend it that way, your original comment comes off as a personal attack on and criticism of somebody who has spent significant time and effort implementing his ideas in Elixir. I don't think we as a community should be okay with treating people that way. If you had discussed why you think `OK` isn't a good fit for the language, fine- discussion and differing opinions is how a community makes progress- but "his ideas don't work in this language and he should go to another" isn't really constructive.
k
&gt; elixir isn't the suitable implementation language he thinks it is. An interesting statement. Could you expand upon this please? :)
Lol it wasn't too hard since it was a family member. 
[Programming Phoenix](https://pragprog.com/book/phoenix/programming-phoenix) does just that. It is a great read with many illustrative examples.
In this case, the full context is: I don't think elixir is the suitable implementation language for the ideas he is trying to implement. 
No, elixir can be used for ecommerce, but what I'm saying is that if you don't have ecommerce experience (like I don't), you shouldn't try. There are all sorts of security and compliance things to consider that you just can't know without experience.
Fair enough. 
Me too!
Hmm that is one option. Thanks I never thought about that. 
Seconded. If not Shopify there are other food ordering systems you can piggy back on. I think maybe GrubHub for example? Do some searching. If you want a chance to learn while getting paid then go for it. I disagree with the comments that say you should not take a job that you don‚Äôt know how to do. However since you mentioned a family member wants you to do it, you should do them a solid and find something off the shelf you can set up and maybe customize for them. It will be cheaper for them and they will be happier with it. Put it this way, I have almost 20 years of dev experience including several large ecommerce sites and I would not build this from scratch.
Turn down the job and respectfully leave that bridge open for the future. 
just add car and gasoline to your mix.exs file
I use VSCode with ElixirLS extension. In the most recent update, I've noticed it starts showing @spec above my functions and will fill it in if I click on it with my mouse. Just takes a single click.
Same. Love it.
Adding specs doesn't exactly mean better coverage. As dialyzer will try and workout the types itself. The main reasons are if you have very specific types that dialyzer can't infer as accurately on its own (or if you want to show certain results depend on certain inputs), and then for the programmer as a kind of documentation. 
I'll give it a try, I currently I use neovim, but I didn't see a feature like this one offered by the Elixir plugin. Thank you :)
Short and useful. Excellent!
 vim textual_supervision_tree.txt # ascii art implementation left as an exercise for the reader
Giggity
I felt the same way before, but I think his work is really important for the community. Just the other day, I was trying to stream data using a chunked response and Phoenix, I've searched everywhere but didn't find a way to do it. And then I remembered a talk by /u/crowdhailer which mentioned that [Raxx](https://github.com/CrowdHailer/raxx) has this ability, I was able to get it working very quickly. I sure hope he keeps doing what he is doing.
I‚Äôm finally finishing up my first production worthy all written using elixir. It‚Äôs a simple web game hosted on https://bulletz.io. I have a few more crucial optimization‚Äôs to make as well as a few features to add but it‚Äôs pretty close to done!
I could but I don't want to. I was just asking if that was something that was already done that I wasn't aware of.
just trying to make some light humor, i imagine they just wrote it out by hand üòÑ
A statically typed language for the Erlang VM :D
I was thinking about building [agar.io](https://agar.io) clone to try out elixir, whats your experience building bulletz?
How do I enable it? I have some .ex and .exs files and the plugin is installed. But when I click on functions, no @spec comes.
Very cool. Looking at types + Erlang/Elixir is an interesting and deep subject. On the one hand we have bulletproof Erlang/OTP essentially singlehandedly nullifying the tried and true ‚Äústrong types = runtime safety‚Äù with little more than tuples and yet types are also so descriptive, useful, and humane that I still want them. Interesting project, will be following, best of luck.
I think you need both. OTP won't stop you making a typo that puts your supervised process into a boot-crash-loop, but it will stop your system from entirely failing because of it. I want safety at compile time and at run time. I also find it much faster and easier to refactor when using a language with a safe type system, Elm's a good example. I'm becoming a lazier programmer as I get older, I want the compiler to do as much work for me as possible. :) Thank you!
Glad it's worked for you. If you ever able to share anything you've done with Raxx I'd be keen to see it.
This just keeps getting better. Awesome project!
&gt; A statically typed language for the Erlang VM Sounds cool! How would statically typed message passing work? Similarly to golangs typed channels?
It is offered by Elixir Language Server and you need such and plugin that will handle communication with such. 
I've looked at Go's channels a little but don't think it'd be a good fit for the way that we pass pids around in Erlang, but I could be wrong. Currently I'm thinking for the MVP raw message passing will be untyped, but the OTP behaviours such as `gen_server` will be typed in a fairly simple fashion. Once the base language, tooling, and standard library are more ready we can then do research into how to effectively type message passing.
&gt; don't think it'd be a good fit for the way that we pass pids around in Erlang Thanks, that makes sense.
Do you have more details to the story? Was it already elixir app before? What persistence layer you used before tarantool?
If you go through the first several [free Elixir learning screencastsÔºΩ(https://alchemist.camp/episodes) I made it should get you at least comfortable enough to have an idea of how to get started. 
I have been watching your videos and they are great! 
As a learning project - it was great. You can really take advantage supervisors/processes and such when making a game. For example in my game every bullet and player and moving food has it's own process and if those go down the game itself doesn't die - just that single entity. I think it's a great way to learn the language as well as the phoenix framework.
If I hadn‚Äôt already used all of my PTO to go to ElixirConf I‚Äôd totally go to Big Elixir!
Your benchmark would be even better if you used something like https://github.com/PragTob/benchee, it'll do warmup and such.
Nice! Context modules can get pretty big. I starting exploring ways to break them up but still wanted to call functions from the root context module. I went as far as quoting the module. For sure I will be using defdelegate going forward, I like the explicit nature of it. 
Learned it from Dave Thomas now I use them all the time
I took my first foray into elixir packages. It‚Äôs super basic but I‚Äôd appreciate some feedback. It‚Äôs a heroku-like name generator with a twist, names can either be random or consistent. [Link](https://github.com/pejrich/AnonymousNameGenerator)
It depends on the size of the message. A good rule of thumb is to assume it gets copied whenever a message is sent. There are a few exceptions like small binaries that are stored in a global heap and as such only a reference to the binary is passed around.
Just keep in mind that `Registry` is local to that node. So if you are potentially passing things around to different BEAM nodes, this will not work.
Is this backwards? I thought that small binaries (&lt; 64 bytes) are in the local process heap and larger binaries (&gt; 64 bytes) are stored in the global heap and passed by reference. &amp;#x200B; Search for "64" in [https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html](https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html)
This is correct - so for multiple nodes (horizontal scaling) you would need to use a global registry library such as [Swarm](https://github.com/bitwalker/swarm)
Measure! :) That said, message passing itself is fast enough for most use cases. It is the cost of copying data that tends to be the issue, and when or how things are copied is a complicated topic. Atoms, despite looking like text, are just integers behind the scenes, and large binaries (and small chunks picked out from larger binaries) are not copied within a node but passed by reference, etc. But unless you are doing high volume (n*100k msgs per second), it probably will not be your bottleneck. But you may want to ask what is being achieved by multiple hops. Is there a useful abstraction being served by that? Is there decision making or necessary data transformation happening? Is it a way to achieve higher parallelisn, e.g. by using one forward facing process as a fast dispatcher (little to no actual processing done) to a larger number of processes that do the actual work? ... Keep in mind that a module does not equal a process. You can separate your code and the concerns across multiple modules for ease of maintenance and general modularity and call any mix of those functions from the same process. Processes are for runtine distribution and isolation of computation. They are units of state and work. Modules are for organizing concepts represented by code. So when designing Elixir apps, it is usueful to think about those two steps separately. In OO languages they are tightly coupled (instances at runtime and their interface implementations) but decoupled in Elixir. So before worrying about performance issues you are unlikely to have (though all things are possible ;), I would step back and look at the design forst and foremost. Refactoring for performance later (if needed) is quite easy in Elixir.
http://plataformatec.com.br Has the creator of Elixir on their team. 
Full disclosure, I know people associated with this agency, and have not used them myself, but I believe that Dwyl use Elixir as part of their preferred stack. https://dwyl.com
We do! https://thoughtbot.com/services/elixir-phoenix
Dockyard https://dockyard.com/phoenix-consulting As far as I know Chris McCord, creator of Phoenix, works there. 
See https://elixir-companies.com/industries/technology-consulting
http://progress-engine.com - Russian team (I‚Äôm CEO) with expertise in web, mobile and high load backend app development
Seems to be a LOT of good alternatives here but i‚Äôd like to add my company as well; https://varvet.com
Sure, we at [Prograils](https://prograils.com) do. Make sure to check out our [playbook](https://prograils.com/playbook/) to know about our process, philosophy and stuff.
I‚Äôll jump on the bandwagon here with my company: https://www.crystalhelix.com
Good to know! I just started learning Elixir and having a hard time wrapping my head around OTP and the ecosystem coming from all the regular backend OOP background.
http://quanterall.com - Bulgarian company. I know they work on the Aeternity blockchain and have done a lot of web application projects.
https://teamgaslight.com/ has a couple based in Ohio.
[http://moove-it.com/](http://moove-it.com/) has elixir devs plus experience on other techs that can help on an elixir based app
it just shows 'submitting' endlessly :( 
Let‚Äôs get started. The first thing we‚Äôll want to do is create an account on on Gigalixir. I‚Äôll create an account through their site. There‚Äôs also an option to signup using their CLI too. 
 how classes get their methods in Ruby and then look at the steps that I took to better understand the world of Elixir.
^ Whatever he's charging you, I'll half it!
Welcome! I'm glad you found the group. üëç Feel free to invite other as well if you know someone who might be interested.
Thanks for the recommendation. In addition to Chris we have the largest US based Elixir team, maybe one of the largest in the world. (haven't compared to Platformatec or Erlang Solutions' sizes) and we also have a very senior team, three of our devs just spoke at ElixirConf this past week.
It‚Äôs much cheaper to calculate on others computers then on yours...
I love the idea of Phoenix.LiveView. It won‚Äôt keep us from needing JS, but I can see this eliminating a lot of the type of JS that I write. The form validations are a good example of that. I‚Äôm curious and excited to see more.
Concerns about performance and backend computation of HTML in Elixir using eex are misplaced. This method is probably more performant than a JSON API. At compilation time eex templates are turned into IO lists. IO lists are extremely fast when writing to IO. Additionally, IO lists can have dynamic content injected into them in ways that are extremely fast. In Elixir when JSON is rendered it is rendered as a binary dynamically which is at least as slow (and probably much slower in most cases) than rendering an eex template. Also Chris's demo yesterday was doing full page HTML pushes. He has plans to create a page state diff on the backend and only send required changes to the FE thereby cutting down on bandwidth requirements and increasing performance even more. If you talk with Chris what he will tell you is that his most major concern is developer productivity. If his work can enable developers who use his software to enter the market place sooner with a competitive product then his mission is accomplished. 
This looks amazing and definitely a huge productivity boost. As someone who works with React a lot - that gap he mentions between SPA and HTML only resonates with me. Curious to see how things play out when the library is more mature: - Does it degrade for non-JS browsers or will you have to have handle_* actions and regular controller actions? - How difficult to build a state monitoring on top of this? This feels very much like the event-bus model of jQuery/Angular that can cause all kinds of issues at scale - How hard will it be to override these behaviors from client-side JS if the use case doesn't work for you. I remember Rails had something like this (rjs??) and if you didn't have what you _exactly_ needed then you were in this bizarro world. If this is done well - I think Elixir has fundamentally shifted how we architect standard CRUD apps and the levels of developer productivity it enables vs Rails.
FIY: There's https://github.com/grych/drab that works on the same principle.
Looks really cool if you can afford to not be offline capable. Unfortunately it seems that fewer and fewer apps can afford that when the competition does.
Turns out we're not charging our customers, but paying them üòÅ
So on both?
`Phoenix ~&gt; 1.2` was a no-go for many of us!
I have been thinking about this approach for some time so I'm super glad to see it implemented in phoenix but I'm not sure how scalable this is. The biggest issue I see is the memory footprint - when you keep the state of ALL clients on the server...yeah, that adds up REALLY fast.
I don't have a terribly similar background ‚Äî other than starting with BASIC and being on the LAMP stack for a while. But "Spiderman senses" was my experience as well. I think Elixir is a job-safe direction. It's a sane and dev-friendly choice in a world which has found it needs to stack cores to get the performance it needs. The ecosystem is a little young yet, but *if* this becomes an issue, it is mitigated if you're willing to fall back on the Erlang ecosystem, write your own implementations, or (if you really have to) use a microservice built in another language. You're going to find that Elixir has borrowed *somewhat* from OOD, though that may just be "the good parts" for you for all I know. But yes, the functional paradigm will be a new wrinkle. For me, too. But it's an exciting one I'm eager to tackle. 
Good luck and welcome. Elixir on the BEAM is a joy to use. The main things to remember is that a process always holds your state, or is the basic primitive of getting things done, kind of like the instance part of an OO object, but we can have millions of them. Then, you push that state around, usually either by tuples, lists (Perl arrays), maps (Perl hashes) or structs which are like named maps with a predetermined shape (specific fields you define ahead of time, similar to the properties part of an OO object), and modules which of course would approximate the class of an OO object. Basically we separate the class and the instance, for modules and structs, and then instead of the object operating ‚Äúon its own‚Äù we use a fully isolated and independent process (like an OS level thread) to update data. HTH. 
[removed]
https://appunite.com - we have some
&gt; The biggest issue I see is the memory footprint - when you keep the state of ALL clients on the server...yeah, that adds up REALLY fast. I suppose it'll depend on what you're doing. If it's something like form validation, that shouldn't be too long lived. Once the client leaves the page I believe all of the state is destroyed on the server (pretty sure Chris mentioned that but it's not 100% clear). **Let's try to estimate memory usage in a real world example:** You have a video watching platform, where users can toggle whether or not they watched a video (some type of state persisted to the DB but also presented in the form of an icon on the front end). Rough concurrency estimates say for every 1,000 users you have, 100 users are probably using your app regularly and 10 of them will be on concurrently. Let's say you have a super die hard fan base and for each 1,000 users, 400 of them are using your app regularly and 40 are on concurrently. So if 40 people are watching videos, then you're saving state on 40 items. Now let's say you have 1,000,000 users. Using the same ratios that would put you at 400,000 people using the site and 40,000 pieces of state saved. Last but not least, let's say you have 3 things on the page being saved, not 1, so now you have 120,000 pieces of state saved. I really have no idea how much memory each ETS item would take to store. Would it be 1kb? 2kb? 4kb? 8kb? I'm just going to go with 4kb. So now we have 120,000 * 4096 bytes = 491.5mb. Let's also say your Elixir process uses ~200mb of RAM, Postgres is using another 100mb. That gives us a grand total of 800mb of RAM. Toss in some popular Linux distro and now you're hovering at 1GB of memory, or a $5/month DigitalOcean server to deal with tracking state on a million users, but if you're probably going to play it safe and use the $10/month server to give 2GB of memory.
Please avoid likening lists and arrays. They do have a similar shape, but have very different properties. One important example is random access. With arrays it is fine, it is O(1) complexity. If you are doing it with lists you are using them wrong, it is O(n) complexity.
actually I designed it this way because in my opinion allows better fault tolerance. to put in some context, theres 4 processes involved: * tcp session in charge of sending and receiving data from clients * user process that keeps each client state, even if they disconnect * "shard" manager, which manages a tree of systems (tasks) * any of the systems under the shard So the thing is passing the data from the client session to any system for processing and back. Users can move between shards at any time, and shards are dynamically spawned. Also anything inside a shard or the whole shard can crash and respawn, so **I** think a lookup table or a name registry wouldnt really help here. Right now: * the session and user process know eachother * the user knows the current shard manager * the shard manager knows all its systems So as it is right now, thats the only clear path. I may be wrong with the design of course.
The flip side is I have never worked on a client app that required offline capability, across dozens of real-world client, domains, and usecases. I do think it's a very valid requirement, but is also a rare requirement that should be case-by-case evaluated exactly the same as client-side options because of all the complexity it brings. If I think about the apps I use day-to-day, Notes.app and Calendar.app are the only offline apps I use that actually provide a useful offline experience, so my bets on the future remain online-focused for the kinds of applications I build.
Can't really agree on the complexity of being offline capable. But my main point was this scenario: Your app can't be offline, but your competitor's is. Your user is on their phone on a bus and goes through a tunnel‚Äîyour app stops working and your competitor's does. It just makes business sense, in my opinion. It's not really a question of "Should _my_ app be offline-capable," but instead it's "What if _my competitor's_ app is offline capable." Internal apps I say sure, Phoenix live view all the way, but it feels a little late to introduce this in our increasingly mobile and offline world (especially in newer markets around the world).
&gt; I will have to learn it and implement something for a client (I'm freelancing at the moment) So, until recently, I was doing a lot of freelancing. I found a magic secret to learning new tech stacks. When the recruiter you're working with says, "Do you know $X?" you say yes. You always say yes, especially if it's something you want to learn anyway. Never outright lie about your experience, but maybe exaggerate a little bit. NB: This only works if you don't fuck it up, so practice learning things. Learn new things all the time. Experiment constantly. Then, when you pick up an Elixir contract, you might not actually know Elixir, but you can cram enough in the course of a weekend to pretend like you know what you're doing. I've done a *lot* of contracts in technologies I've never used until the day I showed up to work. My clients were generally very happy. I stopped freelancing because I did a lot of work at client sites and was on the road more than I wanted to be.
What should you be doing instead for random access of lists? Use a different data structure? 
I will second the issues around a small, young ecosystem. I love the idea of having the time and resources to step in and be the one who helped fill in the missing pieces of a growing open-source ecosystem, but in my current projects, I am more time- and resource-constrained than ever. Falling back to the Erlang ecosystem can be helpful, but it is not nearly the size of, say, the Node or Java open-source ecosystem. On top of that, the core components of Erlang are documented in what feels like the style of a 1990s-era systems manual (which makes sense because it originated in the 90s). Sometimes the path forward can be unclear. For instance, I needed to connect to an SFTP server run on an Azure stack owned by a partnering firm. There were a few unpopular open-source SFTP packages available for Elixir, but all were just convenience wrappers for Erlang‚Äôs ssh_sftp library. Fair enough. Why reinvent the wheel? But then as I was implementing the subsystem that required automated SFTP access, all FTP functions worked except ‚Äòlist‚Äô. For the life of me, I couldn‚Äôt figure out why, given my limited understanding of the remote server‚Äôs configuration and cryptic Erlang errors from that library. So, due to time constraints, I had to build a tiny internal program in Go that merely relayed a directory listing from an SFTP server. Anyway, this turned into a novel. In summary, I really enjoy Elixir, but it‚Äôs ecosystem can be frustratingly limiting. If I were to go back in time and pick a different language for this current project with its time constraints, I probably would. I‚Äôd miss the beauty of Elixir, but I could get the job done more efficiently in a language like Go.
Generally yes, if you want random access use a Map instead.
Elixir is so good that even a beginner like me could spot it, you've made a good choice in choosing it to learn. I spent like 7 months on JavaScript, half the headache wasn't worth it when I started Elixir, where I got things done faster and had a less stressful programming environment, in short, Elixir is the future. Welcome to the community :)
I think I heard someone in the community say something a long the lines of: &gt; "Elixir/Erlang is to concurrency and OOP like what Java was to pointers and memory management." 
I understand your critique but Perl has C-style arrays and keyed hashes, while Erlang has nothing like an indexed ordered array per se, however the way idiomatic Perl arrays are used is often very list-like anyway via shift/unshift access and is a quite natural fit (translation wise) for the way lists are used on BEAM. I think for someone new to Elixir coming from Perl the idiom holds, but maybe noting your objection a bit further into the learning curve. There are also PropLists and HashSets of utility depending on data context. 
Well, the issue with hypothetical scenarios is that you can flip them so the opposite argument also works. What if I can beat my competitor precisely because I can iterate faster and have a shorter time to market because I am using a very productive and robust tool compared to my competitor? The truth is that it is not a zero sum game. Offline or not usually ends up being an early-on design decision and if you are not worried about it upfront, LiveView is shaping up to be a very compelling choice.
I think this is a great addition and will help us avoid messing with JS for simple use cases. I am sure chris is going to add the ability to target a particular section of the web page very soon. The whole concept reminds me of ASP.NET Forms, However, its implementation looks great :)
If you are planning to run at large scale, LiveView may not scale but **Phoenix will**. Phoenix is sometimes typecast as a framework for large scale apps where people say you would only use if it you need performance. But if LiveView allows us to build small scale applications that are reactive and interactive with a fraction of the effort of the other frameworks and tools, then Phoenix becomes undeniably a well rounded choice across the board. You can even start with LiveView for the time to market and productivity and once you start to reach a certain scale, you slowly migrate to client side state. Even with LiveView, Phoenix may as well as scale better than other stateless web frameworks. 
This looks really cool! I haven't had a chance to look at it in depth but at a first glance it looks awesome.
A single developer doing twice the work for both the front and back end is not going to bring you to market faster compared to two developers doing a separate front and back end. I dunno, I'm just skeptical of the importance of something like this, but hey, if it makes companies lots of money then that'll speak for itself and I'll admit I'm in the wrong :p
&gt; A single developer doing twice the work for both the front and back end is not going to bring you to market faster compared to two developers doing a separate front and back end. What if you're a solo developer trying to bring something to market? Most web apps start with 1 person working on the project, and it's not unreasonable to want to make a nice user experience once you get the bare bones functionality in place. LiveView will shine in this situation because now we can just wire up a few dozen lines of Elixir instead of doing double the work on the front end. Also, I'm with Chris here with offline apps. I'm a freelance developer and in my ~20 years of doing this I've rarely came across situations where the app was expected to offer first class offline support.
Looks great! I was just checking if the ecto dependency was optional, then I see {:ecto, "~&gt; 2.2.0", potional: true}, Such a perfect typo for Elixir! :)
Wait, what? That's obvious. A single developer is very unlikely to be faster than two developers. How is that even a comparison? You have to compare one developer on Phoenix with one developer context switching between front and back. Or two developers on Phoenix compared to two developers doing separate client and server work.
&gt; What if I can beat my competitor precisely because I can iterate faster and have a shorter time to market because I am using a very productive and robust tool compared to my competitor? I thought what you meant by "I" was a single developer being you. Still, two developers doing phoenix is no faster than two developers doing separate front/back end apps. There's hardly ever time-to-market boost with any specific stack. And again, in 5 years maybe we'll never be offline and I'll eat my words. I love Elixir and I use it for everything I think it's suitable for, but the front-end (even with this new phoenix live view) I just don't think it's suitable at all.
Thank you! I'll fix it!
Thats because of their doubly linked list under the hood, right?
Great tutorial! A minor suggestion from me - it would be awesome if you could implement a dark mode for your website.
It's heartwarming to see interest in that language
I've nearly finished setting up the portion of the site where you can make feature and content requests. It will basically order what gets produced based on what people spend the most spend green elixir on. (Each signed up user is now getting some automatically on Mondays)
We do! [www.coletiv.com](https://www.coletiv.com) You can also find a huge list of companies that work with Elixir in: [https://elixir-companies.com](https://elixir-companies.com)
I'd be glad to help you implement this and other features in exchange for Elixir code review so I could learn more. I'm a front-end developer and I'm in the process of changing careers to back-end development. PM me if you're interested :)
Thank you!
Interesting, thank you for taking the time to explain this and the source link. I have been studying Elixir‚Äôs AST (and other areas of Erlang in general) and am constantly amazed at how much mileage one may get out of thoughtfully nested tuples.
It seems to have built-in progressive enhancement to me. The way it works rendering partials with changesets means you won't have to alter your controller validation logic, views, or templates; you just add a few extra handles. If you lose service in a tunnel you are back to a normal submit-request-fullpage-response cycle. The difference here is you don't have to implement validation in a language different from your domain model for reactivity in the happy path case, and you don't have to send a bunch of extra JS down the wire. Huge gains in my mind for both developers and users. This is talking about validation in particular, which is the most business-important application of this yet discussed. Things like live page updates are just sugar in comparison, and degrade even more naturally.
I'm really excited about this feature. Just watched the video and I think I could get rid of a large majority of the Stimulus.js that I have in my app, if they get completed and implemented the way it looks like it's heading. I'm already using Channels quite a bit to implement quicker feedback from form submissions and things like that, so it should also simplify code on the backend, as well. We don't really have any need for PWA features, or offline-first functionality, so it seems like an easy win.
I wonder how this would integrate with vendor javascript libraries. For the Stripe JS client for instance, wouldn't the DOM updates remove the bindings? Another use case would be Algolia: it seems that we would need to make the requests to Algolia from the server: client -&gt; server -&gt; algolia -&gt; server -&gt; client?
 I think /u/chrismccord made a mistake by saying you need a single page app to pull off listening to music across pages, although you would need Javascript for sure. A perfect example of this is https://changelog.com/podcast. The above website is created with Phoenix. It uses all server side rendered templates and Turbolinks. But if you start listening to a podcast you can transition between pages without losing the audio. Try clicking into news, community, submit news, or anything in the footer. There's just a little bit of plain old Javascript making all of that work. You can view the code for everything at https://github.com/thechangelog/changelog.com.
Creating a UI for IoT apps is likely a HUGE use case in the near future. Ie, controlling, administering, and monitoring of devices over a LAN which is connected to the internet intermittently or not at all.
One of the main objectives and success of Phoenix, like Rails before it, is to simplify and ease new programmers' onboarding. It's very important in general, though not for everyone of course.
\+1. But be careful being too \*sure\* about the direction of future apps. There is an increasing attention being paid to "private by design" types of products... that don't send personal data to the cloud. Again, IoT comes to mind where nodes on the LAN communicate with each other but not with the cloud. 
IMO, there is no argument that one language is simpler and the way to go especially if one of the goals is to increase the popularity of Elixir, and dev happiness, vs the many other more popular languages. A one-language solution, if possible, will also be the more powerful magnet for new programmers.
The example wasn't really about audio, but rather showing cases where JS applications absolutely make sense, like Spotify's web app or other desktop-like UI experiences. You could use Turbolinks to avoid breaking the page cycle, like changelog, but changelog is almost entirely a static site. So I see your point, but we are talking about very different things. Next time I'll have to use a different example :)
From my understanding the LiveView feature is still very beta. I _think_ his priority is the 1.4 book then continued work on LiveView, but this is speculation based on what he mentioned in his keynote.
It's not for all scenarios as discussed in his presentation. If I have to pick between writing elixir vs javascript, I will definitely pick elixir as it's more productive! 
confirm :)
Wow, this could be a gamechanger. The example of validating a form live is very compelling, since it is both so common, and so complex to do the normal Javascript way. I think many people underestimate the complexity of adding a lot of Javascript, because they are not thinking of problems like: - Balancing code reuse vs asset sizes - Dealing with bundles that are too big, introducing module splitting, and accidentally bloating your bundle sizes with a bad import - Internationalization (as Chris mentioned) 
I assume that OP wanted a how to on doing your own mix task, check the documentation for Mix Tasks! [https://hexdocs.pm/mix/Mix.Task.html](https://hexdocs.pm/mix/Mix.Task.html) &amp;#x200B;
[https://pattern-match.com/elixir-and-erlang/](https://pattern-match.com/elixir-and-erlang/) We specialise in Elixir/Erlang and we can help you with infrastructure and monitoring as well!
Have you open sourced it? What libraries are you using to render the graphics? Looks great!
Thanks I appreciate it! I have not yet decided if I want to open source and I didn't use any libraries to render the graphics - wrote it all from scratch!
Your article is lots of fun to read and at the same time very interesting..!
Funny how I decided to use Elixir for a similar project without even knowing Discord was using it too. It wasn't a tough sell luckily but a Big Name using something is always better.
Hit 'em with the big names! :) But to be serious, it gives you a feeling of "Well my choice wasn't TOO bad if they are using it as well", which is nice :-)
Oh man, would love to have a look at it!
It was a great choice, everybody was on board with it. Finding developer with experience was harder than finding experienced developers that wanted to work with Elixir. We didn't build something super complicated but what we built scaled really well.
I really hope elixir will grow :p
Is the existing project Phoenix based? If so just add the channel (The mix task should tell you were to change a few lines of \`user\_socket.ex\`): \`mix phoenix.gen.channel Room\` Seems reasonable if you are going to allow more than 2 players to play/watch a board game to use channels since you can broadcast a message and all interested parties listening on that channel get the message so you don't have to send messages individually per connected user.
Is there a text version of this content available?
Right under the video is a transcript
Not as yet, are you interested in the text version?
i never figured out how you solved ssr with elixir ?
Awsm, really interesting.
Is this just a rendering of the page in headless chrome and sending it to the client? (Apart from caching and all that). Or do you actually do rehydration on the client and all that? 
Please, I'm not finding the video content very clear and they take a long time to view.
Try this video https://www.codemy.net/posts/elixir-project-introduction-001
It‚Äôs using chrome headless to render the page cache and then serving it. When JavaScript runs on the client the app takes over.
Understood. 
You should add link in your post so people do not need to google the name themselves. 
Isn't the whole point of Mox to force people to use behaviours? There is even a whole article written on why using mocks without contracts/behaviours is a bad idea‚Ñ¢: http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/
What's been said already, just use Elixir back-end as an API and send the requests from the application to that back-end. I suppose that you fixed it but I'd like to highlight some errors in the block of code you posted in your blog. &amp;#x200B; 1. You're assigning \`pid\` to anything in \`start\_link/1\` 2. You forgot to add the function that \`handle\_call({:add, lvalue, rvalue}, \_from, state)\` will handle. &amp;#x200B; &amp;#x200B; &amp;#x200B;
Consensus at our local user group was the changing code (especially in such a drastic way) for the express purpose of testing was a smell and we believe Jos√© is wrong on this one. Mimic provides the same contract checking at compile time with the use of macros instead of using behaviours. 
Yup! Planning on basically re-implementing this with an Android frontend.
Yeah, I was globally registering the pid before as an experiment and forgot to remove it from the example. Good catch! Are you referring to a client API? I didn't bother implementing it, as I am just relying on the message being sent from the Java code. Nothing to use it in the Elixir for the example.
Turbolinks is effectively a SPA as there's no full page reloads.
Ah, I didn't see you were using Jinterface, to be fair I only looked at the first paragraph and the block-code, sorry about that.
Ahh, happens
Isn't writing a test the very definition of changing code for the express purpose of testing? I'm not sure I'm understanding your point.
The whole point of mocks and stubs is exactly to help you design your system and its boundaries. It is something you write *alongside* your code. If you have to change the code to add them, then you should consider that the original code was flawed. &gt; Mimic provides the same contract checking at compile time with the use of macros instead of using behaviours. How can you check a contract if you don't define one? It is fine to say you don't care about the contract, it is your risk to take, but let's not prepend the tools are doing the same. I am sorry but I will side with Plataformatec, Kent Beck, and others on this one. If you are mocking without defining proper contracts, then you end-up coupling components, asserting implementation details, etc. Good luck refactoring/changing code that is implicitly mocking modules everywhere. 
Technically it is, but the implementation is a lot different. Turbolinks requires dropping in some javascript into an existing application and now page transitions are nearly instant with no other work required except for replacing a couple of dom ready events to be turbolinks load. Then you add in a few lines of server code (which is available in Rails by default but has ports for a lot of other web frameworks) and now you can submit forms without full page reloads using turbolinks too.
I'm aware of how it works, I'm just saying that it's a SPA from the user's point of view. It even says this in the documentation.
Thanks for the write up! I was thinking of doing the same.
He used headless chrome then on the SPA and saved the result I believe. My question is how do you go from the rendered results to hydrating them after / booting up the SPA using the saved html? I thought that's what doing it with node/express gave you.
I can't watch the video but how do you handle rehydrating the html? I thought that was what the node solutions helped with. And what SPA framework are you using, react? Angular?
In a talk by Jos√©, he mentioned that services like Heroku aren't great for elixir due to the cores being distributed, and recommends using services where you can get whole machines. Does this address this? If not, have you had any issues related to this? 
Sounds like a good start, do you have a live demo running somewhere?
The very beginning of the video addresses this. Heroku isn't a great option for Phoenix due to that and a number of other limitations. However Phoenix is an excellent choice for Heroku. Its efficiency helps mitigate Heroku's biggest drawback, which is high costs as site usage goes up. I prefer to have more control over the server and run most my sites on Digital Ocean.
What are the gotchas with using Plug and Cowboy for a JSON endpoint? I love Phoenix for channels, templating, and the testing helpers - but for a simple API, it‚Äôs basically a different router DSL and Controllers instead of module Plugs.
Thanks for the reply. I was just wondering if there‚Äôs any explanation for my Elixir is bad on Heroku but Phoenix is better? Phoenix uses the same Erlang processes as Elixir. I imagine if your app uses state shares between processes, the disturbed cores makes it slow either way? I‚Äôve definitely seen recommendations to host in places like digital ocean or get whole EC2 instances.
Reminds me of what Chris McCord worked on for Rails a bit ago... https://github.com/chrismccord/render_sync
Author here, no online demo yet. I'm trying to release a polished version soon. Currently, there is one major [issue](https://github.com/almightycouch/gitgud/issues/11) that needs to be fixed in the Git backend (both for HTTP and SSH). Check the [Packfile](https://github.com/almightycouch/gitgud/blob/master/apps/gitrekt/lib/gitrekt/packfile.ex#L105) module for implementation details. I also need to provide missing Phoenix controllers for editing repository settings, manage maintainers &amp; SSH authentication keys, etc. There are also a lot of basic Git functionalities missing in the web frontend: * Git commit history on trees and blobs. * Git commit diff functionalities. * Git blame on blobs. * Compare (diff) two Git references. You might also want to check the forum post on Elixir forums: https://elixirforum.com/t/gitgud-github-clone-entirely-written-in-elixir/12920/21
It's not different. Phoenix is just Elixir.
Could this be used in a complex chat app? I feel that it could do the job... 
any plans on dog fooding it?
Gigalixir is a really nice service though it is a little expensive, but the free tier is quite generous. Having said that, you absolutely get what you pay for, and Jesse (the owner) is awesome and will work with you to get things working if you're stuck.
Yes of course. Currently, it's still very WIP. Lot's of things missing. Trying to get a release out soon. In the long-term, a public launch is planned and moving the project's codebase to it own service will be the first logic step. With adequate CI/CD features, it could even be possible to let contributors add new features, bug-fixes, etc. and update the service instantaneously, with the benefit of Erlang's hot-code-swapping capabilities to provide high availability. But that's an other adventure =)
observer_cli really has been a lifesaver for getting memory and CPU usage down on production nodes. I couldn't get forwarding to work with the GUI observer, and this is the next best thing.
Ah thanks this is what I was looking for. Totally support the message that Elixir will perform better than the other two!
This is one of my favorite modules to install on a new production app. &amp;#x200B; In addition to the level of stats it gets me in a production node, a feature request I requested was built within a few days, and I really appreciated that!
Great to see new features coming to the platform since the initial release. AWS support, free tier, mix mode. üëç
Nice use of ecto_mnesia! I‚Äôve been wondering lately if using ecto_mnesia with in-memory tables would be a more pleasant experience than direct ETS queries with the cumbersome matchspec tuples.
Do you plan on adding metrics/tracking? I feel like that‚Äôs bitly‚Äôs main selling point, right? I mean, nobody is shortening links just to shorten them. It‚Äôs mostly for marketing purposes.
Cooool. I'd love to have a personal server to do this. 
Actually we do shorten just to shorten. We use it to hide away urls with alot of query params so they fit inside a single sms message / look nicer
I actually disagree with: &gt; No one really uses bitly's paid plan for just shortening (for that, there's the free plan). When you're shortening in bulk like we have to we end up going over their free plan limits, not by much but we do. There next tier is $500 per month, hence this tutorial.
Fair enough. I never went beyond their 10,000 links per month cap on the free tier so I never thought about that. I would have to think that use case is pretty rare (compared to people who have many less links but want tracking).
I'm trying to keep things as simple as possible, but being new to elixir I'm not sure how opinionated the frameworks are. I'm looking at Phoenix at the moment but was curious what the community is doing. 
Community? I think mostly phoenix If you have previous experience with rails or rails-ish it‚Äôs pretty okay. Phoenix did not surprise me but YMMV.
Honestly I‚Äôd recommend reading the Phoenix source, unlike Rails it‚Äôs super simple and mostly composed of other pieces that you can choose not to use. You can recreate lots of Phoenix with plug, ecto and EEx. It doesn‚Äôt force you into a certain convention like rails does, lots of the auto generated templates are just syntactic sugar.
I've heard some folks like [Raxx](https://github.com/crowdhailer/raxx) for something more simple than Phoenix.
``` mix phx.new --no-html --no-brunch ``` You should absolutely utilize Phoenix for something like this. It is not heavyweight at all - only about 40 files in total. If you attempt roll your own - no matter how simple - you will inevitably end up reinventing the wheel with regards to boring things like routing, content types, error handling, rendering of JSON views, and so on. Save yourself the headache and utilize the existing tool, along with the growing ecosystem around that tool.
Another alternative to Plug is [Elli](https://github.com/elli-lib/elli)
Good to know, thanks!
Good Stuff. 
If it‚Äôs your first elixir project, then just go with Phoenix. It is built to be familiar to anyone with experience with MVC style frameworks, and doesn‚Äôt incur any performance overhead. The bigger learning curve for me was Ecto, particularly Changesets. It‚Äôs great once you wrap your head around it, but is different to other ORMs I‚Äôd used.
This is really interesting because Phoenix already feels very thin to me without much boilerplate. Can you give a concrete example? Not doubting it, just curious.
TIL I can make some serious cash for a simple service.
First of all by rehydrating you mean rehydrating the state and the event bindings on the client correct? If that‚Äôs what you mean then basically when the React code takes over in the browser it does that. So that‚Äôs how all the state is fresh and click events work. However when the page is loaded from the server they are just normal links so without JavaScript everything just works like static html. The html is pre rendered with all the state from the server. 
What convention does rails force you into? I like phoenix, but despite a lot smaller and less magical than rails, I guess it's not a lot less opinionated? 
For example, you don‚Äôt have to use MVC with Phoenix, the mvc conventions are just some macro magic around the Phoenix api.
(Creator of Ace here) Ace is not a framwork. Compared to Phoenix it has less opinions and less magic(macros), but you have to sort out more things on your own. Not that phoenix has much bad magic/opinions, but it does lead you to certain folder structures and you have to opt of certain things rather than adding what you need as you go along. In terms of maturity there are several people running Ace in production, we have been for over 18 months and where not the first. If you want to ask more questions the #raxx slack channel is a good place. https://elixir-lang.slack.com/messages/C56H3TBH8/
I can't point to any public code but on one project where we replaced Phoenix with Ace the diff was -1300 lines +400. This might have been smaller if we had made better use of the `--no-brunch` flags etc when starting
Frontend was coded in Elm. For this reason I will give a try :D
I don't have any public code to share but for the small API we removed the views/controllers/router/endpoint/phoenix-config and used 1 module that routed with regular pattern matching and dispatched to our service modules. The resulting web specific code was much smaller and could be understood entirely by just reading it, no knowledge of Phoenix's conventions and macros required.
Cool - makes a lot of sense for a project of that scope.
Aye, I think it only makes sense if you want to render lots of HTML. APIs don't need to be so complex.
It's hard to say because liveview isn't open source yet, but if it's anything like texas, not only will it be capable of doing complex chat app, it will likely be a lot more efficient than a frontend framework
Directly rom the Phoenix docs, lots of reasons why Heroku may not be a proper solution: Limitations Heroku is a great platform and Elixir performs well on it. However, you may run into limitations if you plan to leverage advanced features provided by Elixir and Phoenix, such as: * Connections are limited. * Heroku [limits the number of simultaneous connections](https://devcenter.heroku.com/articles/http-routing#request-concurrency) as well as the [duration of each connection](https://devcenter.heroku.com/articles/limits#http-timeouts). It is common to use Elixir for real-time apps which need lots of concurrent, persistent connections, and Phoenix is capable of [handling over 2 million connections on a single server](http://www.phoenixframework.org/blog/the-road-to-2-million-websocket-connections). * Distributed clustering is not possible. * Heroku [firewalls dynos off from one another](https://devcenter.heroku.com/articles/dynos#networking). This means things like [distributed Phoenix channels](https://dockyard.com/blog/2016/01/28/running-elixir-and-phoenix-projects-on-a-cluster-of-nodes) and [distributed tasks](https://elixir-lang.org/getting-started/mix-otp/distributed-tasks-and-configuration.html) will need to rely on something like Redis instead of Elixir‚Äôs built-in distribution. * In-memory state such as those in [Agents](https://elixir-lang.org/getting-started/mix-otp/agent.html), [GenServers](https://elixir-lang.org/getting-started/mix-otp/genserver.html), and [ETS](https://elixir-lang.org/getting-started/mix-otp/ets.html) will be lost every 24 hours. * Heroku [restarts dynos](https://devcenter.heroku.com/articles/dynos#restarting) every 24 hours regardless of whether the node is healthy. * [Remote shells](https://hexdocs.pm/iex/IEx.html#module-remote-shells) and remote observer are not possible. * Heroku does not allow SSH access to your dynos so you can not inspect, debug, or trace your production nodes using things like [the built-in Observer](https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html#observer). If you are just getting started or you don‚Äôt expect to use the features above, Heroku should be enough for your needs. For instance, if you are migrating an existing application running on Heroku to Phoenix, keeping a similar set of features, Elixir will perform just as well or even better than your current stack.
I can help you out. I have been writing Elixir and Phoenix for about 2 years.
Do you make it an umbrella app where the logic is in one app and the web front end in another?
I would be willing to help, too. I'm 3 years in and can probably answer some questions. 
Udemy has a great Elixir course! if you wait around for a special you might be able to get it for ten bucks.
I'm going to suggest the opposite. Moving modules around in Elixir is so easy that I would keep it simple at the start, especially when learning. Umbrellas are good for separating concerns but add a whole different kind of complexity which you may not be ready to grock. KISS applies here (Keep It Simple Stupid) As for good resources that can provide some type of mentorship check out [https://exercism.io/](https://exercism.io/)
[removed]
I enjoyed your talk, thanks for your contributions!
Agreed
I would say to use one app until you have a clear reason why the extra complexity is advantageous. 
You can even see me looking at and commenting on that section of the docs in the beginning of the video!
I'm searching for a coding group (a group to do something deployable like real life project, but for learning) Let's start a project and learn by doing in group. We can make a Telegram group to start and then an organization in GitHub. The product to deploy may be a platform to organize coding groups (meta coding group). Who say yes?
We have been working with Elixir for 2 years and we have a training program for interns and juniors who want to learn it. Contact me at han@dwarves.foundation
If you make it open source, you can definitely get some decent help in slack / IRC.
At the moment going through Stephen Grinder's udemy course on Elixir and Phoenix. It's the most fun I had in the past few months!
@davydog187 good article ...to the point
the site has that crisp response feel of a phoenix site
We use them for both the public front end as well as our CMS. On the public side of things, they let us keep user state in the channel, which makes implementing infinite scroll a bit easier.
I found this really helpful as a noob, no feedback other than a thank you :)
Just saw the site on mobile, it‚Äôs crazy polished! Awesome work! Loads super fast and has some fun little animations. Did you use JQuery or some other UI library?
Thank you! The front end uses a home grown js framework for the animations as well as Preact for some other pieces
That‚Äôs interesting, so would you say the pages are mostly sever side rendered and then on any page that needs some enhanced UI, you use your JS framework or Preact to load content into a div and manage state within that Preact component, etc? 
Yep. Turn off JavaScript and visit https://theoutline.com We use Javascript for infinite scroll, animations, and our more sophisticated visual components. Preact is very lightly used. 
That is very valuable feedback! Thank YOU!
Very nice and informative write up! Thanks for sharing!
Is this a good use case for sockets? I'm always looking for uses for sockets but wind up going back to Ajax for things like this. 
You can look at escript &amp;#x200B; [https://elixirschool.com/en/lessons/advanced/escripts/](https://elixirschool.com/en/lessons/advanced/escripts/) &amp;#x200B; It makes an executable and you can run that from command line.
They don‚Äôt really deep dive into their elixir architecture other than to brag about the stats. I‚Äôd love to see if they are using genservers to maintain their state, if they are using a cluster of erlang nodes, and if there are any databases in the mix. 
They have another blog post on scaling their backend which goes into a lot more detail.
I'm not finding that article (i'm probably just blind) do you mind linking it if you find it?
If you want more architecture details, check out the Riot Games blog posts. They post a lot more details of how they were able to scale. https://engineering.riotgames.com/news/riot-messaging-service https://engineering.riotgames.com/news/chat-service-architecture-servers https://engineering.riotgames.com/news/chat-service-architecture-protocol Tons of good stuff in there. 
Thanks. Not as much detail as I was hoping, but at least it got more nitty gritty than the one OP posted.
Thanks. Not as much detail as I was hoping, but at least it got more nitty gritty than the one OP posted.
Idiomatic Elixir is still somewhat young and evolving.
Well, `mix format` came in 1.6, and I believe the optional parentheses are pre-1.0. Dropping them now might break some older code. They are still required in anonymous function calls, though.
So I guess the elixir team has decided since then that parentheses shouldn't be optional? Because that seems like an unfortunate decision to make after so long. Also, the official tutorial mentions that they are optional and has many examples that elide parentheses, to my confusion.
For what it‚Äôs worth, `mix format` has very little configurability, but one of the options it does have is `locals_without_parens` which allows you to define a list of functions that should not have parens added. This option is what allows tests to have code like `assert foo` without the parens.
I enjoy skipping parens (with my spaces.. ;) as well, but the community style has evolved and its just one of those things.
Optional parentheses are more of a technical thing now. It allows you to write `if foo, do: ...` instead of `if(foo, do: ...)`. Optional parentheses for your custom functions are not suggested because they very easily make code ambiguous or hard to read.
Ah, that makes a lot of sense, thank you! Does this tie in with the `locals_without_parens` option so developers can make DSLs?
Fair point, increased consistency is probably why `mix format` lacks configurability in the first place, Jos√© and crew seem to take a pretty conservative approach to configuration up until there are definitive use cases for them. It may not suit your needs, but I find myself trying to avoid optional parens anyways, the amount of typing it saves isn‚Äôt worth the two different ways to write function invocations in my view, is except for where the language makes use of it to disguise macros as syntax. I have a feeling optional parens were really intended mostly for macros and mostly so that you could make language syntax looking things like `defstruct` which look more ‚Äúbuilt-in‚Äù without parens. Seems like they left them in the language for DSLs and the like but based off of `mix format` it seems like they might regret that decision. Or I might be reading a bunch of intent into nothing at all. I will say that having a first-class code formatter has been nice for working on a large code base with multiple contributors, no more quibbling over, ‚Äúactually if you have a compound statement you should really put a line break and indent‚Äù or ‚Äúhmm... your pipes aren‚Äôt lined up the way I like.‚Äù
Yes.
I don't think of it as the one true style, more a lowest common denominator when team cohesion is more important than personal aesthetics. I have very opinionated, well-reasoned stylistic preferences in many languages. That goes out the window in large or collaborative projects where agreeing on a standard‚Äîany standard‚Äìspeeds things up by allowing everyone to look past syntax when code changes hands. But when I'm working on personal projects, I write the way I think so I can get back into it even faster. It's nice to have both.
Yeah, I can respect consistency. I come from Rust where the compiler itself has a few lints that keep the general style the same (snake_case vs PascalCase, etc.) and first-party tools provide a more broad style formatting system, albeit with more configuration than `mix format`. The optional parentheses being for syntax-like macros is what I'm also thinking after reading Nicd's comment, and it seems reasonable. Of course, I've also used Haskell, and since learning it I've always felt parentheses are unnecessary visual noise, but it doesn't work for all languages, nor does it work for everyone. Thanks!
Even a function definition, ‚Äòdef foo()‚Äò is technically written as ‚Äòdef(foo())‚Äò, so the feature still used.
Even the `do` notation is just sugar for a keyword list (and the same thing powers `if/else` et al, they're not keywords either) These are all equivalent: def bar(a, b) do a+b end def(bar2(a, b, do: a + b)) def(bar3(a, b), [{:do, a + b}])
Just mix format. Then it doesn‚Äôt matter. 
I'm surprised no one has mentioned that you can import formatter configs from dependencies. &amp;#x200B; For instance, to get \`mix format\` to not add parens around ecto schema definitions, you can add this to your .formatter.exs \`import\_deps: \[:ecto\]\` &amp;#x200B; [https://hexdocs.pm/mix/master/Mix.Tasks.Format.html](https://hexdocs.pm/mix/master/Mix.Tasks.Format.html)
mythicgaming.net
Try accessing them with `static_url` in your template: `&lt;link rel="stylesheet" href="&lt;%= static_url(@conn, "/css/app.css") %&gt;" /&gt;` or `&lt;link rel="stylesheet" href="&lt;%= Routes.static_url(@conn, "/css/app.css") %&gt;" /&gt;` if you're on master/1.4
My library has reached a point to where I feel it can be used for serious projects, and I wanted to share it with the larger community. My hope is that developers with a basic understanding of Ethereum and working with Smart Contracts will be able to get started quickly.
A set of plugs for API access control (and for training - first libs), including: * Authenticators: HTTP Basic, OAuth2 Bearer RFC7662, OAuth2 JWT RFC7523, TLS client certificate * Filters: throttler, IP whitelist/blacklist
Great stuff. I‚Äôm developing a dapp at the moment and even though we‚Äôre very ahead on it I‚Äôll be considering to include this in the back-end, maybe for simple read operations for checks, who knows. 
Good to know, thanks! I was just starting out with Phoenix and I was wondering why it added parentheses to the route macros.
Thanks! And yes I am also going through a phase of figuring out how to integrate exw3 into my own work. Thinking about using it to make a malicious user to test fault tolerance. 
Hey :) check out my channel - [http://twitch.tv/solutionops](http://twitch.tv/solutionops) and I'm more that stream answers to your questions :) If you need private consultation - drop me a message.
According to this video this seems to be the list of things not to use BEAM languages for: * computation heavy tasks * desktop GUI apps * mobile apps * shell scripts * deep learning
^The linked tweet was tweeted by [@wstucco](https://twitter.com/wstucco) on Sep 30, 2018 19:42:41 UTC (19 Retweets | 73 Favorites) ------------------------------------------------- I was wondering if I could create something similar to Flash movieclips with \#ScenicUX and accidentally made Shadow of the Beast Thanks to [@BoydMulterer ](https://twitter.com/BoydMulterer ) GUI programming is fun again \#ScenicUX is just great \#myelixirstatus [Attached video](https://video.twimg.com/ext_tw_video/1046485308219559936/pu/vid/888x720/AY0xc60Z62RpACdn.mp4?tag=5) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
The solution for "computation heavy tasks" is the same as most other languages: write it in C and provide bindings for it. Deep learning likely falls under this scenario too, specially as some bindings are starting to come out.
ha, that didn't take long!
The code is online for those interested :) &amp;#x200B; [https://gitlab.com/wstucco/scenic-sotb](https://gitlab.com/wstucco/scenic-sotb) &amp;#x200B; &amp;#x200B;
Also Named bindings. Not sure I understand the Multi.run/5 change. Why do I want my repo as the first arg?
I think this is where it was originally discussed. https://groups.google.com/forum/#!topic/elixir-ecto/uqUkVCKhd7c I think this is quite useful when we have multiple repos in our application though. Making it easier to abstract and compose multi steps.
GitHub has a [hacktoberfest](https://github.com/topics/hacktoberfest) topic where they also look for open issues with the label "help wanted". There aren't many [Elixir ones](https://github.com/topics/hacktoberfest?l=elixir) marked.
I opened an issue on a project that I help maintain. It is an Elixir [Gremlin](http://tinkerpop.apache.org/) Driver. Setting it up and trying it out yourself without knowledge of graph databases might be a little much but if you look at the example PR in the issue, you can see how simple a lot of these functions could be to submit PRs for. [https://github.com/Revmaker/gremlex/issues/46](https://github.com/Revmaker/gremlex/issues/46)
Why not move the whole verified up into a plug? I assume that its something you're going to need to do for every request the bot makes to your endpoint, so you could handle it all at a plug layer and not have to worry about it in your controllers
Good question! It was only for action endpoints and not all endpoints. How exactly would you say "if verified continue to controller else end conn and send unauthorized?"
This is awesome I'll have to try it out, thank you! Glad to get more refined feedback on the post :)
2:00 PM EDT happens when this comment is 1 hour and 33 minutes old. You can find the live countdown here: https://countle.com/bWSspTFDr --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Might be worth noting that this is only the case when you pass messages around within the same VM instance. Once you pass messages outside of that bubble (i.e. to another vm instance) any data will have to be serialized and copied.
You can use [`Plug.Conn.halt/1`](https://hexdocs.pm/plug/1.6.3/Plug.Conn.html#halt/1) to interrupt a pipeline. You can also make plugs only apply to a single controller or controllers in a namespace
The second link is broken. I'd love to check out the stream though. 
oops. typed from memory. [https://challenge.curbside.com/](https://challenge.curbside.com/) 
[https://github.com/echavezNS/conekta-elixir/issues/7](https://github.com/echavezNS/conekta-elixir/issues/7)
Yes I am. Glad I could help
Good point, will make a follow up video 
Well thanks for making it too then. It makes me wonder if erlang puts a lock on the memory pointer since it then brings up concurrent access issues? I did a (very) quick search on mobile but didn‚Äôt find the answer.
As the data is immutable there is no need for a lock. I will make more videos to explain some of the details around this
Right! My noob shining through.
Good bot
please ask as many questions as you want to!
but you can construct types with tuples and atoms. This can lead to better and safer code
https://goo.gl/forms/U8h58Snvb3h2aB0E3
How useful will this be when LiveView rolls with Phoenix? Or am I just talking non sense in comparing them ?
Thanks for adding my verifying signatures post to the newsletter!
Thanks.
Planga integrates chat in the client's front end. The messages (thus load) never touches your servers :)
Why post this in /r/elixir ?
Thanks for making these educational videos, I really feel like we are missing easy to follow kind of intermediate content of this format in the elixir community right now. I would have loved to see an example of things being comparable, maybe just an iex session with your voice explaining what is going on. Also I still don‚Äôt really understand how comparability can be well defined, but actual compares seem to be random. As a very good example of easy to understand and follow videos on intermediate to advanced level programming is Avdi Grimm in the Ruby community. He has some [free content on ruby tapas](https://www.rubytapas.com/category/freebies/) if you want to check it out. Please don‚Äôt take this as a negative feedback, I would really like to see you improving and keep contributing this kind of content! Keep it up üë® 
"Tag instances of bigotry, ad hominem attacks, sexual harassment." How did you accomplish this? Also, I thought the random super hero names in the demo chat was cool.
I'm working on a multiplayer movie guessing game. React frontend connecting through websockets/channels and using a GenServer to manage each game.
While there's no syntactical element to inform to the compiler that those expressions are grouped together (as is the case in Erlang). The compiler will expect functions to be grouped together and if not will give a warning (IIRC it's a warning and not an error). While that wouldn't detect your mistake, it would catch a mistake if you had say another function above `print_multiple_strings` that was called `print_multiple_times`. Other than that you do have a few options. The first (and really only one I'd suggest) is dialyzer is able to catch infinite recursion if you have code that is expecting the function to return. The other two ideas are more just examples that it's possible but not really suggested. You could create a macro that checks all definitions in the body passed to it to make sure they all have the same name. This would solve your issue exactly. But now you have this abstraction that newcomers to your codebase won't understand and will need to lookup your macro to understand. Or add a compiler callback for the module and check if there's any function definitions next to each other that have some similarity in their name (to a point where you would consider it to possibly be a typo). Wouldn't catch all mistakes (say if the two names were entirely different), although there's probably some other behaviour you could check for. 
A statically typed language for the Erlang VM https://github.com/lpil/gleam
I blogged. About trying to use Elixir to get a speed boost in a short running script (spoiler: I didn't get it) and my adventures with Erlang's "documentation." The latter probably not news to anyone who's spent any amount of time moving between Elixir's genuinely excellent docs and Erlang's... "docs".
So my question to you is then: Why use :httpc rather than HttpPoison or HttpPotion? Those are two libraries on HexPM with great Elixir bindings and documentation. But yes, in your example, it definitely is the network tgat slows down this task, rather than your code itself.
Erlang has good documentation, I have no idea why you're complaining. Those parameters were well explained For your example httpc: http://erlang.org/doc/man/httpc.html The request/4 function is on that page and tells you exactly what the types are for the arguments. At the top of the erlang man pages for libraries - it shows you what values are accepted for each type. It's literally written there. 
I'm not an Erlang or Elixir pro - More like a wet-behind-the-ears rookie, but I'm not sure I agree with everything in the post - Could some of your friction be simple inexperience? The effort to rewrite parts in other languages is commendable and a good exercise, but for such a small program, "it should be faster in X" is likely flawed when the majority of the speed loss stems from uncontrollable factors (such as disk I/O or network speed). You write that: &gt;Erlang's :httpc.request ‚Äì which it turns out has four parameters‚Ä¶ &gt; &gt;`:get, {url, query}, [], []` &gt; &gt;and &gt; &gt;`:post, {url, headers, content_type, body}, [], []` &gt; &gt;both seemed to work, but I had to work that out, you wouldn't know it from the ["documentation"](http://erlang.org/doc/man/httpc.html). I'd show the rest of the code but working out those parameters really was most of the effort. But - the documentation is fairly clear about this? Looking at the sidebar, it lists: &gt;request/1 &gt; &gt;request/2 &gt; &gt;request/4 &gt; &gt;request/5 Which already tells us that there is a method called `request` which accepts 1, 2, 4 or 5 arguments. Looking at the documentation for the method, I'm not sure what they mean by `request(Url) -&gt; request(Url, Profile) -&gt; {ok, Result} | {error, Reason}` exactly, but it seems to indicate that you put in a URL, and get a result back. It also states that this method is "Equivalent to `httpc:request(get, {Url, []}, [], [])`." Just beyond that, you have similar notation for the 4- and 5-argument versions, e.g. `request(Method, Request, HTTPOptions, Options, Profile)`. The definition of Request is outlined, too: &gt;request() &gt; &gt;= {url(), headers()} &gt; &gt;| {url(), headers(), content\_type(), body()} headers, in turn, are defined as a list of `header()`s &gt;headers() = \[header()\] and header() is defined as &gt;{field(), value()} which are in turn defined as &gt;field() = string() &gt; &gt;value() = string() So, all told, I'm not sure I agree that the documentation is user-hostile and worthless. We just pieced together how to make a request, with headers for authentication, just from the API reference! You do touch upon that Erlang strings need to be converted to character lists, and I won't deny this as a possible pain, but even I know that Erlang is.... not great at managing strings, so this shouldn't be too much of a surprise. Still annoying though, I'll give you that. Then you end the post with some conflation: You begin the post by talking about how you wanted to move to Elixir for speed. Then you utilize straight Erlang libraries and function calls and detailing the pain points you stumbled upon using Erlang, and end by saying that "moving to Elixir \[didn't offer much\]" - But you moved to Erlang, not Elixir? I know for a fact that Elixir has way better string handling and a bunch of libraries (Like HTTPoison) that makes simple requests like this very easy to handle. &amp;#x200B;
I would like to have a version in text about this
at some point I may make a transcription of these
Erlang docs are definitely hard to get used to, but imo once I got more comfortable i found them to be just fine, and comprehensive. Inded though, Elixir docs are much better.
Thank you. I will get there eventually.
Just to explain why text would be better than episodic videos, at least for me: - it‚Äôs indexable - it doesn‚Äôt force your pace and only enforces structure - I read faster than you speak - it allows me to approach the message my way (e.g. sometimes I skim through the text to... well, pretty much to index it and assess commitment required) - it allows me to use your blog, book, or however you structure your texts as a quick reference that I can refer to in seconds by using text search, whereas short episodic videos are virtually useless for what is arguably the most important feature of a learning material Granted, videos work great when complimented with textual resources or when the message is focused, extensive, and requires upfront time commitment (lecture videos come to mind).
Um thanks? Normally my wife makes the pizza and I make other stuff
I get that, for now I don't have the time/resources to turn them into blogs. 
We miss you
Your category links don't work.
pushing a fix for it.
##r/erlang --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
done 
Awesome! I thought we were getting a "sneek peek" in LiveView for Phx 1.4, but I think I was mistaken.
LiveView isn't going to be a part of Phoenix, it's going to be its own lib.
Oh yeah, that's right.
I'm quite excited for Live View! 
got inspiration from Chris's Gleam in go? 
Working on Elixir application on K8s with Docker.
Not heard about this project before. Just happens to have the same name :)
The WINDOW support is awesome. Really like the implementation here. Great work (as always).
You should check out erldocs.com, they have searchable and more legible documentation.
I‚Äôm excited about this. It‚Äôll feel better than using fragments. &lt;3 window functions. 
Elm? No thanks I don't like writing lots and lots of boilerplate.
I‚Äôve never written Elm but I am interested. Is it any different in regards to boilerplate as say React, Angular, Vue, or the Redux?
What else do you recommend trying? I'm not a frontend guy so I'm open to suggestions, I mainly try them on personal projects. I admit that Elm can be verbose in the initial setup but I don't mind it, I really like the helpful error messages though.
Yes and no. Elm does not give you tools to abstract and reuse, which is a language issue, as opposed to the libraries you mentioned. Purescript and ReasonML. I think Elm is fine to learn to get your feet wet with functional programming in a language that is closer to haskell. But don't take my word for it, maybe you'll end up liking Elm more than the alternatives out there.
Purescript and ReasonML. In fairness I'm pretty heavily biased towards Ocaml (reason is a different syntax but otherwise uses the same compiler as ocaml, and bucklescript to compile to javascript).
My friend recommended Purescript to me some time ago, I've started reading Purescript by Example but the fact that you basically have to go through 8 chapters before being able to print "Hello" in a browser didn't made it click for me like Elm did. Moreover I've happened to start trying it like the exact day they released v0.12, so the ecosystem was a little unstable since not every library had been ported, but that was clearly a temporary problem, so I might give another try now. The ML-derived family is a much more recent discovery (I think I discovered the existence of Bucklescript on the Elixir forum in the comments regarding the release of Elm 0.19), it makes me curious because the OCaml syntax is strange compared to what I've used to and it's definitely on my todo list.
elm is a dead meme
ReasonML with reason-react is nice.
I don't know what he's talking about. I haven't used React or Vue, but I can assure you Elm does not have more boilerplate than Angular. Sure, if you want to define typeclasses or used advanced functional language constructs, Elm is not for you and Purescript will fit the bill. But I'd argue that if you need those things, you're overloading the client side of your application.
Don‚Äôt listen to the Elm haters. It is really well designed and Evan is a genius. It takes time getting used to it, but the Elm architecture does most of the thinking for you which is great.
ClojureScript with reagent/reframe is my fav. And a fair bit of elixir was influenced by Clojure, aside from syntax. 
You can also alleviate quite a bit of boilerplate by introducing a smarter flow, at least when it comes to how your updates are chained and message events are sent/processed. If you don't try and do anything about it though then it will get boilerplate heavy. But even putting up with that boilerplate I think is worthwhile for the guarantees you get. 
Thanks for this!
Great intro
I recently updated Cachex with sharded support for multiple Erlang processes; figured I'd write up a little about it with an example you can try out to see it in action! 
Thanks for your continued work on this!
Nice write up. ‚ÄúWhat's even better is that there is practically zero overhead for those people using a cache on a single cluster; ‚Äú I think you mean single node? 
How would I approach this to get a working react configuration, preferably with typescript support? Does anyone know? (I'm new to webpack and frontend in general)
What is the current protocol used by elixir/erlang for IPC ?
&gt; This was fairly substantial, especially then you look back and compare it to the current Cachex benchmarks. Perhaps you mean _when_ you look back? Great read btw!
tcp over the network.
&gt; The reason this feature had not been added to ethereumex before is that the dogma around IPC with Elixir is that it couldn‚Äôt be done Nonsense! Nothing forces us to use the network, as you've proven here. :)
I love comprehensive blog posts like this one.
Man this is cool I guess I reinvented the wheel here with https://github.com/selfup/smache lol I'll take a look at your repo and see how you handle the self sharding. I am currently using the modulo (rem) of a key compared to Node.list 
That's actually good enough; I could probably do the same for now. I'm using a hashing technique that should make it easier in future to support adding/removing nodes - but it's just to help out my future self!
Yea adding nodes and stale cache are a current Achilles heel right now for me. So it's cool we are running into the same problems ü§£
Adding nodes is pretty straightforward if you improve your hashing. Stale caches are avoidable if you shard your caches instead of replicate them (if I understand what you mean by "stale").
An update to a Cheat sheet I released a year or two ago for A novice to moderate level to elixir. Hopefully done in a week or two. So much info to digest since Elixir 1.2.4 
My only gripe with Elixir `Logger` is fact that it is completely separate from Erlang‚Äôs logger. I need to configure them separately. Before OTP 21 it was quite understandable as Erlang logging system was a little bit old and convoluted, but now the two share quite a lot. So now we have two almost identical systems which are completely independent from each other and changing that can be hard. Another issue for me is that Elixir logger has only 4 debug levels instead of 7 like the Erlang one (based on syslog protocol). 
I use this at work I can take a look at home I‚Äôm using it, watch this space 
You probably need to start some kind of broker process in your application.ex. Then you can send messages to the process, or create child subscribers under the broker supervision tree. We'd have to look at the docs and code. 
 defmodule TestingDeps.Main do require Tortoise def testing do # children = [Tortoise.Connection, []] opts = [strategy: :one_for_one, name: Tortoise.Supervisor] Tortoise.Supervisor.start_link(opts) Tortoise.Supervisor.start_child( client_id: T1000, handler: {Tortoise.Handler.Logger, []}, server: {Tortoise.Transport.Tcp, host: 'localhost', port: 1883}, subscriptions: [{"foo/bar", 0}] ) Tortoise.publish(T1000, "foo/bar", "Hello from the World of Tomorrow !", qos: 0) end end I'm trying with mix start, if I were to run in iex, I can connect to a broker
&gt;When I look at the library it looks like a DynamicGenserver but when I use mix run should this genserver not already be running anyway? No. DynamicGenservers are started dynamicaly, unlike regular Genservers where you have to specify which genserver to start in your application.ex. If you want to start all your DynamicGenservers than you need to manually start them. i have something like this in my application.ex: def start(_type, _args) do import Supervisor.Spec, warn: false sup = Supervisor.start_link([ supervisor(MyApp.Server.Supervisor, []), {Registry, keys: :unique, name: MyApp.Server}, ], strategy: :one_for_one, name: MyApp.Supervisor) MyApp.Server.restore_all() sup end and in my my_app/sever.ex: def restore_all() do servers = fetch_a_list_of_servers_from_db Enum.each(servers, fn(server) -&gt; Supervisor.start_child(server) end) end 
[Waiting](https://i.imgur.com/lqoUSpN.jpg) :-p
Documentation is quite sparse. It would be worth expanding it a little. 
It is great to see elixir LS is gaining traction :). Does anyone knows if elixir LS is as good as Alchemist in terms of completions? I don't know if it was my fault, but last time I tried I couldn't get completion for external modules. 
In my experience the completion is much better with elixir ls and ale. When you tried last, which ls-client did you use?
Just following the post and getting some configs from the author's vimrc didn't work for me. :'(
If you can link me to your vimrc I can take a look for you.
I used LanguageClient-neovim. that's the one I use with Rust, Python and TypeScript 
So, I think I found the issue. I built the elixir-ls with the latest elixir version that I have, which is 1.7. But the project I'm working right now is in 1.6. I just opened my most recent project and everything worked perfectly. I'll have to figure it out how to setup that.
Oh! That's really interesting. I am wondering if anyone else has run into that trouble. I'm glad you got it figured out!
Yes I agree, I'm in the process of adding it.
The book I've been learning Elixir from didn't cover genserver or any supervising tree, I've just been learning in the past day. But i did do what you said any that hasn't gotten me any further "/ I seems that I can use the start_link and start_child function without error but when it gets to &gt; Tortoise.publish I get &gt; ** (ArgumentError) unknown registry: 
&gt; Client/Server is just another type of distributed system. What if the whole system can be treated as a group of processes that send messages to each other. The biggest flaw with this thought process is that there is a very big trust boundary in-between client/server. Without a way to model and understand how to handle that trust relationship (rather than pretending it didn't exist) this cannot succeed. I suggest you make that a focus first. Also, for an elixir project, don't start the readme off with JavaScript ü§™
Why not just dump the browser and support X11. If we're going back to the mainframe-terminal model, lets use something that could work over a 300 baud connection
Slightly newer version temporarily at https://bitbucket.org/yawaramin/stubbex/ while GitHub is down.
*Arity
Nice discovery but it seems it only works with mix project ? At least, my configuration doesn't work with single file like a exs script ;/
I don't understand this comment. What makes you draw this analogy
There is a security model. All addresses passed to the client are signed. This means that a client cannot fabricate address to process. The only way a client can send a message is if they have explicitly been sent that address in a previous message. https://en.wikipedia.org/wiki/Object-capability_model 
**Object-capability model** The object-capability model is a computer security model. A capability describes a transferable right to perform one (or more) operations on a given object. It can be obtained by the following combination: an unforgeable reference (in the sense of object references or protected pointers) that can be sent in messages. a message that specifies the operation to be performed.The security model relies on not being able to forge references. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/elixir/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I think it should still work. What version of elixir are you using? Elixir LS requires 1.6.0 minimum. 
Don't be sorry, it's not your fault ! and thanks to you, I made the switch from neomake to ale :)
The number of arguments that can/must be passed to them.
You need to start the Tortoise app, it starts the registry [as part of its initialization](https://github.com/gausby/tortoise/blob/d3262d3cd74ffd34e90718f5045852f706d938da/lib/tortoise/app.ex#L12). Normally that's done automatically if your app depends on Tortoise in its `mix.exs`. It's hard to tell why that's not the case without looking at your project's structure, but either way you can start it by calling [`ensure_all_started(:tortoise)`](https://hexdocs.pm/elixir/Application.html#ensure_all_started/1) before using its functions.
Mind sharing the link to this cheat sheet?
I'm working on https://github.com/yawaramin/stubbex , a stub server for HTTP service virtualization. What I think is cool about Stubbex is that it's zero-config and tries to just 'do the right thing'. For example, to start stubbing and immediately serving an endpoint, open http://localhost:4000/stubs/https/github.com (e.g.) in your browser. Stubbex fetches it and saves it for next time. You can find the stub files in `stubbex/stubs/...` organized by host and endpoint. 
Rewriting my blog engine using Raxx. WIP is at https://gitlab.com/Nicd/mebe-2 The old one (Mebe 1) was such a mess, trying to apply all that I have learned now (tests will be added, don't worry). Some of the code (engine side) is from the old version, will go through that to clean it up and document it as well.
A statically typed language for the Erlang VM I've almost just the type inference algorithm working for the main language, now I'm just refactoring to clean things up a bit and to improve codegen using type annotations. Lots of fun :) https://github.com/lpil/gleam
Personally I just put an anon fun in the pipeline: |&gt; (fn name -&gt; user: name end).()
That looks pretty cool
Take this with a grain of salt because my elixir skills are mediocre....but could you create an async task for this? [https://hexdocs.pm/elixir/Task.html](https://hexdocs.pm/elixir/Task.html) So you don't need to store the current state in a database you just wrap the processing call in Task.async() and then you can have it asynchronously wait for the response of "pending", "complete" or "failed"....that way you are hogging up your resources waiting for that 15 second task to complete. 
Can you call a function library? That's all this is.
How important is it to have a durable record of the in-progress tasks? You can take a look at ecto_job for an example that uses GenStage with Postgres. https://github.com/mbuhot/ecto_job If you don‚Äôt need durability for retires across VM restarts, then a GenStage Producer + ConsumerSupervisor with a max_demand setting should do the trick.
The most important thing in a system like this, is that the user is aware of what is going on: A system does not feel 'slow/unresponsive' if the user has a progress bar (or even an incrementing timer! Useful if the progress is impossible to measure) to look at, and is notified both when the job is done, as well as when it has failed (and also when it goes from the waiting queue to the work pool). Phoenix makes this easy with its websockets :D. 
I think in-memory mnesia should ‚Äújust work‚Äù once your nodes are clustered. It also looks like there is some writable storage available in the container that runs your app, used for downloading releases and doing hot upgrades, so you might be able to persist a small amount of data there.
Doppelganger, a Elixir to Erlang code transformer. It already converts most of the simple Elixir code, but I still need to work on stuff like pipes and with blocks, and has some bugs (wrapping a function in parens for no reason). &amp;#x200B; The idea is to build something like Java to Kotlin code transformer in IntelliJ IDEA, and integrate it with different editor extensions. And the reason for doing it is that it's pretty fun ;) &amp;#x200B; Repo: [https://github.com/jxub/doppelganger](https://github.com/jxub/doppelganger)
Graph and relational data are structured rather differently, and the query semantics are likewise rather different .. would not map very nicely imo...
Here's some inspiration for you dude https://github.com/jonschlinkert/is-even/blob/master/index.js
An Ecto adaptor is additional work. It could be implemented on top of this library, as the Postgres Ecto adapter is implemented on top of the Postgrex client library.
This is cool. What's the process? * Elixir -&gt; Elixir AST -&gt; Erlang * Elixir -&gt; Core Erlang -&gt; Erlang ?
I just took a quick look and looks like they're going Elixir AST to Erlang. It's interesting but definitely the most difficult way. The easy alternative would be BEAM to Erlang (given that there's one or two standard functions provided to achieve that). Not sure how they're going to handle non-standard externally defined macros though, or even the `use` macro (if the target `__using__/1` was defined in another file). A nice thing about their approach though is that it's not executing any of the elixir input. So you could actually expose it to allow untrusted input (for instance if you wanted to make an online Elixir to Erlang converter). Since going the BEAM route, would mean someone could add some malicious code that's executed at compile time. Another differentiator is this would let you see examples of how writing something equivalent would be done in Erlang rather than being a 1 to 1 conversion (since they're not putting in the `:Elixir` prefix, nor handling elixir's own abstractions like the different behaviour of `GenServer.cast` vs `:gen_server.cast`, etc.). 
Yes /u/MrPopinjay, the conversion path is Elixir -&gt; Elixir AST -&gt; custom structs with \`impl Strings.Char\` to print them out as Erlang data structures. Regarding the \`\_\_using\_\_\` callback, I'm not sure how to implement it yet, but the \`use\` macro is implemented in [https://github.com/jxub/doppelganger/blob/master/lib/doppelganger/parse/doppel\_behaviour.ex](https://github.com/jxub/doppelganger/blob/master/lib/doppelganger/parse/doppel_behaviour.ex) as a basic translation of the most common OTP behaviours. &amp;#x200B; Now, I'll need to add checks for the required callbacks with a given arity returned by \`get\_required\_callbacks\`. For that, the blocker is the \`Doppelganger.Finder\` module which ought to be a GenServer that looks for function, attribute and variable definitions in a given module/function, and to which each parsed function, attribute, and variable definition is pushed at parse stage. &amp;#x200B; I'm not sure how to implement macros though in a straightforward way, and I have to handle cases when modules don't map 1:1 to the file (like more modules in a file), and unnest nested modules by expanding their path as an Erlang module name. 
New version of \[open\_api\_spex\]([https://github.com/open-api-spex/open\_api\_spex](https://github.com/open-api-spex/open_api_spex)) with support for validating polymorphic swagger 3.0 schemas. Moved the repo from my personal account to a new github org to promote shared ownership.
&gt; The easy alternative would be BEAM to Erlang (given that there's one or two standard functions provided to achieve that). Is there? You can go from Erlang AST to Erlang source I believe (which works as Elixir compiles to Erlang AST) but you can't go from any BEAM to Erlang. Modules written in LFE, Alpaca, Gleam etc don't have the Erlang AST embedded in them so you can only dump them to Core syntax.
Great post, very thorough. For dependencies that rely on compile time configuration, should the `config.exs` file be copied into the deps build stage? Love the idea of pushing the intermediate build stages to a registry to share between developers. Does it work for sharing dialyzer PLTs? That would be a big saving.
Thank you, and great/thoughtful question! If the config content really has a compile-time impact, such as informing a module attribute that then drives function calls between 2+ alternate implementation modules, I would strongly consider including that in the deps stage. The mostly-good news is that the Elixir compiler is well-behaved in the lazy scenario - if the newly COPYed config.exs content is meaningfully different, it *should* recompile those affected modules during the ‚Äúmix release‚Äù layer. So, small repetition of work during docker builds that could be optimized away once we‚Äôre aware it‚Äôs happening.
If the BEAM includes debug information (which if we're compiling the elixir source then that's totally feasible) then you can get the abstract code from it. So the full path would be `elixir source -&gt; compile -&gt; get AST from BEAM -&gt; convert AST to Erlang source`. This will give you a true representation of what the elixir code ends up as, however it's not "programmer-friendly" as it loses some contextual information. Though you could likely make adjustments to that erlang AST based on some things you could pull from the elixir AST. Here's an example (writing this on my phone so probably will have errors, Erlang's docs for beam_lib give the example code to do this however). [{ _, beam }] = Code.compile_string(elixir_source) # replace this with any method for getting the beam/compiling { :ok, { _, [abstract_code: { _, ast }] } } = :beam_lib.chunks(beam, [:abstract_code]) ast |&gt; :erl_syntax.form_list |&gt; :erl_prettypr.format |&gt; to_string |&gt; IO.puts Going `elixir source -&gt; elixir AST -&gt; Erlang AST -&gt; Erlang source` is the other alternative. However I don't know if this can be done without using private API (elixir module)? Plus you'll end up with the unevaluated code. { :ok, quoted } = Code.string_to_quoted(elixir_source) # replace this with any method for getting the quoted/elixir AST { { _, _, ast }, _, _ } = :elixir.quoted_to_erl(quoted, :elixir.env_for_eval([])) ast |&gt; :erl_syntax.form_list |&gt; :erl_prettypr.format |&gt; to_string |&gt; IO.puts
This only works for Elixir and Erlang, the abstract code isn't present for other BEAM languages.
Yep. And wouldn't work if it was stripped out afterwards either. But this wouldn't be a problem seeing as we have the elixir source that we want to convert. If we were trying to handle BEAM files without any abstract code than you'd need to decompile the instructions in that BEAM file. There are some standard modules to assist with working with BEAM bytecode but there isn't any standard (at least not to my knowledge) decompiler (only a disassembler). So you'd have to build the decompiler part. It's doable but a lot of work. And the resulting Erlang code will likely not be a very good representation of the original input source and won't necessarily be able to be compiled back down to the original bytecode either (assuming the decompiler is going have to handle any kind of bytecode layout, rather than just bytecode from compiled Erlang source). 
I only glanced over it, but I believe your `handle_info` implementation will suffer from a race condition: you are reading a record with `Repo.one`, then running a bit of code, then decrementing based on the value you read before with `Repo.update!` (value which may have changed in database between those two calls). Using a small delay rather than `1_000` and a large enough database pool will help highlight that (you could also add some `sleep` calls). Quick ideas to fix this (because I don't have the code handy), I think you'll want to have a look at: * `inc/dec` in https://hexdocs.pm/ecto/Ecto.Query.html#update/3 * `returning` option to return the `value` (probably)
Hello! (I'm the author of the post). You are correct on your assessment. This was just an example to show parallelism and give some meaning to what was being presented. &amp;#x200B; Thanks for the feedback!
You welcome :-) I just want to make sure nobody will get hurt here! Good post otherwise, and I can definitely relate to what you wrote!
This is great! I'm really looking forward to the whole series.
this is awesome! last week I started a game server project where I'm using Kubernetes/Minikube [https://github.com/Alezrik/game\_services\_umbrella](https://github.com/Alezrik/game_services_umbrella) anxious to see how you approach some things (as I was/am completely new to libcluster/swarm/kubernetes.
Started a game server project [https://github.com/Alezrik/game\_services\_umbrella](https://github.com/Alezrik/game_services_umbrella) while learning libcluster/swarm/kubernetes still building basic functionality but clustering/deployment was the first thing I tackled.
Disclosure: I've been a internet service developer since the Internet went public. I just started learning Elixir, and I find the hype (not meaning it in a negative way) to be exciting. The question is are there real service developers out there reading this using it in a real concurrent massively multi-user environment and does it really stand up to the test? Compared to other mainstream platforms? I keep reading people who know a guy that says it is so. Is that guy actually here and can they give a personal account to it's success?
Discord uses Elixir
Definitely! I personally have worked with Ruby, Java, C++, Python, Go and Elixir over the last 10 years across different projects and companies. To me Elixir brings together the joy of many worlds with little drawbacks. I can vouch for it and tell you that it brings the full oomph of Erlang to the table with the syntax sugar of Ruby or Python and an amazing community. And yes, putting it in production see it handling several thousands of RPMs with little struggle, watching the telemetry never going above 2% CPU and a Memory signature lean and stable and with a really good garbage collector kicking in is awesome! 
Thanks but like I was saying I was looking for personal accounts not third hand referrals.
In addition to quantum, I've also built my own small helper for setting up periodic jobs called [Periodic](https://hexdocs.pm/parent/Periodic.html#content), which is included in the [parent](https://hex.pm/packages/parent) library.
Discord has a techblog with detailed articles about their use of Elixir (and some problems they overcome).
Again, looking for personal accounts. Corporate entities have reasons to not disclose the realities of their technologies. I've seen it first hand many times.
Well it's gonna be hard if you want a single person not attached to a company that have a "massive" project. Anyway maybe something like https://blog.usejournal.com/two-years-of-elixir-at-the-outline-ad671a56c9ce
##r/erlang --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
I just use quantum. It is easy to drop it into your config with cron syntax and then its just as easy to modify or create jobs programmatically. Although if I'm using an interval that does not need to be tied to a minute boundary, I'd probably just use a GenServer with Process.send_after in the init and in the handle_info call to cause it to loop.
Best practice and learning experience to first go with the GenServer route IMO. &amp;#x200B; Here is an older example app that you can use for research - [https://github.com/philcallister/ticker-elixir](https://github.com/philcallister/ticker-elixir)
I'd prefer raw SQL embedded in PHP views to AR to be honest.
This is a great application reference, thank you very much. I'll learn a tone about genserver I think. Quite exciting!
Thank you for your input. That answer on stackoverflow is really easy to understand and will help me discover new aspects of elixir I didn't uncover yet.
Hi, As other answers pointed out, I'll certainly go with option1. I'd rather learn the basics first instead of relying on a library.
Any reasons to explain that preference 
I‚Äôm gonna guess ‚Äúbecause things are at least explicit‚Äù
That‚Äôs not scary! Now a tree of Node dependencies, that‚Äôs what keeps me up at night. Anyway here‚Äôs mine! https://twitter.com/Schrockwell/status/1054038420681641984
Thanks for the explanation!
After getting rid of the custom task, changing my mix.exs and putting the start of my supervisor in the right place I was able to get Tortoise to work last week, thanks for the help.
That is a great approach. A cautionary note: GenServers have a mailbox that is processed sequentially and while the Genserver is working, it's not doing anything else. So if you're after precise execution every N time interval, `Process.send_after` is not quite precise
Would love to listen but the volume is too low to understand.
Is that maybe a directional mic... pointed *away* from the speaker? I dunno mics, but wow the audio is low.
I will ensure that this does not happen again. Sorry for that
lol it's hosted on GitHub wth
XD it's hosted in gitlab too [https://gitlab.com/juanpablo/phoenix\_gitlab\_monitor](https://gitlab.com/juanpablo/phoenix_gitlab_monitor) &amp;#x200B; I chose github because of docker hub is connect with github to autobuild the docker images &amp;#x200B; [https://hub.docker.com/r/juanpabloaj/phoenix\_gitlab\_monitor/](https://hub.docker.com/r/juanpabloaj/phoenix_gitlab_monitor/)
I'm having fun building a stub server, [Stubbex](https://github.com/yawaramin/stubbex). Among other things, it can: - Automatically record and playback stubs - Store stubs in an hierarchical directory layout corresponding to the URL path structure - Template stubs using EEx - Diff stubs against the real responses - Do JSON Schema validation of stub body schemas against real responses I've already written a simple frontend test using it and [Cypress](https://www.cypress.io/) for an app that would otherwise need VPN access to develop; works like a charm.
The biggest issue for ActiveRecord for me is when using includes or scopes on an object and Rails in the background decides to magically add 10 extra joins. This has bitten my company a few times. For example we had a query that would take 3 minutes to run because of three extra joins that Rails added. It returned three records. I got it down to 30 microseconds explicitly writing out the SQL. 
üòò
I think its better to use guard statement [https://hexdocs.pm/elixir/master/guards.html](https://hexdocs.pm/elixir/master/guards.html)
If you're not opposed to regex ( which, this is exactly what it's used for ) you can use: `^\d{2}$` This will match all strings that are two characters long and consist of the numbers 0-9. You don't need to check character values under the hood. The "2" in brackets can be swapped out for whatever length you need, for example, `{2,6}` would return true for any number with a length of 2 to 6, so 00 all the way to 999999. You can test this out in the console with: `Regex.match?( ~r/^\d{2}$/ , "00")` and switch out the string for whatever you want to check. Further reading is here [https://blog.grillwork.io/https-blog-grillwork-io-mastering-elixir-regex-e5b9f46671af](https://blog.grillwork.io/https-blog-grillwork-io-mastering-elixir-regex-e5b9f46671af) and I can try and answer questions if you need.
Yay, that's a good idea. A guard in combination with a regex or the charlist check should work for me. defguard is_string_with_two_numbers?(s), do: s in @allowed_strings examples = ["00", "33", "99", "FO", "9A", "V3"] Enum.each(examples, fn numbers when is_string_with_two_numbers?(numbers) -&gt; IO.puts("#{inspect(numbers)}: Matching") other -&gt; IO.puts("#{inspect(other)}: Not matching") end) Thank you guys!
Probably this: https://youtu.be/6Q9qY_TEteU
London‚Äôs Elixir scene seems to be thriving. Hope to find a job there soon.
Does London companies help with relocation?
We're hiring here, come to mention it! Both Elixir and Erlang Devs, and other roles. We help with relocation. Youc an check them out and apply here: [https://www.erlang-solutions.com/careers/careers.html](https://www.erlang-solutions.com/careers/careers.html) &amp;#x200B; Good luck!
I‚Äôm like 90% of the way towards hopping on this train. I‚Äôm responsible for a smart-city / IoT system, mesh networks connected to gateways connected to our backend. I keep imagining using CRDTs to keep mesh state representations in sync on the gateways and backend servers, but the usual apprehensions about bleeding edge tech scare me off. Anyone have any experience with this?
If you are worried about the maturity of the technology, I'd recommend taking a look: 1) At the tests in delta\_crdt, particularly there are a couple of property tests in delta\_crdt that are fairly comprehensive. 2) The academic papers that describe delta CRDTs (linked from the readme and the documentation). It's a bit dense reading, but it should demonstrate that there is a very solid theoretical backing for delta CRDTs. I wouldn't suggest applying delta CRDTs to your problem unless you are confident you understand them fully enough to be confident that it's going to solve more problems than it creates. If you have any particular questions that I can answer, I'll be keeping an eye on this thread.
FWIW we are looking into making an Ecto adapter. The semantics are different, but both libraries are very idiomatic Elixir, and that makes them more similar than we thought they would be when we started on Gremlex.
The original paper is linked here https://arxiv.org/pdf/1603.01529.pdf. https://github.com/ipfs/research-CRDT/issues/31 this is less intimidating, and gives you a good understanding of them. Delta State CRDTs are sound concepts in of themselves, the only thing you MIGHT have to worry about is how correct this particular implementation is and in that case you could always use Lasps crdt library which is written in Erlang. https://github.com/lasp-lang/types/ Honestly if you're going to use them raw without an existing library handling the anti entropy for you you need to keep track of the last delta group shared between you and a replica, or at each point of synchronization you exchange each others causal contexts, check what operations have been applied or not since then, and then send the diff, or some other propagation method. Essentially, it's useful for when you have a very large data set, and you might be using a UDP based gossip protocol which has size constraints and it's cardinality makes it take longer to merge, it's cost is the fact that you need to be aware of how it works in regards to anti entropy, and the data structure itself takes up more memory. So TLDR unlike say an ORSWOT or ORSET where you don't have to be aware of the underlying VersionVector or Tombstones respectively, you have to be aware of the metadata with Causal CRDTs. 
Thank you for sharing, u/derekkraan. I've been looking for an alternative to lasp/Riak Core and I look forward to reading more carefully about your approach for both DeltaCrdt and Horde. &amp;#x200B; I'm very curious about the details of consistency guarantees of Horde and I'm happy to see \`UniformQuorumDistribution\` mentioned front and centre in the README :D
So I spent a bit of time reading the source. He doesn't mean quorum as in a quorum based replication protocol other wise why use the CRDT's. He means that in the event of partitioning as long as you can contact half of your peers the supervisor can continue and removes the bad pids from the registry. It's eventually consistent. 
I read the source, I have a few nit picks. Number one, in horde make a generic Distributor behavior, your current default one that uses hash(pid) % N is very naive, Leave it up to the users to implement, and add p2c + jmp hash out of the box, before you even give me the I used it so I could dynamically look up the pid, that doesn't work well if there is a lot of churn so you don't even get that advantage. Number 2 in the crdt lib, you synchronize them by treating them all as pids, and periodically calculating deltas and sending them to neighbors, this doesn't scale, like notifying 1000 peers and doing 1000 join decompositions every 5 seconds per crdt, isn't very efficient, I don't even think it's a good idea past 10 if you have a lot of data structures, and this is assuming distributed erlang pools or multiplexes connections. Number 3, this is a relative minor complaint but like I don't like the fact that you are depending on Distributed Erlang to keep your crdt's in sync, and it appears you are forcing it onto the users, distributed Erlang is problematic for large clusters, because it's full mesh every node is connected to every other node, which means the number of connections and the number of nodes they have to monitor is N ^ 2. 
Hi! I know this thread is a bit old, but could you explain a little more about this: &gt; basically you will need run a node server (which run react or vuejs) and from here you make restful calls to your backend Would you do this in the same server (say, a single DigitalOcean droplet) or in two separate servers (two DigitalOcean different droplets)? It would be really helpful if you could explain a little more about the process of developing/hosting an application that uses this structure. If you don't want to type a lot, maybe you could link to some kind of resource (a blog post, a StackOverflow thread, anything) to understand this more in-depth. Thanks!!
Thanks for taking the time to read the code! Sometimes it can be hard to see the forest for the trees after a while so it's good to have feedback. To answer your "nit picks": 1. Users can implement their own distributor and configure Horde to use it. There is no "behaviour" yet, but it is already pluggable (you'll notice that Horde already provides two). The only time using the hash to guess which host a pid is running on is in the time before a new pid has been synced, and that remains useful no matter how much churn you get (otherwise you just have to wait, which is maybe not the worst thing in the world). I will gladly accept pull requests for additional distribution strategies. 2. If you have a cluster of 1000 nodes then you can probably afford to take the time to send me a PR that makes delta\_crdt work nicely with 1000+ nodes. Yes, if you have a lot of churn, you might run into delta\_crdt's limits fairly quickly. Yes, Horde automatically makes every CRDT a neighbour of every other CRDT, which is not efficient beyond a certain number of nodes. 3. I am not forcing anything onto anybody. I am making this library freely available to use. I'm not sure if you think I am shortchanging someone by providing this library? If you can't use distributed Erlang, then you can't use delta\_crdt or horde. If Firenest becomes an option in the future then I'll gladly accept a PR for that. Building a distribution layer is quite far outside of the scope of both horde and delta\_crdt. Horde and DeltaCrdt are not finished, and they are certainly not perfect. But they are improving all the time, especially when I get feedback and bug reports and (especially useful) pull requests, which I will gladly accept and guide to a state where I can merge them. Finally, I have some feedback for you, dear random poster on the internet: be kind. This feedback was not.
RemindMe! 10 days
I will be messaging you on [**2018-11-17 12:36:54 UTC**](http://www.wolframalpha.com/input/?i=2018-11-17 12:36:54 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/elixir/comments/9uyr2p/send_a_talk_proposal_to_elixirconf_eu_2019/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/elixir/comments/9uyr2p/send_a_talk_proposal_to_elixirconf_eu_2019/]%0A%0ARemindMe! 10 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Do you intend to take items off of the queue or just use it as a circular buffer? When I look up circular buffers in particular, I get a few hits that sound like they may be what you're looking for: * [https://github.com/mattsta/cbuf](https://github.com/mattsta/cbuf) * [https://github.com/mdevilliers/ring\_buffer](https://github.com/mdevilliers/ring_buffer)
Ring buffer looks promising. I had thought the queue I was reading about was part of the standard library. (And I just couldn't recall the name) I'm using a list now, with Enum.take() and ignoring what falls off, but there are some special cases I'm interested in. Luke when the queue makes a complete cycle. Thanks! Will check into it when I get back. 
Are you thinking of Stream.cycle/1? https://hexdocs.pm/elixir/Stream.html#cycle/1
New to Elixir, but so far I've found the following to be useful in my Phoenix projects: excoveralls httppoison poison xml\_builder
Nice! Major new features are fun but a nice and easy upgrade is always sweet too.
Nice writeup, thank you. I was looking for a solution similar to this. I'm using absinthe and internally subscribing to mutations which is kind of a workaround, but this is very neat.
Thanks!
Great points! [Learning Elixir](https://reactdom.com/elixir) may well be worth a look!
nope
Yes and no. There are actor model languages that are statically typed like Pony. But the BEAM is kind of it‚Äôs own beast. Process linking and failure isolation were the main design decisions of Erlang and they enforce that unique flavor of actor model which is quite unique. If you wanna stay on the BEAM Alpaca is an Elm inspired language. I‚Äôm not sure if it‚Äôs gradually typed since typing the GenServer interface or any Erlang code is quite difficult. 
There are a couple of experimental ones, this seems to be the farthest along: https://wende.github.io/elchemy/
I'm pretty new too, it's a fun ride. Fast-moving though. Apparently Poison is being replaced with Jason as the default JSON library in Phoenix: https://gist.github.com/chrismccord/bb1f8b136f5a9e4abc0bfc07b832257e#update-your-jason-configuration
Do you use Typespecs? It‚Äôs helped me a lot. https://hexdocs.pm/elixir/typespecs.html
&gt; Dialyzer's fairly weak type system doesn't help its IDE story Although it is worth noting Elixir LS (for Visual Studio Code) is doing an excellent job on this area, given the constraints. 
I think you could change the topic in the EventCenter to the name of the node, that way subscribers and broadcasts could communicate to each other only on that specific node.
That‚Äôs actually really clever. 
timex for dealing with times arc for dealing with user uploads hashids for generating unique ids from strings (useful for user uploaded file names) bamboo for email quantum for scheduling recurring tasks without cron 
Why do I need a video for this...
If you're learning Rust, I highly recommend two resources that complement [The Rust Programming Language](https://doc.rust-lang.org/book/) which I linked above: * [Learning Rust With Entirely Too Many Linked Lists](http://cglab.ca/~abeinges/blah/too-many-lists/book/) is available for free and really helped me understand how to use Rust's pointer types. In goes through some of the most surprisingly difficult problems to solve with Rust (implementing various kinds of linked lists) and describes all the ways that you might make mistakes and how you can recover from them. * [Programming Rust](http://shop.oreilly.com/product/0636920040385.do) is not free but very worth it. It is very thorough and did an excellent job filling in gaps in my understanding on all sorts of topics that I found the free resources didn't cover very well. I've also heard good things about [Rust By Example](https://doc.rust-lang.org/rust-by-example/).
You don't. The mods just don't give a shit about OP spamming these videos constantly.
So this link requires me to create an account to view job description? What's the idea behind this?
To sell your information.
I‚Äôve been thinking this every time I see these videos. 
Why are people bashing content creators? If you don't watch or don't need it, just ignore/downvote/hide and move on. It maybe useful for some people, even for the author to learn elixir/erlang/video editing/speaking/lecturing/whatever. It's not spamming if it's a new fresh video on every post.
Repeatedly posting content from the same source with zero reddit interaction is text book spamming.
Our main stack is Python, we mostly suffered Python's parallelism. 
What are the delivery guarantees for PubSub? If your nose dies between committing the DB transaction and broadcasting to the listeners, the messages are lost?
I'm by no means an expert with Webpack, but here is an example I put together using Phoenix 1.3 with Webpack 4.x: [https://tdug.github.io/coding/2018/07/26/phoenix-webpack.html](https://tdug.github.io/coding/2018/07/26/phoenix-webpack.html)
Django for our monolith and flask for our services.
I was able to read it without signing up, but I stopped reading as soon as I saw it‚Äôs sports betting. 
Most post didn't receive a comment, but there was one reply, so it's just low engagement. Since it seems it's the author himself posting it, I wouldn't be so quick to jump on spam.
Thanks. Keep in mind the Phoenix 1.4 app has Webpack 4.4+ set up already, it's just it's not set up to handle SCSS and a few other things I had in my Webpack 3.x version.
Are the examples apart of your project or an external dependency? And if I'm understanding the problem you're getting non-compatible requirements for a dependency (ecto). If they're your examples then depending on what you want to do, you have some options such as making ecto an optional dependency, change the requirements, or leave it as is and have the project that requires your project override the ecto dependency. If the examples are from an external dependency then you'll have to override the ecto dependency. 
How are messages typed?
Any ballpark figure on the compensation?
Giving up the BEAM for a static type system may not be a good tradeoff. The BEAM manages blocking operations for you in a fair way with optimum CPU usage. On other systems you have to worry a lot more about which process is running on which thread, take care to not block on a running process, and think about when a process bound may get hit and switch to another process. That said, the most well-known actor system outside of Erlang is Akka with Scala. It is a complex beast though and has the problems I mentioned above. It‚Äôs possible to program with Akka in a maintainable way but it doesn‚Äôt come out of the box with OTP-alike modules (GenServer, etc.) so you will have to roll your own with the tools at hand.
Not checking the database could introduce a bug if somehow the cookie gets out of sync with the database and it references a user id of an already deleted user. Your system would have to be designed around that assumption. You need to decide if that is simpler than rejecting an invalid cookie early in the request. I think I would check the database to have a system that‚Äôs easier to reason about. And only change strategy when the cost of the database call becomes an intrinsic problem due to scale. 
Thanks a lot! Switching from python, this is one of the things that kept bugging me
Hey lattenwald! It's in order to create a clear community of developers on our platform so all is needed is to answer a short coding question to get access and view all the positions. Any other questions feel free to let me know. Cheers! Patrick 
I couldn't care less about some platform trying to create a community playing on my desire to take a glance at job description, and of course as most of good developers are believed to be lazy, I would assume they most likely cba to register too. Your platform can only survive on employers' market, not employees'.
Well we currently have over 20,000 users on the platform with around 1,000 signing up every month, so hopefully, the old adage of good developers being lazy is not quite as accurate as some may believe :) If you do ever get round to having a look, any thoughts for our dev team on how we can better the platform would be greatly appreciated!
Concise and clear article. It might be worth mentioning that all uppercase "names" are syntactic sugar for atoms (with the "Elixir" prefix), even if they don't refer to a module.
Ok, I like to give feedbacks. Actually, that's what I am doing right now.
Awesome! Feel free to email me directly at [patrick@functionalworks.com](mailto:patrick@functionalworks.com) with your thoughts. Cheers!
Since we use the Erlang queue for messaging we can rely on it that messages are correctly sent. When a message doesn't arrive it will stay in the queue. After the EventSubscriber is started again the messages in the queue have a destination and get resolved. test "create attempt after subscriber was shutdown" do start_supervised(EventSubscriber) EventSubscriber.terminate(:shutdown, []) :timer.sleep(111) EventCenter.broadcast(:created, attendance, user) EventSubscriber.init(:ok) assert_eventually(Attempt |&gt; Repo.exists?()) stop_supervised(EventSubscriber) end Thanks for your question!
It will likely depend on the level of experience of elixir, but i would say $75.00/hr is ballpark
any updates?
That first tip should be avoided. It has no benefit and if your boolean expressions are expensive to compute it will perform worse than using `or`.
Thanks! I'll add that in for sure
But it is an in-memory queue right? If the beam node (not just a process) dies, the messages are lost. There is no durability.
I took a college course that Dave taught - incredible teacher I‚Äôd recommend this course to anybody looking to pick up elixir
I love his teaching style in Programming Elixir and can only imagine how much better he is in person! I'm also thinking of buying his online course for Elixir but I figured I'll do that after finishing the book.
Having done both I would recommend doing the course first. It's faster so you'll achieve a sense of accomplishment. Then you can take a deeper dive with the book and the ideas will hopefully stick better since you've already been introduced to them. They're both great, though, if you can only pick one. 
Awesome, thanks for the advice!
what. I just looked at the blog post and this is INSANE. I have spents the past year learning the world of containerized applications, build pipelines, and general devops. This blog series looks like the most in depth and practical write up I've seen. I wish there some sort of tip jar.
&gt; This phase of the series is provided purely for educational purposes. Does that mean there'll be another part going over a more "production-quality" way of doing things? I'm a complete Docker/Kubernetes noob but I've always wanted to see how that works with Elixir + Phoenix + Ecto
Yeap! If you look at the Introduction post, linked at the top of this one or [here](https://www.shanesveller.com/blog/2018/10/28/kubernetes-native-phoenix-apps-introduction/), you can see what I've got mapped out for the rest of the series. I've also noted specific topics that are out of scope, at least for this series.
Thanks for the kind words! The positive reception is enough for me, but I appreciate the thought. If you have any questions or constructive criticism, that's very welcome too.
Very interesting, thanks!
&gt;The biggest focus of Horde 0.3.0 has been API parity with Elixir‚Äôs own Registry. This is cool and smart. I like that is can be a "drop in" replacement. 
I, for one, think yes it should be a good thing making statements readable not if you are expecting to understand. =)
&gt; This should be in stdlib reads code... &gt; # not sure if i ever used it, but why not
If you haven‚Äôt found it already - [Designing for Scalability with Erlang/OTP](https://www.oreilly.com/library/view/designing-for-scalability/9781449361556/) 
Thanks!
Episode 8 of the podcast Elixir fountain touched on this - It is titled "Software Architecture panel with Sas Juric &amp; Lance Halverson" One of the things I took away from that was what was said about design patterns, in OOP you have all of these gang of four constructs, in elixir &amp; erlang you have modules. Essentially that the very concepts of functional programming lend themselves to a data driven architecture every time. -- But don't take the above as an attempt at an authoritative statement from me, i'm an elixir enthusiast, but I have not had the opportunity to work with it professionally.
Sorry, I won‚Äôt be removing the quote as I stand by that position as-written. Plenty of people are running surviving and even successful businesses on top of MongoDB and I don't consider that a sound practice either, but I won't be changing their minds. Objectively, DC **by itself** is not capable of providing you with: - self-healing of failed containers - passive correction of configuration drift - safe upgrades to new container images without interrupting service availability - administration without being a locally privileged user on the host directly working on the host, or using an insecure practice and exposing remote docker APIs over the network - administration of more than one host All of these contribute meaningfully to a good high-availability story. So, you are required to band-aid all of these shortcomings with workarounds or extra tools, in order to provide what is considered table stakes for either mature-yet-non-Docker deployments or container orchestration. Most of these issues wind up being addressed with configuration management, remote task automation like Ansible, or network abstractions like health-checking load-balancers. Even then, you still would need to automate workflows around the DC tool to preserve its place in the above concerns, so you may as well cut out the middle man. I'd recommend a pivot to either managing containers directly with Systemd units and config management, or step up to multi-host container orchestration.
Most of what you just wrote are benefits associated to using more than 1 host when it comes to hosting an application. That doesn't really have anything to do with Docker Compose or Kubernetes. It's just a side effect that Kubernetes has mechanisms in place to make distributing an application on multiple hosts easier than trying to roll everything yourself. There's nothing fundamentally broken with Docker Compose that makes running containers unsuitable in production. If you run a container with Compose in production, or with the raw Docker command, both containers are going to be equally as stable on that host. But your sentence that I quoted makes it appear that Docker Compose is fundamentally broken, when it's not.
This is a really solid explanation of contexts that I wish had been available when Phoenix 1.3 came out. Even if you're not doing an umbrella app, you can apply all of this.
Feel free to write and publish a counterpoint that describes the true simplicity of Docker Compose for running your production workloads, and the success you've experienced with that technique. In the meantime, I will continue to recommend against practices that I think are somewhere on the spectrum between insufficient and actively harmful, based on my own experience, and point readers towards preferred solutions. I've been around the Docker ecosystem long enough to remember when `docker-compose` was called [Fig](http://www.fig.sh/), before Docker-the-org acquired the IP. Fig offered a more honest portrayal of its suitable use-cases: &gt; Fast, isolated development environments using Docker. I'm of the firm opinion that the intervening time has not made Docker-Compose a compelling choice for **any** other scenario.
I've read it. To me it was more a regular language book with more detail, didn't see anything on higher level design.
By what interface do you want to monitor the process? The command line? Maybe a web-based interface, like an API or a page? Some options that spring to mind: * Print errors to stdout (`IO.puts`) and just log them * Store errors in the DB that you're already accessing, and just retrieve them with another client * Stick your GenServer into a simple Phoenix app, and spit out errors on the web 
Without seeing code, it's hard to be specific, but it sounds like you need to study / create a Supervisor for your GenServer. https://elixir-lang.org/getting-started/mix-otp/supervisor-and-application.html https://hexdocs.pm/elixir/Supervisor.html#content
Thank you for your answer. I was thinking of CLI access, like a top command. Your first idea is interesting, because some logs could involve connection error to the DB, so if no DB, no logs... &gt;_&lt; A phoenix app will come later, because I'll need a front end to display the data I retrieved...
For stuff like this, where you want manual access to genserver state, I just use the ‚Äîremsh flag in iex. If you call mix run with the ‚Äîsname and ‚Äîcookie flags you can just open a new shell in the running app.
Cool! Can you post the whole function at the bottom?
Lightweight knowledge base website for my service. I might turn it into a SaaS product because it's a small niche. This will be simple and clean. I will be using the following: 1. Elixir 2. Phoenix 3. vuejs 4. postgresql
If you want to see it all, it's in his chord repo https://github.com/pcorey/chord/blob/master/lib/permutation.ex
Yeah, that's a great idea. Thankfully in terms of \`P(n, k)\`, I'm dealing with \`k\` values with a max possible value of \`6\`, which naturally limits things nicely. It might be a good exercise to revisit this and do it with streams, though.
thank you for this and thank you for this great framework. I'm having a lot of fun!
Would like to see Elixir addressing more erlang problems because they bubble up as bigger issues than these things. Take for example the inefficient gossip protocol blocking more than 50-100 nodes from joining a cluster or some of the issues libraries like Horde are addressing. Things like the dynamic supervisor and registry we're steps in the right direction but the momentum in elixir core seems to have died down on that regard.
All clustering relies on the distributed erlang protocol. You can't really address any of those issues without dealing with disterl, and that's something ericksson is probably going to have to figure out.
That was exactly my point. It's not something elixir can fix.
I think there are two issues here: as noted later, this can't be really addressed by Elixir itself. But the other one is that those are very specific issues that do not have general solutions. For example, there were discussions on how even allowing multiple connections between nodes would change Erlang's built-in semantics and that can only be done safely without application domain knowledge. I would have a really hard time advocating anything that showed up over the last years (s-groups, lasp, horde, etc) as part of Erlang because they are also going to come with their own set of problems. That's to say I am really happy with the current state of affairs. I am fine with the expectation I will need to explore other distributed solutions once I get close to 50 nodes, especially because I don't believe there will be a magical solution that just works for everyone. I prefer a wide collection of libraries that explore the different trade-offs in distsys and have the Elixir team continue to focus on issues that will largely benefit the community. 
 Why do you want to see the Elixir team try and tackle something they cannot fix? 
... ish.
They've contributed changes to core Erlang in the past. 
&gt; Only to support or improve Elixir specific features That's not true. They've introduced new features into the Erlang core that are of benefit for the whole ecosystem. For instance one of the more recent changes from earlier this year was EEP48, which standardised how documentation can be stored and how to access it. That change isn't just of benefit to elixir developers, it benefits everyone in the whole Erlang ecosystem. &gt; and never anything to do with distributed Erlang. This is not the Elixir core team's strength, they are more effective working elsewhere. Not sure if they've touched any of the distributed code in the past, but regardless I wasn't proposing they start doing so anyway (at least not for this problem). I agree with what another user said, where Erlang's current distribution model is fine as-is, since trying to come up with one single solution for all use cases is very difficult, whereas at the moment you can improve upon this yourself if you find the in-built one does not meet your specific needs. 
Link is broken.
These docs should get you pointed in the right direction: https://stripe.com/docs/quickstart
Ah! I didn't realise that the stripe validation happens on client side - this way I can push it all to the server and only use the token for a charge if the data inserted is valid! &amp;#x200B; Thanks very much
Absolutely. Just a heads up, never EVER send user credit card information (unless it's something like last 4 digits or what-have-you) or else you will be succeptible to PCI compliance... Which won't be easy...
Gotcha, I knew that part - just had some brain fog and over thought the stripe integration without actually looking a whole lot at stripe! Whoops
A short article I wrote after learning about inets/httpd and using them for a simple HTTP server without having to add any external dependencies to my project.
Located in SF
Hey! You should check out my library https://hex.pm/packages/ex_health It seems like you're doing a little more than ex_health is, but I'm sure it'll be good reference if anything
It's also worth pointing out, when it comes time to set up your payment form on the Phoenix side of things, make sure the credit card field never makes its way to your server. I would go as far as removing the "name" property of the form field in the eex template so that Phoenix doesn't even have a chance to process that field. You don't want a user's card details ever showing up on your server, in the logs or anywhere else. It does mean more work for you if you want to track the last 4 digits which is fine, but it's worth the leg work because breaking PCI compliance is a lot worse.
Eh I don‚Äôt care about storing the 4 digits - the app is supposed to handle very one off payments - thanks for the heads up 
I thought stripe did invoicing too?
Can a user submission ever go from "valid" to "invalid"? If not, wondering if it makes sense to separate these concerns. For example, by validating submissions from users, "staging" or marking only that are ready to be paid. Then all those submissions need is a Stripe payment.
You can configure Stripe to send a direct invoice to users but that's a 1 off thing that only happens on payment. What if someone just wants to see their invoice on your site or update their card info assuming you support 1 click purchases for additional things they might want to buy? You would have to call Stripe's API just to get the last 4 every time you want to display that info which is slow and weird. So to get around that you can store invoice / last 4, etc. info locally and present it whenever and however you want without asking Stripe for more info.
They can yeah I was gonna use a changeset to validate data, so the idea was that if the data didn‚Äôt work I‚Äôd validate that first then make the charge after the data was valid from the changeset. If the data is invalid I‚Äôd send them back and they‚Äôd re-enter the card details. I‚Äôd also include client side validation as a first line of protection so users would know it was wrong before submitting 
I‚Äôve been working on a game for a while, and I‚Äôve finally got something worth showing: [Future Butcher](https://www.futurebutcher.com) It‚Äôs a Phoenix umbrella app that contains an Elixir engine and a web interface that‚Äôs essentially just a GenServer and Phoenix channels. The front end is written in Ember. I don‚Äôt get to work with Elixir, so it‚Äôs been a fun learning experience putting this all together.
Looks neat! However, one of my goals for this particular project was to not add any external dependencies since the application is very simple. 
i'd expect a junior dev to have general familiarity with everything covered in the dave thomas book (Programming Elixir). i wouldn't necessarily expect them to know the ins and outs of the BEAM, or deployments, or popular libraries, but i would expect their fundamentals of the language itself to be solid.
I'm reading Introducing Elixir, what should I know in that book to get this position?
Read Dave Thomas' book on it cover to cover. Then study the functions in the [Enum module](https://hexdocs.pm/elixir/Enum.html), in particular try to understand how pretty much everything in there can be implemented in some way using [reduce](https://hexdocs.pm/elixir/Enum.html#reduce/3). This is a functional paradigm that's just good to understand regardless of language. I'd also study the [List](https://hexdocs.pm/elixir/List.html#content) and [Map](https://hexdocs.pm/elixir/Map.html#content) modules. I'd also try to understand how `[1, 2, 3]` is really just syntactic sugar for `[1 | [2 | [3 | []] ] ]` and why that is.
i haven't read that one so i couldn't tell you... hopefully someone with experience with both books can chime in
Thats a 500 page book. I would expect that he has went through everything [links on the left side] in getting started portion of official docs. https://elixir-lang.org/getting-started/introduction.html This will ensure that the dev can write functions, apps, tests and understand the existing code base.
Maybe its just me, but I think I will hire someone for a Junior position if he/she has went though that docs you mentioned. Thats about it. Assuming you understood what you read.
Is this all really required for a Junior position. I would doubt it. Pattern matching, general map reduce filter, data types, functions, guards should do it. That being said, I wouldn't even ask these. I would just see how good the guy/girl is in reading docs, and problem solving. That's about it. I would rather hire a smart person, and tell them to read the docs.
In my experience junior delevlopers are not hired for their *knowledge* but for their *potential*
As someone that has conducted hundreds (if not over a thousand) technical interviews, let me give you some advice. Elixir Specific: - Know how to use `mix`. If there‚Äôs a hands on coding exercise you don‚Äôt want to be fumbling trying to remember how to bootstrap a project (`mix new`). Also good to know `mix deps.get` / `mix test` / `mix run`. - Get comfortable using `iex`. It looks good during an interview if you can use the interactive repl to explore a problem space a little, be familiar with the `iex` helpers like `v/0,1` `h/1` and `b/1` - Depending on the position, having some idea of what OTP is never hurts. General Interview Stuff: - If you can, think aloud, if you get stuck see if there‚Äôs a way to break the problem down into smaller parts. Lots of candidates, even those that get hired, don‚Äôt finish the problem, but they demonstrate their problem solving skills. - If the interviewer says ‚Äúfeel free to ask questions‚Äù or ‚ÄúI‚Äôm here if you need anything‚Äù actually take them up on it. Read the problem carefully, if there‚Äôs anything ambiguous, clarify it, this shows a good attention to detail. If you get stuck or something isn‚Äôt working correctly, explain what you are trying to do and don‚Äôt hesitate to ask the interviewer for help or if they see something silly you might be missing. The second part is a bit of a tight-rope, if you ask for help when you legitimately need it it can foster a feeling of camaraderie and the interviewer will most likely end up liking the solution better because they had a hand in making it and most everyone loves their own code, if you overuse this technique you can come off as incompetent, so be careful there. - Most interviews end with a part where you get to ask questions, think of these before hand, interviews can be stressful and have a way of making you draw a blank. Good questions to ask an interviewer: - How long have you worked here? :: Easy to answer for the interviewer and gives you better context to evaluate the other answers - What do you do here / what‚Äôs a typical day for you here? :: This shows interest in the person and can give you valuable information about what the company is like, also people love to talk about themselves so the interviewer will likely remember this as a positive interaction - What‚Äôs your most favorite thing about working here / what‚Äôs your least favorite? :: Work best in that order because you don‚Äôt come off as looking for the bad but instead as genuinely trying to gauge the workplace, also can yield red flags. - How does code get from the editor to the cluster (or product if not web based)? :: I‚Äôve found that deployment often tells you a lot about how much of a pain in the ass working somewhere will be. There‚Äôs nothing more morale killing then fixing a bug in 5 minutes and then having to go through some complex, error prone, multi day process to ship it. This question normally does a good job of giving you an idea of how good / bad the tooling you would be using on a day to day basis is. - Little things that impact Quality of Life but can be easy to forget. What hours do most people keep? What source control do you use? What‚Äôs the ratio of coding to not coding for junior engineers? Overall, for a junior engineer role, as others have said, knowledge shouldn‚Äôt really be the primary thing they are gauging. Junior Engineers don‚Äôt have as much knowledge, that‚Äôs why they are junior instead of mid-level or senior or whatever. That means you‚Äôll be primarily evaluated for attitude, intelligence, and drive. Do what you can to highlight those attributes, try not to get flustered, if someone offers you help or provides criticism try to show that you are easy to collaborate with, work hard at the problems even if you don‚Äôt know how to solve them at first, just start saying the things you do know about the problem and start talking about possible approaches, you‚Äôll be surprised how often the interviewer will give you tons of help. One last piece of advice, don‚Äôt try to bluff, for the love of everything BEAM, don‚Äôt try to bluff. It is 1000000x better to say, ‚ÄúI‚Äôm sorry, I‚Äôve never made a bloom filter before and I don‚Äôt really know what one is, I could look it up or maybe you could explain it to me.‚Äù Then to lie and go, ‚Äúyes, a bloom filter, I know that‚Äù and then proceed to make a mess on the whiteboard or in your vim buffer for 30 minutes. One last last piece of advice, be confident and calm, you are on a forum asking about how to do this right which means you are more prepared than 80% of junior candidates. Interviewing kinda sucks, it can be dehumanizing and demoralizing and you might get tripped up and mess something up. It can be really hard to soldier on when you feel like you‚Äôve failed part of the interview, it‚Äôs ok to acknowledge that you struggled to get a grasp on something to the interviewer, it‚Äôs ok to not know something, don‚Äôt let little mistakes ruin the rest of the interview. I wish you the very best of luck.
Well this is amazing üëç
I just want to say that this is super solid advice
Thank you 
Your advice is gold, thank a lot :D
Agreed 
I'll buy his course and his book
You‚Äôre very welcome, I hope you do great in your interview!
Thank you so much. And, could you recommend me some book or courses that I could use to study algorithms? 
One of the most useful modules in the language for day-to-day tasks. Sadly (fortunately?), most of a programmer‚Äôs actual work consists of doing operations over lists of things.
Nice work, the library looks very easy to work with. And kind of perfect timing too since have wanted to test some distributed behaviour in a project I'm currently working on. You mention the library handles copying the current application environment state to the new nodes. When we don't want that behaviour are we able to provide custom configuration to be used instead (if you didn't want the current state to be copied across)? Or will we just have to update the state ourselves after the nodes have been created?
That's a pretty interesting idea; perhaps I can make the configuration configurable (heh), so you can provide a custom one, with the default staying as the current configuration. Is that something you need? You're right though that you can do it manually after nodes have been created, for the time being!
Hey there! Pretty neat library you got here. Congrats on releasing it! --- My first thought was to look at the tests. I didn't see any, so pretty much immediately I'd probably not jump to adopting this in a production app. Personally, I don't want to be worried about marketing jumping down my throat, so if I am going to off-load the work elsewhere, I want to know I can trust it. --- Second, it seems like there are some limitations/forced opinions about how Twitter cards are rendered. In this library, they would always be `summary_large_image`, however the [About Twitter Cards](https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/abouts-cards) documentation shows at least three other options: - [`summary`](https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/summary) - [`player`](https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/player-card) - [`app`](https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/app-card) The `player` and `app` type cards have many more meta tags that can be configured. Also, there seems to be some [universal tags that are generally excluded](https://developer.twitter.com/en/docs/tweets/optimize-with-cards/overview/markup), such as: - `twitter:site:id` - `twitter:site` - `twitter:creator` - etc. &gt; Note: I see the use of `twitter:url`, but I do **not** see that listed in the Twitter docs. It seems that `og:url` is used instead. **TL;DR seems a lot of functionality is missing at the moment.** --- Again, congratulations on releasing the library. I'll be interested in seeing how this project develops. I hope these comments are helpful! Let me know if I can clarify anything.
A lot of similarity in execution to the safe_exec_env library I wrote ... 
&gt; SafeExecEnv provides a safe(r) way to run natively compiled code from a BEAM application I'm not sure I understand. That's completely different to what local-cluster does. 
Both start and manage locally reachable slave nodes which mirror the master node's runtime (code paths, e.g...). The intended use case of each is different, but how they get there looms prettt similar...
&gt; My first thought was to look at the tests. I didn't see any, so pretty much immediately I'd probably not jump to adopting this in a production app. If you look at the code, you'd see it's only a sum total of about 200 lines. If he wrote unit tests for that, I'd be pretty concerned about his own confidence in the code. See also: http://www.rbcs-us.com/documents/Why-Most-Unit-Testing-is-Waste.pdf
Thank you for your really helpful comment, my implements is just a barebone working of [https://metatags.io](https://metatags.io) and I think it would be useful for many people. I will improve the library and follow your recommendations. Really appreciate it :D
&gt; That's a pretty interesting idea; perhaps I can make the configuration configurable (heh), so you can provide a custom one, with the default staying as the current configuration. Is that something you need? For this project it is. Basically my library can be configured with what file paths you want to allow access to on the node. So that's some behaviour I'll be testing. But I'll just change the configuration manually for now. Would be a cool use case if the library supports it in the future though. 
Agree, very nice lib. One use-case I'm thinking of for configurable configuration per slave: I think mnesia data dirs should be different on each slave nodes, and one might want to autostart mnesia on these nodes . Again, thanks for the work @whitfin !
Sorry, I haven't used any general algorithms books before so wouldn't know what to recommend. Though I figure you could probably look at what CS courses would use, I doubt you'll find a book on algorithms in elixir however. Although you might find one on functional programming (not sure if this would be the best approach or not however). For some simple things however. You could look at mimicking the behaviour of functions from the Enum or List library. For instance, say you have the data `[1,2,3,4,5]`, try an implement a function that will add `1` to each element in it so it would end up as `[2,3,4,5,6]`. Then you could try write a function that would remove every odd number, etc. And just try to do hinge like that without using the standard library. As you get more comfortable with the language I think you could just go ahead and build libraries/projects that are of interest to you. 
I was talking to someone at Pinterest and they're not actively using Elixir any more. Stopped last year I believe.
Wait, what? Why??
There's lots of good reasons why not to use a language, it doesn't mean that the reason is political or stupid. Possible reasons could include: - The team decided they preferred $OTHER_LANGUAGE - The team were more productive with $OTHER_LANGUAGE - Elixir wasn't a good fit for their business problem - $OTHER_LANGUAGE has more suitable libraries - Not enough Elixir developers for hire in their area - They found the complexity of adding another language to their tech stack wasn't a good trade off All perfectly valid.
I read that facebook changed their messenger from Erlang to c++. Because they had more expertise with later. https://www.quora.com/When-did-Facebook-switch-away-from-using-Erlang-for-Facebook-Chat-What-was-the-reason-for-it-What-did-they-replace-it-with So yeah. I think its about what the engineers are comfortable with. 
I really want to try Elixir again but I don't feel supported as a developer. The community is small and it's difficult to get project help whereas I can tweet a Node/Mongo question or post in a number of Javascript chatroom and get an answer in 60 seconds. ElixirForums is nice but still takes a bit before people respond :-/
All right, thanks for everything
The docs are very good. Which is what matters I think. Docs are the only help for *any* new/less-popular technology. 
seconded
Yup. Lack of fleshed out libraries, and still a small community unfortunately. :/
I am starting to learn Elixir and am really keen on using as my main backend language. However, there is always this nagging question, of there begin library y to solve problem X. And I was wondering problems did you run into in which Elixir didn't have any library or support?
One thing to watch out for, especially with JavaScript/Node, is the [left-pad problem](https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/). While this property: &gt; I can tweet a Node/Mongo question or post in a number of Javascript chatroom and get an answer in 60 seconds. may be an advantage when you're developing production software on a tight deadline, it's a serious *disadvantage* when you're trying to improve yourself as a programmer.
I did a quick search for Netflix using Erlang or Elixir, seems to turn up nothing?
Phoenix 1.4 app to provide a convenient interface to Helm and Kubernetes deployments in my company's cluster. Just got grpc working to talk to tiller today. I have dreams of using websockets to push updates to the browser and write the frontend in Elm.
lol
Seems I miss the fun part of it üòÄ
I find you can get this in the Elixir slack and IRC channels.
Netflix is very heavily invested in Java and does not use Erlang or Elixir :)
A statically typed language for the Erlang VM Typing of multiple modules is nearly done, need to a make a plugin for rebar3 next. After this I'd like to improve type inference of recursive functions, the ergonomics are not as good as I'd like at the moment. https://github.com/lpil/gleam
Thanks for confirming! OP, would you mind correcting the article? We don't want to play up Erlang/Elixir too much especially without evidence :-)
Unfortunately the curse of a small community :-) But hey look at the bright side, you don't get 60-second answers and are forced to dig deeper, read the docs, the source code, etc.
In my last company when we experimented with Elm and decided it wasn't for us we stopped publicising our use of Elm because we didn't want to mislead potential joiners into thinking they would be using Elm. Doing anything else would be irresponsible of us
A crawl bot to fetch product information from stores. We pay so much for using Diffbot, that it's actually worth putting four Elixir developers on the case for half a year.
Working on the Dialyxir side myself. I wrote the feature that takes the Dialyzer messages, lexes/parses them, converts and pretty prints them to Elixir, then shoves through the Elixir formatter to have readable error messages. Ergonomics is always a challenge. 
If you haven't checked out a recent rc, I highly recommend it. There's even an `--explain` flag that tries to explain the class of error, similar to how Credo does it. https://github.com/jeremyjh/dialyxir/ https://github.com/asummers/erlex/
I'm not really a fan of how Dialyzer works (hence my making a new type system) so I've stopped used it to be honest. Love that someone is working on it though! Wish the same improvements were happening on the Erlang side too.
Fair enough! Best of luck on your project. 
And you!
Hmm true. As I am in a very much initial stage could not share any details. But as soon as I progress I will be able to do it üòÄ. 
In a lot of ways, Elixir as a functional language (with modules just being bags of functions) provides a lot of decoupling. At the least, renaming things is pretty straightforward. As for more in-depth refactoring, seems there are a few resources available (like `xref`): https://elixirforum.com/t/how-to-refactor-elixir-with-confidence/15396/8 https://elixirforum.com/t/renaming-contexts-refactoring/17520
Your refactoring ease comes down to how many weird features you use. For example, like in Java, if you're dynamically invoking methods by string names, you're going to have a bad time. The equivalents in Elixir being defining functions via macros and using `apply/2` or `apply/3`. Additionally, refactoring out of a mess is as hard as that mess was to create in the first place. That's all true irrespective of language, imo. If you use tools like Credo and Dialyxir (and use type specs!!), you'll find that refactoring is usually really pleasant. Bad Elixir looks really bad visually (at least to me), so it's unlikely to get into the codebase in a meaningful capacity if you use good conventions across your team, you'll "see" the weird misbehaved code just by looking at it. If you use things like behaviours and @impls where appropriate, you'll have better compiler messaging when you break something. That all said, we've been maintaining an Elixir app at work for 2.5 years and I don't miss a single thing about Java. I find refactoring extremely straightforward, usually just changing some function pointers, pulling things out to separate functions, inlining, etc. If you make your code easily greppable (ignoring the generated stuff I mentioned earlier wherever it's not strictly needed, as well as not using sub-aliases like `alias Foo.Bar` to make typing `Foo.Bar.Baz.frobnicate/0` be `Bar.Baz.frobnicate/0` -- please don't do that, for all that is holy.) you'll have an easier time refactoring. Also golfing is REALLY fun in this language, so if you like doing that, you'll have a great time. 
&gt; How easy/hard is it to refactor Elixir code? Depends on what you're refactoring. If you're just refactoring the code (keeping the overall architecture and data in/out the same) then it's not much effort at all. If you're doing a larger architectural redesign or you're changing the structure of the data in/out then it can be a larger undertaking. With that said I don't find the experience any worse than other languages and in many cases the transition is a lot smoother because of other guarantees the VM provides you (in most scenarios if you make a mistake your entire application isn't suddenly going to break). &gt; Do pattern matching and guards give you enough help or will I get to situations where I am not going to find things until runtime, like in Python and Ruby? Pattern matching won't prevent you from discovering issues at runtime, rather it'll just inform you that you know with complete certainty that only this structure of data is valid here. Rather to catch issues ahead of runtime you'll want to opt for things like the dialyzer or helper tools like credo. Dialyzer won't be able to catch everything however, but it definitely makes a big difference. With that said, one of the reasons you'll often consider elixir is because of how the Erlang VM handles errors. You'll be designing your architecture around the assumption of how should your system respond of a certain part fails (your supervision tree). If you've architected your application structure well, you can be quite confident (with the exception of crashing the VM itself which there aren't many ways to do that) that if something goes wrong the error will be handled accordingly (though maybe that feature might not work at all until it's fixed) and the rest of your system will still function normally. 
How is this course for a total beginner to FP? (I come from Ruby)
I don‚Äôt mean to come off as a dick, but it might end up that way; there are two red flags I see this question: - planning to refactor - thinking that dynamic languages result in runtime problems *Planning to Refactor* Most of what you hear about refactoring is from a certain kind of consultant or someone interested in selling refactoring tools. Refactoring doesn‚Äôt mean ‚Äúfixing ugly code I shouldn‚Äôt have written in the first place‚Äù. If you read the GoF book, or at least heard a lot about it, you‚Äôll know that the whole process of refactoring centers around learning to identify problems with code ‚Äî ‚Äúcode smells‚Äù ‚Äî and how to go about fixing them. If you‚Äôre able to properly refactor you‚Äôll notice these problems as you‚Äôre writing the code. Despite what certain proponents of Agile methods sometimes say, that never means you should plan to write terrible code the first. You‚Äôll be better off developing the skills to write good code in what ever language you‚Äôre using the first time. *Thinking that Dynamic Languages Result in Runtime Problems* Dynamic languages don‚Äôt cause runtime problems, bad programming causes runtime problems. With the sole excepting of languages with Hindley-Milner type systems, no static language is going to save you from runtime problems. If anything, all that will happen is that you‚Äôll delay finding them since they tend to involve improper memory management, bad casting, or both. All things that are often necessary in static languages but not dynamic. The runtime problems people usually think of ‚Äî passing totally incorrect data types, a bunch of unexpected nulls, etc ‚Äî shouldn‚Äôt happen in practice. Really, if someone writes code where API clients can send arbitrary datatypes to functions/methods that can‚Äôt handle them, that‚Äôs a huge mistake in thinking. The compiler isn‚Äôt supposed to do the thinking. If that happens, there is something badly wrong with the design or its implementation. As for the nulls, this might happen when using a library for the first few times, but it doesn‚Äôt usually happen when you‚Äôre working with libraries you know; add to that the fact that, again, initialization problems happen in static languages all the time. *Back to The Original Question* If you take the above to heart, then all but the worst languages are fine for what you need. Guards and pattern matching are not only fine for this, but for something like compliance they‚Äôre exactly what you want because the business logic can be declaratively written. This makes it extremely easy to verify and test. 
Until Elixir doesn‚Äôt compile to itself, keep learning erlang.
I see your point, but I don‚Äôt see, except the compilation, what Erlang has that Elixir still not have?
Learn Erlang. If you already know Elixir it will be easy, basically just syntax. Why? For one, so you can easily read the many great books about Erlang.
Great hint, do you suggest going far in it or only just being able to understand it? Understanding and mastering a languages are two things
It is not an issue of a feature set. Elixir, erlang, C, asm, x86. You have that many layers of abstraction. Elixir (in that sense) is just a set of macros on the top of the erlang vm. You won‚Äôt write high quality elixir code without knowing erlang std library and it architecture.
But once elixir is compiled, it compiles to Erlang AST such as Erlang too, so basically elixir is on top of BEAM more than on top of Erlang(Language)? If my understanding is good
Yes, but that doesn‚Äôt change a thing that you still need to know Erlang to work efficiently with them. 
No you don't need to learn Erlang. Neither do you need to learn assembly.
All valid but none backed up by any evidence from you. Thus I'm sticking with my belief.
Makes sense, thank you!
I like this thinking but it‚Äôs quite different with Elixir since you may use Erlang libs, you would not use CPU register in C
Erlang is way more valuable to learn than Elixir. Elixir is mostly syntax, with emphasis on metaprogramming abstractions and libraries to make the language feel like Ruby. I wouldn't say if you know Elixir you know Erlang. However, if you know Erlang, then you'll mostly know Elixir, or at least how it works. In fact, most of the Elixir code I encounter from people that don't know Erlang isn't great. It's easy to pick up bad habits and patterns in Elixir because you're not forced to deal with how Erlang really works. You're put lengths away from the proper abstractions if you adopt things like the Enum module. But the bearing in the community is to use these tools, so in the end, Elixir devs tend not to be capable of casually writing recursive methods like one normally would in this paradigm. TL;DR Learn Erlang if you want more foundational knowledge and if you want to develop more hygienic habits around the BEAM
This analogy isn't even remotely close
This. Basically you're writing in a DSL with Elixir. It's not about the compiled code (you're not a compiler so it shouldn't matter), but rather how you learn to write the code before compilation. How many DSLs have you learned where it gave you knowledge about the underlying language? For me, none (I think).
This. Basically you're writing in a DSL with Elixir. It's not about the compiled code (you're not a compiler so it shouldn't matter), but rather how you learn to write the code before compilation. How many DSLs have you learned where it gave you knowledge about the underlying language? For me, none (I think).
I'd say unless you're writing code that's explicitly using some BEAM-specific things (GenServers, Agents, Supervisors, etc) then I'd stick to probably just reading about the built-in Erlang standard library. Things like `:etc` or `:crypto` or nice to learn about and they're Erlang modules. I'd also read up a little on the syntax so you can grok the Erlang documentation. But as far as learning everything about Erlang syntactically? Nah, probably not worth as much as just going through Erlang's libraries and maybe poking around the source code. Once you know the ins-and-outs of Elixir's syntax and what it's doing on a technical level then you can pick up on Erlang syntax really easily most likely.
I think this video would have benefitted from a few more takes and some more time spend in editing.
How is your experience with Absinthe/Phoenix thus far? I've heard that Absinthe/Phoenix is pretty good for a GraphQL-based backend
The equivalent there would be writing the BEAM assembly/bytecode yourself. Erlang isn't even a low level language for the BEAM. It is still very equivalent to Elixir or other languages in the ecosystem. A closer comparison would be comparing Erlang to Java (the original languages for their respective VMs). Anyway to answer OPs question you don't need to know Erlang, but as you'll be working with a number of Erlang libraries, it'll be worthwhile at least knowing how to read Erlang code. Writing Erlang code most likely won't be needed because Elixir can call any Erlang functions. The only times I can think where you might is if you're using a library that expects you to use its Erlang macros (unless you want to port it to Elixir), or you want to contribute to an Erlang library. 
You can and at times will. C has the `register` keyword, and compilers often provide extensions for you to even inform the compiler which register you explicitly want it to be stored in. Then there's also compiler extensions for embedding assembly code within C too. The latter is used quite often too (I'd say more often than the register keyword nowadays), since you may need to use some CPU feature that isn't exposed to C, or if you've ever done any optimisation work in C then you'll know that it's missing SIMD/vector types (there are compiler extensions to add those types but the code generated by them is often subpar to what you can write yourself) in which case you'll usually opt for something like the intrinsics library (which are either inline functions or macros wrapped around some embedded assembly code). 
Not the OP but I've used absinthe in a number of projects before, and I highly recommend it. If you want to have a GraphQL endpoint then absinthe is a great option, it's a very mature GraphQL engine (even compared to engines in other languages). There's also a number of plugins for the absinthe ecosystem if you're desiring things like plug, relay, apollo, etc. If your application is only going to have a GraphQL endpoint and nothing else than Phoenix is less useful. You can still use it just to save time setting up some things, but aside from that you won't be using much from Phoenix (a great thing about Phoenix though is you can easily remove what you don't want). 
Damn you for having arguments ahah You‚Äôre dead right my comparison was sh*t
Fantastic, the schema definition and resolver setup is so intuitive and guides you through to the correct implementation. I feel like they really asked, what's the very essence of a GraphQL server, and exposed a DSL to let me implement that. I also just found out about `Absinthe.Resolution.project` which lets me check (during resolution) if the current query contains some fields, and dynamically modify my answer based on that. The power is there when you need it!
Mastering them will be very similar. My advice is pick the one you identify with the most and with time you will naturally master the most important concepts. Once you grasp pattern matching, recursion, processes, supervisors, crossing the Erlang/Elixir bridge will be relatively straight-forward.
No chance of your comment coming off harsh, thanks for the insight! Refactors are a fact of life. I am writing a system that is supposed to live for quite a few years. No, I am not gonna refactor to make things pretty, working and debugged code is much, much better than pretty code, but I am 100% sure that I will get things wrong and have to rewrite parts of the system. That is not even counting that I am not an Elixir expert, I will also make newbie mistakes and write rubbish code. Dynamic languages are not the cause of runtime errors, they just make some things harder to find until runtime. When your data is strictly structured, some types of errors (not all, probably not even most) are simply impossible. Statically typed languages provide that structure. As with everything, it is a trade-off. For 10 years I run my own business on a homemade web framework. On PHP. At the time, I thought my code was not great because I: 1. Did not use OOP for everything; to me, a lot of things make more sense as stand-alone functions that as methods 2. Used simple hashes and arrays of hashes instead of classes 3. Went out of my way to make my functions take different types of arguments (an array or a scalar, with a check to convert to the right thing at the beginning of the function). 4. Avoided mutation as much as possible, copying arrays instead of passing references, returning copies 5. I purposely did not try to recover when things failed 6. Validated and formatted all input to my system at the edges - at that point, I assumed that the format of the data was correct By doing this, I managed to provide a SaaS business, offering 24/7 support, while having a full-time job. When I started looking at Elixir (and Clojure), I recognised some of those patterns and then read about Phoenix, which seems to be the right level of framework for me, so I am very interested in it (back in the day, I tried Erlang for web dev but it just wasn't ready - Erlyweb anyone?). All I am trying to do at this point, is to understand how difficult it is to refactor Elixir code. Refactoring/extending my PHP was mostly OK. Refactoring Ruby is much, much harder, specially Rails code. Refactoring Elixir seems to be easier - I just don't know because I don't understand the language or the libraries/frameworks enough. Sorry if I have gone off on a tangent - all I want to say Elixir seems to tick all the boxes but I want to know how hard will I have to work to reshuffle/refactor/extend/redesign things later because I am making a long term decision. &amp;#x200B;
Have you tried asking your question on https://elixirforum.com/ ? There's lot of good help over there.
Seems a bug in Postgres to me. `5.0` is stored as a `float` but `5.0e3` as an `integer`? Why should `5.0e3` be an `integer` but `5.0` a float? Seems inconsistent.
Where does it says that Netflix is using Elixir? Aren't they partnering with Dockyard to do a kind of studio software? and doesn't Dockyard also writes RoR?
You're very much learning Erlang anyway by learning Elixir; the only difference between the two is basically syntax and a couple of bonuses in the Elixir standard library (most of which wraps existing Erlang functions). You will find that if you learn Elixir "fully", you'll automatically be able to understand most Erlang code. There are some semantic differences but the overall structure is usually very similar, if you get past the symbols being used. Although you might learn Elixir, there are *LOADS* of times you will use Erlang libraries and/or functions, so you'll even be familiar with many parts of the Erlang standard library over time.
Elixir and Erlang have strong types, however they do not have static types. There is huge difference between these two terms. 
I thought Dockyard only did Elixir these days.
I enjoyed it, but the team didn't take to it well.
Yes this video should have talked about this distinction. Upgrades are not a primary reason. It has more to do with typing across nodes can't be enforced yet messages can be passed.
Sorry to make you so upset over your beloved. I've learned Erlang along with Elixir. Not because I've "been around for longer". I've found it incredibly valuable to do this, and when I work with peers who don't have such experience, I can pick up on things they don't understand. It's incredibly easy to not understand important things in BEAM when you only know Elixir (and you're not looking at the source code). Just trying to answer OPs question. No need to try to convince me that Erlang is no good. I'll keep writing my software that will still work after 20 years
Just finished the Elixir &amp; Phoenix course on Udemy by Stephen Grider - it was great. &amp;#x200B; Now I'm building my first real Elixir/Phoenix CRUD app - a job board with a few twists. I'm hoping to add some Stripe integration to it too if the ideas I have for it make it worth paying for! &amp;#x200B; Overall super easy to get going with - Phoenix is super productive to work with. Changesets and Ecto make all the data modeling and querying a breeze (after I got used to some error messages trying to do many\_to\_many relationships).
&gt; No need to try to convince me that Erlang is no good. You should read my reply again because you clearly misunderstood my points. I haven't tried to convince you that Erlang is no good. Erlang is totally fine. As is Elixir. My points are: 1. You claimed that the `Enum` module in Elixir is not the "proper abstraction". Except the abstraction Elixir provides are common place in the huge majority of functional programming languages. 2. You said that Elixir emphasis is on Ruby-like libraries. I provided widely known counter-examples. In fact, you made no attempt to comment on the points above, resuming to a snark "Sorry to make you so upset over your beloved" and more personal anecdotes. I don't doubt learning Erlang made you a better programmer, but it seems you are incapable of explaining why.
Any plans to bring it into the nerves fold for tooling? I don't know how much overlap there would be though
Nice, keep up the good work!
In languages like Objective-C that type of flexible call passing a message usually uses dictionaries and array structures and that works too. Usually you really want a message to conform to some kind of protocol before you can use it yes or yes, if not you can leave it at that.
Which books can you recommend?
What kinds of peripherals does the ESP32 support? eg: temperature / moisture sensors, etc. I didn‚Äôt find much on the site. 
The rule of thumb I have made for myself recently has been to use if/else if I'm working with only two possible outcomes. For everything else, case and cond. Typically case is preferred because it essentially limits you to working with one thing. My experience has been that if I'm using a cond do, I'm trying to do too much in the code. This is my off the cuff answer. I'm going to go back through some of my recent work and work of others and see how they've been using it. 
More than 80% I use `case` or short functions with pattern match with expected values. Life is not simple so in many cases return value is a tuple not boolean. 
Whoever sold Elixir as "mostly syntax" to you did a poor job. Here is a talk on "What Elixir is about": https://www.youtube.com/watch?v=Lqo9-pQuRKE Also the reason why Erlang wouldn't be extended is because Erlang changes slowly and rarely, which most in the Erlang community would agree as a good thing. If you try to change Erlang, the most likely answer will be no. I recommend you to read the erlang-questions mailing list to get a grasp on how most suggestions have gone over the years. Finally, if you believe creating a programming language makes sense from a business perspective to software consultancy, you are delusional. Programming languages are long term investments and most of them never get wide adoption, which means they are also high risk. For a consultancy, the most profitable would probably to ride the coattails of a growing language (like Kotlin is a great investment right now). At this point it is clear you have no idea what you are talking about. You have a poor grasp on Erlang's history, on Elixir raisons d'√™tre and on running consultancies. Good riddance. 
I joke that while I am in my editor thinking about what to write, I just type `case` to save time. It generally ends up being the right thing. In Erlang, `if` is mostly useless, and case works fine. If the case has two choices and is about booleans, then `if/else` is cleaner. `cond` is for special cases where it fits. In practice, I find that I don't use `with` as much as straight matching on results, as well, as it gives better error information when it fails. This is part of the "let it crash" philosophy. You should also use functions and head matching. It is a valuable tool which doesn't exist in other languages, and takes some getting used to. I would almost put it above `if` in usefulness. It avoids deep nesting of logic and excess variable manipulation. This style is quite interesting to study: http://www.gar1t.com/blog/solving-embarrassingly-obvious-problems-in-erlang.html It is a bit excessive, but pays off in clarity and makes some testing unnecessary. You can basically assert that you have correct parameters, like in "design by contract".
Sometimes when I am wondering whether I should use \`if\` or \`case\`, I remember that \`if\` is just a macro that compiles down to \`case\` anyways. [https://github.com/elixir-lang/elixir/blob/29d775dfa79d528c3eaf53b22370d96b34e07545/lib/elixir/lib/kernel.ex#L2995](https://github.com/elixir-lang/elixir/blob/29d775dfa79d528c3eaf53b22370d96b34e07545/lib/elixir/lib/kernel.ex#L2995)
if I'm using a `case` on a parameter of a function without any transformation (like a `trim`), I usually put the shape (map, tuple) in the function head). Of course I don't give up my judgement, and if it looks reaaally weird, I use something else.
Learn you some Erlang for great good is actually pretty solid. It is super easy to read and it covers OTP which is great for both languages. Also it's free! https://learnyousomeerlang.com/
Thanks!
&amp;#x200B; |The other big deal is if something breaks like a bad request to your webserver - Elixir + Phoenix will keep chugging a long because the failure is isolated. So you get the development experience *and* your boss doesn't call you in the middle of the night to troubleshoot the downed app. &amp;#x200B; Should be obvious but stating to make it clear none the less, if that failure happens to be in a portion of code that is poorly designed (relies on in memory state that does not have a persisted and loadable state init for instance) that quick to fail can also be painful. well painful at least until you start to design the code to respect the quick to fail paradigm. 
Isn't this effectively solved by ETS?
DETS uses a hash table layout for the files, and mnesia with disc_copies uses log-based transactions for storage to disc with a full copy in memory ala redis.
There are a lot of decaffeinated brands on the market that are just as tasty as the real thing.
Indeed. Used them in the past in projects, but afaik it is a newer approach than what was common when the relevant OTP bits were written. When your app needs that sort of performance, it defo makes sense to do so. There are nice erlang implementations like leveld and bitcask that, as you noted in you blog entry, fit that bill nicely. Also pair up well with riak_core ...
This is fantastic thank you for sharing
I am working on an open-source push service/client that can provide server-&gt;browser socket pushes. &amp;#x200B; This is really just a layer over Phoenix sockets, but providing an interface that is very very fast to get started, built for scale, and has best practices integrated.
I have not for Erlang, is there one you could recommend? Thanks, Dana
But checking selector implementation or protocol conformance requires runtime introspection, bidirectional between the calling object and the target, essentially guaranteed to be successful on a single process/node, and the BEAM vm is fairly well architected on the entire notion that no message/node/process is ever guaranteed to even exist at all, let alone allow be long lived enough to temporally to introspect its abilities.
Close to the end of the article they mention it: &gt;We are also working with our partners to provide more open source runtimes: &gt; &gt;Erlang (Alert Logic) &gt;Elixir (Alert Logic)
Archives aren't the same as project dependencies. Archives are essentially global application installations you can access them from anywhere. So with regards to Phoenix, what you're installing as the archive is actually the tools so you can utilise it without having to be inside a project that has a Phoenix dependency (e.g. if you want to create a new project using the Phoenix template). Knowing that, you actually can create an ordinary project and add Phoenix as a dependency like you would most other dependencies (you'll just have to manually setup the pieces you want to use). 
Okay, this makes sense, thanks for the answer! Another small question then, can I manage several archive versions? For example, I want to keep an archive of version 1.3 and 1.4, for whatever reason. So, I can boilerplate projects with 1.3 or 1.4 versions of Phoenix. Is that possible? 
why would anyone in the world need this thing in presence of godlike nginx and a few tons of supervisors of any kind.
Wonderful! It's not the best environment for Erlang/Elixir and I don't think we'll be hosting web services with it, but this is great for little scripts and background processing. Looking forward to not having to use Javascript here :)
I am a complete newbie in Elixir and Erlang but am I right in saying that they don't make too much sense with something like AWS Lambda as Elixir/Erlang are particularly well suited to many potentially long running concurrent processes that communicate with each other? Though something similar could be said about Node.js being supported on Lambda which is itself suited to multiple concurrent IO calls
You are not wrong, but elixir is not terrible acting as a scripting language as well. If someone feels most comfortable writing lightweight tasks suitable for aws lambda in elixir, then why the hell not! Everything that makes things easier for elixir developers is very welcome in my books :)
This isn't a super "popular" opinion (and I don't advocate it btw!), maybe a form of taboo I think :-) Yet browsing through the elixir forum, the online tutorials, or even looking at the Heroku buildpack, one can see that some people are picking different deployment choices &amp; running phx.server directly on the server or container. &amp;#x200B;
I haven‚Äôt used lambda for anything yet, but I can totally see use cases... Has anyone tried it with elixir yet? What happens if you spawn processes? If it lets you spawn processes until you hit a processing limit then elixir might have a great future in this environment.
I haven't tried yet. No idea what happens, but I checked the limits doc here: [https://docs.aws.amazon.com/lambda/latest/dg/limits.html](https://docs.aws.amazon.com/lambda/latest/dg/limits.html) This mentions "Execution processes/threads -&gt; 1024" ; yet I have no idea if their implementation actually monitors the number of Elixir processes in a way or another, nor how the Alert Logic bundle behaves with regard to CPU etc... To be tried out!
doesn't seem like any reason that it would? given that elixir processes aren't native processes or threads?
&gt; I‚Äôm not kidding Chris.
&gt; There is huge difference between these two terms. And yet we *still* see dynamic mislabled as ‚Äúweak typing‚Äù. Even in published books by people who otherwise know what they‚Äôre talknig about. The hangover from C hasn‚Äôt worn off yet. Which is hilarious since C has some of the weakest static typing there is. What‚Äôs strange about this video is that where he says ‚Äústrong typing‚Äù he‚Äôs not just talking about strong type systems, he‚Äôs talking about type systems like Hindley-Milner which are both strong, incredibly expressive, and can do a bunch of correctness checking. H-M aside, you can do a decent job of explaining typing with four lines: - Static/Strong ‚Äî Haskell - Static/Weak ‚Äî C - Dynamic/Strong ‚Äî Python - Dynamic/Weak ‚Äî Perl
I don't believe so, whenever you install it will replace the previous one and they can only be referenced by name. Although you could setup different archive installation directories. And then you could switch between which one to use (it references the path from the environment variable `MIX_ARCHIVES`). 
It's pretty common to process a batch of items within a single lambda invocation. This is because startup times and the pricing structure make it much faster and cheaper in some cases to have one lambda invocation processing 1000 records, than to have 1000 lambda functions running. So I can see elixir being useful in that regard. 
GitHub links: https://github.com/alertlogic/erllambda https://github.com/alertlogic/erllambda_elixir_example https://github.com/alertlogic/mix_erllambda 
I'm curious to see if Elixir's strengths can be utilized here. Lambda will spin up an EC2 instance for you to process your lambda requests, and then further requests will go through that instance up until a point where they spin up another instance. IIF the same beam process is used, you'd be able to put transient data (like a cache) to be used by subsequent requests. Also, if your lambda is in your VPC and you use something like libcluster, there's a good chance you'll be able to contact processes within your Auto Scaling Group. I'd be curious to see examples of this kind of testing when it's available. I think Elixir may be better suited for lambda than other people think.
Is the video for this posted anywhere?
I've found I want pattern matching on most minimal when-like-this-do sort of scripts that Lambda is simple at. This could be a good MVP tool.
Do people ever use these slides without having seen the accompanying video? Because I see slides posted a lot without the video and I have no idea how such a thing is useful. Sometimes I click through them thinking that they somehow will be, and they never are.
Lambdas are sandboxed, this won't be possible I don't think. If you want to autoscale and run clusters, you can just use regular ec2 instances.
If anyone gets started with this it would make a great blog post. I‚Äôd really like learn some AWS
The plan is to get some good tooling, I don't have yet idea if the tooling would be based on the nerves one or it will mimic it. It is still an open topic, but indeed having some good tooling is a must.
ESP32 has GPIOs, SPI, I2C, etc... so you can easily connect a lot of stuff. Right now my home thermostat is an ESP32 with a DHT22 sensor connected to a relay. All the control logic is implemented in Erlang and runs on AtomVM.
Glad you like it, there is still a lot of work to do, but it is making progress every day.
Hmm maybe you're right... I'd be curious to know if anyone has tried this. Being in the same VPC you'd think you would be able to make a connection just fine. And as for making cache processes, the only way to stop this is to spin up a different beam process which isn't very efficient.
Nice. Do you have the control logic open sourced?
Not yet, but I will write an how-to soon :)
Elixir is a functional language, built up of functions that are in modules. Because there is no global state in Elixir, it is trivial to move code around inside of a project, or move stuff out into separate libraries entirely. So yes, your usecase is very much supported by Elixir (and thus, by Phoenix)
Late reply, but fair point and I learned something new :)
AFAIK there isn't CSS modules built into templates
http://blog.plataformatec.com.br/2018/05/nested-layouts-with-phoenix/ Might be worth looking at.
&gt;and I feel like the momentum is shifting away from it, and more back towards backend, just because of the complexity of applications This is why the shift from backend to SPAs occurred, not the other way around. Setting up and starting a web pack app is no small feat, true, but it's a one time cost and the maintenance is much lower than if you had started out with a server rendered app (with most widely available tooling today). &gt;I think stuff like turbolinks and such is the future of web apps. Actually it's the past. SPA frameworks have predominantly replaced usage of turbolinks in most cases because some application state still resided on the front end (which things are shown/hidden etc.) and there was never a good mechanism for managing that state or syncing it with the backend. With SPAs that problem is solved by keeping the state local. The issue is the state and the rendering have to be in the same spot or it adds lots of complexity in keeping the rendering side sync'd. Google for Phoenix LiveView, it's a project by the Phoenix team that is trying to turn the trend back to the backend again by keeping the state and the rendering on the backend and syncing them up with Phoenix channels. The benefit is that the initial render is still the same but the rest is done with DOM diffing by sending state changes to the backend and html fragments back. 
I definitely recommend everyone to participate. On the next day, starting tomorrow, I will also live stream as I work on the exercises, and discuss different approaches, solutions, etc. More info here: http://blog.plataformatec.com.br/2018/11/lets-learn-elixir-together-with-advent-of-code/
Is there a place to see how people implemented the solutions in different languages?
Not officially, people share their solutions if they want to, usually in GitHub, but you just have to search around.
[This post](https://blog.danielberkompas.com/2017/01/17/reusable-templates-in-phoenix/) lays out a very nice, simple way to structure Phoenix template partials as reusable components. As far as css, you‚Äôll have to roll your own or just inline styles on your ‚Äúcomponent‚Äù template partials. That being said, I think /u/mgwidmann hit the nail on the head about SPAs vs multi page server rendered apps (like with Phoenix), especially for frontend apps of sufficient complexity. If you have business logic on backend and sufficiently complicated layout logic on your frontend, I‚Äôd say its a good pattern to decouple them. While Phoenix LiveViews are a compelling way to offer interactivity from a multi page server rendered app, I think you might find some much more interesting ideas about cleaning up complicated state and logic on your frontend by looking into [elm](https://elm-lang.org/), a functional frontend language and architecture that actually provided some inspiration for Redux in the React world (iirc). Elm and Elixir (especially via Phoenix) make a very good combination for larger apps that demand a lot from their interfaces. Elm has some great ideas around scoped CSS and styling like youre used to in React, as well as libraries like [elm-ui](https://package.elm-lang.org/packages/mdgriffith/elm-ui/latest/) that try to subvert HTML and CSS for application layout, entirely.
Cool. Thanks for the reminder. I just whipped up [my solution](https://github.com/trbngr/advent_of_code_2018/blob/master/lib/day_1/chronal_calibration.ex) as well. &amp;#x200B; &amp;#x200B;
I see that you used a Map for the cumulative results, you probably want to see about the [MapSet datastructure](https://hexdocs.pm/elixir/MapSet.html) :)
Dude. Thanks! I haven't run into that bad boy yet. 
There's a megathread of solutions on r/adventofcode every day: [https://www.reddit.com/r/adventofcode/comments/a20646/2018\_day\_1\_solutions/](https://www.reddit.com/r/adventofcode/comments/a20646/2018_day_1_solutions/)
Thanks for sharing that!
Lol just did this in elixir as well and the result is scarily similar. 
It was my first use of elixir beyond Fizz Buzz. Got both steps solved, but not happy with my solution for step 2, which is ridiculously inefficient. I'll revisit it a bit later. 
Also, for people who haven't seen it, Jose Valim is solving the puzzles himself the next day, live on Twitch. Here's him doing Day One: [https://www.twitch.tv/videos/343661380](https://www.twitch.tv/videos/343661380)
Is my rust code so bad or my Elixir code so good or is Elixir a beast at lists? On my iMac the elixir version runs in ~13s and the Rust one in 7m 14s
404?
Did you use Map or MapSet to keep track of the seen frequencies? See that OP changed it after initially posting and said it significantly increased performance.
I used MapSet, as per the docs. At first I did it with lists where performance was awful then realized there was a better data structure for this. I'm not saying the performance is terrible compared to node, but there this is completed in ~30ms, vs ~140ms in elixir. Not that it matters, really. Completely different languages and all that. 
Elixir and Phoenix are providing the solid backbone of PushEx and help to make it great. To that end, I want to invite the community to ask any questions they have on the PushEx project so that they may have some of their challenges solved. Please feel free to ask **any** question on the [PushEx Issue Tracker](https://github.com/pushex-project/pushex/issues) regarding any code or ideas in the project. I will personally read and answer each one to help provide back to the community. &amp;#x200B; You can also ask any questions here and I'll respond back!
Thanks for posting. I'd have two questions, that where not really clear for me from the docs: &amp;#x200B; What does PushEx provide above Phoenix/Channels? How would i integrate PushEx into an existing project?
If I were to just use Phoenix channels, what sort of problems would I have that PushEx would solve?
Great question regarding this vs plain old channels. The biggest thing that you'll benefit from with a system like PushEx is a system that is designed for scalability for day one, as well as a vetted client that handles this use case perfectly. When I first started rolling out my push server, using vanilla Phoenix in a project, everything seemed to work well at first but slowly unraveled performance wise over time. How Presence is handled, channel hibernation (now easier to do), and how distribution is handled all effect the system. The goal is you don't have to worry about any of this. The client side gives big benefits as well. You won't have problems that certainly exist with the vanilla client. I have brought down production by having out of control sockets while following all instructions. Turned out to have been a bug, but this is vetted against those issues.
I'm going to refer your first question to my top level comment in this thread because I answered it for another user. It is possible to do by defining the socket in your Endpoint and routes in your router. However, I have held off on writing the guide for it because I don't believe that people are set up for the most success by having it in their project. Particularly servers that deploy often shouldn't be in charge of the push sockets. Guide will be incoming soon on that, though üòÄ
I've seen people start their apps like this and then come to regret it when compilation of elixir + assets begins to take more than 60s. We should encourage the best practices because they tend to work out best in most situations.
We're also doing the advent of code in Elixir! [https://codesync.global/media/advent-of-code-2018-day-1-elixir/](https://codesync.global/media/advent-of-code-2018-day-1-elixir/)
Can you expand on the details of the issues you encountered? I think PushEx is a \*fantastic\* fit for use cases where you have existing pusher.js based clients. Otherwise, the performance and phoenix.js client concerns need more detail than merely claiming they "slowly unravel" ‚Äì especially given that PushEx is built on top of channels and the phoenix.js client :)
Sure thing, Chris. Some of the defaults are not very memory friendly and require a level of knowledge about how memory allocation works in Elixir to avoid problems with. Hibernating channels helps a lot with this, but is something most new people would not bring into their Elixir setup. A blog post covering some of the memory challenges was documented at [https://stephenbussey.com/2018/05/09/elixir-memory-not-quite-free.html](https://stephenbussey.com/2018/05/09/elixir-memory-not-quite-free.html) (pre-hibernate, though). Another example of something that will prove headaches in the future is Presence (as mentioned in the blog post). It's a fantastic tool and PushEx takes advantage of it. However, you don't need to broadcast messages to your channels unless you are wanting to send the presence info back down to clients (which PushEx explicitly doesn't do). The default way of handling this is not scalable and a good solution is not present in the current system. PushEx uses a hack (redefinition warning) in order to avoid the problem without re-inventing the Socket module functionality. You \*will\* encounter scaling issues with Presence if you have a global channel like \`app\` that everyone connects to. It's just a matter of when / how often. PushEx is actually not a pusher.js compatible server, because I don't believe that Pusher is the best way to structure your setup and I don't feel endebted to its API at all. Particularly the \`auth\` HTTP call can be fairly inefficient and have large throughput depending on your user base.
I messaged you on slack, as well. It may be most effective to discuss these ideas in a public or private slack message for maximal clarification opportunities.
What libraries are you after? :)
I have updated the README to better compare PushEx to Phoenix, as there have been a few questions regarding that!
I have it working with [serverless.com](https://serverless.com), I can definitely post it somewhere if interested...
I really wish you the best with this project. language looks like it will be a great fit for me! Almost like a less noisy rust! Cant wait til its done!
There's also the Elixir Forum post: https://elixirforum.com/t/advent-of-code-2018/18388