what about on the client? Imo a more robust solution is to (outlined here: https://elixirforum.com/t/proper-way-to-close-channel-from-the-server-side/10955 ) : in your service code `MyApp.Endpoint.broadcast("topic", "end_session", %{})` Then in the channel push an end session message to the client and terminate on the server by returning a :stop ` def handle_info("end_session", _params, socket) do Logger.debug("Ending session...") push socket, "end_session", %{} {:stop, :normal, socket} end` on the client: ` channel.on("end_session", payload =&gt; { console.log("terminating session") channel.leave() }) channel.onClose( () =&gt; console.log("channel has been closed") ) `
I replaced the Enum.sum with an Enum.reduce and got better performance. I'm not sure why, but replacing the range 0..9 with the explicit [0,1,2,3,4,5,6,7,8,9] also improved the performance. It's still about 5x slower than I expected. But, really, this is a case where I believe an array is the superior solution, so Elixir may just be the wrong tool for this particular task. https://github.com/octonion/puzzles/blob/master/blackjack/elixir/outcomes2.ex
Looks like this code is reliant on the client receiving the disconnection message and handling it correctly? That unfortunately leaves the information leak open as the user could theoretically block such a message.
See here: https://elixirforum.com/t/closing-a-socket-when-user-is-removed-from-system/6118/3
This kind of library doesn't exist in the current eco-system but it seems possible to call some python (pyephem) from elixir: https://hackernoon.com/calling-python-from-elixir-erlport-vs-thrift-be75073b6536
Elixir isn‚Äôt good solution for CPU heavy computing. It is rather for IO heavy computing, where processes are short lived tasks. In your case I would make server in Python that would be connected to Elixir application which would handle IO, caching, etc. and your old application would handle heavy computing as it is doing now. 
I‚Äôve got some calculations in my satelliteEx library. It‚Äôs not specifically a generic library for these calculations but it may have something you can use. https://github.com/Matt-Hornsby/satelliteEx
Thanks a lot! One function won't cut it, sadly (because of date conversions and such), but I think that's the way I'll go. 
Too bad. I really would like to have some kind of list to work on. Some kind of ladder, which i can climb. I can write my first Programms in Elixir but as usual I am not able to get everything and my coding feels wonky. 
It looks like you wrote a lowercase I instead of an uppercase I. This has happened 6129 times on Reddit since the launch of this bot.
Thanks a lot for that, I really appreciate it! 
You're writing procedural/mutable code in a functional/immutable language. I for example, in thousands of lines of Elixir code, have never once had to use `elem` and especially `put_elem`. You have to stop thinking in terms of arrays and start thinking in terms of lists with heads (the first element) and tails (the rest of the elements) and write functions that process things that way.
you mean the tail of the list isnt an empty list...
List has many tails and only one root. And yes, it can happen that the tail of the (non empty) list will not be the list. 
This doesn‚Äôt make any sense. A linked list has only one root and one tail. An improper list is when that tail is a term other than the empty list. Normal list: `[1 | [2 | [3 | []]]` Improper list: `[1 | [2 | 3]]`
I think it doesn‚Äôt hurt to have one more post explaining this topic. A few days ago, I had the same problem and knowing this blog post would have helped me save some time.
OK so I tried to cover this with some kind of test and then rewrite into something functional and only succeeded in making it slower... I know there must be a way to update the Nth element of a list without re-navigating the whole list (which would make it take the same time or be faster) but I ran out of time, here's my work so far: https://gist.github.com/pmarreck/29e2179ccc1d47e74518d5ce5a3937bb
Hey everyone, my goal for February is to write a blog post every day. I figure that doing it on a non-leap year is a good idea. The ideas are varied, but cross technical and human side of Elixir development.
The question is not clear for me. Do you have experience with HTML, CSS and a bit of Javascript? Because that's all you need to achieve something like that.
If you know a little html and css this course may help you with structuring your layout https://scrimba.com/g/gR8PTE
Including dialzyer‚Äôs plt generation was another pain point since it takes so long. Thanks for the update!
I would start by going to https://www.freecodecamp.org/ and taking their free HTML / CSS courses. Click "Map" in their nav menu to see what you'll learn.
This is a good introduction to HTML and CSS: https://www.amazon.com/HTML-CSS-Design-Build-Websites/dp/1118008189/ref=mt_paperback
Slowly but surely working on creating a course hosting platform using Phoenix. I'm learning Elixir / Phoenix along the way from ground 0, but have prior development experience.
I am working on a big blog post on best practices for deploying apps: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ Generally speaking, it's best to use the VM config process (`Application.get_env/3`), as you should be using Erlang releases to deploy. If you have something like a listen port, then ENV vars are ok, but only for simple strings. Using [Conform](https://hexdocs.pm/conform/getting-started.html) is a good way to handle more complex config from env or local config files. 
Well, I mean, with phoenix you can easily render a list of data. How would be possible to render a grid?
My practice has been to store anything that‚Äôs not sensitive info within your config files to pull with Application.get... but if it‚Äôs any sensitive credentials just store it in your environment variables with Docker/K8s or something similar!
This is not true. Config is evaluated when mix is started. So when you're running with mix, config is evaluated before any application is started, but it is done at runtime not compile-time. In releases, since there's no more mix around, the config is basically "frozen" in the form that was present when you run `mix release` (since that's the last time when mix started). You can override that by using custom `sys.config` files or, as pointed out, the `REPLACE_OS_VARS` mechanism.
I wonder if it would have been helpful to have a Day 0 where you introduce yourself, your experience in software developments (years knowing this language or that), and the goals of the blog itself (maybe simply motivating yourself to keep learning and being a diary of sorts). For example, being a relative newbie to Elixir, I'd say your level is way to advanced for me. There are things, as a mature developer, that you take for granted (say, in the first blog, being able to control the version of Elixir you run, where a newbie would pick one and stick with that--undoubtedly, this is driven by something that has occurred while working with other languages where it's good practice to do that).
I don't access them directly. I map them to config items in the `prod.secret.exs`and then read them in from `System.get_env` as you stated. And yes you're exactly correct. Anything that is useful in development as well gets thrown into general config (as well as `staging.exs` and `dev.exs`) and it all gets read in from ENV vars so no sensitive info is ever kept in plaintext.
Cool, thanks.
Great feedback. I'm curious about your comment on say, controlling the version of elixir you run on. Why is this type of thing out of control for a newbie? What sort of things would you be looking for, as a newbie? I'm curious if material like https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html is considered too advanced for newbie or not? I can definitely address that in a "how I got started with Elixir" type of post.
Well, for a newbie, they just want to start coding, right? In an ideal world, the language would be fixed, and I wouldn't have to think about which version I'm working with, because that opens up another can of worms, like "Which version should I use?". For some languages, until you hit some advanced features (or semi-advanced), those features don't affect you much. For example, I mostly program in Java. After 1.5 (where generics, foreach loops, etc are introduced), the only other "feature" I care that much about is not having to specify the type of a generic when assigning to a variable, i.e. List&lt;String&gt; list = new ArrayList&lt;&gt;(); All the other features aren't so relevant (for example, those used to coding Java 1.5 but haven't particularly added to their skill set are probably not super keen to moving to lambdas). About the only other advance in Java I would care about is maybe using the new Date class. In any case, if I pick, say Java 1.7, I can, for the most part, not care what version Java is on. Or I can wholescale change it to Java 1.9 because Java tends to be pretty good about backwards compatibility when it comes to programming. I recall looking at Python's virtualenv. If you look at any tutorial on Python, it probably won't mention this unless you decide to do some web stuff, then it does funky stuff that you wonder, why do I have to care about this? I'm not saying people don't have to care, just that people wish it didn't matter. Maybe if get to doing cloud development for everything, we'll just specify which version we want, and then it will spin up a workspace isolated from everything else, so we don't have to think having one directory in our laptop be in one version and another directory in another version. Perhaps I'm just being silly.
Some have already mentioned env vars, and that is what we are using at work as well for production configuration that needs to be per-node / configurable at runtime. At startup we read in the env_vars and put them into app config with Application.put_env so that we don't see the env vars elsewhere in the code base, and we use REPLACE_OS_VARS for changes to vm.args. This is necessary since we run our applications in clusters, so there is per-node configuration in addition to wanting some things to just be more flexible than release-compile-time values. Though, for some values, that's also fine. It works well, and if you are using something like Docker and/or etcd then it becomes pretty trivial to get these envvars around. Someone has already mentioned Conform, and it has a number of advantages. Namely: env vars are just strings at the end of the day. Complex data structures are pretty much a no-go unless you pull hacks like passing in json objects and parsing them (ugh). Even simple things like dates or IP addresses require validation in the env var approach because they are, at the end of the day, just strings. Lists or maps? Yeah .. no. So quite limiting. Conform does address these issues, and even adds some documentation and type checking. However, if you want to change those values you're pretty much going to have to restart your application with either solution. That's not optimal. I really rather like the idea of etcd, or even better zookeeper, though the latter is more complex than I'd like in a configuration solution. They provide a coordinated way to define and deliver configuration, and most importantly change and watch for changes on those values. I don't like their authentication models one bit, however; they are stuck in the UNIX TTY mindset, though zookeeper does better there offering the option for things like kereberos over sasl (though sasl leaves so much to be desired as well). So, better, but certainly not near perfect. They also mean deploying either a java or go application .. meh. I would love a simpler, Elixir-native solution that provides something similar (though better than :) etcd/zookeeper, which can be embedded for easy usage (either for simple single-node deploys ala heroku, or for self-hosting configuration within a (possibly dynamic) cluster) or run as a separate service. While what we are currently using with envvars is sufficient for the moment, I know it won't be in the long term as our clusters continue to grow. So I somehow fear that unless someone gets their first, we'll end up having to do something eventually. For now .. envvars. :)
I don't think you're being silly...I think we just have different views. I don't think I'd instruct a person who wanted to professionally do elixir to not control their version or care about it. However, I would suggest brew install elixir for anyone who just wants to try the language, with the caveat that they have a path forward before they start trying to really develop on elixir. The elixir docs to a better job at introducing new programmers to elixir than I could in a blog. However, things like "what to expect" and "what material to start with" is something I can provide.
I'm working on a blog post daily this month, as a personal goal. However, I'm working with my team at work to get 2 different elixir services stood up. For my blog, the technical content I'm most excited for is going over how to build a distributed choke point.
I realize this is an Elixir centric post but in Ruby/Rails please don‚Äôt use `ENV[name]`. If that variable doesn‚Äôt exist it will return `nil` which is probably not what is intended. Instead use `ENV.fetch` which throws an `IndexException` unless you explicitly provide a default value or block. It may be longer but it‚Äôs more explicit and will not silently continue and blow things up later.
With tools like [direnv](https://direnv.net/) around, anything truly secret gets shoved in a .envrc, and anything I wouldn't really care about losing goes in plain configs
The way everyone else told you to. This question has nothing to do with Elixir or Phoenix, but general web development (HTML and CSS). That is where this work is done.
"CSS Grid" might be the one where you should look into. Here is my favourite presentation about CSS grid, its really easy to understand: https://www.youtube.com/watch?v=7kVeCqQCxlk
JQuery's Masonry library worked for me finally! But thanks
&gt; Even then bug in NIF library will take whole VM down. That is, of course, true about any exectuable that binds into native C functions. However, it is not true that this is a hard line "must" with the BEAM. You can run code in a slave node and supervise that, so while the slave node may crash, the main VM won't. The return values of calls are returned to the caller in the main VM. We use this where I work to run 'unsafe' (read: possibly crashy) C++ / CUDA code without it taking down the VM. Here is a quick gist: https://gist.github.com/aseigo/c62191e8bbdbcaa1f76dc1aad6bec540 Note that that doesn't work nicely with releases deployed with tools like edeliver due to some unfortunate assumptions in the erlang slave module. I have an Elixir port of that module specifically for this use case (so it isn't as general purpose as the erlang slave module; for instance, it doesn't have a relay mode). Was very little effort to get working ... &gt; lso Python is becoming de facto standard in the physics, so it will be much &gt; easier to find someone who knows Python when it will come to extend &gt; such functionality instead of finding physician who know Elixir You are correct that more physicists know Python than Elixir, I don't agree with this conclusion on two points: a) Python got to that point by providing bindings. That's it. Same for things like TensorFlow, which have a not-very-pleasant-to-use-directly C API designed for bindings, and then nice bindings into languages like Python. For the Elixir community, having similar bindings would be fantastic and would allow Elixir to be used in those contexts. b) If you are going to have physicists on your team, (as opposed to hoping some random physicist puts a library out that you can re-use), Elixir is a small ask. Many already know more than one language as it is. The Elixir community would do well to get past this "not for computation" rubbish. It is far more appropriate for computation than e.g. node or ruby are, and no less appropriate than python with the big caveat that python already has oodles of bindings.
Build badge says failing .. the code of conduct is longer than their docs. Great project, needs to lower the bar to getting onboard.
It's a replacement for the BEAM's included clustering system that connects nodes together. Partisan provides a way for nodes to find each other and then connect up so they can pass messages, just as distributed Erlang does, but with better scalability and flexibility. Distributed Erlang creates a full mesh, and requires add-ons like libcluster to automate joining/parting clusters. From the docs on lasp-lang.org: "Partisan is the technology that provides Lasp's scalable cluster membership. Partisan bypasses the use of Distributed Erlang for manual connection management via TCP, and has several pluggable backends for different deployment scenarios." What I'm not entirely fond of is that it has its own message passing as well. Would be far nicer if inter-process message passing could be hooked into this rather than having to use partisan_peer_service:forward_message(NodeName, RemotePidOrRegisteredName, Message). More here: https://lasp-lang.readme.io/docs/overview
The code of conduct is standard, but they really do need docs.
Could use a ‚Äúthis is how it‚Äôs different than distributed erlang and why it scales better‚Äù section... Looks like it also uses a gossip protocol so where‚Äôs the improved performance or scalability?
This piece needs to be at the top of the readme allows applications to perform up to 13.5x better or scale to clusters of thousands of nodes over the general-purpose runtime distribution layer.
There's a great community at https://elixirforum.com as well.
Shameless plug, but it's relevant! [DeferredConfig](https://hex.pm/packages/deferred_config) is a super-simple approach that lets you defer config to runtime, so that (for instance) you won't have config woes when you start making releases and your `System.env()` calls now need to be moved out of config and into the app startup lifecycle. You just make one call, to `DeferredConfig.populate(:my_app)` at app `start/2`, and it will do a replacing walk of your config for patterns that it recognizes, like 'system tuples' and more general 'module, function' tuples. [Some examples and context/issues to consider in its docs](https://hexdocs.pm/deferred_config/readme.html). 
I'd recommend setting up a config service based on `Phoenix.Tracker` (from phoenix_pubsub, does not require Phoenix at all) for the config you want to keep track of; it's very approachable when, as in this case, you'd probably prefer your config service to run on every node. There are, of course, abstractions built on that already (service, dht, etc), but I'd recommend just using Phoenix.Tracker directly as getting a feel for building practical crdt-based services has such a massive payoff.
Not sure what you mean ... what community disaster are you thinking of?
[The shitstorm that resulted from this](https://bugs.ruby-lang.org/issues/12004)
Direnv is awesome! Thanks for the link.
Authenticating by email is a better approach than some people realize. If a site allows password reset via email alone that is equivalent to email auth anyway.
Hi, I'm new to Phoenix but rolling my own password less authentication was the next thing I was going to do, so your library came at a very good time. Nice one! But I have a question. Why aren't you use Phoenix.Token to generate the tokens?
Yes, I totally agree. I think this should be the standard for any site that doesn't store something important like payment details. And of course everyone should have 2-factor authentication on their email account.
Agreed. I built a system that used passwordless auth (which I rolled myself with Phoenix tokens) in Elixir/Phoenix last year, and I fell in love with it. As you said, if a website allows a "forgot your password" workflow, they already support passwordless auth, just in a clunky, roundabout way.
Sorry to tell you that if you use the short version of child spec `{module, arg}`, the `start_link/1` of that module always gets called, and `arg` is passed to the parameter of `start_link/1` **as is**, so you can't use `{Task, [KVServer, :accept, [4040]]}` because the supervisor will call `Task.start_link([KVServer, :accept, [4040]])` (pay attention to the outermost brackets), and that will raise `badarg`. If you want the supervisor to call `start_link` of other arity, or even other function, you have to use a map as the spec. For example ``` def start(_type, _args) do children = [ %{ type: :worker, # optional, defaults to `:worker`, the other value is `:supervisor` id: Task, # optional, defaults to the module given by the `start` key (see below) start: {Task, :start_link, [KVServer, :accept, [4040]]}, # required, a module-function-args tuple restart: :permanent, # optional, defaults to `:permanent` shutdown: 5000, # optional, defaults to 5000 for worker, and :infinity to supervisor } ] opts = [strategy: :one_for_one, name: KVServer.Supervisor] Supervisor.start_link(children, opts) end ``` You can find the full documentation on [https://hexdocs.pm/elixir/Supervisor.html#module-child-specification](https://hexdocs.pm/elixir/Supervisor.html#module-child-specification)
Thank you for your answer - i had another person also pointing me towards the supervisor documentation. Your code example was super helpful already, but on top of that i also saw the `Supervisor.child_spec/2` function (see [here-ish](https://hexdocs.pm/elixir/Supervisor.html#module-child_spec-1)). It allows one to slightly modify existing childspecs. In the end my child definition would look something like this: ``` children = [ Supervisor.child_spec(Task, start: {Task, :start_link, [KVServer, :accept, [4040]]}) ] ```
It looks great. I was going to roll my own passwordless authentication for a side project but I'm going to use Veil instead
Child specs are just maps so you can build them up yourself, too. The function you found is a convenient wrapper to do that.
Should elaborate a little more on the github readme. Sounds interesting 
The hex docs go pretty in detail but perhaps I will ass a short summary to the github.
I think it depends on how much prior experience you have with web apps and how well you deal with conflict. I'm in the same boat as you and I started by spending a little bit of time glancing https://elixir-lang.org/getting-started/introduction.html. Not in depth reading, but just skimming and jumping around on topics that look either completely foreign to me, or in need of review. Then I just got a hello world Phoenix app up and running and started writing my app. I haven't gotten to the data layer yet, but with very little friction I have a bunch of custom routes, templates and views using various patterns taken from Phoenix's docs. My thought process is, being able to see the web app take form is motivating, and I need to learn how to do the front-end aspect of a Phoenix app no matter what. Next up is to start reviewing user authentication packages and get a handle on ecto (going to read the docs and look at as many examples as I can). I just wish the Programming Phoenix 1.3 book was already out but Amazon says April 25th 2018. That is the only book I think I'd read. Mainly because it's written by the creators of Elixir / Phoenix, so it should be filled with a bunch of best practices.
I really enjoyed the Little Elixir and OTP guide book by Benjamin Tan Wei Hao. As an entry point its great because it shows what's special about elixir. https://www.amazon.com/Little-Elixir-OTP-Guidebook/dp/1633430111 However, if you are coming from rails world and just want to dive into making a phoenix app, that could be a n easier approach. Ive been building a recipe website over past month or so and it's taught me a lot too. I'm using almost none of the OTP stuff I learned to make Phoenix apps btw.
I read one of the recommended books. I felt that it gave me a better overall understanding than what I could get anywhere on the internet
If you like screencasts I've been working on https://elixircasts.io
Let's say you did not understand a whole field (chemestry for example). Quora and google makes you search, search, post messages and wait a long time for a reply to give you a short text. Quora and google makes you read a ton of things. All by yourself. At the end of the week you did only a little bit of progress. This is long, lonely and painful. This program makes you call immediatly with skilled HUMANS. You just sit, relax and enjoy talking to them and will be dedicated to you to make you master the field. isn't it right ?
Fleet Management System. Previously written in Django, started moving it piece by piece to Phoenix. So far the progress is like, i) Moved in the front-end app (previously written in create react app and served separately, into the asset pipeline, it was surprisingly straight-forward) ii) I had to keep the Django auth, so the authentication database is there, Guardian knows about it now. iii) Refactored a major portion of the backend API (REST; sans Reporting).
What if I need to login on a computer where I don‚Äôt have access to my email?
The difference is going to be in the foundations and not in the framework/packages. My suggestion: get Programming Phoenix (or something similar) to get acquainted with Ecto and Plug. Use Elixir in Action to learn more about Elixir and OTP. Programming Elixir is also a great book but my colleagues preferred the pace in Elixir in Action.
Most companies are still in the 'learning' phase with elixir/phoenix and including it in their tech stack. A lot of companies are looking for ruby/rails devs first, with a willingness to learn.
Cool. I think I'll email some companies re: if such an arrangement (train first) would be possible if I pass their hiring process. When I read Elixir before I tried to make my Ruby code look like it hehe. How does the front-end play into this? Should I consider Phoenix apps to be a lot like traditional Rails, or are they more like API backends?
Thank you. When you say foundations, do you mean like coding in a functional style, or like the foundations of web development/programming in general? (I'm guessing both hehe.) Also am I naive to think that we can't marry object-oriented/functional styles? Something like instead of maintaining state, just create a new instance of the object (ex: `employee.change_salary(50)`) just create a new `Employee` with a different salary.
Whoa, it's like Railscasts but for Elixir? Hehe. What programs/microphone do you use for recording?
I meant the functional foundation. I assume you already have the web foundation because of your Ruby/Rails experience... that just carries over to Phoenix. Regarding OO/FP, that works at a basic level, but it is just scratching the surface. Pattern matching, protocols, Ecto schemas/changesets add more depth to it. I would say it is ultimately simpler than OO but you need to get acquainted with it regardless.
I am looking for an Elixir developer, and I will be satisfied with a skilled developer willing to learn Elixir.
The token is stored in a cookie yes, although this is all handled by Phoenix rather than Veil. Phoenix includes built in defences against CSRF attacks, but it's not something that my library adds to at all.
Hi, I'm the founder of Gigalixir. I agree that it really sucks we don't support Windows at the moment. It was a tough decision for us to detect and reject Windows, but we did it because many of the commands don't work on Windows despite being written in Python. For example, gigalixir observer needs to set up ssh tunnels, modify iptables or pfctl rules, check used ports, etc. Also, almost all commands use netrc for authentication and that doesn't work great on Windows. We definitely plan to add Windows support one day, but just not sure when.
Thanks you!
This is awesome man. I just have a few things to do but I'll be taking a few weeks to learn Elixir. Currently reading all your entries :)
Another interesting question (I think): regarding the pool of Elixir/Phoenix devs - will this market be "flooded"/saturated with ex-Ruby/Rails devs converting to Elixir, or there still will be a place for "others", such as e.g. C++ devs willing to jump in?
Unless, you know, they have implemented password reset it in a sane way which requires more than simply "something you may or may not legitimately have access to" as they key to the castle. So yeah, I guess if the bar for security is inches off the ground to begin with, you may as we ll make it just a lil lower. 
I appreciate it. Don't be a stranger on elixir slack if you need anything.
You can achieve a much smaller image using distillery releases from a vanilla alpine base image.
Learn OTP. Without OTP you'll be developer doing Ruby with Elixir syntax. 
 is not only a new language, but it's also very different than the current mainstream ones, because it‚Äôs based on another paradigm: not ‚Äúobject-oriented‚Äù but ‚Äùfunctional‚Äù instead. This means you‚Äôll need to write code in much different way that before. As Jose Valim say: ‚ÄúIt looks like Ruby, but it‚Äôs not Ruby at all‚Äù. The documentation it's ok but very limited, so I would recommend going straight to the books. Luckily there are already several great books published. This is my *ordered* recommended list of books you should read to learn Elixir. *1st. [Learn Functional Programming with Elixir (by Ulisses Almeida)](https://pragprog.com/book/cdc-elixir/learn-functional-programming-with-elixir)* This first book is a great introduction of both Elixir and the functional paradigm. While does not covers all of what Elixir can do, it gives you enough base knowledge to start and not be surprised by the weird/awesome parts of the language (like the fact that ‚Äú=‚Äù is now pattern matching, not assignment and the consequences of that). *2nd. [Programming Phoenix (by Chris McCord)](https://pragprog.com/book/phoenix/programming-phoenix)* Eager to do web programming in Elixir? This book will introduce you to the Phoenix Framework (http://phoenixframework.org), by its creator himself. If you‚Äôre not in hurry you might want to just skim it and return to it later. Sadly, this book it‚Äôs about Phoenix 1.0, and currently the framework it‚Äôs in a trasition period. The new Phoenix 1.3 make some changes, specially to the structure of a new project and the philosophy behind it. But don‚Äôt worry, the new version mantains (almost) backwards compatibility, so you can still use the commands and code from the book without problem. The [new book](https://pragprog.com/book/phoenix13/programming-phoenix-1-3) is due in June if you really want to wait for it. *3rd. [What‚Äôs new in Ecto 2.1 (by the Plataformatec team)](http://blog.plataformatec.com.br/wp-content/uploads/2016/12/whats-new-in-ecto-2-0-1.pdf)* What‚Äôs this? A changelog? Not really‚Ä¶ ok, maybe, but is also a book about the de-facto ORM (actually, just ‚ÄúRM‚Äù) of the Elixir ecosystem and one of the biggest component of Phoenix. The changes in this second version of Ecto are so big ‚Äî Phoenix 1.3 has changed as well because of it ‚Äî that this book paint an almost complete picture of what Ecto can do. Is not an introduction though, you should first read either its [documentation](https://hexdocs.pm/ecto/Ecto.html) or the chapter about in the Phoenix book. *4th. [Programming Elixir ‚â• 1.6 (by Dave Thomas)](https://pragprog.com/book/elixir16/programming-elixir-1-6)* Last, but not least, this is a in-deep and wide introduction to Elixir. From the basis to the most advanced concepts like OTP and macros. When you get ready to *really* know the language, this‚Äôll be the book for you. If the name of the author sounds familiar, it might be because he co-authored the amazing ‚ÄúThe Pragmatic Programmer‚Äù and many Ruby books‚Ä¶ He also runs The Pragmatic Bookshelf publishing company.
Another question: I'm still new enough to Elixir where I'm still in the common package discovery phase. Can you please explain why you chose Swoosh over Bamboo? I only because I've seen Bamboo mentioned a bit more on Phoenix's site and it seems popular in some open source projects I've been looking at.
Something like this? :) https://github.com/felix-d/dockelixir/blob/master/chat/Dockerfile
It‚Äôs a very young language but growing all the time. I decided to really try it out about a year ago and I‚Äôll never go back to Node, Laravel, etc. Beautiful language that is very easy to follow. Compiles to Erlang so you get a rock solid base with incredible uptime and concurrency. Testing is a first class citizen and already built in. Ecto is a great ORM. Combine with OTP and ETS and you have all the data layers you will ever need. Phoenix framework makes writing Rest APIs very easy especially concerning websockets. I‚Äôd write more but that‚Äôs about my typing limit on mobile. Keep at it you‚Äôll grow to love it. 
I was a big fan of how fast I could build applications with Ruby on Rails but it can be a lot of work to make a ROR project into a scalable solution and can be bug prone so you have to write lots of tests. Elixir with Phoenix is just as fast to develop with and scales like nobody's business. Also, it is functional so writing tests is a lot easier and since it is compiled you catch a lot of errors at compile time rather than at runtime. It has a lot of really cool features, but one in particular is the ability to do hot upgrades...there is a video floating around out there on the internet somewhere...where a guy is flying a drone which is running Elixir software and he pushes up new code to the drone and it keeps flying without any issue all while hot swapping to the new code.
Because Erlang is a god-tier language, and Elixir runs on the erlang vm with nice syntax (I was about to say nicer, but I also like erlang syntax a lot). It eliminates the need for a lot of common third party tools like redis, separate tooling to run asyc code, software supervision tools, clustering tools, software monitoring tools, and perhaps even message broker tools. All of this is built into something called OTP which comes with erlang, and also with elixir. Also really really nice pattern matching, and the functional programming aspect is great too. Although it's not as strongly typed as say Scala, it's tons better than something like Python. Elixir/Erlang has dialyzer which is a tool to help with finding bugs early, also elixir typespecs are very handy (you can add types to certain parts of your code for extra security). 
Mix is such a beautiful build tool. Simple, light and just an all around pleasure to use. Hex is a great package manager. Easy to document code and generate documentation. Pattern matching is so very powerful and eliminates a lot of icky conditional code. Just to name a few that *haven't* been named. 
Nice üëç do you get better caching by separating the node stage from the distillery stage? Or is it just for modularity?
Can you share why they are transitioning off Scala? 
I really like how BEAM (the Erlang virtual machine) is designed to power long-running fault-tolerant scalable software systems. I've elaborated in more details in [this talk](https://www.youtube.com/watch?v=pO4_Wlq8JeI). There are many other great properties, such as OTP, functional programming, additional Elixir features and tooling, the ecosystem, and so on, but I personally feel that BEAM is the thing which really sets apart Erlang, Elixir, LFE, and other BEAM facing languages, from the rest.
To me, elixir is a pleasant syntax that allowed me to use the BEAM (the Erlang VM) and OTP (Open Telecom Platform).
The end image will not contain the source nor the artifacts used to built the container this way, only the final build. The first two stages are only used to build the final image.
Honestly I didn‚Äôt put much thought into it. Swoosh was the first one I came across and seemed to work for me so I went with it. Haven‚Äôt used Bamboo but I expect it works equally well. If anyone is better acquainted with the pros and cons then I‚Äôd be open to their input.
IO is Erlang/Elixir's forte, not computation so I don't see Elixir gaining traction in the crypto domain.
Thanks. Yep, both use `render_existing`. It's interesting to see how different the usability is between both set ups, even while using the same underlying Phoenix features. I wonder if Ryan's `yield` function will ever make its way into Phoenix officially because it does seem like maybe it's as good as it gets for doing this type of thing with Phoenix? Or at the very least, it definitely would have saved me hours of tinkering around if something like that example were included in the docs.
`render_existing` is definitely the answer to this question and we have have docs here with examples: https://github.com/phoenixframework/phoenix/blob/8acf61aeb6f11fd81fa1681bf12621bd3781f079/lib/phoenix/view.ex#L203-L251 If the docs could have been improved to save you time with your issue, please let me know. 
Thanks for the reply Chris. From an newcomer's perspective, there's 2 concerns with the current docs: 1. If I navigate to the Views or Templates section of the docs, `render_existing` is not mentioned in either section. It's also not something that came up in any Google searches. 2. The example included in the docs you linked uses the "create many individual templates" approach which immediately makes you think there might be another way to do it because that's going to quickly get out of hand with the use case described in my above post. It would be awesome if there were a little section added to the Templates section that just covered an example use case and demonstrates using `render_existing` and a custom helper function to do what Ryan did in his blog post (creating a `yield` helper). It now doubles as a concrete example for a very popular use case and touches on view helpers too.
To be clear, a "template" in your writeup is just a function, so you don't need to create a bunch of eex files, only define `render` functions in the view modules that want to populate this data. In this case I don't see what `yield` buys other than indirection or familiarity with Rails :)
It's not my write up btw. It's something I managed to find Googling. Here's my Elixir beginner's thought process: **Ryan's yield approach** * I only need to define some function once in a layout helper and it even lets me set a default. * Using it feels natural in the app.html.eex file, such as `&lt;%= yield("title", assigns, "My App") %&gt;`. * When it comes down to populating its value, it's as close to the templates as possible (views). I still don't know the "real" purpose of a view, but it's looking to be some way to control rendering output, whether or not they are from templates is up to you (the app developer). **Your doc's approach** I don't even know where to begin to accomplish my goal without making a bunch of individual extra eex files for each page. Would you be willing to provide a gist or an example showing how all of this comes together using your method, where I'm not stuck creating a lot of eex files?
I like scala too, but I have to acknowledge that elixir is a very well designed language. I'm not sure I've ever been as productive in a language as I have been in elixir lately, throwing together reasonable projects with ease. It has enough of a compilation phase to catch obvious errors which makes it a ton easier to debug than other dynamic languages. Concurrency out of the box is stellar. And while I certainly wouldn't use it for hardware drivers or games, even its speed is pretty decent. Good enough to throw together ad hoc scripts to calculate metrics and so forth. It's standard library is exactly right. The code looks great and is easy to modify. The code reloading while I'm developing is just so useful. If I were to start a business I think there's a high likelihood I would commit to elixir as a primary language.
&gt; Maybe I'm missing a bigger point about mobile development... It should consume data agnostically from an API of some sort. Most people would implement something that is a RESTful HTTP API, I think. Then phoenix/elixir is just an implementation choice to build your API. You could do it in anything and it'd all be the same to the mobile app.
Most reasons for why I really like Elixir come directly from Erlang, OTP and the BEAM. It's just an amazing platform to build distributed systems. Language wise I'm not such a fan of Elixir, as I'd rather have a statically typed ML language on the BEAM. But Elixir makes up for the (IMHO) language deficits in tooling and community.
Elixir also compiles to bytecode, and also requires a VM to be installed on the host (or bundled with a release) to run, so they're similar in that regard. There are a few reasons why I'd choose Elixir over Scala for a new project - learning curve, faster edit/test cycles, enforced immutability, consistent idioms, and many other reasons listed in this thread. But to transition from Scala to Elixir sounds like there was some problems encountered with Scala which I'm curious to hear about.
Watch this keynote, it is one of my favorites, it captures just one of the reasons you are looking for: https://youtu.be/5hDVftaPQwY
If I were to take a guess, it would have to do with Scala's slow compile times (maybe?). Scala's type system is nice at times, and it provides a lot of neat stuff like implicit conversions but a lot of that need stuff really bogs down the language's speed and makes the language almost overwhelming at times. Not to mention - No out-of-the-box concurrency model - Types can get *really* messy - You're going to be using some Java libraries along with Scala libraries at the same time for bigger projects, there's no real way to avoid it (even though the idea of Scala is to be more powerful Java) - There's a *"standard"* way of doing some things in Scala, but not really If anything they could be switching because of *all* the caveats of Scala. Not that Scala is bad, but right now it's not all that cracked up sometimes. 
There was an excellent Clojure conference talk a few years ago about a gentleman who made furniture with hand tools. Bench saws, chisels, the works. If I'm remembering the thesis of the talk appropriately, his view was that by having small reliable tools, the combination of all of them would allow him to produce higher quality furniture than anything that comes off of a machine. He also felt that not having rapidly spinning metal ready to cut his arm off, but that's not particularly relevant for this point. A tertiary impact is doing this kind of furniture building, one eventually creates a workbench that allows the builder to more easily do the jobs they need to, after learning what things they need. A proper workbench would have conveniently placed clamps, e.g. to hold boards of various shapes and sizes, because it's built generally to aid the work in the future. Though he spoke of Clojure, the same things are true with Elixir, and many languages with Lisp-style macros and functional flavors. You have a small core of very strong utilities that allow you, in combination with each other, to create really complex machines with very few building blocks. For the workbench analogy, macros allow you to express your solutions in the language of your problem, by hiding unnecessary syntax where it doesn't need to be. It really feels like a language that is built by craftsmen to do proper build craft. One where very seasoned developers sanded down the corners properly across the board and built a very forward thinking tool that's a pleasure to use. Where I feel Elixir stands out from Lisps in particular is accessibility to new developers. The Ruby looking syntax is VERY easy to read, even if you're unfamiliar with Ruby, and the explicit nature of the language means that someone coming into a code base has very little if any magic to conceptualize. Don't know what something does? Just find the place where it's defined and read the code, or check the HexDocs. At the same time, that syntax is superficial and the underlying methodology is highly derived from that of Erlang (with a little Lisp, without being a full blown Lisp), which is itself an extremely mature platform with decades of development under its belt. Elixir is also defined for the most part within itself (using macros, generally), which means that you can just read the code and figure out what's happening (see e.g. `kernel.ex`). I love this property of languages, and it shows you cannot be held captive by Jose and the core team refusing to add your favorite feature. You can make it appear seamlessly alongside language constructs like `if`and `defmodule`. See Guy Steele's famous Growing A Language talk. Tooling wise, Elixir is very modern with good build tools, package managers, etc. and a smaller (though often extremely high quality), but growing and improving library scene. There are some gotchas around releases, and how to deploy in e.g. Docker in production, though they're working on making these easier. As far as type systems go, Dialyzer is the one in use by Erlang. The error messages are awful and Erlang-ey though there is work being done to fix this. It's often good, but it is one-sided errored so it can miss things. There are ways to program to make it more easily able to determine things, but you have to get a feel for the tool to really get a good sense of that. The supervision model is really an excellent way of reasoning about complex software, and although as with any system there are gotchas (see Erlang in Anger), it allows you to get really reliable software with very easy to predict latency numbers. Finally we get to performance. Thinking futurewise, we can expand number of cores way more easily than we can speed of a single core, and we can way more easily just get more machines. The supervision model allows you to map your solution very well to your topology, if your problem is the right use case for that kind of thing. It's very fast on single machines (I sometimes get responses with a unit of microseconds), and the Erlang VM has very strong primitives for reasoning about your network topology at a high level and predicting failure at development time. This is awesome because it means your software can be easily adapted to changing demands. Finally it's just a pleasure to work with. I love hacking on things with it, and code golfing is a dream. Refactoring is cut/pasting often and changing a few call sites to point to the new place. The community is awesome, the core team of the language and its more famous tools are all really open to contributions from newcomers and veterans alike. I really love Elixir and I'm happy I chose to learn it, and am thankful I get to use it in my day job.
Here's my perspective as someone that's only been professionally developing for ~3 years as a Python / Django + JS / React &amp; 7 months using Phoenix -- The first thing I noticed coming from Python / JavaScript ecosystem is the amount of thoughtfulness the core developers have towards developer UX -- Right out of the box, you're given a toolchain for: 1. Dependency Management via Mix. It just Works. library that you just forked onto github? Works. Just want to install the latest version? yes ma'am. You don't realize how good a tool is until you've used other ones that don't _always_ work. won't name names here :D 2. Code generation via Mix (Coming from the Django world, this was a mind-blowing thing, I know the rails framework does this too). For example mix command: mix phx.gen.json Accounts User users name:string email:string Will generate your controllers, schema, context layer, tests, and helper documentation to push you in the right direction for how to do things the *sane* way. As someone writing REST API's this has saved me countless developer hours. 3. Pattern Matching, a feature of Elixir: I found that pattern matching has allowed me to write very precise definitions for when things should and shouldn't happen. For example, it's very easy to write something like: "run this function if the user is authenticated, and who's permission level is of admin, otherwise this function here will catch everything else and throw an exception". Coming from an imperative language background, it's really changed the way I think about composing behavior. 4. Like others have mentioned: Supervisors, OTP / GenServer / GenStage, ETS. Right now, it probably sounds like a bunch of tech-fancy-wizardry -- but these are abstractions that programmers much smarter than most of us have devised to make our lives much simpler to reason about difficult problems -- I swear this isn't all koolaid! Lastly, the Elixir community, especially on slack has been great. I've asked plenty of beginner questions on slack and have had Chris McCord himself help me out. Just a good feeling to know that the core developers of the language are willing to help little nubbies like me out :)
Fully agree! I've come over from Rails like many others and even after two days I know I'll be sticking around for a long time. Add to the above the great benefits you receive by embracing functional programming, and I really don't think you can go wrong.
Incredible! Gonna need that video!
&gt; It eliminates the need for a lot of common third party tools like redis, separate tooling to run asyc code, software supervision tools, clustering tools, software monitoring tools, and perhaps even message broker tools. All of this is built into something called OTP which comes with erlang, and also with elixir. This is one of the hardest aspects of Elixir/Erlang/OTP for me to grasp. I just cannot accept how it makes all these other fancy technologies obsolete. I'll still research plenty about the limitations of native OTP abilities vs more dedicated options (RabbitMQ for e.g.), but it seems like you get a tonne for free out of the box.
An amazing app? Nope.. I'm working on my first boring business-oriented application (Kube/Elixir/Phoenix) to help me escape the clutches of contracting so I can work on my own stuff full-time. Moving over from Rails and having lots of fun!
The JVM is an amazing piece of engineering. In many many ways better than BEAM. (Yes, BEAM does some things that JVM does not) Complain about the Java language all you want, I'm not going to argument too much.
Erm, thanks! But you sure it was me you saw in HN? Because i) I am an HN shy person, and ii) If I have to say something about anything JS, it won't be pleasant, and you'd remember me with anger ;)
Hmm.. maybe not. It was someone who converted a Fleet Management System from Django to React and Phoenix haha helluva coincidence if it isn't you!
[removed]
There aren't many Elixir jobs out there, so I wouldn't recommend picking up the language with the intention of finding work. As for how to get an Elixir job. Most places I'd assume would be transitioning over to Elixir/may not even be using Elixir exclusively. So aside from knowing Elixir (and OTP), you'll probably need to be familiar with whatever their original stack is. As for myself, I've had no luck with any Elixir jobs. Not that there was a massive pool to apply to anyway. But I got rejected (not even an interview) from all the ones I did apply to. Funnily enough I heard from some of them that they were starting to become desperate for Elixir devs, and were willing to hire people who were keen to learn the language. But rejected again when I applied to them again lol. So yeh I'm not really sure what's required to qualify for a job in Elixir, other than the general assumptions. But since the sample size was so small it could've also been simply not meeting organisational wide requirements, or some other skillset desired, rather than not having enough experience in Elixir. 
Wow. I'm using React (Mobx State Tree) alright. You're right on the coincidence part, helluva coincidence indeed! Anyways, I'm thinking about writing about it, maybe on how to make a small subset?
Regarding OOP like code. Yes, you could pass in the current state, and some value and return the new state. I wouldn't consider that code very OOP-like however. Another option if you want a shared single reference to the same state is to use a process that manages its state, and any actions send messages to that process to update its internal state accordingly. 
As a complete docker and postgres noob I've spent some hours today trying to achieve this to no avail. And your solution works perfectly! Thank you! 
Any comments for "Functional Web Development with Elixir, OTP, and Phoenix" by Lance Halvorsen? Just started reading it, seems quite interesting. For someone with FP background and Erlang familiarity.
&gt; This is a little confusing because technically we could have wrapped the user controllers, views and templates into the accounts/ namespace but we didn't. I think, in the context of being a tutorial, it made sense to introduce the generator without the `--web` option first, to help understand the basic generator behavior. If there is only one way for end-users to modify the underlying User model via the web, you don't even have to namespace the controller, necessarily. Otherwise, you certainly could have used the `--web` option in the first case and ended up with `hello_web/controllers/accounts/user_controller.ex`. &gt; Should we always wrap all web related resources and pages into the context's folder as a best practice? I don't think this is a hard-and-fast rule, by any means. If you follow that pattern to its logical conclusion, every controller action becomes a super-thin layer - basically a one-line call from the web layer down into your application. Structuring the shape of your underlying application just to conform to the user's endpoints is doable and may be helpful for locating the relevant files, but you will find it to be constraining, resulting in a lot of repetitive setup code that could have been done ahead of time, in the controller or Plug pipeline (e.g. fetching and authorizing the current user). &gt; Also when it comes to defining route "as" paths, should you use the context name or not? For example would you use accounts_session_new or session_new? Routes are a web concern, not an application concern. So, if your controllers are namespaced, use the namespaced route helpers. In the end, modules are just bags of functions. Module namespacing is more of a convenience and a mental model, and as your application grows, that model may shift! Renaming and moving modules is pretty easy, so don't be afraid to "stick it somewhere" with the ability to move it later.
So, funny you should mention that, I actually use that exact folder structuring. I just skip generators entirely and in `my_app_web.ex` changed the injected view module helper so that `Phoenix.View` could find the templates at compile-time use Phoenix.View, root: "lib/rhr_web/#{ Regex.replace( ~r/View$/, __MODULE__ |&gt; Module.split() |&gt; Enum.slice(1..-1) |&gt; Enum.join("."), "" ) |&gt; Macro.underscore() }/templates", path: "", namespace: RHRWeb
Thanks for sharing that. And for clarity, do you then have a user/ folder inside of your templates using the above example? I think part of the value of using a framework is sticking to conventions, so I have to wonder if we're going down a bad path to do it this way long term since it's against the grain. But honestly, I care more about productivity and being happy, and having to do those 7 steps just to change a context name makes me unhappy. At the same time, having 35 controllers sitting in 1 folder also makes me unhappy, so something needs to be done in the short term.
No, I just have the `.eex` files directly under `templates/` since it's already nested under the controller. [Like this.](https://imgur.com/uFA5QEE) &gt; I think part of the value of using a framework is sticking to conventions, so I have to wonder if we're going down a bad path to do it this way long term since it's against the grain. That's a fair point. Take solace in the fact that the above change is at least *explicit* - it's a documented option that can only be overridden in one place, not some monkey-patched behavior that changes the whole application behind your back.
Ah I see, so you went as far as making "user" its own folder using the above example, so accounts/user/user_controller.ex instead of accounts/user_controller.ex. Yep, that's true about it being documented. I wonder if Chris or Jose have any plans to revisit the default _web folder directories, especially in relation to contexts.
Yeah, I've found that singular names everywhere works pretty well. It really helps locating code when you have non-standard pluralizations (like country -&gt; countries, or child -&gt; children). In this case, since the controllers are for a user managing their own account, the singular especially made sense (thinking of it like MyAccount).
of course RabbitMQ run on erlang to start off with.
Haven‚Äôt read it, but it looks good and it covers Phoenix 1.3 so it could be even a better introduction to it than the Phoenix book
As far as I understand by reading the ‚ÄúWhat‚Äôs new in Ecto 2.1‚Äù, the contexts are intended to be a way to deal with the problems of fat models. When in Python or Ruby you would use Mixin classes to separate some model fields and related business logic, in Elixir you can use contexts for that.
Yes, but the generators and official documentation on contexts have conflicting information when it comes to namespacing things in the _web folder. That's where the confusion lies.
Don‚Äôt build anything custom with GenServers for this. Phoenix already has the concept of a session, which is already doing exactly what you want it to. You can read more about it here: http://phoenixframework.org/blog/sessions
Is it ok that I still use the request id to name each GenServer?, I changed what I previously had for the sessions approach, thanks.
Mentions addict but if you are looking for an alternative that is just as easy to use please check out my library AccessPass and let me know what you think https://github.com/jpiepkow/accesspass
That is also pretty cool, I like it! 
Wow I'm surprised it works. [The docs](https://hexdocs.pm/elixir/GenServer.html#module-name-registration) suggest that GenServer names should be atoms when registering locally, but can be other terms when using `global` or via-tuples. TIL
The example stores the user_id in the session. Isn't it preferable to store an opaque session token, and associate it with a user_id in the database? That way a user can see and expire all their sessions from an admin page or when they change their password. 
Here is a list of threads in other subreddits about the same content: |Title|Subreddit|Author|Time|Karma| |---|---|---|---|---| |[Functional puzzles (Javascript, Elixir, Clojure)](https://www.reddit.com/r/Clojure/comments/7ym2d2/functional_puzzles_javascript_elixir_clojure/)|/r/Clojure|/u/orestis|2018-02-19 19:38:07|1| |[Functional puzzles (Javascript, Elixir, Clojure)](https://www.reddit.com/r/programming/comments/7ylvn3/functional_puzzles_javascript_elixir_clojure/)|/r/programming|/u/orestis|2018-02-19 18:54:42|0| ---- I am a bot [FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block user (op only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20user&amp;message=orestis)-[Block from subreddit (mods only)](https://www.reddit.com/message/compose/?to=DuplicatesBotBlocker&amp;subject=remove%20subreddit&amp;message=elixir) Now you can remove the comment by replying delete! (op only) 
this looks interesting, I might give it a try. My experience, coming from rails / django is that phoenix lacks of good user management libraries for both API / traditional website.
Nono, the ID is a string but I‚Äôm using the Registry module using via tuples. 
I think their are a couple good library in elixir like addict or ueberauth. Just none of them were quite right for what I wanted/needed.
I just wish for something like Devise for rails
No, you should not use the Request ID. It is in _no_ way related to the actual session or user. It's effectively a random UUID that is relevant to that single request _only_. As I said before, I don't believe you need to be using GenServers at all. You're overcomplicating keeping session state
Nice! Thanks!!!
I'm still new to elixir and functional programming, but I'm curious if it's not slightly better to do: defmodule Santa do def santa(instructions) do instructions |&gt; String.codepoints |&gt; Enum.reduce(fn("(", acc) -&gt; 1 + acc (")", acc) -&gt; 1 + acc (x, acc) -&gt; acc end) end end 
Interesting idea. I think I‚Äôd rather be explicit in the two-stage computation, but I don‚Äôt have a better argument other than ‚Äúit feels better‚Äù. 
Mox is per process. Once you do a HTTP request, you are using another process. You probably just need to call `setup :set_mox_from_context` and make sure your tests are not async. The docs have more information: https://hexdocs.pm/mox/Mox.html#module-multi-process-collaboration
aha. that's very confusing =( I basically solved it by redoing the mock as an module wrapping an on-the-fly generated agent (defined in test-helper) and setting the tests to be async...
You're right.
What's this have to do with Elixir?
Really great article, clean and to the point. Thank you!
As I've mentioned in the article there is a room for improvement. That could be one of those improvements. The authentication topic is quite broad and probably cannot be covered by a single article. 
I've mentioned "Addict" only as an example, I'm pretty sure there are more than one libraries. I wanted to show how does it work inside instead of using any particular library. I think it is also important to understand the internals. I will take a look at your library =)
Thanks very much! Small typo: the "s" was left off the end of the URL link to seeds.exs
Quite true! I thought about, but I opted to show the list destructuring syntax instead. I believe that people new to Elixir will be even more confused when seeing the binary syntax destructuring, but have no data to back it up.
I think it would be harder to explain what "codepoint" is than explaining binary pattern matching to total newbie.
Without the redirect and trackers... https://www.erlang-solutions.com/blog/fips-for-erlang-elixir-systems.html
After installing piHole there's a lot of links that take me nowhere these days.
In case anyone else has shitty eyes like me: .blog-page p { font-size: 16px; color: black; font-weight: 400; } makes it a lot more legible
**Reported for referral link spam across multiple accounts.** https://www.reddit.com/user/UnkindTaborp/submitted/ https://www.reddit.com/user/UnkindTabora/submitted/ https://www.reddit.com/user/UnkindTaboro/submitted/ https://www.reddit.com/user/unkindtabori/submitted/ https://www.reddit.com/user/unkindtabors/submitted/ https://www.reddit.com/user/UnkindTabory/submitted/ https://www.reddit.com/user/UnkindTabore/submitted/ https://www.reddit.com/user/fegertsa/submitted/ https://www.reddit.com/user/trukirukia/submitted/ https://www.reddit.com/user/buyuksd/submitted/ https://twitter.com/nerd2techdeals/ name changed to https://twitter.com/techdealsandmor https://twitter.com/give2emsome name changed to https://twitter.com/give3emsome https://twitter.com/GeekDailyDeal
Sweet, thanks!
Actually all of them were great. Sarah Grays closing keynote was so good. Emma Cunningham's opening keynote was very interesting. Loved the part about linguistics in there. Will Ockleman's ant foraging was an awesome way to showcase OTP behaviors. Andrew Hao and Geoffrey lessel were very interesting. I don't think there was a boring talk. I don't use ecto so that one was less pertinent to me but they are all worth a view. 
1 thing that I might suggest is keeping the count of the lists in a module attribute so it is executed at compile time. Right now, the Enum.count is going to be O(N) on the fairly large lists. 
I'm glad I'm not the only one that gets annoyed by this.
Yup, I went back to this post and the `'hello'` is different from `"hello"` has burned me like 3 times. :)
That's a good idea and quite useful to have. I will be happy to have a PR or something I can do later.
Find more here - https://hackr.io/tutorials/learn-elixir 
I've been reading the code of `Raxx.Static` and `Raxx.MethodOverride` and I'm having a hard time figuring out how middlewares are supposed to work with Raxx. It seems like there's a bunch of macros and so far it's going over my head. Can someone point me to a good primer on the macro stuff used for middlewares (I think it works with `defoverridable`). I'd also like to understand how a request will "flow" through the middlewares to finally hit a handler.
&gt; Plug is not idiomatic Elixir I'd rather see some side-by-side comparisons of where a particular task was accomplished with less code/more clarity in Raxx than Plug. The complaints I see about Plug are that you can't transform a response as easily as you can a request, leading to the asymmetric API, and that since send_resp is a side effect, you can't always be sure that a response was actually sent - leading to runtime errors. 
There is no way to middleware are "supposed" to work. `defoverridable` is just a tool that will allow you to wrap functionality of a function. It's used by most behaviours https://github.com/elixir-lang/elixir/blob/v1.6.1/lib/elixir/lib/gen_server.ex#L647 I'm sure patterns will emerge but it has been a deliberate choice not to enforce a pattern so far due to the variety of concerns when handling streaming.
How is that idomatic Elixir: defmodule MyApp do use Raxx.Server def handle_request(_request, _state) do response(:ok) end end The call of `response` takes neither `_request` nor `_state`; hence it must refer to some unnamed state, which presumably depends on the `_request`. Does `response` actually write the response to the socket? That would make it difficult to test. Or does `response` create a result object which the caller of `handle_request` interprets accordingly? In that case I'm wondering why a function call is necessary and a simple `:ok` insufficient. Further, what are the contents of `_state`? How is different from what is available in `_request`? The post says, each requests gets its own `Raxx.Server` (how can that be efficient?), so where does `_state` come from? As a last note, I would have liked to see an answer to the question raised in the subtitle.
[removed]
Site is not working.
This is one of my favorite features of Elixir. If anyone wants to see a real-world example, my [zipper_list](https://github.com/bbugh/zipper_list/blob/master/lib/zipper_list.ex) library uses it extensively. Here's an example: https://github.com/bbugh/zipper_list/blob/master/lib/zipper_list.ex#L199
This might be useful https://stackoverflow.com/questions/97508/what-libraries-can-i-use-to-build-a-gui-with-erlang Minus the java stuff. 
It would be interesting to use Elixir perhaps. But you might consider trying F# for this since it already has really excellent support for desktop UIs including native Mac bindings (Xamarin.Mac), GTK bindings for Linux (GTK#), WPF on Windows. There is also Xamarin.Forms, which began as a cross-platform toolkit for iOS/Android/Windows Phone but it has expanded to support Xamarin.Mac and GTK#. I've used it quite a lot for mobile but have not yet used it for desktop. IMO it is one of the best designed UI toolkits for cross-platform development because it makes it very easy to get down into the platform-specific APIs, while most cross-platform UI toolkits try to hide you from that layer so you're stuck using their least common denominator APIs. You can also build things with F# in an Elm architecture (what F# devs are now calling Elmish). Here's a small library for using Xamarin.Forms using Elmish: https://github.com/dsyme/Elmish.XamarinForms 
Does anybody who writes Java enjoy writing it, or are they just doing it for a pay check? One of the things that attracts me to Elixir is that Jose seems like a down earth guy who started something because has a passion for what he is doing. Could you say the same about the people who work with JAVA on daily basis?
I enjoy being productive. I'm not a fan of being too tricky. I like my code to be complex only when the problem domain is complex. Java is simple to the point of being plodding a lot of the time, and it's certainly suffers from many historical tradeoffs (e.g. primitive types ). I consider java trusty tool, but certainly not sexy. In the last 2 years or so the ecosystem is starting to see some acceleration in terms of useful new features (co-routines in VM, value types) being worked on, but again the historical stuff and emphasis on backwards compatibility will mean those may not be graceful. Regardless, my point was only that separating the JVM from the java language is important. The JVM has gobs of languages that run on it: https://en.wikipedia.org/wiki/List_of_JVM_languages 
Here is one: * Raxx.Logger: https://github.com/CrowdHailer/raxx/blob/master/lib/raxx/logger.ex * Plug.Logger: https://github.com/elixir-plug/plug/blob/master/lib/plug/logger.ex Honestly, the Raxx one doesn't feel like idiomatic Elixir at all. It is abusing `super` to mirror something like inheritance chains, it uses the process dictionary, and it overly relies on macros. And what would happen if a module that uses Raxx.Logger implements its own handle_data and forgets to call super? Would Raxx.Logger stop working?! At least I can write plugs as simple and straight-forward functions. I value the ability to compose software much higher than I value the purity aspect of things.
I‚Äôm using it as a windows service in one product. It‚Äôs not the ideal platform but does the trick. For GUI you‚Äôll end up with wx I think or serve HTML/JS to a browser. It depends on the app. 
It looks like Raxx expresses middlewares with mixins (hence the use of super) vs plugs function pipelines. Given that a Raxx server module implements multiple callbacks it seems like a reasonable approach. [method_override](https://github.com/CrowdHailer/raxx_method_override/blob/master/lib/raxx/method_override.ex#L101-L117) looks fairly simple, although [the plug version](https://github.com/elixir-plug/plug/blob/master/lib/plug/method_override.ex) is simpler still. The key difference looks like Raxx encourages thinking in terms of (possibly stateful) servers, not a chain of (possibly side-effecting) functions. If Raxx can provide a unified model for simple Request/Response, ServerSentEvents and WebSockets then it could be an improvement over the Plug + Phoenix Channels model.
Request/response are stateless, WebSockets are not. Trying to make them all live under the same abstraction means one of them will feel awkward. In this case, the request/response lifecycle. Most of my code is under a request/response lifecycle, I have no interest in compromising the design of those under the premise of better WebSocket/SSE compatibility. I would say the best approach would be Plug pipelines but with an option to upgrade to something stateful like Websockets dynamically. 
Can you please check now? I am able to access it.
the future
I am not sure I follow. There is nothing is common between matching on struct members values and matching on struct type.
"Quick answer to this one. No." - I see, thanks. You use a before compile callback to guarantee you always invoke it. "the purity is what makes reasoning about the whole unit, and testing it, easy for me" - Doesn't Raxx middleware use the process dictionary to pass state between callbacks? Isn't that impure? I think reducing side-effects is great but the process dictionary, before compile and defoverridable are all side-effects too. Reasoning how plugs compose is simpler because they are function calls at runtime instead of code injection at compile time.
Just got Distillery releases working for my service, next stop is automated beta deployment when pushing to master on GitLab.
I've been working on my first real Elixir project, [Midal,](https://github.com/bees/midal) a [microdata](https://www.w3.org/TR/microdata/) parser. Elixir is my first functional programming language and this felt like a problem that could be solved well with the tools a functional language gives you. I am certain I'm doing things in code that are weird/hard to read. If any of y'all have time review the code I'd love to hear your thoughts. You don't have to be nice - just give me something actionable :)
I've been working on a game where players buy and sell certain commodities and compete for a high score within a limited time. The game engine is a simple Elixir app, and I'm working on the Phoenix interface now. Obviously I'm using channels, so I can expand into multiplayer soon. I write in Ruby/JavaScript at work, so it's a real pleasure to have a fun side project in Elixir. 
That sounds really cool. Please if you ever make the code public link to it I'd really like to see how you've done it as I'm planing on doing something similar in the near future but as a text based roguelike. 
A chat app similar to discord. I'm hoping to finish it around May. 
I'm learning some elm by creating a frontend to an absinthe-graphql/phoenix app
Doing exercism problems - been meaning to write something real in Elixir for some time but have no idea what :|
I like the idea of generating some elm types from the GraphQL schema. [graphqelm](https://github.com/dillonkearns/graphqelm) looks like it supports code generation, and has a [subscriptions example](https://github.com/dillonkearns/graphqelm/blob/master/examples/src/Subscription.elm).
If Raxx makes it cumbersome to write pure middleware then it doesn't help me write pure code. If the only way to compose software in Raxx is by injecting a module that *mutates* my own module and permanently changes it, then it is not idiomatic nor pure. And because of how Raxx middleware is designed, I cannot test them in isolation either. I need to define a fake module they are injected into. And once I add logging to my module, I can no longer test it without side-effects either. On the other side, with Plug, I can define each plug in isolation and test in isolation without having a understanding of the whole context. As you said, Elixir is a pragmatic language, but when you say that Raxx is more idiomatic because of side-effects, then you are throwing away Elixir pragmatic's perspective in favor of a vague goal. Instead of productive discussions about the pros and cons of each library, you get pedantic discussions about the usage of Elixir idioms.
Keep up the good work.
I'm very new to Elixir - so take what I say with a grain of salt. I don't think it's fair to say OTP makes Redis obsolete, but at least the ways Redis gets used in Rails servers is not necessary in an OTP world. If you use Redis to implement message passing between processes then it makes sense that a language with built-in message passing would eliminate such a dependency.
True. I'm only a couple weeks in myself, but am beginning to understand the power of OTP and what it does/doesn't render obsolete. I thought at first I could skip on workers backed by Redis, but if I want durability, then I can't -- as you say, built-in messaging is what OTP provides, not persistence.
Even then it's only message passing within OTP. I'm sure many people use Redis to communicate between their web app and a separate service written in a different language than your web app.
So much nicer than with Rails.
I'm not an expert on Ecto by any means, but can it be that it doesn't know how to handle empty changesets? Maybe you can fix this specific error by filtering out changesets that are empty.
Does your database support JSON fields? If so using an embed_schema instead of an has_many association would make more sense in your use case. Especially since you delete_all and insert every time on every update.
Link to the repo: https://github.com/jpiepkow/accesspass And hex docs: https://hexdocs.pm/access_pass/introduction.html
Make a new folder for Plugs in your web directory at the same level as your controllers and put it in a new module there. Phoenix will auto-import the code and you should be able to call it in Router just fine.
That's how I store my plugs too :), I used to store them in controllers folder before and then I rearranged those.
Do the PragmaticStudio Elixir course. This was a game changer for me understanding the OTP side of things. In the course you build an HTTP server which works as a great example. Here‚Äôs a 20% off coupon they released: https://elixirforum.com/t/developing-with-elixir-pragmatic-studio/4429 Not affiliated but did the course and loved it. 
Watch this channel https://www.youtube.com/channel/UCp01DFl8kp-239gW289C0ew a couple of times. They are short and to the point. 
Only covers the basics, but this post made quite a lot click for me when starting out http://dantswain.herokuapp.com/blog/2015/01/06/storing-state-in-elixir-with-processes/
Get really irritated that you can't store dynamic state in Elixir and then scramble to learn processes, agents and genservers as a tool to get around it. The details will come as a side effect of this.
I'm about half way through this course and I can vouch for the quality albeit I haven't started the portion on OTP yet.
No, I don't believe they had any training at Lonestar Elixirconf last year, although I could be wrong.
Really good job! Keep up!
One monit change. I wouldn‚Äôt use raw `#{user.id}` in query but rather pass it as a parameter via `$1` and setting proper value in third parameter of `stream` call. 
I did it as well and it helped me a lot. The only downside for me is that if you want to go back to certain parts after the first pass the video format is a bit of a chore.
You're right, last year Lonestar had no training. This year was the first year. However, Elixirconf (the main conference) did have training.
Because they refactor the code so heavily? Or what do you mean? 
It's a bit tedious to go back to check again something in videos instead of scanning a book / article you have read earlier.
They did have a Nerves training this year at Lonestar, though 
Wut
Great writeup btw!
So what compilation issues were they having that they needed a full rebuild before every deployment?
Exadmin. Adminium on heroku
Ah thank goodness. This was my last pain point with the language. What he's doing there is exactly what I wanted to see.
I would use [Grav](https://getgrav.org).
Why does it need to be elixir? PHP pretty much has the market cornered on CMSs, and most solutions you find elsewhere won't have nearly the community supporting them that the big PHP ones do. If for some reason you need to build your own CMS, though, elixir would be a good choice.
I attended this year. I'm currently sitting in on a talk in Denver Eilxir Daze. My thoughts on Lonestar. 1. Turnout: This was great. While I did not attend last year's, it seemed that there were a good number of people. If I had to guess I would say around or over 300. Lots of friendly, smart folks and good conversations. 2. Talks: There was a theme of distributed systems -- which being an area of focus for me - was quite enjoyable. 3. Location: Meh. I live in Austin. The location on Anderson (lots of good furniture consignment though) is nothing special and I feel it makes post show socializing harder as you're not within walking distance of anything remotely interesting. 4. Training: I participated in the nerves training. I thought it was good and it did jumpstart me into nerves -- I do wish it was more hands on code wise, however. Not sure what else to include. Feel free to ask.
Will this address the need to have a Docker container for releases on other architectures? That is a problem I would like solved.
u/tacticiankerala is you could ask for some specifics I'd be happy to look over it for you. It's hard to know where you need improvement without having worked together.
How does this differ from the half dozen other solutions out there?
I just wrote a blog post which (I think) might serve as a good example: https://www.reddit.com/r/elixir/comments/81ip1i/using_genserver_in_a_production_phoenix/ (You do need some logic of how it works to understand the implementation) Good luck! :)
Sure it shares some similarities with other libraries but I believe it is the only one that offers this combination 1.token based(short lived access token, long live refresh) 2.revokable without the need to hit a database. 3.fast because it's based on ets as compared to storing access in a database. 4. Does not contain forms for login so mainly based on client API separation. 5. Opaque tokens that are really just keys for stored data
Pretty impressive
Was going to ask the same thing. 
I'm curious about the claim that Heroku limits you to 50 connections per dyno‚ÄîI think they mean that the *backlog* is limited to 50 connections per dyno, but I've never run into this limit with an elixir app‚Äîit handles connections as fast as Heroku can hand them over. 
Hey! Thank you! I‚Äôm glad you enjoyed.... regarding libcluster, nope. I used a singleton paradigm to guarantee there would be only one manager running in the entire cluster. It would be interesting though to allow that to run freely and maybe control through something like libcluster
Why make another clone chat just copying code from dozens of others? You could've shown how to handle presence, disconnects or whatever. I just don't understand why bother
This is *concurrent* connections we're talking about, i.e. if you're using Phoenix Channels. We've not personally run into this issue yet, but it is documented by Heroku here: https://devcenter.heroku.com/articles/http-routing#request-concurrency
I'm using an app as an example. In order to implement the things you mention I need to implement that behavior at first. I cannot build a second floor by avoiding first. Also to cover all the possible topics would be too much for a single article. So I'm planning to cover them in the next articles. The third thing is worth to mention. I write about what did I learn. And I hope someone might find that interesting and learn something as well. If I can reach at least couple of people, that is already great. I'm sorry.
Seconded, this looks very promising. 
How much Elixir do you know?
I work with Elixir on the job everyday.
Good to hear. How is the Denver event?
Smaller. Much more social. Super fun. Venue was Ophelia's which is a bar/music venue. Fun and different. 
Man.. Keep doing what your doing. What you share is going to be valuable to someone. Don't be sorry.
Phoenix is actually not ‚Äúheavy‚Äù. It is composed by a lot of plugs, meaning that you can use only the parts you need of phoenix to make it work. First you need a Phoenix Endponit, and from there you start building what you need. Also using plug you will end up writing more code which phoenix provides. Saying this, I think Plug can be your go to, or look at github for sinatra like repos. P.S. If you find something interesting, please share it
You have maru which seems to be more focused on APIs https://github.com/elixir-maru/maru
What kind of app are you trying to build? For the most part you can get pretty far with just cowboy, plug, and ecto. Although if you were needing all those 3, I'd probably just use Phoenix anyway. Another option if you don't need everything Phoenix has to offer, is you can often leave those parts out entirely. There are some other web frameworks available, but I'm not sure what kind of state they're in or how they really compare to Phoenix in this regard. Though I'd imagine they'd be somewhat similar, if you really don't need all that functionality, you probably don't need a web framework. 
Cast should also validate format, so you don't shove garbage into your DB. 
I‚Äôve been meaning to check out Raxx: https://github.com/CrowdHailer/raxx
&gt; I'm looking for simpler and lighter ones that are actually used by others. Is this driven by some design requirement? What does "lighter" mean? In my experience, starting out with a minimalistic web framework will inevitably lead to re-creating all the tools that come for free with Phoenix - think about routing, content types, templates, middleware, persistence. `mix phx.new --no-brunch --no-ecto --no-html my_app`. It's about as minimal as you can get, and you'll instantly be productive.
To expand what OP said, the cast/1 function should make sure the tuple is 4 numbers between 0 and 255 (in case of v4) or 6 numbers between 0 and 65535 (in case of v6), but since the value comes from Plug we can expect to be a valid IP tuple, so it's not really necessary.
I really like this approach since it allows you to test compliance on a database level plus in doesn't give you root access to the database. But I haven't seen anything that uses it in Elixir. But I don't think this approach should be hard to implement.
How would you implement this ? I was thinking to initiate a process with an Ecto database connection parameters generated from the credentials given by the user but not sure how to do it, I'm still a beginner in Elixir :)
Side note: there are a lot of common ways to write the name of that database, but `PostGreSQL` isn't one of them. Usually spelled `PostgreSQL` or just `Postgre` and there is no official pronunciation. 
`Postgre`?! Oi vey. The original product name was Postgres. When SQL replaced POSTQUEL it got renamed to PostgreSQL. Postgre is a nonsensical name that I see occasionally, but have never heard or seen from people involved in the project. Postgres or PostgreSQL. source: used to be tangentially involved with the postgresql project many years ago.
&gt; Is this driven by some design requirement? by whatever &gt; What does "lighter" mean? Look at a dictionary 
&gt; There are some other web frameworks available, but I'm not sure what kind of state they're in or how they really compare to Phoenix in this regard. then what's your comment here for?
&gt; Phoenix is actually not ‚Äúheavy‚Äù. I'm not asking what it is
You ask for help and then respond in a most hostile and ungracious manner. His point is pretty solid. Plug is lighter. There is your answer. His warning that your boilerplate will make it not worth your while is also good info. If you wish to provide actual details as to what you‚Äôre building, the advice won‚Äôt be shaped as strongly. But you didn‚Äôt, which is why there is confusion. Do you want to scale your http connections more than Phoenix does? Perhaps you can check out Discord‚Äôs blog posts about how they scale. 
Hey everyone! Reviving my blog and put together a little post on how to still take advantage of Phoenix generators, even when using data types not supported by the generators. My case was PostGIS Point types. Anyways, I'm welcome to feedback both stylistically and technically. Hope it's useful!
What's your actual use case though. I didn't want to list out a bunch of libraries if they don't fit your actual needs. 
I think the easiest to being with is doing something like: https://www.postgresql.org/docs/8.1/static/sql-set-session-authorization.html The possible problems with using connection based approaches has to do with polling and if you or the adapter is doing that. It's possible to pass options to Ecto.Repo functions so I would look into that and if that works. I don't see any filtering which would hinder you: https://github.com/elixir-ecto/ecto/blob/e366b71f15593a8decd3733349c44599a4e12a91/lib/ecto/adapters/postgres/connection.ex https://github.com/elixir-ecto/postgrex/blob/master/lib/postgrex.ex
Bingo! For help! How did you help me to answer my question? Where did I ask someone to give me advice of whether or not I should do what I asked for in the first place?
&gt; What kind of app are you trying to build? that's none of your business
&gt; If you generally want specific help, you'll need to give more information. if you don't know what to answer -- don't answer
Postgres connections are expensive to establish, so you pretty much always want to use a connection pool to avoid that cost. So you can't just reconnect with the individual user role for each request, you have to use a role with higher permissions and switch the active role at each request. This approach is interesting if you want to use row-level security inside Postgres, but otherwise it removes the major advantage of DB-level permissions again because you have to switch roles inside the database. If performance and latency doesn't matter at all, and you can skip the connection pool, this would probably be a reasonable idea.
Don't be a dick
I'd suggest having the clients play over WebRTC, rather than passing through your server. It'll use fewer resources and be simpler to implement. In that case, your server just works as a coordinator. You can prevent cheating by having both players report the game's outcome. 
For my Phoenix &amp; Absinthe app, I wrote a middleware called Gatekeeper. I've thought about extracting it into a hex package. It works by passing a GateKeeper struct through the request, performs all checks at the beginning and caches that data for the resolver.
Well I am not yet able to figure out how I would have the basic structure going for a multiplayer game. Like how would the channels communicate with each other or their behavior on terminating and stuff.
try this [course](https://pragmaticstudio.com/unpacked-bingo). it's Elixir + Phoenix + Elm but you can apply the lesson of the Elm parts to React.
https://github.com/h4cc/awesome-elixir#frameworks Here is a list of web frameworks. I've read and heard good things about Sugar and Trot particularly. Also, if you're going to be quite rude when asking others for help I'd advise you stick to using google as that will give you the exact answers you want and you can be as rude as you like.
Seems this can help! https://medium.com/@stanbright/elixir-phoenix-partials-1df87c5eaea0 I think the word you are looking for is "partials" Cheers!
Hey! Thanks for the offered help. Elixir version: 1.5.2 https://github.com/Gurp1272/bar_stool.git Note: I have never used github. I'm not 100% sure I know what I'm doing. It is to my understanding you can clone my directory with that git repository I just gave you. I hope this is the case. If I am doing something wrong or you need anything else please message me.... THANKS
So the version of `hound` you're using (0.5.8) was written in a [craaaaaazy old version of elixir](https://github.com/HashNuke/hound/commit/a9b59793222cf6a3d8720642394d882d13e0fef5#diff-6023be6004fce4718dad3dafb576d258R7) - 0.13.0. I'd say the code that's failing to compile is just not valid in modern elixir. If you really want to continue down this path, I'd suggest starting the tutorial again, and using more recent versions of the packages it suggests. Packages can be found on [hex.pm](https://hex.pm/). When you search a package and select it, it will provide you with a value to put into your `mix.exs` file; for [`hound`](https://hex.pm/packages/hound), it's `{:hound, "~&gt; 1.0"}`. If you go down this path, it's very likely that the code provided in the tutorial will be invalid in places, and you'll have to search the docs for equivalent functions. [hexdocs.pm](https://hexdocs.pm/) will be your best friend here! You can access the docs for the [elixir standard library](https://hexdocs.pm/elixir/Kernel.html) there, as well as any package you find on hex.pm. [`hound`](https://hexdocs.pm/hound/readme.html), for example. Honestly, I'd suggest you just find yourself a newer tutorial! If you don't mind a bit of reading, and you haven't read it yet, I can't recommend the [official Getting Started Guide](https://elixir-lang.org/getting-started/introduction.html) enough. If you want to just practice a bit of elixir, you can't go past [exercism.io](http://exercism.io/languages/elixir/about). If you want something more project-y, just find yourself a similar tutorial, written in 2017+, or get yourself a copy of the excellent book _Elixir in Action_, by Sa≈°a Juriƒá (I'm not affiliated with the author or anything; it's just, IMO, the best book there is on elixir). Definitely, 100% keep trying to learn, though. Programming is an incredibly fulfilling skill to pick up. If you get stuck, come back here, or hit the [elixir forum](https://elixirforum.com/), where you'll very likely find help (often from Jos√© Valim, the creator of the language), or feel free to DM me. As far as git goes, it's an excellent tool for keeping track of the work you do. I suggest trying to commit your code when you feel like you've done a _chunk_ that you can describe in a sentence. Don't worry about all the extra stuff with branches and pull requests and whatnot until you get used to committing and pushing to github repos.
Don't be a cock
&gt; Also, if you're going who asked you to give advice?
Partials is exactly the opposite thing.
Hahahaha, this is awesome. April 1st is coming up, right? Wonder if I can figure out how to stream to the office PA.
Hahahaha, this is awesome. April 1st is coming up, right? Wonder if I can figure out how to stream to the office PA.
Sounds like a job for Nerves! 
You should understand the difference between programming language and framework. Elixir does not have layouts, blocks of anything similar. And Ruby doesn‚Äôt have layouts and blocks also. 
Just want to point out that you don't need Phoenix to mount an absinthe API; the [absinthe_plug](https://hex.pm/packages/absinthe_plug) package allows you to add a schema to a regular [Plug.Router](https://hexdocs.pm/plug/Plug.Router.html).
You should eat less and study more.
I'd take a look at https://hexdocs.pm/phoenix/Phoenix.View.html#render_existing/3. With this approach, I believe, you could create various contents (`header` in your example) simply by making a function `def render("header.html", ‚Ä¶` or the same template in that particular controller's directory.
Somebody pointed me to this comment and I would like to clarify the macro part is not quite true. Plugs are just functions that receive conn+opts and returns a conn. The contract is extremely simple. Building a pipeline of plugs is as simple as this: with %{halted: false} = conn &lt;- plug1(conn, ...opts), %{halted: false} = conn &lt;- plug2(conn, ...opts), %{halted: false} = conn &lt;- plug3(conn, ...opts), do: conn You can compose multiple plugs without any compile time behaviour. They can be developed and tested in isolation. However, there are macros in the Plug library, such as Plug.Builder and Plug.Router. But those are conveniences and not part of the Plug contract. The contract itself is very straight-forward. On the other hand, it seems Raxx implements all middleware at compile-time, so I assume you will end-up with more macro/compile-time behaviour.
The reason you can't have `content_for` work like in Rails-land is that EEx templates are actually just functions, and due to immutability you can't modify the context in which the template runs - you can only return a value. So, you have to either: (a) render the content ahead of time as a string or iolist, and pass it in to the template as an assign like `&lt;%= @my_content %&gt;`, or (b) extract the content into a partial and lazily render it as a child of the template using `render`
If using Phoenix, `render_existing` replaces the need for `content_for` in rails, so this is definitely the way to go
You work on sundays?
Why you gotta ruin my dreams, bro?
Ecto changesets are pretty nice for this.
There's always next year.
I am going through this course right now, and while it is helpful, I don't know if it will help OP unless OP already has some knowledge of Elixir / Phoenix.
lol you fucking prick, go away and don't come back
a few small things: * use .exs for things meant to be run as a script, and put the invocation at the bottom * are you going to do part 2 for these? your solutions are pretty clean, but mine were dirtier mostly because of part 2.
thanks for feedback. yes, I'm gonna do part 2 too, though just noticed, that there's appear second part after you submit answer:)
cool! i look forward to seeing more.
mol, you fucking cock, go away and don't come back 
There might be something useful for you here: https://github.com/mischov/meeseeks/issues/31
Binary garbage collection works differently than most other things in BEAM. Binary processing can easily end up creating lots of temporary binary strings (due to the nature of immutable binaries). Long story short, you will probably need a strategic `:erlang.garbage_collect()`. Here‚Äôs some background reading that might help. [Erlang Binary Garbage Collection: a love / hate relationship](http://blog.bugsense.com/post/74179424069/erlang-binary-garbage-collection-a-lovehate) [Erlang Efficiency Guide: Constructing and Matching Binaries](http://erlang.org/doc/efficiency_guide/binaryhandling.html) 
&gt; https://github.com/mischov/meeseeks/issues/31 That's a great reference, thank you!
Most of elixir seems to be written in erlang. Erlang is written mostly in C. C was originally written in something even lower, but now is capable of compiling itself, so no one needs to go lower than that. It is amazing how much code is involved with every little thing a computer does.
If you're curious how computer actually work, and what a programming language actually is, you should check out http://nand2tetris.org/
&gt; Most of elixir seems to be written in erlang Most of Elixir is written on Elixir. Only the compiler is written in Erlang and the so-called special forms.
Frameworks are like themed recipe books, e.g. for Japanese or Italian food, with many recipes in them, each one containing instructions for a robot cook(or plenty of them) to make some food. You still need to write some instructions to complete the commands. Libraries are like more specific book or tools, like "Knife techniques", containing stuff like how to cut fishes and tomatoes quickly. Programming Languages are the instructions themselves. Humans write those in human language, and they get converted to robot language by "compilers" or "interpreters", which then the robot takes it and executes to the T. Programming is mostly difficult because robots can't understand anything big by themselves, you can't tell them "cut a tomato in half" as they don't know what cut, tomato and half mean. You have to: * provide the tools, or make other robots provide them, then * give the instructions for them to pick the knife (and they don't know what pick means), * give some more instructions for them to recognize what tomatoes are (which itself is one of the most difficult problems in computer science, this is why we borrow libraries from recognition specialists). * Holding up the tomato probably requires a different set of libraries than picking the knife; then * the cut itself, requires instructions for arm position and movement. The "in half" parameter would tell the robot to move the knife to a specific position, based on the tomato size and format. Do any of these 1 inch wrong, and you'll have some expensive robot fingers cut off (which why you use fail-safes, and more libraries). It's turtles all the way down.
Yep. A high level programming language like C or Elixir will compile down to assembly (or be interpreted). Assembly is just a library for dealing with the circuits in a processor. So at the end, it's all just abstractions to make it easier to push current around.
Did you try to implement distribution via anything like pg2 (done this) or distributing the ETS tables yourself (haven't done this)? I'm curious if mnesia introduces a lot more overhead (for developer knowledge and code) for the use case.
After working with elixir for a while what do you feel are it‚Äôs limitations? I love the syntax of the language but I still fail to see what is going to make it stay around for longer than a couple years
I had considered distributed ETS originally but decided against going that route because I would be rebuilding much of what Mnesia offers out the box. Also I do not thing I could go the pg2 route(correct me if I am wrong) but because it is serialized so would not scale as a cache. Regardless of all that the hope for this library is that it does not really matter the underlying codebase as you don't really need to know about it. 
 All the above you mentioned are techniques for deployment, not languages. What type of code is running inside of your containers? Erlang excels at functional programming. There are several huge upshots, one is data immutability, Threading issues do not exist in Erlang. Faulty or incorrect data causes a process restart, and not a segfault. The cost of an error on erlang is a supervisor restarting a process. Super low effort. What happens when an error happens in your container? Or a threading issue in your c program? You restart the whole thing? That‚Äôs a super heavy handed approach. Now erlang is not the right language for lots of applications, what kind of application do you want to build? 
To add to what everyone else mentioned, the actor mode really is a joy to program when it comes to concurrent/parallel programming. Comparatively the mental overhead for doing CSP programming can be pretty high.
I don't have much more to add other than I just want to address a potential misconception. Elixir/Erlang are better for more than just backend application. I work on a project called Nerves which deploys an OTP/Elixir app to embedded Linux systems such as raspberry pi for example. This may just not be a use case for OP, but other readers may be interested.
DSL for finite state machines. Very similar to this one: [fsm](https://github.com/sasa1977/fsm) but with [GenStateMachine](https://hexdocs.pm/gen_state_machine/GenStateMachine.html) running under the hood.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/sasa1977/fsm) - Previous text "fsm" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Thanks!
Forgive me for ignoring the complete technical nature of your question but Elixir is fun. It is what I like to program and think in. And its still pretty cutting edge in the distributed data structure field. The gorgeous syntax and performant nature of the functional programming stuff is amazing to me personally.
If hot code loading is all you need, you definitely don't need Erlang or Elixir. However, you might prefer it. Even though a lot of container orchestration tools can emulate BEAM tricks at the application level, what happens when you need it at the VM level? I know microservices are all the rage, but they have the unfortunate quality of forcing you to consider things like fault tolerance and process isolation yourself rather than letting your VM handle it for you.
If you really want to go back in time to see why the concepts in this language are powerful go back to the early 70's with Prolog. While many languages iterated, trying to get it right from experience, functional languages tended to be specialized in purpose and founded from solid mathematic principles and proofs. Prolog syntax inspired Erlang and it makes use of the same sensibilities. This made the complex concepts of making concurrency reliable and scalable to program very natural. Go programmers for example may think concurrency is their ally but they merely adopted it. Erlang was born in it, molded by it. And now it turns out that old telecom reliability and scale is wanted in your average web project. Elixir gives you alll that as a next major step in that ecosystem. It's not about whether you can do something, it's how easily and what your projects will look like years down the road. The failure rate is incredibly low for that minority that adopts the stack because it encourages fewer mistakes and sensible scaling of code base. Even if it only makes you slightly more reliable and flexible than you otherwise would be, users notice. The problem space is farely wide for the BEAM and in and outside of work so it's a worthwhile added potency and concept as far as I'm concerned.
&gt; Threading issues do not exist in Erlang. Careful there. You can't actually get rid of "threading issues". At least not without getting some other kind of issue in trade. In Erlang, message passing and immutability have been pre-selected as the solution to "threading issues". This eliminates some kinds of problem and leaves you with other kinds of problem. Specifically, in exchange for threading issues, you now have distributed computing issues. Which are a bigger problem in general. That being said, Erlang does a pretty good job at giving you the tools to handle those problems, but the minute your system has concurrent execution things got irreversibly way more complicated.
Don't forget how it's promoted with the 99.9999999% reliability, yet almost nobody has reliability problems with anything else either. I have perl processes that have been running for years. And then there a lot of people promoting how fast it is, yet it's one of the slowest languages out there. It does preemptive multitasking, it's never going to be fast. I think some of the ways its being "sold" are wrong and very confusing. But I've decided to move forward with elixir for these reasons. 1. Its very fast with IO. (This is was one of erlangs requirements when being created). Which is what backends do the most of anyway. Ports make it possible to offload to a much faster language if necessary. Because a server side web app is almost all IO elixir seems fast. 2. Its a higher level language than golang, so you'll get things done faster, wont have 5 times as much code to debug. "Go" is short for "Go write some boilerplate" 3. Its high level like javascript, but you don't have to think about concurrency all of the time, like you do with horrible promises. 4. Its productive like ruby, but its explicit. With ruby you never quite know what's going on, there's so much runtime magic. Because of immutability and muggleness you can focus in on a block of code and not have to think much about its surroundings. 5. Phoenix, elixir, and ecto together is probably one of the most polished programming environments I've ever used. Rails is polished, but its performance is a trainwreck. Server side javascript is simply a dumpster fire.
So, I don't think hot code reloading is generally enough of a reason on its own to pick Elixir, and that there are far better reasons, but it is important to understand a fundamental difference between the container approach and Elixir's: Containers are treated in practice as inherently stateless. This allows one to tear down one container and replace it with a newer version . Elixir applications are allowed to be stateful. This is a fundamental difference that allows different approaches to be taken. For example to attain statelessness, container type applications will externalize their state. This creates more complex applications that are inherently slower than they need to be. It doesn't end at state, either. The idea of containers using traditional network socket connections to cluster, leading to complex systems of protocols that do not reflect the internal state / format of data while in flight, is another departure. Instead of non native API bridging and external state coordination, Elixir apps can decide to natively cluster efficiently. This is how e.g. Phoenix pubsub scales out effortlessly. So I think you are making some category errors in your comps, which is fair enough of you are still getting familiar with the tech. All THAT said, there are still other, perhaps better even, reasons for picking Elixir. Some have already noted a few of these.... 
 Now you are doing it. &gt; It really depends on the task at hand. If it doesn't require (many) mutations then there's no reason you can't get close to C performance, especially if you compile with HiPE. For example, /u/michalmuskala's json parser gets better performance than jiffy, which uses C, when compiled with HiPE. That's not really a fair comparison because data has to be passed to the nif, which creates a bottleneck. So that comparison has nothing to do with c vs erlang, but c-nif vs erlang. HiPE is nowhere near mainstream and probably will never be, I've been hearing about it for a decade... so any day now. It probably saw some easy optimizations and took them in that case. &gt; &gt; But ultimately, it's not the language to choose for computationally intensive tasks, but I don't think it's fair to say it's one of the slowest languages. I would say it lags a little behind Java and Go in terms of overall raw performance. I consider that a good tradeoff for the rest of what it offers. Lags a little behind Java and Go for raw performance? Hotspot is a beast, and it benefits from static typing, and Go is compiled and depending on architecture usually fairly well optimized. They might compare to erlang with pumping IO, which can only be so fast, but for anything else, erlang has scripting level performance, as should be expected.
&gt; HiPE is nowhere near mainstream Huh, isn't it just enabled by default everywhere? Definitely is enabled in official FreeBSD packages: ``` $ iex Erlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:16:16] [ds:16:16:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] ```
I think that means its available if you want to use it. I don't know if erlangs %99.999999999 reliability is guaranteed when using HiPe compiled parts. Here are some HiPe vs Java benchmark results, its not very impressive, and I don't think it ever will be, just because of the nature of BEAM, as I understand it. https://benchmarksgame.alioth.debian.org/u64q/erlang.html
Nerves is the shit! I haven't touched it in a while, how's the wireless module these days?
I maintain it and just gave it a ton of updates last week. It's getting a pretty major update once nerves core 1.0 is out
&gt; Specifically, in exchange for threading issues, you now have distributed computing issues. You will only get distributed computing issues if you are using distribution. But then, you will get those issues regardless of the language. You can still have deadlocks and starvation with Erlang/Elixir too. PS: not disagreeing, just clarifying.
Theres a really good video of [WebRTC and Phoenix](https://www.reddit.com/r/elixir/comments/5s2ipt/elixirconf_2016_webrtc_and_phoenix_when_%CE%BC_seconds/). But if you want to go with [Presence](https://hexdocs.pm/phoenix/Phoenix.Presence.html), you can have each user connect to a named channel, which has its own GenServer process attached to it. From there, you can use the calls made to the channel, like a router, to make requests to your GenServer and update/mutate/read state from that.
Erlang processes simulate distribution. Not being distributed has two benefits: - Your wire can't get unplugged, so you can ignore partitions. - You can share mutable state in shared memory, and thus have one single source of truth without a formal protocol beyond "use locks". On the BEAM, you start by giving up that second thing and committing to dealing with that part of distributed programming for every program.
I think you're more right than you realize. Erlang processes are *logically* distributed, which is the only thing that counts for CAP theory partition-tolerance. To clarify, you can actually experience *logical* partitions in the BEAM, at least in ways that are still CAP-relevant. In a VM with a stop-the-world GC (say, the JVM), you can have a network partition caused by GC. And for almost all systems actually out there, the definition of available is that it responds before the timeout takes effect. If you hit a JVM-powered database and it's busy and doesn't respond, your network between the two is logically partitioned. The core bits of erlang/elixir surface this concept pretty nicely when every receive statement with a timeout, but when you use OTP, a timeout is just an argument and defaults to 5s or so, and so a partition between 2 processes is lurking right under most GenServer calls. Asking if the process is alive isn't going to be enough to guarantee that the response from the other process is available (ie, the processes can be partitioned in the VM). To go back to the JVM example above, just because you can ping the node, and just because you may know (for some reason) the process on the other node is alive doesn't guarantee partition-tolerance between nodes. This usually happens with 1 very very busy process bottleneck on an overloaded system generally, but it's not worth littering the entire codebase with paranoid guards against this. Though it is worth thinking about backpressure in systems that will be expected to fully load a VM.
Eh, you can still use ETS, named processes and other local information without having to think about the complexities of the system if it was truly running distributed - where none of this would be directly available. Plus avoiding shared memory is also a requirement for fault-tolerance. If two processes share state, when one of those processes crash, you have no guarantee it didn't leave the state corrupted. So even if we didn't have distribution at all, we would still be promoting the second bullet because it plays an important role on building robust systems. Again, I agree that processes simulate distribution, but many of the design decisions behind processes are also requirements of other aspects of building Erlang systems. So I don't think the distribution aspect is generally constraining developers. The only aspect that maybe could be drastically different if we did not have distribution would be how we handle timeouts but I am not particularly sure there are better approaches. That would be something interesting to learn about. 
You‚Äôre obviously familiar with Elixir and functional process design so asserting that we cant get rid of every singleton bottleneck reader/writer process once inside the ‚Äúdistributed‚Äù flow of data i think Flow, GenStage, and some form of LASP, Presence or other aggregate root or CRDT data type (bluewater features for elixir all the way..) pretty much solve most of the distribution problems for the next 10 years or so. Many size cores with millions of actor processes on bigger edge pipes.
I'm variably familiar those technologies, and all of them present large tradeoffs (LASP has some of the most straightforward/robust tradeoffs, and I helped with the development of presence), and they really are not a way to make distribution of your program transparent, and there's some strategies around coordinated state that might be useful for local node shared state that might work like ets, but are not doable without nifs.
I am using Distillery. But I can't really ship ERTS with my release as my current setup is.
Include ERTS in your releases and you will be able to upgrade Erlang in production without drama. We have apps that have done that for years, going from 17 to 18 to 19 to 20. Erlang updates pretty frequently, more often than the stable packages that come with the OS. You can use the packages from Erlang Solutions, but it's better to build your own using a tool like ASDF. Then you can have multiple versions of Erlang and Elixir installed at one time, allowing you to test a different version from what you are running in production, then deploy it when you are ready. See this guide for details: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ 
For one project we are in the process of migrating dozens of dedicated servers from CentOS 6 to CentOS 7. We have found that it works fine to build on CentOS 6 and deploy the release to 6 and 7. If you are having problems, you are probably better off making a build box that's the same as prod. You may also be able to make a static build of Erlang with e.g. openssl included. One reason we do it this way is that we mainly develop on macOS, so we have to have a separate build box anyway. You can combine it with a CI system to generate the builds as well. 
This post is a little old now, but Boyd Multerer is working on an OpenGL driven GUI framework. It's supposed to be ready pretty soon. I've seen it in person and it is fast and looks really nice to work with. On the other hand you can do your ui code in C++ or C using QT framework, and communicate with it via a port or Nif or other mechanism, but this can be a pain. The issue with shipping a "cross platform app" is that the app will require installation of Erlang, or the app will require shipping with ERTS. This is a problem for cross platform due to linked binaries,cross compilation etc. 
You could build it in a Docker container that's identical to your production environment
I've been following CrowdHailer and his progress on Raxx for a while now. It's an interesting project and I thought this was an interesting overview.
wew. A self-hostable or open source discord alternative would be amazing. Even a chat+voice app that has dedicated voice channels is sorely missing from the likes of mattermost/matrix/rocketchat
Thanks Onorio! I want to let everyone know there is a bug when using Elixir 1.6 with Erlang 20.3, we are shipping Elixir 1.6.4 today or tomorrow.
I want to add elixirschool.com. Great resource.
Oh--glad you mentioned it! I will try to get 1.6.4 done quickly!
1.6.4 is posted to Chocolatey NuGet. I'm not sure how long approval will take but it should be available later today at the latest. Just wanted to let you know!
https://www.youtube.com/channel/UCOy-_b9bqjokoWX9Hg5ZgUg/videos
Hot reloading is not rolling restarts. If you have 3 servers all having long running (people connected for hours at a time you can change code modules without disconnecting a single person or routing new connections to the other servers whilst waiting for all the clients of one server to disconnect. Rolling restarts would either have to wait for people to disconnect (fine for short lived http connections for a web server but something like a telecoms system or even online game server would suffer badly) or kill people‚Äôs connections. I presume like other orchestrators the rolling restart stops sending incoming requests to an app which is due to restart, waits for existing connections to finish up and then updates and restarts. How would that work if the average connection duration was 20 minutes? (Instead of a second or so for a http request?) TL;DR - hot reloading and rolling restarts seem similar but if the average connection lasts 20 minutes (eg game servers instead of http servers) a rolling restart of 3 servers would take about an hour...) hot reloading lets an instance carry on serving whilst its updates (the app never stops)
great ! what are the benefits of it?
Anyone got a recommendation for top 3?
We use straight Plug in a few places (where we don't need templating, ecto, channels, etc) and it works fine
I would not focus on learning Phoenix. If you know Rails then you should be able to pickup Phoenix easy enough and I don't think it's worth your time. You should focus on learning OTP and working with actors. That is where Elixir really blossoms. If you are only working in single-threaded web requests you're missing the best parts of Elixir and the BEAM
Thanks for sharing this. If you want a link to the slides you can find them here http://crowdhailer.me/2018-03-02/raxx-refined-web-development/
Prefer module and import it there. Because you might end up with a lot of dead code that way. Those are macros that expand in compile time
[removed]
How would that help not end up with dead code?
When you define code inside the `quote`, you will have those functions being defined over and over again on every module that you `use` that functionality. If you use N times, you end-up with N definition, and each of them may or may not be used. When you define in a separate module and import it, the function is defined once and use multiple times throughout our application.
&gt; When you define code inside the quote, you will have those functions being defined over and over again on every module that you use that functionality. If you use N times, you end-up with N definition, and each of them may or may not be used. I don't think that's expensive at all. I'll be copy-pasted. 1Kb of additional space. is that it? from this respective, defining a module won't be completely free either.
Also harder to debug, especially in terms of stacktraces, increases compilation time, makes testing harder (you cannot unit test without defining it in a fake module before), etc. There is probably good reason to trust the Phoenix team if they say something is bad practice. But hey, it is still your call.
I wrote this post as an intro to a library that I might be spinning my wheels on. Here's a link to the bare bones docs: https://hexdocs.pm/moonsugar/0.1.2/api-reference.html#content 
it'll compile for 5 days?
thanks for sharing! Have you used the OK module? I find it very handy for pipelining ok/error producers ...
I actually really like with, but I wish it wasn't so finicky. It seems like I always make a mistake and the error message makes it very difficult to debug.
Not 5 days, but if you start editing web.ex directly in your workflow, it can make compilation times for the project slower. Later in a large project, if you have a few dozen controllers/views/etc, editing web.ex might make take recompile times up to a minute.
No problem! I have tried the OK module, I really like the ~&gt; macro that it provides, it is similar in use to my chain function, but results in cleaner code. Moonsugar's goal though is a bit different. I see it as a library that provides consistent utility functions over a range of data types, not just OK. Also, I made a point to avoid macros as much as possible. I think this makes it more likely to be used. It also helps folks unfamiliar with the library to still get the gist of what's going on. 
Working on a book on full stack development with elixir/Phoenix as the backend and react and redux on the front end
Yes, saw that your lib has a wider scope which is nice, particularly things like maybe types. I don't think the macro thing is a big issue, though, and makes for rather nice language integration.
how much slower?
"up to a minute or two" --&gt; do you mean "more"? how did you measure?
These aren‚Äôt attributes in Ruby sense. These are more similar to C `#defines` (these are evaluated compile time instead of runtime), so you need to think what you really need. 
Maybe just like this? ```elixir defmodule M1 do def var1, do: 123 def var2, do: 456 end ```
I started using `with` with parens and it is much clearer to me and I fall less into error messages traps: with( ... ) do ... end The formatter also supports it in the latest version.
One valid use is to compute a value at compile time and expose it through exported functions in the module for runtime code. I did that a lot when working with the language.
Finicky with formatting? Before I started using the formatter (all hail the formatter), I found myself doing this quite a bit to improve readability: with \ {:ok, foo} &lt;- bar() {:ok, baz} &lt;- oof(foo) do baz end Unfortunately the formatter clobbers that and insists on inline formatting (all hail the formatter). :(
Okay, nice article overall. Although I'd like to point that: `&amp;` is only used in function capture syntax, that is when you're using a lambda. Syntactic sugar is nice but useless and confusing in that case. --- &gt;Wowowo! What is all this ‚Äú@bot_name‚Äù and ‚Äúuse Stuff.Bot‚Äù. By now consider this a #worksOnMyMachine, Telex needs all this and we need Telex.Bot to handle messages :D Adding smileys and hashtags is not a good way to hide the fact that the reader/beginner didn't get what you just did. Take the time to explain, not in depth but at least what it means. --- All in all, It was a nice read. Thanks :)
I put together a summary of the talks along with my favourites here: http://underthehood.meltwater.com/blog/2018/03/21/lonestar-elixirconf-2018/
I also think using the $ prefix in function naming will cause confusion to many readers. `function_name/arity` is the way to name a function in plain text, I think it would be worth it to correct the many references in your article.
Use parens around the args, as I just posted above! The formatter keeps the parens in latest version.
Thank you! Just changed the way functions are named :D
Just changed the function naming and the paragraph you quoted, hope it looks better now ;)
Teaching is a great way to learn :) Writing blog posts will definitely help you understand things you use. Well done :)
Please elaborate on what you need elaboration on.. Dude, we're not getting paid to help you. Why are you acting like a jerk?
cock, you came here to tell me that you're not willing to help me and the way I should behave?
I know the formatter is new so hopefully this isn't heresy yet.. but I've stopped using the formatter in my code. I feel like it just uglifies everything.
&gt; it'll take it 5 days to compile? Yes. Yes I did. Look at the way to replied to "asonge". Do you think that's respectful?
I would expect you to be extremely familiar with OTP. Mix is just a build tool even if it is a damn fine one. As for Phoenix, it's really not that hard to pick up once you're familiar with Elixir, but without OTP knowledge, it's easy to structure your app wrong or otherwise misstep. I think I can narrow down my list of recommended reading to two: 1. [Elixir in Action](https://www.manning.com/books/elixir-in-action) 2. [Functional Web Development with Elixir, OTP, and Phoenix](https://pragprog.com/book/lhelph/functional-web-development-with-elixir-otp-and-phoenix) The former gets you started with Elixir and OTP. The latter teaches you how to apply what you've learned if webdev is the direction you wanna continue in.
x86_64 &gt;&gt;&gt;&gt;&gt; elixir but nice try (ayy blin)
A 2nd on OTP being of prime importance. :) Aside from that, perhaps the most useful thing you can do is to learn the ecosystem. Elixirforum.com is a great place to be, get familiar with hex.pm, the YouTube channels that carry conference talks ... they all contain the breadcrumbs to continue to progress. Also don't be afraid to use Erlang libraries in your projects, and be familiar with how that works in practice (:module.fun rather that Module.fun; functions that take charlists rather that bit strings; where if you have to implement an Erlang behaviour or similar you put it in src/ instead of lib/ ... things like that). There are so many fantastic libraries written in Erlang that are invaluable to many Elixir projects .. Hope you have lots of fun in your explorations! It's a great language and community ...
My experience has been that you can be productive by just learning Plug, Ecto and Phoenix initially, maybe also a job queueing system like Exq. The cowboy web server is already spawning a separate process for each request, and the Ecto Repo is managing a pool of DB connection processes. There's plenty of OTP stuff happening in your app - but you don't need to be writing it yourself straight away. Once your confident writing sequential elixir, you can take on OTP, distributed erlang, advanced macro metaprogramming, but it's the functional basics that are most important. 
Thanks man. Loved the Clif notes version of these and which ones you digged. Much Appreciated 
I freakin‚Äô love Randy. 
Yes I did. But there's no option for elixir. So I don't know how it helps. I used --js-completer.
Yes. Even after that, it doesn't work.
Damn it pragpub, why not letting us buy the Phoenix and Ecto book coming out in June.
That's what I said!
Depends on what I'm hiring you for. We're at this stage of growth in Elixir such that finding local candidates with substantial direct experience is still difficult in most markets, but finding people who want to learn Elixir is relatively easy. So primarily I'd look for some demonstrated desire in that along with substantial web development experience in something else. I don't want to teach you HTML, CSS, JS, etc. I don't mind teaching you a new syntax and some functional programming concepts in the first few months of a shift like that. If I'm hiring you to act as a team lead or in a position that requires more experience and I'm able to FIND you, either locally or because I'm able to hire remote, then I concur with respect to OTP‚ÄîI'd want you to be pretty familiar with things like GenServers, supervision trees, message passing techniques (which is more abstract than just what we do in BEAM applications) and testing with ExUnit. I don't think I'd expect you to be an expert's expert. But well-versed enough that my more junior engineers would be able to learn from you, and you'd catch glaring problems in a code review. In terms of learning, what I recommend is a quick readthrough of Dave Thomas's Programming Elixir, followed by Sasa Juric's Elixir In Action, which I found to be a great help in learning OTP when I started out in Elixir. Probably follow that up with Lance Halvorsen's Functional Web Development with Elixir, OTP, and Phoenix. Then, just write a lot of code....
https://gist.github.com/ConnorRigby/576b971be5bfbdd4fa4c0c3380b31fd1 I wrote the perfect code. It magically defines any function you try to write
Why are these threads always posted much later in the month rather than on the first? Always struck me as odd.
Using plug via phoenix or straight cowboy gives you one process per upload, done ;)
I want to learn Elixir, so I am working on a YouTube chat room web app, where multiple users can view the same video. Play, pause etc. should be synchronized among them. I thought using web sockets and Phoenix would be perfect for this app, as there can potentially be many rooms with lots of chat messages. Most of the work so far has been done on the frontend, but I am looking forward to more work on the backend. To learn Elixir I took the PragDave video course and I am now reading the MEAP version of Elixir in Action.
The Elixir Radar newsletter has a long list of jobs: http://plataformatec.com.br/elixir-radar/jobs
The market is small but growing, however there is also a shortage of experienced developers so it is a great time to learn. 
Trying to get Phoenix running on a local unix socket, proxied by nginx. If I can get it working, I'd like to perform a zero downtime deployment simply by updating the `current_release` symlink, and reloading the nginx config. After digging through plug, cowboy, ranch and kernel erlang, I believe I've confirmed that `:file.sendfile` doesn't work with a socket connected from a unix domain :/ Had to port my test app to C just to confirm it was possible at all :D 
Make your own. I don‚Äôt think your efforts here won‚Äôt pay off long-term. I haven‚Äôt run into any people complaining about Elixir/Phoenix dev
In Columbus OH there's at least one shop I know of that's moved over to Elixir from Ruby. They've been the hot place to work for a few years now, so I suspect others will start following their lead.
Exactly my thoughts!
You don't want to work for them. They're running terrible infrastructure behind Elixir, and they won't change it, so you'll likely be learning exactly how not to do things... Also they got bought out by a huge corporation which is slowly killing the startup culture that made them appealing to begin with
While the number of open jobs for Elixir isn't huge, we're at a particularly interesting part of the adoption curve, IMHO. We saw a very similar kind of growth happen with Rails in the late 2000's. What I see going on right now are a lot of "infection vectors" by which Elixir is introduced into larger companies: * Startups that use Elixir are getting acquired, introducing Elixir into the larger organization. * One-off projects to test viability of Elixir within an organization are turning into multiple projects * More startups are looking first to BEAM where they would have prototyped using Rails or Django or something like that previously. * A lot of side projects are growing up and turning into startups in their own right‚Äîwhich may eventually get acquired. This stage is interesting to me because its represents an inflection point in the growth curve. Its what I think of as the third stage of adoption, after pioneers (1st stage) and tinkerers/very-early-adopters (2nd stage) have pushed it far enough along that the new platform achieves critical mass. Ultimately, this leads to orders of magnitude more jobs, assuming the growth of the community doesn't falter and/or level off. While I don't think any new platform is going to own mindshare as completely as Rails did there for awhile, I think Elixir is going to share a large stage with some other very respectable contenders. Now is a good time to become active in the Elixir community, because when that happens you'll be well-positioned in terms of experience at a time when experience on the BEAM will be at a premium in the market.
I work for a company doing elixir development in Chicago. There are a decent number of elixir shops, depending on where you live or how interested you are in remote work. The elixir job board is probably the best place to start. I believe Chicago has 3-4 that are actively recruiting (including mine!)
I've had a job where I maintained two Elixir projects. The company used to have more, but the guy evangelizing Elixir fucked up and introduced it faster than he himself could keep up, so they were sunsetting most of their Elixir projects because they blamed the language/platform for the failure of those projects. In brighter news, I see new startups post listings for Elixir devs once in a while so maybe now is exactly the time to learn it to be slightly ahead of the curve.
I wrote an [ANSI to HTML](https://hex.pm/packages/athena) package based on something I had to deal with at work, formatting Cucumber output. I also created a new application at work that takes in last weeks user agent data(about 350k rows) from the production database, translates it, and inserts it into my Phoenix application. This application then serves up Javascript graphs based on different queries of that data so that we know what to OS/Browser combinations people are adopting and where to focus our testing efforts. It helps with seeing trends. I am unsure why we aren't using Google Analytics or the like. But still a fun project. 
This sounds really interesting! You got a link?!
It's really helpful for both inspecting data, and flipping args around if they aren't in the correct order. Glad I could help with that dumb little joke. 
Thanks for showing interest, helps with motivation :-) I don't have a link yet, but I can let you know when it is up. I expect to open source it soon‚Ñ¢.
very very very few
https://github.com/stepnivlk/pushex Pusher websockets client. Slowly getting somewhere, appreciate any feedback.
Do you mind PMing me the name?
Another more explicit way would be to define a custom type similar to the plug.conn struct. This han be accomplished with the defstruct keyword
Hmmm interesting- you‚Äôd still have to handle atom conversion thought right? What would be the major benefit ?
Yes that is true. I'd say the main benefit is that you'll end up with a defined struct where you can use enforced keys and therefore end up with a more reliable struct rather than a regular map Here is a hastily written example of how it could be done defmodule Pagination do @enforce_keys ~w(something)a defstruct page: 0, page_size: 30, something: nil def from_params(pagination, map) when is_map(map) do pagination |&gt; Map.from_struct |&gt; Enum.map(fn {key, value} -&gt; {key, Map.get(map, to_string(key), value)} end) |&gt; Enum.reduce(pagination, fn {key, value}, acc -&gt; Map.put(acc, key, value) end) end end params = %{"page" =&gt; 4, "non_existing_key": 100} pagination = Pagination.from_params(%Pagination{something: false}, params) IO.inspect pagination #=&gt; %Pagination{page: 4, page_size: 30, something: false} 
I like this approach. Define a module and struct with a `new` function which will cast and validate the string-keyed map, returning `{:ok, %SomeStruct{}}` or `{:error, reason}`. It allows you to clearly communicate throughout the codebase where you expect to be receiving validated struct data vs untrusted string maps.
Also particularly non-web/phoenix jobs would be interesting - Elixir/OTP only.
There aren't many, especially when compared to other technologies. My city (Melbourne, Australia) has roughly a handful (maybe a bit more now, since when I was applying was over ~8 months ago) of companies that I'm aware of that advertise elixir positions. I did happen to find through my job search quite a few companies with people on staff who either were interested in elixir or were already using it for some personal projects. However the amount of developers that already know elixir is also quite small, so even with those few companies they've even said they've had a hard time finding applicants. Another thing to note is many of those positions are requiring applicants to know whatever other stack of their's they used (or are migrating from). As there's even fewer companies that started with it or have completely replaced all their old tooling with it. This is to be expected though, as the language is still quite new (like Rust) and lacks the backing of some massive company (like Go with Google). So adoption will take time, as long as we keep getting success stories both with companies who've used it and developers themselves enjoying the language then that will change overtime. I think it would be interesting to see what portion of the community currently are just interested in it (haven't taken the plunge to learn it just yet), use it for personal projects, or use it at work. 
I'm im_bot-hi_bot
I may be a bot, but bots are made by humans &lt;3
I really don't see that this approach is solving any problems. `cast/4` already does this (in fairness, noted in the article), and if you want something that operates on other schemas its trivial to define a function that pattern matches on schema type or accepts a schema module to operate on. I'm also a fan of /u/mintcore's suggestion of a custom struct to handle the data. I would personally go towards an Ecto embedded schema, which again allows the use of `cast` to whitelist your parameters.
It depends on how large your project is. The one I was working on had about 20 controllers and changing web.ex would recompile almost everything (this was Phoenix 1.2 days, pre-Context) so it would be 2 minutes to recompile every controller, view, router, and schema every time you modified web.ex. This is why the `xgraph` command was added to mix. Debugging long compile times is important in large projects. If you isolate your stuff that you put into web.ex by using imports/aliases/etc in web.ex, changes in those shared behaviors can reduce compile times to between 5-80%, depending on how your project is structured.
I see! Thanks for the example! That makes sense, it is definitely an interesting approach. Do you mind if I update the example in the article to also include it? Since more people also seem to approve it. For me personally, I believe it is good to have a flexible map. The problem is only partially get rid of bad input, but also helping clean up your contexts. I can think of a couple times where it would be useful to add more things to that map later on, so I wouldn‚Äôt particularly be interested in enforcing only certain keys after params leaves the controller level.
[No, never did and probably never will](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454) :) 
CSS Selectors might not allow you to select nodes based on text, but XPath will. iex&gt; html = """ ...&gt; &lt;div&gt;abc123&lt;/div&gt; ...&gt; &lt;div&gt;&lt;span&gt;./---DeFfff/&lt;/span&gt;&lt;/div&gt; ...&gt; """ iex&gt; import Meeseeks.XPath Meeseeks.XPath iex&gt; Meeseeks.all(html, xpath("//*[text()[contains(., 'abc')]]")) [#Meeseeks.Result&lt;{ &lt;div&gt;abc123&lt;/div&gt; }&gt;] That's still not as flexible as allowing a regex though. [Meeseeks](https://github.com/mischov/meeseeks) tries to make defining custom selectors easy, so how might a custom selector mimicking the one in the post look? iex&gt; defmodule ElementTextSelector do ...&gt; use Meeseeks.Selector ...&gt; ...&gt; alias Meeseeks.Document ...&gt; ...&gt; defstruct value: nil ...&gt; ...&gt; def match(selector, %Document.Element{} = node, document, _) do ...&gt; children = Document.children(document, node.id) ...&gt; child_nodes = Document.get_nodes(document, children) ...&gt; ...&gt; Enum.any?(child_nodes, &amp;text_node_contains?(&amp;1, selector.value)) ...&gt; end ...&gt; ...&gt; def match(_, _, _, _), do: false ...&gt; ...&gt; defp text_node_contains?(%Document.Text{} = node, value) do ...&gt; node.content =~ value ...&gt; end ...&gt; ...&gt; defp text_node_contains?(_, _), do: false ...&gt; end {:module, ElementTextSelector, iex&gt; sel = %ElementTextSelector{value: ~r/abc|def/i} %ElementTextSelector{value: ~r/abc|def/i} Meeseeks.all(html, sel) [#Meeseeks.Result&lt;{ &lt;div&gt;abc123&lt;/div&gt; }&gt;, #Meeseeks.Result&lt;{ &lt;span&gt;./---DeFfff/&lt;/span&gt; }&gt;] A little involved, but no having to rely on implementation details to make it work. :)
I'm currently using `Meeseeks` as well for its support to XPath queries. I had to modify an already running project and frankly removing `Floki` just for XPath was not worth it. It took a few minutes to understand how it worked and having both html5ever as a parsing engine doesn't even make a lot of difference in practice. It's usually a good exercise to read other people's code and try to understand it to get better and better with the language. Actually what I did it's not even relying on an implementation detail, the implementation of `Floki.find(html, selector)` does not make assumptions on the type of the `selector`, it makes assumptions on whether or not HTML is a string or a parsed tree and then forwards the call to Finder which accepts a `%Selector{}` as input def find(html_tree, selector = %Selector{}) do find_selectors(html_tree, [selector]) end BTW I think that [lack of XPpath support in Floki is by design](https://github.com/philss/floki/issues/94), Floki aims to be minimal, not a feature packed parsing and querying library.
The particular implementation detail to which I was referring is `fl-contain`'s use of `=~`- it could just as easily use `String.contains?/2` and then that trick wouldn't work. 
You're right! And thanks 
Yeah, if you're not using Ecto at all I can see a need for something else to sanitize parameters with. I'm still sort of unconvinced a reimplementation of strong_params (which I never really liked in Rails, tbh) is the way to go over a controller- or use-case-specific sanitizing function. (Though having started out more than one project that bypassed Ecto only to reinvent it, poorly‚Äîyou'd have to work pretty hard to convince me that not using it is better than using it!)
Can somebody explain why I would want to run Erlang/Elixir apps inside a container?
London, UK is thriving with Elixir opportunities.
You could have multiple apps run on the same VM with different versions of erlang or elixir. Not really specific to elixir but dependency management seems to be one of the biggest reasons for using containers.
üòÇüòÇ Thanks for your comment- I think you‚Äôre very right to ponder if something like this should be implemented or not. To be fair, I also ponder a lot.
Because if you're on a cloud provider, like googles, and you're using kubernetes it trivializes deployment. Only time it might throw a wrench is if you're running an app that has clients with long lasting/persistent connections. But even then, it's usually find to just delete the old containers and let kubernetes redeploy them with the new image, then the clients just reconnect.
Does doing it this way detract from using BEAM languages? 
I think you avoid some benefits like hot code reloading, but I don't personally miss that for my development work. For me, the real beauty of the BEAM lies in the process and concurrency model.
Yeah, don't get me wrong‚Äîwhile I question the utility of it in most circumstances, its a nice piece of work. :) Kudos on putting it out there.
I am sure he is talking about the built in global registry.
Submitted my abstract for ElixirConf, would be nice to expand on my lightning talk. Going to start building out the API for the weather station, and maybe start the elm front end.
I took some time away from my project but I'm back to working on my Sci-fi real-time MMO with a Unity front-end.
For OTP 21, they are rewriting many of the file APIs to use dirty NIFs so there is a chance this is fixed. I recommend you to try out Erlang/OTP master and report a bug in case sockets are not yet supported on sendfile.
I think the course is going to be basic for you. Dave doesn't spend much time on data structures, standard libraries etc. because he assumes you're a programmer that I personally liked. Instead he takes an introductory approach how to structure your modules and applications (components/modules), which I found very valuable. For example if you need a chat GenServer you split that into three modules: chat.ex # API chat ‚îú‚îÄ‚îÄ impl.ex # Business logic ‚îî‚îÄ‚îÄ server.ex # GenServer This makes it easy to make changes to the business logic since you know exactly what is where. This is not very Elixir specific but I like that Dave teaches good programming practices even in his introductory course. It also makes testing easier since you can test the implementation without thinking about a GenServer. This chat module might even be its own application so that it could be reused in multiple projects instead of it being a module tied only to a Phoenix application. Some discussions [here](https://elixirforum.com/t/single-responsibility-principle-what-does-it-mean-to-you-and-your-elixir-apps/8704/5), [here](https://elixirforum.com/t/applications-are-components-aka-microservices-in-elixir/6884/10) and [here](https://elixirforum.com/t/discussion-dont-add-a-database-layer-to-your-phoenix-application/8623). While nice with a quick introduction to Phoenix (both request/response and web sockets) there are no videos on Ecto. You will definitely need another resource for learning Phoenix which was expected. Personally I still have trouble understanding OTP; especially supervisors but also GenServers, Tasks, Agents etc. That is why I bought Elixir in Action to hopefully get a much better understanding of OTP, which is what I think really sets Erlang/Elixir apart from other languages/platforms and what I am mostly interested in learning. TL;DR: you will know how to write and structure Elixir code into modules and applications but you will only touch lightly on how OTP with GenServers, Tasks, Agents, Supervisors etc work which is fair.
Good idea. I would suggest to follow along the lines of 4clojure. This is a good starting point imo. Here'source code : https://github.com/4clojure/4clojure . 
The original idea is on the elixirforum
https://elixirforum.com/t/a-free-and-open-source-online-elixir-and-phoenix-bootcamp/13032
The last suggestion was to use Elm instead of Vue. Let me know if anybody is interested.
I'm not aware of there being any safe/sandboxed evaluation environments for elixir, so you wouldn't be able to execute the code on the server. Two possibilities might be to grab the AST and write your own evaluator or walk over the AST and remove any illegal expressions before compiling and running. Although looking at the original elixirforum topic, it looks like you want to make Phoenix challenges. Which would just complicate things further. One alternative (but won't be able to be contained entirely within the browser) would be to get the user to add a hex package to their project for the challenge. That package could then setup the challenge environment (could even present it as a web page or do whatever really), and all code would then be executed on the user's local machine so there wouldn't be the same concerns like before. 
And it‚Äôs available now?
exercism.io may be a good place to investigate. They have an elixir course
Not quite a boot camp, but open sourced - [exorcism.io ](exorcism.io).
*exercism.io
That will allow them to run any code (even if you don't call any functions of the module explicitly, cause you have to remember elixir can have code outside of functions that gets run during the compilation stage). Which is a really bad idea given just how much functionality is self contained inside Erlang itself (and that's assuming you've sandboxed the entire VM and protected your server). They could run code to establish their own SSH connection directly to the VM, or they could grab all of your secret keys, or they could interact directly with your DB, or they could change the content being served to users, etc. 
You can use `Code.string_to_quoted` to convert elixir code into an AST. That's the easy part however, either evaluating it yourself (without relying on compiling and executing it) would take a lot of work. I wouldn't actually recommend it beyond the trivial stuff. Or doing the same and walking over the AST and filtering out any illegal operations. I feel like that's the more sane approach you could take. Given that all illegal operations will be from calling functions in certain modules, you could make a whitelist of modules that are allowed to be accessed. Then just walk over the AST looking for any function calls and seeing which module is being used. It would of course have to be a little bit more complicated than that seeing as they could make it a dynamic call (passing the module name to a variable and ten using that to call), or use imports, requires, aliases, etc. But if you also prevent them from using the Code module, don't allow them to use quotes, basically just block any way they could provide a string or AST with illegal code then it shouldn't be too complicated. 
How far will ExUnit take me in eval?
I seem to have found a sandbox. It's based on try elixir. 
ITT OP is dick
Cool. I did a quick search and there seems to be another [Exbox](https://github.com/christhekeele/exbox). It does say it's no longer maintained though, but it may have some other useful information for you. 
Thanks you for the thorough explanation! 
Hmm, wonder what they teach there...
&gt;The most obvious option for rest APIs in Django is DRF, which is an external package that acts as a framework on top the framework. Some people love this approach, some people hate it. You can build a restful API without the need for any extra package in Phoenix. As someone who has used both languages/frameworks, that's just unfair. You can build a rest api without DRF, it's just a matter of "why would I do that when I have DRF?"
I haven't tried this or anything but have you tried just doing: render("footer.html") 
For somebody unfamiliar with Django and DRF, what does DRF bring that Phoenix doesn't have?
It's great to see Phoenix contrasted to frameworks other than rails. I see the 'you don't need an external job queue' advice quite often, but rarely are the trade-offs discussed. Simply spawning processes to perform async work gives you at-most-once processing semantics. This is almost never what you want for a business application. If you don't want a dependency on redis/rabbitmq, then the safest place to put your async jobs is in the SQL DB you are already using. The backy and ecto_job packages make it pretty easy to setup on postgres.
idk much about the differences, maybe this might be useful https://elixirforum.com/t/comparison-to-django-django-rest-framework/8075
Haha. Exorcism. Did that but we need something for beginners.
At exercism, you solve challenges. Urdu for people who have basic knowledge of programming and have read official docs or have completed a bootcamp.
[Eh, Tobias... :D](https://i.imgur.com/8wkOGK2.png)
It can be very confusing to see Foxy talk about bunnies. I blame the others ;) 
Yup, the underlying PubSub functionality exports a direct_broadcast function: https://hexdocs.pm/phoenix_pubsub/Phoenix.PubSub.html#direct_broadcast/4 Here is how absinthe uses it: https://github.com/absinthe-graphql/absinthe_phoenix/blob/master/lib/absinthe/phoenix/endpoint.ex
For now bunny still works a lot like benchee. 
We will use this to convert the given command-line arguments into a structured form and validate them. 
 The key idea is to take the samples that make the overall shape of your data as similar to the original one as possible.
Through our investment in collaboration and innovation üí° we ensure the excellence of our product.
Yes, I know, I was talking about the typo. 
So what do you think: full stacks cert elm/Vue ( nyd ) + elixir phoenix
I liked how taskrabbit was the ad that was placed for me. 
Correct
Yes. 
I'm particularly fond of Tesla
Almost as if someone just wrote a thin wrapper around benchee as an excuse to post lots of pictures of their rabbits ``` () () (* *) o( 0 ) ```
Ok thanks for indulging me, if anyone ends up here out of context - this was an Aprils' fools joke. However, don't worry bunny is just a thin wrapper around benchee. It will remain usable if you want to have that bunnytastic benchmarking experience. Look forward to benchee 0.13 with memory measurements at your doorstop soon-ish (stilla blocker remaining).
However it is rather wrapper on other libraries, to provide easier interface, rather than JTTP library on it‚Äôs own. 
As is HTTPoison, as is HTTPotion....
+1 for Tesla, my client of choice for all my projects
Just about all of the HTTP client libraries in Elixir are wrappers around Erlang implementations: HTTPoison wraps Hackney, HTTPotion wraps ibrowse, Tesla and [Maxwell](https://github.com/zhongwencool/maxwell) have default adapters for Hackney, ibrowse, and httpc, so it's important consider the underlying Erlang libraries when figuring out which Elixir library to use. A simple rule for beginners to follow is: use something that wraps Hackney, because [Hackney handles HTTPS more safely by default than the others do](https://blog.voltone.net/post/7). Similarly, *don't use httpc*, it can be quite buggy- I am currently flummoxed by an issue regarding malformed gzipped body content of synchronous (but not streaming) responses.
[Heads up if you're using hackney](https://github.com/benoitc/hackney/issues/462)
This is particularly interesting to me. I have a Davis weather station on my roof, and right now get data out of it and online using WeeWX. Its not terrible, pretty good actually, but I've been meaning to get around to writing an elixir interface.
Hackney. Why bother with a wrapper for it when it already is extremely easy to use.
what's the downside of using a wrapper?
Not sure if this will help or not: https://joearms.github.io/published/2016-03-13-Calling-Elixir-From_Erlang.html
I haven't tried this plugin, but it's mentioned in the Rebar3 documentation: https://github.com/barrel-db/rebar3_elixir_compile
Unfortunately it runs into versioning issues when used alongside an application that also uses the Cowboy webserver (which is the default for Phoenix).
that's sad given it's been developed by cowboy authors. gonna check it, I'm using gun in a lib (without cowboy dependency) without any problems.
Apparently they just figured it out and pushed a fix for it. Spurred on by your comment maybe? 
For one, it‚Äôs a little bit extra overhead, but that‚Äôs generally negligible. The other issue - a common one for wrappers around erlang libraries, is that you potentially have to debug two layers of issues. ‚ÄúIs my problem how httpoison wraps hackney, or is the problem in hackney itself?‚Äù Both are pretty stable libraries, so I generally lean towards using the wrapper. Hackney may be simple, but HTTPoison feels just a little more comfortable. 
You are correct in your assessment. Generally speaking, use the simplest abstraction to solve the problem at hand. In terms of complexity, function clauses are simpler than behaviours, behaviours are simpler than protocols. Both function clauses and protocols provide polymorphism based on the data. I.e. they allow you to control the branch to invoke based on the data. Function clauses are more general but they are also "closed". Once you define the function clauses for a given module, you can't change them. Protocols are open and can be defined and implemented at any time. Behaviours bring you polymorphism based on the module name/function dispatch. They exist for documentation and they provide warnings and some static checking when using dialyzer. Protocols are internally implemented with behaviours plus a dispatch logic based on the data type implemented with function clauses. So it is implemented on top of the two other mechanisms.
I‚Äôd say it entirely depends on their perspective. Elixir solves a lot of problems that other languages struggle with and some problems that other languages don‚Äôt even know they struggle with. Aim your speech at the audience. Talk to them or think about it on your own and find the thing Elixir solves that they are (or don‚Äôt know they are) having issues with. 
On mobile sorry but there are a few Erlang/Elixir bitcoin packages on hex.pm and github so check there.
I guess you didn‚Äôt read the blog post? :)
Total beginner. New to programming though we might have something for experienced devs too..
This will be interesting because I don't think there have been really many Elixir/Phoenix resources aimed at a total beginner. Almost all material I've seen assumes you've seen something else (typically Ruby). You should, of course, really think of what you mean by a total beginner. A beginning 7 year old is not a beginning 20 year old. I'm sure I could read any intro material you have, and point out something that you're assuming a beginner knows.
Yeah. I'm thinking of writing a lot analogies. Aimed at a 5-yo. 
Lol nope my bad ü§ó 
In reality, Mesos, for example, would do the hot switch of your app to a newer version bootstrapping the new image in parallel with the current, and switch the traffic once the new one is healthchecked. On practice, the downtime was not really visible. Beside of that I would add that code hot reloading is quite a complex topic, and I find it quite easy to really mess up things here (but it's my personal experience with it, and I accept that more experienced... I would say more lucky people, had a better experience with it :) )
Isn't there a conflict between Docker containers being disposable and the focus on statefulness common to BEAM systems?
Agreed :)
While there are lots of things to love about elixir (the community, mix, hex, pattern matching, macros, ...) the unique feature is the concurrency model on the BEAM VM. Isolated processes communicating by immutable message passing, with a scheduler that allows thousands to run smoothly on a single core, automatically scaling up to use multiple cores, and a path to scale out to multiple nodes. Other languages can run on BEAM, but elixir has Ecto, Phoenix and other libraries that make Elixir the best for new projects. 
I guess I am just a little confused on the use for this library. For example in the github readme...is this not just as easy and more forward about what is happening: # def index(%{assigns: %{current_user: %{admin: true}}} = conn, _params) do # your normal function logic end def index(conn, _params) do # unauth end
Cool! One thing that confused me about GenServers is how they save state over long periods of time - if someone pulls the plug on all the VMs at once, how do you hold on to the data?
We're indeed not storing any data persistently right now, but since all Players' connections are through Websockets, they'll simply continue to try to reconnect in the front-end until the servers are back up. So if the servers for example take a brief nap for 10 seconds, the users in the front-end shouldn't really notice anything, other than some lag if they attempt to interact with one another during those 10 seconds.
Pretty neat. In other words, any important state that is lost during downtime is regained when players are able to reconnect. I wonder how this performs compared to periodically caching data on the disk and reading it back into memory when the servers restart. 
Indeed - this should perform rather well, but it's due to the nature of the service being realtime, such that it doesn't really make sense to store anything since we require that the user be present. As such, the 'persistency' just comes from them leaving the site open and thus keeping the websocket alive.
Glad you think so! We've tried to keep it that way indeed! There's not too many using it right now, as it only comes in bursts when we post it on league subreddit, so I can see how you could miss that :D 
Awesome! 10k Phoenix channels open I assume? What‚Äôs the specs on the server and what‚Äôs the CPU and memory load with 10k?
Yes - 10k websockets/channels. The server used for testing was [Digital Oceans 5$](https://www.digitalocean.com/pricing/) server, which has 1GB of Ram and 1vCPU. And it was basically a 'worst case' load, in which all Players matched with around 50% of other players, which in practise would be a bit much. I believe we hit around 500mb of ram usage, and actually hit a File Descriptor wall, which we stilll need to fix, rather than a memory wall.
Awesome, this might give me a reason to actually implement my shareplaywith.me for PS4. 
Nice project. Have you thought about moving the riot API app into its own hex package?
Not a terrible idea - will defintely consider it, although right now it is still somewhat tailored to our specific use-case rather than a more broad API integration. 
What are your pain points with php? 
how about submitting files to json api?
That's definitely tutorial worthy material. But to give you an answer, there is two ways to go about it: 1. If you want to remain a JSON purist, you can Base64 encode the file (at 33.3% more file size [https://stackoverflow.com/questions/4715415/base64-what-is-the-worst-possible-increase-in-space-usage]). Then simply send it as a string. 2. Have an endpoiint that accepts mixed content (application/json and multipart/form-data). I usually go with number 2 unless expected files are very small... still prefer number 2 though.
I saw you didn't find a good development API client, have you tried https://insomnia.rest/ ?
I want to register interest in a version with JWT auth as well. I'm a little surprised that you didn't use any of the Auth libraries from https://github.com/h4cc/awesome-elixir#authentication Any reason for that?
visual studio code and a command line lol.
The Elixir core team is working on a pure Elixir http client. So don‚Äôt write everything off just yet
Hey! How's your elixir learning going?!
I created a simple web app to extract text found in images. Feedback welcomed. https://image-to-text.edgardev.com
The goal of our http client is to be extensible, support HTTP 1 and HTTP 2 and be safe. It likely won't support pools by default, which makes it most likely not useful out of the box for applications talking to APIs, but it should be fine for one off requests. We want to make it extensible so we can write pools, GenStage pipelines and others on top of it. The master thesis /u/mischov shared below does seem to cover this aspect well - which is one of our main design principles.
This thesisys looks great! All in all, the article mostly cover ‚Äúwhat to do today‚Äù. I‚Äôll be happy to get one main way to make http communications in Elixir, and hope to make contributions to make this come true.
This thesisys looks great! All in all, the article mostly cover ‚Äúwhat to do today‚Äù. I‚Äôll be happy to get one main way to make http communications in Elixir, and hope to make contributions to make this come true.
Good to hear. Hit me up whenever =D
Hi there, I just pushed (meh) new version of pushest. My approach to a pusher client. It's getting more stable so feel free to check it (and the docs https://hexdocs.pm/pushest/Pushest.html).
Why would anyone use pusher with Elixir other than migrating off of it? What's the point of paying for infrastructure that the language can do?
Interoperability with apps written in other languages?
https://github.com/phoenixframework/phoenix/blob/master/mix.exs#L57 In master of phoenix it's fixed
Are you using Pusher as a message queue then? Why not use a proper message queueing service then?
I think providing a digestible chunk of a design pattern like this is naturally going to lead to that. Especially a design pattern focused around eliminating boilerplate by absorbing the boilerplate behind macro calls. This pattern very much emulates Plug, which is already a well respected pipeline based way to architect a web server. So I don't think the examples being a lot of code is necessarily an important factor in evaluating the pattern.
Plug was written to be initialized at compile-time. It makes sense, because you don't want to process options and initialize plugs on every request. That's mostly why the Plug pipeline exists. And even if you remove that, you could implement the Plug pipeline like this: with %{halted: false} = conn &lt;- plug1(conn), %{halted: false} = conn &lt;- plug2(conn), ... do conn end For your custom business logic, you could standardize on `{:ok, val}` and `{:error, reason}` tuples and that's it. There is no reason to hide your code, your logic and your conditionals under tons of macro code. The previous post from the same series mentioned Ecto and Ecto doesn't use any meta-programming when working with changesets. You will actually find that most Elixir code doesn't use macros for flow control and there is no reason why we should be promoting it here (unless you are doing some compile-time preprocessing, such as plug, which is rare).
Yeah, even though I defended the article I feel the same. I just didn't want the verbosity of it to be the only criticism, as its not really the reason that I think the design pattern has issues. I'd much rather see central_state_object |&gt; do_thing1 |&gt; do_thing2 |&gt; do_thing3 Or with {:ok, res1} &lt;- do_thing1, {:ok, res2} &lt;- do_thing2, {:ok, res3} &lt;- do_thing3 I've seen a few articles on design similar to this and for some reason I always go in w/ my hopes up that they've some how cleanly wrapped or solved for complex control flow. But so far none of them has :D
Not trolling. :) I have been following the series, thank you for writing it. However, I feel like this article missed the nuance that Plug uses meta-programming mostly because it wants to initialize plugs at compile-time. It is not about flow control. The blog post is very didactic but I wouldn't ever use this solution in practice without further considerations - which were not mentioned, such as compile-time initialization. See my other replies on this thread. 
I have not, thx. But I see it's a desktop app, I was looking for an in-browser solution.
Hmm I wasn't aware of that resource. And it surely is a BIG list... which one would you pick? As I said I'm just starting with Phoenix / Elixir and wanted to have a look at what was needed for building a simple authentication from scratch. I was happy that I didn't need that much! :) I'm a Rails developer and you also don't need much when rolling your own Auth, and there is little margin for error with libraries like Bcrypt. So, unless I have specific needs (like multiple login strategies [google, facebook, github, etc]) I usually prefer to roll my own and fully control my stack. 
I look forward to reading them :)
You didn't mention phoenix, we'll have to know if that's part of the plan. I tasked myself with learning elixir as quickly as possible to evaluate it for a project and I found that learning it broke up into 4 groups. 1. elixir: which is a pretty simple language because its so well thought out. So you'll get that out of the way quickly. 2. OTP, which you have to learn a fair amount of or you'll feel like an idiot because knowing just elixir gets you almost nowhere. 3. Phoenix: you might need to tackle this, and its more complicated than "minimalist frameworks", and you'll have to figure out contexts, a recent pattern that seems designed to confuse newbies. 4. ecto: you'll get nowhere in phoenix without this, and its not at all trivial. 
I would be working on some API services, so I would assume Phoenix will be involved, but am not 100% certain. My previous (year-old) experience includes Phoenix 1.2.5 (and Ecto), so I'll have to learn about contexts. I don't have much experience with OTP. Maybe I'll make a web app to re-familiarize myself with the syntax and the new Phoenix, then get back to learning more about OTP...
Phoenix |&gt; Ecto |&gt; Making a REST API with Phoenix |&gt; Deploying Phoenix But I'm also an amateur elixir enthusiast. 
^The linked tweet was tweeted by [@ElixirConf](https://twitter.com/ElixirConf) on Apr 11, 2018 01:54:40 UTC (6 Retweets | 10 Favorites) ------------------------------------------------- Release the hounds! Registration for ElixirConf US 2018 is NOW OPEN!! [https://ElixirConf.com/#registration](https://ElixirConf.com/#registration) [Attached photo](https://pbs.twimg.com/media/Dad3AdqU0AA7UQP.jpg:orig) ------------------------------------------------- ^^‚Ä¢ Beep boop I'm a bot ‚Ä¢ Find out more about me at /r/tweettranscriberbot/ ‚Ä¢
Seems you have good advice already for what to learn so I'll just mention; it seems to me there is no cause for panic. They hired you knowing they hadn't tested your full Elixir aptitude and knowing it's a newer tech, and like any dev job there will be some fast pragmatic learning required but don't be fooled into thinking everyone else knows everything about what they are doing. If the company is smart they hired you based on their way of judging conscientiousness, which since your asking your questions here I'm guessing you are strong. So good luck and feel free to message me if you have more to ask. I develop professionally (mainly with other languages but some elixir &amp; erlang). 
Thank you so much. What a relief this thread has been. This must be what imposter syndrome feels like. I might take you up on the offer to message you. I'm not hired yet, but if I get the next interview, I'm sure I'll have some questions :)
I'll echo others and say understanding OTP is probably on the top of the list. It's a fundamental part of how most Elixir projects are structured. If you don't already have it, I'd get Dave Thomas's [Programming Elixir](https://pragprog.com/book/elixir/programming-elixir) book. Helped me pick up the language fairly quickly when I first started.
Out of curiosity, what language is that service written in?
I need realtime messaging, I mentioned rabbitmq just b/c some of its features overlap a bit and I can see it being useful in my scenario at some point in future. I just wanted to say, it allows you to communicate with other apps while being quite a cheap.
It looks like you're using still using global under the hood. I may be missing something but because its still based on global if there is a partition in your cluster then you can end up in a split brain scenario where there are 2 versions of your singleton process. That may be fine for your use case but it would be good to document that somewhere in order to not mislead any potential users. I also may be missing something here so please correct me if I'm wrong.
That's probably true if you want to do server to server communication or have special needs with big loads because of lots of users signing in. In my case I'll be using my API for web clients, so I'm fine with http_only and secure cookies. I'll leave these here: * http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/ * http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/ I'll change my approach to JWTs when I think I really need them, otherwise cookies is the way to go for me now.
A thought: if they're purely an API it's possible it's just Plug and not phoenix. Plug is a pretty simple little framework! So don't fear, you could learn a lot about it in no time at all :)
Absolutely. I came from a small town to the city for these kinds of jobs and remember very well how it seemed at the time. Good luck, talk to you soon
Danke sch√∂n!
Yep, you've hot it right. I've added some commentaries to README on Github. Thank you! If you have any ideas about resolvig split brain - welocome with PRs
Our company recently put together a list of resources for our rails team to help them learn elixir. It might be useful to you as well: https://letoteteam.github.io/how_the_fulfillment_team_works/resources
No, I'm struggling with the same problem. Right now, the only option is to access it via REST using OAuth. See: https://firebase.google.com/docs/firestore/use-rest-api https://developers.google.com/identity/protocols/OAuth2ServiceAccount The underlying issue is that there's no solid gRPC support in Elixir, which is how other libs (Node, etc.) are using Firebase services. There's https://github.com/tony612/grpc-elixir but it's quite new, and probably because of that, no one has built on it yet. There's also some other stuff to read: https://medium.com/@KevinHoffman/mutual-tls-over-grpc-with-elixir-a071d514deb3 https://speakerdeck.com/tony612/the-way-to-grpc-elixir https://www.reddit.com/r/elixir/comments/4qrv6a/any_implementations_of_grpc_in_elixirerlang/ But for now, I'm planning on just using it via REST and revisiting the problem later.
While I like Elixir, I just imagine how this might be written in, say, C, and I feel that it would be shorter to write in C. Admittedly, that's because most of the article is not just about getting the task done, but other stuff are things we *ought* to be doing (creating a unit test, making a mix project, etc, etc).
&gt; Flapping tests are usually an indication of a race condition that is happening between the test suite and the browser under test. Many times, they occur because some asynchronous code is running and does not return before the test suite makes an assertion. This is super helpful. Thanks for writing the post!
You are definitely right that the goal here is not to find a simple solution but to explore tooling with a simple task. This code can definitely be written more condensed with Elixir. For example inline like this: ``` echo -e "ice cream\npizza\ncats" | elixir -e 'IO.stream(:stdio, :line) |&gt; Enum.map(&amp;("I like " &lt;&gt; &amp;1)) |&gt; IO.puts' ``` But then you are better off doing it in shell directly: ``` echo -e "ice cream\npizza\ncats" | sed 's/^/I like /' ```
I have found this article that goes with JWT for a REST API: http://blog.nathansplace.co.uk/2018/ueberauth-and-guardian Hopefully you'll find it useful.
Yes, this post is definitely not an introduction to all mentioned concepts (testing, repl, property tests, docs, ...). It is rather targeted at people that are already familiar with programming techniques and search for a quick example how to do things in Elixir. There is definitely room for another post explaining those concepts and when you would want to use them =)
If I were you I would maybe do a really quick refresher for Phoenix, like generate a 1.2 app and a 1.3 app with a JSON resource for each one and just take a quick look through each of them to see the differences. This will basically get you up to speed with contexts in like 15-20 minutes I think. One thing I would probably invest some time in if this were me is looking at Ecto queries in a little more depth. I don't use Elixir professionally, but I do use it regularly for a side project (as in, I probably hack on code a couple nights a week) and one thing that has never felt natural to me for whatever reason is Ecto. Not like you need to know every function for an interview or anything, but just in case they ask about repos and changesets or the two styles of making queries.. just to make sure you're familiar enough that you can talk about these things. Another thing I think I'd spend some time on understanding (again, if this were me) is applications. Very often when I add a hex package then I have to go and add it to my list of applications to start, but other than that I don't have much in-depth experience with them and I suspect that I should. I feel like if someone asked me to explain all about applications I'd just have a totally hand-wavy explanation, so if I were going into an interview this is something I might want to read up on again. If I were in a position to be hiring an Elixir dev to work on my project I think I'd want to ask them to explain how GenServers work. There's a lot more to OTP of course but I feel like if someone can explain to me what's going on inside a GenServer then they'll be able to learn and understand almost anything else. If you don't know how GenServers really work I'd recommend looking at Elixir in Action. There's a chapter in there that explains it very well in my opinion.
Nice post! Would love to see some throughput stats that we're captured or stats about the metrics system.
Thank you! I‚Äôll keep that in mind for the next blog post
Wrong subreddit. Our Elixir is "... a functional, concurrent, general-purpose programming language that runs on the Erlang virtual machine". 
Isn't awesome elixir already like this, or the elixir forum? Anyway look's like a cool project. I'll definitely try and contribute once I'm done with uni. Good luck. 
In a way it is, but this is focused on projects only. Each project includes a description, author, title, website url, and source code url. I want to make it easier to find and feature Elixir projects. 
Built with Elixir and the Phoenix Framework: https://elixirfiddle.com/ Not open source yet
Awesome, it doesn‚Äôt have to be open source. I will post it on the site. Thanks!!!
Elixir and Erlang have binary pattern matching for this purposes. Try to read this article, there should be answers to all your questions: http://www.zohaib.me/binary-pattern-matching-in-elixir/ Here is the binary pattern matching doc: https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1 TL;DR: You can take `a[i]` using something like `&lt;&lt;_::integer-size(i), variable :: integer, _::binary&gt;&gt;` 
You could fetch individual bytes out of the string like this but it's probably not the ideal way to sum the bytes in the line. A more Elixir-style way to do this might be to write a recursive function: defmodule LineSummer do def sum_line(sum, &lt;&lt;h, t::binary&gt;&gt;) do case t do "\n" -&gt; sum + h _ -&gt; sum_line(sum + h, t) end end end Then you can do: File.stream!("foo.txt") |&gt; Enum.each(&amp;IO.puts(LineSummer.sum_line(0, &amp;1))) This treats the binary a lot more like a list, with a head and tail. It's like instead of having `["a", "s", "d", "f", "\n"]` you have `&lt;&lt;97, 115, 100, 102, 10&gt;&gt;`. With a list you would pattern match it as `[h|t] = list` and then `h` would be set to `"a"`, but in this case we're doing `&lt;&lt;h, t::binary&gt;&gt; = line`.
I am working on a terminal animation haha maybe I will add it over here. I was also considering making an MMO as ascii terminal game before I asked myself WTF
Type safety, help avoid SQL injection, query composition, automatically casting/loading/dumping from the DB types to Elixir types, etc.
Thanks for the quick response. I agree with all of the above. I think what I meant by raw queries was using a specific dB driver for elixir. https://github.com/elixir-ecto/postgrex/ Just like one has node-mysql in node which allows to have control over the query and still provide (most) benefits you mentioned. I am not adamant about not using ecto. Was just curious what opinions some of you have. 
google 'why should I use an ORM'
Well thanks for the reply. Afaik, it is not really an ORM. Although it is close to one. Ecto is a domain specific language for writing queries and interacting with databases in Elixir. It is something similar to ORM (Object relational mapper) but the fact that there are no objects in Elixir makes this statement invalid. Anyways, sorry for the noise. This thread is relevant to this discussion. https://elixirforum.com/t/is-orm-the-only-way-or-the-right-way-to-design-and-deal-with-data/6562 
OmiseGO stack is mostly Elixir. SDK is already published. Blockchain part is in progress (previous iteration is at github.com/omisego/honted)
Ecto can be used as little more than a connection pool, just sending string queries to the Repo. From there you can use schema-less queries to compose larger queries from smaller pieces. Add Schemas and you can describe types and relationships. So on the Query side, Ecto gracefully scales from a minimal library to a clever DSL. Then there's Changesets and Multi for updates. Changesets are an alternative to the change detection mechanisms in traditional ORMs, since Elixir data is immutable. Multi composes many Changesets into a single transaction. Once you grok Changesets and Multi, they can be used to structure code into a more pure functional style, separating the construction of the update commands from actually submitting those commands to the database. Then there's validations, migrations, test sandbox, logging, ... Lots of great features that you can opt into as you need. The only reason I wouldn't use Ecto is it doesn't support joins between tables in different PostgreSQL schemas, which might be problematic when working with an existing DB that makes heavy use of schemas for logical namespacing.
Thank you for such a detailed response. Appreciated. :)
I t is not an ORM because Elixir doesn't have "objects" per se but it is still a relational mapper. The What's new in Ecto ebook talks about this too: http://pages.plataformatec.com.br/ebook-whats-new-in-ecto-2-0
I really enjoyed this, thank you for sharing!
I still think you shouldn't encourage its use in new tutorials like these, and should point to headless chrome instead, at least so the tutorial stays relevant a little longer :) 
My advice is to write it without Ecto once. Then rewrite it with Ecto and take note of how much of Ecto's featureset you implemented (probably with a less-than-ideal API). I had a couple of projects where I objected to Ecto's perceived bloat and balked at learning the full API "when i just needed to do a quick update." My experience was that I ended up implementing a less-flexible API than what Ecto gave me, doing a lot more work to shepherd my data elsewhere in my app. It only took me a week or two of experimenting with a low-level API before I tossed it and just used Ecto schemas when I needed the database, and embedded schemas when I didn't. Ecto really doesn't cost much to provide you with a great deal of functionality you should really be using anyway (if you care about your app at all, that is...)
Thanks for the write up. This is an interesting way to solve the problem. We solve it slightly different in Wallaby. In wallaby you use declarative queries that describe how the DOM \_should\_ look and then Wallaby handles and the retry logic and blocking until that query either returns successfully or times out.
The [most recent Achemist Camp episode](https://youtu.be/m2NGQ9qnYsc) is on exactly this topic and covers a few different ways of doing it.
 I don't know... [Alchemist Camp](https://alchemist.camp) has over 50 free elixir learning screencast on the site and over 70 on YouTube. AFIK, that's far more than any other resource but awesome elixir still doesn't list it, but they do discontinued series, paid only screencast and in some cases ones that are badly out of date. It seems like it's a bit of an insider's club.
This talk was presented at ElixirSydney, to an audience of... tens of people. :D 
Thanks for the link. I don't agree with their sentiment exactly, but I can see why it's viewed as a valid stance.
1) Your player needs a real volume control, not just mute 2) Links to items from the podcast should open in a new tab (I lost my place more than once trying to follow along -.-) 3) I'm brand new to elixir and I have no idea who you two are, and it seems like you're not just two randoms in the community.. maybe an introduction would be a good idea? Other than that, it seems like you've done a good first episode.
Cool project - keep up the good work. Feel free to add https://elixircasts.io
Will definitely do, thank you!!!!
I just added more projects, thanks to everyone who submitted them. More features coming soon. 
Thanks for listening! Just wanted to address your comments: 1. We don't control the player. Its provided by [fireside.fm](https://fireside.fm) the service we use to host the podcast. I'll mention it to them though. We've been accepted to itunes \(and the google play store and spotify I think\) so you'll probably have a better time using an off the shelf podcast app or player. 2. Basically the same thing. We just submit markdown. I'll see if we can use an alternate syntax for links so they open in a new tab. 3. We'll try to do a better intro. We really want it to be very conversational which is why we didn't do anything this first time. We just started recording as soon as we opened zoom. We're not far away from rando's anyway. Just rando's who have been around the community for a while.
People choose it because it scales really well so if you had a project where you solved solutions around scaling you should highlight it. Numbers of concurrent users, how many nodes, what you did to distribute. Totally made up paragraph: "I wrote an online voting system that was required to handle north of 200.000 votes per seconds. I've built performance tests to prove it would hold up under load and figured out how to best spread the load over different nodes. The system performed fast and flawless with a peak of 850.000 concurrent voters over 4 nodes, backed by a single machine running a GenServer".
Why not make your resume in Elixir/Phoenix!
If I were evaluating someone's experience in Elixir I'd want to know in what capacity they used it and where they are in terms of understanding. Was it full-time? Do you understand OTP? What kind of scale did you work with? Did you have a hand in deployment and machine configuration? Was it a single node or multi-node setup? Do you have any open source contributions? How comfortable are you with the Erlang ecosystem? Elixir is still pretty new and finding people with experience is tough. If you have experience though, it's good to surface how deep that experience is (e.g. are you a beginner, intermediate, or expert?)
Full disclosure: I'm a technical cofounder at a startup currently, I designed and built our entire backend platform in Elixir with Phoenix, and have been an engineer and hiring manager at various points in my career. My 2¬¢ is that I would avoid characterizing yourself as a "StackX developer". To me, this raises a red flag every time I see it. If you're experienced and capable, I would suggest characterizing yourself as a "software engineer" or, if you want a narrower focus, a "distributed systems engineer". I see that you asked, "What skills...", so I think you're already probably thinking in this direction, but I just wanted to call it out specifically because I feel it's really that important. The kind of person a company is looking for varies pretty widely, but my own tendency is toward people with a variety of language experience and solid fundamentals. I would highlight your understanding of distributed systems, functional programming, databases, and cloud architecture over any specific focus on a particular language (i.e., "I know Elixir, Phoenix, Ecto, and ExUnit", or whatever). To me, when I see "Node developer", "Rails developer", etc., it gets translated in my mind to, "I don't have depth or breadth, but I make up for it by being able to recite trivia about this language, and it's the (only) one I know how to get things done in, or am willing to work with". This is admittedly not very fair, but it is an interpretation based on many years' experience working with people who identified themselves in this way. Another way to frame it might be to echo what others have said‚Äîdo you understand OTP? Processes, Supervisors, and GenServer? I would argue that if you do, you're a capable distributed systems engineer in general, because these principles are the same whether they're at the architecture level (e.g., Kubernetes, etc.) or the application level, as is the case with Erlang &amp; Elixir, so calling out Elixir specifically doesn't really add a lot in my opinion. Ultimately, my point is that from a hiring perspective, I'd prefer a resume that highlights an in-depth understanding of fundamental distributed systems design (concurrency, streaming patterns, queuing patterns, etc.), functional programming, database design, and modern cloud architecture (containers, container orchestration, etc.) in *any* language over a resume that highlights that a person "knows Elixir". If you have the skills I called out, learning Elixir won't be an obstacle to you, but if you don't, knowing Elixir won't help you. 
JavaScript.
Here's to the randos! :)
This is a really cool project to see and makes me want to open source the next Alchemist Camp side project!
Knowledge of Erlang syntax &amp; NIF implementation is helpfull too
did you just spin up 200k processes?)
Thanks
Welcome!
Yeah, that would be great. I'm not sure how to do that with the CodeMirror (the JS code editor). It does do syntax highlighting and a bunch of features but I'm not sure how to work the autocompletion for Elixir. Any thoughts on how to do it with [CodeMirror AddOns](https://codemirror.net/doc/manual.html#addons)?
I would love some input of my situation. I am an "iOS Developer." Self taught, never taken a CS college course, and never coded outside of Apple's IDE, XCode. I would like to break out of mobile/frontend development and move towards backend development, and of course have considered Elixir/Phoenix. I'm currently a lead dev at a large, Fortune 500 company. Is Elixir an appropriate path for my first experience in backend development? Or is it too much to take in at once? Ideally, I would build Elixir projects on the side until I can find a opportunity that would pay comparable as my current role. It may take a couple years of personal project, but I'm okay with that. I guess I wondering if I will understand the void that Elixir fills without ever understanding the problems with more traditional backend languages and frameworks. How can I make the best of this situation and be an attractive candidate to someone in your position? Thanks!
thank you, I'm glad you like it. I will continue to add features. 
This is a thought-provoking question with many layers that strikes a chord with me on a personal level. I wish more than anything that I could give you a Medium-like "5 Ways to Achieve Your Dreams in Tech", but life is often about nuance, subtlety, and resilience and rarely about n-point plans. You usually end up having to do a kind of controlled slide gradually toward your goal, trying to figure out how to turn things outside your control to your advantage by adapting to _yourself_ to _them_, rather than fixing a point on the horizon, forming a checklist, putting your head down, and marching to the end, blasting through every obstacle. That being said, I'll do my best to share my perspective here and I hope it helps you! First, and this is just a subjective opinion, I'm not sure Elixir fills any void, really. I _love_ Elixir, and have enjoyed working with Erlang, too, in the past, but the problems that they solve also have other solutions nowadays, like Kubernetes, which is effectively the same kinds of things the BEAM and OTP were designed to do applied to cloud infrastructure and containerized applications, and serverless computing, which takes a different approach, but still solves many of the same problems. I suppose if Elixir could be said to fill a void, what it really provides is a) an on-ramp for developers with experience using modern languages like Python or Ruby to build web applications into the world (and mindset!) of building distributed systems in general, and b) language-level (rather than infrastructure-level) primitives and libraries for designing and crafting modern distributed systems. That being said, I don't think Elixir is too much, no. If anything, I think in many ways, Elixir makes learning these concepts a lot easier by bringing them all together and approaching them as core, fundamental building blocks. You _can_ build a fault-tolerant, scalable distributed system in Python or Ruby, but you'll lean hard on tools and techniques _outside_ the language to do so, whereas with Elixir, most of those are built right in. You can get _incredibly_ far with just OTP and EC2 instances running Elixir and nothing else! In any case, if you had to learn every technology that ever was just to understand the ones we use today, well, I think we'd all be in a lot of trouble! üòÜYou're also not trying to master every detail‚Äîyou're trying to acquire the capability to land that first opportunity. After that, you can continue to build on your understanding. Being self-taught myself, one of the most important things I've discovered (which you probably know, as well) is that if you find something you _do_ know and are able to connect it in some way to something you _don't_, it makes learning new things much faster and helps the concepts stick with you longer. So, being an iOS developer, I would recommend starting with processes, threads, and dispatch (https://developer.apple.com/documentation/DISPATCH) within iOS/Swift, then move toward functional programming and try to apply the principles of functional programming in your current work. From there, you have a solid general conceptual framework to hang _new_ concepts off of, and can jump over into distributed systems, since you would be doing fairly similar things at a small, app-level scale to what a distributed system does at a large, cloud-level scale. You get the added benefit using your existing work to prepare for the work you want to do _next_, something that I've done many times and still do. From there, I think focusing on Elixir is a great idea. You _could_ also use serverless (https://s3.amazonaws.com/awslambda-reference-architectures/mobile-backend/lambda-refarch-mobilebackend.pdf) as a similar kind of learning tool, since even though you'll need an ability to _write code_ at a high level of detail, you'll also need to _design_ your solutions at a large, systems-wide scale, and this is what many engineers miss. But Elixir really brings everything together very nicely, so I think it's perfect for this task. While you're learning, I'd say try to avoid using libraries as much as possible and use the language and OTP to solve problems. You'll be reinventing the wheel a lot, but remember, it's not meant to be production code and if the goal is accelerated learning, handcrafting everything yourself will support that best, in my opinion. *Constraints like this force you to focus on understanding and solving the problem yourself.* Build a mobile backend for an app you made with just Elixir, ETS, Mnesia, and the rest of OTP and you'll learn just about everything you need to know that way. It's not so much about the tool, but _what is this tool meant to solve_, and thinking in this way will help you translate your skills across different stacks more easily. Stick to it, concentrate on developing your capability, and the opportunity will come. Some useful links: https://elixir-lang.org/getting-started/introduction.html (of course!) https://www.manning.com/books/the-little-elixir-and-otp-guidebook (my personal favorite Elixir book) https://github.com/donnemartin/system-design-primer https://github.com/checkcheckzz/system-design-interview https://github.com/binhnguyennus/awesome-scalability http://www.redbook.io/ Also, there are so many great talks, screencasts, etc. out there on Elixir, it would be pretty difficult _not_ to learn if you just dive in, and the community is *amazing*! Hope this helps, and good luck! 
I wrote a library to allow snapshot testing of json web responses https://github.com/sb8244/elixir_response_snapshot
What do you expect this line to return? :proplists.get_value(nd_nm_char_list, node) :proplists.get_value(999, [{'price', 999}]) It returns `:undefined`, You are passing `999` as the value for `nd_nm_char_list`. There isn't anything related to a closure here.
&gt; You are passing 999 as the value for nd_nm_char_list I'm not passing it
I got the same understanding as /u/haqkm. Can you put the whole contents and variables in a file we can execute with `elixir path/to/file.exs`?
Hi!! This is a really valid point :) I centralized all the macros and "heavy lifting" in `Errol.Wiring` precisely not to have the DSL take over your codebase, just define the *wiring* and let the rest of the implementation be about passing functions around. I don't see an easy way to use behaviours to define this and still have the supervision tree set up for you, but if you have a clear idea I'd love to see an issue proposing an alternative DSL going in this direction! I didn't want to force people to use macros either, that's why the `Errol.Consumer.Server` module is also fully documented so you can start a consumer on your own without going through this DSL. The reason to have this macros is that I wanted your `Wiring` modules to be compiled into a `Supervisor` that you can then handle/supervise/start the way you prefer. Another proposal for defining consumers would be to use something like: ```elixir &amp;UsersConsumer.account_created/1 |&gt; consume("users.account.created") |&gt; bind(""account_created") ``` but you wouldn't be able to use this macros on their own I didn't see the advantage besides making it look more like *the elixir way*. Thanks for the feedback! It's very much appreciated :)
Great little project and write up, thanks!
The Scrap Exchange is definitely a treasure :\) Thank you for the tip about the services page \-\- fixing it now.
Gotta ask. Is there a real-world example where property-based testing is useful. To me one test-case is usually enough. Mathematical induction kinda way. If it works for one or two, you can assume that it works for all. Also I'd imagine that doing a lot of property-based testing would slow your test-suite quite a bit.
From the top of my head, I can pick the following example. Suppose you are saving the payment details of a user. Those details consist of Cardholder name, last 4 digits of credit card and an expiration date. You write the test and use "John Doe" as a cardholder name. Everything works fine, until one day some user decides to an emoji in the cardholder name. And you get: ``` "Incorrect string value: '\xF0\x9F\x94\x94' for column 'cardholder_name' ``` Could you prevent that kind of errors, yes for sure. If you think of emoji before releasing the code. But I guess in most of the cases you (not you exactly, hypothetical you) won't think about every possible case. If you have a proper string generator to use in your property-based tests, that might help to catch the case and maybe some other. Even if you think about special characters in the name, you need to provide several tests to cover all those cases. Again, property-based testing may do that dirty work for you. And reduce the number of tests. Is it slower? Yes, sure. The testing is all about trade-offs, sometimes you may want to sacrifice the tests execution time to get more robust coverage. Of course, that does not mean you need to use property-based tests everywhere. 
Even the emoji example still requires you to create string generator with emoji case in mind. So I'd just create a test case with emoji input.
Even though, you do it once for many property-based tests.
Yeah. I think it's a matter of having a use-case when you need generator of inputs that can cause edge-cases and you can apply it in many test-cases. So many cases.
This video tweeted from the elixir-lang account a couple days ago is a very good example: https://www.youtube.com/watch?v=AfaNEebCDos The stream_data repo also has some examples of properties that were used to find/understand bugs in Elixir itself: https://github.com/whatyouhide/stream_data/blob/master/test/stdlib/string_test.exs
Nice. Those are great examples.
Nice!
First time hearing of alchemist.camp. Looks nice!
If my wife wasn't in school I would totally apply. I love Germany! 
That's very exciting! Have you also announced it on the [Elixir Radar](http://plataformatec.com.br/elixir-radar)?
Yes, I have :)
That's too bad! Once she finishes you should check our website, we always have new positions available.
Isn't it possible to just update the article in place?
&gt; past data can be used in the future in ways that aren't immediately apparent If only all devs thought this through. Thank you!
Instead of using render, just use: html(conn, html_content) [check the docs](https://hexdocs.pm/phoenix/controllers.html#rendering) for more info.
They said the talks would be available within the next month. Check their YouTube channel regularly to find out when they upload them https://www.youtube.com/user/ErlangSolutions, but I'd guess they'll be posted in this subreddit as soon as they are available.
First video from Lambda Days (also organized by Erlang Solutions) were published after one week, the last video after month. So I guess with Elixir Conf will be the same
ah...icic
Love me some HTTPoison. One thing I noticed is that your require Logger is not in a module but global. You probably want this in the module: https://github.com/f1sty/retall/blob/master/lib/github.ex#L1 https://elixir-lang.org/getting-started/alias-require-and-import.html#require In the iex examples, they're globally applying it; this is good for demo but not best practice.
Thanks for your feedback. Yeap, gonna fix it. Also this is escript is more like on a prototype stage, so there is still much more to fix:)
I &lt;3 U
The [unicode module in Erlang](http://erlang.org/doc/man/unicode.html) supports converting to and from unicode and that's it. Elixir doesn't have something like a Latin1String module that works on latin 1 - although one can probably be implemented by hand without much work.
Awesome post. I hadn't read the series so I thought "hey, is that the hexdump guy?" when I saw the hex dump
Easier than supporting Big-5, for sure!
Well, it supports unicode out of the box, but as you can see in the article you can convert from ISO-8859-1 to UTF-8.
https://www.youtube.com/user/ErlangSolutions/videos The first few videos just went up, figured you might not get a notification on youtube but might here.
oooh bootstrap, yeah that makes sense. It's hard to tell. 
The sheer amount of work required just to get the project going is staggering. So I suggest you begin anyway. Then show us the progress or if bored/failing ‚Äî you can quietly drop it.
I love this idea. Some of dialyxir's messages are baffling. 
If it's successful outside Elixir then it could be, but there are significant technological challenges with doing so (and why it hasn't been done). There is a PDF paper out there explaining why success typing is the strongest type system possible for the Erlang VM but I can't find it at the moment. There's also a EVM vs JVM PDF that's pretty good as well (on my phone so hopefully someone can link them).
In general, I think this could be done to a degree. The biggest technical challenge are process boundaries since sending a message is basically a type information void. You'd lose type information anytime you cross a boundary, local or distributed. Same goes for apply calls since the function you're calling is often a runtime value and can't be verified at compile time. If you scratch those things (and maybe any others I've missed), you may still be able to get something useful out if it. Just don't put the expectation that you'll have an Elm quality, fully type spec'd compiler because until you can find a way to computer those runtime boundaries at compile time, it won't happen.
I would be really interested in reading that PDF if you have the time to find it. I guess I'm not sure what you mean by "The best possible for the Erlang VM". As far as I know, the VM can be completely separate from the type checker. For example, flow type is a powerful JS type checker that's built in OCAML. Obviously, I would like to write the type checker in Elixir if possible, but it seems to me that the Erlang VM shouldn't add much in the way of road blocks.
Great point about process boundaries. That has been in the back of my mind since I decided to start looking into this. I wonder how other strongly typed languages handle this. I think Scala with Akka is pretty close to the OTP model in some aspects? Maybe I'll give that a look-see.
&gt;They're referring to \[the original paper\]\([https://it.uu.se/research/group/hipe/papers/succ\_types.pdf](https://it.uu.se/research/group/hipe/papers/succ_types.pdf)\) on success typing, but they don't make nearly as strong of a claim. It's worth reading regardless, imo.
There‚Äôs a PR in progress to make them better. https://github.com/jeremyjh/dialyxir/pull/118
I guess you're already familiar with the Elmchemy project?
Another great write up! Keep up the awesome work! 
I recommend you to read the recent discussion in the forum: https://elixirforum.com/t/how-to-make-dialyzer-more-strict/13854/33 As Jos√© and others pointed out, it is unlikely you can convert typespecs to a ML-type system such as Haskell / Elm without having to compromise on something, such as type inference or the amount of typeable Elixir code, as typespecs are much more expressive than ML-types.
Thanks Dave!
Nice project... :) I see that sandbox Lua counts function calls in the sandbox, and tries to limit functions that can allocate large blocks of memory ... that's great already. Have you also considered wall-clocl running time and memory usage? The former would be easy from the elixir side, the latter with ulimit's on the ous sandbox ...
I faced a similar problem in the past with a library I was making, where I wanted to show relationships (including messages). The way I decided to handle it was to create files which could contain a list of matches, that would match against the arguments passed into a gen* modules message sends. While that served my use case just fine, for a typing tool it would only solve half the problem. Another issue that comes up is you won't necessarily have access to the typing information of the destination. As you can send messages to a server that isn't an explicit dependency of the project sending the message. And then there's the whole issue of runtime generated code. But as you gave the example of wanting to make it work like Elm's static typing, maybe you could solve all of these problems the same way as Elm handles ports. So essentially just treat it as a blackbox. Although then you're basically just ending up with dialyzer again with the exception of better warnings, and forcing that everything needs to be typed. 
Yes sorry, that's more accurate.
You can actually already pass in timeout and reduction values to limit it I guess based on the code examples in the repo. https://github.com/rvirding/luerl/blob/develop/examples/hello/hello_sandbox.erl As for memory consumption. I may be alright because scripts in my case are supposed to execute in under 3 seconds or die, but will probably still look for a solution down the road. My solution will probably revolve around the sandboxed code running in its own beam process that I can track memory on / kill if needed.
I'm reading some Erlang books that will help with running production services. Namely Erlang in anger and the recent happi book that was posted here. Learning about GC and things to avoid has been very enlightening.
That's a clever way of logging in to a site.
I love this article. 
Doesn't pg2 use global which basically means joining a group puts a lock on all nodes?
It's missing at least one: crash a NIF.
good shit. i've been keeping my eye on beamjit since i heard about it.
That is 100&amp;#37; correct, but since I never did that myself \(I never wrote a NIF\), I wasn't able to \_show\_ how to do it or to see what the result was ;\)
In Phoenix, the "view" is used to render the results. https://hexdocs.pm/phoenix/Phoenix.View.html The defaults are to render content using templates, but you can play games, e.g. rendering results in code or having the same method handle different output formats. For example, one API we have supports XML and JSON this way: def render("error.json", %{reason: reason}) do %{error: reason} end def render("error.json", %{changeset: changeset}) do %{error: render_errors(changeset)} end def render("response.json", %{response: response}) do response end def render("error.xml", %{changeset: changeset}) do XmlBuilder.doc(:result, [XmlBuilder.element(:error, render_errors(changeset))]) end def render("response.xml", %{response: response}) do results = for {key, value} &lt;- response, do: XmlBuilder.element(key, value) XmlBuilder.doc(:result, results) end defp render_errors(changeset) do errors = Enum.map(changeset.errors, fn {field, detail} -&gt; "#{field}: " &lt;&gt; render_detail(detail) end) Enum.join(errors, "|") end defp render_detail({message, values}) do Enum.reduce values, message, fn {k, v}, acc -&gt; String.replace(acc, "%{#{k}}", to_string(v)) end end defp render_detail(message) do message end
&gt; Do I need to put the logic in a separate function and just call that function for both the API and the template controllers, or is there a better way of doing this? Yup, that's exactly it. This is entirely the motivation behind Phoenix's concept of "contexts" - putting your application logic in a separate layer that's NOT tied to the web. I highly recommend reading the [Phoenix Contexts](https://hexdocs.pm/phoenix/contexts.html) documentation.
Yea, more specifically it uses \`global:trans\` which acquires a lock on terms of the type \`{{pg2, group\_name}, pid}. It's a bit more fine grained than nodes.
Just wanted to add here that returning `render(conn, :index, videos: results)` will dispatch to `render(conn, "index.html", ...)` or `render(conn, "index.json", ...)` depending on content-negotiation.
I set up transactional emails via Swoosh and Amazon SES, because it writing welcome emails to all the learners who signed up on [my site](https://alchemist.camp) each day was beginning to become a drag. I'm going to automate password recovery next. After that, I'm going to start working on some gamification to motivate learners and on compiling good external resources that can help with various elixir-related tasks. I also recently bought *Phoenix in Action* and am looking for some time to go through it.
Huge undertaking! That said, as an ML fan, I'd love to have stronger checking. I understand the historical reason that dialyzer had to use success typing and only reject programs it can prove to be wrong, but I'd love a from-scratch type checker that only _accepts_ programs it can prove to be right (from a type perspective), at the expense of rejecting some valid programs. I know people take issue with Elm's types. I don't know Elm, but from what I understand it doesn't support Higher-Kinded Types (HKT) like Haskell. But I don't know if that's the extent of it, since rust also doesn't support HKT, but is plenty productive. I believe pony lang is a typed actor based language with message passing, so I don't see why inter-process communication would make it impossible. Worst come to worst, some sort of hacky approach just for GenServers would solve 99% of my message passing use cases! Obvious inspirations are facebook's flow and TypeScript. Another random thought I just had about typed messages is that sounds a little like protocol buffers or cap'n proto. A lot of software is built with those, and those messages have encoded types and some degree of polymorphism. I think if your type checking is rich enough to match those, it should be fine for production code. &gt; What features would you want to be included? * At the minimum sum ("enums") and product ("tuples") types. * Conveniences for handling `nil` (a la Swift's `?`). * Exhaustiveness checking * Some amount of polymorphism (this is where it gets hairy and I'm not super clear on what the levers are here).
How long are talks supposed to be?
They‚Äôll be full length talks, so around 35-45 minutes (with break time in between of course).
Wow! I‚Äôm so excited about this, thanks for the heads up, hopefully I can make it!
We hope so too!!
As a general rule I'd say you should be relying on the higher level abstractions most of the time. It's good to learn the underlying principles of spawn, send, and receive to understand what's really happening when using gen_*
Unless you really need to make something that spawns a lot of processes efficient or some other edge case I can't think of, you should probably use the OTP abstractions. You can get better integration into the tooling (better hot code upgrading integration into release tooling, enhanced debugging/tracing support, sasl logging reports). You can roll your own OTP abstractions and get all that free integration via `proc_lib`: http://erlang.org/doc/design_principles/spec_proc.html
I haven't been writing much of it myself. I was digging in the task code to see the difference in two functions. The task module is essentially a wrapper around send and receive with some basic edge cases handled. I think I'll stick to it when I find myself needing that behavior. Otherwise, lots of genserver call and cast.
Even if you're writing your own behaviors, there's usually an existing abstraction you can build on. If nothing else, a gen_server will do ya.
I think this is a cool project. Keep it up for sure. I'll look at using it for a project to see how it works out.
Generally you won't. Most of the time you'll be using OTP abstractions, but if you find you have some code where you won't ever need any of the functionality OTP provides, then that's when you normally would use those lower level operations. However elixir already provides a number of other less feature-full abstractions such as agents and tasks (as you mentioned). So generally you'll just use those in that situation. Only time I can think of using receive is in two situations. The first is where you might not want not want to spawn a new process from the caller, but the function still expects to receive a message from some other process (that isn't the typical spawn a task workflow). The second is if you had some really complicated receive pattern/synchronisation (maybe you wish to do some work sometimes rather than always waiting in a receive loop), but I'd be very skeptical of why you'd want this (overhead of just spawning new processes as needed likely won't matter). 
If you don't require a dsl, I might suggest https://github.com/infinitered/elasticsearch-elixir. ES has a lot of good docs and knowing exactly what calls are going on could be beneficial. AWS elasticsearch should work with any library as it's just a URL exposed
I'm using that lib, it fits my needs very well and it's pretty simple.
A multiplayer web game I've been working on [https://bulletz.io](https://bulletz.io) it's still in pretty early stages and isn't really fun at all but hey it's getting there!
Aren't agents and tasks built on top of genserver? They are *more* featureful, if I'm not mistaken
My bad, looks like an agent is. A task also seems to follow OTP (rather than simply being a spawned process as I assumed) as it's using proc_lib under the hood to spawn the process. 
I've been using Elastix, works well, very simple. Doesn't cover everything, but it's a nice wrapper.
I started a project with that library and we intend to pull it out. It doesn't do much for you, and if there is an error with ES, it doesn't tell you what it is at all. We've just used the direct http interface everywhere, so at that point you may as well use a regular http library.
I released a new version of my project (https://github.com/sirko-io/engine) which is aimed to predict and precache resources (pages and assets) which might be requested by the user in their next transition. Thus, when the prediction is correct, resources are served from the browser's cache. Actually, there are 2 parts of the project: the backend in Elixir and frontend in JS. The prediction model is very simple, so I am looking for improvements now.
That would be actually an great feature... 
[This](https://hexdocs.pm/iex/IEx.Helpers.html#open/1) is the best answer I could come up with: open Some.Module.fun/2
Links!
Nothing fancy yet, just a little app that connects to the Reddit API that scrapes post score over time and inserts the data into elasticsearch. Fun to see the trends of posts over time.
I tried to sign up, but got an Internal Server Error. Just figured I'd let you know.
https://www.erlang-in-anger.com/ is the one I've read so far. It's about 85 pages of content and doesn't go too deep into nitty gritty things. Makes it a good read. I am going to start https://happi.github.io/theBeamBook/#introduction soon
Thanks \- Yeah I think using supervised GenServers to represent the agents and using another GenServer to represent the "stage" makes for a pretty easy to maintain parallelizable game architecture. Writing an [Agar.io](https://Agar.io) clone would be pretty fun \- if you do it definitely drop me a DM and I'd love to look it over with you/let you see how I structured this game/work on it a bit.
If I do it wouldn't be for quite some time. I'm already working on a game that uses Unity as a front-end and I'm trying to get that out before I move to something else.
These benchmarks are super promising. I'm always a little discouraged as how low elixir/Erlang/Phoenix is on the TechEmpower benchmarks. I know those benchmark very specific, even esoteric things (and very much do not encapsulate developer happiness), but hopefully these changes will allow a few uptics in overall throughput.
I wrote this post to detail some lessons I picked up while debugging why 200 websockets would take over 500 MB of RAM sometimes. I ended up getting it down to multiple thousands connections in almost no RAM overhead.
I had a similar problem in production. Specifically: I was sending big payloads when clients were joining the channel and only sending small updates later on. From what I understand this caused big heap allocations for websocket connection and transport processes, and the GC was never being triggered because memory usage in these processes practically wasn't growing. My solution was to manually trigger gc in both processes after handling the join. Code can be found here: https://groups.google.com/forum/#!msg/phoenix-core/OCVzVm4C9PA/XG205gCVCgAJ (ws_info :garbage_collect callback has been added to phoenix so there's no need to fork it anymore)
Is there a rejected PR to show someone tired to add it and failed? I thought the awesome series was just community driven.
One reason is that python has a lot of the best libraries for this type of work.
Can you give some examples ? I would like to learn a framework like Keras.
Where to even start? It all builds from numpy and scipy and pandas to scikit-learn, spacy, nltk, gensim, pytorch, first class tensorflow bindings, the list just goes on and on. For what OP is asking stuff like Dask is coming up.
Floating point math is pretty slow in BEAM. Of course you could use native functions, but AFAIK you lose out on concurrency and they are not feasible for long operations like multiplying huge matrices. However, there is a book called ‚ÄúHandbook of Neuroevolution Through Erlang‚Äù that you might want to check out if you are interested. Probably the only book on machine learning in Erlang. Also, if your are looking for Erlang-like concurrency with adequate floating point math you can check out Scala. Akka framework implements actors that are close to Erlang‚Äôs processes and JVM has multiple linear algebra libraries.
The problem with AI in Elixir for me is that BLAS computations heavily rely on internal mutability of some data (ex. matrix multiplication). While you can implement it in C and then just expose proper NIGs in BEAM there are other problems: - Dirty schedules became default only recently, till then one CPU heavy process could overtake whole processor time. You could use ports or servers, but then you would get nothing from BEAM only troubles with maintaining connection - Python seems easier to grasp by mathematicians, especially as there is much more tooling like gplot integration, IPython, etc. That is the same reason why Matlab, Fortean and R are die hard in their respective fields (engineering, math, statistics) - There are other languages in the field that provide functional features, top of the shelf example is Prolog which is here longer that Erlang itself - Elixir is young, and creating such libraries take time, a lot of time, especially in immutable languages - No big player backing on such project. Tensorflow have enormous backing and Python API is first-class citizen, one could even say that Tensorflow‚Äôs Python API is treated better than native C++ - If you ask question ‚Äúwhy nobody‚Äù then ask yourself ‚Äúwhy you don‚Äôt‚Äù and in most cases you will get answer to the both of these questions
Tensorflow?
They are all just wrappers around C libs though. 
Python just calls into C libs for all that work. I presume Elixir can do the same.
I don't for the same reason I presume others don't. The path of least resistance already exists which is python. I guess somebody has to blaze the path.
In fact, Pandas is often calling C or FORTRAN written in the 1960s. We could call those libraries from Elixir using NIFs, but it's not really playing to the strengths of the platform. Generally speaking, managing a pool of Python processes works pretty well, as long as the serialization overhead is small relative to the work being done. Concurrency and working with large data sets is a general issue for Python: http://wesmckinney.com/blog/apache-arrow-pandas-internals/ Elixir can fit into this pretty well as an orchestration layer. It is also generally good for processing binary data. While Elixir is about half the speed of C, it is very easy to take advantage of all the cores on your server. On a podcast people were talking about processing uploaded JPEG images at large scale to extract the location from the EXIF information. Using Erlang actually performed very well at this. 
I just pushed a library to hex that helps define struct-to-struct mapping functions. It's called cartograf, and while it is still early days for it, I think it could prove very useful in a few scenarios. The use case that drove me to make it was having to convert between protobuf structs, structs used for ecto, and structs presented to the user through my web-api. With cartograf though, it is super easy to create a function to convert from one struct to another, no matter how the struct shapes and fields change. The documentation isn't complete, but the tests are in case anyone wants to pull it down and play with it. https://github.com/Herlitzd/cartograf
It can and we are doing this for photogrammetry where I work. Soon machine learning as well, so maybe we will end up with reasonable bindings to tensorflow or similar soon :)
Re: tensorflow... the C API is designed for bindings and they are moving more of the functionality to the C++ implementation and exposing it via the C binding API. Why? golang bindings, which makes tons of sense if you think about who is behind these projects. Training looks like it will remain easiest in Python for a while but applying trained networks to data which is where the practical applications are is there for the picking. Being able to conveniently apply ML as part of your phoenix app would be rather nice :) We are using it for semantic segmentation of images and 3D models and have made first steps to driving that from Elixir .... if we manage something useful from the exercise we will share it :)
How will it help me?
To be fair you could rank it in the top 20, but its because there are not enough books to fill 20 slots. I do mean to read the book though. I used Elixir for some computational biology stuff. It worked well but was probably not efficient.
Pretty much all of these are built on top of C wrappers. Or they are derivatives of those libraries.
For individual tasks, this makes sense. I think OP was looking for Machine Learning tasks which are usually serialized as you indicated. I'm not an expert though.
There's a GSoC project for Tensorflow bindings (https://summerofcode.withgoogle.com/projects/#5406400314867712)
Can Julia and Erlange/Elixir work together (i.e., good combo of strengths/weaknesses)?
&gt; NIFs running for more than 1ms can cause errors and performance side effects, like slowing down the scheduler. That restriction is gone nowadays if you mark it as a dirty NIF: [http://erlang.org/documentation/doc\-10.0\-rc1/erts\-10.0/doc/html/erl\_nif.html](http://erlang.org/documentation/doc-10.0-rc1/erts-10.0/doc/html/erl_nif.html) &gt; A NIF that cannot be split and cannot execute in a millisecond or less is called a "dirty NIF", as it performs work that the ordinary schedulers of the Erlang runtime system cannot handle cleanly. Applications that make use of such functions must indicate to the runtime that the functions are dirty so they can be handled specially. This is handled by executing dirty jobs on a separate set of schedulers called dirty schedulers. A dirty NIF executing on a dirty scheduler does not have the same duration restriction as a normal NIF. 
Is there a reason you can't just call `Process.sleep/1` in the new process, before it does anything?
Oh wow, that is fantastic news. Will try to get in touch with them!
Not as nice as nifs, but yes you can drive julia scripts from elixir.
You should edit your post to include the real problem you're trying to solve. This screams _XY-problem_.
You should shift your mindset.
Yes. They run on a dedicated set of ‚Äúdirty‚Äù schedulers (two sets technically: CPU-bound and I/O-bound). If you try to run more dirty NIFs in parallel than there are dirty schedulers, they‚Äôll queue up. Since Erlang/OTP 20 long garbage collections run on dirty schedulers automatically. On 21-RC1 the file I/O functions are also implemented using dirty NIFs, rather than an async thread pool. There‚Äôs a good explanation here: https://medium.com/@jlouis666/erlang-dirty-scheduler-overhead-6e1219dcc7 and here: https://github.com/tuncer/re2/issues/9#issuecomment-184846992
Awesome. A couple of years ago I wanted to write a distributed neural net learning using actors and I ended up picking Scala and Akka because of the problems with NIF's. Would be interesting to use some C matrix lib now with dirty schedulers and see how it stacks up against Scala.
Sure but it‚Äôs a lot of effort still they are not just loading some shared object libraries. Elixir has a lot of the properties that make Python popular for this kind of thing and even some that python doesn‚Äôt as op says but Python is basically a de facto standard along with R at this point.
Again. It seems to me that a highly distributable and concurrent language would be a natural fit for this kind of work
You're arguing with the wrong person.
And they all exist now so people can do real work with them now
Thanks I'll keep an eye out for your stuff. I am just starting to get into photogrammetry and processing of remote sensing equipment. 
oh, cool! if you end up doing anything in that vein with elixir, drop me a line in case there is mutual interest and we can collaborate ... 
I am an absolute noob at this stage. Frankly I don't even know where to start so I am just reading at this stage. 
Everyone starts at the beginning :) feel free to ask questions if you run into anything puzzling ... and happy hacking!
Cause it's slow for number crunching. I did Erlang with Project Euler and it's slow as hell. Your other comments seem to comment about distributed. There's disco (http://discoproject.org/), if that's what you want but number crunching isn't it. If you're gonna say python stuff is implemented in C/C++ and whatever, then I'm going to point out writing NIF safe code without messing with BEAM schedule is hard. Python and R doesn't have such a complex state of the art system of concurrency so the C++ implementation doesn't have such a restrictions to care when coding. The best BEAM is going to be is to provide the infrastructure to enable batch process or real time process. I don't believe there is a good momentum to do ML in this language and unless the ML paradigm changed enough to fix the BEAM model of concurrency. An example is website just happened to fix the concurrency model of BEAM. There is some weird fringe stuff such as https://www.springer.com/us/book/9781461444626 . Since erlang's process can be model as graph or neural node. 
Honestly where do I start? Is there a tutorial someplace that you know of? What's the algorithm for mosaicking or orthorectification or creating DEMs and such?
openmvg has some really good documentation that covers quite a bit of the algorithmic side. but each of the topics you listed are not small topics on their own. it's why tools like arcgis are so popular. but there is info online as long as you are willing to search a bit. e.g. on orthorectification: https://www.google.ch/amp/s/www.geospatialworld.net/article/review-of-digital-image-orthorectification-techniques/amp/
A few reasons come to mind: * Scientist that use scientific computing are often people that don't write code all day. They just want to write the code and get it done. In that sense, they are more likely to stick to a language that they know or that feels similar to one they know. Functional programming and the actor paradigm are great, but they take some getting used to. Compare that to just using a language you already know. * Libraries such as Numpy offer a great amount of functionality out of the box. As far as I know, elixir and erlang don't offer similar libraries. At the very least the community around those libraries is way smaller. Also worth noting that these libraries are implemented in C which makes them very fast. * BEAM is not that great at raw computational speed. Where it really shines is low latency when responding to requests, but that's not very relevant for the types of applications you're talking about. * Even if you're okay with all of the above, rewriting an algorithm in a different programming paradigm is *hard*. Furthermore, some algorithms don't get much use out of extra parallelism (Amdahl's law), so just spinning up a few extra instances in python might be enough to get all the parallelism you ever need. 
It's important to break apart the concept of "thread" in the Elixir language. You don't have traditional threading model and it becomes easier to think about when you think about the process model. In Elixir's case, when you spawn a new Task or start a new GenServer, a process is created. That process is going to wait for incoming requests (GenServer) or execute a function (Task). In either case, if you call `Process.sleep/1` from the Task/GenServer, you will make that process, and only that process, wait the requested amount of time before executing. I would use this if wanting a Task to wait. If I was wanting a GenServer to do something after X seconds, I would use `Process.send_after/3`, which will send a message to the process after a certain amount of time. Because GenServer responds to messages to do work, you can think of this as saying "do this work in X time". For your question, Task/sleep seem like an acceptable solution.
Arcgis seems like a black hole where I am going to throw money into for the rest of my life. 
The link from the PaperClip CFP back to the main site doesn't resolve. It's missing the www.
Nice series of posts. One semi-non important question/observation: This is the first time that I've heard/read this approach as being called a `Token Flow`. I've always heard of it referred to as context. Is this how it's commonly referred to?
Short answer: https://davejingtian.org/2017/10/06/why-list-and-charlist-are-confusing-in-elixir/ + https://hexdocs.pm/elixir/Inspect.Opts.html
When you are not sure what a value is in `iex`, put an `i` at the beginning of the expression: iex(2)&gt; i Enum.to_list 7..12 Term '\a\b\t\n\v\f' Data type List Description This is a list of integers that is printed as a sequence of characters delimited by single quotes because all the integers in it represent valid ASCII characters. Conventionally, such lists of integers are referred to as "charlists" (more precisely, a charlist is a list of Unicode codepoints, and ASCII is a subset of Unicode). Raw representation [7, 8, 9, 10, 11, 12] Reference modules List Implemented protocols IEx.Info, Collectable, Enumerable, Inspect, List.Chars, String.Chars
Thanks for the tip I will remember that
Erlang legacy. Otherwise if you would write `'abc'` in IEx session you would get `[97, 98, 99]`. 
I've seen context and middleware. I've never seen it called `Token`. Trying to google it just gives me a bunch of articles about OAuth2. All that checking of the `halted` property at every step feels like a very manual version of a monad.
To my knowledge, this is not commonly referred to as Token. I used the word "Token" in this series to illustrate how this "thing" is moving through a business process (similar to a Token on a game board).
I used the word "Token" for this blog series on a concept in Elixir. I have also seen this called a context before, but that term has another meaning in the world of Phoenix. &gt; All that checking of the halted property at every step feels like a very manual version of a monad. I wish I could speak to that, but my knowledge of monads is very limited. The described MO is simply how Plug, a popular Elixir library, does it. I really liked it from the start and finally found the time to explain it in a series of blog posts. 
&gt; Nomoko Was it you the guy presenting "Rendering the World: 3D Reconstruction at Global Scale On the BEAM" at the Beam lite conference in Milan?
Guilty as charged ...
Great talk I really enjoyed it
Ah cool, glad you did! Had a blast there, and look forward to the next conf I can get to ...
BEAM is very good at what it does, but I don't really like Erlang's syntax.
Having started to dabble in more 'functional' programming concepts in JS, Elixir felt like a good way to increase my understanding of those ideas using a grammar/syntax that I enjoy. I also kind of bought into the party line about the stability and capability of Elixir/BEAM as a way of managing the backend.
honestly? cool name, cool looking syntax, cool terms like "fault tolerance", "easy concurrency", etc. in practice im just a web developer so i cant really take advantage of most of the things i learned because im too fucking dumb. so i decided to go to uni and im now in the second semester of my first year of an actual CS course that im enjoying a lot (but im still at the basics relatively speaking)
I finally began to understand Erlang‚Äôs conventions after a helpful conversation with someone at work. Elixir made more sense after that. I found myself frustrated with python for projects that went beyond prototypes. I wanted the properties of the erlang runtime and so instead of approximating it I decided to use it. I have been happy with my decision. I learned it at work porting a prototype from python to elixir. Launched it and found it ran continuously for months after without hiccup. 
I want to build telephony things. Erlang's history in the industry combined with Elixir's rad syntax makes it a good choice.
the branding is on point
My professor invited me to go with him to the first Elixir conf in Austin because he knew Jose. Listening to all the presentations was very convincing. My other two favorite programming languages are Ruby and Clojure so it was an easy sell for me :p
I had heard of Erlang before, but I never invested any time into learning anything about it. I knew it was created as a telecom platform and I knew what OTP stood for, so I just didn't look any deeper into it. I had used Ruby on Rails for a couple web projects and I basically liked Ruby. I think because Jose was very involved in the Ruby world at the time I learned pretty early on about Elixir and I just read his "pitch" about it somewhere. The syntax had that very basic, surface familiarity of Ruby (same as C++ and Java had for C programmers - different language, but just a hint of familiarity that makes it easy to get started). His "pitch" was more about how Erlang's features were designed for telecom systems but just happened to solve the same things that we're trying to do in web systems these days. So I played around with it early on but it wasn't until Phoenix matured that I tried building anything with Elixir. Phoenix/Ecto/mix help get things close to (but still not quite to) Rails's productivity, Elixir's general simplicity makes everything feel more understandable and maintainable to me compared to Ruby, and Erlang/OTP runtimes make things fast and stable. As Michael Scott would say, "Win win win."
Out of all the languages I know, it is the most elegant, with a real lot of thought out in its design. I love the white paper driven approach of its development.
For me a lot of micro reasons to enjoy it over others but the one that tops; the competitive advantage possible to gain in many types of web projects compared to other language/envs. I'll build it faster and better
Took a position and inherited a Ruby on Rails app. This thing was built by a 15 year vet but it‚Äôs a mess. It‚Äôs so fragile. Every little change has massive side effects. I can feel the aftershock ripple through the codebase. It‚Äôs not small either. I‚Äôm not saying you can‚Äôt build crap in elixir but I‚Äôm over tracking down mutable state transformations. Plus I‚Äôm ready for a change. I also believe elixir will be see a wider adoption and will prove to be a lucrative career choice. In 10 years when someone inherits my crappy elixir app they‚Äôll be pissed off they can‚Äôt just mutate state and then they‚Äôll rebuild it in ‚ÄúPython on Bike Lanes‚Äù. 
Because the language and tooling is very neat and precise. I never felt that I am learning a functional programming language. I tried Clojure earlier but parenthesis was bit off putting in addition to functional programming concepts. Digesting these two at the same time was not healthy :)
because I was learning erlang and wanted to use a popular web framework 
I had a co-worker who I look up to who was really hyped into it. He knows I like to ride the wave and so he started talking about it more and more. Next thing you know, we have about 3-4 microservices running and more on the way. Biggest reason I wanted to learn it was to just expand my horizons and he swore by it.
I started a side project and I wanted to write it in Clojure but felt like context switching from Ruby (which I used at work) to Clojure might get annoying. Elixir &amp; Phoenix felt like it might give me the productivity I was used to with Rails with the some of the benefits of Clojure (FP, thread first macro, immutable data, good concurrency story, etc). One year later, I switched jobs and now use Elixir at work and on the side and couldn't be happier.
Come from a Java and C background, very interested in the concurrency and fault tolerance approaches built in. Always wanted to get into Erlang due to OTP and the above reasons, but couldn't be bothered to learn the esoteric syntax. I at first had a hard time because I despise Ruby, but Jose and Co. really succeeded in making Elixir only cosmetically related to Ruby. The Dave Thomas book also had me pumped. Currently I enjoy it because it fits the niche of in between a quick bash script and a full fledged java microservice. I can crank out a scheduled fault tolerant job in a maybe a few hundred lines of code. While this isn't terribly impressive itself, it has the "batteries included" feel that you don't get when you try to schedule a ruby script or java jar in cron. I had always thought the raw performance could be better though, but it really hasn't been a problem so far.
Because it's like Scala just a million times better
I already loved Erlang. Thus learning Elixir, a beam language with a more fresh and new approach, seemed a logical choice to learn for my ‚Äûone programming language a year‚Äú approach. And I didn't get disappointed: I love Elixir.
Was php web dev. Dabble around in nodejs and erlang. Realize Erlang was awesome. Hang out at Erlang meetup. Erlang peeps asked, "why don't more dev use Erlang?" I basically said, "Erlang needs something awesome like Ruby got Rails." They all disagree and said it's bullshit and still wonder what's wrong with Erlang adoption rate. Elixir came about and the community seems better. It's like Ruby less like Erlang peeps at the meetup. Elixir missed the boat that Ruby had, Elixir is coming in where web dev market is saturated but everything is fine. Less hype probably less tribalism unlike Ruby or NodeJS bs. Ruby had a lot of tribalism especially early day they were shitting on jruby and then rift between main core Ruby and other implementation. 
I was working on a .Net project that, from what I knew of the BEAM via conference videos, was a shitty clone of the BEAM. Then I made a rough proof-of-concept project in Elixir for one of our many services. Without _knowing_ idiomatic BEAM or Elixir practices (but knowing a fair bit of FP), my POC was 3 orders of magnitude more efficient than our .Net implementations. From there it was easy to convince managers that using Elixir was worth the effort and then I needed to get better at it.
Had an eye on it in the distance for a bit. But since others shared most of my favorite reasons I‚Äôll mention another. I was big into Clojure for a while but soured on some community culture things such as how beginners were treated. It was an experts only club in way and if you wanted to join you really had to do the work. I always felt that software is more a people game so I immediately recognized Elixir‚Äôs community had nailed it and really cared about investing in that aspect. Instead of fighting learning it was a breeze and probably the easiest language to learn for me to date. I also liked that Elixir is very lisp‚Äôy. If you haven‚Äôt looked at the macro system or AST it‚Äôs basically a lisp. But the great thing is Elixir can have is all the benefits without the purity of being isomorphic which IMHO is super cool but doesn‚Äôt make my programs better. Also best documentation of any language 
 * I needed a websocket that could handle large volumes of messages * The problem was almost stateless * Needed a high level of reliability * Needed a high level of scalability * I hate JavaScript * I worked with F# before * For street creds
Same here, tried to sign up but wouldn't let me.
I heard about it on the Ruby Weekly newsletter, and at the time that was exactly what I was looking for. But it was this video: [https://www.youtube.com/watch?v=SVisr\_gYA1w](https://www.youtube.com/watch?v=SVisr_gYA1w) that got me really excited about learning it.
I've been dabbling a lot more into Erlang and honestly if you got rid of the punctuation I'd probably like it more than elixir. There's something about all the `do..end` that's been starting to bug me for some reason.
For simple tasks Elixir is a functional, dynamically typed language with beautiful syntax and pretty damn good performance. It is so easy and enjoyable to use Elixir to solve small problems. For more complex systems it provides powerful and easy to reason about cuncurrency. Honestly, after learning elixir I don‚Äôt think I will ever use a different dynamic language. 
I was going to learn [Nemerle](http://nemerle.org/About) because of the macros and somebody on Hacker News suggested I look into Elixir instead. I did and haven't turned back.
I wanted to write a simple, actor-based, 2D online game server. It results in [lkn_core](https://github.com/lkn-org/lkn-core), and a demo game server called [lykan](https://github.com/lkn-org/lykan). Still a toy project, but it has been a very fun and pleasant journey so far.
I do not know of this setting, although I still have some advice that might be applicable: Have you looked at setting fullsweep_after to something lower, like 10 or even 0 (extreme, always do a major gc)? This could give you the benefits you're looking for.
The JVM and the EVM work completely differently in this respect. The EVM does not have a single heap to even set a size on, there's one heap is contained within each process. I'm not sure but I suspect the per process heap size to be unbounded, though you can look around for it. The more common scenario is to discard the entire process so that no garbage collection cycle is needed at all. There was an article not too long ago that talked about this but I'm on my mobile and don't have time to find it now. Can you explain more what symptoms you see and what you're trying to fix? Memory management is quite different due to immutability, so there may be some tips we could give you if you post some sample code.
I needed to write some configuration management software, and I was looking for a dynamically typed language with syntax niceties. I already had a lot of experience with Python and JavaScript but couldn't bear having to use them for new software. My prototypes in Clojure and Rust didn't work out very well. Everything about Elixir felt right as I started learning it, so I kept going and I'm still very happy with it two years later.
Its syntax is nice and it leverages decades of best practices and patterns available in Erlang / BEAM VM. When I learn a new language it's usually because I have something to build in mind and this is no different. I could have built the app I'm building with frameworks I know very well (Rails and Flask) but I chose to use Elixir / Phoenix because I think learning a functional language could potentially make me a better programmer in general. That are there are a few components of the app where I know I'm going to benefit from Phoenix channels. Also, I don't treat learning new languages as a drop in replacement for something else. Elixir will just end up becoming another tool in my tool belt. Perhaps over time I'll use it more, but it really comes down to what type of libraries are available in the languages I know when it comes to building out projects.
I want to create a library for creating a image made by titles or mosaic. Something like this [https://nearsoft.com/blog/putting\-it\-all\-to\-work\-elixir\-poolboy\-mogrify\-andreamosaic/](https://nearsoft.com/blog/putting-it-all-to-work-elixir-poolboy-mogrify-andreamosaic/)
1. I assume this is locally. Hot swap can happen locally when watched files change. Phoenix has this setup out of the box and it works well. It's fast enough that I've never thought about it. 2. Distillery does package the BEAM VM (erts) by default. This is why you need to compile packages on the same architecture OS as what you'll be running in production. 3. There is `mix test --stale` and also there are test watchers, but I haven't used them. It looks like https://github.com/lpil/mix-test.watch supports --stale option as well. In general, I feel like Elixir / JS are pretty non-comparable. You can use a JS actor model, but it fundamentally is going to have differences from how the erlang process model works. You will surely be able to create an efficient workflow that allows you to be productive and fast.
BTW, this is what Phoenix uses for change detection https://hexdocs.pm/phoenix/Phoenix.CodeReloader.html. Note it's a plug and requires that the request comes through the web. You could put this in a non-web environment through a timed genserver or something if you wanted to.
I wanted to code in a functional way. After doing some tests, I ended using it for every pet project where I needed a backend. BEAM is very good and the syntax makes it fun to code.
Thanks for your reply, however recompiling into IEX every time I change a file is not gonna work when I have too many files. I don't think crashing would be a problem, we have supervisors, right?
Thanks for your reply, this does sound really good. And yes, I meant locally for development purposes only. I agree Elixir and JS are totally different languages, however, as long as you implement the actor model correctly, the differences don't matter. Still, I much prefer Elixir since it has a good community and there are many tools available already. For JS, the few libs that do implement the actor model are incomplete.
Awesome, thanks for the link! It is definitely something I'll try and adapt for my needs.
Thanks for your reply, how fast would you say the recompilation is \(for a more sizeable project\)?
I'm not 100%, but I think recompile only compiles files that have been changed! 
I'm actually pretty sure I'm wrong in my previous comment. Only the file that has changed gets recompiled and the virtual machine handles the rest of the linkage changes. Which means that it is all dependent on how fast the module compiles. I've never really worked on a significantly large project, so I've never paid attention to compilation.
You are correct now and then. There is a mix task in Elixir called `mix xref` that shows how modules relate to each other in a project. If they have a compile time dependency, then they are recompiled at compilation time. Otherwise the VM handles the rest at runtime. 
What I'm looking for is easy and efficient distribution and a way to structure code so that it will be easily composable. The actor model fits both of those bills. I think just starting distribution at the process\-level rather than VM\-level \(and optimizing based on locality\) and enforcing isolation harder \(throwing errors via linter or build system\) is enough to get it to work for most practical problems. The bigger issue is the lack of tooling. A different runtime like Beam.js \(which is dead\) with bidirectional integration would've been the best, but it seems like that's not gonna happen.
One solution around this is to simply cluster NodeJS across all cores \(and use the same distribution patterns you would use for horizontal scaling\). Another solution would be to use a multithreaded runtime like Nexus.js or just invent a new one with the actor model built\-in. I agree the actor model isn't a first\-class citizen in JS, but once you've got an actor model working, you can abstract the details away and just think of your problem from the new layer. It may sound unorthodox to mutilate JS to the point where it doesn't even resemble it's old self, but this has been done before succesfully.
There is no reason you can't use node to file watch and run certain tasks. ie. nodemon --ext ex --exec "mix test"
Oh very cool. I didn't know about that mix task.
"It may sound unorthodox to mutilate JS to the point where it doesn't even resemble it's old self, but this has been done before successfully." I'm pretty sure that this is the foundation of JavaScript. (joke)
It kinda is, tbh. It's the embodiment of the "Improvise. Adapt. Overcome" meme.
Easier to statically analyze Elixir code within Elixir. And if I want to change a source code file and have the tests files associated with it run \(maybe not even the whole files, just the tests that affect that file\), it will probably be easier to stick within the same language.
The right article at the right time. We're just getting to a stage where our first Elixir project goes into production in a few weeks and we're still figuring out best practices. Thanks a lot!
For that you can use hot code updates. They are reasonably straightforward, similar to database migrations, but for GenServer state. If you use a map to keep state, then it is easy. Much better than the old days of Erlang records. On the other hand, you will always have connection glitches in, e.g. a chat system. So if you build in a way of reconnecting on failure, then you can deal with it, thou you can get a thundering herd of reconnects to deal with. Depends on the application. We use Blue Green deployment for AWS. It doesn‚Äôt keep from dropping connections, though it could allow a smoother transition, i.e. taking down one server in the ASG at a time.
Another approach if you have really sensitive requirements could be to maintain a separate set of servers for websocket connections and bridge the communication between the websockets and the main application via Node.connect or possibly a different distributed communication mechanism. This would allow deploys to either codebase w/o impacting the other, but you would need to make sure that the API contract doesn't change.
I think you may be interested in cortex https://github.com/urbint/cortex
Does this one help, or thinking something different? https://stephenbussey.com/2018/01/08/designing-elixir-supervisor-trees.html
Thanks! Please let me know if you don't see anything that you'd benefit from. Every suggestion helps me balance my writing list over time.
I think deployment is one very topic that needs much sharing. I'm coming from dockerizing node apps and using it with kubernetis. Is using something like kubernetis even a good idea with the Erlang vm?
I had so much trouble with erlang/elixir deployment... it's just easier to give up and use docker or whatever works.
Some metaprogramming would be nice
Utilizing Elixir alongside big data tooling (Spark, Hadoop, Elasticsearch, etc.).
This is what I did as well, but I'm curious to read about it and look at alternatives!
Web dev in general. Express and Flask make it look so "easy". I would like to see more articles around "look how easy it is to {spin up a web server, parse csv, resize an image}". Less emphasis on "coming from rails". I feel the narrative doesn't fit a lot of developers who are interested in elixir/phoenix. I, for example never touched rails in a workplace until about 1 month ago, but I've worked with PHP and Python for many years prior. (I actually think PHP developers are a large pool of people who'd be pretty happy coming to elixir/phoenix). I second content around deployment. More information about production deployment would be awesome. Especially using AWS, GCP, Azure etc. An aws employee on twitter called elixir developers neckbeards who don't use the cloud anyway. I would like to see that narrative to change. More structured beginner friends tutorials would be excellent. For example, in python https://automatetheboringstuff.com/ is a common suggestion for new devs. Content along those lines would be great to get developers to try elixir. Automate the boring stuff [Elixir edition] would be pretty valuable.
I'm surprised by this - granted I've only used Distillery inside of Docker but I found it to be pretty straightforward. There are a few gotchas that I never solved (like reading from STDIN) but for the most part it was much easier than I was expecting Our primary Elixir app runs in Docker and Kubernetes though. It feels like we reinvented the wheel going that route but it does fit better with all the rest of our infrastructure and gives us freedom to not use Elixir without losing a ton of functionality
From one of our project retrospectives - think about how things fail and how you want them to restart. We originally separated things by domain in their supervision trees and at the end of the day just wound up with a bunch of global processes (sometimes pooled or sharded) that had strong dependencies on one another. They maintained a lot of state so one going down can cause cascading failures throughout the system until things normalize, and those failures tend to be cause big interruptions. We've eventually gotten to the point where these dependencies are at least one-way dependencies, but it's still not where I think we want to be Today we probably would've broken things up a lot more - many processes with small bits of state that can crash and reboot themselves properly. Our app is essentially a task processing framework so we have heartbeat processes for our workers, stuck detection for jobs, job dependencies which are managed via queues for each processor, and all sorts of recovery mechanisms. If we could change things we'd probably create a tree of all of these processes that manage one single worker instance/job and then scale that out by creating more instances of this process tree, tossing them in supervisors for fault tolerance. But right now it's just a bit of a big global mess (which to be fair has uses as well such as making analytics, monitoring, and inspection easier)
This is a good suggestion. That twitter comment sounds nuts! Where can I find this?
The issue is that reasoning about restarts is very hard for newcomers (and sometimes even experiences devs). My recommendation is to actually think about the startup. What is the order you expect processes to be started? That takes them 90% of the way. After they do that, think about what should happen when each of them fail: is the supervision strategy appropriate? If so, ship it.
&gt; An aws employee on twitter called elixir developers neckbeards who don't use the cloud anyway Good god, you cannot be serious...
This happens when the VM can't talk to epmd (the port mapper daemon). If you have any firewall rules or something else is listening on that port already, there may be an issue.
Can you elaborate more on this problem?
pretty excited for his new book.
This sounds like a fun idea to explore. I'm sure there's some super elegant way to approach this in erlang process architecture that I'm not sure about yet. Would be interesting to research though! Off the top of my head, it could be beneficial to have a process which holds the pool and then that pool can be dynamically resized (close pool and re-open of different size if pooling mechanism doesn't allow dynamic size changes) via a genserver call back. There could be a process that polls every minute looking at the count and adjusts the pool size at thresholds. Downside here is that unless connections can be transferred between pools (or pool dynamically sized), you would have a reconnect period. Will probably look into this further over time! Thanks for the idea.
&gt; I'm sure there's some super elegant way to approach this in erlang process architecture that I'm not sure about yet. Right? I feel like there *has* to be something I'm missing, and that I can't be the only person to ever want to do this. I just can't think of what it is. 
I would say they are complementary. Kubernetes is a standard solution for packaging and deploying apps. If you run a lot of apps, you want your ops team to be able to manage them without knowing all the details. You get better utilization of your servers by allowing them to deploy standard units and manage resources at a higher level. You can put an Elixir app into a container and deploy it, but containerization doesn't provide as much value as it may for other languages. The Erlang VM doesn't depend much on the operating system. The mix build tool tightly manages runtime library dependencies, and building a release combines the VM and the app's libraries into a single tarball that you can deploy as a unit. So we don't find it particularly useful to use Docker/Kubernetes to deploy. Erlang/Elixir makes it very easy to take advantage of all the CPU cores available, so you generally benefit from having one instance with lots of CPUs instead of lot of little instances. And it can be a lot cheaper to do this in a dedicated server environment instead of the cloud. So on the whole, Kubernetes is not that big a win for Erlang, but they work fine together. I expect that we will be using it more in the future as public cloud offerings like GKE become more mature. Right now, we mainly deploy to dedicated servers and cloud instances using AWS CodeDeploy. I am in the process of writing a big blog post series on deploying apps in production: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ It includes a template for building and deploying apps using Ansible: https://github.com/cogini/elixir-deploy-template
I actually just discovered dynamic supervisors before seeing your comment, but thank you for the explanation! I think that helps me a lot.
 epmd: up and running on port 4369 with data: name rabbit at port 25672 This is the response i get from epmd -names. And typing epmd seems to return no errors, but it doesn't indicate anything happened...
So epmd is definitely working and there is already a node connected to it. You can try killing it via the activity monitor (or command line) and try again.
https://www.rabbitmq.com/networking.html It seems rabbit also uses the epmd and it is already running epmd on that port as I'm running rabbit in docker. Could this be the issue and how do I work around this? Do I need to start a new epmd on a different port, or some how allow iex to use the same one as rabbit?
I sorted it now, thanks to your tips that pointed me in the right direction and updated my OP to hopefully help anyone in that situation. epmd was working but it was an instance running in docker because I'm running rabbitMQ in docker and rabbitMQ runs its own epmd (hence the `name rabbit at port 25672`) when I checked `epmd -names` I simply changed my system EPMD port to something other than the default and started a new epmd server and it worked fine! Thanks for the help!
I am not anti cloud, I do a *lot* of cloud and DevOps work. For example, we recently migrated a customer from bare metal to AWS. They have a dozen Rails apps, each running in dev/test/staging/demo/prod environments, and they need to run in multiple countries for legal jurisdiction and performance reasons (US, EU, China). There there are definitely advantages to the cloud. It's better than the legacy self hosted mess that many companies have. The health care world has mostly decided that Amazon is "secure", so it's a lot easier to get through compliance reviews if you are hosted in AWS. On the other hand, there is a lot of cost and complexity to the cloud, and some people don't understand that there are options. The cloud vendors are all "rah rah cloud," but who is there to talk about bare metal? I also work on high volume Elixir systems that run dozens of those $100/month servers, and the hosting bill would be pushing $100K on AWS. From an Elixir advocacy perspective, we can definitely reduce costs and improve reliability: See my presentation at Ruby/ElixirConf: https://www.cogini.com/blog/presentation-incrementally-migrating-large-rails-apps-to-phoenix/ I am doing my part to show regular devs how to get things running: https://www.cogini.com/blog/best-practices-for-deploying-elixir-apps/ and https://github.com/cogini/elixir-deploy-template I am working on another series which uses Terraform + Ansible + AWS CodeDeploy to deploy to the cloud. The complexity is pretty high, though. I am looking forward to hosted Kubernetes reducing that, but that needs some time to mature. While I would love to see Elixir support in Lambda, you are not really taking advantage of Elixir. Lambda is nice for small chunks of code which respond to events and interact with the AWS APIs, but not for larger apps with persistent state. The security model is a big question. Amazon could provide [Erlang on Xen](http://erlangonxen.org/) hosting, but it comes down to the pricing model. You can do it yourself now, building your own AMIs and deploying them to an ASG, still pretty hard core. You are relying on AWS infrastructure to respond to demand, and it's not that fast.
We use Gigalixir and it has been very smooth. 
It feels like the author is missing the main complaint about `gen_event`, which is the poor error semantics. If a `gen_event` handler crashes, it is gone forever, unless you write a good amount of boilerplate code to add it back.
For the record I really enjoy your blog and I hope you keep putting out great content. I'm not trying to critique any one person. I wasn't advocating for Elixir in lambda (Although if it was an option I would probably use it). Elixir and OTP pretty much negate the benefits of lambda. It was brought up and an AWS employee on the serverless team had a perception of elixir I didn't like. I don't want that perception to propagate and put off potential newcomers. Obviously, they have an incentive to keep people on their platform. Selling elixir can be pretty hard. At least where I live. I believe getting some content out around the "basics" would help. Of course languages like java, node, and python and a huge head start. Just as a suggestion for content I'd like to see, I would like to see more basic to the point content. Like I stated "Automate the Boring Stuff - Elixir Edition" would be pretty a pretty valuable resource. Regardless, Elixir and the libraries tend to have great documentation and I look forward to fresh content coming out daily. 
I honestly read the article 3 times and couldn't extract something interesting and/or useful :/
Sure, why not. I've been doing elixir professionally for two years now -- why did you start learning elixir and what are you trying to get from if?
The book is a good start, but I mean, metaprogramming is a good topic I am interested the OP could write about.
I started learning elixir because I was interest in a job opportunity that used it. I ended up not taking the job, but I loved elixir and have kept learning. I want to become familiar enough with it that I'd be confident in using it for more than just side projects. 
Still typing away at my sci-fi mmo. I do have a playable build that people can try out if they're interested. https://s3.amazonaws.com/plex-dev-builds/plexdev.apk It's still very much an alpha but feel free to leave comments here or in a PM.
You should check out the elixir forum, great community and a lot of helpful people (my handle: hlx)
Telephony use erlang and have a downtime equal to 32ms per year. I decided to learn some erlang stuff but it sound like a really hard language because of the syntax. So I move to elixir and then I discover a really amazing language that use some amazing feature that help you to think differently (eg. Pattern matching, functionnal programming, meta programming ...). 
Be specific what would be the bare minimum product features and how much would you pay for it?
I don't think he wanted to commission one, but was wondering that given the high overlap of elixir/Erlang selling points and needs for these API gateways how come nothing had already been written for this market. I'm also pretty sure that its for this exact reason that most elixir/Erlang people don't encounter the issues that need an API gateway in the first place and so don't feel the pain points that cause their introduction.
I don't think a generic proxy exists today as a product, but you can certainly build one. You can use [Terraform](https://github.com/poteto/terraform) to do this in a Phoenix app. You can also use [Absynthe](https://absinthe-graphql.org/) to do this using GraphQL as the front end interface. It's useful as a way of making existing apps more reliable. I cover that in [this talk](https://www.cogini.com/blog/presentation-incrementally-migrating-large-rails-apps-to-phoenix/).
I'd be happy to review code. I don't have as much stuff available to review in return, but, I mentor frequently and have done Elixir at a previous company. So, can certainly give my fair share of opinions. :) 
Awesome. Yeah, I'm also looking forward to (and curious about) the Mix improvements. The basic idea that it pretty much always makes sense to defer config to runtime is why I made [DeferredConfig](https://hexdocs.pm/deferred_config/readme.html). Or, rather, to defer the filling of patterns like system tuples, or mfa tuples, to runtime; makes it easy to test a prod binary artifact on a dev's machine by just tweaking ENV vars, make it Mix-agnostic, etc. I feel like 'app env as a way to configure runtime behavior dynamically during the lifetime of the service' isn't such an important use case -- we have ets and many other options available as sources of truth/ways of changing or polling for the current 'settings' for a running service; app env is a poor/limited API by comparison. It's suited to values that are known at compile-time, even if they're not fully evaluated until later.
Threatened? Why?
Well I get that Elixir is further ahead in development than this one, but its a decentralized crowdfunding platform built on Ethereum... sound familiar? 
One of us is confused. Elixir is a programming language that as far as I know has little to nothing to do with the crypto currency scene. Is there an elixir coin or crowdfunding platform you‚Äôre referencing?
Well the main reasons I can see for using a API gateway is for fronting applications that don't handle concurrent requests well, that don't offer high availability, handling versioning differences, etc.
I was so confused
Really liked this article. I've been feeling much the same regarding configs. Although what turned me off was not just poor runtime configurability, though that was a contributing factor. My other issue came about from how I was designing my system, I opted for building microservices as separate projects (rather than a single umbrella), so this led to development and test environments having to keep duplicating the copy of all of the configs from the other services. Which overtime started to become very annoying. I've experimented with some ways of tackling that issue, some brought about other issues. I eventually settled on something that solved some of the issues but was still less than perfect. But I like some of the ways you mentioned solving the problem, so will probably be revisiting this once again in my projects haha. 
That's awesome. Sometimes I just need some opinions. If you're on the elixir slack, DM me your handle
Accenture built something along those lines: https://accenture.github.io/blog/2017/11/09/introducing-rig.html 
Platformatec's blog posts a lot of stuff on elixir. Not sure how to filter it for language (en and pt) or on Elixir tags.
I've been working on a free/libre video surveillance system written in Elixir/Phoenix with a mostly react frontend. I'm hoping to distinguish my system by offering very high performance through hardware acceleration of video decoding on various platforms, including the raspberry pi. And also transparent reliability, in the sense that it recovers from errors and tells you when something is wrong that it can't recover from. For example, if your disk is full or if the system can't write the disk fast enough, it will give you a precise, actionable error. Once I get a few more pieces in place I want to implement video analysis by feeding frames to machine learning based object detection systems running in a port. Focusing first on tightly constrained problems with real utility: Is there a package on my porch? Is there a car in my garage?, etc. Elixir has been a joy to use so far. The main hangups have been with documentation, especially supervisors. I couldn't figure out how to use the new DynamicSupervisor with phoenix. Oh well I'll keep using :simple_one_for_one until I can't :)
We have feeds of our blog: * https://www.cogini.com/feeds/atom.xml * https://www.cogini.com/feeds/rss.xml It's a bit eclectic, covering development, devops and startup product design, so you might prefer to select by category: * https://www.cogini.com/feeds/category-development.atom.xml * https://www.cogini.com/feeds/category-development.rss.xml or by tag: * https://www.cogini.com/feeds/tag-elixir.atom.xml * https://www.cogini.com/feeds/tag-elixir.rss.xml
There is Sa≈°a Juriƒá‚Äôs site: http://www.theerlangelist.com/rss
We're replacing our dynamic SQL query engine written in ruby and replacing it with our new QueryEx package. We're also planning on porting over our security layer called Securables to elixir in the next few weeks. I expect us to be running this in production in about two months. https://github.com/markglenn/queryex Basically, this allows you to build an API for a SQL database that includes side loading data, automatic joining of tables, and your basic filtering and sorting. We've been using our Ruby version in production successfully for the past 5 years, but it's hard to keep it running fast due to the speed of ActiveRecord.
I run my local Python on Bike Lanes meetup.
The question is not about api behind the gateway. It‚Äôs about the gateway itself. There no api gateway that work like a proxy ( but with more features ) that use the Erlang machine :/
Wow it seem awesome. if I understand the client subscribe to some event and does not consume directly the data. I mean, basically in API world people use http verb with parameters to obtains / create data from/to an endpoint. Here it‚Äôs like the client just ask to get notify if an event occurs. If it‚Äôs been like a think it can be amazing!
I think it's quite a good use case for Elixir, especially when the back ends are less reliable or able to handle load. We also get to write code in Elixir that runs in the proxy instead of lower level languages or snippets of lua. I am not sure if the requirements are generic enough to make it a standalone product like HAProxy as opposed to a collection of plugs to handle different requirements. 
Would [this](https://github.com/Nebo15/annon.api) be the kind of thing you're talking about?
Yes i think, I gonna check and maybe participate thanks a lot!!!
Launched my first elixir project the other week so I‚Äôm working on refactoring it. It‚Äôs a sweary travel guide called [What the fuck should I do in?](https://whatthefuckshouldido.in/). It‚Äôs not too complex as it saves a bunch of results from foursquare locally and then randomly picks one, but for some reason some foursquare queries only return a few results, whilst others return &gt; 90. I‚Äôm also working on my second project, which uses public data about politicians. Turns out there‚Äôs a lot of politicians in the world, so it takes more than an hour to seed the database. I tried using tasks to parallelise it but it didn‚Äôt seem to work, so I might take a look at that soon too. 
Cool article! I'm inspired to finally give Credo a try.
I'm working on some imaging bindings for libvips and opencv.
I had been using Erlang (so already loved the Erlang VM) and I heard about this new language being developed on top of the VM. Checked it out, it was still early in development but it had taken shape where it had features I wish Erlang had. Some of these things were things like the powerful macro capabilities (as opposed to Erlang's simple C-like preprocessor), the build system, etc. 
Why are you trying to use DynamicSupervisor with phoenix? You can split your functionality with Phoenix being only your web ‚Äúfrontend‚Äù (the frontend of the backend). This way you can call any function from your Phoenix controller.
Sounds really cool. Maybe in the future it can be expanded to more sources other than Foursquare. It is pretty much dead in my country :(
What services is more used where you are?
Thanks for the reply and given what I wrote it definitely makes sense. My application is actually split between a backend and a phoenix frontend so what I said was wrong. What I meant is I couldn't figure out how in my application.ex to start a DynamicSupervisor. Looking at it now I guess I'm still using the deprecated Supervisor.Spec module.
There is no default. Apparently people gave up contributing to platforms like that one on Mexico
What about Yelp?
Alchemist camp on YouTube
Just now saw your comment here. I narrowed that problem down to an interaction between the referral marketing service I've been using and certain JS ad\-blockers people have been using. I believe, based on the logs, that you did create an account and should be able to log in with the creds you provide.
I have four years or so of anonymous Elixir experience but with a nomadic schedule so wouldn‚Äôt be able to commit to much but would extend a private offer if you PM me we can trade emails and even text/phone if needed.
Hey, welcome to the community! Hit me up with a PM if you ever want someone to kinda just chat with or pair with.
On mobile so no way to test your code but take a look at Ecto.Multi. https://hexdocs.pm/ecto/Ecto.Multi.html
Test with benchee. Parallelize it, not sure if a 296 ms average is bad or not for ecto, but you are running them serially. 
I realize Im doing it sequentially, and that wasn't ms it was seconds as in like 5 minutes. Incredibly slow, this is not really a parallelization issue just yet.
Just to be clear and isolate the db have you ran it with creating the user maps and everything else except the changeset and insert?
...296 ms _average_...
How are you generating the password? If you're using bcrypt make sure it's 0 pass so it's really fast.
I dug into coherence's password generation and it seems you may be on the money there
Yep there you go
I do live coding on Twitch three times a week. You can find the channel here: https://twitch.tv/joebew42. What I do there: try to contribute to existing elixir open source projects, build new playground projects, learn something new about elixir, practice Clean code, TDD and Refactoring :D
Yes. I don't use it now but just reading 200 pages of a beginner book opens your eyes in some kind of way. I was programming js, c, python before. Genserver, supervisors, and the process spawning stuff is just cool. 
Highly recommended! Joe's stream gave me the motivation to keep learning Elixir. Now I have some Elixir related works on my side-hustle! Thanks, Joe!
The deal itself may be moot, but I agree with the poster‚Äôs assessment that Phoenix is a ready replacement for RoR/Node.
Consider opening a bug report on coherence because they should instruct users to set the pass to 0 by default in the test environment.
Ive found this to be more true of Erlang. Although Elixir / Erlang are effectively the same language.. the emphasis with more of the Erlang learning resources is more about a different way of programming, specifically focused on error handling and robustness. The emphasis with more of the Elixir learning resources are more about how it can be a replacement for, say, Ruby, but with multi-threading for free. This is just what i felt when reading Elixir / Erlang books, and it's not to say that the Elixir books don't cover the same stuff as the Erlang books, they do and they are very good.
Yeah I opened a feature request
It's really great to have state so separated from logic. Even when I try to do it in different languages things tend to be hard because most libraries are not built with that style of programming in mind.
My path was: - Syntax - Data structures - FP (use pattern matching, etc...) - How to architect the project (files, modules are not classes, etc...) - Grabbed an OTP Erlang book. (Beautiful syntax, somewhat annoying) - Read code and try to contribute Good luck
Upload your code to github and dm me for feedback. I‚Äôm more than happy to help.
I recommend reading the [Getting Started](https://elixir-lang.org/getting-started/introduction.html) guide. It's fairly short and lays out the features pretty well.
It helped really understand concurrency and race conditions in other languages that share memory. 
actually, learning any language brings new insights to your "main" language. After learning elixir I've really looked in some parts of JS I never thought of before, also python is good to learn for nicer naming and overall aesthetic part of your code. 
It is an elegant language, that and I tend to write complex web applications that incorporate different microservices for things like machine learning classifiers or job queues or for my latest project I'm looking to build out a microservice for syntatic correctness checking for different programming languages and between elixir's decent FFI, OTP + the languages first class idea of umbrella apps AND being compiled so its much quicker than ruby and I am a happy guy.
Macros are amazing and I don't know how I'm going to go back to languages that don't have them. There are things you can do with them that you cannot do in other languages without crazy duplication. Take a look at `kernel.ex` if you get a chance and look at ALL the language features you can implement with them. When you get to sufficiently large code bases, they create abstractions that allow you to DSL over the wiring and create very expressive solutions to your problems. 
There is a focus on reliability. Ruby programmers are all like, "look at this new DSL I have for making HTTP requests." Elixir programmers are like, "cool, what if it times out?".
Cheap and easy processes mean that you can model the natural concurrency of your application. You get a request, handle it, give a response back. Or you model a chat system with one process per connected user, and one process for the chat room. The code is simple. In other languages, you have to deal explicitly with non-blocking I/O, thread pools, synchronization.
Is there an archive somewhere? Twitch seems to only have the three most recent videos?
If you‚Äôre doing this, also use the param option on the resource function to specify a better key for your slug parameter (i.e. name in this case).
Hi, unfortunately Twitch keeps only recent videos! I am thinking to export videos on YouTube and create a sort of permanent archive there.
Elixir has some amazing properties. But for me, unfortunately I gave up on it. The main reason - it has lower productivity than Ruby / Rails or JS / Node, more verbose and more complicated. It's true that Elixir is way better than Node.js - but the thing is for most apps what we need is cheap and fast development, as for robustness and great performance and stability - those are not so important. 
I'd find that interesting! I was looking for your videos about building the chat service, but couldn't find them.
I haven‚Äôt dug too far in Elixir but it isn‚Äôt as hardcore as Haskell. Haskell is more an academic language. It is good to learn (especialy learn you a Haskell book/site) because you go through relearning how to manage state and to make pure functions, how to avoid side effects, and write good functional code, then you get to monads and realize reaity is not that clean. Those concepts are what carry over to stuff like jnderstanding state. Haskell is also huge on recursion. I‚Äôd imagine you could put all of the same concepts to use in Elixir. Haskell and the accompanying book (learnyouahaskell.com) are good to see the ideal way of doing FP, but Elixir should give you more in the way of practical applications. Elixir also has a easier to follow syntax coming from OOP especially Ruby. Elixir is definitely not just Ruby plus FP tacked on (Python more fits that) due to the underlying language.
pattern matching makes me love love love elixir. It's just ridiculous how awesome it is and how I lived without it. Now when I program in languages without it, i miss it a lot. 
I wouldn't use any of those libraries. I would use comeonin and bcrypt to hash passwords and verify authentication credentials manually. It's not complicated at all and you will know *exactly* how your system works. For auth, just create a simple permission module. Say you have a Listing module and db table `listings`. Create a ListingAuthorization module to check if `can_view?/2` or `can_edit?/2` and pass in your resource and your user, to return true or false. Don't fall into the rails habit of reaching for libs for every little thing. You may not need it.
https://medium.com/@jpiepkow/accesspass-yet-another-elixir-authentication-library-7ea59734a49 Disclosure I made it and it is still slightly black box when it comes to the schema but there are some issues open on the repo I plan to get to and change that. It is slightly based off addict but with some changes I made in order to not be locked into addicts view. There is a ton of info on hex about it as well.
Thanks everyone. I appreciate the help and offers. I'm gonna try to delve deep after the weekend. 
That dude. Whooooh. Crazy. 
You mean like this? [http://nithinbekal.com/posts/phoenix\-authentication/](http://nithinbekal.com/posts/phoenix-authentication/)
Hi, you are right, I'm thinking to export all my videos on YouTube in the future. If you are interested in the chat, you will find the code on github: https://github.com/joebew42/ex_chat BTW, in one of the next episodes I will continue to work on this project ;)
Agreed that it isn't complicated, but I am curious if anyone else develops in Windows and has to manually run vcvarsall.bat amd64 and then compile Bcrypt from the same shell, every time. There has to be some alternative to writing/running a simple script.
This is helpful, thanks for sharing.
I think this entirely depends on who's teaching Elixir. Reading Sa≈°a Juriƒá's [Elixir in Action](https://www.manning.com/books/elixir-in-action-second-edition) was a revelation to me. If someone is teaching Elixir / Phoenix as if it were a more performant RoR, I think they are missing the point.
I am in that course on Udemy and it is a bit outdated. The instructor says he is going to update it soon. 
Glad to help! It was super confusing for me at first and I spent a ton of hours writing this, so I'm glad it was useful
It is literally the best article I have read on Phoenix contexts, great job!
Thank you, that means a lot!
Wrong sub 
Because it says Blockchain?
oh yup. my b. someone posted about elixir token last week or so. 
Hey, joebew42. Do you use OBS? I use it to record my screencasts and it also has broadcasting functionality. It might be a good solution if you want to do both. I'm considering it myself actually due to some people on IH suggesting I try Twitch.
Hey alchemist! Yes, I am using OBS and I am very happy with it! Thank you for your suggestion, I never tried the "collections", I will give it a look just to learn something more about this world :)
I find in elixir I transition from ! Methods to ok tuples over time (prototyping with !, deploying with tuples after writing unit tests). Also the with clause is simply amazing for making coding the happy path work well with error handling and robustness.
Oh, hey -- this looks awesome. It resonates because I spent the better part of last year dealing mostly with the client side of the flow you use as an example :) for an android/ios travel + day-of-travel app. And so I've also got the JS-land 'sagas' stuff in mind to compare with. The systems our app integrated with were so painful that now we're talking over inserting our own server-side layer between the user and the crufty backends we talk to. So this sort of "retry" and "save-point" logic in Elixir has been kicking around in my head for a while, and it's a good time to run across this.
Yeah, that looks like a pretty good guide. I'd also recommend making yourself a simple plug that checks if the user is authenticated and adds their info to conn.assigns rather than having to use that current_user() fn everywhere. Something like this: https://gist.code.espn.com/falksonu/fcbb16569641351eca096acbf5e69bb8
What's the name of the UML program you're using?
I used Draw.io which is pretty great!
I'm not sure what OBS is. But i'll look into it. So this would give an option to share a screen while live coding?
Coming from Scala with its lean towards immutability, pattern matching and the Actor model, maybe not much. Coming from Python and JS, you should grow a fair amount (and actually have an easier time with something like Haskell in the future as well).
This sub
I think Allan Kay would be pleased at where you're headed. 
In order to learn Elixir I set myself a task: build a server (and later a client) for a network protocol that I am also currently developing. The protocol is basicly modified variant of MQTT with some added functionlity but not as general or verbose as AMQP. I know about RabbitMQ etc. etc. but I wanted to learn Elixir so decided that it is a good task. Another benefit is that it may also benefit my day-job someday. Server can be found [here](https://gitlab.com/Shakti213/lighttel-server) and some shared modules that is intended to be shared by both server and client are [here](https://gitlab.com/Shakti213/lighttel). 
Hey, Shakti213, just a quick heads-up: **basicly** is actually spelled **basically**. You can remember it by **ends with -ally**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Feel bad, I'm student but with a @student.42.fr :c
It's an ebook. You can probably find it for free in a couple of days time.
If you had a real use case for `with` in your test you could also add an `else` case with `flunk`.
If you are really lacking funds I will buy you a copy 
darn already own it, great book though.
Thanks mate, someone gave me a copy of the ebook :)
&gt; If you have a pragprog.com account with a valid email address ending in .edu Just wonderful... At least have the honesty to say it's for American students. 
RTFA before whining &gt; In addition to .edu in the US, the offer is valid for the following other educational domains: rug.nl, th-koeln.de, post.au.dk, iesdonana.org, .edu.cn, .ac.uk, .edu.br, .edu.au, uwo.ca, .education.nsw.gov.au, uanl.mx, edu.pl, usp.br, .ac.jp, .ac.nz
Still not all available for free to academic students in general. 
That's probably a common theme in your life seeing how you are retarded 
Kys
Very true. Though I'm having a hard time imagining when I'd use `with` in tests rather than plain old assignments.
No problem. If you really like the book, Dave has a really good online course as well. https://codestool.coding-gnome.com/courses/elixir-for-programmers 
Yup. Both universities I attended used .ca for their email domains
Thanks for reading. You're right, I didn't address how \`gen\_event\` behaves when installed handlers have errors. If I want some piece of event handling logic to be supervised, I usually install a handler that forwards a message to a registered process under supervision. My main point was ultimately that I think \`gen\_event\`'s model of executing handlers sequentially within a single process is a more flexible default behavior than the behavior of the various proposed replacements.
Yes, there are known solutions to "restarting" installed handlers but it is not always straightforward and even the fact that extra work is required catches a lot of people by surprise. So it is a bit dangerous to push people towards `gen_event` and not discuss its number one pitfall. I don't dispute there are cases `gen_event` is well suited but they are not as frequent as one would expect. Concurrent handling should be preferred. If you are certain that you don't need sequential handling, there is no reason to use `gen_event`. As a matter of fact, if there is a `gen_event` and I want to install a concurrent handler, I would need to: 1. to implement the handler that forwards the messages 2. to implement a "watcher" that needs to act in case of three different failure scenarios: a. the gen_event server itself crashes b. the handler you installed crashes c. the process I am forwarding messages to fails 3. implement the code that handles the forwarded messages On the other hand, if I need to integrate with a dispatch mechanism built on top of a supervisor (or even better, on top of a process registry), all I need to implement is a simple process/GenServer. I find the reasoning of making concurrent code harder to write because of the one off chance you may need sequential execution to be a bit backwards. 
While I understand your frustration, I don't think this is a helpful feedback either. What could be improved? What is missing? Put yourself in the author shoes.
&gt; So it is a bit dangerous to push people towards `gen_event` and not discuss its number one pitfall. Fair! I will write an update to my post warning people about how `gen_event` behaves in the presence of errors. As per point 2, I haven't thought deeply about it, but I'm not certain a "watcher" process is required: a. I usually put `gen_event` processes pretty early in the initialization sequence for `rest_for_one` supervisors, so my bases are usually covered for this. Various processes that are started later in the initialization sequence can install whatever handlers they like to the `gen_event`, and I can be sure that they will be added to a new `gen_event` after a crash. If a process that adds a handler during initialization crashes, then there's nothing to do if messages are forwarded using calls, as the old handler will throw an exception and be removed silently (yikes.) b. If your handler forwards messages with raw sends, it will not crash. If your handler casts to a `gen_server`, it will not crash either. If it calls to a `gen_server` that does not exist, an exception will be thrown, and the handler will be removed, which I suspect is what one wants anyway. c. If you do a call to a `gen_server` that doesn't exist, then an exception will be thrown and the handler will be removed. If you do casts/raw sends, then the process that receives the forwarded messages, which should probably be responsible for adding its forwarding handler in the first place, should check the installed handlers and conditionally use `gen_event:swap_handler/3`. instead of `add_handler/3`. d. Usually when I use `gen_event`, the supervisor that starts the process acts as the watcher. In these cases, the supervisor's supervisor is responsible for restarting. You're not the first to state that sequential execution of handlers is an unlikely use-case for event handling. I expect that my opinion will change over time, but right now I prefer defaults that are flexible over defaults that sacrifice flexibility for the sake of the more common use-case(s). As I mention in my post, I'm happy that `gen_event` exists as a part of OTP, mainly because it has let me build and ship software quickly. I'm certain that there will come a day when I will need something different to manage event handling, but it hasn't happened yet, and in the meantime I've gotten software projects off the ground faster thanks to `gen_event` and the pattern of installing handlers that use calls to forward events to interested `gen_*` processes. Thank you for taking the time to write a reply. It's really nice to hear different perspectives.
The [official guide](https://hexdocs.pm/phoenix/overview.html) is quite good.
Excellent. You have thought about all of the cases and scenarios, but it is actually very hard for somebody to put all of these pieces together when they first use a `gen_event`, even for experienced developers. For example, your solution for a) doesn't work if the `gen_event`was started in another tree, as we see when integrating with a third party supervisor such as `error_logger` and `sasl`. b) can only be simplified if you don't care about losing messages, but if you do, then you need to handle it. Etc. So overall there are just so many different ways it can fail that it is hard to put it all together. My suggestion would be to find less error prone ways to make this work. For example, if you are interested in sequential execution, then you can simply perform sequential calls using a GenServer + Supervisor. If you want to have sequential calls and avoid the cost of copying of messages, then an ETS table and MFAs can be a good alternative (which is how the new logger in Erlang/OTP 21 works), etc.
There is an entire book about phoenix framework. https://pragprog.com/book/phoenix/programming-phoenix
+1 for this book. It was extremely helpful for me, somebody that had almost no experience working with web stacks. I do recommend looking into the `1.4` version of the book though (which is currently in beta), since the changes made in phoenix 1.3 have a noticeable impact on how you structure your app.
Cool. Thanks!
I don‚Äôt think I‚Äôd say Option #2 (NodeJS Backend) would be as over-engineered as you‚Äôd think. Take a look at this library I wrote for building a React rendering server on the NodeJS side ([Isorender](https://github.com/chancedickson/isorender-node)). This library has both a client and a server for NodeJS, so you‚Äôd have to write a client for Elixir, however if you use Ports and design your server to communicate with stdin/out, it turns out to be a pretty barebones client, just a GenServer that serializing maps into JSON, sends them over the port, waits for a response, unserializes it and then sends it back to the initial request pid. I like this model for working with an external rendering server, however I may be biased since I wrote a small library for doing so. :)
Thanks, it looks more simple than I thought, I'll check it out. Still not a drop in solution that *just works***‚Ñ¢** like react\_on\_rails, but maybe keeping a node server for rendering is not so bad after all. Another advantage is that I think I could implement everything as client\-side and add SSR at the end, without having to refactor much.
[removed]
Oh yeah, it‚Äôs certainly not drop-in. I think my Elixir client implementation (that I really need to open-source) is about 100 LoC for the Elixir client and about 150 LoC for the Node server. After thinking about the issue, I remembered that the reason I did not release the Elixir client for the Isorender server was because using Elixir Ports and communicating via stdin/out makes it _super_ easy to scale the rendering server horizontally if it becomes a bottleneck. Since the NodeJS processes can be wrapped in a GenServer using Ports, you can spin up as many of the GenServers you need and send requests to them in round-robin or some other load balancing fashion (but that may be a little over-engineered if you don‚Äôt necessarily need it). It also makes it a lot easier to start up your Elixir server since instead of starting the NodeJS server then starting the Elixir server, you just start the Elixir server and it starts up the rendering server(s) for you in a managed way.
I have been trying to learn elixir since quite some time. The one thing i wanted to get a hang of was otp. You only really get it once you build something in it and then the fun starts. As a result, I tried to build a redis clone in elixir that relies heavily on genservers , supervisors, registry. The otp tutorial on official site was helpful as well since it already has something like this. I've implemented some commands and the project is in no way complete. So I thought maybe I could get some helping hands and we could build something good . what say ? 
Glad you‚Äôre enjoying elixir and OTP. Out of curiosity, why did you want to continue to build on this project instead of building out [redix](https://github.com/whatyouhide/redix)?
You're confused: this isn't a Redis client, this is a Redis *server*.
You‚Äôll want to follow this: https://elixirschool.com/en/lessons/advanced/escripts/ You‚Äôll still need to make a elixir module to even if you are writing a single escript. 
I see. Thanks for that explanation. I hadn‚Äôt dig into OP‚Äôs code, yet. But glad there‚Äôs also an existing implementation for this. I‚Äôm always for 1 paradigm over 50 (*cough* JavaScript *cough*) and a tight community.
This is dope. I'm just starting out with Elixir and, after going through a few books, have been looking for *read\-world minimalist* examples. Thanks for sharing.
If you want to just save it as an \`.exs\` you can perfectly do it, if you want the script functionality you can use escript as /u/dj_goku mentioned. You can still use dependencies and yes, you'll need a http client library just like a normal module.
so would it be better to just do a "mix new ..." then mix deps.get in the project, then create a script file within the project? Would this be the preferred method rather than creating a stand alone script? I guess the dependencies would all be published with the project this way? 
You might be able to use the http client included with OTP. https://virviil.github.io/2018/04/06/elixir-do-you-have-http-requests-you-are-doing-them-wrong/ has some examples and comparisons between the major options. 
As a fellow Rails / Phoenix developer I am biased towards Turbolinks. I really do think server side templates, Turbolinks and sprinkling in a little extra JS where needed is a combo that works wonderfully for most web apps. With that said, I'm using Turbolinks now with a Phoenix app (I'm learning as I go too) and it's working really well. Sounds like you want to go React either way but I just wanted to say you can make blazing fast sites with Turbolinks outside of Rails and have it all work out.
I'm glad you brought up your bias. I've only worked at a few places and they've all used full JavaScript frontend's. As I've been learning elixir, I've been questioning why we don't server side render and sprinkle JavaScript where it's needed. I was wondering if I was the only one thinking this. I'm going to try out turbolinks, thanks!
I'm liking that path more and more, but got so used to React for UI that I don't feel like going back. Maybe with enough BEM and a nice file structure I can still reason about my UI with "components", and include those in templates. I'll have to do some experimentation.
No problem, you're definitely not alone. I go a bit deeper into why I prefer this style on my site at https://nickjanetakis.com/blog/server-side-templates-vs-rest-api-and-javascript-front-end. 
There are two use cases for embedded schemas: 1. as the same suggests, embedding a schema inside another schema. These are persisted as JSONB columns in postgres. 2. as a struct with 'typed' fields, supporting casting and validation with `Ecto.Changeset`. You can use these to validate API params, or any other data coming from an external source. 
I've used them for the 2nd use case. It happens quite often that a user-facing resource doesn't map exactly to your backend structure. That's a good place for an embedded schema I think. For instance one could use an embedded schema called `Registration` for signup forms. After validation, this then maps to a `users` and a `credentials` table in the backend.
Thanks! So embedded schemas don't map to the database unless explicitly done so?
Pretty much. Here's two good resources on the matter (which I have referred to extensively in the past): https://medium.com/@abitdodgy/building-many-to-many-associations-with-embedded-schemas-in-ecto-and-phoenix-e420abc4c6ea http://blog.plataformatec.com.br/2016/05/ectos-insert_all-and-schemaless-queries/ Hope these help!